id,quality_attribute,keyword,matched_word,match_idx,sentence,source,filename,author,repo,version,wiki,url
https://psicode.org/psi4manual/4.0b5/_modules/proc.html:18280,Performance,load,load,18280,"CF', 'SCF_TYPE') == 'DF':; castdf = True; else:; castdf = False. if psi4.has_option_changed('SCF', 'DF_BASIS_GUESS'):; castdf = psi4.get_option('SCF', 'DF_BASIS_GUESS'); if yes.match(str(castdf)):; castdf = True; elif no.match(str(castdf)):; castdf = False. # sort out broken_symmetry settings.; if 'brokensymmetry' in kwargs:; molecule = psi4.get_active_molecule(); multp = molecule.multiplicity(); if multp != 1:; raise ValidationError('Broken symmetry is only for singlets.'); if psi4.get_option('SCF','REFERENCE') != 'UHF' and psi4.get_option('SCF','REFERENCE') != 'UKS':; raise ValidationError('You must specify ""set reference uhf"" to use broken symmetry.'); do_broken = True; else:; do_broken = False. precallback = None; if 'precallback' in kwargs:; precallback = kwargs.pop('precallback'). postcallback = None; if 'postcallback' in kwargs:; postcallback = kwargs.pop('postcallback'). # Hack to ensure cartesian or pure are used throughout; # Note that can't query PUREAM option directly, as it only; # reflects user changes to value, so load basis and; # read effective PUREAM setting off of it; psi4.set_global_option('BASIS', psi4.get_global_option('BASIS')); psi4.set_global_option('PUREAM', psi4.MintsHelper().basisset().has_puream()). # broken set-up; if do_broken:; molecule.set_multiplicity(3); psi4.print_out('\n'); p4util.banner(' Computing high-spin triplet guess '); psi4.print_out('\n'). # cast set-up; if (cast):. if yes.match(str(cast)):; guessbasis = '3-21G'; else:; guessbasis = cast. if (castdf):; if yes.match(str(castdf)):; guessbasisdf = p4util.corresponding_jkfit(guessbasis); else:; guessbasisdf = castdf. # Switch to the guess namespace; namespace = psi4.IO.get_default_namespace(); psi4.IO.set_default_namespace((namespace + '.guess')). # Setup initial SCF; psi4.set_global_option('BASIS', guessbasis); if (castdf):; psi4.set_local_option('SCF', 'SCF_TYPE', 'DF'); psi4.set_local_option('SCF', 'DF_INTS_IO', 'none'); psi4.set_global_option('DF_BASIS_SCF', guessbasisdf",MatchSource.WIKI,psi4manual/4.0b5/_modules/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/proc.html
https://psicode.org/psi4manual/4.0b5/_modules/proc.html:19417,Performance,Perform,Perform,19417,"i4.set_global_option('PUREAM', psi4.MintsHelper().basisset().has_puream()). # broken set-up; if do_broken:; molecule.set_multiplicity(3); psi4.print_out('\n'); p4util.banner(' Computing high-spin triplet guess '); psi4.print_out('\n'). # cast set-up; if (cast):. if yes.match(str(cast)):; guessbasis = '3-21G'; else:; guessbasis = cast. if (castdf):; if yes.match(str(castdf)):; guessbasisdf = p4util.corresponding_jkfit(guessbasis); else:; guessbasisdf = castdf. # Switch to the guess namespace; namespace = psi4.IO.get_default_namespace(); psi4.IO.set_default_namespace((namespace + '.guess')). # Setup initial SCF; psi4.set_global_option('BASIS', guessbasis); if (castdf):; psi4.set_local_option('SCF', 'SCF_TYPE', 'DF'); psi4.set_local_option('SCF', 'DF_INTS_IO', 'none'); psi4.set_global_option('DF_BASIS_SCF', guessbasisdf). # Print some info about the guess; psi4.print_out('\n'); p4util.banner('Guess SCF, %s Basis' % (guessbasis)); psi4.print_out('\n'). # the FIRST scf call; if cast or do_broken:; # Perform the guess scf; psi4.scf(). # broken clean-up; if do_broken:; molecule.set_multiplicity(1); psi4.set_local_option('SCF', 'GUESS', 'READ'); psi4.print_out('\n'); p4util.banner(' Computing broken symmetry solution from high-spin triplet guess '); psi4.print_out('\n'). # cast clean-up; if (cast):. # Move files to proper namespace; psi4.IO.change_file_namespace(180, (namespace + '.guess'), namespace); psi4.IO.set_default_namespace(namespace). # Set to read and project, and reset bases to final ones; optstash2.restore(); psi4.set_local_option('SCF', 'GUESS', 'READ'). # Print the banner for the standard operation; psi4.print_out('\n'); p4util.banner(name.upper()); psi4.print_out('\n'). # the SECOND scf call; e_scf = psi4.scf(precallback, postcallback). optstash.restore(); return e_scf. [docs]def run_mp2_select(name, **kwargs):; """"""Function selecting the algorithm for a MP2 energy call; and directing toward the OCC (conv MP2) or the DFMP2 modules. """"""; if (psi4.get_option(""DF",MatchSource.WIKI,psi4manual/4.0b5/_modules/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/proc.html
https://psicode.org/psi4manual/4.0b5/_modules/proc.html:46667,Performance,LOAD,LOAD,46667,"'monomerA'); monomerB = molecule.extract_subsets(2, 1); monomerB.set_name('monomerB'). # if the df_basis_mp2 basis is not set, pick a sensible one.; if psi4.get_global_option('DF_BASIS_MP2') == '':; ribasis = p4util.corresponding_rifit(psi4.get_global_option('BASIS')); if ribasis:; psi4.set_global_option('DF_BASIS_MP2', ribasis); psi4.print_out(' No DF_BASIS_MP2 auxiliary basis selected, defaulting to %s\n' % (ribasis)); else:; raise ValidationError('Keyword DF_BASIS_MP2 is required.'). ri = psi4.get_option('SCF', 'SCF_TYPE'); df_ints_io = psi4.get_option('SCF', 'DF_INTS_IO'); # inquire if above at all applies to dfmp2. psi4.IO.set_default_namespace('dimer'); psi4.set_local_option('SCF', 'SAPT', '2-dimer'); psi4.print_out('\n'); p4util.banner('Dimer HF'); psi4.print_out('\n'); psi4.set_global_option('DF_INTS_IO', 'SAVE'); e_dimer = scf_helper('RHF', **kwargs); psi4.print_out('\n'); p4util.banner('Dimer DFMP2'); psi4.print_out('\n'); e_dimer_mp2 = psi4.dfmp2(); psi4.set_global_option('DF_INTS_IO', 'LOAD'). activate(monomerA); if (ri == 'DF'):; psi4.IO.change_file_namespace(97, 'dimer', 'monomerA'); psi4.IO.set_default_namespace('monomerA'); psi4.set_local_option('SCF', 'SAPT', '2-monomer_A'); psi4.print_out('\n'); p4util.banner('Monomer A HF'); psi4.print_out('\n'); e_monomerA = scf_helper('RHF', **kwargs); psi4.print_out('\n'); p4util.banner('Monomer A DFMP2'); psi4.print_out('\n'); e_monomerA_mp2 = psi4.dfmp2(). activate(monomerB); if (ri == 'DF'):; psi4.IO.change_file_namespace(97, 'monomerA', 'monomerB'); psi4.IO.set_default_namespace('monomerB'); psi4.set_local_option('SCF', 'SAPT', '2-monomer_B'); psi4.print_out('\n'); p4util.banner('Monomer B HF'); psi4.print_out('\n'); e_monomerB = scf_helper('RHF', **kwargs); psi4.print_out('\n'); p4util.banner('Monomer B DFMP2'); psi4.print_out('\n'); e_monomerB_mp2 = psi4.dfmp2(); psi4.set_global_option('DF_INTS_IO', df_ints_io). psi4.IO.change_file_namespace(p4const.PSIF_SAPT_MONOMERA, 'monomerA', 'dimer'); psi4.IO.change",MatchSource.WIKI,psi4manual/4.0b5/_modules/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/proc.html
https://psicode.org/psi4manual/4.0b5/_modules/proc.html:50224,Performance,LOAD,LOAD,50224,")). sapt_basis = 'dimer'; if 'sapt_basis' in kwargs:; sapt_basis = kwargs.pop('sapt_basis'); sapt_basis = sapt_basis.lower(). if (sapt_basis == 'dimer'):; #molecule.update_geometry(); monomerA = molecule.extract_subsets(1, 2); monomerA.set_name('monomerA'); monomerB = molecule.extract_subsets(2, 1); monomerB.set_name('monomerB'); elif (sapt_basis == 'monomer'):; #molecule.update_geometry(); monomerA = molecule.extract_subsets(1); monomerA.set_name('monomerA'); monomerB = molecule.extract_subsets(2); monomerB.set_name('monomerB'). ri = psi4.get_option('SCF', 'SCF_TYPE'); df_ints_io = psi4.get_option('SCF', 'DF_INTS_IO'); # inquire if above at all applies to dfmp2. psi4.IO.set_default_namespace('dimer'); psi4.set_local_option('SCF', 'SAPT', '2-dimer'); psi4.print_out('\n'); p4util.banner('Dimer HF'); psi4.print_out('\n'); if (sapt_basis == 'dimer'):; psi4.set_global_option('DF_INTS_IO', 'SAVE'); e_dimer = scf_helper('RHF', **kwargs); if (sapt_basis == 'dimer'):; psi4.set_global_option('DF_INTS_IO', 'LOAD'). activate(monomerA); if (ri == 'DF' and sapt_basis == 'dimer'):; psi4.IO.change_file_namespace(97, 'dimer', 'monomerA'); psi4.IO.set_default_namespace('monomerA'); psi4.set_local_option('SCF', 'SAPT', '2-monomer_A'); psi4.print_out('\n'); p4util.banner('Monomer A HF'); psi4.print_out('\n'); e_monomerA = scf_helper('RHF', **kwargs). activate(monomerB); if (ri == 'DF' and sapt_basis == 'dimer'):; psi4.IO.change_file_namespace(97, 'monomerA', 'monomerB'); psi4.IO.set_default_namespace('monomerB'); psi4.set_local_option('SCF', 'SAPT', '2-monomer_B'); psi4.print_out('\n'); p4util.banner('Monomer B HF'); psi4.print_out('\n'); e_monomerB = scf_helper('RHF', **kwargs); psi4.set_global_option('DF_INTS_IO', df_ints_io). psi4.IO.change_file_namespace(p4const.PSIF_SAPT_MONOMERA, 'monomerA', 'dimer'); psi4.IO.change_file_namespace(p4const.PSIF_SAPT_MONOMERB, 'monomerB', 'dimer'). activate(molecule); psi4.IO.set_default_namespace('dimer'); psi4.set_local_option('SAPT', 'E_CONVERG",MatchSource.WIKI,psi4manual/4.0b5/_modules/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/proc.html
https://psicode.org/psi4manual/4.0b5/_modules/proc.html:54796,Performance,LOAD,LOAD,54796,"p.\n'). if (psi4.get_option('SCF','REFERENCE') != 'RHF' ):; raise ValidationError('SAPT requires requires \""reference rhf\"".'). nfrag = molecule.nfragments(); if nfrag != 2:; raise ValidationError('SAPT requires active molecule to have 2 fragments, not %s.' % (nfrag)). monomerA = molecule.extract_subsets(1, 2); monomerA.set_name('monomerA'); monomerB = molecule.extract_subsets(2, 1); monomerB.set_name('monomerB'); molecule.update_geometry(); monomerAm = molecule.extract_subsets(1); monomerAm.set_name('monomerAm'); monomerBm = molecule.extract_subsets(2); monomerBm.set_name('monomerBm'). ri = psi4.get_option('SCF', 'SCF_TYPE'); df_ints_io = psi4.get_option('SCF', 'DF_INTS_IO'); # inquire if above at all applies to dfmp2. psi4.IO.set_default_namespace('dimer'); psi4.set_local_option('SCF', 'SAPT', '2-dimer'); psi4.print_out('\n'); p4util.banner('Dimer HF'); psi4.print_out('\n'); psi4.set_global_option('DF_INTS_IO', 'SAVE'); e_dimer = scf_helper('RHF', **kwargs); psi4.set_global_option('DF_INTS_IO', 'LOAD'). activate(monomerA); if (ri == 'DF'):; psi4.IO.change_file_namespace(97, 'dimer', 'monomerA'); psi4.IO.set_default_namespace('monomerA'); psi4.set_local_option('SCF', 'SAPT', '2-monomer_A'); psi4.print_out('\n'); p4util.banner('Monomer A HF (Dimer Basis)'); psi4.print_out('\n'); e_monomerA = scf_helper('RHF', **kwargs). activate(monomerB); if (ri == 'DF'):; psi4.IO.change_file_namespace(97, 'monomerA', 'monomerB'); psi4.IO.set_default_namespace('monomerB'); psi4.set_local_option('SCF', 'SAPT', '2-monomer_B'); psi4.print_out('\n'); p4util.banner('Monomer B HF (Dimer Basis)'); psi4.print_out('\n'); e_monomerB = scf_helper('RHF', **kwargs); psi4.set_global_option('DF_INTS_IO', df_ints_io). activate(monomerAm); psi4.IO.set_default_namespace('monomerAm'); psi4.set_local_option('SCF', 'SAPT', '2-monomer_A'); psi4.print_out('\n'); p4util.banner('Monomer A HF (Monomer Basis)'); psi4.print_out('\n'); e_monomerA = scf_helper('RHF', **kwargs). activate(monomerBm); psi4.IO.set_",MatchSource.WIKI,psi4manual/4.0b5/_modules/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/proc.html
https://psicode.org/psi4manual/4.0b5/_modules/proc.html:60673,Performance,Load,Load,60673,"dationError('level parameter was not provided.'). level = kwargs['level']. # Fullname is the string we need to search for in iface; fullname = level['fullname']. # User can provide 'keep' to the method.; # When provided, do not delete the MRCC scratch directory.; keep = False; if 'keep' in kwargs:; keep = kwargs['keep']. # Save current directory location; current_directory = os.getcwd(). # Need to move to the scratch directory, perferrably into a separate directory in that location; psi_io = psi4.IOManager.shared_object(); os.chdir(psi_io.get_default_path()). # Make new directory specifically for mrcc; mrcc_tmpdir = 'mrcc_' + str(os.getpid()); if 'path' in kwargs:; mrcc_tmpdir = kwargs['path']. # Check to see if directory already exists, if not, create.; if os.path.exists(mrcc_tmpdir) == False:; os.mkdir(mrcc_tmpdir). # Move into the new directory; os.chdir(mrcc_tmpdir). # Generate integrals and input file (dumps files to the current directory); psi4.mrcc_generate_input(level). # Load the fort.56 file; # and dump a copy into the outfile; psi4.print_out('\n===== Begin fort.56 input for MRCC ======\n'); psi4.print_out(open('fort.56', 'r').read()); psi4.print_out('===== End fort.56 input for MRCC ======\n'). # Close output file; psi4.close_outfile(). # Modify the environment:; # PGI Fortan prints warning to screen if STOP is used; os.environ['NO_STOP_MESSAGE'] = '1'. # Obtain user's OMP_NUM_THREADS so that we don't blow it away.; omp_num_threads_found = 'OMP_NUM_THREADS' in os.environ; if omp_num_threads_found == True:; omp_num_threads_user = os.environ['OMP_NUM_THREADS']. # If the user provided MRCC_OMP_NUM_THREADS set the environ to it; if psi4.has_option_changed('MRCC', 'MRCC_OMP_NUM_THREADS') == True:; os.environ['OMP_NUM_THREADS'] = str(psi4.get_option('MRCC', 'MRCC_OMP_NUM_THREADS')). # Call dmrcc, directing all screen output to the output file; try:; if psi4.outfile_name() == 'stdout':; retcode = subprocess.call('dmrcc', shell=True); else:; retcode = subprocess.c",MatchSource.WIKI,psi4manual/4.0b5/_modules/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/proc.html
https://psicode.org/psi4manual/4.0b5/_modules/proc.html:62689,Performance,Load,Load,62689,"psi4.outfile_name(), shell=True). if retcode < 0:; print('MRCC was terminated by signal %d' % -retcode, file=sys.stderr); exit(1); elif retcode > 0:; print('MRCC errored %d' % retcode, file=sys.stderr); exit(1). except OSError as e:; print('Execution failed: %s' % e, file=sys.stderr); exit(1). # Restore the OMP_NUM_THREADS that the user set.; if omp_num_threads_found == True:; if psi4.has_option_changed('MRCC', 'MRCC_OMP_NUM_THREADS') == True:; os.environ['OMP_NUM_THREADS'] = omp_num_threads_user. # Scan iface file and grab the file energy.; e = 0.0; for line in file('iface'):; fields = line.split(); m = fields[1]; try:; e = float(fields[5]); if m == ""MP(2)"":; m = ""MP2""; psi4.set_variable(m + ' TOTAL ENERGY', e); psi4.set_variable(m + ' CORRELATION ENERGY', e - vscf); except ValueError:; continue. # The last 'e' in iface is the one the user requested.; psi4.set_variable('CURRENT ENERGY', e); psi4.set_variable('CURRENT CORRELATION ENERGY', e - vscf). # Load the iface file; iface = open('iface', 'r'); iface_contents = iface.read(). # Delete mrcc tempdir; os.chdir('..'); try:; # Delete unless we're told not to; if (keep == False and not('path' in kwargs)):; shutil.rmtree(mrcc_tmpdir); except OSError as e:; print('Unable to remove MRCC temporary directory %s' % e, file=sys.stderr); exit(1). # Revert to previous current directory location; os.chdir(current_directory). # Reopen output file; psi4.reopen_outfile(). # If we're told to keep the files or the user provided a path, do nothing.; if (keep != False or ('path' in kwargs)):; psi4.print_out('\nMRCC scratch files have been kept.\n'); psi4.print_out('They can be found in ' + mrcc_tmpdir). # Dump iface contents to output; psi4.print_out('\n'); p4util.banner('Full results from MRCC'); psi4.print_out('\n'); psi4.print_out(iface_contents). return e. [docs]def run_fnodfcc(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a DF-CCSD(T) computation. >>> energy('df-ccsd(t)'). """"""; lowername = name.lower(); ",MatchSource.WIKI,psi4manual/4.0b5/_modules/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/proc.html
https://psicode.org/psi4manual/4.0b5/_modules/proc.html:14070,Security,Validat,ValidationError,14070," psi4.get_option('SCF', 'REFERENCE') == 'UKS':; psi4.set_local_option('SCF', 'REFERENCE', 'UHF'); else:; pass; elif lowername == 'rhf':; psi4.set_local_option('SCF', 'REFERENCE', 'RHF'); elif lowername == 'uhf':; psi4.set_local_option('SCF', 'REFERENCE', 'UHF'); elif lowername == 'rohf':; psi4.set_local_option('SCF', 'REFERENCE', 'ROHF'); elif lowername == 'rscf':; if (len(psi4.get_option('SCF', 'DFT_FUNCTIONAL')) > 0) or psi4.get_option('SCF', 'DFT_CUSTOM_FUNCTIONAL') is not None:; psi4.set_local_option('SCF', 'REFERENCE', 'RKS'); else:; psi4.set_local_option('SCF', 'REFERENCE', 'RHF'); elif lowername == 'uscf':; if (len(psi4.get_option('SCF', 'DFT_FUNCTIONAL')) > 0) or psi4.get_option('SCF', 'DFT_CUSTOM_FUNCTIONAL') is not None:; psi4.set_local_option('SCF', 'REFERENCE', 'UKS'); else:; psi4.set_local_option('SCF', 'REFERENCE', 'UHF'); elif lowername == 'roscf':; if (len(psi4.get_option('SCF', 'DFT_FUNCTIONAL')) > 0) or psi4.get_option('SCF', 'DFT_CUSTOM_FUNCTIONAL') is not None:; raise ValidationError('ROHF reference for DFT is not available.'); else:; psi4.set_local_option('SCF', 'REFERENCE', 'ROHF'). scf_helper(name, **kwargs). optstash.restore(). [docs]def run_scf_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a SCF gradient calculation. """"""; optstash = p4util.OptionsState(; ['DF_BASIS_SCF'],; ['SCF', 'SCF_TYPE']). # Alter default algorithm; if not psi4.has_option_changed('SCF', 'SCF_TYPE'):; psi4.set_local_option('SCF', 'SCF_TYPE', 'DF'). run_scf(name, **kwargs). if (psi4.get_option('SCF', 'SCF_TYPE') == 'DF'):. # if the df_basis_scf basis is not set, pick a sensible one.; if psi4.get_global_option('DF_BASIS_SCF') == '':; jkbasis = p4util.corresponding_jkfit(psi4.get_global_option('BASIS')); if jkbasis:; psi4.set_global_option('DF_BASIS_SCF', jkbasis); psi4.print_out('\n No DF_BASIS_SCF auxiliary basis selected, defaulting to %s\n\n' % (jkbasis)); else:; raise ValidationError('Keyword DF_BASIS_SCF is required.'). psi4.scfgrad",MatchSource.WIKI,psi4manual/4.0b5/_modules/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/proc.html
https://psicode.org/psi4manual/4.0b5/_modules/proc.html:15001,Security,Validat,ValidationError,15001,", 'DFT_FUNCTIONAL')) > 0) or psi4.get_option('SCF', 'DFT_CUSTOM_FUNCTIONAL') is not None:; raise ValidationError('ROHF reference for DFT is not available.'); else:; psi4.set_local_option('SCF', 'REFERENCE', 'ROHF'). scf_helper(name, **kwargs). optstash.restore(). [docs]def run_scf_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a SCF gradient calculation. """"""; optstash = p4util.OptionsState(; ['DF_BASIS_SCF'],; ['SCF', 'SCF_TYPE']). # Alter default algorithm; if not psi4.has_option_changed('SCF', 'SCF_TYPE'):; psi4.set_local_option('SCF', 'SCF_TYPE', 'DF'). run_scf(name, **kwargs). if (psi4.get_option('SCF', 'SCF_TYPE') == 'DF'):. # if the df_basis_scf basis is not set, pick a sensible one.; if psi4.get_global_option('DF_BASIS_SCF') == '':; jkbasis = p4util.corresponding_jkfit(psi4.get_global_option('BASIS')); if jkbasis:; psi4.set_global_option('DF_BASIS_SCF', jkbasis); psi4.print_out('\n No DF_BASIS_SCF auxiliary basis selected, defaulting to %s\n\n' % (jkbasis)); else:; raise ValidationError('Keyword DF_BASIS_SCF is required.'). psi4.scfgrad(); optstash.restore(). [docs]def run_libfock(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a calculation through libfock, namely RCPHF,; RCIS, RTDHF, RTDA, and RTDDFT. """"""; if (name.lower() == 'cphf'):; psi4.set_global_option('MODULE', 'RCPHF'); if (name.lower() == 'cis'):; psi4.set_global_option('MODULE', 'RCIS'); if (name.lower() == 'tdhf'):; psi4.set_global_option('MODULE', 'RTDHF'); if (name.lower() == 'cpks'):; psi4.set_global_option('MODULE', 'RCPKS'); if (name.lower() == 'tda'):; psi4.set_global_option('MODULE', 'RTDA'); if (name.lower() == 'tddft'):; psi4.set_global_option('MODULE', 'RTDDFT'). psi4.libfock(). [docs]def run_mcscf(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a multiconfigurational self-consistent-field calculation. """"""; return psi4.mcscf(). [docs]def scf_helper(name, **kwargs):; """"""Function serving as helper to SCF, ",MatchSource.WIKI,psi4manual/4.0b5/_modules/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/proc.html
https://psicode.org/psi4manual/4.0b5/_modules/proc.html:16776,Security,Validat,ValidationError,16776,"kwargs):; """"""Function encoding sequence of PSI module calls for; a multiconfigurational self-consistent-field calculation. """"""; return psi4.mcscf(). [docs]def scf_helper(name, **kwargs):; """"""Function serving as helper to SCF, choosing whether to cast; up or just run SCF with a standard guess. This preserves; previous SCF options set by other procedures (e.g., SAPT; output file types for SCF). """"""; optstash = p4util.OptionsState(; ['PUREAM'],; ['BASIS'],; ['DF_BASIS_SCF'],; ['SCF', 'SCF_TYPE'],; ['SCF', 'GUESS'],; ['SCF', 'DF_INTS_IO'],; ['SCF', 'SCF_TYPE'] # Hack: scope gets changed internally with the Andy trick; ). # if the df_basis_scf basis is not set, pick a sensible one.; if psi4.get_option('SCF', 'SCF_TYPE') == 'DF':; if psi4.get_global_option('DF_BASIS_SCF') == '':; jkbasis = p4util.corresponding_jkfit(psi4.get_global_option('BASIS')); if jkbasis:; psi4.set_global_option('DF_BASIS_SCF', jkbasis); psi4.print_out('\n No DF_BASIS_SCF auxiliary basis selected, defaulting to %s\n\n' % (jkbasis)); else:; raise ValidationError('Keyword DF_BASIS_SCF is required.'). optstash2 = p4util.OptionsState(; ['BASIS'],; ['DF_BASIS_SCF'],; ['SCF', 'SCF_TYPE'],; ['SCF', 'DF_INTS_IO']). # sort out cast_up settings. no need to stash these since only read, never reset; cast = False; if psi4.has_option_changed('SCF', 'BASIS_GUESS'):; cast = psi4.get_option('SCF', 'BASIS_GUESS'); if yes.match(str(cast)):; cast = True; elif no.match(str(cast)):; cast = False. if psi4.get_option('SCF', 'SCF_TYPE') == 'DF':; castdf = True; else:; castdf = False. if psi4.has_option_changed('SCF', 'DF_BASIS_GUESS'):; castdf = psi4.get_option('SCF', 'DF_BASIS_GUESS'); if yes.match(str(castdf)):; castdf = True; elif no.match(str(castdf)):; castdf = False. # sort out broken_symmetry settings.; if 'brokensymmetry' in kwargs:; molecule = psi4.get_active_molecule(); multp = molecule.multiplicity(); if multp != 1:; raise ValidationError('Broken symmetry is only for singlets.'); if psi4.get_option('SCF','REFERENC",MatchSource.WIKI,psi4manual/4.0b5/_modules/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/proc.html
https://psicode.org/psi4manual/4.0b5/_modules/proc.html:17657,Security,Validat,ValidationError,17657," psi4.print_out('\n No DF_BASIS_SCF auxiliary basis selected, defaulting to %s\n\n' % (jkbasis)); else:; raise ValidationError('Keyword DF_BASIS_SCF is required.'). optstash2 = p4util.OptionsState(; ['BASIS'],; ['DF_BASIS_SCF'],; ['SCF', 'SCF_TYPE'],; ['SCF', 'DF_INTS_IO']). # sort out cast_up settings. no need to stash these since only read, never reset; cast = False; if psi4.has_option_changed('SCF', 'BASIS_GUESS'):; cast = psi4.get_option('SCF', 'BASIS_GUESS'); if yes.match(str(cast)):; cast = True; elif no.match(str(cast)):; cast = False. if psi4.get_option('SCF', 'SCF_TYPE') == 'DF':; castdf = True; else:; castdf = False. if psi4.has_option_changed('SCF', 'DF_BASIS_GUESS'):; castdf = psi4.get_option('SCF', 'DF_BASIS_GUESS'); if yes.match(str(castdf)):; castdf = True; elif no.match(str(castdf)):; castdf = False. # sort out broken_symmetry settings.; if 'brokensymmetry' in kwargs:; molecule = psi4.get_active_molecule(); multp = molecule.multiplicity(); if multp != 1:; raise ValidationError('Broken symmetry is only for singlets.'); if psi4.get_option('SCF','REFERENCE') != 'UHF' and psi4.get_option('SCF','REFERENCE') != 'UKS':; raise ValidationError('You must specify ""set reference uhf"" to use broken symmetry.'); do_broken = True; else:; do_broken = False. precallback = None; if 'precallback' in kwargs:; precallback = kwargs.pop('precallback'). postcallback = None; if 'postcallback' in kwargs:; postcallback = kwargs.pop('postcallback'). # Hack to ensure cartesian or pure are used throughout; # Note that can't query PUREAM option directly, as it only; # reflects user changes to value, so load basis and; # read effective PUREAM setting off of it; psi4.set_global_option('BASIS', psi4.get_global_option('BASIS')); psi4.set_global_option('PUREAM', psi4.MintsHelper().basisset().has_puream()). # broken set-up; if do_broken:; molecule.set_multiplicity(3); psi4.print_out('\n'); p4util.banner(' Computing high-spin triplet guess '); psi4.print_out('\n'). # cast set-up; if (cas",MatchSource.WIKI,psi4manual/4.0b5/_modules/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/proc.html
https://psicode.org/psi4manual/4.0b5/_modules/proc.html:17818,Security,Validat,ValidationError,17818,"stash2 = p4util.OptionsState(; ['BASIS'],; ['DF_BASIS_SCF'],; ['SCF', 'SCF_TYPE'],; ['SCF', 'DF_INTS_IO']). # sort out cast_up settings. no need to stash these since only read, never reset; cast = False; if psi4.has_option_changed('SCF', 'BASIS_GUESS'):; cast = psi4.get_option('SCF', 'BASIS_GUESS'); if yes.match(str(cast)):; cast = True; elif no.match(str(cast)):; cast = False. if psi4.get_option('SCF', 'SCF_TYPE') == 'DF':; castdf = True; else:; castdf = False. if psi4.has_option_changed('SCF', 'DF_BASIS_GUESS'):; castdf = psi4.get_option('SCF', 'DF_BASIS_GUESS'); if yes.match(str(castdf)):; castdf = True; elif no.match(str(castdf)):; castdf = False. # sort out broken_symmetry settings.; if 'brokensymmetry' in kwargs:; molecule = psi4.get_active_molecule(); multp = molecule.multiplicity(); if multp != 1:; raise ValidationError('Broken symmetry is only for singlets.'); if psi4.get_option('SCF','REFERENCE') != 'UHF' and psi4.get_option('SCF','REFERENCE') != 'UKS':; raise ValidationError('You must specify ""set reference uhf"" to use broken symmetry.'); do_broken = True; else:; do_broken = False. precallback = None; if 'precallback' in kwargs:; precallback = kwargs.pop('precallback'). postcallback = None; if 'postcallback' in kwargs:; postcallback = kwargs.pop('postcallback'). # Hack to ensure cartesian or pure are used throughout; # Note that can't query PUREAM option directly, as it only; # reflects user changes to value, so load basis and; # read effective PUREAM setting off of it; psi4.set_global_option('BASIS', psi4.get_global_option('BASIS')); psi4.set_global_option('PUREAM', psi4.MintsHelper().basisset().has_puream()). # broken set-up; if do_broken:; molecule.set_multiplicity(3); psi4.print_out('\n'); p4util.banner(' Computing high-spin triplet guess '); psi4.print_out('\n'). # cast set-up; if (cast):. if yes.match(str(cast)):; guessbasis = '3-21G'; else:; guessbasis = cast. if (castdf):; if yes.match(str(castdf)):; guessbasisdf = p4util.corresponding_jkfit(guess",MatchSource.WIKI,psi4manual/4.0b5/_modules/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/proc.html
https://psicode.org/psi4manual/4.0b5/_modules/proc.html:21431,Security,Validat,ValidationError,21431,"psi4.get_option(""OCC"", ""MP2_TYPE"") == ""CONV""):; return run_mp2(name, **kwargs); else:; return run_dfmp2(name, **kwargs). [docs]def run_mp2_select_gradient(name, **kwargs):; """"""Function selecting the algorithm for a MP2 gradient call; and directing toward the OCC (conv MP2) or the DFMP2 modules. """"""; if (psi4.get_option(""DFMP2"", ""MP2_TYPE"") == ""CONV"") or (psi4.get_option(""OCC"", ""MP2_TYPE"") == ""CONV""):; return run_mp2_gradient(name, **kwargs); else:; return run_dfmp2_gradient(name, **kwargs). [docs]def run_dfmp2_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a DFMP2 gradient calculation. """"""; optstash = p4util.OptionsState(; ['DF_BASIS_SCF'],; ['DF_BASIS_MP2'],; ['SCF_TYPE']). # Alter default algorithm; if not psi4.has_option_changed('SCF', 'SCF_TYPE'):; #psi4.set_local_option('SCF', 'SCF_TYPE', 'DF') # insufficient b/c SCF option read in DFMP2; psi4.set_global_option('SCF_TYPE', 'DF'). if not psi4.get_option('SCF', 'SCF_TYPE') == 'DF':; raise ValidationError('DF-MP2 gradients need DF-SCF reference, for now.'). if 'restart_file' in kwargs:; restartfile = kwargs.pop('restart_file'); # Rename the checkpoint file to be consistent with psi4's file system; psioh = psi4.IOManager.shared_object(); psio = psi4.IO.shared_object(); filepath = psioh.get_file_path(32); namespace = psio.get_default_namespace(); pid = str(os.getpid()); prefix = 'psi'; targetfile = filepath + prefix + '.' + pid + '.' + namespace + '.32'; if(psi4.me() == 0):; shutil.copy(restartfile, targetfile); else:; # if the df_basis_scf basis is not set, pick a sensible one.; if psi4.get_global_option('DF_BASIS_SCF') == '':; jkbasis = p4util.corresponding_jkfit(psi4.get_global_option('BASIS')); if jkbasis:; psi4.set_global_option('DF_BASIS_SCF', jkbasis); psi4.print_out('\n No DF_BASIS_SCF auxiliary basis selected, defaulting to %s\n\n' % (jkbasis)); else:; raise ValidationError('Keyword DF_BASIS_SCF is required.'). scf_helper(name, **kwargs). psi4.print_out('\n'); p4util.banner",MatchSource.WIKI,psi4manual/4.0b5/_modules/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/proc.html
https://psicode.org/psi4manual/4.0b5/_modules/proc.html:22324,Security,Validat,ValidationError,22324,"ient b/c SCF option read in DFMP2; psi4.set_global_option('SCF_TYPE', 'DF'). if not psi4.get_option('SCF', 'SCF_TYPE') == 'DF':; raise ValidationError('DF-MP2 gradients need DF-SCF reference, for now.'). if 'restart_file' in kwargs:; restartfile = kwargs.pop('restart_file'); # Rename the checkpoint file to be consistent with psi4's file system; psioh = psi4.IOManager.shared_object(); psio = psi4.IO.shared_object(); filepath = psioh.get_file_path(32); namespace = psio.get_default_namespace(); pid = str(os.getpid()); prefix = 'psi'; targetfile = filepath + prefix + '.' + pid + '.' + namespace + '.32'; if(psi4.me() == 0):; shutil.copy(restartfile, targetfile); else:; # if the df_basis_scf basis is not set, pick a sensible one.; if psi4.get_global_option('DF_BASIS_SCF') == '':; jkbasis = p4util.corresponding_jkfit(psi4.get_global_option('BASIS')); if jkbasis:; psi4.set_global_option('DF_BASIS_SCF', jkbasis); psi4.print_out('\n No DF_BASIS_SCF auxiliary basis selected, defaulting to %s\n\n' % (jkbasis)); else:; raise ValidationError('Keyword DF_BASIS_SCF is required.'). scf_helper(name, **kwargs). psi4.print_out('\n'); p4util.banner('DFMP2'); psi4.print_out('\n'). # if the df_basis_mp2 basis is not set, pick a sensible one.; if psi4.get_global_option('DF_BASIS_MP2') == '':; ribasis = p4util.corresponding_rifit(psi4.get_global_option('BASIS')); if ribasis:; psi4.set_global_option('DF_BASIS_MP2', ribasis); psi4.print_out(' No DF_BASIS_MP2 auxiliary basis selected, defaulting to %s\n' % (ribasis)); else:; raise ValidationError('Keyword DF_BASIS_MP2 is required.'). psi4.dfmp2grad(); e_dfmp2 = psi4.get_variable('MP2 TOTAL ENERGY'); e_scs_dfmp2 = psi4.get_variable('SCS-MP2 TOTAL ENERGY'). optstash.restore(). if (name.upper() == 'SCS-MP2'):; return e_scs_dfmp2; elif (name.upper() == 'DF-MP2') or (name.upper() == 'DFMP2') or (name.upper() == 'MP2'):; return e_dfmp2. [docs]def run_ccenergy(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a CCSD, CC2, and CC",MatchSource.WIKI,psi4manual/4.0b5/_modules/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/proc.html
https://psicode.org/psi4manual/4.0b5/_modules/proc.html:22825,Security,Validat,ValidationError,22825,"str(os.getpid()); prefix = 'psi'; targetfile = filepath + prefix + '.' + pid + '.' + namespace + '.32'; if(psi4.me() == 0):; shutil.copy(restartfile, targetfile); else:; # if the df_basis_scf basis is not set, pick a sensible one.; if psi4.get_global_option('DF_BASIS_SCF') == '':; jkbasis = p4util.corresponding_jkfit(psi4.get_global_option('BASIS')); if jkbasis:; psi4.set_global_option('DF_BASIS_SCF', jkbasis); psi4.print_out('\n No DF_BASIS_SCF auxiliary basis selected, defaulting to %s\n\n' % (jkbasis)); else:; raise ValidationError('Keyword DF_BASIS_SCF is required.'). scf_helper(name, **kwargs). psi4.print_out('\n'); p4util.banner('DFMP2'); psi4.print_out('\n'). # if the df_basis_mp2 basis is not set, pick a sensible one.; if psi4.get_global_option('DF_BASIS_MP2') == '':; ribasis = p4util.corresponding_rifit(psi4.get_global_option('BASIS')); if ribasis:; psi4.set_global_option('DF_BASIS_MP2', ribasis); psi4.print_out(' No DF_BASIS_MP2 auxiliary basis selected, defaulting to %s\n' % (ribasis)); else:; raise ValidationError('Keyword DF_BASIS_MP2 is required.'). psi4.dfmp2grad(); e_dfmp2 = psi4.get_variable('MP2 TOTAL ENERGY'); e_scs_dfmp2 = psi4.get_variable('SCS-MP2 TOTAL ENERGY'). optstash.restore(). if (name.upper() == 'SCS-MP2'):; return e_scs_dfmp2; elif (name.upper() == 'DF-MP2') or (name.upper() == 'DFMP2') or (name.upper() == 'MP2'):; return e_dfmp2. [docs]def run_ccenergy(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a CCSD, CC2, and CC3 calculation. """"""; lowername = name.lower(). optstash = p4util.OptionsState(; ['TRANSQT2', 'WFN'],; ['CCSORT', 'WFN'],; ['CCENERGY', 'WFN']). if (lowername == 'ccsd'):; psi4.set_local_option('TRANSQT2', 'WFN', 'CCSD'); psi4.set_local_option('CCSORT', 'WFN', 'CCSD'); psi4.set_local_option('CCENERGY', 'WFN', 'CCSD'); elif (lowername == 'ccsd(t)'):; psi4.set_local_option('TRANSQT2', 'WFN', 'CCSD_T'); psi4.set_local_option('CCSORT', 'WFN', 'CCSD_T'); psi4.set_local_option('CCENERGY', 'WFN', 'CCSD_T');",MatchSource.WIKI,psi4manual/4.0b5/_modules/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/proc.html
https://psicode.org/psi4manual/4.0b5/_modules/proc.html:26231,Security,Validat,ValidationError,26231,"o disk; if psi4.get_option('SCF', 'SCF_TYPE') == 'DF' or psi4.get_option('SCF', 'SCF_TYPE') == 'CD':; mints = psi4.MintsHelper(); mints.integrals(). psi4.transqt2(); psi4.ccsort(); psi4.ccenergy(). if (lowername == 'ccsd(at)' or lowername == 'a-ccsd(t)'):; 	psi4.cchbar(); 	psi4.cclambda(). optstash.restore(). [docs]def run_cc_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a CCSD and CCSD(T) gradient calculation. """"""; optstash = p4util.OptionsState(; ['GLOBALS', 'DERTYPE'],; ['CCLAMBDA', 'WFN'],; ['CCDENSITY', 'WFN']). psi4.set_global_option('DERTYPE', 'FIRST'). run_ccenergy(name, **kwargs); if (name.lower() == 'ccsd'):; psi4.set_local_option('CCLAMBDA', 'WFN', 'CCSD'); psi4.set_local_option('CCDENSITY', 'WFN', 'CCSD'); elif (name.lower() == 'ccsd(t)'):; psi4.set_local_option('CCLAMBDA', 'WFN', 'CCSD_T'); psi4.set_local_option('CCDENSITY', 'WFN', 'CCSD_T'). user_ref = psi4.get_option('CCENERGY', 'REFERENCE'); if (user_ref != 'RHF') and (user_ref != 'UHF'):; raise ValidationError('Reference %s for CCSD(T) gradients is not available.' % user_ref). psi4.cchbar(); psi4.cclambda(); psi4.ccdensity(); psi4.deriv(). optstash.restore(). [docs]def run_bccd(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a Brueckner CCD calculation. """"""; optstash = p4util.OptionsState(; ['TRANSQT2', 'DELETE_TEI'],; ['TRANSQT2', 'WFN'],; ['CCSORT', 'WFN'],; ['CCENERGY', 'WFN']). if (name.lower() == 'bccd'):; psi4.set_local_option('TRANSQT2', 'WFN', 'BCCD'); psi4.set_local_option('CCSORT', 'WFN', 'BCCD'); psi4.set_local_option('CCENERGY', 'WFN', 'BCCD'). # Bypass routine scf if user did something special to get it to converge; if not (('bypass_scf' in kwargs) and yes.match(str(kwargs['bypass_scf']))):; scf_helper(name, **kwargs). # If the scf type is DF/CD, then the AO integrals were never written to disk; if psi4.get_option('SCF', 'SCF_TYPE') == 'DF' or psi4.get_option('SCF', 'SCF_TYPE') == 'CD':; mints = psi4.MintsHelper(); mints.integr",MatchSource.WIKI,psi4manual/4.0b5/_modules/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/proc.html
https://psicode.org/psi4manual/4.0b5/_modules/proc.html:29289,Security,Validat,ValidationError,29289,"TYPE']). # Alter default algorithm; if not psi4.has_option_changed('SCF', 'SCF_TYPE'):; psi4.set_local_option('SCF', 'SCF_TYPE', 'DF'). run_scf(name, **kwargs). optstash.restore(). [docs]def run_cc_property(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; all CC property calculations. """"""; oneel_properties = ['dipole', 'quadrupole']; twoel_properties = []; response_properties = ['polarizability', 'rotation', 'roa']; excited_properties = ['oscillator_strength', 'rotational_strength']. one = []; two = []; response = []; excited = []; invalid = []. if 'properties' in kwargs:; properties = kwargs.pop('properties'); properties = p4util.drop_duplicates(properties). for prop in properties:; if prop in oneel_properties:; one.append(prop); elif prop in twoel_properties:; two.append(prop); elif prop in response_properties:; response.append(prop); elif prop in excited_properties:; excited.append(prop); else:; invalid.append(prop); else:; raise ValidationError(""The \""properties\"" keyword is required with the property() function.""). n_one = len(one); n_two = len(two); n_response = len(response); n_excited = len(excited); n_invalid = len(invalid). if (n_invalid > 0):; print(""The following properties are not currently supported: %s"" % invalid). if (n_excited > 0 and (name.lower() != 'eom-ccsd' and name.lower() != 'eom-cc2')):; raise ValidationError(""Excited state CC properties require EOM-CC2 or EOM-CCSD.""). if ((name.lower() == 'eom-ccsd' or name.lower() == 'eom-cc2') and n_response > 0):; raise ValidationError(""Cannot (yet) compute response properties for excited states.""). if (n_one > 0 or n_two > 0) and (n_response > 0):; print(""Computing both density- and response-based properties.""). if (name.lower() == 'ccsd'):; psi4.set_global_option('WFN', 'CCSD'); run_ccenergy('ccsd', **kwargs); psi4.set_global_option('WFN', 'CCSD'); elif (name.lower() == 'cc2'):; psi4.set_global_option('WFN', 'CC2'); run_ccenergy('cc2', **kwargs); psi4.set_global_option('WFN', 'C",MatchSource.WIKI,psi4manual/4.0b5/_modules/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/proc.html
https://psicode.org/psi4manual/4.0b5/_modules/proc.html:29682,Security,Validat,ValidationError,29682,"sponse_properties = ['polarizability', 'rotation', 'roa']; excited_properties = ['oscillator_strength', 'rotational_strength']. one = []; two = []; response = []; excited = []; invalid = []. if 'properties' in kwargs:; properties = kwargs.pop('properties'); properties = p4util.drop_duplicates(properties). for prop in properties:; if prop in oneel_properties:; one.append(prop); elif prop in twoel_properties:; two.append(prop); elif prop in response_properties:; response.append(prop); elif prop in excited_properties:; excited.append(prop); else:; invalid.append(prop); else:; raise ValidationError(""The \""properties\"" keyword is required with the property() function.""). n_one = len(one); n_two = len(two); n_response = len(response); n_excited = len(excited); n_invalid = len(invalid). if (n_invalid > 0):; print(""The following properties are not currently supported: %s"" % invalid). if (n_excited > 0 and (name.lower() != 'eom-ccsd' and name.lower() != 'eom-cc2')):; raise ValidationError(""Excited state CC properties require EOM-CC2 or EOM-CCSD.""). if ((name.lower() == 'eom-ccsd' or name.lower() == 'eom-cc2') and n_response > 0):; raise ValidationError(""Cannot (yet) compute response properties for excited states.""). if (n_one > 0 or n_two > 0) and (n_response > 0):; print(""Computing both density- and response-based properties.""). if (name.lower() == 'ccsd'):; psi4.set_global_option('WFN', 'CCSD'); run_ccenergy('ccsd', **kwargs); psi4.set_global_option('WFN', 'CCSD'); elif (name.lower() == 'cc2'):; psi4.set_global_option('WFN', 'CC2'); run_ccenergy('cc2', **kwargs); psi4.set_global_option('WFN', 'CC2'); elif (name.lower() == 'eom-ccsd'):; psi4.set_global_option('WFN', 'EOM_CCSD'); run_ccenergy('eom-ccsd', **kwargs); psi4.set_global_option('WFN', 'EOM_CCSD'); elif (name.lower() == 'eom-cc2'):; psi4.set_global_option('WFN', 'EOM_CC2'); run_ccenergy('eom-cc2', **kwargs); psi4.set_global_option('WFN', 'EOM_CC2'). # Need cchbar for everything; psi4.cchbar(). # Need ccdensity at th",MatchSource.WIKI,psi4manual/4.0b5/_modules/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/proc.html
https://psicode.org/psi4manual/4.0b5/_modules/proc.html:29849,Security,Validat,ValidationError,29849,"[]; excited = []; invalid = []. if 'properties' in kwargs:; properties = kwargs.pop('properties'); properties = p4util.drop_duplicates(properties). for prop in properties:; if prop in oneel_properties:; one.append(prop); elif prop in twoel_properties:; two.append(prop); elif prop in response_properties:; response.append(prop); elif prop in excited_properties:; excited.append(prop); else:; invalid.append(prop); else:; raise ValidationError(""The \""properties\"" keyword is required with the property() function.""). n_one = len(one); n_two = len(two); n_response = len(response); n_excited = len(excited); n_invalid = len(invalid). if (n_invalid > 0):; print(""The following properties are not currently supported: %s"" % invalid). if (n_excited > 0 and (name.lower() != 'eom-ccsd' and name.lower() != 'eom-cc2')):; raise ValidationError(""Excited state CC properties require EOM-CC2 or EOM-CCSD.""). if ((name.lower() == 'eom-ccsd' or name.lower() == 'eom-cc2') and n_response > 0):; raise ValidationError(""Cannot (yet) compute response properties for excited states.""). if (n_one > 0 or n_two > 0) and (n_response > 0):; print(""Computing both density- and response-based properties.""). if (name.lower() == 'ccsd'):; psi4.set_global_option('WFN', 'CCSD'); run_ccenergy('ccsd', **kwargs); psi4.set_global_option('WFN', 'CCSD'); elif (name.lower() == 'cc2'):; psi4.set_global_option('WFN', 'CC2'); run_ccenergy('cc2', **kwargs); psi4.set_global_option('WFN', 'CC2'); elif (name.lower() == 'eom-ccsd'):; psi4.set_global_option('WFN', 'EOM_CCSD'); run_ccenergy('eom-ccsd', **kwargs); psi4.set_global_option('WFN', 'EOM_CCSD'); elif (name.lower() == 'eom-cc2'):; psi4.set_global_option('WFN', 'EOM_CC2'); run_ccenergy('eom-cc2', **kwargs); psi4.set_global_option('WFN', 'EOM_CC2'). # Need cchbar for everything; psi4.cchbar(). # Need ccdensity at this point only for density-based props; if (n_one > 0 or n_two > 0):; if (name.lower() == 'eom-ccsd'):; psi4.set_global_option('WFN', 'EOM_CCSD'); psi4.set_globa",MatchSource.WIKI,psi4manual/4.0b5/_modules/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/proc.html
https://psicode.org/psi4manual/4.0b5/_modules/proc.html:31689,Security,Validat,ValidationError,31689,"nsity at this point only for density-based props; if (n_one > 0 or n_two > 0):; if (name.lower() == 'eom-ccsd'):; psi4.set_global_option('WFN', 'EOM_CCSD'); psi4.set_global_option('DERTYPE', 'NONE'); psi4.set_global_option('ONEPDM', 'TRUE'); psi4.cceom(); elif (name.lower() == 'eom-cc2'):; psi4.set_global_option('WFN', 'EOM_CC2'); psi4.set_global_option('DERTYPE', 'NONE'); psi4.set_global_option('ONEPDM', 'TRUE'); psi4.cceom(); psi4.set_global_option('DERTYPE', 'NONE'); psi4.set_global_option('ONEPDM', 'TRUE'); psi4.cclambda(); psi4.ccdensity(). # Need ccresponse only for response-type props; if (n_response > 0):; psi4.set_global_option('DERTYPE', 'RESPONSE'); psi4.cclambda(); for prop in response:; psi4.set_global_option('PROPERTY', prop); psi4.ccresponse(). # Excited-state transition properties; if (n_excited > 0):; if (name.lower() == 'eom-ccsd'):; psi4.set_global_option('WFN', 'EOM_CCSD'); elif (name.lower() == 'eom-cc2'):; psi4.set_global_option('WFN', 'EOM_CC2'); else:; raise ValidationError(""Unknown excited-state CC wave function.""); psi4.set_global_option('DERTYPE', 'NONE'); psi4.set_global_option('ONEPDM', 'TRUE'); psi4.cceom(); psi4.cclambda(); psi4.ccdensity(). psi4.set_global_option('WFN', 'SCF'); psi4.revoke_global_option_changed('WFN'); psi4.set_global_option('DERTYPE', 'NONE'); psi4.revoke_global_option_changed('DERTYPE'). [docs]def run_dfmp2_property(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a DFMP2 property calculation. """"""; optstash = p4util.OptionsState(; ['DF_BASIS_SCF'],; ['DF_BASIS_MP2'],; ['SCF_TYPE']). psi4.set_global_option('ONEPDM', 'TRUE'); psi4.set_global_option('OPDM_RELAX', 'TRUE'). # Alter default algorithm; if not psi4.has_option_changed('SCF', 'SCF_TYPE'):; #psi4.set_local_option('SCF', 'SCF_TYPE', 'DF') # insufficient b/c SCF option read in DFMP2; psi4.set_global_option('SCF_TYPE', 'DF'). if not psi4.get_option('SCF', 'SCF_TYPE') == 'DF':; raise ValidationError('DF-MP2 properties need DF-SCF reference,",MatchSource.WIKI,psi4manual/4.0b5/_modules/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/proc.html
https://psicode.org/psi4manual/4.0b5/_modules/proc.html:32635,Security,Validat,ValidationError,32635,"obal_option('WFN', 'EOM_CC2'); else:; raise ValidationError(""Unknown excited-state CC wave function.""); psi4.set_global_option('DERTYPE', 'NONE'); psi4.set_global_option('ONEPDM', 'TRUE'); psi4.cceom(); psi4.cclambda(); psi4.ccdensity(). psi4.set_global_option('WFN', 'SCF'); psi4.revoke_global_option_changed('WFN'); psi4.set_global_option('DERTYPE', 'NONE'); psi4.revoke_global_option_changed('DERTYPE'). [docs]def run_dfmp2_property(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a DFMP2 property calculation. """"""; optstash = p4util.OptionsState(; ['DF_BASIS_SCF'],; ['DF_BASIS_MP2'],; ['SCF_TYPE']). psi4.set_global_option('ONEPDM', 'TRUE'); psi4.set_global_option('OPDM_RELAX', 'TRUE'). # Alter default algorithm; if not psi4.has_option_changed('SCF', 'SCF_TYPE'):; #psi4.set_local_option('SCF', 'SCF_TYPE', 'DF') # insufficient b/c SCF option read in DFMP2; psi4.set_global_option('SCF_TYPE', 'DF'). if not psi4.get_option('SCF', 'SCF_TYPE') == 'DF':; raise ValidationError('DF-MP2 properties need DF-SCF reference, for now.'). if 'restart_file' in kwargs:; restartfile = kwargs.pop('restart_file'); # Rename the checkpoint file to be consistent with psi4's file system; psioh = psi4.IOManager.shared_object(); psio = psi4.IO.shared_object(); filepath = psioh.get_file_path(32); namespace = psio.get_default_namespace(); pid = str(os.getpid()); prefix = 'psi'; targetfile = filepath + prefix + '.' + pid + '.' + namespace + '.32'; if(psi4.me() == 0):; shutil.copy(restartfile, targetfile); else:; # if the df_basis_scf basis is not set, pick a sensible one.; if psi4.get_global_option('DF_BASIS_SCF') == '':; jkbasis = p4util.corresponding_jkfit(psi4.get_global_option('BASIS')); if jkbasis:; psi4.set_global_option('DF_BASIS_SCF', jkbasis); psi4.print_out('\nNo DF_BASIS_SCF auxiliary basis selected, defaulting to %s\n\n' % (jkbasis)); else:; raise ValidationError('Keyword DF_BASIS_SCF is required.'). scf_helper(name, **kwargs). psi4.print_out('\n'); p4util.banner",MatchSource.WIKI,psi4manual/4.0b5/_modules/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/proc.html
https://psicode.org/psi4manual/4.0b5/_modules/proc.html:33528,Security,Validat,ValidationError,33528,"ent b/c SCF option read in DFMP2; psi4.set_global_option('SCF_TYPE', 'DF'). if not psi4.get_option('SCF', 'SCF_TYPE') == 'DF':; raise ValidationError('DF-MP2 properties need DF-SCF reference, for now.'). if 'restart_file' in kwargs:; restartfile = kwargs.pop('restart_file'); # Rename the checkpoint file to be consistent with psi4's file system; psioh = psi4.IOManager.shared_object(); psio = psi4.IO.shared_object(); filepath = psioh.get_file_path(32); namespace = psio.get_default_namespace(); pid = str(os.getpid()); prefix = 'psi'; targetfile = filepath + prefix + '.' + pid + '.' + namespace + '.32'; if(psi4.me() == 0):; shutil.copy(restartfile, targetfile); else:; # if the df_basis_scf basis is not set, pick a sensible one.; if psi4.get_global_option('DF_BASIS_SCF') == '':; jkbasis = p4util.corresponding_jkfit(psi4.get_global_option('BASIS')); if jkbasis:; psi4.set_global_option('DF_BASIS_SCF', jkbasis); psi4.print_out('\nNo DF_BASIS_SCF auxiliary basis selected, defaulting to %s\n\n' % (jkbasis)); else:; raise ValidationError('Keyword DF_BASIS_SCF is required.'). scf_helper(name, **kwargs). psi4.print_out('\n'); p4util.banner('DFMP2'); psi4.print_out('\n'). # if the df_basis_mp2 basis is not set, pick a sensible one.; if psi4.get_global_option('DF_BASIS_MP2') == '':; ribasis = p4util.corresponding_rifit(psi4.get_global_option('BASIS')); if ribasis:; psi4.set_global_option('DF_BASIS_MP2', ribasis); psi4.print_out('No DF_BASIS_MP2 auxiliary basis selected, defaulting to %s\n' % (ribasis)); else:; raise ValidationError('Keyword DF_BASIS_MP2 is required.'). psi4.dfmp2grad(); e_dfmp2 = psi4.get_variable('MP2 TOTAL ENERGY'); e_scs_dfmp2 = psi4.get_variable('SCS-MP2 TOTAL ENERGY'). optstash.restore(). if (name.upper() == 'SCS-MP2'):; return e_scs_dfmp2; elif (name.upper() == 'DF-MP2') or (name.upper() == 'DFMP2') or (name.upper() == 'MP2'):; return e_dfmp2. [docs]def run_eom_cc(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; an EOM-CC calculation,",MatchSource.WIKI,psi4manual/4.0b5/_modules/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/proc.html
https://psicode.org/psi4manual/4.0b5/_modules/proc.html:34028,Security,Validat,ValidationError,34028," str(os.getpid()); prefix = 'psi'; targetfile = filepath + prefix + '.' + pid + '.' + namespace + '.32'; if(psi4.me() == 0):; shutil.copy(restartfile, targetfile); else:; # if the df_basis_scf basis is not set, pick a sensible one.; if psi4.get_global_option('DF_BASIS_SCF') == '':; jkbasis = p4util.corresponding_jkfit(psi4.get_global_option('BASIS')); if jkbasis:; psi4.set_global_option('DF_BASIS_SCF', jkbasis); psi4.print_out('\nNo DF_BASIS_SCF auxiliary basis selected, defaulting to %s\n\n' % (jkbasis)); else:; raise ValidationError('Keyword DF_BASIS_SCF is required.'). scf_helper(name, **kwargs). psi4.print_out('\n'); p4util.banner('DFMP2'); psi4.print_out('\n'). # if the df_basis_mp2 basis is not set, pick a sensible one.; if psi4.get_global_option('DF_BASIS_MP2') == '':; ribasis = p4util.corresponding_rifit(psi4.get_global_option('BASIS')); if ribasis:; psi4.set_global_option('DF_BASIS_MP2', ribasis); psi4.print_out('No DF_BASIS_MP2 auxiliary basis selected, defaulting to %s\n' % (ribasis)); else:; raise ValidationError('Keyword DF_BASIS_MP2 is required.'). psi4.dfmp2grad(); e_dfmp2 = psi4.get_variable('MP2 TOTAL ENERGY'); e_scs_dfmp2 = psi4.get_variable('SCS-MP2 TOTAL ENERGY'). optstash.restore(). if (name.upper() == 'SCS-MP2'):; return e_scs_dfmp2; elif (name.upper() == 'DF-MP2') or (name.upper() == 'DFMP2') or (name.upper() == 'MP2'):; return e_dfmp2. [docs]def run_eom_cc(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; an EOM-CC calculation, namely EOM-CC2, EOM-CCSD, and EOM-CC3. """"""; optstash = p4util.OptionsState(; ['TRANSQT2', 'WFN'],; ['CCSORT', 'WFN'],; ['CCENERGY', 'WFN'],; ['CCHBAR', 'WFN'],; ['CCEOM', 'WFN']). if (name.lower() == 'eom-ccsd'):; psi4.set_local_option('TRANSQT2', 'WFN', 'EOM_CCSD'); psi4.set_local_option('CCSORT', 'WFN', 'EOM_CCSD'); psi4.set_local_option('CCENERGY', 'WFN', 'EOM_CCSD'); psi4.set_local_option('CCHBAR', 'WFN', 'EOM_CCSD'); psi4.set_local_option('CCEOM', 'WFN', 'EOM_CCSD'); run_ccenergy('ccsd', **k",MatchSource.WIKI,psi4manual/4.0b5/_modules/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/proc.html
https://psicode.org/psi4manual/4.0b5/_modules/proc.html:35154,Security,Validat,ValidationError,35154,"L ENERGY'); e_scs_dfmp2 = psi4.get_variable('SCS-MP2 TOTAL ENERGY'). optstash.restore(). if (name.upper() == 'SCS-MP2'):; return e_scs_dfmp2; elif (name.upper() == 'DF-MP2') or (name.upper() == 'DFMP2') or (name.upper() == 'MP2'):; return e_dfmp2. [docs]def run_eom_cc(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; an EOM-CC calculation, namely EOM-CC2, EOM-CCSD, and EOM-CC3. """"""; optstash = p4util.OptionsState(; ['TRANSQT2', 'WFN'],; ['CCSORT', 'WFN'],; ['CCENERGY', 'WFN'],; ['CCHBAR', 'WFN'],; ['CCEOM', 'WFN']). if (name.lower() == 'eom-ccsd'):; psi4.set_local_option('TRANSQT2', 'WFN', 'EOM_CCSD'); psi4.set_local_option('CCSORT', 'WFN', 'EOM_CCSD'); psi4.set_local_option('CCENERGY', 'WFN', 'EOM_CCSD'); psi4.set_local_option('CCHBAR', 'WFN', 'EOM_CCSD'); psi4.set_local_option('CCEOM', 'WFN', 'EOM_CCSD'); run_ccenergy('ccsd', **kwargs); elif (name.lower() == 'eom-cc2'):. user_ref = psi4.get_option('CCENERGY', 'REFERENCE'); if (user_ref != 'RHF') and (user_ref != 'UHF'):; raise ValidationError('Reference %s for EOM-CC2 is not available.' % user_ref). psi4.set_local_option('TRANSQT2', 'WFN', 'EOM_CC2'); psi4.set_local_option('CCSORT', 'WFN', 'EOM_CC2'); psi4.set_local_option('CCENERGY', 'WFN', 'EOM_CC2'); psi4.set_local_option('CCHBAR', 'WFN', 'EOM_CC2'); psi4.set_local_option('CCEOM', 'WFN', 'EOM_CC2'); run_ccenergy('cc2', **kwargs); elif (name.lower() == 'eom-cc3'):; psi4.set_local_option('TRANSQT2', 'WFN', 'EOM_CC3'); psi4.set_local_option('CCSORT', 'WFN', 'EOM_CC3'); psi4.set_local_option('CCENERGY', 'WFN', 'EOM_CC3'); psi4.set_local_option('CCHBAR', 'WFN', 'EOM_CC3'); psi4.set_local_option('CCEOM', 'WFN', 'EOM_CC3'); run_ccenergy('cc3', **kwargs). psi4.cchbar(); psi4.cceom(). optstash.restore(). [docs]def run_eom_cc_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; an EOM-CCSD gradient calculation. """"""; optstash = p4util.OptionsState(; ['CCDENSITY', 'XI'],; ['CCDENSITY', 'ZETA'],; ['CCLAMBDA', 'ZETA'],; ['DE",MatchSource.WIKI,psi4manual/4.0b5/_modules/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/proc.html
https://psicode.org/psi4manual/4.0b5/_modules/proc.html:37103,Security,Validat,ValidationError,37103,"'ZETA'],; ['CCLAMBDA', 'ZETA'],; ['DERTYPE'],; ['CCDENSITY', 'WFN'],; ['CCLAMBDA', 'WFN']). psi4.set_global_option('DERTYPE', 'FIRST'). if (name.lower() == 'eom-ccsd'):; psi4.set_local_option('CCLAMBDA', 'WFN', 'EOM_CCSD'); psi4.set_local_option('CCDENSITY', 'WFN', 'EOM_CCSD'); run_eom_cc(name, **kwargs). psi4.set_local_option('CCLAMBDA', 'ZETA', 'FALSE'); psi4.set_local_option('CCDENSITY', 'ZETA', 'FALSE'); psi4.set_local_option('CCDENSITY', 'XI', 'TRUE'); psi4.cclambda(); psi4.ccdensity(); psi4.set_local_option('CCLAMBDA', 'ZETA', 'TRUE'); psi4.set_local_option('CCDENSITY', 'ZETA', 'TRUE'); psi4.set_local_option('CCDENSITY', 'XI', 'FALSE'); psi4.cclambda(); psi4.ccdensity(); psi4.deriv(). optstash.restore(). [docs]def run_adc(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; an algebraic diagrammatic construction calculation. .. caution:: Get rid of active molecule lines- should be handled in energy. """"""; if (psi4.get_option('ADC', 'REFERENCE') != 'RHF'):; raise ValidationError('ADC requires reference RHF'). # Bypass routine scf if user did something special to get it to converge; if not (('bypass_scf' in kwargs) and yes.match(str(kwargs['bypass_scf']))):; scf_helper(name, **kwargs). return psi4.adc(). [docs]def run_dft(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-functional-theory calculation. """"""; optstash = p4util.OptionsState(; ['SCF', 'DFT_FUNCTIONAL'],; ['SCF', 'REFERENCE'],; ['SCF', 'SCF_TYPE'],; ['DF_BASIS_MP2'],; ['DFMP2', 'MP2_OS_SCALE'],; ['DFMP2', 'MP2_SS_SCALE']). # Alter default algorithm; if not psi4.has_option_changed('SCF', 'SCF_TYPE'):; psi4.set_local_option('SCF', 'SCF_TYPE', 'DF'). psi4.set_local_option('SCF', 'DFT_FUNCTIONAL', name). user_ref = psi4.get_option('SCF', 'REFERENCE'); if (user_ref == 'RHF'):; psi4.set_local_option('SCF', 'REFERENCE', 'RKS'); elif (user_ref == 'UHF'):; psi4.set_local_option('SCF', 'REFERENCE', 'UKS'); elif (user_ref == 'ROHF'):; raise ValidationError('ROHF",MatchSource.WIKI,psi4manual/4.0b5/_modules/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/proc.html
https://psicode.org/psi4manual/4.0b5/_modules/proc.html:38081,Security,Validat,ValidationError,38081,", 'REFERENCE') != 'RHF'):; raise ValidationError('ADC requires reference RHF'). # Bypass routine scf if user did something special to get it to converge; if not (('bypass_scf' in kwargs) and yes.match(str(kwargs['bypass_scf']))):; scf_helper(name, **kwargs). return psi4.adc(). [docs]def run_dft(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-functional-theory calculation. """"""; optstash = p4util.OptionsState(; ['SCF', 'DFT_FUNCTIONAL'],; ['SCF', 'REFERENCE'],; ['SCF', 'SCF_TYPE'],; ['DF_BASIS_MP2'],; ['DFMP2', 'MP2_OS_SCALE'],; ['DFMP2', 'MP2_SS_SCALE']). # Alter default algorithm; if not psi4.has_option_changed('SCF', 'SCF_TYPE'):; psi4.set_local_option('SCF', 'SCF_TYPE', 'DF'). psi4.set_local_option('SCF', 'DFT_FUNCTIONAL', name). user_ref = psi4.get_option('SCF', 'REFERENCE'); if (user_ref == 'RHF'):; psi4.set_local_option('SCF', 'REFERENCE', 'RKS'); elif (user_ref == 'UHF'):; psi4.set_local_option('SCF', 'REFERENCE', 'UKS'); elif (user_ref == 'ROHF'):; raise ValidationError('ROHF reference for DFT is not available.'); elif (user_ref == 'CUHF'):; raise ValidationError('CUHF reference for DFT is not available.'). run_scf(name, **kwargs); returnvalue = psi4.get_variable('CURRENT ENERGY'). for ssuper in superfunctional_list():; if ssuper.name().lower() == name.lower():; dfun = ssuper. if dfun.is_c_hybrid():. # if the df_basis_mp2 basis is not set, pick a sensible one.; if psi4.get_global_option('DF_BASIS_MP2') == '':; ribasis = p4util.corresponding_rifit(psi4.get_global_option('BASIS')); if ribasis:; psi4.set_global_option('DF_BASIS_MP2', ribasis); psi4.print_out(' No DF_BASIS_MP2 auxiliary basis selected, defaulting to %s\n' % (ribasis)); else:; raise ValidationError('Keyword DF_BASIS_MP2 is required.'). if dfun.is_c_scs_hybrid():; psi4.set_local_option('DFMP2', 'MP2_OS_SCALE', dfun.c_os_alpha()); psi4.set_local_option('DFMP2', 'MP2_SS_SCALE', dfun.c_ss_alpha()); psi4.dfmp2(); vdh = dfun.c_alpha() * psi4.get_variable('SCS-MP2 CORRE",MatchSource.WIKI,psi4manual/4.0b5/_modules/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/proc.html
https://psicode.org/psi4manual/4.0b5/_modules/proc.html:38176,Security,Validat,ValidationError,38176,"mething special to get it to converge; if not (('bypass_scf' in kwargs) and yes.match(str(kwargs['bypass_scf']))):; scf_helper(name, **kwargs). return psi4.adc(). [docs]def run_dft(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-functional-theory calculation. """"""; optstash = p4util.OptionsState(; ['SCF', 'DFT_FUNCTIONAL'],; ['SCF', 'REFERENCE'],; ['SCF', 'SCF_TYPE'],; ['DF_BASIS_MP2'],; ['DFMP2', 'MP2_OS_SCALE'],; ['DFMP2', 'MP2_SS_SCALE']). # Alter default algorithm; if not psi4.has_option_changed('SCF', 'SCF_TYPE'):; psi4.set_local_option('SCF', 'SCF_TYPE', 'DF'). psi4.set_local_option('SCF', 'DFT_FUNCTIONAL', name). user_ref = psi4.get_option('SCF', 'REFERENCE'); if (user_ref == 'RHF'):; psi4.set_local_option('SCF', 'REFERENCE', 'RKS'); elif (user_ref == 'UHF'):; psi4.set_local_option('SCF', 'REFERENCE', 'UKS'); elif (user_ref == 'ROHF'):; raise ValidationError('ROHF reference for DFT is not available.'); elif (user_ref == 'CUHF'):; raise ValidationError('CUHF reference for DFT is not available.'). run_scf(name, **kwargs); returnvalue = psi4.get_variable('CURRENT ENERGY'). for ssuper in superfunctional_list():; if ssuper.name().lower() == name.lower():; dfun = ssuper. if dfun.is_c_hybrid():. # if the df_basis_mp2 basis is not set, pick a sensible one.; if psi4.get_global_option('DF_BASIS_MP2') == '':; ribasis = p4util.corresponding_rifit(psi4.get_global_option('BASIS')); if ribasis:; psi4.set_global_option('DF_BASIS_MP2', ribasis); psi4.print_out(' No DF_BASIS_MP2 auxiliary basis selected, defaulting to %s\n' % (ribasis)); else:; raise ValidationError('Keyword DF_BASIS_MP2 is required.'). if dfun.is_c_scs_hybrid():; psi4.set_local_option('DFMP2', 'MP2_OS_SCALE', dfun.c_os_alpha()); psi4.set_local_option('DFMP2', 'MP2_SS_SCALE', dfun.c_ss_alpha()); psi4.dfmp2(); vdh = dfun.c_alpha() * psi4.get_variable('SCS-MP2 CORRELATION ENERGY'). else:; psi4.dfmp2(); vdh = dfun.c_alpha() * psi4.get_variable('MP2 CORRELATION ENERGY'). psi4.set_v",MatchSource.WIKI,psi4manual/4.0b5/_modules/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/proc.html
https://psicode.org/psi4manual/4.0b5/_modules/proc.html:38785,Security,Validat,ValidationError,38785,"_option('SCF', 'SCF_TYPE', 'DF'). psi4.set_local_option('SCF', 'DFT_FUNCTIONAL', name). user_ref = psi4.get_option('SCF', 'REFERENCE'); if (user_ref == 'RHF'):; psi4.set_local_option('SCF', 'REFERENCE', 'RKS'); elif (user_ref == 'UHF'):; psi4.set_local_option('SCF', 'REFERENCE', 'UKS'); elif (user_ref == 'ROHF'):; raise ValidationError('ROHF reference for DFT is not available.'); elif (user_ref == 'CUHF'):; raise ValidationError('CUHF reference for DFT is not available.'). run_scf(name, **kwargs); returnvalue = psi4.get_variable('CURRENT ENERGY'). for ssuper in superfunctional_list():; if ssuper.name().lower() == name.lower():; dfun = ssuper. if dfun.is_c_hybrid():. # if the df_basis_mp2 basis is not set, pick a sensible one.; if psi4.get_global_option('DF_BASIS_MP2') == '':; ribasis = p4util.corresponding_rifit(psi4.get_global_option('BASIS')); if ribasis:; psi4.set_global_option('DF_BASIS_MP2', ribasis); psi4.print_out(' No DF_BASIS_MP2 auxiliary basis selected, defaulting to %s\n' % (ribasis)); else:; raise ValidationError('Keyword DF_BASIS_MP2 is required.'). if dfun.is_c_scs_hybrid():; psi4.set_local_option('DFMP2', 'MP2_OS_SCALE', dfun.c_os_alpha()); psi4.set_local_option('DFMP2', 'MP2_SS_SCALE', dfun.c_ss_alpha()); psi4.dfmp2(); vdh = dfun.c_alpha() * psi4.get_variable('SCS-MP2 CORRELATION ENERGY'). else:; psi4.dfmp2(); vdh = dfun.c_alpha() * psi4.get_variable('MP2 CORRELATION ENERGY'). psi4.set_variable('DOUBLE-HYBRID CORRECTION ENERGY', vdh); returnvalue += vdh; psi4.set_variable('DFT TOTAL ENERGY', returnvalue); psi4.set_variable('CURRENT ENERGY', returnvalue). optstash.restore(). [docs]def run_dft_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-functional-theory gradient calculation. """"""; optstash = p4util.OptionsState(; ['SCF', 'DFT_FUNCTIONAL'],; ['SCF', 'REFERENCE'],; ['SCF', 'SCF_TYPE']). # Alter default algorithm; if not psi4.has_option_changed('SCF', 'SCF_TYPE'):; psi4.set_local_option('SCF', 'SCF_TYPE', 'D",MatchSource.WIKI,psi4manual/4.0b5/_modules/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/proc.html
https://psicode.org/psi4manual/4.0b5/_modules/proc.html:40053,Security,Validat,ValidationError,40053,".get_variable('SCS-MP2 CORRELATION ENERGY'). else:; psi4.dfmp2(); vdh = dfun.c_alpha() * psi4.get_variable('MP2 CORRELATION ENERGY'). psi4.set_variable('DOUBLE-HYBRID CORRECTION ENERGY', vdh); returnvalue += vdh; psi4.set_variable('DFT TOTAL ENERGY', returnvalue); psi4.set_variable('CURRENT ENERGY', returnvalue). optstash.restore(). [docs]def run_dft_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-functional-theory gradient calculation. """"""; optstash = p4util.OptionsState(; ['SCF', 'DFT_FUNCTIONAL'],; ['SCF', 'REFERENCE'],; ['SCF', 'SCF_TYPE']). # Alter default algorithm; if not psi4.has_option_changed('SCF', 'SCF_TYPE'):; psi4.set_local_option('SCF', 'SCF_TYPE', 'DF'). psi4.set_local_option('SCF', 'DFT_FUNCTIONAL', name). user_ref = psi4.get_option('SCF', 'REFERENCE'); if (user_ref == 'RHF'):; psi4.set_local_option('SCF', 'REFERENCE', 'RKS'); elif (user_ref == 'UHF'):; psi4.set_local_option('SCF', 'REFERENCE', 'UKS'); elif (user_ref == 'ROHF'):; raise ValidationError('ROHF reference for DFT is not available.'); elif (user_ref == 'CUHF'):; raise ValidationError('CUHF reference for DFT is not available.'). run_scf_gradient(name, **kwargs). optstash.restore(). [docs]def run_detci(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a configuration interaction calculation, namely FCI,; CIn, MPn, and ZAPTn. """"""; optstash = p4util.OptionsState(; ['TRANSQT2', 'WFN'],; ['DETCI', 'WFN'],; ['DETCI', 'MAX_NUM_VECS'],; ['DETCI', 'MPN_ORDER_SAVE'],; ['DETCI', 'MPN'],; ['DETCI', 'FCI'],; ['DETCI', 'EX_LEVEL']). user_ref = psi4.get_option('DETCI', 'REFERENCE'); if (user_ref != 'RHF') and (user_ref != 'ROHF'):; raise ValidationError('Reference %s for DETCI is not available.' % user_ref). if (name.lower() == 'zapt'):; psi4.set_local_option('TRANSQT2', 'WFN', 'ZAPTN'); psi4.set_local_option('DETCI', 'WFN', 'ZAPTN'); level = kwargs['level']; maxnvect = (level + 1) / 2 + (level + 1) % 2; psi4.set_local_option('DETCI', 'MA",MatchSource.WIKI,psi4manual/4.0b5/_modules/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/proc.html
https://psicode.org/psi4manual/4.0b5/_modules/proc.html:40148,Security,Validat,ValidationError,40148,"RELATION ENERGY'). psi4.set_variable('DOUBLE-HYBRID CORRECTION ENERGY', vdh); returnvalue += vdh; psi4.set_variable('DFT TOTAL ENERGY', returnvalue); psi4.set_variable('CURRENT ENERGY', returnvalue). optstash.restore(). [docs]def run_dft_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-functional-theory gradient calculation. """"""; optstash = p4util.OptionsState(; ['SCF', 'DFT_FUNCTIONAL'],; ['SCF', 'REFERENCE'],; ['SCF', 'SCF_TYPE']). # Alter default algorithm; if not psi4.has_option_changed('SCF', 'SCF_TYPE'):; psi4.set_local_option('SCF', 'SCF_TYPE', 'DF'). psi4.set_local_option('SCF', 'DFT_FUNCTIONAL', name). user_ref = psi4.get_option('SCF', 'REFERENCE'); if (user_ref == 'RHF'):; psi4.set_local_option('SCF', 'REFERENCE', 'RKS'); elif (user_ref == 'UHF'):; psi4.set_local_option('SCF', 'REFERENCE', 'UKS'); elif (user_ref == 'ROHF'):; raise ValidationError('ROHF reference for DFT is not available.'); elif (user_ref == 'CUHF'):; raise ValidationError('CUHF reference for DFT is not available.'). run_scf_gradient(name, **kwargs). optstash.restore(). [docs]def run_detci(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a configuration interaction calculation, namely FCI,; CIn, MPn, and ZAPTn. """"""; optstash = p4util.OptionsState(; ['TRANSQT2', 'WFN'],; ['DETCI', 'WFN'],; ['DETCI', 'MAX_NUM_VECS'],; ['DETCI', 'MPN_ORDER_SAVE'],; ['DETCI', 'MPN'],; ['DETCI', 'FCI'],; ['DETCI', 'EX_LEVEL']). user_ref = psi4.get_option('DETCI', 'REFERENCE'); if (user_ref != 'RHF') and (user_ref != 'ROHF'):; raise ValidationError('Reference %s for DETCI is not available.' % user_ref). if (name.lower() == 'zapt'):; psi4.set_local_option('TRANSQT2', 'WFN', 'ZAPTN'); psi4.set_local_option('DETCI', 'WFN', 'ZAPTN'); level = kwargs['level']; maxnvect = (level + 1) / 2 + (level + 1) % 2; psi4.set_local_option('DETCI', 'MAX_NUM_VECS', maxnvect); if ((level + 1) % 2):; psi4.set_local_option('DETCI', 'MPN_ORDER_SAVE', 2); else:; psi4.set_",MatchSource.WIKI,psi4manual/4.0b5/_modules/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/proc.html
https://psicode.org/psi4manual/4.0b5/_modules/proc.html:40736,Security,Validat,ValidationError,40736,"i4.set_local_option('SCF', 'SCF_TYPE', 'DF'). psi4.set_local_option('SCF', 'DFT_FUNCTIONAL', name). user_ref = psi4.get_option('SCF', 'REFERENCE'); if (user_ref == 'RHF'):; psi4.set_local_option('SCF', 'REFERENCE', 'RKS'); elif (user_ref == 'UHF'):; psi4.set_local_option('SCF', 'REFERENCE', 'UKS'); elif (user_ref == 'ROHF'):; raise ValidationError('ROHF reference for DFT is not available.'); elif (user_ref == 'CUHF'):; raise ValidationError('CUHF reference for DFT is not available.'). run_scf_gradient(name, **kwargs). optstash.restore(). [docs]def run_detci(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a configuration interaction calculation, namely FCI,; CIn, MPn, and ZAPTn. """"""; optstash = p4util.OptionsState(; ['TRANSQT2', 'WFN'],; ['DETCI', 'WFN'],; ['DETCI', 'MAX_NUM_VECS'],; ['DETCI', 'MPN_ORDER_SAVE'],; ['DETCI', 'MPN'],; ['DETCI', 'FCI'],; ['DETCI', 'EX_LEVEL']). user_ref = psi4.get_option('DETCI', 'REFERENCE'); if (user_ref != 'RHF') and (user_ref != 'ROHF'):; raise ValidationError('Reference %s for DETCI is not available.' % user_ref). if (name.lower() == 'zapt'):; psi4.set_local_option('TRANSQT2', 'WFN', 'ZAPTN'); psi4.set_local_option('DETCI', 'WFN', 'ZAPTN'); level = kwargs['level']; maxnvect = (level + 1) / 2 + (level + 1) % 2; psi4.set_local_option('DETCI', 'MAX_NUM_VECS', maxnvect); if ((level + 1) % 2):; psi4.set_local_option('DETCI', 'MPN_ORDER_SAVE', 2); else:; psi4.set_local_option('DETCI', 'MPN_ORDER_SAVE', 1); elif (name.lower() == 'detci-mp') or (name.lower() == 'mp'):; psi4.set_local_option('TRANSQT2', 'WFN', 'DETCI'); psi4.set_local_option('DETCI', 'WFN', 'DETCI'); psi4.set_local_option('DETCI', 'MPN', 'TRUE'). level = kwargs['level']; maxnvect = (level + 1) / 2 + (level + 1) % 2; psi4.set_local_option('DETCI', 'MAX_NUM_VECS', maxnvect); if ((level + 1) % 2):; psi4.set_local_option('DETCI', 'MPN_ORDER_SAVE', 2); else:; psi4.set_local_option('DETCI', 'MPN_ORDER_SAVE', 1); elif (name.lower() == 'fci'):; psi4.set_local",MatchSource.WIKI,psi4manual/4.0b5/_modules/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/proc.html
https://psicode.org/psi4manual/4.0b5/_modules/proc.html:44382,Security,Validat,ValidationError,44382,"lgorithm; if not psi4.has_option_changed('SCF', 'SCF_TYPE'):; psi4.set_local_option('SCF', 'SCF_TYPE', 'DF'). if 'restart_file' in kwargs:; restartfile = kwargs.pop('restart_file'); # Rename the checkpoint file to be consistent with psi4's file system; psioh = psi4.IOManager.shared_object(); psio = psi4.IO.shared_object(); filepath = psioh.get_file_path(32); namespace = psio.get_default_namespace(); pid = str(os.getpid()); prefix = 'psi'; targetfile = filepath + prefix + '.' + pid + '.' + namespace + '.32'; if(psi4.me() == 0):; shutil.copy(restartfile, targetfile); else:; scf_helper(name, **kwargs). psi4.print_out('\n'); p4util.banner('DFMP2'); psi4.print_out('\n'). # if the df_basis_mp2 basis is not set, pick a sensible one.; if psi4.get_global_option('DF_BASIS_MP2') == '':; ribasis = p4util.corresponding_rifit(psi4.get_global_option('BASIS')); if ribasis:; psi4.set_global_option('DF_BASIS_MP2', ribasis); psi4.print_out(' No DF_BASIS_MP2 auxiliary basis selected, defaulting to %s\n' % (ribasis)); else:; raise ValidationError('Keyword DF_BASIS_MP2 is required.'). e_dfmp2 = psi4.dfmp2(); e_scs_dfmp2 = psi4.get_variable('SCS-MP2 TOTAL ENERGY'). optstash.restore(). if (name.upper() == 'SCS-MP2'):; return e_scs_dfmp2; elif (name.upper() == 'DF-MP2') or (name.upper() == 'DFMP2') or (name.upper() == 'MP2'):; return e_dfmp2. [docs]def run_psimrcc(name, **kwargs):; """"""Function encoding sequence of PSI module calls for a PSIMRCC computation; using a reference from the MCSCF module. """"""; run_mcscf(name, **kwargs); psi4.psimrcc(); return psi4.get_variable(""CURRENT ENERGY""). [docs]def run_psimrcc_scf(name, **kwargs):; """"""Function encoding sequence of PSI module calls for a PSIMRCC computation; using a reference from the SCF module. """"""; # Bypass routine scf if user did something special to get it to converge; if not (('bypass_scf' in kwargs) and yes.match(str(kwargs['bypass_scf']))):; scf_helper(name, **kwargs). psi4.psimrcc(); return psi4.get_variable(""CURRENT ENERGY""). [docs]d",MatchSource.WIKI,psi4manual/4.0b5/_modules/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/proc.html
https://psicode.org/psi4manual/4.0b5/_modules/proc.html:46092,Security,Validat,ValidationError,46092," using a reference from the SCF module. """"""; # Bypass routine scf if user did something special to get it to converge; if not (('bypass_scf' in kwargs) and yes.match(str(kwargs['bypass_scf']))):; scf_helper(name, **kwargs). psi4.psimrcc(); return psi4.get_variable(""CURRENT ENERGY""). [docs]def run_mp2c(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a coupled MP2 calculation. """"""; optstash = p4util.OptionsState(; ['DF_BASIS_MP2']). molecule = psi4.get_active_molecule(); molecule.update_geometry(); monomerA = molecule.extract_subsets(1, 2); monomerA.set_name('monomerA'); monomerB = molecule.extract_subsets(2, 1); monomerB.set_name('monomerB'). # if the df_basis_mp2 basis is not set, pick a sensible one.; if psi4.get_global_option('DF_BASIS_MP2') == '':; ribasis = p4util.corresponding_rifit(psi4.get_global_option('BASIS')); if ribasis:; psi4.set_global_option('DF_BASIS_MP2', ribasis); psi4.print_out(' No DF_BASIS_MP2 auxiliary basis selected, defaulting to %s\n' % (ribasis)); else:; raise ValidationError('Keyword DF_BASIS_MP2 is required.'). ri = psi4.get_option('SCF', 'SCF_TYPE'); df_ints_io = psi4.get_option('SCF', 'DF_INTS_IO'); # inquire if above at all applies to dfmp2. psi4.IO.set_default_namespace('dimer'); psi4.set_local_option('SCF', 'SAPT', '2-dimer'); psi4.print_out('\n'); p4util.banner('Dimer HF'); psi4.print_out('\n'); psi4.set_global_option('DF_INTS_IO', 'SAVE'); e_dimer = scf_helper('RHF', **kwargs); psi4.print_out('\n'); p4util.banner('Dimer DFMP2'); psi4.print_out('\n'); e_dimer_mp2 = psi4.dfmp2(); psi4.set_global_option('DF_INTS_IO', 'LOAD'). activate(monomerA); if (ri == 'DF'):; psi4.IO.change_file_namespace(97, 'dimer', 'monomerA'); psi4.IO.set_default_namespace('monomerA'); psi4.set_local_option('SCF', 'SAPT', '2-monomer_A'); psi4.print_out('\n'); p4util.banner('Monomer A HF'); psi4.print_out('\n'); e_monomerA = scf_helper('RHF', **kwargs); psi4.print_out('\n'); p4util.banner('Monomer A DFMP2'); psi4.print_out('\n'); e_monom",MatchSource.WIKI,psi4manual/4.0b5/_modules/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/proc.html
https://psicode.org/psi4manual/4.0b5/_modules/proc.html:49011,Security,Validat,ValidationError,49011,"4.set_variable('MP2C DIMER MP2 ENERGY', e_dimer_mp2); psi4.set_variable('MP2C MONOMER A MP2 ENERGY', e_monomerA_mp2); psi4.set_variable('MP2C MONOMER B MP2 ENERGY', e_monomerB_mp2). e_sapt = psi4.sapt(). optstash.restore(); return e_sapt. [docs]def run_sapt(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a SAPT calculation of any level. """"""; optstash = p4util.OptionsState(; ['SCF', 'SCF_TYPE']). # Alter default algorithm; if not psi4.has_option_changed('SCF', 'SCF_TYPE'):; psi4.set_local_option('SCF', 'SCF_TYPE', 'DF'). molecule = psi4.get_active_molecule(); user_pg = molecule.schoenflies_symbol(); molecule.reset_point_group('c1'); molecule.fix_orientation(True); molecule.fix_com(True) # This should always have been set, very dangerous bug here; molecule.update_geometry(); if user_pg != 'c1':; psi4.print_out(' SAPT does not make use of molecular symmetry, further calculations in C1 point group.\n'). if (psi4.get_option('SCF','REFERENCE') != 'RHF' ):; raise ValidationError('SAPT requires requires \""reference rhf\"".'). nfrag = molecule.nfragments(); if nfrag != 2:; raise ValidationError('SAPT requires active molecule to have 2 fragments, not %s.' % (nfrag)). sapt_basis = 'dimer'; if 'sapt_basis' in kwargs:; sapt_basis = kwargs.pop('sapt_basis'); sapt_basis = sapt_basis.lower(). if (sapt_basis == 'dimer'):; #molecule.update_geometry(); monomerA = molecule.extract_subsets(1, 2); monomerA.set_name('monomerA'); monomerB = molecule.extract_subsets(2, 1); monomerB.set_name('monomerB'); elif (sapt_basis == 'monomer'):; #molecule.update_geometry(); monomerA = molecule.extract_subsets(1); monomerA.set_name('monomerA'); monomerB = molecule.extract_subsets(2); monomerB.set_name('monomerB'). ri = psi4.get_option('SCF', 'SCF_TYPE'); df_ints_io = psi4.get_option('SCF', 'DF_INTS_IO'); # inquire if above at all applies to dfmp2. psi4.IO.set_default_namespace('dimer'); psi4.set_local_option('SCF', 'SAPT', '2-dimer'); psi4.print_out('\n'); p4util.banner('Dimer H",MatchSource.WIKI,psi4manual/4.0b5/_modules/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/proc.html
https://psicode.org/psi4manual/4.0b5/_modules/proc.html:49126,Security,Validat,ValidationError,49126,"iable('MP2C MONOMER B MP2 ENERGY', e_monomerB_mp2). e_sapt = psi4.sapt(). optstash.restore(); return e_sapt. [docs]def run_sapt(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a SAPT calculation of any level. """"""; optstash = p4util.OptionsState(; ['SCF', 'SCF_TYPE']). # Alter default algorithm; if not psi4.has_option_changed('SCF', 'SCF_TYPE'):; psi4.set_local_option('SCF', 'SCF_TYPE', 'DF'). molecule = psi4.get_active_molecule(); user_pg = molecule.schoenflies_symbol(); molecule.reset_point_group('c1'); molecule.fix_orientation(True); molecule.fix_com(True) # This should always have been set, very dangerous bug here; molecule.update_geometry(); if user_pg != 'c1':; psi4.print_out(' SAPT does not make use of molecular symmetry, further calculations in C1 point group.\n'). if (psi4.get_option('SCF','REFERENCE') != 'RHF' ):; raise ValidationError('SAPT requires requires \""reference rhf\"".'). nfrag = molecule.nfragments(); if nfrag != 2:; raise ValidationError('SAPT requires active molecule to have 2 fragments, not %s.' % (nfrag)). sapt_basis = 'dimer'; if 'sapt_basis' in kwargs:; sapt_basis = kwargs.pop('sapt_basis'); sapt_basis = sapt_basis.lower(). if (sapt_basis == 'dimer'):; #molecule.update_geometry(); monomerA = molecule.extract_subsets(1, 2); monomerA.set_name('monomerA'); monomerB = molecule.extract_subsets(2, 1); monomerB.set_name('monomerB'); elif (sapt_basis == 'monomer'):; #molecule.update_geometry(); monomerA = molecule.extract_subsets(1); monomerA.set_name('monomerA'); monomerB = molecule.extract_subsets(2); monomerB.set_name('monomerB'). ri = psi4.get_option('SCF', 'SCF_TYPE'); df_ints_io = psi4.get_option('SCF', 'DF_INTS_IO'); # inquire if above at all applies to dfmp2. psi4.IO.set_default_namespace('dimer'); psi4.set_local_option('SCF', 'SAPT', '2-dimer'); psi4.print_out('\n'); p4util.banner('Dimer HF'); psi4.print_out('\n'); if (sapt_basis == 'dimer'):; psi4.set_global_option('DF_INTS_IO', 'SAVE'); e_dimer = scf_helper('RHF', ",MatchSource.WIKI,psi4manual/4.0b5/_modules/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/proc.html
https://psicode.org/psi4manual/4.0b5/_modules/proc.html:52908,Security,Validat,ValidationError,52908,"T2+3'); psi4.set_local_option('SAPT', 'DO_THIRD_ORDER', True); psi4.set_local_option('SAPT', 'DO_CCD_DISP', False); elif (name.lower() == 'sapt2+(ccd)'):; psi4.set_local_option('SAPT', 'SAPT_LEVEL', 'SAPT2+'); psi4.set_local_option('SAPT', 'DO_CCD_DISP', True); elif (name.lower() == 'sapt2+(3)(ccd)'):; psi4.set_local_option('SAPT', 'SAPT_LEVEL', 'SAPT2+3'); psi4.set_local_option('SAPT', 'DO_THIRD_ORDER', False); psi4.set_local_option('SAPT', 'DO_CCD_DISP', True); elif (name.lower() == 'sapt2+3(ccd)'):; psi4.set_local_option('SAPT', 'SAPT_LEVEL', 'SAPT2+3'); psi4.set_local_option('SAPT', 'DO_THIRD_ORDER', True); psi4.set_local_option('SAPT', 'DO_CCD_DISP', True). # if the df_basis_sapt basis is not set, pick a sensible one.; if psi4.get_global_option('DF_BASIS_SAPT') == '':; ribasis = p4util.corresponding_rifit(psi4.get_global_option('BASIS')); if ribasis:; psi4.set_global_option('DF_BASIS_SAPT', ribasis); psi4.print_out(' No DF_BASIS_SAPT auxiliary basis selected, defaulting to %s\n' % (ribasis)); else:; raise ValidationError('Keyword DF_BASIS_SAPT is required.'). psi4.print_out('\n'); p4util.banner(name.upper()); psi4.print_out('\n'); e_sapt = psi4.sapt(). molecule.reset_point_group(user_pg); molecule.update_geometry(). optstash.restore(); return e_sapt. [docs]def run_sapt_ct(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a charge-transfer SAPT calcuation of any level. """"""; optstash = p4util.OptionsState(; ['SCF', 'SCF_TYPE']). # Alter default algorithm; if not psi4.has_option_changed('SCF', 'SCF_TYPE'):; psi4.set_local_option('SCF', 'SCF_TYPE', 'DF'). molecule = psi4.get_active_molecule(); user_pg = molecule.schoenflies_symbol(); molecule.reset_point_group('c1'); molecule.fix_orientation(True); molecule.update_geometry(); if user_pg != 'c1':; psi4.print_out(' SAPT does not make use of molecular symmetry, further calculations in C1 point group.\n'). if (psi4.get_option('SCF','REFERENCE') != 'RHF' ):; raise ValidationError('SAPT requires req",MatchSource.WIKI,psi4manual/4.0b5/_modules/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/proc.html
https://psicode.org/psi4manual/4.0b5/_modules/proc.html:53849,Security,Validat,ValidationError,53849,"lected, defaulting to %s\n' % (ribasis)); else:; raise ValidationError('Keyword DF_BASIS_SAPT is required.'). psi4.print_out('\n'); p4util.banner(name.upper()); psi4.print_out('\n'); e_sapt = psi4.sapt(). molecule.reset_point_group(user_pg); molecule.update_geometry(). optstash.restore(); return e_sapt. [docs]def run_sapt_ct(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a charge-transfer SAPT calcuation of any level. """"""; optstash = p4util.OptionsState(; ['SCF', 'SCF_TYPE']). # Alter default algorithm; if not psi4.has_option_changed('SCF', 'SCF_TYPE'):; psi4.set_local_option('SCF', 'SCF_TYPE', 'DF'). molecule = psi4.get_active_molecule(); user_pg = molecule.schoenflies_symbol(); molecule.reset_point_group('c1'); molecule.fix_orientation(True); molecule.update_geometry(); if user_pg != 'c1':; psi4.print_out(' SAPT does not make use of molecular symmetry, further calculations in C1 point group.\n'). if (psi4.get_option('SCF','REFERENCE') != 'RHF' ):; raise ValidationError('SAPT requires requires \""reference rhf\"".'). nfrag = molecule.nfragments(); if nfrag != 2:; raise ValidationError('SAPT requires active molecule to have 2 fragments, not %s.' % (nfrag)). monomerA = molecule.extract_subsets(1, 2); monomerA.set_name('monomerA'); monomerB = molecule.extract_subsets(2, 1); monomerB.set_name('monomerB'); molecule.update_geometry(); monomerAm = molecule.extract_subsets(1); monomerAm.set_name('monomerAm'); monomerBm = molecule.extract_subsets(2); monomerBm.set_name('monomerBm'). ri = psi4.get_option('SCF', 'SCF_TYPE'); df_ints_io = psi4.get_option('SCF', 'DF_INTS_IO'); # inquire if above at all applies to dfmp2. psi4.IO.set_default_namespace('dimer'); psi4.set_local_option('SCF', 'SAPT', '2-dimer'); psi4.print_out('\n'); p4util.banner('Dimer HF'); psi4.print_out('\n'); psi4.set_global_option('DF_INTS_IO', 'SAVE'); e_dimer = scf_helper('RHF', **kwargs); psi4.set_global_option('DF_INTS_IO', 'LOAD'). activate(monomerA); if (ri == 'DF'):; psi4.IO.chan",MatchSource.WIKI,psi4manual/4.0b5/_modules/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/proc.html
https://psicode.org/psi4manual/4.0b5/_modules/proc.html:53964,Security,Validat,ValidationError,53964,"; p4util.banner(name.upper()); psi4.print_out('\n'); e_sapt = psi4.sapt(). molecule.reset_point_group(user_pg); molecule.update_geometry(). optstash.restore(); return e_sapt. [docs]def run_sapt_ct(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a charge-transfer SAPT calcuation of any level. """"""; optstash = p4util.OptionsState(; ['SCF', 'SCF_TYPE']). # Alter default algorithm; if not psi4.has_option_changed('SCF', 'SCF_TYPE'):; psi4.set_local_option('SCF', 'SCF_TYPE', 'DF'). molecule = psi4.get_active_molecule(); user_pg = molecule.schoenflies_symbol(); molecule.reset_point_group('c1'); molecule.fix_orientation(True); molecule.update_geometry(); if user_pg != 'c1':; psi4.print_out(' SAPT does not make use of molecular symmetry, further calculations in C1 point group.\n'). if (psi4.get_option('SCF','REFERENCE') != 'RHF' ):; raise ValidationError('SAPT requires requires \""reference rhf\"".'). nfrag = molecule.nfragments(); if nfrag != 2:; raise ValidationError('SAPT requires active molecule to have 2 fragments, not %s.' % (nfrag)). monomerA = molecule.extract_subsets(1, 2); monomerA.set_name('monomerA'); monomerB = molecule.extract_subsets(2, 1); monomerB.set_name('monomerB'); molecule.update_geometry(); monomerAm = molecule.extract_subsets(1); monomerAm.set_name('monomerAm'); monomerBm = molecule.extract_subsets(2); monomerBm.set_name('monomerBm'). ri = psi4.get_option('SCF', 'SCF_TYPE'); df_ints_io = psi4.get_option('SCF', 'DF_INTS_IO'); # inquire if above at all applies to dfmp2. psi4.IO.set_default_namespace('dimer'); psi4.set_local_option('SCF', 'SAPT', '2-dimer'); psi4.print_out('\n'); p4util.banner('Dimer HF'); psi4.print_out('\n'); psi4.set_global_option('DF_INTS_IO', 'SAVE'); e_dimer = scf_helper('RHF', **kwargs); psi4.set_global_option('DF_INTS_IO', 'LOAD'). activate(monomerA); if (ri == 'DF'):; psi4.IO.change_file_namespace(97, 'dimer', 'monomerA'); psi4.IO.set_default_namespace('monomerA'); psi4.set_local_option('SCF', 'SAPT', '2-mon",MatchSource.WIKI,psi4manual/4.0b5/_modules/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/proc.html
https://psicode.org/psi4manual/4.0b5/_modules/proc.html:57746,Security,Validat,ValidationError,57746,"DO_THIRD_ORDER', True); elif (name.lower() == 'sapt2+(ccd)-ct'):; psi4.set_local_option('SAPT', 'SAPT_LEVEL', 'SAPT2+'); psi4.set_local_option('SAPT', 'DO_CCD_DISP', True); elif (name.lower() == 'sapt2+(3)(ccd)-ct'):; psi4.set_local_option('SAPT', 'SAPT_LEVEL', 'SAPT2+3'); psi4.set_local_option('SAPT', 'DO_THIRD_ORDER', False); psi4.set_local_option('SAPT', 'DO_CCD_DISP', True); elif (name.lower() == 'sapt2+3(ccd)-ct'):; psi4.set_local_option('SAPT', 'SAPT_LEVEL', 'SAPT2+3'); psi4.set_local_option('SAPT', 'DO_THIRD_ORDER', True); psi4.set_local_option('SAPT', 'DO_CCD_DISP', True); psi4.print_out('\n'); p4util.banner('SAPT Charge Transfer'); psi4.print_out('\n'). # if the df_basis_sapt basis is not set, pick a sensible one.; if psi4.get_global_option('DF_BASIS_SAPT') == '':; ribasis = p4util.corresponding_rifit(psi4.get_global_option('BASIS')); if ribasis:; psi4.set_global_option('DF_BASIS_SAPT', ribasis); psi4.print_out(' No DF_BASIS_SAPT auxiliary basis selected, defaulting to %s\n' % (ribasis)); else:; raise ValidationError('Keyword DF_BASIS_SAPT is required.'). psi4.print_out('\n'); p4util.banner('Dimer Basis SAPT'); psi4.print_out('\n'); psi4.IO.change_file_namespace(p4const.PSIF_SAPT_MONOMERA, 'monomerA', 'dimer'); psi4.IO.change_file_namespace(p4const.PSIF_SAPT_MONOMERB, 'monomerB', 'dimer'); e_sapt = psi4.sapt(); CTd = psi4.get_variable('SAPT CT ENERGY'). psi4.print_out('\n'); p4util.banner('Monomer Basis SAPT'); psi4.print_out('\n'); psi4.IO.change_file_namespace(p4const.PSIF_SAPT_MONOMERA, 'monomerAm', 'dimer'); psi4.IO.change_file_namespace(p4const.PSIF_SAPT_MONOMERB, 'monomerBm', 'dimer'); e_sapt = psi4.sapt(); CTm = psi4.get_variable('SAPT CT ENERGY'); CT = CTd - CTm. psi4.print_out('\n\n'); psi4.print_out(' SAPT Charge Transfer Analysis\n'); psi4.print_out(' -----------------------------------------------------------------------------\n'); line1 = ' SAPT Induction (Dimer Basis) %10.4lf mH %10.4lf kcal mol^-1\n' % (CTd * 1000.0, CTd * p4const.psi_hartree2",MatchSource.WIKI,psi4manual/4.0b5/_modules/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/proc.html
https://psicode.org/psi4manual/4.0b5/_modules/proc.html:59674,Security,Validat,ValidationError,59674," (CTd * 1000.0, CTd * p4const.psi_hartree2kcalmol); line2 = ' SAPT Induction (Monomer Basis) %10.4lf mH %10.4lf kcal mol^-1\n' % (CTm * 1000.0, CTm * p4const.psi_hartree2kcalmol); line3 = ' SAPT Charge Transfer %10.4lf mH %10.4lf kcal mol^-1\n\n' % (CT * 1000.0, CT * p4const.psi_hartree2kcalmol); psi4.print_out(line1); psi4.print_out(line2); psi4.print_out(line3); psi4.set_variable('SAPT CT ENERGY', CT). molecule.reset_point_group(user_pg); molecule.update_geometry(). optstash.restore(); return e_sapt. [docs]def run_mrcc(name, **kwargs):; """"""Function that prepares environment and input files; for a calculation calling Kallay's MRCC code. """"""; # TODO: Check to see if we really need to run the SCF code.; scf_helper(name, **kwargs); vscf = psi4.get_variable('SCF TOTAL ENERGY'). # The parse_arbitrary_order method provides us the following information; # We require that level be provided. level is a dictionary; # of settings to be passed to psi4.mrcc; if not('level' in kwargs):; raise ValidationError('level parameter was not provided.'). level = kwargs['level']. # Fullname is the string we need to search for in iface; fullname = level['fullname']. # User can provide 'keep' to the method.; # When provided, do not delete the MRCC scratch directory.; keep = False; if 'keep' in kwargs:; keep = kwargs['keep']. # Save current directory location; current_directory = os.getcwd(). # Need to move to the scratch directory, perferrably into a separate directory in that location; psi_io = psi4.IOManager.shared_object(); os.chdir(psi_io.get_default_path()). # Make new directory specifically for mrcc; mrcc_tmpdir = 'mrcc_' + str(os.getpid()); if 'path' in kwargs:; mrcc_tmpdir = kwargs['path']. # Check to see if directory already exists, if not, create.; if os.path.exists(mrcc_tmpdir) == False:; os.mkdir(mrcc_tmpdir). # Move into the new directory; os.chdir(mrcc_tmpdir). # Generate integrals and input file (dumps files to the current directory); psi4.mrcc_generate_input(level). # Load t",MatchSource.WIKI,psi4manual/4.0b5/_modules/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/proc.html
https://psicode.org/psi4manual/4.0b5/_modules/proc.html:64174,Security,Validat,ValidationError,64174,"p the files or the user provided a path, do nothing.; if (keep != False or ('path' in kwargs)):; psi4.print_out('\nMRCC scratch files have been kept.\n'); psi4.print_out('They can be found in ' + mrcc_tmpdir). # Dump iface contents to output; psi4.print_out('\n'); p4util.banner('Full results from MRCC'); psi4.print_out('\n'); psi4.print_out(iface_contents). return e. [docs]def run_fnodfcc(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a DF-CCSD(T) computation. >>> energy('df-ccsd(t)'). """"""; lowername = name.lower(); kwargs = p4util.kwargs_lower(kwargs). # stash user options; optstash = p4util.OptionsState(; ['FNOCC','COMPUTE_TRIPLES'],; ['FNOCC','DFCC'],; ['FNOCC','NAT_ORBS'],; ['FNOCC','RUN_CEPA'],; ['SCF','DF_BASIS_SCF'],; ['SCF','DF_INTS_IO'],; ['SCF','SCF_TYPE']). psi4.set_local_option('FNOCC', 'DFCC', True); psi4.set_local_option('FNOCC', 'RUN_CEPA', False). # throw an exception for open-shells; if (psi4.get_option('SCF','REFERENCE') != 'RHF' ):; raise ValidationError(""Error: %s requires \""reference rhf\""."" % lowername). # override symmetry:; molecule = psi4.get_active_molecule(); user_pg = molecule.schoenflies_symbol(); molecule.reset_point_group('c1'); molecule.fix_orientation(1); molecule.update_geometry(); if user_pg != 'c1':; psi4.print_out(' FNOCC does not make use of molecular symmetry, further calculations in C1 point group.\n'). # hack to ensure puream (or not) throughout; psi4.set_global_option('PUREAM', psi4.MintsHelper().basisset().has_puream()). # triples?; if (lowername == 'df-ccsd'):; psi4.set_local_option('FNOCC', 'COMPUTE_TRIPLES', False); if (lowername == 'df-ccsd(t)'):; psi4.set_local_option('FNOCC', 'COMPUTE_TRIPLES', True); if (lowername == 'fno-df-ccsd'):; psi4.set_local_option('FNOCC', 'COMPUTE_TRIPLES', False); psi4.set_local_option('FNOCC', 'NAT_ORBS', True); if (lowername == 'fno-df-ccsd(t)'):; psi4.set_local_option('FNOCC', 'COMPUTE_TRIPLES', True); psi4.set_local_option('FNOCC', 'NAT_ORBS', True). # set scf-t",MatchSource.WIKI,psi4manual/4.0b5/_modules/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/proc.html
https://psicode.org/psi4manual/4.0b5/_modules/proc.html:65422,Security,Validat,ValidationError,65422,"on(1); molecule.update_geometry(); if user_pg != 'c1':; psi4.print_out(' FNOCC does not make use of molecular symmetry, further calculations in C1 point group.\n'). # hack to ensure puream (or not) throughout; psi4.set_global_option('PUREAM', psi4.MintsHelper().basisset().has_puream()). # triples?; if (lowername == 'df-ccsd'):; psi4.set_local_option('FNOCC', 'COMPUTE_TRIPLES', False); if (lowername == 'df-ccsd(t)'):; psi4.set_local_option('FNOCC', 'COMPUTE_TRIPLES', True); if (lowername == 'fno-df-ccsd'):; psi4.set_local_option('FNOCC', 'COMPUTE_TRIPLES', False); psi4.set_local_option('FNOCC', 'NAT_ORBS', True); if (lowername == 'fno-df-ccsd(t)'):; psi4.set_local_option('FNOCC', 'COMPUTE_TRIPLES', True); psi4.set_local_option('FNOCC', 'NAT_ORBS', True). # set scf-type to df unless the user wants something else; if psi4.has_option_changed('SCF','SCF_TYPE') == False:; psi4.set_global_option('SCF_TYPE', 'DF'). scf_type = psi4.get_option('SCF','SCF_TYPE'); if ( scf_type != 'CD' and scf_type != 'DF' ):; raise ValidationError(""Invalid scf_type for DFCC.""). # save DF or CD ints generated by SCF for use in CC; psi4.set_local_option('SCF','DF_INTS_IO', 'SAVE'). # the default auxiliary basis; if psi4.get_option('FNOCC','DF_BASIS_CC') == '':; basis = psi4.get_global_option('BASIS'); dfbasis = p4util.corresponding_rifit(basis); psi4.set_local_option('FNOCC','DF_BASIS_CC',dfbasis). # make sure this module knows what df basis was used in the scf; if ( psi4.get_option('SCF','SCF_TYPE') == ""DF"" ):; df_basis_scf = psi4.get_option('SCF','DF_BASIS_SCF'); if df_basis_scf == '':; basis = psi4.get_global_option('BASIS'); df_basis_scf = p4util.corresponding_jkfit(basis). psi4.set_global_option('DF_BASIS_SCF',df_basis_scf). scf_helper(name,**kwargs). psi4.fnocc(). molecule.reset_point_group(user_pg); molecule.update_geometry(). # restore options; optstash.restore(). return psi4.get_variable(""CURRENT ENERGY""). [docs]def run_fnocc(name, **kwargs):; """"""Function encoding sequence of PSI module",MatchSource.WIKI,psi4manual/4.0b5/_modules/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/proc.html
https://psicode.org/psi4manual/4.0b5/_modules/proc.html:69735,Security,Validat,ValidationError,69735,"CC','COMPUTE_MP4_TRIPLES', True); psi4.set_local_option('FNOCC','COMPUTE_TRIPLES', True); psi4.set_local_option('FNOCC','NAT_ORBS', True); elif (lowername == 'mp4(sdq)'):; psi4.set_local_option('FNOCC','RUN_MP4', True); psi4.set_local_option('FNOCC','COMPUTE_MP4_TRIPLES', False); psi4.set_local_option('FNOCC','COMPUTE_TRIPLES', False); elif (lowername == 'fno-mp4(sdq)'):; psi4.set_local_option('FNOCC','RUN_MP4', True); psi4.set_local_option('FNOCC','COMPUTE_MP4_TRIPLES', False); psi4.set_local_option('FNOCC','COMPUTE_TRIPLES', False); psi4.set_local_option('FNOCC','NAT_ORBS', True); elif (lowername == 'fnocc-mp') and (level == 3):; psi4.set_local_option('FNOCC','RUN_MP3', True); elif (lowername == 'fnocc-mp') and (level == 4):; psi4.set_local_option('FNOCC','RUN_MP4', True); psi4.set_local_option('FNOCC','COMPUTE_MP4_TRIPLES', True); psi4.set_local_option('FNOCC','COMPUTE_TRIPLES', True). # throw an exception for open-shells; if (psi4.get_option('SCF','REFERENCE') != 'RHF' ):; raise ValidationError(""Error: %s requires \""reference rhf\""."" % lowername). # scf; scf_helper(name,**kwargs). # if the scf type is df/cd, then the ao integrals were never written to disk.; if psi4.get_option('SCF', 'SCF_TYPE') == 'DF' or psi4.get_option('SCF', 'SCF_TYPE') == 'CD':; # do we generate 4-index eri's with 3-index ones, or do we want conventional eri's?; if psi4.get_option('FNOCC', 'USE_DF_INTS') == False:; mints = psi4.MintsHelper(); mints.integrals(). # if this is not cim or FNO-CC, run transqt2. otherwise, libtrans will be used; if psi4.get_option('FNOCC','NAT_ORBS') == False and psi4.get_option('FNOCC','RUN_MP2') == False:; if psi4.get_option('FNOCC', 'USE_DF_INTS') == False:; psi4.set_local_option('TRANSQT2', 'WFN', 'CCSD'); psi4.transqt2(). # run ccsd; psi4.fnocc(). # set current correlation energy and total energy. only need to treat mpn here.; if (lowername == 'fnocc-mp') and (level == 3):; emp3 = psi4.get_variable(""MP3 TOTAL ENERGY""); cemp3 = psi4.get_variable(""MP3 CORRELATI",MatchSource.WIKI,psi4manual/4.0b5/_modules/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/proc.html
https://psicode.org/psi4manual/4.0b5/_modules/proc.html:72745,Security,Validat,ValidationError,72745,"URRENT CORRELATION ENERGY"",cemp4); elif (lowername == 'fnocc-mp') and (level == 4):; emp4 = psi4.get_variable(""MP4 TOTAL ENERGY""); cemp4 = psi4.get_variable(""MP4 CORRELATION ENERGY""); psi4.set_variable(""CURRENT ENERGY"",emp4); psi4.set_variable(""CURRENT CORRELATION ENERGY"",cemp4). # restore options; optstash.restore(). return psi4.get_variable(""CURRENT ENERGY""). [docs]def run_cepa(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a cepa-like calculation. >>> energy('cepa(1)'). """"""; lowername = name.lower(); uppername = name.upper(); kwargs = p4util.kwargs_lower(kwargs). # save user options; optstash = p4util.OptionsState(; ['TRANSQT2', 'WFN'],; ['FNOCC', 'NAT_ORBS'],; ['FNOCC', 'RUN_CEPA'],; ['FNOCC', 'USE_DF_INTS'],; ['FNOCC', 'CEPA_NO_SINGLES']). psi4.set_local_option('FNOCC','RUN_CEPA', True); psi4.set_local_option('FNOCC','USE_DF_INTS', False). # what type of cepa?; cepa_level = uppername; if (lowername == 'cepa(2)'):; raise ValidationError(""Error: %s not implemented\n"" % lowername); if (lowername == 'dci'):; cepa_level = 'CISD'; if (lowername == 'sdci'):; cepa_level = 'CISD'. if (lowername == 'fno-cepa(0)'):; cepa_level = 'CEPA(0)'; psi4.set_local_option('FNOCC', 'NAT_ORBS', True); if (lowername == 'fno-cepa(1)'):; psi4.set_local_option('FNOCC', 'NAT_ORBS', True); cepa_level = 'CEPA(1)'; if (lowername == 'fno-cepa(3)'):; psi4.set_local_option('FNOCC', 'NAT_ORBS', True); cepa_level = 'CEPA(3)'; if (lowername == 'fno-acpf'):; psi4.set_local_option('FNOCC', 'NAT_ORBS', True); cepa_level = 'ACPF'; if (lowername == 'fno-aqcc'):; psi4.set_local_option('FNOCC', 'NAT_ORBS', True); cepa_level = 'AQCC'; if (lowername == 'fno-sdci'):; psi4.set_local_option('FNOCC', 'NAT_ORBS', True); cepa_level = 'CISD'; if (lowername == 'fno-dci'):; psi4.set_local_option('FNOCC', 'NAT_ORBS', True); cepa_level = 'CISD'. psi4.set_local_option('FNOCC', 'CEPA_LEVEL', cepa_level). # throw an exception for open-shells; if (psi4.get_option('SCF','REFERENCE') != 'RHF' ):; ra",MatchSource.WIKI,psi4manual/4.0b5/_modules/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/proc.html
https://psicode.org/psi4manual/4.0b5/_modules/proc.html:73785,Security,Validat,ValidationError,73785,"\n"" % lowername); if (lowername == 'dci'):; cepa_level = 'CISD'; if (lowername == 'sdci'):; cepa_level = 'CISD'. if (lowername == 'fno-cepa(0)'):; cepa_level = 'CEPA(0)'; psi4.set_local_option('FNOCC', 'NAT_ORBS', True); if (lowername == 'fno-cepa(1)'):; psi4.set_local_option('FNOCC', 'NAT_ORBS', True); cepa_level = 'CEPA(1)'; if (lowername == 'fno-cepa(3)'):; psi4.set_local_option('FNOCC', 'NAT_ORBS', True); cepa_level = 'CEPA(3)'; if (lowername == 'fno-acpf'):; psi4.set_local_option('FNOCC', 'NAT_ORBS', True); cepa_level = 'ACPF'; if (lowername == 'fno-aqcc'):; psi4.set_local_option('FNOCC', 'NAT_ORBS', True); cepa_level = 'AQCC'; if (lowername == 'fno-sdci'):; psi4.set_local_option('FNOCC', 'NAT_ORBS', True); cepa_level = 'CISD'; if (lowername == 'fno-dci'):; psi4.set_local_option('FNOCC', 'NAT_ORBS', True); cepa_level = 'CISD'. psi4.set_local_option('FNOCC', 'CEPA_LEVEL', cepa_level). # throw an exception for open-shells; if (psi4.get_option('SCF','REFERENCE') != 'RHF' ):; raise ValidationError(""Error: %s requires \""reference rhf\""."" % lowername). psi4.set_local_option('TRANSQT2', 'WFN', 'CCSD'); scf_helper(name, **kwargs). # If the scf type is DF/CD, then the AO integrals were never written to disk; if psi4.get_option('SCF', 'SCF_TYPE') == 'DF' or psi4.get_option('SCF', 'SCF_TYPE') == 'CD':; if psi4.get_option('FNOCC', 'USE_DF_INTS') == False:; mints = psi4.MintsHelper(); mints.integrals(). if psi4.get_option('FNOCC','NAT_ORBS') == False:; if psi4.get_option('FNOCC', 'USE_DF_INTS') == False:; psi4.set_local_option('TRANSQT2', 'WFN', 'CCSD'); psi4.transqt2(). # run cepa; psi4.fnocc(). # one-electron properties; if psi4.get_option('FNOCC', 'DIPMOM'):; if cepa_level == ""CEPA(1)"" or cepa_level == ""CEPA(3)"":; psi4.print_out(""\n""); psi4.print_out("" Error: one-electron properties not implemented for %s\n"" % lowername); psi4.print_out(""\n""); elif psi4.get_option('FNOCC','NAT_ORBS'):; psi4.print_out(""\n""); psi4.print_out("" Error: one-electron properties not implemented f",MatchSource.WIKI,psi4manual/4.0b5/_modules/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/proc.html
https://psicode.org/psi4manual/4.0b5/_modules/proc.html:28176,Usability,simpl,simple,28176,"= psi4.MintsHelper(); mints.integrals(). psi4.set_local_option('TRANSQT2', 'DELETE_TEI', 'false'). while True:; psi4.transqt2(); psi4.ccsort(); psi4.ccenergy(); psi4.print_out('Brueckner convergence check: %d\n' % psi4.get_variable('BRUECKNER CONVERGED')); if (psi4.get_variable('BRUECKNER CONVERGED') == True):; break. optstash.restore(). [docs]def run_bccd_t(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a Brueckner CCD(T) calculation. """"""; optstash = p4util.OptionsState(; ['TRANSQT2', 'WFN'],; ['CCSORT', 'WFN'],; ['CCENERGY', 'WFN'],; ['CCTRIPLES', 'WFN']). psi4.set_local_option('TRANSQT2', 'WFN', 'BCCD_T'); psi4.set_local_option('CCSORT', 'WFN', 'BCCD_T'); psi4.set_local_option('CCENERGY', 'WFN', 'BCCD_T'); psi4.set_local_option('CCTRIPLES', 'WFN', 'BCCD_T'); run_bccd(name, **kwargs); psi4.cctriples(). optstash.restore(). [docs]def run_scf_property(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; SCF calculations. This is a simple alias to :py:func:`~proc.run_scf`; since SCF properties all handled through oeprop. """"""; optstash = p4util.OptionsState(; ['SCF', 'SCF_TYPE']). # Alter default algorithm; if not psi4.has_option_changed('SCF', 'SCF_TYPE'):; psi4.set_local_option('SCF', 'SCF_TYPE', 'DF'). run_scf(name, **kwargs). optstash.restore(). [docs]def run_cc_property(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; all CC property calculations. """"""; oneel_properties = ['dipole', 'quadrupole']; twoel_properties = []; response_properties = ['polarizability', 'rotation', 'roa']; excited_properties = ['oscillator_strength', 'rotational_strength']. one = []; two = []; response = []; excited = []; invalid = []. if 'properties' in kwargs:; properties = kwargs.pop('properties'); properties = p4util.drop_duplicates(properties). for prop in properties:; if prop in oneel_properties:; one.append(prop); elif prop in twoel_properties:; two.append(prop); elif prop in response_properties:; response.append(pro",MatchSource.WIKI,psi4manual/4.0b5/_modules/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/proc.html
https://psicode.org/psi4manual/4.0b5/_modules/psiexceptions.html:1076,Availability,Error,Error,1076,". psiexceptions  PSI4 [beta5] documentation. Navigation. index. modules  . toc  ; PSI4 [beta5]  ; Module code . Source code for psiexceptions; #; #@BEGIN LICENSE; #; # PSI4: an ab initio quantum chemistry software package; #; # This program is free software; you can redistribute it and/or modify; # it under the terms of the GNU General Public License as published by; # the Free Software Foundation; either version 2 of the License, or; # (at your option) any later version.; #; # This program is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU General Public License for more details.; #; # You should have received a copy of the GNU General Public License along; # with this program; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; #@END LICENSE; #. """"""Module with non-generic exceptions classes.""""""; import psi4. [docs]class PsiException(Exception):; """"""Error class for Psi.""""""; pass. [docs]class ValidationError(PsiException):; """"""Error called for problems with the input file. Prints; error message *msg* to standard output stream and output file. """"""; def __init__(self, msg):; PsiException.__init__(self, msg); self.msg = msg; psi4.print_out('\nPsiException: %s\n\n' % (msg)). Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  ; PSI4 [beta5]  ; Module code .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/_modules/psiexceptions.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/psiexceptions.html
https://psicode.org/psi4manual/4.0b5/_modules/psiexceptions.html:1154,Availability,Error,Error,1154,". psiexceptions  PSI4 [beta5] documentation. Navigation. index. modules  . toc  ; PSI4 [beta5]  ; Module code . Source code for psiexceptions; #; #@BEGIN LICENSE; #; # PSI4: an ab initio quantum chemistry software package; #; # This program is free software; you can redistribute it and/or modify; # it under the terms of the GNU General Public License as published by; # the Free Software Foundation; either version 2 of the License, or; # (at your option) any later version.; #; # This program is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU General Public License for more details.; #; # You should have received a copy of the GNU General Public License along; # with this program; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; #@END LICENSE; #. """"""Module with non-generic exceptions classes.""""""; import psi4. [docs]class PsiException(Exception):; """"""Error class for Psi.""""""; pass. [docs]class ValidationError(PsiException):; """"""Error called for problems with the input file. Prints; error message *msg* to standard output stream and output file. """"""; def __init__(self, msg):; PsiException.__init__(self, msg); self.msg = msg; psi4.print_out('\nPsiException: %s\n\n' % (msg)). Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  ; PSI4 [beta5]  ; Module code .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/_modules/psiexceptions.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/psiexceptions.html
https://psicode.org/psi4manual/4.0b5/_modules/psiexceptions.html:1209,Availability,error,error,1209,". psiexceptions  PSI4 [beta5] documentation. Navigation. index. modules  . toc  ; PSI4 [beta5]  ; Module code . Source code for psiexceptions; #; #@BEGIN LICENSE; #; # PSI4: an ab initio quantum chemistry software package; #; # This program is free software; you can redistribute it and/or modify; # it under the terms of the GNU General Public License as published by; # the Free Software Foundation; either version 2 of the License, or; # (at your option) any later version.; #; # This program is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU General Public License for more details.; #; # You should have received a copy of the GNU General Public License along; # with this program; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; #@END LICENSE; #. """"""Module with non-generic exceptions classes.""""""; import psi4. [docs]class PsiException(Exception):; """"""Error class for Psi.""""""; pass. [docs]class ValidationError(PsiException):; """"""Error called for problems with the input file. Prints; error message *msg* to standard output stream and output file. """"""; def __init__(self, msg):; PsiException.__init__(self, msg); self.msg = msg; psi4.print_out('\nPsiException: %s\n\n' % (msg)). Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  ; PSI4 [beta5]  ; Module code .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/_modules/psiexceptions.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/psiexceptions.html
https://psicode.org/psi4manual/4.0b5/_modules/psiexceptions.html:1591,Deployability,update,updated,1591,". psiexceptions  PSI4 [beta5] documentation. Navigation. index. modules  . toc  ; PSI4 [beta5]  ; Module code . Source code for psiexceptions; #; #@BEGIN LICENSE; #; # PSI4: an ab initio quantum chemistry software package; #; # This program is free software; you can redistribute it and/or modify; # it under the terms of the GNU General Public License as published by; # the Free Software Foundation; either version 2 of the License, or; # (at your option) any later version.; #; # This program is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU General Public License for more details.; #; # You should have received a copy of the GNU General Public License along; # with this program; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; #@END LICENSE; #. """"""Module with non-generic exceptions classes.""""""; import psi4. [docs]class PsiException(Exception):; """"""Error class for Psi.""""""; pass. [docs]class ValidationError(PsiException):; """"""Error called for problems with the input file. Prints; error message *msg* to standard output stream and output file. """"""; def __init__(self, msg):; PsiException.__init__(self, msg); self.msg = msg; psi4.print_out('\nPsiException: %s\n\n' % (msg)). Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  ; PSI4 [beta5]  ; Module code .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/_modules/psiexceptions.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/psiexceptions.html
https://psicode.org/psi4manual/4.0b5/_modules/psiexceptions.html:1215,Integrability,message,message,1215,". psiexceptions  PSI4 [beta5] documentation. Navigation. index. modules  . toc  ; PSI4 [beta5]  ; Module code . Source code for psiexceptions; #; #@BEGIN LICENSE; #; # PSI4: an ab initio quantum chemistry software package; #; # This program is free software; you can redistribute it and/or modify; # it under the terms of the GNU General Public License as published by; # the Free Software Foundation; either version 2 of the License, or; # (at your option) any later version.; #; # This program is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU General Public License for more details.; #; # You should have received a copy of the GNU General Public License along; # with this program; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; #@END LICENSE; #. """"""Module with non-generic exceptions classes.""""""; import psi4. [docs]class PsiException(Exception):; """"""Error class for Psi.""""""; pass. [docs]class ValidationError(PsiException):; """"""Error called for problems with the input file. Prints; error message *msg* to standard output stream and output file. """"""; def __init__(self, msg):; PsiException.__init__(self, msg); self.msg = msg; psi4.print_out('\nPsiException: %s\n\n' % (msg)). Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  ; PSI4 [beta5]  ; Module code .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/_modules/psiexceptions.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/psiexceptions.html
https://psicode.org/psi4manual/4.0b5/_modules/psiexceptions.html:1119,Security,Validat,ValidationError,1119,". psiexceptions  PSI4 [beta5] documentation. Navigation. index. modules  . toc  ; PSI4 [beta5]  ; Module code . Source code for psiexceptions; #; #@BEGIN LICENSE; #; # PSI4: an ab initio quantum chemistry software package; #; # This program is free software; you can redistribute it and/or modify; # it under the terms of the GNU General Public License as published by; # the Free Software Foundation; either version 2 of the License, or; # (at your option) any later version.; #; # This program is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU General Public License for more details.; #; # You should have received a copy of the GNU General Public License along; # with this program; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; #@END LICENSE; #. """"""Module with non-generic exceptions classes.""""""; import psi4. [docs]class PsiException(Exception):; """"""Error class for Psi.""""""; pass. [docs]class ValidationError(PsiException):; """"""Error called for problems with the input file. Prints; error message *msg* to standard output stream and output file. """"""; def __init__(self, msg):; PsiException.__init__(self, msg); self.msg = msg; psi4.print_out('\nPsiException: %s\n\n' % (msg)). Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  ; PSI4 [beta5]  ; Module code .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/_modules/psiexceptions.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/psiexceptions.html
https://psicode.org/psi4manual/4.0b5/_modules/pubchem.html:1782,Availability,error,error,1782,"th this program; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; #@END LICENSE; #. from __future__ import print_function; """"""Queries the PubChem database using a compound name (i.e. 1,3,5-hexatriene); to obtain a molecule string that can be passed to Molecule. ::. results = getPubChemObj(""1,3,5-hexatriene""). Results is an array of results from PubChem matches to your query.; for entry in results:; entry[""CID""] => PubChem compound identifer; entry[""IUPAC""] => IUPAC name for the resulting compound; entry[""PubChemObj""] => instance of PubChemObj for this compound. entry[""PubChemObj""].getMoleculeString() => returns a string compatible; with PSI4's Molecule creation. """"""; try:; # Python 2 syntax; from urllib2 import urlopen; from urllib2 import quote; from urllib2 import URLError; except ImportError:; # Python 3 syntax; from urllib.request import urlopen; from urllib.parse import quote; from urllib.error import URLError; import re; import sys. [docs]class PubChemObj(object):. def __init__(self, cid, mf, iupac):; self.url = 'http://pubchem.ncbi.nlm.nih.gov/summary/summary.cgi'; self.cid = cid; self.mf = mf; self.iupac = iupac; self.natom = 0; self.dataSDF = ''. def __str__(self):; return ""%17d %s\n"" % (self.cid, self.iupac). [docs] def getSDF(self):; """"""Function to return the SDF (structure-data file) of the PubChem object.""""""; if (len(self.dataSDF) == 0):; # When completed uncomment the following:; url = self.url + '?cid=' + quote(str(self.cid)) + '&disopt=3DDisplaySDF'; try:; location = urlopen(url); except URLError as e:; msg = ""\tPubchemError\n%s\n\treceived when trying to open\n\t%s\n"" % (str(e), url); msg += ""\tCheck your internet connection, and the above URL, and try again.\n""; raise Exception(msg); print(""\tRetrieved entry for chemical ID %d\n"" % self.cid); self.dataSDF = location.read().decode(sys.getdefaultencoding()); #f = open(""TEST"", ""w""); #f.write(self.dataSDF); return self.dataSDF. [docs",MatchSource.WIKI,psi4manual/4.0b5/_modules/pubchem.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/pubchem.html
https://psicode.org/psi4manual/4.0b5/_modules/pubchem.html:3413,Availability,avail,available,3413," URLError as e:; msg = ""\tPubchemError\n%s\n\treceived when trying to open\n\t%s\n"" % (str(e), url); msg += ""\tCheck your internet connection, and the above URL, and try again.\n""; raise Exception(msg); print(""\tRetrieved entry for chemical ID %d\n"" % self.cid); self.dataSDF = location.read().decode(sys.getdefaultencoding()); #f = open(""TEST"", ""w""); #f.write(self.dataSDF); return self.dataSDF. [docs] def name(self):; """"""Function to return the IUPAC name of the PubChem object.""""""; return self.iupac. [docs] def getCartesian(self):; """"""Function to return a string of the atom symbol and XYZ; coordinates of the PubChem object. """"""; try:; sdfText = self.getSDF(); except Exception as e:; raise e. # Find; # NA NB CONSTANT; # 14 13 0 0 0 0 0 0 0999 V2000; m = re.search(r'^\s*(\d+)\s+(?:\d+\s+){8}V2000$', sdfText, re.MULTILINE); self.natom = 0; if (m):; self.natom = int(m.group(1)). if (self.natom == 0):; raise Exception(""PubchemError\n Cannot find the number of atoms. 3D data doesn't appear\n"" +; ""to be available for %s.\n"" % self.iupac). lines = re.split('\n', sdfText). # 3.7320 -0.2500 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0; NUMBER = ""((?:[-+]?\\d*\\.\\d+(?:[DdEe][-+]?\\d+)?)|(?:[-+]?\\d+\\.\\d*(?:[DdEe][-+]?\\d+)?))""; atom_re = re.compile(r'^\s*' + NUMBER + r'\s+' + NUMBER + r'\s+' + NUMBER + r'\s*(\w+)(?:\s+\d+){12}'). molecule_string = ""PubchemInput\n"". atom_count = 0; for line in lines:; if (not line or line.isspace()):; continue. atom_match = atom_re.match(line); if atom_match:; x = float(atom_match.group(1)); y = float(atom_match.group(2)); z = float(atom_match.group(3)); sym = atom_match.group(4). atom_count = atom_count + 1. molecule_string += ""%s %10.6f %10.6f %10.6f\n"" % (sym, x, y, z). if (atom_count == self.natom):; break. return molecule_string. [docs] def getXYZFile(self):; """"""Function to obtain preferentially a molecule string; through getCartesian() or a query string otherwise. """"""; try:; temp = self.getCartesian(); except Exception as e:; raise; molstr = ""%d\n%s",MatchSource.WIKI,psi4manual/4.0b5/_modules/pubchem.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/pubchem.html
https://psicode.org/psi4manual/4.0b5/_modules/pubchem.html:6324,Deployability,update,updated,6324,"aise; molstr = ""%d\n%s\n%s"" % (self.natom, self.iupac, temp); return molstr. [docs] def getMoleculeString(self):; """"""Function to obtain a molecule string through; getCartesian() or fail.; """"""; try:; return self.getCartesian(); except Exception as e:; return e.message. [docs]def getPubChemResults(name):; """"""Function to query the PubChem database for molecules matching the; input string. Builds a PubChem object if found. """"""; url = 'http://www.ncbi.nlm.nih.gov/sites/entrez?db=pccompound&term=%s&format=text' % quote(name); print(""\tSearching PubChem database for %s"" % (name)); try:; loc = urlopen(url); except URLError as e:; msg = ""\tPubchemError\n%s\n\treceived when trying to open\n\t%s\n"" % (str(e), url); msg += ""\tCheck your internet connection, and the above URL, and try again.\n""; raise Exception(msg); data = loc.read(). ans = []; l = data.find(b""<pre>""); l = data.find(b""\n"", l); i = 1; while(True):; l = data.find(str(""%d. "" % i).encode(sys.getdefaultencoding()), l); if l == -1:; break; tag = b""MF: ""; l = data.find(tag, l) + len(tag); mf = data[l:data.find(b'\n', l)].decode(sys.getdefaultencoding()); tag = b""IUPAC name: ""; l = data.find(tag, l) + len(tag); iupac = data[l:data.find(b'\n', l)].decode(sys.getdefaultencoding()); tag = b""CID:""; l = data.find(tag, l) + len(tag); #if l == 4:; # break; cid = int(data[l:data.find(b""\n"", l)]); l = data.find(b'\t', l) + 1. pubobj = PubChemObj(cid, mf, iupac); ans.append(pubobj); i += 1. print(""\tFound %d results"" % (len(ans))); return ans. if __name__ == ""__main__"":; try:; obj = getPubChemResults(""1-methoxy-4-[(E)-prop-1-enyl]benzene""); #obj = getPubChemResults(""sodium benzenesulfonate""); except Exception as e:; print(e.message). for r in obj:; print(r); print(r.getMoleculeString()). Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  ; PSI4 [beta5]  ; Module code .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/_modules/pubchem.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/pubchem.html
https://psicode.org/psi4manual/4.0b5/_modules/pubchem.html:4641,Integrability,message,message,4641,"pile(r'^\s*' + NUMBER + r'\s+' + NUMBER + r'\s+' + NUMBER + r'\s*(\w+)(?:\s+\d+){12}'). molecule_string = ""PubchemInput\n"". atom_count = 0; for line in lines:; if (not line or line.isspace()):; continue. atom_match = atom_re.match(line); if atom_match:; x = float(atom_match.group(1)); y = float(atom_match.group(2)); z = float(atom_match.group(3)); sym = atom_match.group(4). atom_count = atom_count + 1. molecule_string += ""%s %10.6f %10.6f %10.6f\n"" % (sym, x, y, z). if (atom_count == self.natom):; break. return molecule_string. [docs] def getXYZFile(self):; """"""Function to obtain preferentially a molecule string; through getCartesian() or a query string otherwise. """"""; try:; temp = self.getCartesian(); except Exception as e:; raise; molstr = ""%d\n%s\n%s"" % (self.natom, self.iupac, temp); return molstr. [docs] def getMoleculeString(self):; """"""Function to obtain a molecule string through; getCartesian() or fail.; """"""; try:; return self.getCartesian(); except Exception as e:; return e.message. [docs]def getPubChemResults(name):; """"""Function to query the PubChem database for molecules matching the; input string. Builds a PubChem object if found. """"""; url = 'http://www.ncbi.nlm.nih.gov/sites/entrez?db=pccompound&term=%s&format=text' % quote(name); print(""\tSearching PubChem database for %s"" % (name)); try:; loc = urlopen(url); except URLError as e:; msg = ""\tPubchemError\n%s\n\treceived when trying to open\n\t%s\n"" % (str(e), url); msg += ""\tCheck your internet connection, and the above URL, and try again.\n""; raise Exception(msg); data = loc.read(). ans = []; l = data.find(b""<pre>""); l = data.find(b""\n"", l); i = 1; while(True):; l = data.find(str(""%d. "" % i).encode(sys.getdefaultencoding()), l); if l == -1:; break; tag = b""MF: ""; l = data.find(tag, l) + len(tag); mf = data[l:data.find(b'\n', l)].decode(sys.getdefaultencoding()); tag = b""IUPAC name: ""; l = data.find(tag, l) + len(tag); iupac = data[l:data.find(b'\n', l)].decode(sys.getdefaultencoding()); tag = b""CID:""; l ",MatchSource.WIKI,psi4manual/4.0b5/_modules/pubchem.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/pubchem.html
https://psicode.org/psi4manual/4.0b5/_modules/pubchem.html:6071,Integrability,message,message,6071,"aise; molstr = ""%d\n%s\n%s"" % (self.natom, self.iupac, temp); return molstr. [docs] def getMoleculeString(self):; """"""Function to obtain a molecule string through; getCartesian() or fail.; """"""; try:; return self.getCartesian(); except Exception as e:; return e.message. [docs]def getPubChemResults(name):; """"""Function to query the PubChem database for molecules matching the; input string. Builds a PubChem object if found. """"""; url = 'http://www.ncbi.nlm.nih.gov/sites/entrez?db=pccompound&term=%s&format=text' % quote(name); print(""\tSearching PubChem database for %s"" % (name)); try:; loc = urlopen(url); except URLError as e:; msg = ""\tPubchemError\n%s\n\treceived when trying to open\n\t%s\n"" % (str(e), url); msg += ""\tCheck your internet connection, and the above URL, and try again.\n""; raise Exception(msg); data = loc.read(). ans = []; l = data.find(b""<pre>""); l = data.find(b""\n"", l); i = 1; while(True):; l = data.find(str(""%d. "" % i).encode(sys.getdefaultencoding()), l); if l == -1:; break; tag = b""MF: ""; l = data.find(tag, l) + len(tag); mf = data[l:data.find(b'\n', l)].decode(sys.getdefaultencoding()); tag = b""IUPAC name: ""; l = data.find(tag, l) + len(tag); iupac = data[l:data.find(b'\n', l)].decode(sys.getdefaultencoding()); tag = b""CID:""; l = data.find(tag, l) + len(tag); #if l == 4:; # break; cid = int(data[l:data.find(b""\n"", l)]); l = data.find(b'\t', l) + 1. pubobj = PubChemObj(cid, mf, iupac); ans.append(pubobj); i += 1. print(""\tFound %d results"" % (len(ans))); return ans. if __name__ == ""__main__"":; try:; obj = getPubChemResults(""1-methoxy-4-[(E)-prop-1-enyl]benzene""); #obj = getPubChemResults(""sodium benzenesulfonate""); except Exception as e:; print(e.message). for r in obj:; print(r); print(r.getMoleculeString()). Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  ; PSI4 [beta5]  ; Module code .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/_modules/pubchem.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/pubchem.html
https://psicode.org/psi4manual/4.0b5/_modules/pubchem.html:2742,Testability,TEST,TEST,2742,"pen; from urllib.parse import quote; from urllib.error import URLError; import re; import sys. [docs]class PubChemObj(object):. def __init__(self, cid, mf, iupac):; self.url = 'http://pubchem.ncbi.nlm.nih.gov/summary/summary.cgi'; self.cid = cid; self.mf = mf; self.iupac = iupac; self.natom = 0; self.dataSDF = ''. def __str__(self):; return ""%17d %s\n"" % (self.cid, self.iupac). [docs] def getSDF(self):; """"""Function to return the SDF (structure-data file) of the PubChem object.""""""; if (len(self.dataSDF) == 0):; # When completed uncomment the following:; url = self.url + '?cid=' + quote(str(self.cid)) + '&disopt=3DDisplaySDF'; try:; location = urlopen(url); except URLError as e:; msg = ""\tPubchemError\n%s\n\treceived when trying to open\n\t%s\n"" % (str(e), url); msg += ""\tCheck your internet connection, and the above URL, and try again.\n""; raise Exception(msg); print(""\tRetrieved entry for chemical ID %d\n"" % self.cid); self.dataSDF = location.read().decode(sys.getdefaultencoding()); #f = open(""TEST"", ""w""); #f.write(self.dataSDF); return self.dataSDF. [docs] def name(self):; """"""Function to return the IUPAC name of the PubChem object.""""""; return self.iupac. [docs] def getCartesian(self):; """"""Function to return a string of the atom symbol and XYZ; coordinates of the PubChem object. """"""; try:; sdfText = self.getSDF(); except Exception as e:; raise e. # Find; # NA NB CONSTANT; # 14 13 0 0 0 0 0 0 0999 V2000; m = re.search(r'^\s*(\d+)\s+(?:\d+\s+){8}V2000$', sdfText, re.MULTILINE); self.natom = 0; if (m):; self.natom = int(m.group(1)). if (self.natom == 0):; raise Exception(""PubchemError\n Cannot find the number of atoms. 3D data doesn't appear\n"" +; ""to be available for %s.\n"" % self.iupac). lines = re.split('\n', sdfText). # 3.7320 -0.2500 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0; NUMBER = ""((?:[-+]?\\d*\\.\\d+(?:[DdEe][-+]?\\d+)?)|(?:[-+]?\\d+\\.\\d*(?:[DdEe][-+]?\\d+)?))""; atom_re = re.compile(r'^\s*' + NUMBER + r'\s+' + NUMBER + r'\s+' + NUMBER + r'\s*(\w+)(?:\s+\d+){12}'). ",MatchSource.WIKI,psi4manual/4.0b5/_modules/pubchem.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/pubchem.html
https://psicode.org/psi4manual/4.0b5/_modules/qmmm.html:979,Deployability,integrat,integrate,979,". qmmm  PSI4 [beta5] documentation. Navigation. index. modules  . toc  ; PSI4 [beta5]  ; Module code . Source code for qmmm; #; #@BEGIN LICENSE; #; # PSI4: an ab initio quantum chemistry software package; #; # This program is free software; you can redistribute it and/or modify; # it under the terms of the GNU General Public License as published by; # the Free Software Foundation; either version 2 of the License, or; # (at your option) any later version.; #; # This program is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU General Public License for more details.; #; # You should have received a copy of the GNU General Public License along; # with this program; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; #@END LICENSE; #. """"""Module with classes to integrate MM charges into; a QM calculation. """"""; import psi4; import re; import os; import math; import p4const; from molutil import *; from driver import *. [docs]class Diffuse(object):. def __init__(self, molecule, basisname, ribasisname):. self.molecule = molecule; self.basisname = basisname; self.ribasisname = ribasisname; self.basis = None; self.ribasis = None; self.da = None; self.Da = None; self.wfn = None. def __str__(self):. s = ' => Diffuse <=\n\n'; s = s + ' ' + str(self.molecule) + '\n'; s = s + ' ' + self.basisname + '\n'; s = s + ' ' + self.ribasisname + '\n'; s = s + '\n'. return s. [docs] def fitScf(self):; """"""Function to run scf and fit a system of diffuse charges to; resulting density. """"""; basisChanged = psi4.has_option_changed(""BASIS""); ribasisChanged = psi4.has_option_changed(""DF_BASIS_SCF""); scftypeChanged = psi4.has_option_changed(""SCF_TYPE""). basis = psi4.get_option(""BASIS""); ribasis = psi4.get_option(""DF_BASIS_SCF""); scftype = psi4.get_option(""SCF_TYPE""). psi4.print_out("" => Diffus",MatchSource.WIKI,psi4manual/4.0b5/_modules/qmmm.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qmmm.html
https://psicode.org/psi4manual/4.0b5/_modules/qmmm.html:5055,Deployability,update,updated,5055,"lf.Da); self.da = fitter.fit(); self.da.scale(2.0). [docs] def populateExtern(self, extern):; # Electronic Part; extern.addBasis(self.ribasis, self.da); # Nuclear Part; for A in range(0, self.molecule.natom()):; extern.addCharge(self.molecule.Z(A), self.molecule.x(A), self.molecule.y(A), self.molecule.z(A)). [docs]class QMMM(object):. def __init__(self):; self.charges = []; self.diffuses = []; self.extern = psi4.ExternalPotential(). [docs] def addDiffuse(self, diffuse):; """"""Function to add a diffuse charge field *diffuse*.""""""; self.diffuses.append(diffuse). [docs] def addChargeBohr(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Bohr. """"""; self.charges.append([Q, x, y, z]). [docs] def addChargeAngstrom(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Angstroms. """"""; self.charges.append([Q, x / p4const.psi_bohr2angstroms, y / p4const.psi_bohr2angstroms, z / p4const.psi_bohr2angstroms]). def __str__(self):. s = ' ==> QMMM <==\n\n'. s = s + ' => Charges (a.u.) <=\n\n'; s = s + ' %11s %11s %11s %11s\n' % ('Z', 'x', 'y', 'z'); for k in range(0, len(self.charges)):; s = s + ' %11.7f %11.3E %11.3E %11.3E\n' % (self.charges[k][0], self.charges[k][1], self.charges[k][2], self.charges[k][3]); s = s + '\n'. s = s + ' => Diffuses <=\n\n'. for k in range(0, len(self.diffuses)):; s = s + str(self.diffuses[k]). return s. [docs] def populateExtern(self):; """"""Function to define a charge field external to the; molecule through point and diffuse charges. """"""; # Charges; for charge in self.charges:; self.extern.addCharge(charge[0], charge[1], charge[2], charge[3]); # Diffuses; for diffuse in self.diffuses:; diffuse.populateExtern(self.extern). Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  ; PSI4 [beta5]  ; Module code .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/_modules/qmmm.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qmmm.html
https://psicode.org/psi4manual/4.0b5/_modules/qmmm.html:992,Energy Efficiency,charge,charges,992,". qmmm  PSI4 [beta5] documentation. Navigation. index. modules  . toc  ; PSI4 [beta5]  ; Module code . Source code for qmmm; #; #@BEGIN LICENSE; #; # PSI4: an ab initio quantum chemistry software package; #; # This program is free software; you can redistribute it and/or modify; # it under the terms of the GNU General Public License as published by; # the Free Software Foundation; either version 2 of the License, or; # (at your option) any later version.; #; # This program is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU General Public License for more details.; #; # You should have received a copy of the GNU General Public License along; # with this program; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; #@END LICENSE; #. """"""Module with classes to integrate MM charges into; a QM calculation. """"""; import psi4; import re; import os; import math; import p4const; from molutil import *; from driver import *. [docs]class Diffuse(object):. def __init__(self, molecule, basisname, ribasisname):. self.molecule = molecule; self.basisname = basisname; self.ribasisname = ribasisname; self.basis = None; self.ribasis = None; self.da = None; self.Da = None; self.wfn = None. def __str__(self):. s = ' => Diffuse <=\n\n'; s = s + ' ' + str(self.molecule) + '\n'; s = s + ' ' + self.basisname + '\n'; s = s + ' ' + self.ribasisname + '\n'; s = s + '\n'. return s. [docs] def fitScf(self):; """"""Function to run scf and fit a system of diffuse charges to; resulting density. """"""; basisChanged = psi4.has_option_changed(""BASIS""); ribasisChanged = psi4.has_option_changed(""DF_BASIS_SCF""); scftypeChanged = psi4.has_option_changed(""SCF_TYPE""). basis = psi4.get_option(""BASIS""); ribasis = psi4.get_option(""DF_BASIS_SCF""); scftype = psi4.get_option(""SCF_TYPE""). psi4.print_out("" => Diffus",MatchSource.WIKI,psi4manual/4.0b5/_modules/qmmm.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qmmm.html
https://psicode.org/psi4manual/4.0b5/_modules/qmmm.html:1662,Energy Efficiency,charge,charges,1662," PARTICULAR PURPOSE. See the; # GNU General Public License for more details.; #; # You should have received a copy of the GNU General Public License along; # with this program; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; #@END LICENSE; #. """"""Module with classes to integrate MM charges into; a QM calculation. """"""; import psi4; import re; import os; import math; import p4const; from molutil import *; from driver import *. [docs]class Diffuse(object):. def __init__(self, molecule, basisname, ribasisname):. self.molecule = molecule; self.basisname = basisname; self.ribasisname = ribasisname; self.basis = None; self.ribasis = None; self.da = None; self.Da = None; self.wfn = None. def __str__(self):. s = ' => Diffuse <=\n\n'; s = s + ' ' + str(self.molecule) + '\n'; s = s + ' ' + self.basisname + '\n'; s = s + ' ' + self.ribasisname + '\n'; s = s + '\n'. return s. [docs] def fitScf(self):; """"""Function to run scf and fit a system of diffuse charges to; resulting density. """"""; basisChanged = psi4.has_option_changed(""BASIS""); ribasisChanged = psi4.has_option_changed(""DF_BASIS_SCF""); scftypeChanged = psi4.has_option_changed(""SCF_TYPE""). basis = psi4.get_option(""BASIS""); ribasis = psi4.get_option(""DF_BASIS_SCF""); scftype = psi4.get_option(""SCF_TYPE""). psi4.print_out("" => Diffuse SCF (Determines Da) <=\n\n""); activate(self.molecule). psi4.set_global_option(""BASIS"", self.basisname); psi4.set_global_option(""DF_BASIS_SCF"", self.ribasisname); psi4.set_global_option(""SCF_TYPE"", ""DF""); energy('scf'); psi4.print_out(""\n""). self.fitGeneral(). psi4.clean(). psi4.set_global_option(""BASIS"", basis); psi4.set_global_option(""DF_BASIS_SCF"", ribasis); psi4.set_global_option(""SCF_TYPE"", scftype). if not basisChanged:; psi4.revoke_option_changed(""BASIS""); if not ribasisChanged:; psi4.revoke_option_changed(""DF_BASIS_SCF""); if not scftypeChanged:; psi4.revoke_option_changed(""SCF_TYPE""). [docs] def fitGeneral(self):; """"""Fun",MatchSource.WIKI,psi4manual/4.0b5/_modules/qmmm.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qmmm.html
https://psicode.org/psi4manual/4.0b5/_modules/qmmm.html:2207,Energy Efficiency,energy,energy,2207,"asisname, ribasisname):. self.molecule = molecule; self.basisname = basisname; self.ribasisname = ribasisname; self.basis = None; self.ribasis = None; self.da = None; self.Da = None; self.wfn = None. def __str__(self):. s = ' => Diffuse <=\n\n'; s = s + ' ' + str(self.molecule) + '\n'; s = s + ' ' + self.basisname + '\n'; s = s + ' ' + self.ribasisname + '\n'; s = s + '\n'. return s. [docs] def fitScf(self):; """"""Function to run scf and fit a system of diffuse charges to; resulting density. """"""; basisChanged = psi4.has_option_changed(""BASIS""); ribasisChanged = psi4.has_option_changed(""DF_BASIS_SCF""); scftypeChanged = psi4.has_option_changed(""SCF_TYPE""). basis = psi4.get_option(""BASIS""); ribasis = psi4.get_option(""DF_BASIS_SCF""); scftype = psi4.get_option(""SCF_TYPE""). psi4.print_out("" => Diffuse SCF (Determines Da) <=\n\n""); activate(self.molecule). psi4.set_global_option(""BASIS"", self.basisname); psi4.set_global_option(""DF_BASIS_SCF"", self.ribasisname); psi4.set_global_option(""SCF_TYPE"", ""DF""); energy('scf'); psi4.print_out(""\n""). self.fitGeneral(). psi4.clean(). psi4.set_global_option(""BASIS"", basis); psi4.set_global_option(""DF_BASIS_SCF"", ribasis); psi4.set_global_option(""SCF_TYPE"", scftype). if not basisChanged:; psi4.revoke_option_changed(""BASIS""); if not ribasisChanged:; psi4.revoke_option_changed(""DF_BASIS_SCF""); if not scftypeChanged:; psi4.revoke_option_changed(""SCF_TYPE""). [docs] def fitGeneral(self):; """"""Function to perform a general fit of diffuse charges; to wavefunction density. """"""; psi4.print_out("" => Diffuse Charge Fitting (Determines da) <=\n\n""); self.wfn = psi4.wavefunction(); self.Da = self.wfn.Da(); self.basis = self.wfn.basisset(); parser = psi4.Gaussian94BasisSetParser(); self.ribasis = psi4.BasisSet.construct(parser, self.molecule, ""DF_BASIS_SCF""). fitter = psi4.DFChargeFitter(); fitter.setPrimary(self.basis); fitter.setAuxiliary(self.ribasis); fitter.setD(self.Da); self.da = fitter.fit(); self.da.scale(2.0). [docs] def populateExtern(self, ext",MatchSource.WIKI,psi4manual/4.0b5/_modules/qmmm.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qmmm.html
https://psicode.org/psi4manual/4.0b5/_modules/qmmm.html:2680,Energy Efficiency,charge,charges,2680,"fuse charges to; resulting density. """"""; basisChanged = psi4.has_option_changed(""BASIS""); ribasisChanged = psi4.has_option_changed(""DF_BASIS_SCF""); scftypeChanged = psi4.has_option_changed(""SCF_TYPE""). basis = psi4.get_option(""BASIS""); ribasis = psi4.get_option(""DF_BASIS_SCF""); scftype = psi4.get_option(""SCF_TYPE""). psi4.print_out("" => Diffuse SCF (Determines Da) <=\n\n""); activate(self.molecule). psi4.set_global_option(""BASIS"", self.basisname); psi4.set_global_option(""DF_BASIS_SCF"", self.ribasisname); psi4.set_global_option(""SCF_TYPE"", ""DF""); energy('scf'); psi4.print_out(""\n""). self.fitGeneral(). psi4.clean(). psi4.set_global_option(""BASIS"", basis); psi4.set_global_option(""DF_BASIS_SCF"", ribasis); psi4.set_global_option(""SCF_TYPE"", scftype). if not basisChanged:; psi4.revoke_option_changed(""BASIS""); if not ribasisChanged:; psi4.revoke_option_changed(""DF_BASIS_SCF""); if not scftypeChanged:; psi4.revoke_option_changed(""SCF_TYPE""). [docs] def fitGeneral(self):; """"""Function to perform a general fit of diffuse charges; to wavefunction density. """"""; psi4.print_out("" => Diffuse Charge Fitting (Determines da) <=\n\n""); self.wfn = psi4.wavefunction(); self.Da = self.wfn.Da(); self.basis = self.wfn.basisset(); parser = psi4.Gaussian94BasisSetParser(); self.ribasis = psi4.BasisSet.construct(parser, self.molecule, ""DF_BASIS_SCF""). fitter = psi4.DFChargeFitter(); fitter.setPrimary(self.basis); fitter.setAuxiliary(self.ribasis); fitter.setD(self.Da); self.da = fitter.fit(); self.da.scale(2.0). [docs] def populateExtern(self, extern):; # Electronic Part; extern.addBasis(self.ribasis, self.da); # Nuclear Part; for A in range(0, self.molecule.natom()):; extern.addCharge(self.molecule.Z(A), self.molecule.x(A), self.molecule.y(A), self.molecule.z(A)). [docs]class QMMM(object):. def __init__(self):; self.charges = []; self.diffuses = []; self.extern = psi4.ExternalPotential(). [docs] def addDiffuse(self, diffuse):; """"""Function to add a diffuse charge field *diffuse*.""""""; self.diffuse",MatchSource.WIKI,psi4manual/4.0b5/_modules/qmmm.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qmmm.html
https://psicode.org/psi4manual/4.0b5/_modules/qmmm.html:2747,Energy Efficiency,Charge,Charge,2747,"ged = psi4.has_option_changed(""DF_BASIS_SCF""); scftypeChanged = psi4.has_option_changed(""SCF_TYPE""). basis = psi4.get_option(""BASIS""); ribasis = psi4.get_option(""DF_BASIS_SCF""); scftype = psi4.get_option(""SCF_TYPE""). psi4.print_out("" => Diffuse SCF (Determines Da) <=\n\n""); activate(self.molecule). psi4.set_global_option(""BASIS"", self.basisname); psi4.set_global_option(""DF_BASIS_SCF"", self.ribasisname); psi4.set_global_option(""SCF_TYPE"", ""DF""); energy('scf'); psi4.print_out(""\n""). self.fitGeneral(). psi4.clean(). psi4.set_global_option(""BASIS"", basis); psi4.set_global_option(""DF_BASIS_SCF"", ribasis); psi4.set_global_option(""SCF_TYPE"", scftype). if not basisChanged:; psi4.revoke_option_changed(""BASIS""); if not ribasisChanged:; psi4.revoke_option_changed(""DF_BASIS_SCF""); if not scftypeChanged:; psi4.revoke_option_changed(""SCF_TYPE""). [docs] def fitGeneral(self):; """"""Function to perform a general fit of diffuse charges; to wavefunction density. """"""; psi4.print_out("" => Diffuse Charge Fitting (Determines da) <=\n\n""); self.wfn = psi4.wavefunction(); self.Da = self.wfn.Da(); self.basis = self.wfn.basisset(); parser = psi4.Gaussian94BasisSetParser(); self.ribasis = psi4.BasisSet.construct(parser, self.molecule, ""DF_BASIS_SCF""). fitter = psi4.DFChargeFitter(); fitter.setPrimary(self.basis); fitter.setAuxiliary(self.ribasis); fitter.setD(self.Da); self.da = fitter.fit(); self.da.scale(2.0). [docs] def populateExtern(self, extern):; # Electronic Part; extern.addBasis(self.ribasis, self.da); # Nuclear Part; for A in range(0, self.molecule.natom()):; extern.addCharge(self.molecule.Z(A), self.molecule.x(A), self.molecule.y(A), self.molecule.z(A)). [docs]class QMMM(object):. def __init__(self):; self.charges = []; self.diffuses = []; self.extern = psi4.ExternalPotential(). [docs] def addDiffuse(self, diffuse):; """"""Function to add a diffuse charge field *diffuse*.""""""; self.diffuses.append(diffuse). [docs] def addChargeBohr(self, Q, x, y, z):; """"""Function to add a point charge of m",MatchSource.WIKI,psi4manual/4.0b5/_modules/qmmm.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qmmm.html
https://psicode.org/psi4manual/4.0b5/_modules/qmmm.html:3475,Energy Efficiency,charge,charges,3475,"Changed:; psi4.revoke_option_changed(""DF_BASIS_SCF""); if not scftypeChanged:; psi4.revoke_option_changed(""SCF_TYPE""). [docs] def fitGeneral(self):; """"""Function to perform a general fit of diffuse charges; to wavefunction density. """"""; psi4.print_out("" => Diffuse Charge Fitting (Determines da) <=\n\n""); self.wfn = psi4.wavefunction(); self.Da = self.wfn.Da(); self.basis = self.wfn.basisset(); parser = psi4.Gaussian94BasisSetParser(); self.ribasis = psi4.BasisSet.construct(parser, self.molecule, ""DF_BASIS_SCF""). fitter = psi4.DFChargeFitter(); fitter.setPrimary(self.basis); fitter.setAuxiliary(self.ribasis); fitter.setD(self.Da); self.da = fitter.fit(); self.da.scale(2.0). [docs] def populateExtern(self, extern):; # Electronic Part; extern.addBasis(self.ribasis, self.da); # Nuclear Part; for A in range(0, self.molecule.natom()):; extern.addCharge(self.molecule.Z(A), self.molecule.x(A), self.molecule.y(A), self.molecule.z(A)). [docs]class QMMM(object):. def __init__(self):; self.charges = []; self.diffuses = []; self.extern = psi4.ExternalPotential(). [docs] def addDiffuse(self, diffuse):; """"""Function to add a diffuse charge field *diffuse*.""""""; self.diffuses.append(diffuse). [docs] def addChargeBohr(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Bohr. """"""; self.charges.append([Q, x, y, z]). [docs] def addChargeAngstrom(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Angstroms. """"""; self.charges.append([Q, x / p4const.psi_bohr2angstroms, y / p4const.psi_bohr2angstroms, z / p4const.psi_bohr2angstroms]). def __str__(self):. s = ' ==> QMMM <==\n\n'. s = s + ' => Charges (a.u.) <=\n\n'; s = s + ' %11s %11s %11s %11s\n' % ('Z', 'x', 'y', 'z'); for k in range(0, len(self.charges)):; s = s + ' %11.7f %11.3E %11.3E %11.3E\n' % (self.charges[k][0], self.charges[k][1], self.charges[k][2], self.charges[k][3]); s = s + '\n'. s = s + ' => Diffuses <=\n\n'. for k in range(0, len(s",MatchSource.WIKI,psi4manual/4.0b5/_modules/qmmm.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qmmm.html
https://psicode.org/psi4manual/4.0b5/_modules/qmmm.html:3617,Energy Efficiency,charge,charge,3617,"TYPE""). [docs] def fitGeneral(self):; """"""Function to perform a general fit of diffuse charges; to wavefunction density. """"""; psi4.print_out("" => Diffuse Charge Fitting (Determines da) <=\n\n""); self.wfn = psi4.wavefunction(); self.Da = self.wfn.Da(); self.basis = self.wfn.basisset(); parser = psi4.Gaussian94BasisSetParser(); self.ribasis = psi4.BasisSet.construct(parser, self.molecule, ""DF_BASIS_SCF""). fitter = psi4.DFChargeFitter(); fitter.setPrimary(self.basis); fitter.setAuxiliary(self.ribasis); fitter.setD(self.Da); self.da = fitter.fit(); self.da.scale(2.0). [docs] def populateExtern(self, extern):; # Electronic Part; extern.addBasis(self.ribasis, self.da); # Nuclear Part; for A in range(0, self.molecule.natom()):; extern.addCharge(self.molecule.Z(A), self.molecule.x(A), self.molecule.y(A), self.molecule.z(A)). [docs]class QMMM(object):. def __init__(self):; self.charges = []; self.diffuses = []; self.extern = psi4.ExternalPotential(). [docs] def addDiffuse(self, diffuse):; """"""Function to add a diffuse charge field *diffuse*.""""""; self.diffuses.append(diffuse). [docs] def addChargeBohr(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Bohr. """"""; self.charges.append([Q, x, y, z]). [docs] def addChargeAngstrom(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Angstroms. """"""; self.charges.append([Q, x / p4const.psi_bohr2angstroms, y / p4const.psi_bohr2angstroms, z / p4const.psi_bohr2angstroms]). def __str__(self):. s = ' ==> QMMM <==\n\n'. s = s + ' => Charges (a.u.) <=\n\n'; s = s + ' %11s %11s %11s %11s\n' % ('Z', 'x', 'y', 'z'); for k in range(0, len(self.charges)):; s = s + ' %11.7f %11.3E %11.3E %11.3E\n' % (self.charges[k][0], self.charges[k][1], self.charges[k][2], self.charges[k][3]); s = s + '\n'. s = s + ' => Diffuses <=\n\n'. for k in range(0, len(self.diffuses)):; s = s + str(self.diffuses[k]). return s. [docs] def populateExtern(self):; """"""Function to de",MatchSource.WIKI,psi4manual/4.0b5/_modules/qmmm.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qmmm.html
https://psicode.org/psi4manual/4.0b5/_modules/qmmm.html:3748,Energy Efficiency,charge,charge,3748,"iffuse Charge Fitting (Determines da) <=\n\n""); self.wfn = psi4.wavefunction(); self.Da = self.wfn.Da(); self.basis = self.wfn.basisset(); parser = psi4.Gaussian94BasisSetParser(); self.ribasis = psi4.BasisSet.construct(parser, self.molecule, ""DF_BASIS_SCF""). fitter = psi4.DFChargeFitter(); fitter.setPrimary(self.basis); fitter.setAuxiliary(self.ribasis); fitter.setD(self.Da); self.da = fitter.fit(); self.da.scale(2.0). [docs] def populateExtern(self, extern):; # Electronic Part; extern.addBasis(self.ribasis, self.da); # Nuclear Part; for A in range(0, self.molecule.natom()):; extern.addCharge(self.molecule.Z(A), self.molecule.x(A), self.molecule.y(A), self.molecule.z(A)). [docs]class QMMM(object):. def __init__(self):; self.charges = []; self.diffuses = []; self.extern = psi4.ExternalPotential(). [docs] def addDiffuse(self, diffuse):; """"""Function to add a diffuse charge field *diffuse*.""""""; self.diffuses.append(diffuse). [docs] def addChargeBohr(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Bohr. """"""; self.charges.append([Q, x, y, z]). [docs] def addChargeAngstrom(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Angstroms. """"""; self.charges.append([Q, x / p4const.psi_bohr2angstroms, y / p4const.psi_bohr2angstroms, z / p4const.psi_bohr2angstroms]). def __str__(self):. s = ' ==> QMMM <==\n\n'. s = s + ' => Charges (a.u.) <=\n\n'; s = s + ' %11s %11s %11s %11s\n' % ('Z', 'x', 'y', 'z'); for k in range(0, len(self.charges)):; s = s + ' %11.7f %11.3E %11.3E %11.3E\n' % (self.charges[k][0], self.charges[k][1], self.charges[k][2], self.charges[k][3]); s = s + '\n'. s = s + ' => Diffuses <=\n\n'. for k in range(0, len(self.diffuses)):; s = s + str(self.diffuses[k]). return s. [docs] def populateExtern(self):; """"""Function to define a charge field external to the; molecule through point and diffuse charges. """"""; # Charges; for charge in self.charges:; self.extern.addCharge",MatchSource.WIKI,psi4manual/4.0b5/_modules/qmmm.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qmmm.html
https://psicode.org/psi4manual/4.0b5/_modules/qmmm.html:3817,Energy Efficiency,charge,charges,3817,"elf.Da = self.wfn.Da(); self.basis = self.wfn.basisset(); parser = psi4.Gaussian94BasisSetParser(); self.ribasis = psi4.BasisSet.construct(parser, self.molecule, ""DF_BASIS_SCF""). fitter = psi4.DFChargeFitter(); fitter.setPrimary(self.basis); fitter.setAuxiliary(self.ribasis); fitter.setD(self.Da); self.da = fitter.fit(); self.da.scale(2.0). [docs] def populateExtern(self, extern):; # Electronic Part; extern.addBasis(self.ribasis, self.da); # Nuclear Part; for A in range(0, self.molecule.natom()):; extern.addCharge(self.molecule.Z(A), self.molecule.x(A), self.molecule.y(A), self.molecule.z(A)). [docs]class QMMM(object):. def __init__(self):; self.charges = []; self.diffuses = []; self.extern = psi4.ExternalPotential(). [docs] def addDiffuse(self, diffuse):; """"""Function to add a diffuse charge field *diffuse*.""""""; self.diffuses.append(diffuse). [docs] def addChargeBohr(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Bohr. """"""; self.charges.append([Q, x, y, z]). [docs] def addChargeAngstrom(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Angstroms. """"""; self.charges.append([Q, x / p4const.psi_bohr2angstroms, y / p4const.psi_bohr2angstroms, z / p4const.psi_bohr2angstroms]). def __str__(self):. s = ' ==> QMMM <==\n\n'. s = s + ' => Charges (a.u.) <=\n\n'; s = s + ' %11s %11s %11s %11s\n' % ('Z', 'x', 'y', 'z'); for k in range(0, len(self.charges)):; s = s + ' %11.7f %11.3E %11.3E %11.3E\n' % (self.charges[k][0], self.charges[k][1], self.charges[k][2], self.charges[k][3]); s = s + '\n'. s = s + ' => Diffuses <=\n\n'. for k in range(0, len(self.diffuses)):; s = s + str(self.diffuses[k]). return s. [docs] def populateExtern(self):; """"""Function to define a charge field external to the; molecule through point and diffuse charges. """"""; # Charges; for charge in self.charges:; self.extern.addCharge(charge[0], charge[1], charge[2], charge[3]); # Diffuses; for diffuse in self.di",MatchSource.WIKI,psi4manual/4.0b5/_modules/qmmm.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qmmm.html
https://psicode.org/psi4manual/4.0b5/_modules/qmmm.html:3923,Energy Efficiency,charge,charge,3923,"r(); self.ribasis = psi4.BasisSet.construct(parser, self.molecule, ""DF_BASIS_SCF""). fitter = psi4.DFChargeFitter(); fitter.setPrimary(self.basis); fitter.setAuxiliary(self.ribasis); fitter.setD(self.Da); self.da = fitter.fit(); self.da.scale(2.0). [docs] def populateExtern(self, extern):; # Electronic Part; extern.addBasis(self.ribasis, self.da); # Nuclear Part; for A in range(0, self.molecule.natom()):; extern.addCharge(self.molecule.Z(A), self.molecule.x(A), self.molecule.y(A), self.molecule.z(A)). [docs]class QMMM(object):. def __init__(self):; self.charges = []; self.diffuses = []; self.extern = psi4.ExternalPotential(). [docs] def addDiffuse(self, diffuse):; """"""Function to add a diffuse charge field *diffuse*.""""""; self.diffuses.append(diffuse). [docs] def addChargeBohr(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Bohr. """"""; self.charges.append([Q, x, y, z]). [docs] def addChargeAngstrom(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Angstroms. """"""; self.charges.append([Q, x / p4const.psi_bohr2angstroms, y / p4const.psi_bohr2angstroms, z / p4const.psi_bohr2angstroms]). def __str__(self):. s = ' ==> QMMM <==\n\n'. s = s + ' => Charges (a.u.) <=\n\n'; s = s + ' %11s %11s %11s %11s\n' % ('Z', 'x', 'y', 'z'); for k in range(0, len(self.charges)):; s = s + ' %11.7f %11.3E %11.3E %11.3E\n' % (self.charges[k][0], self.charges[k][1], self.charges[k][2], self.charges[k][3]); s = s + '\n'. s = s + ' => Diffuses <=\n\n'. for k in range(0, len(self.diffuses)):; s = s + str(self.diffuses[k]). return s. [docs] def populateExtern(self):; """"""Function to define a charge field external to the; molecule through point and diffuse charges. """"""; # Charges; for charge in self.charges:; self.extern.addCharge(charge[0], charge[1], charge[2], charge[3]); # Diffuses; for diffuse in self.diffuses:; diffuse.populateExtern(self.extern). Quick search. Enter search terms or a module, cla",MatchSource.WIKI,psi4manual/4.0b5/_modules/qmmm.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qmmm.html
https://psicode.org/psi4manual/4.0b5/_modules/qmmm.html:3997,Energy Efficiency,charge,charges,3997,"itter = psi4.DFChargeFitter(); fitter.setPrimary(self.basis); fitter.setAuxiliary(self.ribasis); fitter.setD(self.Da); self.da = fitter.fit(); self.da.scale(2.0). [docs] def populateExtern(self, extern):; # Electronic Part; extern.addBasis(self.ribasis, self.da); # Nuclear Part; for A in range(0, self.molecule.natom()):; extern.addCharge(self.molecule.Z(A), self.molecule.x(A), self.molecule.y(A), self.molecule.z(A)). [docs]class QMMM(object):. def __init__(self):; self.charges = []; self.diffuses = []; self.extern = psi4.ExternalPotential(). [docs] def addDiffuse(self, diffuse):; """"""Function to add a diffuse charge field *diffuse*.""""""; self.diffuses.append(diffuse). [docs] def addChargeBohr(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Bohr. """"""; self.charges.append([Q, x, y, z]). [docs] def addChargeAngstrom(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Angstroms. """"""; self.charges.append([Q, x / p4const.psi_bohr2angstroms, y / p4const.psi_bohr2angstroms, z / p4const.psi_bohr2angstroms]). def __str__(self):. s = ' ==> QMMM <==\n\n'. s = s + ' => Charges (a.u.) <=\n\n'; s = s + ' %11s %11s %11s %11s\n' % ('Z', 'x', 'y', 'z'); for k in range(0, len(self.charges)):; s = s + ' %11.7f %11.3E %11.3E %11.3E\n' % (self.charges[k][0], self.charges[k][1], self.charges[k][2], self.charges[k][3]); s = s + '\n'. s = s + ' => Diffuses <=\n\n'. for k in range(0, len(self.diffuses)):; s = s + str(self.diffuses[k]). return s. [docs] def populateExtern(self):; """"""Function to define a charge field external to the; molecule through point and diffuse charges. """"""; # Charges; for charge in self.charges:; self.extern.addCharge(charge[0], charge[1], charge[2], charge[3]); # Diffuses; for diffuse in self.diffuses:; diffuse.populateExtern(self.extern). Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  ; PSI4 [beta5]  ; Mod",MatchSource.WIKI,psi4manual/4.0b5/_modules/qmmm.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qmmm.html
https://psicode.org/psi4manual/4.0b5/_modules/qmmm.html:4172,Energy Efficiency,Charge,Charges,4172,"lf.Da); self.da = fitter.fit(); self.da.scale(2.0). [docs] def populateExtern(self, extern):; # Electronic Part; extern.addBasis(self.ribasis, self.da); # Nuclear Part; for A in range(0, self.molecule.natom()):; extern.addCharge(self.molecule.Z(A), self.molecule.x(A), self.molecule.y(A), self.molecule.z(A)). [docs]class QMMM(object):. def __init__(self):; self.charges = []; self.diffuses = []; self.extern = psi4.ExternalPotential(). [docs] def addDiffuse(self, diffuse):; """"""Function to add a diffuse charge field *diffuse*.""""""; self.diffuses.append(diffuse). [docs] def addChargeBohr(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Bohr. """"""; self.charges.append([Q, x, y, z]). [docs] def addChargeAngstrom(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Angstroms. """"""; self.charges.append([Q, x / p4const.psi_bohr2angstroms, y / p4const.psi_bohr2angstroms, z / p4const.psi_bohr2angstroms]). def __str__(self):. s = ' ==> QMMM <==\n\n'. s = s + ' => Charges (a.u.) <=\n\n'; s = s + ' %11s %11s %11s %11s\n' % ('Z', 'x', 'y', 'z'); for k in range(0, len(self.charges)):; s = s + ' %11.7f %11.3E %11.3E %11.3E\n' % (self.charges[k][0], self.charges[k][1], self.charges[k][2], self.charges[k][3]); s = s + '\n'. s = s + ' => Diffuses <=\n\n'. for k in range(0, len(self.diffuses)):; s = s + str(self.diffuses[k]). return s. [docs] def populateExtern(self):; """"""Function to define a charge field external to the; molecule through point and diffuse charges. """"""; # Charges; for charge in self.charges:; self.extern.addCharge(charge[0], charge[1], charge[2], charge[3]); # Diffuses; for diffuse in self.diffuses:; diffuse.populateExtern(self.extern). Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  ; PSI4 [beta5]  ; Module code .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/_modules/qmmm.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qmmm.html
https://psicode.org/psi4manual/4.0b5/_modules/qmmm.html:4280,Energy Efficiency,charge,charges,4280,"lf.Da); self.da = fitter.fit(); self.da.scale(2.0). [docs] def populateExtern(self, extern):; # Electronic Part; extern.addBasis(self.ribasis, self.da); # Nuclear Part; for A in range(0, self.molecule.natom()):; extern.addCharge(self.molecule.Z(A), self.molecule.x(A), self.molecule.y(A), self.molecule.z(A)). [docs]class QMMM(object):. def __init__(self):; self.charges = []; self.diffuses = []; self.extern = psi4.ExternalPotential(). [docs] def addDiffuse(self, diffuse):; """"""Function to add a diffuse charge field *diffuse*.""""""; self.diffuses.append(diffuse). [docs] def addChargeBohr(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Bohr. """"""; self.charges.append([Q, x, y, z]). [docs] def addChargeAngstrom(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Angstroms. """"""; self.charges.append([Q, x / p4const.psi_bohr2angstroms, y / p4const.psi_bohr2angstroms, z / p4const.psi_bohr2angstroms]). def __str__(self):. s = ' ==> QMMM <==\n\n'. s = s + ' => Charges (a.u.) <=\n\n'; s = s + ' %11s %11s %11s %11s\n' % ('Z', 'x', 'y', 'z'); for k in range(0, len(self.charges)):; s = s + ' %11.7f %11.3E %11.3E %11.3E\n' % (self.charges[k][0], self.charges[k][1], self.charges[k][2], self.charges[k][3]); s = s + '\n'. s = s + ' => Diffuses <=\n\n'. for k in range(0, len(self.diffuses)):; s = s + str(self.diffuses[k]). return s. [docs] def populateExtern(self):; """"""Function to define a charge field external to the; molecule through point and diffuse charges. """"""; # Charges; for charge in self.charges:; self.extern.addCharge(charge[0], charge[1], charge[2], charge[3]); # Diffuses; for diffuse in self.diffuses:; diffuse.populateExtern(self.extern). Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  ; PSI4 [beta5]  ; Module code .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/_modules/qmmm.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qmmm.html
https://psicode.org/psi4manual/4.0b5/_modules/qmmm.html:4341,Energy Efficiency,charge,charges,4341,"lf.Da); self.da = fitter.fit(); self.da.scale(2.0). [docs] def populateExtern(self, extern):; # Electronic Part; extern.addBasis(self.ribasis, self.da); # Nuclear Part; for A in range(0, self.molecule.natom()):; extern.addCharge(self.molecule.Z(A), self.molecule.x(A), self.molecule.y(A), self.molecule.z(A)). [docs]class QMMM(object):. def __init__(self):; self.charges = []; self.diffuses = []; self.extern = psi4.ExternalPotential(). [docs] def addDiffuse(self, diffuse):; """"""Function to add a diffuse charge field *diffuse*.""""""; self.diffuses.append(diffuse). [docs] def addChargeBohr(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Bohr. """"""; self.charges.append([Q, x, y, z]). [docs] def addChargeAngstrom(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Angstroms. """"""; self.charges.append([Q, x / p4const.psi_bohr2angstroms, y / p4const.psi_bohr2angstroms, z / p4const.psi_bohr2angstroms]). def __str__(self):. s = ' ==> QMMM <==\n\n'. s = s + ' => Charges (a.u.) <=\n\n'; s = s + ' %11s %11s %11s %11s\n' % ('Z', 'x', 'y', 'z'); for k in range(0, len(self.charges)):; s = s + ' %11.7f %11.3E %11.3E %11.3E\n' % (self.charges[k][0], self.charges[k][1], self.charges[k][2], self.charges[k][3]); s = s + '\n'. s = s + ' => Diffuses <=\n\n'. for k in range(0, len(self.diffuses)):; s = s + str(self.diffuses[k]). return s. [docs] def populateExtern(self):; """"""Function to define a charge field external to the; molecule through point and diffuse charges. """"""; # Charges; for charge in self.charges:; self.extern.addCharge(charge[0], charge[1], charge[2], charge[3]); # Diffuses; for diffuse in self.diffuses:; diffuse.populateExtern(self.extern). Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  ; PSI4 [beta5]  ; Module code .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/_modules/qmmm.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qmmm.html
https://psicode.org/psi4manual/4.0b5/_modules/qmmm.html:4361,Energy Efficiency,charge,charges,4361,"lf.Da); self.da = fitter.fit(); self.da.scale(2.0). [docs] def populateExtern(self, extern):; # Electronic Part; extern.addBasis(self.ribasis, self.da); # Nuclear Part; for A in range(0, self.molecule.natom()):; extern.addCharge(self.molecule.Z(A), self.molecule.x(A), self.molecule.y(A), self.molecule.z(A)). [docs]class QMMM(object):. def __init__(self):; self.charges = []; self.diffuses = []; self.extern = psi4.ExternalPotential(). [docs] def addDiffuse(self, diffuse):; """"""Function to add a diffuse charge field *diffuse*.""""""; self.diffuses.append(diffuse). [docs] def addChargeBohr(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Bohr. """"""; self.charges.append([Q, x, y, z]). [docs] def addChargeAngstrom(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Angstroms. """"""; self.charges.append([Q, x / p4const.psi_bohr2angstroms, y / p4const.psi_bohr2angstroms, z / p4const.psi_bohr2angstroms]). def __str__(self):. s = ' ==> QMMM <==\n\n'. s = s + ' => Charges (a.u.) <=\n\n'; s = s + ' %11s %11s %11s %11s\n' % ('Z', 'x', 'y', 'z'); for k in range(0, len(self.charges)):; s = s + ' %11.7f %11.3E %11.3E %11.3E\n' % (self.charges[k][0], self.charges[k][1], self.charges[k][2], self.charges[k][3]); s = s + '\n'. s = s + ' => Diffuses <=\n\n'. for k in range(0, len(self.diffuses)):; s = s + str(self.diffuses[k]). return s. [docs] def populateExtern(self):; """"""Function to define a charge field external to the; molecule through point and diffuse charges. """"""; # Charges; for charge in self.charges:; self.extern.addCharge(charge[0], charge[1], charge[2], charge[3]); # Diffuses; for diffuse in self.diffuses:; diffuse.populateExtern(self.extern). Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  ; PSI4 [beta5]  ; Module code .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/_modules/qmmm.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qmmm.html
https://psicode.org/psi4manual/4.0b5/_modules/qmmm.html:4381,Energy Efficiency,charge,charges,4381,"lf.Da); self.da = fitter.fit(); self.da.scale(2.0). [docs] def populateExtern(self, extern):; # Electronic Part; extern.addBasis(self.ribasis, self.da); # Nuclear Part; for A in range(0, self.molecule.natom()):; extern.addCharge(self.molecule.Z(A), self.molecule.x(A), self.molecule.y(A), self.molecule.z(A)). [docs]class QMMM(object):. def __init__(self):; self.charges = []; self.diffuses = []; self.extern = psi4.ExternalPotential(). [docs] def addDiffuse(self, diffuse):; """"""Function to add a diffuse charge field *diffuse*.""""""; self.diffuses.append(diffuse). [docs] def addChargeBohr(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Bohr. """"""; self.charges.append([Q, x, y, z]). [docs] def addChargeAngstrom(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Angstroms. """"""; self.charges.append([Q, x / p4const.psi_bohr2angstroms, y / p4const.psi_bohr2angstroms, z / p4const.psi_bohr2angstroms]). def __str__(self):. s = ' ==> QMMM <==\n\n'. s = s + ' => Charges (a.u.) <=\n\n'; s = s + ' %11s %11s %11s %11s\n' % ('Z', 'x', 'y', 'z'); for k in range(0, len(self.charges)):; s = s + ' %11.7f %11.3E %11.3E %11.3E\n' % (self.charges[k][0], self.charges[k][1], self.charges[k][2], self.charges[k][3]); s = s + '\n'. s = s + ' => Diffuses <=\n\n'. for k in range(0, len(self.diffuses)):; s = s + str(self.diffuses[k]). return s. [docs] def populateExtern(self):; """"""Function to define a charge field external to the; molecule through point and diffuse charges. """"""; # Charges; for charge in self.charges:; self.extern.addCharge(charge[0], charge[1], charge[2], charge[3]); # Diffuses; for diffuse in self.diffuses:; diffuse.populateExtern(self.extern). Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  ; PSI4 [beta5]  ; Module code .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/_modules/qmmm.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qmmm.html
https://psicode.org/psi4manual/4.0b5/_modules/qmmm.html:4401,Energy Efficiency,charge,charges,4401,"lf.Da); self.da = fitter.fit(); self.da.scale(2.0). [docs] def populateExtern(self, extern):; # Electronic Part; extern.addBasis(self.ribasis, self.da); # Nuclear Part; for A in range(0, self.molecule.natom()):; extern.addCharge(self.molecule.Z(A), self.molecule.x(A), self.molecule.y(A), self.molecule.z(A)). [docs]class QMMM(object):. def __init__(self):; self.charges = []; self.diffuses = []; self.extern = psi4.ExternalPotential(). [docs] def addDiffuse(self, diffuse):; """"""Function to add a diffuse charge field *diffuse*.""""""; self.diffuses.append(diffuse). [docs] def addChargeBohr(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Bohr. """"""; self.charges.append([Q, x, y, z]). [docs] def addChargeAngstrom(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Angstroms. """"""; self.charges.append([Q, x / p4const.psi_bohr2angstroms, y / p4const.psi_bohr2angstroms, z / p4const.psi_bohr2angstroms]). def __str__(self):. s = ' ==> QMMM <==\n\n'. s = s + ' => Charges (a.u.) <=\n\n'; s = s + ' %11s %11s %11s %11s\n' % ('Z', 'x', 'y', 'z'); for k in range(0, len(self.charges)):; s = s + ' %11.7f %11.3E %11.3E %11.3E\n' % (self.charges[k][0], self.charges[k][1], self.charges[k][2], self.charges[k][3]); s = s + '\n'. s = s + ' => Diffuses <=\n\n'. for k in range(0, len(self.diffuses)):; s = s + str(self.diffuses[k]). return s. [docs] def populateExtern(self):; """"""Function to define a charge field external to the; molecule through point and diffuse charges. """"""; # Charges; for charge in self.charges:; self.extern.addCharge(charge[0], charge[1], charge[2], charge[3]); # Diffuses; for diffuse in self.diffuses:; diffuse.populateExtern(self.extern). Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  ; PSI4 [beta5]  ; Module code .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/_modules/qmmm.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qmmm.html
https://psicode.org/psi4manual/4.0b5/_modules/qmmm.html:4601,Energy Efficiency,charge,charge,4601,"lf.Da); self.da = fitter.fit(); self.da.scale(2.0). [docs] def populateExtern(self, extern):; # Electronic Part; extern.addBasis(self.ribasis, self.da); # Nuclear Part; for A in range(0, self.molecule.natom()):; extern.addCharge(self.molecule.Z(A), self.molecule.x(A), self.molecule.y(A), self.molecule.z(A)). [docs]class QMMM(object):. def __init__(self):; self.charges = []; self.diffuses = []; self.extern = psi4.ExternalPotential(). [docs] def addDiffuse(self, diffuse):; """"""Function to add a diffuse charge field *diffuse*.""""""; self.diffuses.append(diffuse). [docs] def addChargeBohr(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Bohr. """"""; self.charges.append([Q, x, y, z]). [docs] def addChargeAngstrom(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Angstroms. """"""; self.charges.append([Q, x / p4const.psi_bohr2angstroms, y / p4const.psi_bohr2angstroms, z / p4const.psi_bohr2angstroms]). def __str__(self):. s = ' ==> QMMM <==\n\n'. s = s + ' => Charges (a.u.) <=\n\n'; s = s + ' %11s %11s %11s %11s\n' % ('Z', 'x', 'y', 'z'); for k in range(0, len(self.charges)):; s = s + ' %11.7f %11.3E %11.3E %11.3E\n' % (self.charges[k][0], self.charges[k][1], self.charges[k][2], self.charges[k][3]); s = s + '\n'. s = s + ' => Diffuses <=\n\n'. for k in range(0, len(self.diffuses)):; s = s + str(self.diffuses[k]). return s. [docs] def populateExtern(self):; """"""Function to define a charge field external to the; molecule through point and diffuse charges. """"""; # Charges; for charge in self.charges:; self.extern.addCharge(charge[0], charge[1], charge[2], charge[3]); # Diffuses; for diffuse in self.diffuses:; diffuse.populateExtern(self.extern). Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  ; PSI4 [beta5]  ; Module code .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/_modules/qmmm.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qmmm.html
https://psicode.org/psi4manual/4.0b5/_modules/qmmm.html:4666,Energy Efficiency,charge,charges,4666,"lf.Da); self.da = fitter.fit(); self.da.scale(2.0). [docs] def populateExtern(self, extern):; # Electronic Part; extern.addBasis(self.ribasis, self.da); # Nuclear Part; for A in range(0, self.molecule.natom()):; extern.addCharge(self.molecule.Z(A), self.molecule.x(A), self.molecule.y(A), self.molecule.z(A)). [docs]class QMMM(object):. def __init__(self):; self.charges = []; self.diffuses = []; self.extern = psi4.ExternalPotential(). [docs] def addDiffuse(self, diffuse):; """"""Function to add a diffuse charge field *diffuse*.""""""; self.diffuses.append(diffuse). [docs] def addChargeBohr(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Bohr. """"""; self.charges.append([Q, x, y, z]). [docs] def addChargeAngstrom(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Angstroms. """"""; self.charges.append([Q, x / p4const.psi_bohr2angstroms, y / p4const.psi_bohr2angstroms, z / p4const.psi_bohr2angstroms]). def __str__(self):. s = ' ==> QMMM <==\n\n'. s = s + ' => Charges (a.u.) <=\n\n'; s = s + ' %11s %11s %11s %11s\n' % ('Z', 'x', 'y', 'z'); for k in range(0, len(self.charges)):; s = s + ' %11.7f %11.3E %11.3E %11.3E\n' % (self.charges[k][0], self.charges[k][1], self.charges[k][2], self.charges[k][3]); s = s + '\n'. s = s + ' => Diffuses <=\n\n'. for k in range(0, len(self.diffuses)):; s = s + str(self.diffuses[k]). return s. [docs] def populateExtern(self):; """"""Function to define a charge field external to the; molecule through point and diffuse charges. """"""; # Charges; for charge in self.charges:; self.extern.addCharge(charge[0], charge[1], charge[2], charge[3]); # Diffuses; for diffuse in self.diffuses:; diffuse.populateExtern(self.extern). Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  ; PSI4 [beta5]  ; Module code .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/_modules/qmmm.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qmmm.html
https://psicode.org/psi4manual/4.0b5/_modules/qmmm.html:4682,Energy Efficiency,Charge,Charges,4682,"lf.Da); self.da = fitter.fit(); self.da.scale(2.0). [docs] def populateExtern(self, extern):; # Electronic Part; extern.addBasis(self.ribasis, self.da); # Nuclear Part; for A in range(0, self.molecule.natom()):; extern.addCharge(self.molecule.Z(A), self.molecule.x(A), self.molecule.y(A), self.molecule.z(A)). [docs]class QMMM(object):. def __init__(self):; self.charges = []; self.diffuses = []; self.extern = psi4.ExternalPotential(). [docs] def addDiffuse(self, diffuse):; """"""Function to add a diffuse charge field *diffuse*.""""""; self.diffuses.append(diffuse). [docs] def addChargeBohr(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Bohr. """"""; self.charges.append([Q, x, y, z]). [docs] def addChargeAngstrom(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Angstroms. """"""; self.charges.append([Q, x / p4const.psi_bohr2angstroms, y / p4const.psi_bohr2angstroms, z / p4const.psi_bohr2angstroms]). def __str__(self):. s = ' ==> QMMM <==\n\n'. s = s + ' => Charges (a.u.) <=\n\n'; s = s + ' %11s %11s %11s %11s\n' % ('Z', 'x', 'y', 'z'); for k in range(0, len(self.charges)):; s = s + ' %11.7f %11.3E %11.3E %11.3E\n' % (self.charges[k][0], self.charges[k][1], self.charges[k][2], self.charges[k][3]); s = s + '\n'. s = s + ' => Diffuses <=\n\n'. for k in range(0, len(self.diffuses)):; s = s + str(self.diffuses[k]). return s. [docs] def populateExtern(self):; """"""Function to define a charge field external to the; molecule through point and diffuse charges. """"""; # Charges; for charge in self.charges:; self.extern.addCharge(charge[0], charge[1], charge[2], charge[3]); # Diffuses; for diffuse in self.diffuses:; diffuse.populateExtern(self.extern). Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  ; PSI4 [beta5]  ; Module code .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/_modules/qmmm.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qmmm.html
https://psicode.org/psi4manual/4.0b5/_modules/qmmm.html:4695,Energy Efficiency,charge,charge,4695,"lf.Da); self.da = fitter.fit(); self.da.scale(2.0). [docs] def populateExtern(self, extern):; # Electronic Part; extern.addBasis(self.ribasis, self.da); # Nuclear Part; for A in range(0, self.molecule.natom()):; extern.addCharge(self.molecule.Z(A), self.molecule.x(A), self.molecule.y(A), self.molecule.z(A)). [docs]class QMMM(object):. def __init__(self):; self.charges = []; self.diffuses = []; self.extern = psi4.ExternalPotential(). [docs] def addDiffuse(self, diffuse):; """"""Function to add a diffuse charge field *diffuse*.""""""; self.diffuses.append(diffuse). [docs] def addChargeBohr(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Bohr. """"""; self.charges.append([Q, x, y, z]). [docs] def addChargeAngstrom(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Angstroms. """"""; self.charges.append([Q, x / p4const.psi_bohr2angstroms, y / p4const.psi_bohr2angstroms, z / p4const.psi_bohr2angstroms]). def __str__(self):. s = ' ==> QMMM <==\n\n'. s = s + ' => Charges (a.u.) <=\n\n'; s = s + ' %11s %11s %11s %11s\n' % ('Z', 'x', 'y', 'z'); for k in range(0, len(self.charges)):; s = s + ' %11.7f %11.3E %11.3E %11.3E\n' % (self.charges[k][0], self.charges[k][1], self.charges[k][2], self.charges[k][3]); s = s + '\n'. s = s + ' => Diffuses <=\n\n'. for k in range(0, len(self.diffuses)):; s = s + str(self.diffuses[k]). return s. [docs] def populateExtern(self):; """"""Function to define a charge field external to the; molecule through point and diffuse charges. """"""; # Charges; for charge in self.charges:; self.extern.addCharge(charge[0], charge[1], charge[2], charge[3]); # Diffuses; for diffuse in self.diffuses:; diffuse.populateExtern(self.extern). Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  ; PSI4 [beta5]  ; Module code .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/_modules/qmmm.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qmmm.html
https://psicode.org/psi4manual/4.0b5/_modules/qmmm.html:4710,Energy Efficiency,charge,charges,4710,"lf.Da); self.da = fitter.fit(); self.da.scale(2.0). [docs] def populateExtern(self, extern):; # Electronic Part; extern.addBasis(self.ribasis, self.da); # Nuclear Part; for A in range(0, self.molecule.natom()):; extern.addCharge(self.molecule.Z(A), self.molecule.x(A), self.molecule.y(A), self.molecule.z(A)). [docs]class QMMM(object):. def __init__(self):; self.charges = []; self.diffuses = []; self.extern = psi4.ExternalPotential(). [docs] def addDiffuse(self, diffuse):; """"""Function to add a diffuse charge field *diffuse*.""""""; self.diffuses.append(diffuse). [docs] def addChargeBohr(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Bohr. """"""; self.charges.append([Q, x, y, z]). [docs] def addChargeAngstrom(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Angstroms. """"""; self.charges.append([Q, x / p4const.psi_bohr2angstroms, y / p4const.psi_bohr2angstroms, z / p4const.psi_bohr2angstroms]). def __str__(self):. s = ' ==> QMMM <==\n\n'. s = s + ' => Charges (a.u.) <=\n\n'; s = s + ' %11s %11s %11s %11s\n' % ('Z', 'x', 'y', 'z'); for k in range(0, len(self.charges)):; s = s + ' %11.7f %11.3E %11.3E %11.3E\n' % (self.charges[k][0], self.charges[k][1], self.charges[k][2], self.charges[k][3]); s = s + '\n'. s = s + ' => Diffuses <=\n\n'. for k in range(0, len(self.diffuses)):; s = s + str(self.diffuses[k]). return s. [docs] def populateExtern(self):; """"""Function to define a charge field external to the; molecule through point and diffuse charges. """"""; # Charges; for charge in self.charges:; self.extern.addCharge(charge[0], charge[1], charge[2], charge[3]); # Diffuses; for diffuse in self.diffuses:; diffuse.populateExtern(self.extern). Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  ; PSI4 [beta5]  ; Module code .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/_modules/qmmm.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qmmm.html
https://psicode.org/psi4manual/4.0b5/_modules/qmmm.html:4742,Energy Efficiency,charge,charge,4742,"lf.Da); self.da = fitter.fit(); self.da.scale(2.0). [docs] def populateExtern(self, extern):; # Electronic Part; extern.addBasis(self.ribasis, self.da); # Nuclear Part; for A in range(0, self.molecule.natom()):; extern.addCharge(self.molecule.Z(A), self.molecule.x(A), self.molecule.y(A), self.molecule.z(A)). [docs]class QMMM(object):. def __init__(self):; self.charges = []; self.diffuses = []; self.extern = psi4.ExternalPotential(). [docs] def addDiffuse(self, diffuse):; """"""Function to add a diffuse charge field *diffuse*.""""""; self.diffuses.append(diffuse). [docs] def addChargeBohr(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Bohr. """"""; self.charges.append([Q, x, y, z]). [docs] def addChargeAngstrom(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Angstroms. """"""; self.charges.append([Q, x / p4const.psi_bohr2angstroms, y / p4const.psi_bohr2angstroms, z / p4const.psi_bohr2angstroms]). def __str__(self):. s = ' ==> QMMM <==\n\n'. s = s + ' => Charges (a.u.) <=\n\n'; s = s + ' %11s %11s %11s %11s\n' % ('Z', 'x', 'y', 'z'); for k in range(0, len(self.charges)):; s = s + ' %11.7f %11.3E %11.3E %11.3E\n' % (self.charges[k][0], self.charges[k][1], self.charges[k][2], self.charges[k][3]); s = s + '\n'. s = s + ' => Diffuses <=\n\n'. for k in range(0, len(self.diffuses)):; s = s + str(self.diffuses[k]). return s. [docs] def populateExtern(self):; """"""Function to define a charge field external to the; molecule through point and diffuse charges. """"""; # Charges; for charge in self.charges:; self.extern.addCharge(charge[0], charge[1], charge[2], charge[3]); # Diffuses; for diffuse in self.diffuses:; diffuse.populateExtern(self.extern). Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  ; PSI4 [beta5]  ; Module code .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/_modules/qmmm.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qmmm.html
https://psicode.org/psi4manual/4.0b5/_modules/qmmm.html:4753,Energy Efficiency,charge,charge,4753,"lf.Da); self.da = fitter.fit(); self.da.scale(2.0). [docs] def populateExtern(self, extern):; # Electronic Part; extern.addBasis(self.ribasis, self.da); # Nuclear Part; for A in range(0, self.molecule.natom()):; extern.addCharge(self.molecule.Z(A), self.molecule.x(A), self.molecule.y(A), self.molecule.z(A)). [docs]class QMMM(object):. def __init__(self):; self.charges = []; self.diffuses = []; self.extern = psi4.ExternalPotential(). [docs] def addDiffuse(self, diffuse):; """"""Function to add a diffuse charge field *diffuse*.""""""; self.diffuses.append(diffuse). [docs] def addChargeBohr(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Bohr. """"""; self.charges.append([Q, x, y, z]). [docs] def addChargeAngstrom(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Angstroms. """"""; self.charges.append([Q, x / p4const.psi_bohr2angstroms, y / p4const.psi_bohr2angstroms, z / p4const.psi_bohr2angstroms]). def __str__(self):. s = ' ==> QMMM <==\n\n'. s = s + ' => Charges (a.u.) <=\n\n'; s = s + ' %11s %11s %11s %11s\n' % ('Z', 'x', 'y', 'z'); for k in range(0, len(self.charges)):; s = s + ' %11.7f %11.3E %11.3E %11.3E\n' % (self.charges[k][0], self.charges[k][1], self.charges[k][2], self.charges[k][3]); s = s + '\n'. s = s + ' => Diffuses <=\n\n'. for k in range(0, len(self.diffuses)):; s = s + str(self.diffuses[k]). return s. [docs] def populateExtern(self):; """"""Function to define a charge field external to the; molecule through point and diffuse charges. """"""; # Charges; for charge in self.charges:; self.extern.addCharge(charge[0], charge[1], charge[2], charge[3]); # Diffuses; for diffuse in self.diffuses:; diffuse.populateExtern(self.extern). Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  ; PSI4 [beta5]  ; Module code .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/_modules/qmmm.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qmmm.html
https://psicode.org/psi4manual/4.0b5/_modules/qmmm.html:4764,Energy Efficiency,charge,charge,4764,"lf.Da); self.da = fitter.fit(); self.da.scale(2.0). [docs] def populateExtern(self, extern):; # Electronic Part; extern.addBasis(self.ribasis, self.da); # Nuclear Part; for A in range(0, self.molecule.natom()):; extern.addCharge(self.molecule.Z(A), self.molecule.x(A), self.molecule.y(A), self.molecule.z(A)). [docs]class QMMM(object):. def __init__(self):; self.charges = []; self.diffuses = []; self.extern = psi4.ExternalPotential(). [docs] def addDiffuse(self, diffuse):; """"""Function to add a diffuse charge field *diffuse*.""""""; self.diffuses.append(diffuse). [docs] def addChargeBohr(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Bohr. """"""; self.charges.append([Q, x, y, z]). [docs] def addChargeAngstrom(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Angstroms. """"""; self.charges.append([Q, x / p4const.psi_bohr2angstroms, y / p4const.psi_bohr2angstroms, z / p4const.psi_bohr2angstroms]). def __str__(self):. s = ' ==> QMMM <==\n\n'. s = s + ' => Charges (a.u.) <=\n\n'; s = s + ' %11s %11s %11s %11s\n' % ('Z', 'x', 'y', 'z'); for k in range(0, len(self.charges)):; s = s + ' %11.7f %11.3E %11.3E %11.3E\n' % (self.charges[k][0], self.charges[k][1], self.charges[k][2], self.charges[k][3]); s = s + '\n'. s = s + ' => Diffuses <=\n\n'. for k in range(0, len(self.diffuses)):; s = s + str(self.diffuses[k]). return s. [docs] def populateExtern(self):; """"""Function to define a charge field external to the; molecule through point and diffuse charges. """"""; # Charges; for charge in self.charges:; self.extern.addCharge(charge[0], charge[1], charge[2], charge[3]); # Diffuses; for diffuse in self.diffuses:; diffuse.populateExtern(self.extern). Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  ; PSI4 [beta5]  ; Module code .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/_modules/qmmm.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qmmm.html
https://psicode.org/psi4manual/4.0b5/_modules/qmmm.html:4775,Energy Efficiency,charge,charge,4775,"lf.Da); self.da = fitter.fit(); self.da.scale(2.0). [docs] def populateExtern(self, extern):; # Electronic Part; extern.addBasis(self.ribasis, self.da); # Nuclear Part; for A in range(0, self.molecule.natom()):; extern.addCharge(self.molecule.Z(A), self.molecule.x(A), self.molecule.y(A), self.molecule.z(A)). [docs]class QMMM(object):. def __init__(self):; self.charges = []; self.diffuses = []; self.extern = psi4.ExternalPotential(). [docs] def addDiffuse(self, diffuse):; """"""Function to add a diffuse charge field *diffuse*.""""""; self.diffuses.append(diffuse). [docs] def addChargeBohr(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Bohr. """"""; self.charges.append([Q, x, y, z]). [docs] def addChargeAngstrom(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Angstroms. """"""; self.charges.append([Q, x / p4const.psi_bohr2angstroms, y / p4const.psi_bohr2angstroms, z / p4const.psi_bohr2angstroms]). def __str__(self):. s = ' ==> QMMM <==\n\n'. s = s + ' => Charges (a.u.) <=\n\n'; s = s + ' %11s %11s %11s %11s\n' % ('Z', 'x', 'y', 'z'); for k in range(0, len(self.charges)):; s = s + ' %11.7f %11.3E %11.3E %11.3E\n' % (self.charges[k][0], self.charges[k][1], self.charges[k][2], self.charges[k][3]); s = s + '\n'. s = s + ' => Diffuses <=\n\n'. for k in range(0, len(self.diffuses)):; s = s + str(self.diffuses[k]). return s. [docs] def populateExtern(self):; """"""Function to define a charge field external to the; molecule through point and diffuse charges. """"""; # Charges; for charge in self.charges:; self.extern.addCharge(charge[0], charge[1], charge[2], charge[3]); # Diffuses; for diffuse in self.diffuses:; diffuse.populateExtern(self.extern). Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  ; PSI4 [beta5]  ; Module code .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/_modules/qmmm.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qmmm.html
https://psicode.org/psi4manual/4.0b5/_modules/qmmm.html:979,Integrability,integrat,integrate,979,". qmmm  PSI4 [beta5] documentation. Navigation. index. modules  . toc  ; PSI4 [beta5]  ; Module code . Source code for qmmm; #; #@BEGIN LICENSE; #; # PSI4: an ab initio quantum chemistry software package; #; # This program is free software; you can redistribute it and/or modify; # it under the terms of the GNU General Public License as published by; # the Free Software Foundation; either version 2 of the License, or; # (at your option) any later version.; #; # This program is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU General Public License for more details.; #; # You should have received a copy of the GNU General Public License along; # with this program; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; #@END LICENSE; #. """"""Module with classes to integrate MM charges into; a QM calculation. """"""; import psi4; import re; import os; import math; import p4const; from molutil import *; from driver import *. [docs]class Diffuse(object):. def __init__(self, molecule, basisname, ribasisname):. self.molecule = molecule; self.basisname = basisname; self.ribasisname = ribasisname; self.basis = None; self.ribasis = None; self.da = None; self.Da = None; self.wfn = None. def __str__(self):. s = ' => Diffuse <=\n\n'; s = s + ' ' + str(self.molecule) + '\n'; s = s + ' ' + self.basisname + '\n'; s = s + ' ' + self.ribasisname + '\n'; s = s + '\n'. return s. [docs] def fitScf(self):; """"""Function to run scf and fit a system of diffuse charges to; resulting density. """"""; basisChanged = psi4.has_option_changed(""BASIS""); ribasisChanged = psi4.has_option_changed(""DF_BASIS_SCF""); scftypeChanged = psi4.has_option_changed(""SCF_TYPE""). basis = psi4.get_option(""BASIS""); ribasis = psi4.get_option(""DF_BASIS_SCF""); scftype = psi4.get_option(""SCF_TYPE""). psi4.print_out("" => Diffus",MatchSource.WIKI,psi4manual/4.0b5/_modules/qmmm.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qmmm.html
https://psicode.org/psi4manual/4.0b5/_modules/qmmm.html:2647,Performance,perform,perform,2647,"fuse charges to; resulting density. """"""; basisChanged = psi4.has_option_changed(""BASIS""); ribasisChanged = psi4.has_option_changed(""DF_BASIS_SCF""); scftypeChanged = psi4.has_option_changed(""SCF_TYPE""). basis = psi4.get_option(""BASIS""); ribasis = psi4.get_option(""DF_BASIS_SCF""); scftype = psi4.get_option(""SCF_TYPE""). psi4.print_out("" => Diffuse SCF (Determines Da) <=\n\n""); activate(self.molecule). psi4.set_global_option(""BASIS"", self.basisname); psi4.set_global_option(""DF_BASIS_SCF"", self.ribasisname); psi4.set_global_option(""SCF_TYPE"", ""DF""); energy('scf'); psi4.print_out(""\n""). self.fitGeneral(). psi4.clean(). psi4.set_global_option(""BASIS"", basis); psi4.set_global_option(""DF_BASIS_SCF"", ribasis); psi4.set_global_option(""SCF_TYPE"", scftype). if not basisChanged:; psi4.revoke_option_changed(""BASIS""); if not ribasisChanged:; psi4.revoke_option_changed(""DF_BASIS_SCF""); if not scftypeChanged:; psi4.revoke_option_changed(""SCF_TYPE""). [docs] def fitGeneral(self):; """"""Function to perform a general fit of diffuse charges; to wavefunction density. """"""; psi4.print_out("" => Diffuse Charge Fitting (Determines da) <=\n\n""); self.wfn = psi4.wavefunction(); self.Da = self.wfn.Da(); self.basis = self.wfn.basisset(); parser = psi4.Gaussian94BasisSetParser(); self.ribasis = psi4.BasisSet.construct(parser, self.molecule, ""DF_BASIS_SCF""). fitter = psi4.DFChargeFitter(); fitter.setPrimary(self.basis); fitter.setAuxiliary(self.ribasis); fitter.setD(self.Da); self.da = fitter.fit(); self.da.scale(2.0). [docs] def populateExtern(self, extern):; # Electronic Part; extern.addBasis(self.ribasis, self.da); # Nuclear Part; for A in range(0, self.molecule.natom()):; extern.addCharge(self.molecule.Z(A), self.molecule.x(A), self.molecule.y(A), self.molecule.z(A)). [docs]class QMMM(object):. def __init__(self):; self.charges = []; self.diffuses = []; self.extern = psi4.ExternalPotential(). [docs] def addDiffuse(self, diffuse):; """"""Function to add a diffuse charge field *diffuse*.""""""; self.diffuse",MatchSource.WIKI,psi4manual/4.0b5/_modules/qmmm.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qmmm.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:18632,Availability,error,error,18632," - Table print-out needs improving. Add some PSI variables. :type name: string; :param name: ``'scf'`` || ``'ccsd(t)'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the molecule. May be any valid argument to; :py:func:`~driver.energy`; however, SAPT is not appropriate. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``energy`` |dr| || ``optimize`` || ``cbs``. Indicates the type of calculation to be performed on the molecule; and each of its monomers. The default performs a single-point; ``energy('name')``, while ``optimize`` perfoms a geometry optimization; on each system, and ``cbs`` performs a compound single-point energy.; If a nested series of python functions is intended; (see :ref:`sec:intercalls`), use keyword ``cp_func`` instead of ``func``. :type check_bsse: :ref:`boolean <op_py_boolean>`; :param check_bsse: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether to additionally compute un-counterpoise corrected; monomers and thus obtain an estimate for the basis set superposition error. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :examples:. >>> # [1] counterpoise-corrected mp2 interaction energy; >>> cp('df-mp2'). """"""; lowername = name.lower(); kwargs = p4util.kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name.lower(). # Establish function to call; if not('cp_func' in kwargs):; if ('func' in kwargs):; kwargs['cp_func'] = kwargs['func']; del kwargs['func']; else:; kwargs['cp_func'] = energy; func = kwargs['cp_func']; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper counterpoise_correct.' % (func.__name__)); if (func is db):; raise ValidationError('Wrapper counterpoise_correct is unhappy to be calling function \'%s\'.' % (func.__name__)). if 'check_bsse' in k",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:24950,Availability,avail,available,24950,"ixyz2database.pl`.; See :ref:`sec:createDatabase` for details. .. caution:: Some features are not yet implemented. Buy a developer some coffee. - In sow/reap mode, use only global options (e.g., the local option set by ``set scf scf_type df`` will not be respected). .. note:: To access a database that is not embedded in a |PSIfour|; distribution, add the path to the directory containing the database; to the environment variable :envvar:`PYTHONPATH`. :type name: string; :param name: ``'scf'`` || ``'sapt0'`` || ``'ccsd(t)'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; :py:func:`~driver.energy`. :type db_name: string; :param db_name: ``'BASIC'`` || ``'S22'`` || ``'HTBH'`` || etc. Second argument, usually unlabeled. Indicates the requested database; name, matching (case insensitive) the name of a python file in; ``psi4/lib/databases`` or :envvar:`PYTHONPATH`. Consult that; directory for available databases and literature citations. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``energy`` |dr| || ``optimize`` || ``cbs``. Indicates the type of calculation to be performed on each database; member. The default performs a single-point ``energy('name')``, while; ``optimize`` perfoms a geometry optimization on each reagent, and; ``cbs`` performs a compound single-point energy. If a nested series; of python functions is intended (see :ref:`sec:intercalls`), use; keyword ``db_func`` instead of ``func``. :type mode: string; :param mode: |dl| ``'continuous'`` |dr| || ``'sow'`` || ``'reap'``. Indicates whether the calculations required to complete the; database are to be run in one file (``'continuous'``) or are to be; farmed out in an embarrassingly parallel fashion; (``'sow'``/``'reap'``). For the latter, run an initial job with; ``'sow'`` and follow instructions in its output file. :type cp: :ref:`boolean <op_py_boolean>`; :param cp: ``'on'`` || |dl| ``'off'`` |dr|. ",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:26152,Availability,avail,available,26152,"erforms a single-point ``energy('name')``, while; ``optimize`` perfoms a geometry optimization on each reagent, and; ``cbs`` performs a compound single-point energy. If a nested series; of python functions is intended (see :ref:`sec:intercalls`), use; keyword ``db_func`` instead of ``func``. :type mode: string; :param mode: |dl| ``'continuous'`` |dr| || ``'sow'`` || ``'reap'``. Indicates whether the calculations required to complete the; database are to be run in one file (``'continuous'``) or are to be; farmed out in an embarrassingly parallel fashion; (``'sow'``/``'reap'``). For the latter, run an initial job with; ``'sow'`` and follow instructions in its output file. :type cp: :ref:`boolean <op_py_boolean>`; :param cp: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether counterpoise correction is employed in computing; interaction energies. Use this option and NOT the :py:func:`~wrappers.cp`; function for BSSE correction in database(). Option available; (See :ref:`sec:availableDatabases`) only for databases of bimolecular complexes. :type rlxd: :ref:`boolean <op_py_boolean>`; :param rlxd: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether correction for deformation energy is; employed in computing interaction energies. Option available; (See :ref:`sec:availableDatabases`) only for databases of bimolecular complexes; with non-frozen monomers, e.g., HBC6. :type symm: :ref:`boolean <op_py_boolean>`; :param symm: |dl| ``'on'`` |dr| || ``'off'``. Indicates whether the native symmetry of the database reagents is; employed (``'on'``) or whether it is forced to :math:`C_1` symmetry; (``'off'``). Some computational methods (e.g., SAPT) require no; symmetry, and this will be set by database(). :type zpe: :ref:`boolean <op_py_boolean>`; :param zpe: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether zero-point-energy corrections are appended to; single-point energy values. Option valid only for certain; thermochemical databases. Disabled until Hessians ready. :type benchmark: ",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:26178,Availability,avail,availableDatabases,26178,"erforms a single-point ``energy('name')``, while; ``optimize`` perfoms a geometry optimization on each reagent, and; ``cbs`` performs a compound single-point energy. If a nested series; of python functions is intended (see :ref:`sec:intercalls`), use; keyword ``db_func`` instead of ``func``. :type mode: string; :param mode: |dl| ``'continuous'`` |dr| || ``'sow'`` || ``'reap'``. Indicates whether the calculations required to complete the; database are to be run in one file (``'continuous'``) or are to be; farmed out in an embarrassingly parallel fashion; (``'sow'``/``'reap'``). For the latter, run an initial job with; ``'sow'`` and follow instructions in its output file. :type cp: :ref:`boolean <op_py_boolean>`; :param cp: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether counterpoise correction is employed in computing; interaction energies. Use this option and NOT the :py:func:`~wrappers.cp`; function for BSSE correction in database(). Option available; (See :ref:`sec:availableDatabases`) only for databases of bimolecular complexes. :type rlxd: :ref:`boolean <op_py_boolean>`; :param rlxd: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether correction for deformation energy is; employed in computing interaction energies. Option available; (See :ref:`sec:availableDatabases`) only for databases of bimolecular complexes; with non-frozen monomers, e.g., HBC6. :type symm: :ref:`boolean <op_py_boolean>`; :param symm: |dl| ``'on'`` |dr| || ``'off'``. Indicates whether the native symmetry of the database reagents is; employed (``'on'``) or whether it is forced to :math:`C_1` symmetry; (``'off'``). Some computational methods (e.g., SAPT) require no; symmetry, and this will be set by database(). :type zpe: :ref:`boolean <op_py_boolean>`; :param zpe: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether zero-point-energy corrections are appended to; single-point energy values. Option valid only for certain; thermochemical databases. Disabled until Hessians ready. :type benchmark: ",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:26441,Availability,avail,available,26441," string; :param mode: |dl| ``'continuous'`` |dr| || ``'sow'`` || ``'reap'``. Indicates whether the calculations required to complete the; database are to be run in one file (``'continuous'``) or are to be; farmed out in an embarrassingly parallel fashion; (``'sow'``/``'reap'``). For the latter, run an initial job with; ``'sow'`` and follow instructions in its output file. :type cp: :ref:`boolean <op_py_boolean>`; :param cp: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether counterpoise correction is employed in computing; interaction energies. Use this option and NOT the :py:func:`~wrappers.cp`; function for BSSE correction in database(). Option available; (See :ref:`sec:availableDatabases`) only for databases of bimolecular complexes. :type rlxd: :ref:`boolean <op_py_boolean>`; :param rlxd: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether correction for deformation energy is; employed in computing interaction energies. Option available; (See :ref:`sec:availableDatabases`) only for databases of bimolecular complexes; with non-frozen monomers, e.g., HBC6. :type symm: :ref:`boolean <op_py_boolean>`; :param symm: |dl| ``'on'`` |dr| || ``'off'``. Indicates whether the native symmetry of the database reagents is; employed (``'on'``) or whether it is forced to :math:`C_1` symmetry; (``'off'``). Some computational methods (e.g., SAPT) require no; symmetry, and this will be set by database(). :type zpe: :ref:`boolean <op_py_boolean>`; :param zpe: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether zero-point-energy corrections are appended to; single-point energy values. Option valid only for certain; thermochemical databases. Disabled until Hessians ready. :type benchmark: string; :param benchmark: |dl| ``'default'`` |dr| || ``'S22A'`` || etc. Indicates whether a non-default set of reference energies, if; available (See :ref:`sec:availableDatabases`), are employed for the; calculation of error statistics. :type tabulate: array of strings; :param tabulate: |dl| ``[]`` |dr",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:26467,Availability,avail,availableDatabases,26467," string; :param mode: |dl| ``'continuous'`` |dr| || ``'sow'`` || ``'reap'``. Indicates whether the calculations required to complete the; database are to be run in one file (``'continuous'``) or are to be; farmed out in an embarrassingly parallel fashion; (``'sow'``/``'reap'``). For the latter, run an initial job with; ``'sow'`` and follow instructions in its output file. :type cp: :ref:`boolean <op_py_boolean>`; :param cp: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether counterpoise correction is employed in computing; interaction energies. Use this option and NOT the :py:func:`~wrappers.cp`; function for BSSE correction in database(). Option available; (See :ref:`sec:availableDatabases`) only for databases of bimolecular complexes. :type rlxd: :ref:`boolean <op_py_boolean>`; :param rlxd: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether correction for deformation energy is; employed in computing interaction energies. Option available; (See :ref:`sec:availableDatabases`) only for databases of bimolecular complexes; with non-frozen monomers, e.g., HBC6. :type symm: :ref:`boolean <op_py_boolean>`; :param symm: |dl| ``'on'`` |dr| || ``'off'``. Indicates whether the native symmetry of the database reagents is; employed (``'on'``) or whether it is forced to :math:`C_1` symmetry; (``'off'``). Some computational methods (e.g., SAPT) require no; symmetry, and this will be set by database(). :type zpe: :ref:`boolean <op_py_boolean>`; :param zpe: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether zero-point-energy corrections are appended to; single-point energy values. Option valid only for certain; thermochemical databases. Disabled until Hessians ready. :type benchmark: string; :param benchmark: |dl| ``'default'`` |dr| || ``'S22A'`` || etc. Indicates whether a non-default set of reference energies, if; available (See :ref:`sec:availableDatabases`), are employed for the; calculation of error statistics. :type tabulate: array of strings; :param tabulate: |dl| ``[]`` |dr",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:27329,Availability,avail,available,27329,"ther correction for deformation energy is; employed in computing interaction energies. Option available; (See :ref:`sec:availableDatabases`) only for databases of bimolecular complexes; with non-frozen monomers, e.g., HBC6. :type symm: :ref:`boolean <op_py_boolean>`; :param symm: |dl| ``'on'`` |dr| || ``'off'``. Indicates whether the native symmetry of the database reagents is; employed (``'on'``) or whether it is forced to :math:`C_1` symmetry; (``'off'``). Some computational methods (e.g., SAPT) require no; symmetry, and this will be set by database(). :type zpe: :ref:`boolean <op_py_boolean>`; :param zpe: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether zero-point-energy corrections are appended to; single-point energy values. Option valid only for certain; thermochemical databases. Disabled until Hessians ready. :type benchmark: string; :param benchmark: |dl| ``'default'`` |dr| || ``'S22A'`` || etc. Indicates whether a non-default set of reference energies, if; available (See :ref:`sec:availableDatabases`), are employed for the; calculation of error statistics. :type tabulate: array of strings; :param tabulate: |dl| ``[]`` |dr| || ``['scf total energy', 'natom']`` || etc. Indicates whether to form tables of variables other than the; primary requested energy. Available for any PSI variable. :type subset: string or array of strings; :param subset:. Indicates a subset of the full database to run. This is a very; flexible option and can be used in three distinct ways, outlined; below. Note that two take a string and the last takes an array.; See `Available Databases`_ for available values. * ``'small'`` || ``'large'`` || ``'equilibrium'``; Calls predefined subsets of the requested database, either; ``'small'``, a few of the smallest database members,; ``'large'``, the largest of the database members, or; ``'equilibrium'``, the equilibrium geometries for a database; composed of dissociation curves.; * ``'BzBz_S'`` || ``'FaOOFaON'`` || ``'ArNe'`` || ``'HB'`` || etc.;",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:27354,Availability,avail,availableDatabases,27354,"ther correction for deformation energy is; employed in computing interaction energies. Option available; (See :ref:`sec:availableDatabases`) only for databases of bimolecular complexes; with non-frozen monomers, e.g., HBC6. :type symm: :ref:`boolean <op_py_boolean>`; :param symm: |dl| ``'on'`` |dr| || ``'off'``. Indicates whether the native symmetry of the database reagents is; employed (``'on'``) or whether it is forced to :math:`C_1` symmetry; (``'off'``). Some computational methods (e.g., SAPT) require no; symmetry, and this will be set by database(). :type zpe: :ref:`boolean <op_py_boolean>`; :param zpe: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether zero-point-energy corrections are appended to; single-point energy values. Option valid only for certain; thermochemical databases. Disabled until Hessians ready. :type benchmark: string; :param benchmark: |dl| ``'default'`` |dr| || ``'S22A'`` || etc. Indicates whether a non-default set of reference energies, if; available (See :ref:`sec:availableDatabases`), are employed for the; calculation of error statistics. :type tabulate: array of strings; :param tabulate: |dl| ``[]`` |dr| || ``['scf total energy', 'natom']`` || etc. Indicates whether to form tables of variables other than the; primary requested energy. Available for any PSI variable. :type subset: string or array of strings; :param subset:. Indicates a subset of the full database to run. This is a very; flexible option and can be used in three distinct ways, outlined; below. Note that two take a string and the last takes an array.; See `Available Databases`_ for available values. * ``'small'`` || ``'large'`` || ``'equilibrium'``; Calls predefined subsets of the requested database, either; ``'small'``, a few of the smallest database members,; ``'large'``, the largest of the database members, or; ``'equilibrium'``, the equilibrium geometries for a database; composed of dissociation curves.; * ``'BzBz_S'`` || ``'FaOOFaON'`` || ``'ArNe'`` || ``'HB'`` || etc.;",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:27413,Availability,error,error,27413,"ther correction for deformation energy is; employed in computing interaction energies. Option available; (See :ref:`sec:availableDatabases`) only for databases of bimolecular complexes; with non-frozen monomers, e.g., HBC6. :type symm: :ref:`boolean <op_py_boolean>`; :param symm: |dl| ``'on'`` |dr| || ``'off'``. Indicates whether the native symmetry of the database reagents is; employed (``'on'``) or whether it is forced to :math:`C_1` symmetry; (``'off'``). Some computational methods (e.g., SAPT) require no; symmetry, and this will be set by database(). :type zpe: :ref:`boolean <op_py_boolean>`; :param zpe: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether zero-point-energy corrections are appended to; single-point energy values. Option valid only for certain; thermochemical databases. Disabled until Hessians ready. :type benchmark: string; :param benchmark: |dl| ``'default'`` |dr| || ``'S22A'`` || etc. Indicates whether a non-default set of reference energies, if; available (See :ref:`sec:availableDatabases`), are employed for the; calculation of error statistics. :type tabulate: array of strings; :param tabulate: |dl| ``[]`` |dr| || ``['scf total energy', 'natom']`` || etc. Indicates whether to form tables of variables other than the; primary requested energy. Available for any PSI variable. :type subset: string or array of strings; :param subset:. Indicates a subset of the full database to run. This is a very; flexible option and can be used in three distinct ways, outlined; below. Note that two take a string and the last takes an array.; See `Available Databases`_ for available values. * ``'small'`` || ``'large'`` || ``'equilibrium'``; Calls predefined subsets of the requested database, either; ``'small'``, a few of the smallest database members,; ``'large'``, the largest of the database members, or; ``'equilibrium'``, the equilibrium geometries for a database; composed of dissociation curves.; * ``'BzBz_S'`` || ``'FaOOFaON'`` || ``'ArNe'`` || ``'HB'`` || etc.;",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:27632,Availability,Avail,Available,27632,"|| ``'off'``. Indicates whether the native symmetry of the database reagents is; employed (``'on'``) or whether it is forced to :math:`C_1` symmetry; (``'off'``). Some computational methods (e.g., SAPT) require no; symmetry, and this will be set by database(). :type zpe: :ref:`boolean <op_py_boolean>`; :param zpe: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether zero-point-energy corrections are appended to; single-point energy values. Option valid only for certain; thermochemical databases. Disabled until Hessians ready. :type benchmark: string; :param benchmark: |dl| ``'default'`` |dr| || ``'S22A'`` || etc. Indicates whether a non-default set of reference energies, if; available (See :ref:`sec:availableDatabases`), are employed for the; calculation of error statistics. :type tabulate: array of strings; :param tabulate: |dl| ``[]`` |dr| || ``['scf total energy', 'natom']`` || etc. Indicates whether to form tables of variables other than the; primary requested energy. Available for any PSI variable. :type subset: string or array of strings; :param subset:. Indicates a subset of the full database to run. This is a very; flexible option and can be used in three distinct ways, outlined; below. Note that two take a string and the last takes an array.; See `Available Databases`_ for available values. * ``'small'`` || ``'large'`` || ``'equilibrium'``; Calls predefined subsets of the requested database, either; ``'small'``, a few of the smallest database members,; ``'large'``, the largest of the database members, or; ``'equilibrium'``, the equilibrium geometries for a database; composed of dissociation curves.; * ``'BzBz_S'`` || ``'FaOOFaON'`` || ``'ArNe'`` || ``'HB'`` || etc.; For databases composed of dissociation curves, or otherwise; divided into subsets, individual curves and subsets can be; called by name. Consult the database python files for available; molecular systems (case insensitive).; * ``[1,2,5]`` || ``['1','2','5']`` || ``['BzMe-3.5', 'MeMe-5.0']`` || etc",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:27922,Availability,Avail,Available,27922,"boolean>`; :param zpe: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether zero-point-energy corrections are appended to; single-point energy values. Option valid only for certain; thermochemical databases. Disabled until Hessians ready. :type benchmark: string; :param benchmark: |dl| ``'default'`` |dr| || ``'S22A'`` || etc. Indicates whether a non-default set of reference energies, if; available (See :ref:`sec:availableDatabases`), are employed for the; calculation of error statistics. :type tabulate: array of strings; :param tabulate: |dl| ``[]`` |dr| || ``['scf total energy', 'natom']`` || etc. Indicates whether to form tables of variables other than the; primary requested energy. Available for any PSI variable. :type subset: string or array of strings; :param subset:. Indicates a subset of the full database to run. This is a very; flexible option and can be used in three distinct ways, outlined; below. Note that two take a string and the last takes an array.; See `Available Databases`_ for available values. * ``'small'`` || ``'large'`` || ``'equilibrium'``; Calls predefined subsets of the requested database, either; ``'small'``, a few of the smallest database members,; ``'large'``, the largest of the database members, or; ``'equilibrium'``, the equilibrium geometries for a database; composed of dissociation curves.; * ``'BzBz_S'`` || ``'FaOOFaON'`` || ``'ArNe'`` || ``'HB'`` || etc.; For databases composed of dissociation curves, or otherwise; divided into subsets, individual curves and subsets can be; called by name. Consult the database python files for available; molecular systems (case insensitive).; * ``[1,2,5]`` || ``['1','2','5']`` || ``['BzMe-3.5', 'MeMe-5.0']`` || etc.; Specify a list of database members to run. Consult the; database python files for available molecular systems. This; is the only portion of database input that is case sensitive;; choices for this keyword must match the database python file. :examples:. >>> # [1] Two-stage SCF calculation ",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:27948,Availability,avail,available,27948,"boolean>`; :param zpe: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether zero-point-energy corrections are appended to; single-point energy values. Option valid only for certain; thermochemical databases. Disabled until Hessians ready. :type benchmark: string; :param benchmark: |dl| ``'default'`` |dr| || ``'S22A'`` || etc. Indicates whether a non-default set of reference energies, if; available (See :ref:`sec:availableDatabases`), are employed for the; calculation of error statistics. :type tabulate: array of strings; :param tabulate: |dl| ``[]`` |dr| || ``['scf total energy', 'natom']`` || etc. Indicates whether to form tables of variables other than the; primary requested energy. Available for any PSI variable. :type subset: string or array of strings; :param subset:. Indicates a subset of the full database to run. This is a very; flexible option and can be used in three distinct ways, outlined; below. Note that two take a string and the last takes an array.; See `Available Databases`_ for available values. * ``'small'`` || ``'large'`` || ``'equilibrium'``; Calls predefined subsets of the requested database, either; ``'small'``, a few of the smallest database members,; ``'large'``, the largest of the database members, or; ``'equilibrium'``, the equilibrium geometries for a database; composed of dissociation curves.; * ``'BzBz_S'`` || ``'FaOOFaON'`` || ``'ArNe'`` || ``'HB'`` || etc.; For databases composed of dissociation curves, or otherwise; divided into subsets, individual curves and subsets can be; called by name. Consult the database python files for available; molecular systems (case insensitive).; * ``[1,2,5]`` || ``['1','2','5']`` || ``['BzMe-3.5', 'MeMe-5.0']`` || etc.; Specify a list of database members to run. Consult the; database python files for available molecular systems. This; is the only portion of database input that is case sensitive;; choices for this keyword must match the database python file. :examples:. >>> # [1] Two-stage SCF calculation ",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:28524,Availability,avail,available,28524,"tom']`` || etc. Indicates whether to form tables of variables other than the; primary requested energy. Available for any PSI variable. :type subset: string or array of strings; :param subset:. Indicates a subset of the full database to run. This is a very; flexible option and can be used in three distinct ways, outlined; below. Note that two take a string and the last takes an array.; See `Available Databases`_ for available values. * ``'small'`` || ``'large'`` || ``'equilibrium'``; Calls predefined subsets of the requested database, either; ``'small'``, a few of the smallest database members,; ``'large'``, the largest of the database members, or; ``'equilibrium'``, the equilibrium geometries for a database; composed of dissociation curves.; * ``'BzBz_S'`` || ``'FaOOFaON'`` || ``'ArNe'`` || ``'HB'`` || etc.; For databases composed of dissociation curves, or otherwise; divided into subsets, individual curves and subsets can be; called by name. Consult the database python files for available; molecular systems (case insensitive).; * ``[1,2,5]`` || ``['1','2','5']`` || ``['BzMe-3.5', 'MeMe-5.0']`` || etc.; Specify a list of database members to run. Consult the; database python files for available molecular systems. This; is the only portion of database input that is case sensitive;; choices for this keyword must match the database python file. :examples:. >>> # [1] Two-stage SCF calculation on short, equilibrium, and long helium dimer; >>> db('scf','RGC10',cast_up='sto-3g',subset=['HeHe-0.85','HeHe-1.0','HeHe-1.5'], tabulate=['scf total energy','natom']). >>> # [2] Counterpoise-corrected interaction energies for three complexes in S22; >>> # Error statistics computed wrt an old benchmark, S22A; >>> database('df-mp2','S22',cp=1,subset=[16,17,8],benchmark='S22A'). >>> # [3] SAPT0 on the neon dimer dissociation curve; >>> db('sapt0',subset='NeNe',cp=0,symm=0,db_name='RGC10'). >>> # [4] Optimize system 1 in database S22, producing tables of scf and mp2 energy; >>> db('mp2'",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:28732,Availability,avail,available,28732,"cates a subset of the full database to run. This is a very; flexible option and can be used in three distinct ways, outlined; below. Note that two take a string and the last takes an array.; See `Available Databases`_ for available values. * ``'small'`` || ``'large'`` || ``'equilibrium'``; Calls predefined subsets of the requested database, either; ``'small'``, a few of the smallest database members,; ``'large'``, the largest of the database members, or; ``'equilibrium'``, the equilibrium geometries for a database; composed of dissociation curves.; * ``'BzBz_S'`` || ``'FaOOFaON'`` || ``'ArNe'`` || ``'HB'`` || etc.; For databases composed of dissociation curves, or otherwise; divided into subsets, individual curves and subsets can be; called by name. Consult the database python files for available; molecular systems (case insensitive).; * ``[1,2,5]`` || ``['1','2','5']`` || ``['BzMe-3.5', 'MeMe-5.0']`` || etc.; Specify a list of database members to run. Consult the; database python files for available molecular systems. This; is the only portion of database input that is case sensitive;; choices for this keyword must match the database python file. :examples:. >>> # [1] Two-stage SCF calculation on short, equilibrium, and long helium dimer; >>> db('scf','RGC10',cast_up='sto-3g',subset=['HeHe-0.85','HeHe-1.0','HeHe-1.5'], tabulate=['scf total energy','natom']). >>> # [2] Counterpoise-corrected interaction energies for three complexes in S22; >>> # Error statistics computed wrt an old benchmark, S22A; >>> database('df-mp2','S22',cp=1,subset=[16,17,8],benchmark='S22A'). >>> # [3] SAPT0 on the neon dimer dissociation curve; >>> db('sapt0',subset='NeNe',cp=0,symm=0,db_name='RGC10'). >>> # [4] Optimize system 1 in database S22, producing tables of scf and mp2 energy; >>> db('mp2','S22',db_func=optimize,subset=[1], tabulate=['mp2 total energy','current energy']). >>> # [5] CCSD on the smallest systems of HTBH, a hydrogen-transfer database; >>> database('ccsd','HTBH',subset=",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:29196,Availability,Error,Error,29196,"librium geometries for a database; composed of dissociation curves.; * ``'BzBz_S'`` || ``'FaOOFaON'`` || ``'ArNe'`` || ``'HB'`` || etc.; For databases composed of dissociation curves, or otherwise; divided into subsets, individual curves and subsets can be; called by name. Consult the database python files for available; molecular systems (case insensitive).; * ``[1,2,5]`` || ``['1','2','5']`` || ``['BzMe-3.5', 'MeMe-5.0']`` || etc.; Specify a list of database members to run. Consult the; database python files for available molecular systems. This; is the only portion of database input that is case sensitive;; choices for this keyword must match the database python file. :examples:. >>> # [1] Two-stage SCF calculation on short, equilibrium, and long helium dimer; >>> db('scf','RGC10',cast_up='sto-3g',subset=['HeHe-0.85','HeHe-1.0','HeHe-1.5'], tabulate=['scf total energy','natom']). >>> # [2] Counterpoise-corrected interaction energies for three complexes in S22; >>> # Error statistics computed wrt an old benchmark, S22A; >>> database('df-mp2','S22',cp=1,subset=[16,17,8],benchmark='S22A'). >>> # [3] SAPT0 on the neon dimer dissociation curve; >>> db('sapt0',subset='NeNe',cp=0,symm=0,db_name='RGC10'). >>> # [4] Optimize system 1 in database S22, producing tables of scf and mp2 energy; >>> db('mp2','S22',db_func=optimize,subset=[1], tabulate=['mp2 total energy','current energy']). >>> # [5] CCSD on the smallest systems of HTBH, a hydrogen-transfer database; >>> database('ccsd','HTBH',subset='small', tabulate=['ccsd total energy', 'mp2 total energy']). """"""; lowername = name.lower(); kwargs = p4util.kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name.lower(); if not('db_name' in kwargs) and db_name:; kwargs['db_name'] = db_name. # Establish function to call; if not('db_func' in kwargs):; if ('func' in kwargs):; kwargs['db_func'] = kwargs['func']; del kwargs['func']; e",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:35393,Availability,error,error,35393,"buteError:; raise ValidationError('Deformation and counterpoise correction mode \'yes\' invalid for database %s.' % (db_name)); else:; ACTV = database.ACTV_CPRLX; RXNM = database.RXNM_CPRLX; elif no.match(str(db_cp)):; try:; database.ACTV_RLX; except AttributeError:; raise ValidationError('Deformation correction mode \'yes\' invalid for database %s.' % (db_name)); else:; ACTV = database.ACTV_RLX; elif no.match(str(db_rlxd)):; pass; else:; raise ValidationError('Deformation correction mode \'%s\' not valid.' % (db_rlxd)). # Option zero-point-correction- whether for thermochem databases jobs are corrected by zpe; db_zpe = 'no'; if 'zpe' in kwargs:; db_zpe = kwargs['zpe']. if yes.match(str(db_zpe)):; raise ValidationError('Zero-point-correction mode \'yes\' not yet implemented.'); elif no.match(str(db_zpe)):; pass; else:; raise ValidationError('Zero-point-correction \'mode\' %s not valid.' % (db_zpe)). # Option benchmark- whether error statistics computed wrt alternate reference energies; db_benchmark = 'default'; if 'benchmark' in kwargs:; db_benchmark = kwargs['benchmark']. if (db_benchmark.lower() == 'default'):; pass; else:; BIND = p4util.getattr_ignorecase(database, 'BIND_' + db_benchmark); if BIND is None:; raise ValidationError('Special benchmark \'%s\' not available for database %s.' % (db_benchmark, db_name)). # Option tabulate- whether tables of variables other than primary energy method are formed; db_tabulate = []; if 'tabulate' in kwargs:; db_tabulate = kwargs['tabulate']. # Option subset- whether all of the database or just a portion is run; db_subset = HRXN; if 'subset' in kwargs:; db_subset = kwargs['subset']. if isinstance(db_subset, basestring):; if (db_subset.lower() == 'small'):; try:; database.HRXN_SM; except AttributeError:; raise ValidationError('Special subset \'small\' not available for database %s.' % (db_name)); else:; HRXN = database.HRXN_SM; elif (db_subset.lower() == 'large'):; try:; database.HRXN_LG; except AttributeError:; raise Validatio",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:35734,Availability,avail,available,35734,".ACTV_RLX; except AttributeError:; raise ValidationError('Deformation correction mode \'yes\' invalid for database %s.' % (db_name)); else:; ACTV = database.ACTV_RLX; elif no.match(str(db_rlxd)):; pass; else:; raise ValidationError('Deformation correction mode \'%s\' not valid.' % (db_rlxd)). # Option zero-point-correction- whether for thermochem databases jobs are corrected by zpe; db_zpe = 'no'; if 'zpe' in kwargs:; db_zpe = kwargs['zpe']. if yes.match(str(db_zpe)):; raise ValidationError('Zero-point-correction mode \'yes\' not yet implemented.'); elif no.match(str(db_zpe)):; pass; else:; raise ValidationError('Zero-point-correction \'mode\' %s not valid.' % (db_zpe)). # Option benchmark- whether error statistics computed wrt alternate reference energies; db_benchmark = 'default'; if 'benchmark' in kwargs:; db_benchmark = kwargs['benchmark']. if (db_benchmark.lower() == 'default'):; pass; else:; BIND = p4util.getattr_ignorecase(database, 'BIND_' + db_benchmark); if BIND is None:; raise ValidationError('Special benchmark \'%s\' not available for database %s.' % (db_benchmark, db_name)). # Option tabulate- whether tables of variables other than primary energy method are formed; db_tabulate = []; if 'tabulate' in kwargs:; db_tabulate = kwargs['tabulate']. # Option subset- whether all of the database or just a portion is run; db_subset = HRXN; if 'subset' in kwargs:; db_subset = kwargs['subset']. if isinstance(db_subset, basestring):; if (db_subset.lower() == 'small'):; try:; database.HRXN_SM; except AttributeError:; raise ValidationError('Special subset \'small\' not available for database %s.' % (db_name)); else:; HRXN = database.HRXN_SM; elif (db_subset.lower() == 'large'):; try:; database.HRXN_LG; except AttributeError:; raise ValidationError('Special subset \'large\' not available for database %s.' % (db_name)); else:; HRXN = database.HRXN_LG; elif (db_subset.lower() == 'equilibrium'):; try:; database.HRXN_EQ; except AttributeError:; raise ValidationError('Specia",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:36278,Availability,avail,available,36278,".match(str(db_zpe)):; pass; else:; raise ValidationError('Zero-point-correction \'mode\' %s not valid.' % (db_zpe)). # Option benchmark- whether error statistics computed wrt alternate reference energies; db_benchmark = 'default'; if 'benchmark' in kwargs:; db_benchmark = kwargs['benchmark']. if (db_benchmark.lower() == 'default'):; pass; else:; BIND = p4util.getattr_ignorecase(database, 'BIND_' + db_benchmark); if BIND is None:; raise ValidationError('Special benchmark \'%s\' not available for database %s.' % (db_benchmark, db_name)). # Option tabulate- whether tables of variables other than primary energy method are formed; db_tabulate = []; if 'tabulate' in kwargs:; db_tabulate = kwargs['tabulate']. # Option subset- whether all of the database or just a portion is run; db_subset = HRXN; if 'subset' in kwargs:; db_subset = kwargs['subset']. if isinstance(db_subset, basestring):; if (db_subset.lower() == 'small'):; try:; database.HRXN_SM; except AttributeError:; raise ValidationError('Special subset \'small\' not available for database %s.' % (db_name)); else:; HRXN = database.HRXN_SM; elif (db_subset.lower() == 'large'):; try:; database.HRXN_LG; except AttributeError:; raise ValidationError('Special subset \'large\' not available for database %s.' % (db_name)); else:; HRXN = database.HRXN_LG; elif (db_subset.lower() == 'equilibrium'):; try:; database.HRXN_EQ; except AttributeError:; raise ValidationError('Special subset \'equilibrium\' not available for database %s.' % (db_name)); else:; HRXN = database.HRXN_EQ; else:; HRXN = p4util.getattr_ignorecase(database, db_subset); if HRXN is None:; HRXN = p4util.getattr_ignorecase(database, 'HRXN_' + db_subset); if HRXN is None:; raise ValidationError('Special subset \'%s\' not available for database %s.' % (db_subset, db_name)); else:; temp = []; for rxn in db_subset:; if rxn in HRXN:; temp.append(rxn); else:; raise ValidationError('Subset element \'%s\' not a member of database %s.' % (str(rxn), db_name)); HRXN = temp. t",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:36490,Availability,avail,available,36490,"hmark = 'default'; if 'benchmark' in kwargs:; db_benchmark = kwargs['benchmark']. if (db_benchmark.lower() == 'default'):; pass; else:; BIND = p4util.getattr_ignorecase(database, 'BIND_' + db_benchmark); if BIND is None:; raise ValidationError('Special benchmark \'%s\' not available for database %s.' % (db_benchmark, db_name)). # Option tabulate- whether tables of variables other than primary energy method are formed; db_tabulate = []; if 'tabulate' in kwargs:; db_tabulate = kwargs['tabulate']. # Option subset- whether all of the database or just a portion is run; db_subset = HRXN; if 'subset' in kwargs:; db_subset = kwargs['subset']. if isinstance(db_subset, basestring):; if (db_subset.lower() == 'small'):; try:; database.HRXN_SM; except AttributeError:; raise ValidationError('Special subset \'small\' not available for database %s.' % (db_name)); else:; HRXN = database.HRXN_SM; elif (db_subset.lower() == 'large'):; try:; database.HRXN_LG; except AttributeError:; raise ValidationError('Special subset \'large\' not available for database %s.' % (db_name)); else:; HRXN = database.HRXN_LG; elif (db_subset.lower() == 'equilibrium'):; try:; database.HRXN_EQ; except AttributeError:; raise ValidationError('Special subset \'equilibrium\' not available for database %s.' % (db_name)); else:; HRXN = database.HRXN_EQ; else:; HRXN = p4util.getattr_ignorecase(database, db_subset); if HRXN is None:; HRXN = p4util.getattr_ignorecase(database, 'HRXN_' + db_subset); if HRXN is None:; raise ValidationError('Special subset \'%s\' not available for database %s.' % (db_subset, db_name)); else:; temp = []; for rxn in db_subset:; if rxn in HRXN:; temp.append(rxn); else:; raise ValidationError('Subset element \'%s\' not a member of database %s.' % (str(rxn), db_name)); HRXN = temp. temp = []; for rxn in HRXN:; temp.append(ACTV['%s-%s' % (dbse, rxn)]); HSYS = p4util.drop_duplicates(sum(temp, [])). # Sow all the necessary reagent computations; psi4.print_out(""\n\n""); p4util.banner((""Database %",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:36714,Availability,avail,available,36714," raise ValidationError('Special benchmark \'%s\' not available for database %s.' % (db_benchmark, db_name)). # Option tabulate- whether tables of variables other than primary energy method are formed; db_tabulate = []; if 'tabulate' in kwargs:; db_tabulate = kwargs['tabulate']. # Option subset- whether all of the database or just a portion is run; db_subset = HRXN; if 'subset' in kwargs:; db_subset = kwargs['subset']. if isinstance(db_subset, basestring):; if (db_subset.lower() == 'small'):; try:; database.HRXN_SM; except AttributeError:; raise ValidationError('Special subset \'small\' not available for database %s.' % (db_name)); else:; HRXN = database.HRXN_SM; elif (db_subset.lower() == 'large'):; try:; database.HRXN_LG; except AttributeError:; raise ValidationError('Special subset \'large\' not available for database %s.' % (db_name)); else:; HRXN = database.HRXN_LG; elif (db_subset.lower() == 'equilibrium'):; try:; database.HRXN_EQ; except AttributeError:; raise ValidationError('Special subset \'equilibrium\' not available for database %s.' % (db_name)); else:; HRXN = database.HRXN_EQ; else:; HRXN = p4util.getattr_ignorecase(database, db_subset); if HRXN is None:; HRXN = p4util.getattr_ignorecase(database, 'HRXN_' + db_subset); if HRXN is None:; raise ValidationError('Special subset \'%s\' not available for database %s.' % (db_subset, db_name)); else:; temp = []; for rxn in db_subset:; if rxn in HRXN:; temp.append(rxn); else:; raise ValidationError('Subset element \'%s\' not a member of database %s.' % (str(rxn), db_name)); HRXN = temp. temp = []; for rxn in HRXN:; temp.append(ACTV['%s-%s' % (dbse, rxn)]); HSYS = p4util.drop_duplicates(sum(temp, [])). # Sow all the necessary reagent computations; psi4.print_out(""\n\n""); p4util.banner((""Database %s Computation"" % (db_name))); psi4.print_out(""\n""). # write index of calcs to output file; if (db_mode.lower() == 'continuous'):; instructions = """"""\n The database single-job procedure has been selected through mode='cont",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:37000,Availability,avail,available,37000,"te']. # Option subset- whether all of the database or just a portion is run; db_subset = HRXN; if 'subset' in kwargs:; db_subset = kwargs['subset']. if isinstance(db_subset, basestring):; if (db_subset.lower() == 'small'):; try:; database.HRXN_SM; except AttributeError:; raise ValidationError('Special subset \'small\' not available for database %s.' % (db_name)); else:; HRXN = database.HRXN_SM; elif (db_subset.lower() == 'large'):; try:; database.HRXN_LG; except AttributeError:; raise ValidationError('Special subset \'large\' not available for database %s.' % (db_name)); else:; HRXN = database.HRXN_LG; elif (db_subset.lower() == 'equilibrium'):; try:; database.HRXN_EQ; except AttributeError:; raise ValidationError('Special subset \'equilibrium\' not available for database %s.' % (db_name)); else:; HRXN = database.HRXN_EQ; else:; HRXN = p4util.getattr_ignorecase(database, db_subset); if HRXN is None:; HRXN = p4util.getattr_ignorecase(database, 'HRXN_' + db_subset); if HRXN is None:; raise ValidationError('Special subset \'%s\' not available for database %s.' % (db_subset, db_name)); else:; temp = []; for rxn in db_subset:; if rxn in HRXN:; temp.append(rxn); else:; raise ValidationError('Subset element \'%s\' not a member of database %s.' % (str(rxn), db_name)); HRXN = temp. temp = []; for rxn in HRXN:; temp.append(ACTV['%s-%s' % (dbse, rxn)]); HSYS = p4util.drop_duplicates(sum(temp, [])). # Sow all the necessary reagent computations; psi4.print_out(""\n\n""); p4util.banner((""Database %s Computation"" % (db_name))); psi4.print_out(""\n""). # write index of calcs to output file; if (db_mode.lower() == 'continuous'):; instructions = """"""\n The database single-job procedure has been selected through mode='continuous'.\n""""""; instructions += """""" Calculations for the reagents will proceed in the order below and will be followed\n""""""; instructions += """""" by summary results for the database.\n\n""""""; for rgt in HSYS:; instructions += """""" %-s\n"""""" % (rgt); instructions += """"""\n Alter",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:49753,Availability,error,error,49753,"[db_rxn][envv] = 0.0; for i in range(len(ACTV[db_rxn])):; VRXN[db_rxn][envv] += VRGT[ACTV[db_rxn][i]][envv] * RXNM[db_rxn][ACTV[db_rxn][i]]. tables += """"""\n%23s %16.8f """""" % (db_rxn, VRXN[db_rxn][envv]); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (VRGT[ACTV[db_rxn][i]][envv], RXNM[db_rxn][ACTV[db_rxn][i]]); tables += """"""\n %s\n"""""" % (table_delimit). # tabulate primary requested energy variable with statistics; count_rxn = 0; minDerror = 100000.0; maxDerror = 0.0; MSDerror = 0.0; MADerror = 0.0; RMSDerror = 0.0. tables += """"""\n ==> %s <==\n\n"""""" % ('Requested Energy'); tables += tblhead(maxrgt, table_delimit, 1); for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn). if FAIL[rxn]:; tables += """"""\n%23s %8.4f %8s %8s"""""" % (db_rxn, BIND[db_rxn], '****', '****'); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (ERGT[ACTV[db_rxn][i]], RXNM[db_rxn][ACTV[db_rxn][i]]). else:; ERXN[db_rxn] = 0.0; for i in range(len(ACTV[db_rxn])):; ERXN[db_rxn] += ERGT[ACTV[db_rxn][i]] * RXNM[db_rxn][ACTV[db_rxn][i]]; error = p4const.psi_hartree2kcalmol * ERXN[db_rxn] - BIND[db_rxn]. tables += """"""\n%23s %8.4f %8.4f %8.4f"""""" % (db_rxn, BIND[db_rxn], p4const.psi_hartree2kcalmol * ERXN[db_rxn], error); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (ERGT[ACTV[db_rxn][i]], RXNM[db_rxn][ACTV[db_rxn][i]]). if abs(error) < abs(minDerror):; minDerror = error; if abs(error) > abs(maxDerror):; maxDerror = error; MSDerror += error; MADerror += abs(error); RMSDerror += error * error; count_rxn += 1; tables += """"""\n %s\n"""""" % (table_delimit). if count_rxn:. MSDerror /= float(count_rxn); MADerror /= float(count_rxn); RMSDerror = math.sqrt(RMSDerror / float(count_rxn)). tables += """"""%23s %19s %8.4f\n"""""" % ('Minimal Dev', '', minDerror); tables += """"""%23s %19s %8.4f\n"""""" % ('Maximal Dev', '', maxDerror); tables += """"""%23s %19s %8.4f\n"""""" % ('Mean Signed Dev', '', MSDerror); tables += """"""%23s %19s %8.4f\n"""""" % ('Mean Absolute Dev', '', MADerror); ta",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:49930,Availability,error,error,49930,":; tables += """""" %16.8f %2.0f"""""" % (VRGT[ACTV[db_rxn][i]][envv], RXNM[db_rxn][ACTV[db_rxn][i]]); tables += """"""\n %s\n"""""" % (table_delimit). # tabulate primary requested energy variable with statistics; count_rxn = 0; minDerror = 100000.0; maxDerror = 0.0; MSDerror = 0.0; MADerror = 0.0; RMSDerror = 0.0. tables += """"""\n ==> %s <==\n\n"""""" % ('Requested Energy'); tables += tblhead(maxrgt, table_delimit, 1); for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn). if FAIL[rxn]:; tables += """"""\n%23s %8.4f %8s %8s"""""" % (db_rxn, BIND[db_rxn], '****', '****'); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (ERGT[ACTV[db_rxn][i]], RXNM[db_rxn][ACTV[db_rxn][i]]). else:; ERXN[db_rxn] = 0.0; for i in range(len(ACTV[db_rxn])):; ERXN[db_rxn] += ERGT[ACTV[db_rxn][i]] * RXNM[db_rxn][ACTV[db_rxn][i]]; error = p4const.psi_hartree2kcalmol * ERXN[db_rxn] - BIND[db_rxn]. tables += """"""\n%23s %8.4f %8.4f %8.4f"""""" % (db_rxn, BIND[db_rxn], p4const.psi_hartree2kcalmol * ERXN[db_rxn], error); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (ERGT[ACTV[db_rxn][i]], RXNM[db_rxn][ACTV[db_rxn][i]]). if abs(error) < abs(minDerror):; minDerror = error; if abs(error) > abs(maxDerror):; maxDerror = error; MSDerror += error; MADerror += abs(error); RMSDerror += error * error; count_rxn += 1; tables += """"""\n %s\n"""""" % (table_delimit). if count_rxn:. MSDerror /= float(count_rxn); MADerror /= float(count_rxn); RMSDerror = math.sqrt(RMSDerror / float(count_rxn)). tables += """"""%23s %19s %8.4f\n"""""" % ('Minimal Dev', '', minDerror); tables += """"""%23s %19s %8.4f\n"""""" % ('Maximal Dev', '', maxDerror); tables += """"""%23s %19s %8.4f\n"""""" % ('Mean Signed Dev', '', MSDerror); tables += """"""%23s %19s %8.4f\n"""""" % ('Mean Absolute Dev', '', MADerror); tables += """"""%23s %19s %8.4f\n"""""" % ('RMS Dev', '', RMSDerror); tables += """""" %s\n"""""" % (table_delimit). psi4.set_variable('%s DATABASE MEAN SIGNED DEVIATION' % (db_name), MSDerror); psi4.set_variable('%s DATABASE MEAN ABSOLUTE DEVIATION' ",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:50069,Availability,error,error,50069,".0; maxDerror = 0.0; MSDerror = 0.0; MADerror = 0.0; RMSDerror = 0.0. tables += """"""\n ==> %s <==\n\n"""""" % ('Requested Energy'); tables += tblhead(maxrgt, table_delimit, 1); for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn). if FAIL[rxn]:; tables += """"""\n%23s %8.4f %8s %8s"""""" % (db_rxn, BIND[db_rxn], '****', '****'); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (ERGT[ACTV[db_rxn][i]], RXNM[db_rxn][ACTV[db_rxn][i]]). else:; ERXN[db_rxn] = 0.0; for i in range(len(ACTV[db_rxn])):; ERXN[db_rxn] += ERGT[ACTV[db_rxn][i]] * RXNM[db_rxn][ACTV[db_rxn][i]]; error = p4const.psi_hartree2kcalmol * ERXN[db_rxn] - BIND[db_rxn]. tables += """"""\n%23s %8.4f %8.4f %8.4f"""""" % (db_rxn, BIND[db_rxn], p4const.psi_hartree2kcalmol * ERXN[db_rxn], error); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (ERGT[ACTV[db_rxn][i]], RXNM[db_rxn][ACTV[db_rxn][i]]). if abs(error) < abs(minDerror):; minDerror = error; if abs(error) > abs(maxDerror):; maxDerror = error; MSDerror += error; MADerror += abs(error); RMSDerror += error * error; count_rxn += 1; tables += """"""\n %s\n"""""" % (table_delimit). if count_rxn:. MSDerror /= float(count_rxn); MADerror /= float(count_rxn); RMSDerror = math.sqrt(RMSDerror / float(count_rxn)). tables += """"""%23s %19s %8.4f\n"""""" % ('Minimal Dev', '', minDerror); tables += """"""%23s %19s %8.4f\n"""""" % ('Maximal Dev', '', maxDerror); tables += """"""%23s %19s %8.4f\n"""""" % ('Mean Signed Dev', '', MSDerror); tables += """"""%23s %19s %8.4f\n"""""" % ('Mean Absolute Dev', '', MADerror); tables += """"""%23s %19s %8.4f\n"""""" % ('RMS Dev', '', RMSDerror); tables += """""" %s\n"""""" % (table_delimit). psi4.set_variable('%s DATABASE MEAN SIGNED DEVIATION' % (db_name), MSDerror); psi4.set_variable('%s DATABASE MEAN ABSOLUTE DEVIATION' % (db_name), MADerror); psi4.set_variable('%s DATABASE ROOT-MEAN-SQUARE DEVIATION' % (db_name), RMSDerror). #print tables; psi4.print_out(tables); finalenergy = MADerror. else:; finalenergy = 0.0. # restore molecule and options; activa",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:50107,Availability,error,error,50107,".0; maxDerror = 0.0; MSDerror = 0.0; MADerror = 0.0; RMSDerror = 0.0. tables += """"""\n ==> %s <==\n\n"""""" % ('Requested Energy'); tables += tblhead(maxrgt, table_delimit, 1); for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn). if FAIL[rxn]:; tables += """"""\n%23s %8.4f %8s %8s"""""" % (db_rxn, BIND[db_rxn], '****', '****'); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (ERGT[ACTV[db_rxn][i]], RXNM[db_rxn][ACTV[db_rxn][i]]). else:; ERXN[db_rxn] = 0.0; for i in range(len(ACTV[db_rxn])):; ERXN[db_rxn] += ERGT[ACTV[db_rxn][i]] * RXNM[db_rxn][ACTV[db_rxn][i]]; error = p4const.psi_hartree2kcalmol * ERXN[db_rxn] - BIND[db_rxn]. tables += """"""\n%23s %8.4f %8.4f %8.4f"""""" % (db_rxn, BIND[db_rxn], p4const.psi_hartree2kcalmol * ERXN[db_rxn], error); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (ERGT[ACTV[db_rxn][i]], RXNM[db_rxn][ACTV[db_rxn][i]]). if abs(error) < abs(minDerror):; minDerror = error; if abs(error) > abs(maxDerror):; maxDerror = error; MSDerror += error; MADerror += abs(error); RMSDerror += error * error; count_rxn += 1; tables += """"""\n %s\n"""""" % (table_delimit). if count_rxn:. MSDerror /= float(count_rxn); MADerror /= float(count_rxn); RMSDerror = math.sqrt(RMSDerror / float(count_rxn)). tables += """"""%23s %19s %8.4f\n"""""" % ('Minimal Dev', '', minDerror); tables += """"""%23s %19s %8.4f\n"""""" % ('Maximal Dev', '', maxDerror); tables += """"""%23s %19s %8.4f\n"""""" % ('Mean Signed Dev', '', MSDerror); tables += """"""%23s %19s %8.4f\n"""""" % ('Mean Absolute Dev', '', MADerror); tables += """"""%23s %19s %8.4f\n"""""" % ('RMS Dev', '', RMSDerror); tables += """""" %s\n"""""" % (table_delimit). psi4.set_variable('%s DATABASE MEAN SIGNED DEVIATION' % (db_name), MSDerror); psi4.set_variable('%s DATABASE MEAN ABSOLUTE DEVIATION' % (db_name), MADerror); psi4.set_variable('%s DATABASE ROOT-MEAN-SQUARE DEVIATION' % (db_name), RMSDerror). #print tables; psi4.print_out(tables); finalenergy = MADerror. else:; finalenergy = 0.0. # restore molecule and options; activa",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:50121,Availability,error,error,50121,".0; maxDerror = 0.0; MSDerror = 0.0; MADerror = 0.0; RMSDerror = 0.0. tables += """"""\n ==> %s <==\n\n"""""" % ('Requested Energy'); tables += tblhead(maxrgt, table_delimit, 1); for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn). if FAIL[rxn]:; tables += """"""\n%23s %8.4f %8s %8s"""""" % (db_rxn, BIND[db_rxn], '****', '****'); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (ERGT[ACTV[db_rxn][i]], RXNM[db_rxn][ACTV[db_rxn][i]]). else:; ERXN[db_rxn] = 0.0; for i in range(len(ACTV[db_rxn])):; ERXN[db_rxn] += ERGT[ACTV[db_rxn][i]] * RXNM[db_rxn][ACTV[db_rxn][i]]; error = p4const.psi_hartree2kcalmol * ERXN[db_rxn] - BIND[db_rxn]. tables += """"""\n%23s %8.4f %8.4f %8.4f"""""" % (db_rxn, BIND[db_rxn], p4const.psi_hartree2kcalmol * ERXN[db_rxn], error); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (ERGT[ACTV[db_rxn][i]], RXNM[db_rxn][ACTV[db_rxn][i]]). if abs(error) < abs(minDerror):; minDerror = error; if abs(error) > abs(maxDerror):; maxDerror = error; MSDerror += error; MADerror += abs(error); RMSDerror += error * error; count_rxn += 1; tables += """"""\n %s\n"""""" % (table_delimit). if count_rxn:. MSDerror /= float(count_rxn); MADerror /= float(count_rxn); RMSDerror = math.sqrt(RMSDerror / float(count_rxn)). tables += """"""%23s %19s %8.4f\n"""""" % ('Minimal Dev', '', minDerror); tables += """"""%23s %19s %8.4f\n"""""" % ('Maximal Dev', '', maxDerror); tables += """"""%23s %19s %8.4f\n"""""" % ('Mean Signed Dev', '', MSDerror); tables += """"""%23s %19s %8.4f\n"""""" % ('Mean Absolute Dev', '', MADerror); tables += """"""%23s %19s %8.4f\n"""""" % ('RMS Dev', '', RMSDerror); tables += """""" %s\n"""""" % (table_delimit). psi4.set_variable('%s DATABASE MEAN SIGNED DEVIATION' % (db_name), MSDerror); psi4.set_variable('%s DATABASE MEAN ABSOLUTE DEVIATION' % (db_name), MADerror); psi4.set_variable('%s DATABASE ROOT-MEAN-SQUARE DEVIATION' % (db_name), RMSDerror). #print tables; psi4.print_out(tables); finalenergy = MADerror. else:; finalenergy = 0.0. # restore molecule and options; activa",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:50159,Availability,error,error,50159,".0; maxDerror = 0.0; MSDerror = 0.0; MADerror = 0.0; RMSDerror = 0.0. tables += """"""\n ==> %s <==\n\n"""""" % ('Requested Energy'); tables += tblhead(maxrgt, table_delimit, 1); for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn). if FAIL[rxn]:; tables += """"""\n%23s %8.4f %8s %8s"""""" % (db_rxn, BIND[db_rxn], '****', '****'); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (ERGT[ACTV[db_rxn][i]], RXNM[db_rxn][ACTV[db_rxn][i]]). else:; ERXN[db_rxn] = 0.0; for i in range(len(ACTV[db_rxn])):; ERXN[db_rxn] += ERGT[ACTV[db_rxn][i]] * RXNM[db_rxn][ACTV[db_rxn][i]]; error = p4const.psi_hartree2kcalmol * ERXN[db_rxn] - BIND[db_rxn]. tables += """"""\n%23s %8.4f %8.4f %8.4f"""""" % (db_rxn, BIND[db_rxn], p4const.psi_hartree2kcalmol * ERXN[db_rxn], error); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (ERGT[ACTV[db_rxn][i]], RXNM[db_rxn][ACTV[db_rxn][i]]). if abs(error) < abs(minDerror):; minDerror = error; if abs(error) > abs(maxDerror):; maxDerror = error; MSDerror += error; MADerror += abs(error); RMSDerror += error * error; count_rxn += 1; tables += """"""\n %s\n"""""" % (table_delimit). if count_rxn:. MSDerror /= float(count_rxn); MADerror /= float(count_rxn); RMSDerror = math.sqrt(RMSDerror / float(count_rxn)). tables += """"""%23s %19s %8.4f\n"""""" % ('Minimal Dev', '', minDerror); tables += """"""%23s %19s %8.4f\n"""""" % ('Maximal Dev', '', maxDerror); tables += """"""%23s %19s %8.4f\n"""""" % ('Mean Signed Dev', '', MSDerror); tables += """"""%23s %19s %8.4f\n"""""" % ('Mean Absolute Dev', '', MADerror); tables += """"""%23s %19s %8.4f\n"""""" % ('RMS Dev', '', RMSDerror); tables += """""" %s\n"""""" % (table_delimit). psi4.set_variable('%s DATABASE MEAN SIGNED DEVIATION' % (db_name), MSDerror); psi4.set_variable('%s DATABASE MEAN ABSOLUTE DEVIATION' % (db_name), MADerror); psi4.set_variable('%s DATABASE ROOT-MEAN-SQUARE DEVIATION' % (db_name), RMSDerror). #print tables; psi4.print_out(tables); finalenergy = MADerror. else:; finalenergy = 0.0. # restore molecule and options; activa",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:50178,Availability,error,error,50178,".0; maxDerror = 0.0; MSDerror = 0.0; MADerror = 0.0; RMSDerror = 0.0. tables += """"""\n ==> %s <==\n\n"""""" % ('Requested Energy'); tables += tblhead(maxrgt, table_delimit, 1); for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn). if FAIL[rxn]:; tables += """"""\n%23s %8.4f %8s %8s"""""" % (db_rxn, BIND[db_rxn], '****', '****'); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (ERGT[ACTV[db_rxn][i]], RXNM[db_rxn][ACTV[db_rxn][i]]). else:; ERXN[db_rxn] = 0.0; for i in range(len(ACTV[db_rxn])):; ERXN[db_rxn] += ERGT[ACTV[db_rxn][i]] * RXNM[db_rxn][ACTV[db_rxn][i]]; error = p4const.psi_hartree2kcalmol * ERXN[db_rxn] - BIND[db_rxn]. tables += """"""\n%23s %8.4f %8.4f %8.4f"""""" % (db_rxn, BIND[db_rxn], p4const.psi_hartree2kcalmol * ERXN[db_rxn], error); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (ERGT[ACTV[db_rxn][i]], RXNM[db_rxn][ACTV[db_rxn][i]]). if abs(error) < abs(minDerror):; minDerror = error; if abs(error) > abs(maxDerror):; maxDerror = error; MSDerror += error; MADerror += abs(error); RMSDerror += error * error; count_rxn += 1; tables += """"""\n %s\n"""""" % (table_delimit). if count_rxn:. MSDerror /= float(count_rxn); MADerror /= float(count_rxn); RMSDerror = math.sqrt(RMSDerror / float(count_rxn)). tables += """"""%23s %19s %8.4f\n"""""" % ('Minimal Dev', '', minDerror); tables += """"""%23s %19s %8.4f\n"""""" % ('Maximal Dev', '', maxDerror); tables += """"""%23s %19s %8.4f\n"""""" % ('Mean Signed Dev', '', MSDerror); tables += """"""%23s %19s %8.4f\n"""""" % ('Mean Absolute Dev', '', MADerror); tables += """"""%23s %19s %8.4f\n"""""" % ('RMS Dev', '', RMSDerror); tables += """""" %s\n"""""" % (table_delimit). psi4.set_variable('%s DATABASE MEAN SIGNED DEVIATION' % (db_name), MSDerror); psi4.set_variable('%s DATABASE MEAN ABSOLUTE DEVIATION' % (db_name), MADerror); psi4.set_variable('%s DATABASE ROOT-MEAN-SQUARE DEVIATION' % (db_name), RMSDerror). #print tables; psi4.print_out(tables); finalenergy = MADerror. else:; finalenergy = 0.0. # restore molecule and options; activa",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:50201,Availability,error,error,50201,".0; maxDerror = 0.0; MSDerror = 0.0; MADerror = 0.0; RMSDerror = 0.0. tables += """"""\n ==> %s <==\n\n"""""" % ('Requested Energy'); tables += tblhead(maxrgt, table_delimit, 1); for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn). if FAIL[rxn]:; tables += """"""\n%23s %8.4f %8s %8s"""""" % (db_rxn, BIND[db_rxn], '****', '****'); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (ERGT[ACTV[db_rxn][i]], RXNM[db_rxn][ACTV[db_rxn][i]]). else:; ERXN[db_rxn] = 0.0; for i in range(len(ACTV[db_rxn])):; ERXN[db_rxn] += ERGT[ACTV[db_rxn][i]] * RXNM[db_rxn][ACTV[db_rxn][i]]; error = p4const.psi_hartree2kcalmol * ERXN[db_rxn] - BIND[db_rxn]. tables += """"""\n%23s %8.4f %8.4f %8.4f"""""" % (db_rxn, BIND[db_rxn], p4const.psi_hartree2kcalmol * ERXN[db_rxn], error); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (ERGT[ACTV[db_rxn][i]], RXNM[db_rxn][ACTV[db_rxn][i]]). if abs(error) < abs(minDerror):; minDerror = error; if abs(error) > abs(maxDerror):; maxDerror = error; MSDerror += error; MADerror += abs(error); RMSDerror += error * error; count_rxn += 1; tables += """"""\n %s\n"""""" % (table_delimit). if count_rxn:. MSDerror /= float(count_rxn); MADerror /= float(count_rxn); RMSDerror = math.sqrt(RMSDerror / float(count_rxn)). tables += """"""%23s %19s %8.4f\n"""""" % ('Minimal Dev', '', minDerror); tables += """"""%23s %19s %8.4f\n"""""" % ('Maximal Dev', '', maxDerror); tables += """"""%23s %19s %8.4f\n"""""" % ('Mean Signed Dev', '', MSDerror); tables += """"""%23s %19s %8.4f\n"""""" % ('Mean Absolute Dev', '', MADerror); tables += """"""%23s %19s %8.4f\n"""""" % ('RMS Dev', '', RMSDerror); tables += """""" %s\n"""""" % (table_delimit). psi4.set_variable('%s DATABASE MEAN SIGNED DEVIATION' % (db_name), MSDerror); psi4.set_variable('%s DATABASE MEAN ABSOLUTE DEVIATION' % (db_name), MADerror); psi4.set_variable('%s DATABASE ROOT-MEAN-SQUARE DEVIATION' % (db_name), RMSDerror). #print tables; psi4.print_out(tables); finalenergy = MADerror. else:; finalenergy = 0.0. # restore molecule and options; activa",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:50222,Availability,error,error,50222,".0; maxDerror = 0.0; MSDerror = 0.0; MADerror = 0.0; RMSDerror = 0.0. tables += """"""\n ==> %s <==\n\n"""""" % ('Requested Energy'); tables += tblhead(maxrgt, table_delimit, 1); for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn). if FAIL[rxn]:; tables += """"""\n%23s %8.4f %8s %8s"""""" % (db_rxn, BIND[db_rxn], '****', '****'); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (ERGT[ACTV[db_rxn][i]], RXNM[db_rxn][ACTV[db_rxn][i]]). else:; ERXN[db_rxn] = 0.0; for i in range(len(ACTV[db_rxn])):; ERXN[db_rxn] += ERGT[ACTV[db_rxn][i]] * RXNM[db_rxn][ACTV[db_rxn][i]]; error = p4const.psi_hartree2kcalmol * ERXN[db_rxn] - BIND[db_rxn]. tables += """"""\n%23s %8.4f %8.4f %8.4f"""""" % (db_rxn, BIND[db_rxn], p4const.psi_hartree2kcalmol * ERXN[db_rxn], error); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (ERGT[ACTV[db_rxn][i]], RXNM[db_rxn][ACTV[db_rxn][i]]). if abs(error) < abs(minDerror):; minDerror = error; if abs(error) > abs(maxDerror):; maxDerror = error; MSDerror += error; MADerror += abs(error); RMSDerror += error * error; count_rxn += 1; tables += """"""\n %s\n"""""" % (table_delimit). if count_rxn:. MSDerror /= float(count_rxn); MADerror /= float(count_rxn); RMSDerror = math.sqrt(RMSDerror / float(count_rxn)). tables += """"""%23s %19s %8.4f\n"""""" % ('Minimal Dev', '', minDerror); tables += """"""%23s %19s %8.4f\n"""""" % ('Maximal Dev', '', maxDerror); tables += """"""%23s %19s %8.4f\n"""""" % ('Mean Signed Dev', '', MSDerror); tables += """"""%23s %19s %8.4f\n"""""" % ('Mean Absolute Dev', '', MADerror); tables += """"""%23s %19s %8.4f\n"""""" % ('RMS Dev', '', RMSDerror); tables += """""" %s\n"""""" % (table_delimit). psi4.set_variable('%s DATABASE MEAN SIGNED DEVIATION' % (db_name), MSDerror); psi4.set_variable('%s DATABASE MEAN ABSOLUTE DEVIATION' % (db_name), MADerror); psi4.set_variable('%s DATABASE ROOT-MEAN-SQUARE DEVIATION' % (db_name), RMSDerror). #print tables; psi4.print_out(tables); finalenergy = MADerror. else:; finalenergy = 0.0. # restore molecule and options; activa",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:50230,Availability,error,error,50230,".0; maxDerror = 0.0; MSDerror = 0.0; MADerror = 0.0; RMSDerror = 0.0. tables += """"""\n ==> %s <==\n\n"""""" % ('Requested Energy'); tables += tblhead(maxrgt, table_delimit, 1); for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn). if FAIL[rxn]:; tables += """"""\n%23s %8.4f %8s %8s"""""" % (db_rxn, BIND[db_rxn], '****', '****'); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (ERGT[ACTV[db_rxn][i]], RXNM[db_rxn][ACTV[db_rxn][i]]). else:; ERXN[db_rxn] = 0.0; for i in range(len(ACTV[db_rxn])):; ERXN[db_rxn] += ERGT[ACTV[db_rxn][i]] * RXNM[db_rxn][ACTV[db_rxn][i]]; error = p4const.psi_hartree2kcalmol * ERXN[db_rxn] - BIND[db_rxn]. tables += """"""\n%23s %8.4f %8.4f %8.4f"""""" % (db_rxn, BIND[db_rxn], p4const.psi_hartree2kcalmol * ERXN[db_rxn], error); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (ERGT[ACTV[db_rxn][i]], RXNM[db_rxn][ACTV[db_rxn][i]]). if abs(error) < abs(minDerror):; minDerror = error; if abs(error) > abs(maxDerror):; maxDerror = error; MSDerror += error; MADerror += abs(error); RMSDerror += error * error; count_rxn += 1; tables += """"""\n %s\n"""""" % (table_delimit). if count_rxn:. MSDerror /= float(count_rxn); MADerror /= float(count_rxn); RMSDerror = math.sqrt(RMSDerror / float(count_rxn)). tables += """"""%23s %19s %8.4f\n"""""" % ('Minimal Dev', '', minDerror); tables += """"""%23s %19s %8.4f\n"""""" % ('Maximal Dev', '', maxDerror); tables += """"""%23s %19s %8.4f\n"""""" % ('Mean Signed Dev', '', MSDerror); tables += """"""%23s %19s %8.4f\n"""""" % ('Mean Absolute Dev', '', MADerror); tables += """"""%23s %19s %8.4f\n"""""" % ('RMS Dev', '', RMSDerror); tables += """""" %s\n"""""" % (table_delimit). psi4.set_variable('%s DATABASE MEAN SIGNED DEVIATION' % (db_name), MSDerror); psi4.set_variable('%s DATABASE MEAN ABSOLUTE DEVIATION' % (db_name), MADerror); psi4.set_variable('%s DATABASE ROOT-MEAN-SQUARE DEVIATION' % (db_name), RMSDerror). #print tables; psi4.print_out(tables); finalenergy = MADerror. else:; finalenergy = 0.0. # restore molecule and options; activa",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:52127,Availability,Error,Error,52127," user_reference); if not b_user_reference:; psi4.revoke_global_option_changed('REFERENCE'); psi4.set_global_option('WRITER_FILE_LABEL', user_writer_file_label). DB_RGT.clear(); DB_RGT.update(VRGT); DB_RXN.clear(); DB_RXN.update(VRXN); return finalenergy. [docs]def tblhead(tbl_maxrgt, tbl_delimit, ttype):; r""""""Function that prints the header for the changable-width results tables in db().; *tbl_maxrgt* is the number of reagent columns the table must plan for. *tbl_delimit*; is a string of dashes of the correct length to set off the table. *ttype* is 1 for; tables comparing the computed values to the reference or 2 for simple tabulation; and sum of the computed values. """"""; tbl_str = ''; tbl_str += """""" %s"""""" % (tbl_delimit); if ttype == 1:; tbl_str += """"""\n%23s %19s %8s"""""" % ('Reaction', 'Reaction Energy', 'Error'); elif ttype == 2:; tbl_str += """"""\n%23s %19s %6s"""""" % ('Reaction', 'Reaction Value', ''); for i in range(tbl_maxrgt):; tbl_str += """"""%20s"""""" % ('Reagent ' + str(i + 1)); if ttype == 1:; tbl_str += """"""\n%23s %8s %8s %8s"""""" % ('', 'Ref', 'Calc', '[kcal/mol]'); elif ttype == 2:; tbl_str += """"""\n%54s"""""" % (''); for i in range(tbl_maxrgt):; if ttype == 1:; tbl_str += """"""%20s"""""" % ('[H] Wt'); elif ttype == 2:; tbl_str += """"""%20s"""""" % ('Value Wt'); tbl_str += """"""\n %s"""""" % (tbl_delimit); return tbl_str. ## Aliases ##; db = database. #######################; ## End of Database ##; #######################. ###################################; ## Start of Complete Basis Set ##; ###################################. [docs]def complete_basis_set(name, **kwargs):; r""""""Function to define a multistage energy method from combinations of; basis set extrapolations and delta corrections and condense the; components into a minimum number of calculations. :aliases: cbs(). :returns: (*float*) -- Total electronic energy in Hartrees. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CBS TOTAL ENERGY <CBSTOTALENERGY>`; * :psivar:`CBS REFERENCE ENERGY <CBSREFERENCEENERGY>`; * :psiv",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:60078,Availability,avail,available,60078,"ing <apdx:basisElement>`; :param delta3_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the third delta correction; to the correlation energy. :type delta4_basis: :ref:`basis string <apdx:basisElement>`; :param delta4_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the fourth delta correction; to the correlation energy. :type delta5_basis: :ref:`basis string <apdx:basisElement>`; :param delta5_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the fifth delta correction; to the correlation energy. * Schemes; Transformations of the energy through basis set extrapolation for each; stage of the CBS definition. A complaint is generated if number of basis; sets in stage_basis does not exactly satisfy requirements of stage_scheme.; An exception is the default, ``'highest_1'``, which uses the best basis; set available. See `Extrapolation Schemes`_ for all available schemes. :type scf_scheme: function; :param scf_scheme: |dl| ``highest_1`` |dr| || ``scf_xtpl_helgaker_3`` || etc. Indicates the basis set extrapolation scheme to be applied to the reference energy. :type corl_scheme: function; :param corl_scheme: |dl| ``highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the correlation energy. :type delta_scheme: function; :param delta_scheme: |dl| ``highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the delta correction; to the correlation energy. :type delta2_scheme: function; :param delta2_scheme: |dl| ``highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the second delta correction; to the correlation energy. :type delta3_scheme: function; :param delta3_scheme: |dl| ``h",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:60126,Availability,avail,available,60126,"-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the third delta correction; to the correlation energy. :type delta4_basis: :ref:`basis string <apdx:basisElement>`; :param delta4_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the fourth delta correction; to the correlation energy. :type delta5_basis: :ref:`basis string <apdx:basisElement>`; :param delta5_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the fifth delta correction; to the correlation energy. * Schemes; Transformations of the energy through basis set extrapolation for each; stage of the CBS definition. A complaint is generated if number of basis; sets in stage_basis does not exactly satisfy requirements of stage_scheme.; An exception is the default, ``'highest_1'``, which uses the best basis; set available. See `Extrapolation Schemes`_ for all available schemes. :type scf_scheme: function; :param scf_scheme: |dl| ``highest_1`` |dr| || ``scf_xtpl_helgaker_3`` || etc. Indicates the basis set extrapolation scheme to be applied to the reference energy. :type corl_scheme: function; :param corl_scheme: |dl| ``highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the correlation energy. :type delta_scheme: function; :param delta_scheme: |dl| ``highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the delta correction; to the correlation energy. :type delta2_scheme: function; :param delta2_scheme: |dl| ``highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the second delta correction; to the correlation energy. :type delta3_scheme: function; :param delta3_scheme: |dl| ``highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis ",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:5630,Deployability,configurat,configuration,5630,"name, **kwargs):; lowername = name.lower(); kwargs = p4util.kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name.lower(). # Establish function to call; if not('n_body_func' in kwargs):; if ('func' in kwargs):; kwargs['n_body_func'] = kwargs['func']; del kwargs['func']; else:; kwargs['n_body_func'] = energy; func = kwargs['n_body_func']; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper n_body.' % (func.__name__)); if (func is db):; raise ValidationError('Wrapper n_body is unhappy to be calling function \'%s\'.' % (func.__name__)). # Make sure the molecule the user provided is the active one; if 'molecule' in kwargs:; activate(kwargs['molecule']); del kwargs['molecule']; molecule = psi4.get_active_molecule(); molecule.update_geometry(); psi4.set_global_option(""BASIS"", psi4.get_global_option(""BASIS"")). # N-body run configuration; bsse = 'on'; if 'bsse' in kwargs:; bsse = kwargs['bsse']. max_n_body = molecule.nfragments(); if 'max_n_body' in kwargs:; max_n_body = kwargs['max_n_body']. do_total = False; if 'do_total' in kwargs:; do_total = kwargs['do_total']. external = None; external_indices = []; if 'external' in kwargs:; external = kwargs['external']; external_indices = [molecule.nfragments()]; if 'external_monomers' in kwargs:; external_indices = kwargs['external_monomers']. # Check input args; if not bsse == 'off' and not bsse == 'on' and not bsse == 'both':; raise ValidationError('n_body: bsse argument is one of on, off, or both'); if max_n_body < 1:; raise ValidationError('n_body: max_n_body must be at least 1'); if max_n_body > molecule.nfragments():; raise ValidationError('n_body: max_n_body must be <= to the number of fragments in the molecule'). # Set to save RI integrals for repeated full-basis computations; ri_ints_io = psi4.get_global_option('DF_INTS_IO'); # inquire if above at all applies to dfmp2 or just scf; p",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:25527,Deployability,continuous,continuous,25527," Indicates the computational method; to be applied to the database. May be any valid argument to; :py:func:`~driver.energy`. :type db_name: string; :param db_name: ``'BASIC'`` || ``'S22'`` || ``'HTBH'`` || etc. Second argument, usually unlabeled. Indicates the requested database; name, matching (case insensitive) the name of a python file in; ``psi4/lib/databases`` or :envvar:`PYTHONPATH`. Consult that; directory for available databases and literature citations. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``energy`` |dr| || ``optimize`` || ``cbs``. Indicates the type of calculation to be performed on each database; member. The default performs a single-point ``energy('name')``, while; ``optimize`` perfoms a geometry optimization on each reagent, and; ``cbs`` performs a compound single-point energy. If a nested series; of python functions is intended (see :ref:`sec:intercalls`), use; keyword ``db_func`` instead of ``func``. :type mode: string; :param mode: |dl| ``'continuous'`` |dr| || ``'sow'`` || ``'reap'``. Indicates whether the calculations required to complete the; database are to be run in one file (``'continuous'``) or are to be; farmed out in an embarrassingly parallel fashion; (``'sow'``/``'reap'``). For the latter, run an initial job with; ``'sow'`` and follow instructions in its output file. :type cp: :ref:`boolean <op_py_boolean>`; :param cp: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether counterpoise correction is employed in computing; interaction energies. Use this option and NOT the :py:func:`~wrappers.cp`; function for BSSE correction in database(). Option available; (See :ref:`sec:availableDatabases`) only for databases of bimolecular complexes. :type rlxd: :ref:`boolean <op_py_boolean>`; :param rlxd: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether correction for deformation energy is; employed in computing interaction energies. Option available; (See :ref:`sec:availableDatabases`) only for databases of bimolecular complex",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:25674,Deployability,continuous,continuous,25674,"g; :param db_name: ``'BASIC'`` || ``'S22'`` || ``'HTBH'`` || etc. Second argument, usually unlabeled. Indicates the requested database; name, matching (case insensitive) the name of a python file in; ``psi4/lib/databases`` or :envvar:`PYTHONPATH`. Consult that; directory for available databases and literature citations. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``energy`` |dr| || ``optimize`` || ``cbs``. Indicates the type of calculation to be performed on each database; member. The default performs a single-point ``energy('name')``, while; ``optimize`` perfoms a geometry optimization on each reagent, and; ``cbs`` performs a compound single-point energy. If a nested series; of python functions is intended (see :ref:`sec:intercalls`), use; keyword ``db_func`` instead of ``func``. :type mode: string; :param mode: |dl| ``'continuous'`` |dr| || ``'sow'`` || ``'reap'``. Indicates whether the calculations required to complete the; database are to be run in one file (``'continuous'``) or are to be; farmed out in an embarrassingly parallel fashion; (``'sow'``/``'reap'``). For the latter, run an initial job with; ``'sow'`` and follow instructions in its output file. :type cp: :ref:`boolean <op_py_boolean>`; :param cp: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether counterpoise correction is employed in computing; interaction energies. Use this option and NOT the :py:func:`~wrappers.cp`; function for BSSE correction in database(). Option available; (See :ref:`sec:availableDatabases`) only for databases of bimolecular complexes. :type rlxd: :ref:`boolean <op_py_boolean>`; :param rlxd: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether correction for deformation energy is; employed in computing interaction energies. Option available; (See :ref:`sec:availableDatabases`) only for databases of bimolecular complexes; with non-frozen monomers, e.g., HBC6. :type symm: :ref:`boolean <op_py_boolean>`; :param symm: |dl| ``'on'`` |dr| || ``'off'``. Indicates whet",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:31951,Deployability,Configurat,Configuration,31951,"; raise ValidationError(""Python module loading problem for database "" + str(db_name)); else:; dbse = database.dbse; HRXN = database.HRXN; ACTV = database.ACTV; RXNM = database.RXNM; BIND = database.BIND; TAGL = database.TAGL; GEOS = database.GEOS; try:; DATA = database.DATA; except AttributeError:; DATA = {}. # Must collect (here) and set (below) basis sets after every new molecule activation; user_basis = psi4.get_global_option('BASIS'); user_df_basis_scf = psi4.get_global_option('DF_BASIS_SCF'); user_df_basis_mp2 = psi4.get_global_option('DF_BASIS_MP2'); user_df_basis_sapt = psi4.get_global_option('DF_BASIS_SAPT'); user_df_basis_elst = psi4.get_global_option('DF_BASIS_ELST'). user_writer_file_label = psi4.get_global_option('WRITER_FILE_LABEL'). b_user_reference = psi4.has_global_option_changed('REFERENCE'); user_reference = psi4.get_global_option('REFERENCE'); user_memory = psi4.get_memory(). user_molecule = psi4.get_active_molecule(). # Configuration based upon e_name & db_name options; # Force non-supramolecular if needed; if re.match(r'^sapt', lowername) or re.match(r'^.*sapt', lowername):; try:; database.ACTV_SA; except AttributeError:; raise ValidationError('Database %s not suitable for non-supramolecular calculation.' % (db_name)); else:; ACTV = database.ACTV_SA; # Force open-shell if needed; openshell_override = 0; if (user_reference == 'RHF') or (user_reference == 'RKS'):; try:; database.isOS; except AttributeError:; pass; else:; if yes.match(str(database.isOS)):; openshell_override = 1; psi4.print_out('\nSome reagents in database %s require an open-shell reference; will be reset to UHF/UKS as needed.\n' % (db_name)). # Configuration based upon database keyword options; # Option symmetry- whether symmetry treated normally or turned off (currently req'd for dfmp2 & dft); db_symm = 'yes'; if 'symm' in kwargs:; db_symm = kwargs['symm']. symmetry_override = 0; if no.match(str(db_symm)):; symmetry_override = 1; elif yes.match(str(db_symm)):; pass; else:; raise ",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:32655,Deployability,Configurat,Configuration,32655,"eference = psi4.has_global_option_changed('REFERENCE'); user_reference = psi4.get_global_option('REFERENCE'); user_memory = psi4.get_memory(). user_molecule = psi4.get_active_molecule(). # Configuration based upon e_name & db_name options; # Force non-supramolecular if needed; if re.match(r'^sapt', lowername) or re.match(r'^.*sapt', lowername):; try:; database.ACTV_SA; except AttributeError:; raise ValidationError('Database %s not suitable for non-supramolecular calculation.' % (db_name)); else:; ACTV = database.ACTV_SA; # Force open-shell if needed; openshell_override = 0; if (user_reference == 'RHF') or (user_reference == 'RKS'):; try:; database.isOS; except AttributeError:; pass; else:; if yes.match(str(database.isOS)):; openshell_override = 1; psi4.print_out('\nSome reagents in database %s require an open-shell reference; will be reset to UHF/UKS as needed.\n' % (db_name)). # Configuration based upon database keyword options; # Option symmetry- whether symmetry treated normally or turned off (currently req'd for dfmp2 & dft); db_symm = 'yes'; if 'symm' in kwargs:; db_symm = kwargs['symm']. symmetry_override = 0; if no.match(str(db_symm)):; symmetry_override = 1; elif yes.match(str(db_symm)):; pass; else:; raise ValidationError('Symmetry mode \'%s\' not valid.' % (db_symm)). # Option mode of operation- whether db run in one job or files farmed out; if not('db_mode' in kwargs):; if ('mode' in kwargs):; kwargs['db_mode'] = kwargs['mode']; del kwargs['mode']; else:; kwargs['db_mode'] = 'continuous'; db_mode = kwargs['db_mode']. if (db_mode.lower() == 'continuous'):; pass; elif (db_mode.lower() == 'sow'):; pass; elif (db_mode.lower() == 'reap'):; if 'linkage' in kwargs:; db_linkage = kwargs['linkage']; else:; raise ValidationError('Database execution mode \'reap\' requires a linkage option.'); else:; raise ValidationError('Database execution mode \'%s\' not valid.' % (db_mode)). # Option counterpoise- whether for interaction energy databases run in bsse-corrected or ",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:33274,Deployability,continuous,continuous,33274,se %s not suitable for non-supramolecular calculation.' % (db_name)); else:; ACTV = database.ACTV_SA; # Force open-shell if needed; openshell_override = 0; if (user_reference == 'RHF') or (user_reference == 'RKS'):; try:; database.isOS; except AttributeError:; pass; else:; if yes.match(str(database.isOS)):; openshell_override = 1; psi4.print_out('\nSome reagents in database %s require an open-shell reference; will be reset to UHF/UKS as needed.\n' % (db_name)). # Configuration based upon database keyword options; # Option symmetry- whether symmetry treated normally or turned off (currently req'd for dfmp2 & dft); db_symm = 'yes'; if 'symm' in kwargs:; db_symm = kwargs['symm']. symmetry_override = 0; if no.match(str(db_symm)):; symmetry_override = 1; elif yes.match(str(db_symm)):; pass; else:; raise ValidationError('Symmetry mode \'%s\' not valid.' % (db_symm)). # Option mode of operation- whether db run in one job or files farmed out; if not('db_mode' in kwargs):; if ('mode' in kwargs):; kwargs['db_mode'] = kwargs['mode']; del kwargs['mode']; else:; kwargs['db_mode'] = 'continuous'; db_mode = kwargs['db_mode']. if (db_mode.lower() == 'continuous'):; pass; elif (db_mode.lower() == 'sow'):; pass; elif (db_mode.lower() == 'reap'):; if 'linkage' in kwargs:; db_linkage = kwargs['linkage']; else:; raise ValidationError('Database execution mode \'reap\' requires a linkage option.'); else:; raise ValidationError('Database execution mode \'%s\' not valid.' % (db_mode)). # Option counterpoise- whether for interaction energy databases run in bsse-corrected or not; db_cp = 'no'; if 'cp' in kwargs:; db_cp = kwargs['cp']. if yes.match(str(db_cp)):; try:; database.ACTV_CP; except AttributeError:; raise ValidationError('Counterpoise correction mode \'yes\' invalid for database %s.' % (db_name)); else:; ACTV = database.ACTV_CP; elif no.match(str(db_cp)):; pass; else:; raise ValidationError('Counterpoise correction mode \'%s\' not valid.' % (db_cp)). # Option relaxed- whether for non-,MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:33340,Deployability,continuous,continuous,33340,_reference == 'RHF') or (user_reference == 'RKS'):; try:; database.isOS; except AttributeError:; pass; else:; if yes.match(str(database.isOS)):; openshell_override = 1; psi4.print_out('\nSome reagents in database %s require an open-shell reference; will be reset to UHF/UKS as needed.\n' % (db_name)). # Configuration based upon database keyword options; # Option symmetry- whether symmetry treated normally or turned off (currently req'd for dfmp2 & dft); db_symm = 'yes'; if 'symm' in kwargs:; db_symm = kwargs['symm']. symmetry_override = 0; if no.match(str(db_symm)):; symmetry_override = 1; elif yes.match(str(db_symm)):; pass; else:; raise ValidationError('Symmetry mode \'%s\' not valid.' % (db_symm)). # Option mode of operation- whether db run in one job or files farmed out; if not('db_mode' in kwargs):; if ('mode' in kwargs):; kwargs['db_mode'] = kwargs['mode']; del kwargs['mode']; else:; kwargs['db_mode'] = 'continuous'; db_mode = kwargs['db_mode']. if (db_mode.lower() == 'continuous'):; pass; elif (db_mode.lower() == 'sow'):; pass; elif (db_mode.lower() == 'reap'):; if 'linkage' in kwargs:; db_linkage = kwargs['linkage']; else:; raise ValidationError('Database execution mode \'reap\' requires a linkage option.'); else:; raise ValidationError('Database execution mode \'%s\' not valid.' % (db_mode)). # Option counterpoise- whether for interaction energy databases run in bsse-corrected or not; db_cp = 'no'; if 'cp' in kwargs:; db_cp = kwargs['cp']. if yes.match(str(db_cp)):; try:; database.ACTV_CP; except AttributeError:; raise ValidationError('Counterpoise correction mode \'yes\' invalid for database %s.' % (db_name)); else:; ACTV = database.ACTV_CP; elif no.match(str(db_cp)):; pass; else:; raise ValidationError('Counterpoise correction mode \'%s\' not valid.' % (db_cp)). # Option relaxed- whether for non-frozen-monomer interaction energy databases include deformation correction or not?; db_rlxd = 'no'; if 'rlxd' in kwargs:; db_rlxd = kwargs['rlxd']. if yes.match(str,MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:37576,Deployability,continuous,continuous,37576,"_EQ; except AttributeError:; raise ValidationError('Special subset \'equilibrium\' not available for database %s.' % (db_name)); else:; HRXN = database.HRXN_EQ; else:; HRXN = p4util.getattr_ignorecase(database, db_subset); if HRXN is None:; HRXN = p4util.getattr_ignorecase(database, 'HRXN_' + db_subset); if HRXN is None:; raise ValidationError('Special subset \'%s\' not available for database %s.' % (db_subset, db_name)); else:; temp = []; for rxn in db_subset:; if rxn in HRXN:; temp.append(rxn); else:; raise ValidationError('Subset element \'%s\' not a member of database %s.' % (str(rxn), db_name)); HRXN = temp. temp = []; for rxn in HRXN:; temp.append(ACTV['%s-%s' % (dbse, rxn)]); HSYS = p4util.drop_duplicates(sum(temp, [])). # Sow all the necessary reagent computations; psi4.print_out(""\n\n""); p4util.banner((""Database %s Computation"" % (db_name))); psi4.print_out(""\n""). # write index of calcs to output file; if (db_mode.lower() == 'continuous'):; instructions = """"""\n The database single-job procedure has been selected through mode='continuous'.\n""""""; instructions += """""" Calculations for the reagents will proceed in the order below and will be followed\n""""""; instructions += """""" by summary results for the database.\n\n""""""; for rgt in HSYS:; instructions += """""" %-s\n"""""" % (rgt); instructions += """"""\n Alternatively, a farming-out of the database calculations may be accessed through\n""""""; instructions += """""" the database wrapper option mode='sow'/'reap'.\n\n""""""; psi4.print_out(instructions). # write sow/reap instructions and index of calcs to output file and reap input file; if (db_mode.lower() == 'sow'):; instructions = """"""\n The database sow/reap procedure has been selected through mode='sow'. In addition\n""""""; instructions += """""" to this output file (which contains no quantum chemical calculations), this job\n""""""; instructions += """""" has produced a number of input files (%s-*.in) for individual database members\n"""""" % (dbse); instructions += """""" and a single input ",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:37678,Deployability,continuous,continuous,37678,"_EQ; except AttributeError:; raise ValidationError('Special subset \'equilibrium\' not available for database %s.' % (db_name)); else:; HRXN = database.HRXN_EQ; else:; HRXN = p4util.getattr_ignorecase(database, db_subset); if HRXN is None:; HRXN = p4util.getattr_ignorecase(database, 'HRXN_' + db_subset); if HRXN is None:; raise ValidationError('Special subset \'%s\' not available for database %s.' % (db_subset, db_name)); else:; temp = []; for rxn in db_subset:; if rxn in HRXN:; temp.append(rxn); else:; raise ValidationError('Subset element \'%s\' not a member of database %s.' % (str(rxn), db_name)); HRXN = temp. temp = []; for rxn in HRXN:; temp.append(ACTV['%s-%s' % (dbse, rxn)]); HSYS = p4util.drop_duplicates(sum(temp, [])). # Sow all the necessary reagent computations; psi4.print_out(""\n\n""); p4util.banner((""Database %s Computation"" % (db_name))); psi4.print_out(""\n""). # write index of calcs to output file; if (db_mode.lower() == 'continuous'):; instructions = """"""\n The database single-job procedure has been selected through mode='continuous'.\n""""""; instructions += """""" Calculations for the reagents will proceed in the order below and will be followed\n""""""; instructions += """""" by summary results for the database.\n\n""""""; for rgt in HSYS:; instructions += """""" %-s\n"""""" % (rgt); instructions += """"""\n Alternatively, a farming-out of the database calculations may be accessed through\n""""""; instructions += """""" the database wrapper option mode='sow'/'reap'.\n\n""""""; psi4.print_out(instructions). # write sow/reap instructions and index of calcs to output file and reap input file; if (db_mode.lower() == 'sow'):; instructions = """"""\n The database sow/reap procedure has been selected through mode='sow'. In addition\n""""""; instructions += """""" to this output file (which contains no quantum chemical calculations), this job\n""""""; instructions += """""" has produced a number of input files (%s-*.in) for individual database members\n"""""" % (dbse); instructions += """""" and a single input ",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:39748,Deployability,continuous,continuous,39748,"ap') command.\n"""""" % (dbse); instructions += """""" The former may look very peculiar since processed and pickled python rather than\n""""""; instructions += """""" raw input is written. Follow the instructions below to continue.\n\n""""""; instructions += """""" (1) Run all of the %s-*.in input files on any variety of computer architecture.\n"""""" % (dbse); instructions += """""" The output file names must be as given below.\n\n""""""; for rgt in HSYS:; instructions += """""" psi4 -i %-27s -o %-27s\n"""""" % (rgt + '.in', rgt + '.out'); instructions += """"""\n (2) Gather all the resulting output files in a directory. Place input file\n""""""; instructions += """""" %s-master.in into that directory and run it. The job will be trivial in\n"""""" % (dbse); instructions += """""" length and give summary results for the database in its output file.\n\n""""""; instructions += """""" psi4 -i %-27s -o %-27s\n\n"""""" % (dbse + '-master.in', dbse + '-master.out'); instructions += """""" Alternatively, a single-job execution of the database may be accessed through\n""""""; instructions += """""" the database wrapper option mode='continuous'.\n\n""""""; psi4.print_out(instructions). fmaster = open('%s-master.in' % (dbse), 'w'); fmaster.write('# This is a psi4 input file auto-generated from the database() wrapper.\n\n'); fmaster.write(""database('%s', '%s', mode='reap', cp='%s', rlxd='%s', zpe='%s', benchmark='%s', linkage=%d, subset=%s, tabulate=%s)\n\n"" %; (name, db_name, db_cp, db_rlxd, db_zpe, db_benchmark, os.getpid(), HRXN, db_tabulate)); fmaster.close(). # Loop through chemical systems; ERGT = {}; ERXN = {}; VRGT = {}; VRXN = {}; for rgt in HSYS:; VRGT[rgt] = {}. # extra definition of molecule so that logic in building commands string has something to act on; exec(p4util.format_molecule_for_input(GEOS[rgt])); molecule = psi4.get_active_molecule(). # build string of title banner; banners = ''; banners += """"""psi4.print_out('\\n')\n""""""; banners += """"""p4util.banner(' Database %s Computation: Reagent %s \\n %s')\n"""""" % (db_name, rgt, TAGL[",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:43467,Deployability,continuous,continuous,43467,"er_df_basis_elst == 'NONE')):; commands += """"""psi4.set_global_option('DF_BASIS_ELST', '%s')\n"""""" % (user_df_basis_elst); commands += """"""molecule = psi4.get_active_molecule()\n""""""; commands += """"""molecule.update_geometry()\n"""""". if symmetry_override:; commands += """"""molecule.reset_point_group('c1')\n""""""; commands += """"""molecule.fix_orientation(1)\n""""""; commands += """"""molecule.update_geometry()\n"""""". if (openshell_override) and (molecule.multiplicity() != 1):; if user_reference == 'RHF':; commands += """"""psi4.set_global_option('REFERENCE', 'UHF')\n""""""; elif user_reference == 'RKS':; commands += """"""psi4.set_global_option('REFERENCE', 'UKS')\n"""""". commands += """"""psi4.set_global_option('WRITER_FILE_LABEL', '%s')\n"""""" % \; (user_writer_file_label + ('' if user_writer_file_label == '' else '-') + rgt). # all modes need to step through the reagents but all for different purposes; # continuous: defines necessary commands, executes energy(method) call, and collects results into dictionary; # sow: opens individual reagent input file, writes the necessary commands, and writes energy(method) call; # reap: opens individual reagent output file, collects results into a dictionary; if (db_mode.lower() == 'continuous'):; exec(banners); exec(p4util.format_molecule_for_input(GEOS[rgt])); exec(commands); #print 'MOLECULE LIVES %23s %8s %4d %4d %4s' % (rgt, psi4.get_global_option('REFERENCE'),; # molecule.molecular_charge(), molecule.multiplicity(), molecule.schoenflies_symbol()); psi4.set_variable('NATOM', molecule.natom()); psi4.set_variable('NUCLEAR REPULSION ENERGY', molecule.nuclear_repulsion_energy()); if re.match(r'^verify', lowername):; compare_values(DATA['NUCLEAR REPULSION ENERGY'][rgt], psi4.get_variable('NUCLEAR REPULSION ENERGY'),; 4, '%s %.4f' % (rgt, psi4.get_variable('NUCLEAR REPULSION ENERGY'))); ERGT[rgt] = 7.0; else:; ERGT[rgt] = call_function_in_1st_argument(func, **kwargs); #print ERGT[rgt]; psi4.print_variables(); exec(actives); for envv in db_tabulate:; VRGT[rgt][en",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:43788,Deployability,continuous,continuous,43788,"n"""""". if symmetry_override:; commands += """"""molecule.reset_point_group('c1')\n""""""; commands += """"""molecule.fix_orientation(1)\n""""""; commands += """"""molecule.update_geometry()\n"""""". if (openshell_override) and (molecule.multiplicity() != 1):; if user_reference == 'RHF':; commands += """"""psi4.set_global_option('REFERENCE', 'UHF')\n""""""; elif user_reference == 'RKS':; commands += """"""psi4.set_global_option('REFERENCE', 'UKS')\n"""""". commands += """"""psi4.set_global_option('WRITER_FILE_LABEL', '%s')\n"""""" % \; (user_writer_file_label + ('' if user_writer_file_label == '' else '-') + rgt). # all modes need to step through the reagents but all for different purposes; # continuous: defines necessary commands, executes energy(method) call, and collects results into dictionary; # sow: opens individual reagent input file, writes the necessary commands, and writes energy(method) call; # reap: opens individual reagent output file, collects results into a dictionary; if (db_mode.lower() == 'continuous'):; exec(banners); exec(p4util.format_molecule_for_input(GEOS[rgt])); exec(commands); #print 'MOLECULE LIVES %23s %8s %4d %4d %4s' % (rgt, psi4.get_global_option('REFERENCE'),; # molecule.molecular_charge(), molecule.multiplicity(), molecule.schoenflies_symbol()); psi4.set_variable('NATOM', molecule.natom()); psi4.set_variable('NUCLEAR REPULSION ENERGY', molecule.nuclear_repulsion_energy()); if re.match(r'^verify', lowername):; compare_values(DATA['NUCLEAR REPULSION ENERGY'][rgt], psi4.get_variable('NUCLEAR REPULSION ENERGY'),; 4, '%s %.4f' % (rgt, psi4.get_variable('NUCLEAR REPULSION ENERGY'))); ERGT[rgt] = 7.0; else:; ERGT[rgt] = call_function_in_1st_argument(func, **kwargs); #print ERGT[rgt]; psi4.print_variables(); exec(actives); for envv in db_tabulate:; VRGT[rgt][envv.upper()] = psi4.get_variable(envv); psi4.set_global_option(""REFERENCE"", user_reference); psi4.clean(). elif (db_mode.lower() == 'sow'):; freagent = open('%s.in' % (rgt), 'w'); freagent.write('# This is a psi4 input file",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:51494,Deployability,update,update,51494,"""%23s %19s %8.4f\n"""""" % ('Maximal Dev', '', maxDerror); tables += """"""%23s %19s %8.4f\n"""""" % ('Mean Signed Dev', '', MSDerror); tables += """"""%23s %19s %8.4f\n"""""" % ('Mean Absolute Dev', '', MADerror); tables += """"""%23s %19s %8.4f\n"""""" % ('RMS Dev', '', RMSDerror); tables += """""" %s\n"""""" % (table_delimit). psi4.set_variable('%s DATABASE MEAN SIGNED DEVIATION' % (db_name), MSDerror); psi4.set_variable('%s DATABASE MEAN ABSOLUTE DEVIATION' % (db_name), MADerror); psi4.set_variable('%s DATABASE ROOT-MEAN-SQUARE DEVIATION' % (db_name), RMSDerror). #print tables; psi4.print_out(tables); finalenergy = MADerror. else:; finalenergy = 0.0. # restore molecule and options; activate(user_molecule); user_molecule.update_geometry(); psi4.set_global_option(""BASIS"", user_basis); psi4.set_global_option(""REFERENCE"", user_reference); if not b_user_reference:; psi4.revoke_global_option_changed('REFERENCE'); psi4.set_global_option('WRITER_FILE_LABEL', user_writer_file_label). DB_RGT.clear(); DB_RGT.update(VRGT); DB_RXN.clear(); DB_RXN.update(VRXN); return finalenergy. [docs]def tblhead(tbl_maxrgt, tbl_delimit, ttype):; r""""""Function that prints the header for the changable-width results tables in db().; *tbl_maxrgt* is the number of reagent columns the table must plan for. *tbl_delimit*; is a string of dashes of the correct length to set off the table. *ttype* is 1 for; tables comparing the computed values to the reference or 2 for simple tabulation; and sum of the computed values. """"""; tbl_str = ''; tbl_str += """""" %s"""""" % (tbl_delimit); if ttype == 1:; tbl_str += """"""\n%23s %19s %8s"""""" % ('Reaction', 'Reaction Energy', 'Error'); elif ttype == 2:; tbl_str += """"""\n%23s %19s %6s"""""" % ('Reaction', 'Reaction Value', ''); for i in range(tbl_maxrgt):; tbl_str += """"""%20s"""""" % ('Reagent ' + str(i + 1)); if ttype == 1:; tbl_str += """"""\n%23s %8s %8s %8s"""""" % ('', 'Ref', 'Calc', '[kcal/mol]'); elif ttype == 2:; tbl_str += """"""\n%54s"""""" % (''); for i in range(tbl_maxrgt):; if ttype == 1:; tbl_str += """"""%2",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:51531,Deployability,update,update,51531," maxDerror); tables += """"""%23s %19s %8.4f\n"""""" % ('Mean Signed Dev', '', MSDerror); tables += """"""%23s %19s %8.4f\n"""""" % ('Mean Absolute Dev', '', MADerror); tables += """"""%23s %19s %8.4f\n"""""" % ('RMS Dev', '', RMSDerror); tables += """""" %s\n"""""" % (table_delimit). psi4.set_variable('%s DATABASE MEAN SIGNED DEVIATION' % (db_name), MSDerror); psi4.set_variable('%s DATABASE MEAN ABSOLUTE DEVIATION' % (db_name), MADerror); psi4.set_variable('%s DATABASE ROOT-MEAN-SQUARE DEVIATION' % (db_name), RMSDerror). #print tables; psi4.print_out(tables); finalenergy = MADerror. else:; finalenergy = 0.0. # restore molecule and options; activate(user_molecule); user_molecule.update_geometry(); psi4.set_global_option(""BASIS"", user_basis); psi4.set_global_option(""REFERENCE"", user_reference); if not b_user_reference:; psi4.revoke_global_option_changed('REFERENCE'); psi4.set_global_option('WRITER_FILE_LABEL', user_writer_file_label). DB_RGT.clear(); DB_RGT.update(VRGT); DB_RXN.clear(); DB_RXN.update(VRXN); return finalenergy. [docs]def tblhead(tbl_maxrgt, tbl_delimit, ttype):; r""""""Function that prints the header for the changable-width results tables in db().; *tbl_maxrgt* is the number of reagent columns the table must plan for. *tbl_delimit*; is a string of dashes of the correct length to set off the table. *ttype* is 1 for; tables comparing the computed values to the reference or 2 for simple tabulation; and sum of the computed values. """"""; tbl_str = ''; tbl_str += """""" %s"""""" % (tbl_delimit); if ttype == 1:; tbl_str += """"""\n%23s %19s %8s"""""" % ('Reaction', 'Reaction Energy', 'Error'); elif ttype == 2:; tbl_str += """"""\n%23s %19s %6s"""""" % ('Reaction', 'Reaction Value', ''); for i in range(tbl_maxrgt):; tbl_str += """"""%20s"""""" % ('Reagent ' + str(i + 1)); if ttype == 1:; tbl_str += """"""\n%23s %8s %8s %8s"""""" % ('', 'Ref', 'Calc', '[kcal/mol]'); elif ttype == 2:; tbl_str += """"""\n%54s"""""" % (''); for i in range(tbl_maxrgt):; if ttype == 1:; tbl_str += """"""%20s"""""" % ('[H] Wt'); elif ttype == 2:; tbl_s",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:53666,Deployability,configurat,configuration,53666,"###################; ## End of Database ##; #######################. ###################################; ## Start of Complete Basis Set ##; ###################################. [docs]def complete_basis_set(name, **kwargs):; r""""""Function to define a multistage energy method from combinations of; basis set extrapolations and delta corrections and condense the; components into a minimum number of calculations. :aliases: cbs(). :returns: (*float*) -- Total electronic energy in Hartrees. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CBS TOTAL ENERGY <CBSTOTALENERGY>`; * :psivar:`CBS REFERENCE ENERGY <CBSREFERENCEENERGY>`; * :psivar:`CBS CORRELATION ENERGY <CBSCORRELATIONENERGY>`; * :psivar:`CURRENT ENERGY <CURRENTENERGY>`; * :psivar:`CURRENT REFERENCE ENERGY <CURRENTREFERENCEENERGY>`; * :psivar:`CURRENT CORRELATION ENERGY <CURRENTCORRELATIONENERGY>`. .. caution:: Some features are not yet implemented. Buy a developer a coffee. - Not all methods hooked in through PSI variables, configuration interaction and arbitrary order MP in particular. - No scheme defaults for given basis zeta number, so scheme must be specified explicitly. - No way to tell function to boost fitting basis size for all calculations. - No way to extrapolate def2 family basis sets. - Need to add more extrapolation schemes. As represented in the equation below, a CBS energy method is defined in several; sequential stages (scf, corl, delta, delta2, delta3, delta4, delta5) covering treatment; of the reference total energy, the correlation energy, a delta correction to the; correlation energy, and a second delta correction, etc.. Each is activated by its; stage_wfn keyword and is only allowed if all preceding stages are active. .. include:: cbs_eqn.rst. * Energy Methods; The presence of a stage_wfn keyword is the indicator to incorporate; (and check for stage_basis and stage_scheme keywords) and compute; that stage in defining the CBS energy. The cbs() function requires, at a minimum, ``name='scf'`` ",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:102970,Deployability,update,updated,102970,"h(r'corl_.*$', functionname) and (wfnname == 'scf'):; raise ValidationError('Call to \'%s\' is not intended for scf portion of calculation.' % (functionname)). if 'basisname' in largs:; BSET = largs['basisname']; else:; raise ValidationError('Call to \'%s\' has keyword \'basisname\' missing.' % (functionname)). if 'basiszeta' in largs:; ZSET = largs['basiszeta']; else:; raise ValidationError('Call to \'%s\' has keyword \'basiszeta\' missing.' % (functionname)). # Mode where function reads the now-filled-in energies from that same form and performs the sp, xtpl, delta, etc.; elif (largs['mode'].lower() == 'evaluate'):; mode = largs['mode'].lower(). if 'needname' in largs:; NEED = largs['needname']; else:; raise ValidationError('Call to \'%s\' has keyword \'needname\' missing.' % (functionname)). else:; raise ValidationError('Call to \'%s\' has keyword \'mode\' missing or invalid.' % (functionname)). return [mode, NEED, wfnname, BSET, ZSET]. [docs]def split_menial(menial):; r""""""Function used by :py:func:`~wrappers.complete_basis_set` to separate; *menial* 'scftot' into [scf, tot] and 'mp2corl' into [mp2, corl]. """"""; PTYP = ['tot', 'corl']; for temp in PTYP:; if menial.endswith(temp):; temp_wfn = menial[:-len(temp)]; temp_portion = temp. return [temp_wfn, temp_portion]. # Quickly normalize the types for both python 2 and 3; try:; unicode = unicode; except NameError:; # 'unicode' is undefined, must be Python 3; str = str; unicode = str; bytes = bytes; basestring = (str,bytes); else:; # 'unicode' exists, must be Python 2; str = str; unicode = unicode; bytes = str; basestring = basestring. ## Aliases ##; cbs = complete_basis_set. #################################; ## End of Complete Basis Set ##; #################################. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  ; PSI4 [beta5]  ; Module code .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:1055,Energy Efficiency,energy,energy,1055,"s  . toc  ; PSI4 [beta5]  ; Module code . Source code for wrappers; #; #@BEGIN LICENSE; #; # PSI4: an ab initio quantum chemistry software package; #; # This program is free software; you can redistribute it and/or modify; # it under the terms of the GNU General Public License as published by; # the Free Software Foundation; either version 2 of the License, or; # (at your option) any later version.; #; # This program is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU General Public License for more details.; #; # You should have received a copy of the GNU General Public License along; # with this program; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; #@END LICENSE; #. """"""Module with functions that call the four main :py:mod:`driver`; functions: :py:mod:`driver.energy`, :py:mod:`driver.optimize`,; :py:mod:`driver.response`, and :py:mod:`driver.frequency`. """"""; import re; import os; import math; import warnings; import pickle; import copy; import collections; import psi4; import p4const; import p4util; from driver import *; #from extend_Molecule import *; from molutil import *; from p4regex import *; # never import aliases into this file. # Function to make calls among wrappers(), energy(), optimize(), etc.; [docs]def call_function_in_1st_argument(funcarg, **largs):; r""""""Function to make primary function call to energy(), opt(), etc.; with options dictionary *largs*.; Useful when *funcarg* to call is stored in variable. """"""; return funcarg(**largs). [docs]def convert(p, symbol):; if symbol[p] == 'H':; d = 1.001; if symbol[p] == 'He':; d = 1.012; if symbol[p] == 'Li':; d = 0.825; if symbol[p] == 'Be':; d = 1.408; if symbol[p] == 'B':; d = 1.485; if symbol[p] == 'C':; d = 1.452; if symbol[p] == 'N':; d = 1.397; if symbol[p] == 'O':; d = 1.342; if symbol[p] =",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:1482,Energy Efficiency,energy,energy,1482,".; #; # This program is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU General Public License for more details.; #; # You should have received a copy of the GNU General Public License along; # with this program; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; #@END LICENSE; #. """"""Module with functions that call the four main :py:mod:`driver`; functions: :py:mod:`driver.energy`, :py:mod:`driver.optimize`,; :py:mod:`driver.response`, and :py:mod:`driver.frequency`. """"""; import re; import os; import math; import warnings; import pickle; import copy; import collections; import psi4; import p4const; import p4util; from driver import *; #from extend_Molecule import *; from molutil import *; from p4regex import *; # never import aliases into this file. # Function to make calls among wrappers(), energy(), optimize(), etc.; [docs]def call_function_in_1st_argument(funcarg, **largs):; r""""""Function to make primary function call to energy(), opt(), etc.; with options dictionary *largs*.; Useful when *funcarg* to call is stored in variable. """"""; return funcarg(**largs). [docs]def convert(p, symbol):; if symbol[p] == 'H':; d = 1.001; if symbol[p] == 'He':; d = 1.012; if symbol[p] == 'Li':; d = 0.825; if symbol[p] == 'Be':; d = 1.408; if symbol[p] == 'B':; d = 1.485; if symbol[p] == 'C':; d = 1.452; if symbol[p] == 'N':; d = 1.397; if symbol[p] == 'O':; d = 1.342; if symbol[p] == 'F':; d = 1.287; if symbol[p] == 'Ne':; d = 1.243; if symbol[p] == 'Na':; d = 1.144; if symbol[p] == 'Mg':; d = 1.364; if symbol[p] == 'Al':; d = 1.639; if symbol[p] == 'Si':; d = 1.716; if symbol[p] == 'P':; d = 1.705; if symbol[p] == 'S':; d = 1.683; if symbol[p] == 'Cl':; d = 1.639; if symbol[p] == 'Ar':; d = 1.595. return d / 1.5. #Automatically detect fragments and build a new molecule for fragm",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:1616,Energy Efficiency,energy,energy,1616,"; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU General Public License for more details.; #; # You should have received a copy of the GNU General Public License along; # with this program; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; #@END LICENSE; #. """"""Module with functions that call the four main :py:mod:`driver`; functions: :py:mod:`driver.energy`, :py:mod:`driver.optimize`,; :py:mod:`driver.response`, and :py:mod:`driver.frequency`. """"""; import re; import os; import math; import warnings; import pickle; import copy; import collections; import psi4; import p4const; import p4util; from driver import *; #from extend_Molecule import *; from molutil import *; from p4regex import *; # never import aliases into this file. # Function to make calls among wrappers(), energy(), optimize(), etc.; [docs]def call_function_in_1st_argument(funcarg, **largs):; r""""""Function to make primary function call to energy(), opt(), etc.; with options dictionary *largs*.; Useful when *funcarg* to call is stored in variable. """"""; return funcarg(**largs). [docs]def convert(p, symbol):; if symbol[p] == 'H':; d = 1.001; if symbol[p] == 'He':; d = 1.012; if symbol[p] == 'Li':; d = 0.825; if symbol[p] == 'Be':; d = 1.408; if symbol[p] == 'B':; d = 1.485; if symbol[p] == 'C':; d = 1.452; if symbol[p] == 'N':; d = 1.397; if symbol[p] == 'O':; d = 1.342; if symbol[p] == 'F':; d = 1.287; if symbol[p] == 'Ne':; d = 1.243; if symbol[p] == 'Na':; d = 1.144; if symbol[p] == 'Mg':; d = 1.364; if symbol[p] == 'Al':; d = 1.639; if symbol[p] == 'Si':; d = 1.716; if symbol[p] == 'P':; d = 1.705; if symbol[p] == 'S':; d = 1.683; if symbol[p] == 'Cl':; d = 1.639; if symbol[p] == 'Ar':; d = 1.595. return d / 1.5. #Automatically detect fragments and build a new molecule for fragment; #needing methods (SAPT0, etc...); [docs]def auto_fragments(name, **kwargs):; r""""""; Detects frag",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:5064,Energy Efficiency,energy,energy,5064,"oup (adding 1 to start; # list at one instead of zero). if(len(White) != 0): # cant move White->Queue if no more exist; Queue.append(White[0]); White.remove(White[0]); frag += 1. new_geom = """"""\n0 1\n""""""; for i in Fragment[0]:; new_geom = new_geom + F[i].lstrip() + """"""\n""""""; new_geom = new_geom + """"""--\n0 1\n""""""; for j in Fragment[1]:; new_geom = new_geom + F[j].lstrip() + """"""\n""""""; new_geom = new_geom + """"""units angstrom\n"""""". new_mol = geometry(new_geom); new_mol.print_out(); psi4.print_out(""Exiting auto_fragments\n""). #######################; ## Start of n_body ##; #######################. [docs]def n_body(name, **kwargs):; lowername = name.lower(); kwargs = p4util.kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name.lower(). # Establish function to call; if not('n_body_func' in kwargs):; if ('func' in kwargs):; kwargs['n_body_func'] = kwargs['func']; del kwargs['func']; else:; kwargs['n_body_func'] = energy; func = kwargs['n_body_func']; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper n_body.' % (func.__name__)); if (func is db):; raise ValidationError('Wrapper n_body is unhappy to be calling function \'%s\'.' % (func.__name__)). # Make sure the molecule the user provided is the active one; if 'molecule' in kwargs:; activate(kwargs['molecule']); del kwargs['molecule']; molecule = psi4.get_active_molecule(); molecule.update_geometry(); psi4.set_global_option(""BASIS"", psi4.get_global_option(""BASIS"")). # N-body run configuration; bsse = 'on'; if 'bsse' in kwargs:; bsse = kwargs['bsse']. max_n_body = molecule.nfragments(); if 'max_n_body' in kwargs:; max_n_body = kwargs['max_n_body']. do_total = False; if 'do_total' in kwargs:; do_total = kwargs['do_total']. external = None; external_indices = []; if 'external' in kwargs:; external = kwargs['external']; external_indices = [molecule.nfragments()]; if 'external_monomers' in",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:6944,Energy Efficiency,Energy,Energy,6944," external = kwargs['external']; external_indices = [molecule.nfragments()]; if 'external_monomers' in kwargs:; external_indices = kwargs['external_monomers']. # Check input args; if not bsse == 'off' and not bsse == 'on' and not bsse == 'both':; raise ValidationError('n_body: bsse argument is one of on, off, or both'); if max_n_body < 1:; raise ValidationError('n_body: max_n_body must be at least 1'); if max_n_body > molecule.nfragments():; raise ValidationError('n_body: max_n_body must be <= to the number of fragments in the molecule'). # Set to save RI integrals for repeated full-basis computations; ri_ints_io = psi4.get_global_option('DF_INTS_IO'); # inquire if above at all applies to dfmp2 or just scf; psi4.set_global_option('DF_INTS_IO', 'SAVE'); psioh = psi4.IOManager.shared_object(); psioh.set_specific_retention(97, True). # Tell 'em what you're gonna tell 'em; has_external = 'No'; if (external):; has_external = 'Yes'; psi4.print_out('\n'); psi4.print_out(' ==> N-Body Interaction Energy Analysis <==\n\n'); psi4.print_out(' BSSE Treatment: %s\n' % (bsse)); psi4.print_out(' Maximum N-Body Interactions: %d\n' % (max_n_body)); psi4.print_out(' Compute Total Energy: %s\n' % (do_total)); psi4.print_out(' External Field: %s\n' % (has_external)); if (external):; psi4.print_out(' External Field Monomers: '); for k in external_indices:; psi4.print_out('%-3d ' % (k)); psi4.print_out('\n'); psi4.print_out('\n'). # Run the total molecule, if required; energies_full = {}; energies_mon = {}; N = molecule.nfragments(); Etotal = 0.0; if do_total or max_n_body == molecule.nfragments():; psi4.print_out(' => Total Cluster Energy <=\n'); # Full cluster always gets the external field; if (external):; psi4.set_global_option_python(""EXTERN"", external); Etotal = call_function_in_1st_argument(func, **kwargs); if (external):; psi4.set_global_option_python(""EXTERN"", None); energies_full[N] = []; energies_full[N].append(Etotal); energies_mon[N] = []; energies_mon[N].append(Etotal); psi4.s",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:7121,Energy Efficiency,Energy,Energy,7121,"ot bsse == 'off' and not bsse == 'on' and not bsse == 'both':; raise ValidationError('n_body: bsse argument is one of on, off, or both'); if max_n_body < 1:; raise ValidationError('n_body: max_n_body must be at least 1'); if max_n_body > molecule.nfragments():; raise ValidationError('n_body: max_n_body must be <= to the number of fragments in the molecule'). # Set to save RI integrals for repeated full-basis computations; ri_ints_io = psi4.get_global_option('DF_INTS_IO'); # inquire if above at all applies to dfmp2 or just scf; psi4.set_global_option('DF_INTS_IO', 'SAVE'); psioh = psi4.IOManager.shared_object(); psioh.set_specific_retention(97, True). # Tell 'em what you're gonna tell 'em; has_external = 'No'; if (external):; has_external = 'Yes'; psi4.print_out('\n'); psi4.print_out(' ==> N-Body Interaction Energy Analysis <==\n\n'); psi4.print_out(' BSSE Treatment: %s\n' % (bsse)); psi4.print_out(' Maximum N-Body Interactions: %d\n' % (max_n_body)); psi4.print_out(' Compute Total Energy: %s\n' % (do_total)); psi4.print_out(' External Field: %s\n' % (has_external)); if (external):; psi4.print_out(' External Field Monomers: '); for k in external_indices:; psi4.print_out('%-3d ' % (k)); psi4.print_out('\n'); psi4.print_out('\n'). # Run the total molecule, if required; energies_full = {}; energies_mon = {}; N = molecule.nfragments(); Etotal = 0.0; if do_total or max_n_body == molecule.nfragments():; psi4.print_out(' => Total Cluster Energy <=\n'); # Full cluster always gets the external field; if (external):; psi4.set_global_option_python(""EXTERN"", external); Etotal = call_function_in_1st_argument(func, **kwargs); if (external):; psi4.set_global_option_python(""EXTERN"", None); energies_full[N] = []; energies_full[N].append(Etotal); energies_mon[N] = []; energies_mon[N].append(Etotal); psi4.set_global_option('DF_INTS_IO', 'LOAD'); psi4.clean(). max_effective = max_n_body; if (max_effective == N):; max_effective = N - 1. # Build the combos for indexing purposes; Ns = []; ",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:7579,Energy Efficiency,Energy,Energy,7579,"quire if above at all applies to dfmp2 or just scf; psi4.set_global_option('DF_INTS_IO', 'SAVE'); psioh = psi4.IOManager.shared_object(); psioh.set_specific_retention(97, True). # Tell 'em what you're gonna tell 'em; has_external = 'No'; if (external):; has_external = 'Yes'; psi4.print_out('\n'); psi4.print_out(' ==> N-Body Interaction Energy Analysis <==\n\n'); psi4.print_out(' BSSE Treatment: %s\n' % (bsse)); psi4.print_out(' Maximum N-Body Interactions: %d\n' % (max_n_body)); psi4.print_out(' Compute Total Energy: %s\n' % (do_total)); psi4.print_out(' External Field: %s\n' % (has_external)); if (external):; psi4.print_out(' External Field Monomers: '); for k in external_indices:; psi4.print_out('%-3d ' % (k)); psi4.print_out('\n'); psi4.print_out('\n'). # Run the total molecule, if required; energies_full = {}; energies_mon = {}; N = molecule.nfragments(); Etotal = 0.0; if do_total or max_n_body == molecule.nfragments():; psi4.print_out(' => Total Cluster Energy <=\n'); # Full cluster always gets the external field; if (external):; psi4.set_global_option_python(""EXTERN"", external); Etotal = call_function_in_1st_argument(func, **kwargs); if (external):; psi4.set_global_option_python(""EXTERN"", None); energies_full[N] = []; energies_full[N].append(Etotal); energies_mon[N] = []; energies_mon[N].append(Etotal); psi4.set_global_option('DF_INTS_IO', 'LOAD'); psi4.clean(). max_effective = max_n_body; if (max_effective == N):; max_effective = N - 1. # Build the combos for indexing purposes; Ns = []; if (max_n_body == N or do_total):; Ns.append(N); for n in range(max_effective, 0, -1):; Ns.append(n). combos = {}; for n in Ns:. combos[n] = []. # Loop through combinations in lexical order #. # initialize the reals list; reals = []; #setup first combination [3,2,1] lexical ordering; #fragments indexing is 1's based, bloody hell; for index in range(n, 0, -1):; reals.append(index); #start loop through lexical promotion; counter = 0; while True:. counter = counter + 1. # Append ",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:9744,Energy Efficiency,Energy,Energy,9744,"as a promotion opportunity at; # index 1 to produce [4 3 1]; for k in range(n - 2, -1, -1):; if (reals[k] != reals[k + 1] + 1):; rank = k + 1; break. #do the promotion; reals[rank] = reals[rank] + 1. #demote the right portion of the register; val = 1; for k in range(n - 1, rank, -1):; reals[k] = val; val = val + 1. #boundary condition is promotion into; #[nfrag+1 nfrag-1 ...]; if (reals[0] > N):; break. # Hack for external; externNone = psi4.ExternalPotential(). # Run the clusters in the full basis; if bsse == 'on' or bsse == 'both':; for n in range(max_effective, 0, -1):; energies_full[n] = []; clusters = extract_clusters(molecule, True, n); for k in range(len(clusters)):; activate(clusters[k]); # Do the external field for this cluster or not?; if (external):; do_extern = False; for mon in combos[n][k]:; if (mon in external_indices):; do_extern = True; break; if do_extern:; psi4.set_global_option_python(""EXTERN"", external); psi4.print_out('\n => Cluster (N-Body %4d, Combination %4d) Energy (Full Basis) <=\n' % (n, k + 1)); energies_full[n].append(call_function_in_1st_argument(func, **kwargs)); # Turn the external field off; if (external):; psi4.set_global_option_python(""EXTERN"", externNone); psi4.set_global_option('DF_INTS_IO', 'LOAD'); psi4.clean(). # Run the clusters in the minimal cluster bases; psi4.set_global_option('DF_INTS_IO', 'NONE'); if bsse == 'off' or bsse == 'both':; for n in range(max_effective, 0, -1):; energies_mon[n] = []; clusters = extract_clusters(molecule, False, n); for k in range(len(clusters)):; activate(clusters[k]); # Do the external field for this cluster or not?; if (external):; do_extern = False; for mon in combos[n][k]:; if (mon in external_indices):; do_extern = True; break; if do_extern:; psi4.set_global_option_python(""EXTERN"", external); psi4.print_out('\n => Cluster (N-Body %4d, Combination %4d) Energy (Cluster Basis) <=\n' % (n, k + 1)); energies_mon[n].append(call_function_in_1st_argument(func, **kwargs)); # Turn the external fiel",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:10607,Energy Efficiency,Energy,Energy,10607,"; break; if do_extern:; psi4.set_global_option_python(""EXTERN"", external); psi4.print_out('\n => Cluster (N-Body %4d, Combination %4d) Energy (Full Basis) <=\n' % (n, k + 1)); energies_full[n].append(call_function_in_1st_argument(func, **kwargs)); # Turn the external field off; if (external):; psi4.set_global_option_python(""EXTERN"", externNone); psi4.set_global_option('DF_INTS_IO', 'LOAD'); psi4.clean(). # Run the clusters in the minimal cluster bases; psi4.set_global_option('DF_INTS_IO', 'NONE'); if bsse == 'off' or bsse == 'both':; for n in range(max_effective, 0, -1):; energies_mon[n] = []; clusters = extract_clusters(molecule, False, n); for k in range(len(clusters)):; activate(clusters[k]); # Do the external field for this cluster or not?; if (external):; do_extern = False; for mon in combos[n][k]:; if (mon in external_indices):; do_extern = True; break; if do_extern:; psi4.set_global_option_python(""EXTERN"", external); psi4.print_out('\n => Cluster (N-Body %4d, Combination %4d) Energy (Cluster Basis) <=\n' % (n, k + 1)); energies_mon[n].append(call_function_in_1st_argument(func, **kwargs)); # Turn the external field off; if (external):; psi4.set_global_option_python(""EXTERN"", externNone); psi4.clean(). # Report the energies; psi4.print_out('\n ==> N-Body Interaction Energy Analysis: Combination Definitions <==\n\n'). psi4.print_out(' %6s %6s | %-24s\n' % (""N-Body"", ""Combo"", ""Monomers"")); for n in Ns:; for k in range(len(combos[n])):; psi4.print_out(' %6d %6d | ' % (n, k + 1)); for l in combos[n][k]:; psi4.print_out('%-3d ' % (l)); psi4.print_out('\n'); psi4.print_out('\n'). psi4.print_out(' ==> N-Body Interaction Energy Analysis: Total Energies <==\n\n'). if bsse == 'on' or bsse == 'both':; psi4.print_out(' => Full Basis Set Results <=\n\n'); psi4.print_out(' %6s %6s %24s %24s\n' % (""N-Body"", ""Combo"", ""E [H]"", ""E [kcal mol^-1]"")); for n in Ns:; for k in range(len(energies_full[n])):; psi4.print_out(' %6d %6d %24.16E %24.16E\n' % (n, k + 1, energies_full[n][k],; ",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:10901,Energy Efficiency,Energy,Energy,10901,".set_global_option_python(""EXTERN"", externNone); psi4.set_global_option('DF_INTS_IO', 'LOAD'); psi4.clean(). # Run the clusters in the minimal cluster bases; psi4.set_global_option('DF_INTS_IO', 'NONE'); if bsse == 'off' or bsse == 'both':; for n in range(max_effective, 0, -1):; energies_mon[n] = []; clusters = extract_clusters(molecule, False, n); for k in range(len(clusters)):; activate(clusters[k]); # Do the external field for this cluster or not?; if (external):; do_extern = False; for mon in combos[n][k]:; if (mon in external_indices):; do_extern = True; break; if do_extern:; psi4.set_global_option_python(""EXTERN"", external); psi4.print_out('\n => Cluster (N-Body %4d, Combination %4d) Energy (Cluster Basis) <=\n' % (n, k + 1)); energies_mon[n].append(call_function_in_1st_argument(func, **kwargs)); # Turn the external field off; if (external):; psi4.set_global_option_python(""EXTERN"", externNone); psi4.clean(). # Report the energies; psi4.print_out('\n ==> N-Body Interaction Energy Analysis: Combination Definitions <==\n\n'). psi4.print_out(' %6s %6s | %-24s\n' % (""N-Body"", ""Combo"", ""Monomers"")); for n in Ns:; for k in range(len(combos[n])):; psi4.print_out(' %6d %6d | ' % (n, k + 1)); for l in combos[n][k]:; psi4.print_out('%-3d ' % (l)); psi4.print_out('\n'); psi4.print_out('\n'). psi4.print_out(' ==> N-Body Interaction Energy Analysis: Total Energies <==\n\n'). if bsse == 'on' or bsse == 'both':; psi4.print_out(' => Full Basis Set Results <=\n\n'); psi4.print_out(' %6s %6s %24s %24s\n' % (""N-Body"", ""Combo"", ""E [H]"", ""E [kcal mol^-1]"")); for n in Ns:; for k in range(len(energies_full[n])):; psi4.print_out(' %6d %6d %24.16E %24.16E\n' % (n, k + 1, energies_full[n][k],; p4const.psi_hartree2kcalmol * energies_full[n][k])); psi4.print_out('\n'). if bsse == 'off' or bsse == 'both':; psi4.print_out(' => Cluster Basis Set Results <=\n\n'); psi4.print_out(' %6s %6s %24s %24s\n' % (""N-Body"", ""Combo"", ""E [H]"", ""E [kcal mol^-1]"")); for n in Ns:; for k in range(len(energie",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:11255,Energy Efficiency,Energy,Energy,11255," for k in range(len(clusters)):; activate(clusters[k]); # Do the external field for this cluster or not?; if (external):; do_extern = False; for mon in combos[n][k]:; if (mon in external_indices):; do_extern = True; break; if do_extern:; psi4.set_global_option_python(""EXTERN"", external); psi4.print_out('\n => Cluster (N-Body %4d, Combination %4d) Energy (Cluster Basis) <=\n' % (n, k + 1)); energies_mon[n].append(call_function_in_1st_argument(func, **kwargs)); # Turn the external field off; if (external):; psi4.set_global_option_python(""EXTERN"", externNone); psi4.clean(). # Report the energies; psi4.print_out('\n ==> N-Body Interaction Energy Analysis: Combination Definitions <==\n\n'). psi4.print_out(' %6s %6s | %-24s\n' % (""N-Body"", ""Combo"", ""Monomers"")); for n in Ns:; for k in range(len(combos[n])):; psi4.print_out(' %6d %6d | ' % (n, k + 1)); for l in combos[n][k]:; psi4.print_out('%-3d ' % (l)); psi4.print_out('\n'); psi4.print_out('\n'). psi4.print_out(' ==> N-Body Interaction Energy Analysis: Total Energies <==\n\n'). if bsse == 'on' or bsse == 'both':; psi4.print_out(' => Full Basis Set Results <=\n\n'); psi4.print_out(' %6s %6s %24s %24s\n' % (""N-Body"", ""Combo"", ""E [H]"", ""E [kcal mol^-1]"")); for n in Ns:; for k in range(len(energies_full[n])):; psi4.print_out(' %6d %6d %24.16E %24.16E\n' % (n, k + 1, energies_full[n][k],; p4const.psi_hartree2kcalmol * energies_full[n][k])); psi4.print_out('\n'). if bsse == 'off' or bsse == 'both':; psi4.print_out(' => Cluster Basis Set Results <=\n\n'); psi4.print_out(' %6s %6s %24s %24s\n' % (""N-Body"", ""Combo"", ""E [H]"", ""E [kcal mol^-1]"")); for n in Ns:; for k in range(len(energies_mon[n])):; psi4.print_out(' %6d %6d %24.16E %24.16E\n' % (n, k + 1, energies_mon[n][k],; p4const.psi_hartree2kcalmol * energies_mon[n][k])); psi4.print_out('\n'). if bsse == 'both':; psi4.print_out(' => BSSE Results <=\n\n'); psi4.print_out(' %6s %6s %24s %24s\n' % (""N-Body"", ""Combo"", ""Delta E [H]"", ""Delta E [kcal mol^-1]"")); for n in Ns:; for k i",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:12529,Energy Efficiency,Energy,Energy,12529,"i4.print_out(' %6d %6d %24.16E %24.16E\n' % (n, k + 1, energies_full[n][k],; p4const.psi_hartree2kcalmol * energies_full[n][k])); psi4.print_out('\n'). if bsse == 'off' or bsse == 'both':; psi4.print_out(' => Cluster Basis Set Results <=\n\n'); psi4.print_out(' %6s %6s %24s %24s\n' % (""N-Body"", ""Combo"", ""E [H]"", ""E [kcal mol^-1]"")); for n in Ns:; for k in range(len(energies_mon[n])):; psi4.print_out(' %6d %6d %24.16E %24.16E\n' % (n, k + 1, energies_mon[n][k],; p4const.psi_hartree2kcalmol * energies_mon[n][k])); psi4.print_out('\n'). if bsse == 'both':; psi4.print_out(' => BSSE Results <=\n\n'); psi4.print_out(' %6s %6s %24s %24s\n' % (""N-Body"", ""Combo"", ""Delta E [H]"", ""Delta E [kcal mol^-1]"")); for n in Ns:; for k in range(len(energies_mon[n])):; psi4.print_out(' %6d %6d %24.16E %24.16E\n' % (n, k + 1, energies_full[n][k] - energies_mon[n][k],; p4const.psi_hartree2kcalmol * (energies_full[n][k] - energies_mon[n][k]))); psi4.print_out('\n'). psi4.print_out(' ==> N-Body Interaction Energy Analysis: N-Body Energies <==\n\n'). if bsse == 'on' or bsse == 'both':; psi4.print_out(' => Full Basis Set Results <=\n\n'); psi4.print_out(' %6s %6s %24s %24s\n' % (""N-Body"", ""Combo"", ""E [H]"", ""E [kcal mol^-1]"")); energies_n_full = {}; for n in Ns:; if n == 1:; continue; En = 0.0; for k in range(len(energies_full[n])):; E = energies_full[n][k]; for l in range(len(combos[n][k])):; E -= energies_full[1][combos[n][k][l] - 1]; psi4.print_out(' %6d %6d %24.16E %24.16E\n' % (n, k + 1, E, p4const.psi_hartree2kcalmol * E)); En += E; energies_n_full[n] = En; for n in Ns:; if n == 1:; continue; nn = molecule.nfragments() - 2; kk = n - 2; energies_n_full[n] /= (math.factorial(nn) / (math.factorial(kk) * math.factorial(nn - kk))); psi4.print_out(' %6d %6s %24.16E %24.16E\n' % (n, 'Total', energies_n_full[n],; p4const.psi_hartree2kcalmol * energies_n_full[n])); psi4.print_out('\n'). if bsse == 'off' or bsse == 'both':; psi4.print_out(' => Cluster Basis Set Results <=\n\n'); psi4.print_out(' %6",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:15202,Energy Efficiency,Energy,Energy,15202,"rtree2kcalmol * energies_n_mon[n])); psi4.print_out('\n'). if bsse == 'both':; psi4.print_out(' => BSSE Results <=\n\n'); psi4.print_out(' %6s %6s %24s %24s\n' % (""N-Body"", ""Combo"", ""Delta E [H]"", ""Delta E [kcal mol^-1]"")); energies_n_bsse = {}; for n in Ns:; if n == 1:; continue; En = 0.0; for k in range(len(energies_mon[n])):; E = energies_full[n][k] - energies_mon[n][k]; for l in range(len(combos[n][k])):; E -= energies_full[1][combos[n][k][l] - 1]; E += energies_mon[1][combos[n][k][l] - 1]; psi4.print_out(' %6d %6d %24.16E %24.16E\n' % (n, k + 1, E, p4const.psi_hartree2kcalmol * E)); En += E; energies_n_bsse[n] = En; for n in Ns:; if n == 1:; continue; nn = molecule.nfragments() - 2; kk = n - 2; energies_n_bsse[n] /= (math.factorial(nn) / (math.factorial(kk) * math.factorial(nn - kk))); psi4.print_out(' %6d %6s %24.16E %24.16E\n' % (n, 'Total', energies_n_bsse[n],; p4const.psi_hartree2kcalmol * energies_n_bsse[n])); psi4.print_out('\n'). psi4.print_out(' ==> N-Body Interaction Energy Analysis: Non-Additivities <==\n\n'). if bsse == 'on' or bsse == 'both':; energies_n_full[1] = 0.0; psi4.print_out(' => Full Basis Set Results <=\n\n'); psi4.print_out(' %6s %24s %24s\n' % (""N-Body"", ""E [H]"", ""E [kcal mol^-1]"")); for k in range(len(Ns)):; n = Ns[k]; if n == 1:; continue; E = energies_n_full[Ns[k]] - energies_n_full[Ns[k + 1]]; psi4.print_out(' %6s %24.16E %24.16E\n' % (n, E, p4const.psi_hartree2kcalmol * E)); psi4.print_out('\n'). if bsse == 'off' or bsse == 'both':; energies_n_mon[1] = 0.0; psi4.print_out(' => Cluster Basis Set Results <=\n\n'); psi4.print_out(' %6s %24s %24s\n' % (""N-Body"", ""E [H]"", ""E [kcal mol^-1]"")); for k in range(len(Ns)):; n = Ns[k]; if n == 1:; continue; E = energies_n_mon[Ns[k]] - energies_n_mon[Ns[k + 1]]; psi4.print_out(' %6s %24.16E %24.16E\n' % (n, E, p4const.psi_hartree2kcalmol * E)); psi4.print_out('\n'). if bsse == 'both':; energies_n_bsse[1] = 0.0; psi4.print_out(' => BSSE Results <=\n\n'); psi4.print_out(' %6s %24s %24s\n' % (""N-Bo",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:17189,Energy Efficiency,energy,energy,17189,"print_out(' %6s %24s %24s\n' % (""N-Body"", ""Delta E [H]"", ""Delta E [kcal mol^-1]"")); for k in range(len(Ns)):; n = Ns[k]; if n == 1:; continue; E = energies_n_bsse[Ns[k]] - energies_n_bsse[Ns[k + 1]]; psi4.print_out(' %6s %24.16E %24.16E\n' % (n, E, p4const.psi_hartree2kcalmol * E)); psi4.print_out('\n'). # Put everything back the way it was; psi4.set_global_option('DF_INTS_IO', ri_ints_io); psioh.set_specific_retention(97, False); psi4.clean(); activate(molecule). if bsse == 'on' or bsse == 'both':; return energies_n_full[Ns[0]]; else:; return energies_n_mon[Ns[0]]. ## Aliases ##; nbody = n_body. #####################; ## End of n_body ##; #####################. ###################; ## Start of cp ##; ###################. [docs]def cp(name, **kwargs):; r""""""The cp function computes counterpoise-corrected two-body interaction energies; for complexes composed of arbitrary numbers of monomers. :aliases: counterpoise_correct(), counterpoise_correction(). :returns: (*float*) Counterpoise-corrected interaction energy in Hartrees. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CP-CORRECTED 2-BODY INTERACTION ENERGY <CP-CORRECTED2-BODYINTERACTIONENERGY>`; * :psivar:`UNCP-CORRECTED 2-BODY INTERACTION ENERGY <UNCP-CORRECTED2-BODYINTERACTIONENERGY>`. .. caution:: Some features are not yet implemented. Buy a developer a coffee. - No values of func besides energy have been tested. - Table print-out needs improving. Add some PSI variables. :type name: string; :param name: ``'scf'`` || ``'ccsd(t)'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the molecule. May be any valid argument to; :py:func:`~driver.energy`; however, SAPT is not appropriate. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``energy`` |dr| || ``optimize`` || ``cbs``. Indicates the type of calculation to be performed on the molecule; and each of its monomers. The default performs a single-point; ``energy('name')``, while ``optimize`` perfoms ",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:17294,Energy Efficiency,ENERGY,ENERGY,17294,"energies_n_bsse[Ns[k + 1]]; psi4.print_out(' %6s %24.16E %24.16E\n' % (n, E, p4const.psi_hartree2kcalmol * E)); psi4.print_out('\n'). # Put everything back the way it was; psi4.set_global_option('DF_INTS_IO', ri_ints_io); psioh.set_specific_retention(97, False); psi4.clean(); activate(molecule). if bsse == 'on' or bsse == 'both':; return energies_n_full[Ns[0]]; else:; return energies_n_mon[Ns[0]]. ## Aliases ##; nbody = n_body. #####################; ## End of n_body ##; #####################. ###################; ## Start of cp ##; ###################. [docs]def cp(name, **kwargs):; r""""""The cp function computes counterpoise-corrected two-body interaction energies; for complexes composed of arbitrary numbers of monomers. :aliases: counterpoise_correct(), counterpoise_correction(). :returns: (*float*) Counterpoise-corrected interaction energy in Hartrees. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CP-CORRECTED 2-BODY INTERACTION ENERGY <CP-CORRECTED2-BODYINTERACTIONENERGY>`; * :psivar:`UNCP-CORRECTED 2-BODY INTERACTION ENERGY <UNCP-CORRECTED2-BODYINTERACTIONENERGY>`. .. caution:: Some features are not yet implemented. Buy a developer a coffee. - No values of func besides energy have been tested. - Table print-out needs improving. Add some PSI variables. :type name: string; :param name: ``'scf'`` || ``'ccsd(t)'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the molecule. May be any valid argument to; :py:func:`~driver.energy`; however, SAPT is not appropriate. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``energy`` |dr| || ``optimize`` || ``cbs``. Indicates the type of calculation to be performed on the molecule; and each of its monomers. The default performs a single-point; ``energy('name')``, while ``optimize`` perfoms a geometry optimization; on each system, and ``cbs`` performs a compound single-point energy.; If a nested series of python functions is intended; (see :ref:`sec:intercall",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:17386,Energy Efficiency,ENERGY,ENERGY,17386,"energies_n_bsse[Ns[k + 1]]; psi4.print_out(' %6s %24.16E %24.16E\n' % (n, E, p4const.psi_hartree2kcalmol * E)); psi4.print_out('\n'). # Put everything back the way it was; psi4.set_global_option('DF_INTS_IO', ri_ints_io); psioh.set_specific_retention(97, False); psi4.clean(); activate(molecule). if bsse == 'on' or bsse == 'both':; return energies_n_full[Ns[0]]; else:; return energies_n_mon[Ns[0]]. ## Aliases ##; nbody = n_body. #####################; ## End of n_body ##; #####################. ###################; ## Start of cp ##; ###################. [docs]def cp(name, **kwargs):; r""""""The cp function computes counterpoise-corrected two-body interaction energies; for complexes composed of arbitrary numbers of monomers. :aliases: counterpoise_correct(), counterpoise_correction(). :returns: (*float*) Counterpoise-corrected interaction energy in Hartrees. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CP-CORRECTED 2-BODY INTERACTION ENERGY <CP-CORRECTED2-BODYINTERACTIONENERGY>`; * :psivar:`UNCP-CORRECTED 2-BODY INTERACTION ENERGY <UNCP-CORRECTED2-BODYINTERACTIONENERGY>`. .. caution:: Some features are not yet implemented. Buy a developer a coffee. - No values of func besides energy have been tested. - Table print-out needs improving. Add some PSI variables. :type name: string; :param name: ``'scf'`` || ``'ccsd(t)'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the molecule. May be any valid argument to; :py:func:`~driver.energy`; however, SAPT is not appropriate. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``energy`` |dr| || ``optimize`` || ``cbs``. Indicates the type of calculation to be performed on the molecule; and each of its monomers. The default performs a single-point; ``energy('name')``, while ``optimize`` perfoms a geometry optimization; on each system, and ``cbs`` performs a compound single-point energy.; If a nested series of python functions is intended; (see :ref:`sec:intercall",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:17541,Energy Efficiency,energy,energy,17541,"DF_INTS_IO', ri_ints_io); psioh.set_specific_retention(97, False); psi4.clean(); activate(molecule). if bsse == 'on' or bsse == 'both':; return energies_n_full[Ns[0]]; else:; return energies_n_mon[Ns[0]]. ## Aliases ##; nbody = n_body. #####################; ## End of n_body ##; #####################. ###################; ## Start of cp ##; ###################. [docs]def cp(name, **kwargs):; r""""""The cp function computes counterpoise-corrected two-body interaction energies; for complexes composed of arbitrary numbers of monomers. :aliases: counterpoise_correct(), counterpoise_correction(). :returns: (*float*) Counterpoise-corrected interaction energy in Hartrees. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CP-CORRECTED 2-BODY INTERACTION ENERGY <CP-CORRECTED2-BODYINTERACTIONENERGY>`; * :psivar:`UNCP-CORRECTED 2-BODY INTERACTION ENERGY <UNCP-CORRECTED2-BODYINTERACTIONENERGY>`. .. caution:: Some features are not yet implemented. Buy a developer a coffee. - No values of func besides energy have been tested. - Table print-out needs improving. Add some PSI variables. :type name: string; :param name: ``'scf'`` || ``'ccsd(t)'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the molecule. May be any valid argument to; :py:func:`~driver.energy`; however, SAPT is not appropriate. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``energy`` |dr| || ``optimize`` || ``cbs``. Indicates the type of calculation to be performed on the molecule; and each of its monomers. The default performs a single-point; ``energy('name')``, while ``optimize`` perfoms a geometry optimization; on each system, and ``cbs`` performs a compound single-point energy.; If a nested series of python functions is intended; (see :ref:`sec:intercalls`), use keyword ``cp_func`` instead of ``func``. :type check_bsse: :ref:`boolean <op_py_boolean>`; :param check_bsse: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether to additionally compute un-",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:17843,Energy Efficiency,energy,energy,17843," Start of cp ##; ###################. [docs]def cp(name, **kwargs):; r""""""The cp function computes counterpoise-corrected two-body interaction energies; for complexes composed of arbitrary numbers of monomers. :aliases: counterpoise_correct(), counterpoise_correction(). :returns: (*float*) Counterpoise-corrected interaction energy in Hartrees. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CP-CORRECTED 2-BODY INTERACTION ENERGY <CP-CORRECTED2-BODYINTERACTIONENERGY>`; * :psivar:`UNCP-CORRECTED 2-BODY INTERACTION ENERGY <UNCP-CORRECTED2-BODYINTERACTIONENERGY>`. .. caution:: Some features are not yet implemented. Buy a developer a coffee. - No values of func besides energy have been tested. - Table print-out needs improving. Add some PSI variables. :type name: string; :param name: ``'scf'`` || ``'ccsd(t)'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the molecule. May be any valid argument to; :py:func:`~driver.energy`; however, SAPT is not appropriate. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``energy`` |dr| || ``optimize`` || ``cbs``. Indicates the type of calculation to be performed on the molecule; and each of its monomers. The default performs a single-point; ``energy('name')``, while ``optimize`` perfoms a geometry optimization; on each system, and ``cbs`` performs a compound single-point energy.; If a nested series of python functions is intended; (see :ref:`sec:intercalls`), use keyword ``cp_func`` instead of ``func``. :type check_bsse: :ref:`boolean <op_py_boolean>`; :param check_bsse: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether to additionally compute un-counterpoise corrected; monomers and thus obtain an estimate for the basis set superposition error. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :examples:. >>> # [1] counterpoise-corrected mp2 interaction energy; >>> cp('df-mp2'). ",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:17952,Energy Efficiency,energy,energy,17952,"e cp function computes counterpoise-corrected two-body interaction energies; for complexes composed of arbitrary numbers of monomers. :aliases: counterpoise_correct(), counterpoise_correction(). :returns: (*float*) Counterpoise-corrected interaction energy in Hartrees. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CP-CORRECTED 2-BODY INTERACTION ENERGY <CP-CORRECTED2-BODYINTERACTIONENERGY>`; * :psivar:`UNCP-CORRECTED 2-BODY INTERACTION ENERGY <UNCP-CORRECTED2-BODYINTERACTIONENERGY>`. .. caution:: Some features are not yet implemented. Buy a developer a coffee. - No values of func besides energy have been tested. - Table print-out needs improving. Add some PSI variables. :type name: string; :param name: ``'scf'`` || ``'ccsd(t)'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the molecule. May be any valid argument to; :py:func:`~driver.energy`; however, SAPT is not appropriate. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``energy`` |dr| || ``optimize`` || ``cbs``. Indicates the type of calculation to be performed on the molecule; and each of its monomers. The default performs a single-point; ``energy('name')``, while ``optimize`` perfoms a geometry optimization; on each system, and ``cbs`` performs a compound single-point energy.; If a nested series of python functions is intended; (see :ref:`sec:intercalls`), use keyword ``cp_func`` instead of ``func``. :type check_bsse: :ref:`boolean <op_py_boolean>`; :param check_bsse: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether to additionally compute un-counterpoise corrected; monomers and thus obtain an estimate for the basis set superposition error. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :examples:. >>> # [1] counterpoise-corrected mp2 interaction energy; >>> cp('df-mp2'). """"""; lowername = name.lower(); kwargs = p4util.kwargs_lower(kwargs). # Wrap",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:18126,Energy Efficiency,energy,energy,18126,"d interaction energy in Hartrees. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CP-CORRECTED 2-BODY INTERACTION ENERGY <CP-CORRECTED2-BODYINTERACTIONENERGY>`; * :psivar:`UNCP-CORRECTED 2-BODY INTERACTION ENERGY <UNCP-CORRECTED2-BODYINTERACTIONENERGY>`. .. caution:: Some features are not yet implemented. Buy a developer a coffee. - No values of func besides energy have been tested. - Table print-out needs improving. Add some PSI variables. :type name: string; :param name: ``'scf'`` || ``'ccsd(t)'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the molecule. May be any valid argument to; :py:func:`~driver.energy`; however, SAPT is not appropriate. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``energy`` |dr| || ``optimize`` || ``cbs``. Indicates the type of calculation to be performed on the molecule; and each of its monomers. The default performs a single-point; ``energy('name')``, while ``optimize`` perfoms a geometry optimization; on each system, and ``cbs`` performs a compound single-point energy.; If a nested series of python functions is intended; (see :ref:`sec:intercalls`), use keyword ``cp_func`` instead of ``func``. :type check_bsse: :ref:`boolean <op_py_boolean>`; :param check_bsse: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether to additionally compute un-counterpoise corrected; monomers and thus obtain an estimate for the basis set superposition error. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :examples:. >>> # [1] counterpoise-corrected mp2 interaction energy; >>> cp('df-mp2'). """"""; lowername = name.lower(); kwargs = p4util.kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name.lower(). # Establish function to call; if not('cp_func' in kwargs):; if ('func' in kwargs):; kwargs['cp_fun",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:18257,Energy Efficiency,energy,energy,18257,"d interaction energy in Hartrees. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CP-CORRECTED 2-BODY INTERACTION ENERGY <CP-CORRECTED2-BODYINTERACTIONENERGY>`; * :psivar:`UNCP-CORRECTED 2-BODY INTERACTION ENERGY <UNCP-CORRECTED2-BODYINTERACTIONENERGY>`. .. caution:: Some features are not yet implemented. Buy a developer a coffee. - No values of func besides energy have been tested. - Table print-out needs improving. Add some PSI variables. :type name: string; :param name: ``'scf'`` || ``'ccsd(t)'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the molecule. May be any valid argument to; :py:func:`~driver.energy`; however, SAPT is not appropriate. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``energy`` |dr| || ``optimize`` || ``cbs``. Indicates the type of calculation to be performed on the molecule; and each of its monomers. The default performs a single-point; ``energy('name')``, while ``optimize`` perfoms a geometry optimization; on each system, and ``cbs`` performs a compound single-point energy.; If a nested series of python functions is intended; (see :ref:`sec:intercalls`), use keyword ``cp_func`` instead of ``func``. :type check_bsse: :ref:`boolean <op_py_boolean>`; :param check_bsse: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether to additionally compute un-counterpoise corrected; monomers and thus obtain an estimate for the basis set superposition error. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :examples:. >>> # [1] counterpoise-corrected mp2 interaction energy; >>> cp('df-mp2'). """"""; lowername = name.lower(); kwargs = p4util.kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name.lower(). # Establish function to call; if not('cp_func' in kwargs):; if ('func' in kwargs):; kwargs['cp_fun",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:18838,Energy Efficiency,energy,energy,18838,":py:func:`~driver.energy`; however, SAPT is not appropriate. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``energy`` |dr| || ``optimize`` || ``cbs``. Indicates the type of calculation to be performed on the molecule; and each of its monomers. The default performs a single-point; ``energy('name')``, while ``optimize`` perfoms a geometry optimization; on each system, and ``cbs`` performs a compound single-point energy.; If a nested series of python functions is intended; (see :ref:`sec:intercalls`), use keyword ``cp_func`` instead of ``func``. :type check_bsse: :ref:`boolean <op_py_boolean>`; :param check_bsse: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether to additionally compute un-counterpoise corrected; monomers and thus obtain an estimate for the basis set superposition error. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :examples:. >>> # [1] counterpoise-corrected mp2 interaction energy; >>> cp('df-mp2'). """"""; lowername = name.lower(); kwargs = p4util.kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name.lower(). # Establish function to call; if not('cp_func' in kwargs):; if ('func' in kwargs):; kwargs['cp_func'] = kwargs['func']; del kwargs['func']; else:; kwargs['cp_func'] = energy; func = kwargs['cp_func']; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper counterpoise_correct.' % (func.__name__)); if (func is db):; raise ValidationError('Wrapper counterpoise_correct is unhappy to be calling function \'%s\'.' % (func.__name__)). if 'check_bsse' in kwargs and yes.match(str(kwargs['check_bsse'])):; check_bsse = True; else:; check_bsse = False. # Make sure the molecule the user provided is the active one; if 'molecule' in kwargs:; activate(kwargs['molecule']); del kwargs['molecule']; molecule = psi4.get_act",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:19244,Energy Efficiency,energy,energy,19244,"a compound single-point energy.; If a nested series of python functions is intended; (see :ref:`sec:intercalls`), use keyword ``cp_func`` instead of ``func``. :type check_bsse: :ref:`boolean <op_py_boolean>`; :param check_bsse: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether to additionally compute un-counterpoise corrected; monomers and thus obtain an estimate for the basis set superposition error. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :examples:. >>> # [1] counterpoise-corrected mp2 interaction energy; >>> cp('df-mp2'). """"""; lowername = name.lower(); kwargs = p4util.kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name.lower(). # Establish function to call; if not('cp_func' in kwargs):; if ('func' in kwargs):; kwargs['cp_func'] = kwargs['func']; del kwargs['func']; else:; kwargs['cp_func'] = energy; func = kwargs['cp_func']; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper counterpoise_correct.' % (func.__name__)); if (func is db):; raise ValidationError('Wrapper counterpoise_correct is unhappy to be calling function \'%s\'.' % (func.__name__)). if 'check_bsse' in kwargs and yes.match(str(kwargs['check_bsse'])):; check_bsse = True; else:; check_bsse = False. # Make sure the molecule the user provided is the active one; if 'molecule' in kwargs:; activate(kwargs['molecule']); del kwargs['molecule']; molecule = psi4.get_active_molecule(); molecule.update_geometry(); psi4.set_global_option(""BASIS"", psi4.get_global_option(""BASIS"")). df_ints_io = psi4.get_global_option('DF_INTS_IO'); # inquire if above at all applies to dfmp2 or just scf; psi4.set_global_option('DF_INTS_IO', 'SAVE'); psioh = psi4.IOManager.shared_object(); psioh.set_specific_retention(97, True). activate(molecule); molecule.update_geometry(). psi4.print_out(""\",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:20389,Energy Efficiency,energy,energy,20389," by wrapper counterpoise_correct.' % (func.__name__)); if (func is db):; raise ValidationError('Wrapper counterpoise_correct is unhappy to be calling function \'%s\'.' % (func.__name__)). if 'check_bsse' in kwargs and yes.match(str(kwargs['check_bsse'])):; check_bsse = True; else:; check_bsse = False. # Make sure the molecule the user provided is the active one; if 'molecule' in kwargs:; activate(kwargs['molecule']); del kwargs['molecule']; molecule = psi4.get_active_molecule(); molecule.update_geometry(); psi4.set_global_option(""BASIS"", psi4.get_global_option(""BASIS"")). df_ints_io = psi4.get_global_option('DF_INTS_IO'); # inquire if above at all applies to dfmp2 or just scf; psi4.set_global_option('DF_INTS_IO', 'SAVE'); psioh = psi4.IOManager.shared_object(); psioh.set_specific_retention(97, True). activate(molecule); molecule.update_geometry(). psi4.print_out(""\n""); p4util.banner(""CP Computation: Complex.\nFull Basis Set.""); psi4.print_out(""\n""); e_dimer = call_function_in_1st_argument(func, **kwargs); #e_dimer = energy(name, **kwargs). psi4.clean(); psi4.set_global_option('DF_INTS_IO', 'LOAD'). # All monomers with ghosts; monomers = extract_clusters(molecule, True, 1); e_monomer_full = []. cluster_n = 0; for cluster in monomers:; activate(cluster); psi4.print_out(""\n""); p4util.banner((""CP Computation: Monomer %d.\n Full Basis Set."" % (cluster_n + 1))); psi4.print_out(""\n""); e_monomer_full.append(call_function_in_1st_argument(func, **kwargs)); #e_monomer_full.append(energy(name,**kwargs)); cluster_n = cluster_n + 1; psi4.clean(). psi4.set_global_option('DF_INTS_IO', 'NONE'); if (check_bsse):; # All monomers without ghosts; monomers = extract_clusters(molecule, False, 1); e_monomer_bsse = []. cluster_n = 0; for cluster in monomers:; activate(cluster); psi4.print_out(""\n""); #cluster.print_to_output(); p4util.banner((""CP Computation: Monomer %d.\n Monomer Set."" % (cluster_n + 1))); psi4.print_out(""\n""); e_monomer_bsse.append(call_function_in_1st_argument(func, **kwar",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:20851,Energy Efficiency,energy,energy,20851,"set_global_option(""BASIS"", psi4.get_global_option(""BASIS"")). df_ints_io = psi4.get_global_option('DF_INTS_IO'); # inquire if above at all applies to dfmp2 or just scf; psi4.set_global_option('DF_INTS_IO', 'SAVE'); psioh = psi4.IOManager.shared_object(); psioh.set_specific_retention(97, True). activate(molecule); molecule.update_geometry(). psi4.print_out(""\n""); p4util.banner(""CP Computation: Complex.\nFull Basis Set.""); psi4.print_out(""\n""); e_dimer = call_function_in_1st_argument(func, **kwargs); #e_dimer = energy(name, **kwargs). psi4.clean(); psi4.set_global_option('DF_INTS_IO', 'LOAD'). # All monomers with ghosts; monomers = extract_clusters(molecule, True, 1); e_monomer_full = []. cluster_n = 0; for cluster in monomers:; activate(cluster); psi4.print_out(""\n""); p4util.banner((""CP Computation: Monomer %d.\n Full Basis Set."" % (cluster_n + 1))); psi4.print_out(""\n""); e_monomer_full.append(call_function_in_1st_argument(func, **kwargs)); #e_monomer_full.append(energy(name,**kwargs)); cluster_n = cluster_n + 1; psi4.clean(). psi4.set_global_option('DF_INTS_IO', 'NONE'); if (check_bsse):; # All monomers without ghosts; monomers = extract_clusters(molecule, False, 1); e_monomer_bsse = []. cluster_n = 0; for cluster in monomers:; activate(cluster); psi4.print_out(""\n""); #cluster.print_to_output(); p4util.banner((""CP Computation: Monomer %d.\n Monomer Set."" % (cluster_n + 1))); psi4.print_out(""\n""); e_monomer_bsse.append(call_function_in_1st_argument(func, **kwargs)); #e_monomer_bsse.append(energy(name,**kwargs)); cluster_n = cluster_n + 1. psi4.set_global_option('DF_INTS_IO', df_ints_io); psioh.set_specific_retention(97, False). activate(molecule). if (check_bsse == False):; cp_table = p4util.Table(rows=[""System:""], cols=[""Energy (full):""]); cp_table[""Complex""] = [e_dimer]; for cluster_n in range(0, len(monomers)):; key = ""Monomer %d"" % (cluster_n + 1); cp_table[key] = [e_monomer_full[cluster_n]]. e_full = e_dimer; for cluster_n in range(0, len(monomers)):; e_full = e_f",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:21387,Energy Efficiency,energy,energy,21387,"gs). psi4.clean(); psi4.set_global_option('DF_INTS_IO', 'LOAD'). # All monomers with ghosts; monomers = extract_clusters(molecule, True, 1); e_monomer_full = []. cluster_n = 0; for cluster in monomers:; activate(cluster); psi4.print_out(""\n""); p4util.banner((""CP Computation: Monomer %d.\n Full Basis Set."" % (cluster_n + 1))); psi4.print_out(""\n""); e_monomer_full.append(call_function_in_1st_argument(func, **kwargs)); #e_monomer_full.append(energy(name,**kwargs)); cluster_n = cluster_n + 1; psi4.clean(). psi4.set_global_option('DF_INTS_IO', 'NONE'); if (check_bsse):; # All monomers without ghosts; monomers = extract_clusters(molecule, False, 1); e_monomer_bsse = []. cluster_n = 0; for cluster in monomers:; activate(cluster); psi4.print_out(""\n""); #cluster.print_to_output(); p4util.banner((""CP Computation: Monomer %d.\n Monomer Set."" % (cluster_n + 1))); psi4.print_out(""\n""); e_monomer_bsse.append(call_function_in_1st_argument(func, **kwargs)); #e_monomer_bsse.append(energy(name,**kwargs)); cluster_n = cluster_n + 1. psi4.set_global_option('DF_INTS_IO', df_ints_io); psioh.set_specific_retention(97, False). activate(molecule). if (check_bsse == False):; cp_table = p4util.Table(rows=[""System:""], cols=[""Energy (full):""]); cp_table[""Complex""] = [e_dimer]; for cluster_n in range(0, len(monomers)):; key = ""Monomer %d"" % (cluster_n + 1); cp_table[key] = [e_monomer_full[cluster_n]]. e_full = e_dimer; for cluster_n in range(0, len(monomers)):; e_full = e_full - e_monomer_full[cluster_n]; cp_table[""Interaction""] = [e_full]. psi4.set_variable('CP-CORRECTED 2-BODY INTERACTION ENERGY', e_full). else:; cp_table = Table(rows=[""System:""], cols=[""Energy (full):"", ""Energy (monomer):"", ""BSSE:""]); cp_table[""Complex""] = [e_dimer, 0.0, 0.0]; for cluster_n in range(0, len(monomers)):; key = ""Monomer %d"" % (cluster_n + 1); cp_table[key] = [e_monomer_full[cluster_n], e_monomer_bsse[cluster_n], \; e_monomer_full[cluster_n] - e_monomer_bsse[cluster_n]]. e_full = e_dimer; e_bsse = e_dimer; for clu",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:21625,Energy Efficiency,Energy,Energy,21625,"Full Basis Set."" % (cluster_n + 1))); psi4.print_out(""\n""); e_monomer_full.append(call_function_in_1st_argument(func, **kwargs)); #e_monomer_full.append(energy(name,**kwargs)); cluster_n = cluster_n + 1; psi4.clean(). psi4.set_global_option('DF_INTS_IO', 'NONE'); if (check_bsse):; # All monomers without ghosts; monomers = extract_clusters(molecule, False, 1); e_monomer_bsse = []. cluster_n = 0; for cluster in monomers:; activate(cluster); psi4.print_out(""\n""); #cluster.print_to_output(); p4util.banner((""CP Computation: Monomer %d.\n Monomer Set."" % (cluster_n + 1))); psi4.print_out(""\n""); e_monomer_bsse.append(call_function_in_1st_argument(func, **kwargs)); #e_monomer_bsse.append(energy(name,**kwargs)); cluster_n = cluster_n + 1. psi4.set_global_option('DF_INTS_IO', df_ints_io); psioh.set_specific_retention(97, False). activate(molecule). if (check_bsse == False):; cp_table = p4util.Table(rows=[""System:""], cols=[""Energy (full):""]); cp_table[""Complex""] = [e_dimer]; for cluster_n in range(0, len(monomers)):; key = ""Monomer %d"" % (cluster_n + 1); cp_table[key] = [e_monomer_full[cluster_n]]. e_full = e_dimer; for cluster_n in range(0, len(monomers)):; e_full = e_full - e_monomer_full[cluster_n]; cp_table[""Interaction""] = [e_full]. psi4.set_variable('CP-CORRECTED 2-BODY INTERACTION ENERGY', e_full). else:; cp_table = Table(rows=[""System:""], cols=[""Energy (full):"", ""Energy (monomer):"", ""BSSE:""]); cp_table[""Complex""] = [e_dimer, 0.0, 0.0]; for cluster_n in range(0, len(monomers)):; key = ""Monomer %d"" % (cluster_n + 1); cp_table[key] = [e_monomer_full[cluster_n], e_monomer_bsse[cluster_n], \; e_monomer_full[cluster_n] - e_monomer_bsse[cluster_n]]. e_full = e_dimer; e_bsse = e_dimer; for cluster_n in range(0, len(monomers)):; e_full = e_full - e_monomer_full[cluster_n]; e_bsse = e_bsse - e_monomer_bsse[cluster_n]; cp_table[""Totals:""] = [e_full, e_bsse, e_full - e_bsse]. psi4.set_variable('UNCP-CORRECTED 2-BODY INTERACTION ENERGY', e_full). psi4.print_out(""\n""); p4util.banner",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:21996,Energy Efficiency,ENERGY,ENERGY,21996," All monomers without ghosts; monomers = extract_clusters(molecule, False, 1); e_monomer_bsse = []. cluster_n = 0; for cluster in monomers:; activate(cluster); psi4.print_out(""\n""); #cluster.print_to_output(); p4util.banner((""CP Computation: Monomer %d.\n Monomer Set."" % (cluster_n + 1))); psi4.print_out(""\n""); e_monomer_bsse.append(call_function_in_1st_argument(func, **kwargs)); #e_monomer_bsse.append(energy(name,**kwargs)); cluster_n = cluster_n + 1. psi4.set_global_option('DF_INTS_IO', df_ints_io); psioh.set_specific_retention(97, False). activate(molecule). if (check_bsse == False):; cp_table = p4util.Table(rows=[""System:""], cols=[""Energy (full):""]); cp_table[""Complex""] = [e_dimer]; for cluster_n in range(0, len(monomers)):; key = ""Monomer %d"" % (cluster_n + 1); cp_table[key] = [e_monomer_full[cluster_n]]. e_full = e_dimer; for cluster_n in range(0, len(monomers)):; e_full = e_full - e_monomer_full[cluster_n]; cp_table[""Interaction""] = [e_full]. psi4.set_variable('CP-CORRECTED 2-BODY INTERACTION ENERGY', e_full). else:; cp_table = Table(rows=[""System:""], cols=[""Energy (full):"", ""Energy (monomer):"", ""BSSE:""]); cp_table[""Complex""] = [e_dimer, 0.0, 0.0]; for cluster_n in range(0, len(monomers)):; key = ""Monomer %d"" % (cluster_n + 1); cp_table[key] = [e_monomer_full[cluster_n], e_monomer_bsse[cluster_n], \; e_monomer_full[cluster_n] - e_monomer_bsse[cluster_n]]. e_full = e_dimer; e_bsse = e_dimer; for cluster_n in range(0, len(monomers)):; e_full = e_full - e_monomer_full[cluster_n]; e_bsse = e_bsse - e_monomer_bsse[cluster_n]; cp_table[""Totals:""] = [e_full, e_bsse, e_full - e_bsse]. psi4.set_variable('UNCP-CORRECTED 2-BODY INTERACTION ENERGY', e_full). psi4.print_out(""\n""); p4util.banner(""CP Computation: Results.""); psi4.print_out(""\n""). p4util.banner(""Hartree"", 2); psi4.print_out(""\n""). psi4.print_out(str(cp_table)). psi4.print_out(""\n""); p4util.banner(""kcal*mol^-1"", 2); psi4.print_out(""\n""). cp_table.scale(). psi4.print_out(str(cp_table)); return e_full. ## Aliase",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:22063,Energy Efficiency,Energy,Energy,22063,". cluster_n = 0; for cluster in monomers:; activate(cluster); psi4.print_out(""\n""); #cluster.print_to_output(); p4util.banner((""CP Computation: Monomer %d.\n Monomer Set."" % (cluster_n + 1))); psi4.print_out(""\n""); e_monomer_bsse.append(call_function_in_1st_argument(func, **kwargs)); #e_monomer_bsse.append(energy(name,**kwargs)); cluster_n = cluster_n + 1. psi4.set_global_option('DF_INTS_IO', df_ints_io); psioh.set_specific_retention(97, False). activate(molecule). if (check_bsse == False):; cp_table = p4util.Table(rows=[""System:""], cols=[""Energy (full):""]); cp_table[""Complex""] = [e_dimer]; for cluster_n in range(0, len(monomers)):; key = ""Monomer %d"" % (cluster_n + 1); cp_table[key] = [e_monomer_full[cluster_n]]. e_full = e_dimer; for cluster_n in range(0, len(monomers)):; e_full = e_full - e_monomer_full[cluster_n]; cp_table[""Interaction""] = [e_full]. psi4.set_variable('CP-CORRECTED 2-BODY INTERACTION ENERGY', e_full). else:; cp_table = Table(rows=[""System:""], cols=[""Energy (full):"", ""Energy (monomer):"", ""BSSE:""]); cp_table[""Complex""] = [e_dimer, 0.0, 0.0]; for cluster_n in range(0, len(monomers)):; key = ""Monomer %d"" % (cluster_n + 1); cp_table[key] = [e_monomer_full[cluster_n], e_monomer_bsse[cluster_n], \; e_monomer_full[cluster_n] - e_monomer_bsse[cluster_n]]. e_full = e_dimer; e_bsse = e_dimer; for cluster_n in range(0, len(monomers)):; e_full = e_full - e_monomer_full[cluster_n]; e_bsse = e_bsse - e_monomer_bsse[cluster_n]; cp_table[""Totals:""] = [e_full, e_bsse, e_full - e_bsse]. psi4.set_variable('UNCP-CORRECTED 2-BODY INTERACTION ENERGY', e_full). psi4.print_out(""\n""); p4util.banner(""CP Computation: Results.""); psi4.print_out(""\n""). p4util.banner(""Hartree"", 2); psi4.print_out(""\n""). psi4.print_out(str(cp_table)). psi4.print_out(""\n""); p4util.banner(""kcal*mol^-1"", 2); psi4.print_out(""\n""). cp_table.scale(). psi4.print_out(str(cp_table)); return e_full. ## Aliases ##; counterpoise_correct = cp; counterpoise_correction = cp. #################; ## End of cp ##;",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:22081,Energy Efficiency,Energy,Energy,22081,". cluster_n = 0; for cluster in monomers:; activate(cluster); psi4.print_out(""\n""); #cluster.print_to_output(); p4util.banner((""CP Computation: Monomer %d.\n Monomer Set."" % (cluster_n + 1))); psi4.print_out(""\n""); e_monomer_bsse.append(call_function_in_1st_argument(func, **kwargs)); #e_monomer_bsse.append(energy(name,**kwargs)); cluster_n = cluster_n + 1. psi4.set_global_option('DF_INTS_IO', df_ints_io); psioh.set_specific_retention(97, False). activate(molecule). if (check_bsse == False):; cp_table = p4util.Table(rows=[""System:""], cols=[""Energy (full):""]); cp_table[""Complex""] = [e_dimer]; for cluster_n in range(0, len(monomers)):; key = ""Monomer %d"" % (cluster_n + 1); cp_table[key] = [e_monomer_full[cluster_n]]. e_full = e_dimer; for cluster_n in range(0, len(monomers)):; e_full = e_full - e_monomer_full[cluster_n]; cp_table[""Interaction""] = [e_full]. psi4.set_variable('CP-CORRECTED 2-BODY INTERACTION ENERGY', e_full). else:; cp_table = Table(rows=[""System:""], cols=[""Energy (full):"", ""Energy (monomer):"", ""BSSE:""]); cp_table[""Complex""] = [e_dimer, 0.0, 0.0]; for cluster_n in range(0, len(monomers)):; key = ""Monomer %d"" % (cluster_n + 1); cp_table[key] = [e_monomer_full[cluster_n], e_monomer_bsse[cluster_n], \; e_monomer_full[cluster_n] - e_monomer_bsse[cluster_n]]. e_full = e_dimer; e_bsse = e_dimer; for cluster_n in range(0, len(monomers)):; e_full = e_full - e_monomer_full[cluster_n]; e_bsse = e_bsse - e_monomer_bsse[cluster_n]; cp_table[""Totals:""] = [e_full, e_bsse, e_full - e_bsse]. psi4.set_variable('UNCP-CORRECTED 2-BODY INTERACTION ENERGY', e_full). psi4.print_out(""\n""); p4util.banner(""CP Computation: Results.""); psi4.print_out(""\n""). p4util.banner(""Hartree"", 2); psi4.print_out(""\n""). psi4.print_out(str(cp_table)). psi4.print_out(""\n""); p4util.banner(""kcal*mol^-1"", 2); psi4.print_out(""\n""). cp_table.scale(). psi4.print_out(str(cp_table)); return e_full. ## Aliases ##; counterpoise_correct = cp; counterpoise_correction = cp. #################; ## End of cp ##;",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:22645,Energy Efficiency,ENERGY,ENERGY,22645,"gy (full):""]); cp_table[""Complex""] = [e_dimer]; for cluster_n in range(0, len(monomers)):; key = ""Monomer %d"" % (cluster_n + 1); cp_table[key] = [e_monomer_full[cluster_n]]. e_full = e_dimer; for cluster_n in range(0, len(monomers)):; e_full = e_full - e_monomer_full[cluster_n]; cp_table[""Interaction""] = [e_full]. psi4.set_variable('CP-CORRECTED 2-BODY INTERACTION ENERGY', e_full). else:; cp_table = Table(rows=[""System:""], cols=[""Energy (full):"", ""Energy (monomer):"", ""BSSE:""]); cp_table[""Complex""] = [e_dimer, 0.0, 0.0]; for cluster_n in range(0, len(monomers)):; key = ""Monomer %d"" % (cluster_n + 1); cp_table[key] = [e_monomer_full[cluster_n], e_monomer_bsse[cluster_n], \; e_monomer_full[cluster_n] - e_monomer_bsse[cluster_n]]. e_full = e_dimer; e_bsse = e_dimer; for cluster_n in range(0, len(monomers)):; e_full = e_full - e_monomer_full[cluster_n]; e_bsse = e_bsse - e_monomer_bsse[cluster_n]; cp_table[""Totals:""] = [e_full, e_bsse, e_full - e_bsse]. psi4.set_variable('UNCP-CORRECTED 2-BODY INTERACTION ENERGY', e_full). psi4.print_out(""\n""); p4util.banner(""CP Computation: Results.""); psi4.print_out(""\n""). p4util.banner(""Hartree"", 2); psi4.print_out(""\n""). psi4.print_out(str(cp_table)). psi4.print_out(""\n""); p4util.banner(""kcal*mol^-1"", 2); psi4.print_out(""\n""). cp_table.scale(). psi4.print_out(str(cp_table)); return e_full. ## Aliases ##; counterpoise_correct = cp; counterpoise_correction = cp. #################; ## End of cp ##; #################. #########################; ## Start of Database ##; #########################. DB_RGT = {}; DB_RXN = {}. [docs]def database(name, db_name, **kwargs):; r""""""Function to access the molecule objects and reference energies of; popular chemical databases. :aliases: db(). :returns: (*float*) Mean absolute deviation of the database in kcal/mol. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`db_name DATABASE MEAN SIGNED DEVIATION <db_nameDATABASEMEANSIGNEDDEVIATION>`; * :psivar:`db_name DATABASE MEAN ABSOLUTE DEVIATION <db_name",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:24645,Energy Efficiency,energy,energy,24645,"EDEVIATION>`; * :psivar:`db_name DATABASE ROOT-MEAN-SQUARE DEVIATION <db_nameDATABASEROOT-MEAN-SQUARESIGNEDDEVIATION>`; * Python dictionaries of results accessible as ``DB_RGT`` and ``DB_RXN``. .. note:: It is very easy to make a database from a collection of xyz files; using the script :source:`lib/scripts/ixyz2database.pl`.; See :ref:`sec:createDatabase` for details. .. caution:: Some features are not yet implemented. Buy a developer some coffee. - In sow/reap mode, use only global options (e.g., the local option set by ``set scf scf_type df`` will not be respected). .. note:: To access a database that is not embedded in a |PSIfour|; distribution, add the path to the directory containing the database; to the environment variable :envvar:`PYTHONPATH`. :type name: string; :param name: ``'scf'`` || ``'sapt0'`` || ``'ccsd(t)'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; :py:func:`~driver.energy`. :type db_name: string; :param db_name: ``'BASIC'`` || ``'S22'`` || ``'HTBH'`` || etc. Second argument, usually unlabeled. Indicates the requested database; name, matching (case insensitive) the name of a python file in; ``psi4/lib/databases`` or :envvar:`PYTHONPATH`. Consult that; directory for available databases and literature citations. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``energy`` |dr| || ``optimize`` || ``cbs``. Indicates the type of calculation to be performed on each database; member. The default performs a single-point ``energy('name')``, while; ``optimize`` perfoms a geometry optimization on each reagent, and; ``cbs`` performs a compound single-point energy. If a nested series; of python functions is intended (see :ref:`sec:intercalls`), use; keyword ``db_func`` instead of ``func``. :type mode: string; :param mode: |dl| ``'continuous'`` |dr| || ``'sow'`` || ``'reap'``. Indicates whether the calculations required to complete the; database are t",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:25062,Energy Efficiency,energy,energy,25062,"re not yet implemented. Buy a developer some coffee. - In sow/reap mode, use only global options (e.g., the local option set by ``set scf scf_type df`` will not be respected). .. note:: To access a database that is not embedded in a |PSIfour|; distribution, add the path to the directory containing the database; to the environment variable :envvar:`PYTHONPATH`. :type name: string; :param name: ``'scf'`` || ``'sapt0'`` || ``'ccsd(t)'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; :py:func:`~driver.energy`. :type db_name: string; :param db_name: ``'BASIC'`` || ``'S22'`` || ``'HTBH'`` || etc. Second argument, usually unlabeled. Indicates the requested database; name, matching (case insensitive) the name of a python file in; ``psi4/lib/databases`` or :envvar:`PYTHONPATH`. Consult that; directory for available databases and literature citations. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``energy`` |dr| || ``optimize`` || ``cbs``. Indicates the type of calculation to be performed on each database; member. The default performs a single-point ``energy('name')``, while; ``optimize`` perfoms a geometry optimization on each reagent, and; ``cbs`` performs a compound single-point energy. If a nested series; of python functions is intended (see :ref:`sec:intercalls`), use; keyword ``db_func`` instead of ``func``. :type mode: string; :param mode: |dl| ``'continuous'`` |dr| || ``'sow'`` || ``'reap'``. Indicates whether the calculations required to complete the; database are to be run in one file (``'continuous'``) or are to be; farmed out in an embarrassingly parallel fashion; (``'sow'``/``'reap'``). For the latter, run an initial job with; ``'sow'`` and follow instructions in its output file. :type cp: :ref:`boolean <op_py_boolean>`; :param cp: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether counterpoise correction is employed in computing; interaction energies. U",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:25218,Energy Efficiency,energy,energy,25218,"embedded in a |PSIfour|; distribution, add the path to the directory containing the database; to the environment variable :envvar:`PYTHONPATH`. :type name: string; :param name: ``'scf'`` || ``'sapt0'`` || ``'ccsd(t)'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; :py:func:`~driver.energy`. :type db_name: string; :param db_name: ``'BASIC'`` || ``'S22'`` || ``'HTBH'`` || etc. Second argument, usually unlabeled. Indicates the requested database; name, matching (case insensitive) the name of a python file in; ``psi4/lib/databases`` or :envvar:`PYTHONPATH`. Consult that; directory for available databases and literature citations. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``energy`` |dr| || ``optimize`` || ``cbs``. Indicates the type of calculation to be performed on each database; member. The default performs a single-point ``energy('name')``, while; ``optimize`` perfoms a geometry optimization on each reagent, and; ``cbs`` performs a compound single-point energy. If a nested series; of python functions is intended (see :ref:`sec:intercalls`), use; keyword ``db_func`` instead of ``func``. :type mode: string; :param mode: |dl| ``'continuous'`` |dr| || ``'sow'`` || ``'reap'``. Indicates whether the calculations required to complete the; database are to be run in one file (``'continuous'``) or are to be; farmed out in an embarrassingly parallel fashion; (``'sow'``/``'reap'``). For the latter, run an initial job with; ``'sow'`` and follow instructions in its output file. :type cp: :ref:`boolean <op_py_boolean>`; :param cp: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether counterpoise correction is employed in computing; interaction energies. Use this option and NOT the :py:func:`~wrappers.cp`; function for BSSE correction in database(). Option available; (See :ref:`sec:availableDatabases`) only for databases of bimolecular complexes. :type rlxd: :ref:`boolean",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:25351,Energy Efficiency,energy,energy,25351,"embedded in a |PSIfour|; distribution, add the path to the directory containing the database; to the environment variable :envvar:`PYTHONPATH`. :type name: string; :param name: ``'scf'`` || ``'sapt0'`` || ``'ccsd(t)'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; :py:func:`~driver.energy`. :type db_name: string; :param db_name: ``'BASIC'`` || ``'S22'`` || ``'HTBH'`` || etc. Second argument, usually unlabeled. Indicates the requested database; name, matching (case insensitive) the name of a python file in; ``psi4/lib/databases`` or :envvar:`PYTHONPATH`. Consult that; directory for available databases and literature citations. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``energy`` |dr| || ``optimize`` || ``cbs``. Indicates the type of calculation to be performed on each database; member. The default performs a single-point ``energy('name')``, while; ``optimize`` perfoms a geometry optimization on each reagent, and; ``cbs`` performs a compound single-point energy. If a nested series; of python functions is intended (see :ref:`sec:intercalls`), use; keyword ``db_func`` instead of ``func``. :type mode: string; :param mode: |dl| ``'continuous'`` |dr| || ``'sow'`` || ``'reap'``. Indicates whether the calculations required to complete the; database are to be run in one file (``'continuous'``) or are to be; farmed out in an embarrassingly parallel fashion; (``'sow'``/``'reap'``). For the latter, run an initial job with; ``'sow'`` and follow instructions in its output file. :type cp: :ref:`boolean <op_py_boolean>`; :param cp: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether counterpoise correction is employed in computing; interaction energies. Use this option and NOT the :py:func:`~wrappers.cp`; function for BSSE correction in database(). Option available; (See :ref:`sec:availableDatabases`) only for databases of bimolecular complexes. :type rlxd: :ref:`boolean",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:26379,Energy Efficiency,energy,energy,26379,"ython functions is intended (see :ref:`sec:intercalls`), use; keyword ``db_func`` instead of ``func``. :type mode: string; :param mode: |dl| ``'continuous'`` |dr| || ``'sow'`` || ``'reap'``. Indicates whether the calculations required to complete the; database are to be run in one file (``'continuous'``) or are to be; farmed out in an embarrassingly parallel fashion; (``'sow'``/``'reap'``). For the latter, run an initial job with; ``'sow'`` and follow instructions in its output file. :type cp: :ref:`boolean <op_py_boolean>`; :param cp: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether counterpoise correction is employed in computing; interaction energies. Use this option and NOT the :py:func:`~wrappers.cp`; function for BSSE correction in database(). Option available; (See :ref:`sec:availableDatabases`) only for databases of bimolecular complexes. :type rlxd: :ref:`boolean <op_py_boolean>`; :param rlxd: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether correction for deformation energy is; employed in computing interaction energies. Option available; (See :ref:`sec:availableDatabases`) only for databases of bimolecular complexes; with non-frozen monomers, e.g., HBC6. :type symm: :ref:`boolean <op_py_boolean>`; :param symm: |dl| ``'on'`` |dr| || ``'off'``. Indicates whether the native symmetry of the database reagents is; employed (``'on'``) or whether it is forced to :math:`C_1` symmetry; (``'off'``). Some computational methods (e.g., SAPT) require no; symmetry, and this will be set by database(). :type zpe: :ref:`boolean <op_py_boolean>`; :param zpe: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether zero-point-energy corrections are appended to; single-point energy values. Option valid only for certain; thermochemical databases. Disabled until Hessians ready. :type benchmark: string; :param benchmark: |dl| ``'default'`` |dr| || ``'S22A'`` || etc. Indicates whether a non-default set of reference energies, if; available (See :ref:`sec:availableDatabases`), are emp",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:27025,Energy Efficiency,energy,energy,27025,"rgies. Use this option and NOT the :py:func:`~wrappers.cp`; function for BSSE correction in database(). Option available; (See :ref:`sec:availableDatabases`) only for databases of bimolecular complexes. :type rlxd: :ref:`boolean <op_py_boolean>`; :param rlxd: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether correction for deformation energy is; employed in computing interaction energies. Option available; (See :ref:`sec:availableDatabases`) only for databases of bimolecular complexes; with non-frozen monomers, e.g., HBC6. :type symm: :ref:`boolean <op_py_boolean>`; :param symm: |dl| ``'on'`` |dr| || ``'off'``. Indicates whether the native symmetry of the database reagents is; employed (``'on'``) or whether it is forced to :math:`C_1` symmetry; (``'off'``). Some computational methods (e.g., SAPT) require no; symmetry, and this will be set by database(). :type zpe: :ref:`boolean <op_py_boolean>`; :param zpe: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether zero-point-energy corrections are appended to; single-point energy values. Option valid only for certain; thermochemical databases. Disabled until Hessians ready. :type benchmark: string; :param benchmark: |dl| ``'default'`` |dr| || ``'S22A'`` || etc. Indicates whether a non-default set of reference energies, if; available (See :ref:`sec:availableDatabases`), are employed for the; calculation of error statistics. :type tabulate: array of strings; :param tabulate: |dl| ``[]`` |dr| || ``['scf total energy', 'natom']`` || etc. Indicates whether to form tables of variables other than the; primary requested energy. Available for any PSI variable. :type subset: string or array of strings; :param subset:. Indicates a subset of the full database to run. This is a very; flexible option and can be used in three distinct ways, outlined; below. Note that two take a string and the last takes an array.; See `Available Databases`_ for available values. * ``'small'`` || ``'large'`` || ``'equilibrium'``; Calls predefined subsets ",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:27074,Energy Efficiency,energy,energy,27074,"rgies. Use this option and NOT the :py:func:`~wrappers.cp`; function for BSSE correction in database(). Option available; (See :ref:`sec:availableDatabases`) only for databases of bimolecular complexes. :type rlxd: :ref:`boolean <op_py_boolean>`; :param rlxd: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether correction for deformation energy is; employed in computing interaction energies. Option available; (See :ref:`sec:availableDatabases`) only for databases of bimolecular complexes; with non-frozen monomers, e.g., HBC6. :type symm: :ref:`boolean <op_py_boolean>`; :param symm: |dl| ``'on'`` |dr| || ``'off'``. Indicates whether the native symmetry of the database reagents is; employed (``'on'``) or whether it is forced to :math:`C_1` symmetry; (``'off'``). Some computational methods (e.g., SAPT) require no; symmetry, and this will be set by database(). :type zpe: :ref:`boolean <op_py_boolean>`; :param zpe: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether zero-point-energy corrections are appended to; single-point energy values. Option valid only for certain; thermochemical databases. Disabled until Hessians ready. :type benchmark: string; :param benchmark: |dl| ``'default'`` |dr| || ``'S22A'`` || etc. Indicates whether a non-default set of reference energies, if; available (See :ref:`sec:availableDatabases`), are employed for the; calculation of error statistics. :type tabulate: array of strings; :param tabulate: |dl| ``[]`` |dr| || ``['scf total energy', 'natom']`` || etc. Indicates whether to form tables of variables other than the; primary requested energy. Available for any PSI variable. :type subset: string or array of strings; :param subset:. Indicates a subset of the full database to run. This is a very; flexible option and can be used in three distinct ways, outlined; below. Note that two take a string and the last takes an array.; See `Available Databases`_ for available values. * ``'small'`` || ``'large'`` || ``'equilibrium'``; Calls predefined subsets ",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:27516,Energy Efficiency,energy,energy,27516,") only for databases of bimolecular complexes; with non-frozen monomers, e.g., HBC6. :type symm: :ref:`boolean <op_py_boolean>`; :param symm: |dl| ``'on'`` |dr| || ``'off'``. Indicates whether the native symmetry of the database reagents is; employed (``'on'``) or whether it is forced to :math:`C_1` symmetry; (``'off'``). Some computational methods (e.g., SAPT) require no; symmetry, and this will be set by database(). :type zpe: :ref:`boolean <op_py_boolean>`; :param zpe: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether zero-point-energy corrections are appended to; single-point energy values. Option valid only for certain; thermochemical databases. Disabled until Hessians ready. :type benchmark: string; :param benchmark: |dl| ``'default'`` |dr| || ``'S22A'`` || etc. Indicates whether a non-default set of reference energies, if; available (See :ref:`sec:availableDatabases`), are employed for the; calculation of error statistics. :type tabulate: array of strings; :param tabulate: |dl| ``[]`` |dr| || ``['scf total energy', 'natom']`` || etc. Indicates whether to form tables of variables other than the; primary requested energy. Available for any PSI variable. :type subset: string or array of strings; :param subset:. Indicates a subset of the full database to run. This is a very; flexible option and can be used in three distinct ways, outlined; below. Note that two take a string and the last takes an array.; See `Available Databases`_ for available values. * ``'small'`` || ``'large'`` || ``'equilibrium'``; Calls predefined subsets of the requested database, either; ``'small'``, a few of the smallest database members,; ``'large'``, the largest of the database members, or; ``'equilibrium'``, the equilibrium geometries for a database; composed of dissociation curves.; * ``'BzBz_S'`` || ``'FaOOFaON'`` || ``'ArNe'`` || ``'HB'`` || etc.; For databases composed of dissociation curves, or otherwise; divided into subsets, individual curves and subsets can be; called by name. C",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:27624,Energy Efficiency,energy,energy,27624,":`boolean <op_py_boolean>`; :param symm: |dl| ``'on'`` |dr| || ``'off'``. Indicates whether the native symmetry of the database reagents is; employed (``'on'``) or whether it is forced to :math:`C_1` symmetry; (``'off'``). Some computational methods (e.g., SAPT) require no; symmetry, and this will be set by database(). :type zpe: :ref:`boolean <op_py_boolean>`; :param zpe: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether zero-point-energy corrections are appended to; single-point energy values. Option valid only for certain; thermochemical databases. Disabled until Hessians ready. :type benchmark: string; :param benchmark: |dl| ``'default'`` |dr| || ``'S22A'`` || etc. Indicates whether a non-default set of reference energies, if; available (See :ref:`sec:availableDatabases`), are employed for the; calculation of error statistics. :type tabulate: array of strings; :param tabulate: |dl| ``[]`` |dr| || ``['scf total energy', 'natom']`` || etc. Indicates whether to form tables of variables other than the; primary requested energy. Available for any PSI variable. :type subset: string or array of strings; :param subset:. Indicates a subset of the full database to run. This is a very; flexible option and can be used in three distinct ways, outlined; below. Note that two take a string and the last takes an array.; See `Available Databases`_ for available values. * ``'small'`` || ``'large'`` || ``'equilibrium'``; Calls predefined subsets of the requested database, either; ``'small'``, a few of the smallest database members,; ``'large'``, the largest of the database members, or; ``'equilibrium'``, the equilibrium geometries for a database; composed of dissociation curves.; * ``'BzBz_S'`` || ``'FaOOFaON'`` || ``'ArNe'`` || ``'HB'`` || etc.; For databases composed of dissociation curves, or otherwise; divided into subsets, individual curves and subsets can be; called by name. Consult the database python files for available; molecular systems (case insensitive).; * ``[1,2,5]``",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:29089,Energy Efficiency,energy,energy,29089,"'``, a few of the smallest database members,; ``'large'``, the largest of the database members, or; ``'equilibrium'``, the equilibrium geometries for a database; composed of dissociation curves.; * ``'BzBz_S'`` || ``'FaOOFaON'`` || ``'ArNe'`` || ``'HB'`` || etc.; For databases composed of dissociation curves, or otherwise; divided into subsets, individual curves and subsets can be; called by name. Consult the database python files for available; molecular systems (case insensitive).; * ``[1,2,5]`` || ``['1','2','5']`` || ``['BzMe-3.5', 'MeMe-5.0']`` || etc.; Specify a list of database members to run. Consult the; database python files for available molecular systems. This; is the only portion of database input that is case sensitive;; choices for this keyword must match the database python file. :examples:. >>> # [1] Two-stage SCF calculation on short, equilibrium, and long helium dimer; >>> db('scf','RGC10',cast_up='sto-3g',subset=['HeHe-0.85','HeHe-1.0','HeHe-1.5'], tabulate=['scf total energy','natom']). >>> # [2] Counterpoise-corrected interaction energies for three complexes in S22; >>> # Error statistics computed wrt an old benchmark, S22A; >>> database('df-mp2','S22',cp=1,subset=[16,17,8],benchmark='S22A'). >>> # [3] SAPT0 on the neon dimer dissociation curve; >>> db('sapt0',subset='NeNe',cp=0,symm=0,db_name='RGC10'). >>> # [4] Optimize system 1 in database S22, producing tables of scf and mp2 energy; >>> db('mp2','S22',db_func=optimize,subset=[1], tabulate=['mp2 total energy','current energy']). >>> # [5] CCSD on the smallest systems of HTBH, a hydrogen-transfer database; >>> database('ccsd','HTBH',subset='small', tabulate=['ccsd total energy', 'mp2 total energy']). """"""; lowername = name.lower(); kwargs = p4util.kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name.lower(); if not('db_name' in kwargs) and db_name:; kwargs['db_name'] = db_name. # Establish f",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:29509,Energy Efficiency,energy,energy,29509,"r available; molecular systems (case insensitive).; * ``[1,2,5]`` || ``['1','2','5']`` || ``['BzMe-3.5', 'MeMe-5.0']`` || etc.; Specify a list of database members to run. Consult the; database python files for available molecular systems. This; is the only portion of database input that is case sensitive;; choices for this keyword must match the database python file. :examples:. >>> # [1] Two-stage SCF calculation on short, equilibrium, and long helium dimer; >>> db('scf','RGC10',cast_up='sto-3g',subset=['HeHe-0.85','HeHe-1.0','HeHe-1.5'], tabulate=['scf total energy','natom']). >>> # [2] Counterpoise-corrected interaction energies for three complexes in S22; >>> # Error statistics computed wrt an old benchmark, S22A; >>> database('df-mp2','S22',cp=1,subset=[16,17,8],benchmark='S22A'). >>> # [3] SAPT0 on the neon dimer dissociation curve; >>> db('sapt0',subset='NeNe',cp=0,symm=0,db_name='RGC10'). >>> # [4] Optimize system 1 in database S22, producing tables of scf and mp2 energy; >>> db('mp2','S22',db_func=optimize,subset=[1], tabulate=['mp2 total energy','current energy']). >>> # [5] CCSD on the smallest systems of HTBH, a hydrogen-transfer database; >>> database('ccsd','HTBH',subset='small', tabulate=['ccsd total energy', 'mp2 total energy']). """"""; lowername = name.lower(); kwargs = p4util.kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name.lower(); if not('db_name' in kwargs) and db_name:; kwargs['db_name'] = db_name. # Establish function to call; if not('db_func' in kwargs):; if ('func' in kwargs):; kwargs['db_func'] = kwargs['func']; del kwargs['func']; else:; kwargs['db_func'] = energy; func = kwargs['db_func']; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper database.' % (func.__name__)); if (func is cp):; raise ValidationError('Wrapper database is unhappy to be calling function \'%s\'. Use the cp keyword within ",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:29586,Energy Efficiency,energy,energy,29586,"r available; molecular systems (case insensitive).; * ``[1,2,5]`` || ``['1','2','5']`` || ``['BzMe-3.5', 'MeMe-5.0']`` || etc.; Specify a list of database members to run. Consult the; database python files for available molecular systems. This; is the only portion of database input that is case sensitive;; choices for this keyword must match the database python file. :examples:. >>> # [1] Two-stage SCF calculation on short, equilibrium, and long helium dimer; >>> db('scf','RGC10',cast_up='sto-3g',subset=['HeHe-0.85','HeHe-1.0','HeHe-1.5'], tabulate=['scf total energy','natom']). >>> # [2] Counterpoise-corrected interaction energies for three complexes in S22; >>> # Error statistics computed wrt an old benchmark, S22A; >>> database('df-mp2','S22',cp=1,subset=[16,17,8],benchmark='S22A'). >>> # [3] SAPT0 on the neon dimer dissociation curve; >>> db('sapt0',subset='NeNe',cp=0,symm=0,db_name='RGC10'). >>> # [4] Optimize system 1 in database S22, producing tables of scf and mp2 energy; >>> db('mp2','S22',db_func=optimize,subset=[1], tabulate=['mp2 total energy','current energy']). >>> # [5] CCSD on the smallest systems of HTBH, a hydrogen-transfer database; >>> database('ccsd','HTBH',subset='small', tabulate=['ccsd total energy', 'mp2 total energy']). """"""; lowername = name.lower(); kwargs = p4util.kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name.lower(); if not('db_name' in kwargs) and db_name:; kwargs['db_name'] = db_name. # Establish function to call; if not('db_func' in kwargs):; if ('func' in kwargs):; kwargs['db_func'] = kwargs['func']; del kwargs['func']; else:; kwargs['db_func'] = energy; func = kwargs['db_func']; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper database.' % (func.__name__)); if (func is cp):; raise ValidationError('Wrapper database is unhappy to be calling function \'%s\'. Use the cp keyword within ",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:29603,Energy Efficiency,energy,energy,29603,"r available; molecular systems (case insensitive).; * ``[1,2,5]`` || ``['1','2','5']`` || ``['BzMe-3.5', 'MeMe-5.0']`` || etc.; Specify a list of database members to run. Consult the; database python files for available molecular systems. This; is the only portion of database input that is case sensitive;; choices for this keyword must match the database python file. :examples:. >>> # [1] Two-stage SCF calculation on short, equilibrium, and long helium dimer; >>> db('scf','RGC10',cast_up='sto-3g',subset=['HeHe-0.85','HeHe-1.0','HeHe-1.5'], tabulate=['scf total energy','natom']). >>> # [2] Counterpoise-corrected interaction energies for three complexes in S22; >>> # Error statistics computed wrt an old benchmark, S22A; >>> database('df-mp2','S22',cp=1,subset=[16,17,8],benchmark='S22A'). >>> # [3] SAPT0 on the neon dimer dissociation curve; >>> db('sapt0',subset='NeNe',cp=0,symm=0,db_name='RGC10'). >>> # [4] Optimize system 1 in database S22, producing tables of scf and mp2 energy; >>> db('mp2','S22',db_func=optimize,subset=[1], tabulate=['mp2 total energy','current energy']). >>> # [5] CCSD on the smallest systems of HTBH, a hydrogen-transfer database; >>> database('ccsd','HTBH',subset='small', tabulate=['ccsd total energy', 'mp2 total energy']). """"""; lowername = name.lower(); kwargs = p4util.kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name.lower(); if not('db_name' in kwargs) and db_name:; kwargs['db_name'] = db_name. # Establish function to call; if not('db_func' in kwargs):; if ('func' in kwargs):; kwargs['db_func'] = kwargs['func']; del kwargs['func']; else:; kwargs['db_func'] = energy; func = kwargs['db_func']; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper database.' % (func.__name__)); if (func is cp):; raise ValidationError('Wrapper database is unhappy to be calling function \'%s\'. Use the cp keyword within ",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:29757,Energy Efficiency,energy,energy,29757," the; database python files for available molecular systems. This; is the only portion of database input that is case sensitive;; choices for this keyword must match the database python file. :examples:. >>> # [1] Two-stage SCF calculation on short, equilibrium, and long helium dimer; >>> db('scf','RGC10',cast_up='sto-3g',subset=['HeHe-0.85','HeHe-1.0','HeHe-1.5'], tabulate=['scf total energy','natom']). >>> # [2] Counterpoise-corrected interaction energies for three complexes in S22; >>> # Error statistics computed wrt an old benchmark, S22A; >>> database('df-mp2','S22',cp=1,subset=[16,17,8],benchmark='S22A'). >>> # [3] SAPT0 on the neon dimer dissociation curve; >>> db('sapt0',subset='NeNe',cp=0,symm=0,db_name='RGC10'). >>> # [4] Optimize system 1 in database S22, producing tables of scf and mp2 energy; >>> db('mp2','S22',db_func=optimize,subset=[1], tabulate=['mp2 total energy','current energy']). >>> # [5] CCSD on the smallest systems of HTBH, a hydrogen-transfer database; >>> database('ccsd','HTBH',subset='small', tabulate=['ccsd total energy', 'mp2 total energy']). """"""; lowername = name.lower(); kwargs = p4util.kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name.lower(); if not('db_name' in kwargs) and db_name:; kwargs['db_name'] = db_name. # Establish function to call; if not('db_func' in kwargs):; if ('func' in kwargs):; kwargs['db_func'] = kwargs['func']; del kwargs['func']; else:; kwargs['db_func'] = energy; func = kwargs['db_func']; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper database.' % (func.__name__)); if (func is cp):; raise ValidationError('Wrapper database is unhappy to be calling function \'%s\'. Use the cp keyword within database instead.' % (func.__name__)). # Define path and load module for requested database; sys.path.append('%sdatabases' % (psi4.Process.environment[""PSIDATADIR""])); sys.path.a",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:29777,Energy Efficiency,energy,energy,29777," the; database python files for available molecular systems. This; is the only portion of database input that is case sensitive;; choices for this keyword must match the database python file. :examples:. >>> # [1] Two-stage SCF calculation on short, equilibrium, and long helium dimer; >>> db('scf','RGC10',cast_up='sto-3g',subset=['HeHe-0.85','HeHe-1.0','HeHe-1.5'], tabulate=['scf total energy','natom']). >>> # [2] Counterpoise-corrected interaction energies for three complexes in S22; >>> # Error statistics computed wrt an old benchmark, S22A; >>> database('df-mp2','S22',cp=1,subset=[16,17,8],benchmark='S22A'). >>> # [3] SAPT0 on the neon dimer dissociation curve; >>> db('sapt0',subset='NeNe',cp=0,symm=0,db_name='RGC10'). >>> # [4] Optimize system 1 in database S22, producing tables of scf and mp2 energy; >>> db('mp2','S22',db_func=optimize,subset=[1], tabulate=['mp2 total energy','current energy']). >>> # [5] CCSD on the smallest systems of HTBH, a hydrogen-transfer database; >>> database('ccsd','HTBH',subset='small', tabulate=['ccsd total energy', 'mp2 total energy']). """"""; lowername = name.lower(); kwargs = p4util.kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name.lower(); if not('db_name' in kwargs) and db_name:; kwargs['db_name'] = db_name. # Establish function to call; if not('db_func' in kwargs):; if ('func' in kwargs):; kwargs['db_func'] = kwargs['func']; del kwargs['func']; else:; kwargs['db_func'] = energy; func = kwargs['db_func']; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper database.' % (func.__name__)); if (func is cp):; raise ValidationError('Wrapper database is unhappy to be calling function \'%s\'. Use the cp keyword within database instead.' % (func.__name__)). # Define path and load module for requested database; sys.path.append('%sdatabases' % (psi4.Process.environment[""PSIDATADIR""])); sys.path.a",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:30239,Energy Efficiency,energy,energy,30239,"wrt an old benchmark, S22A; >>> database('df-mp2','S22',cp=1,subset=[16,17,8],benchmark='S22A'). >>> # [3] SAPT0 on the neon dimer dissociation curve; >>> db('sapt0',subset='NeNe',cp=0,symm=0,db_name='RGC10'). >>> # [4] Optimize system 1 in database S22, producing tables of scf and mp2 energy; >>> db('mp2','S22',db_func=optimize,subset=[1], tabulate=['mp2 total energy','current energy']). >>> # [5] CCSD on the smallest systems of HTBH, a hydrogen-transfer database; >>> database('ccsd','HTBH',subset='small', tabulate=['ccsd total energy', 'mp2 total energy']). """"""; lowername = name.lower(); kwargs = p4util.kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name.lower(); if not('db_name' in kwargs) and db_name:; kwargs['db_name'] = db_name. # Establish function to call; if not('db_func' in kwargs):; if ('func' in kwargs):; kwargs['db_func'] = kwargs['func']; del kwargs['func']; else:; kwargs['db_func'] = energy; func = kwargs['db_func']; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper database.' % (func.__name__)); if (func is cp):; raise ValidationError('Wrapper database is unhappy to be calling function \'%s\'. Use the cp keyword within database instead.' % (func.__name__)). # Define path and load module for requested database; sys.path.append('%sdatabases' % (psi4.Process.environment[""PSIDATADIR""])); sys.path.append('%s/lib/databases' % psi4.psi_top_srcdir()); database = p4util.import_ignorecase(db_name); if database is None:; psi4.print_out('\nPython module for database %s failed to load\n\n' % (db_name)); psi4.print_out('\nSearch path that was tried:\n'); psi4.print_out("", "".join(map(str, sys.path))); raise ValidationError(""Python module loading problem for database "" + str(db_name)); else:; dbse = database.dbse; HRXN = database.HRXN; ACTV = database.ACTV; RXNM = database.RXNM; BIND = database.BIND; TAGL = database.TAGL; ",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:33720,Energy Efficiency,energy,energy,33720,ed normally or turned off (currently req'd for dfmp2 & dft); db_symm = 'yes'; if 'symm' in kwargs:; db_symm = kwargs['symm']. symmetry_override = 0; if no.match(str(db_symm)):; symmetry_override = 1; elif yes.match(str(db_symm)):; pass; else:; raise ValidationError('Symmetry mode \'%s\' not valid.' % (db_symm)). # Option mode of operation- whether db run in one job or files farmed out; if not('db_mode' in kwargs):; if ('mode' in kwargs):; kwargs['db_mode'] = kwargs['mode']; del kwargs['mode']; else:; kwargs['db_mode'] = 'continuous'; db_mode = kwargs['db_mode']. if (db_mode.lower() == 'continuous'):; pass; elif (db_mode.lower() == 'sow'):; pass; elif (db_mode.lower() == 'reap'):; if 'linkage' in kwargs:; db_linkage = kwargs['linkage']; else:; raise ValidationError('Database execution mode \'reap\' requires a linkage option.'); else:; raise ValidationError('Database execution mode \'%s\' not valid.' % (db_mode)). # Option counterpoise- whether for interaction energy databases run in bsse-corrected or not; db_cp = 'no'; if 'cp' in kwargs:; db_cp = kwargs['cp']. if yes.match(str(db_cp)):; try:; database.ACTV_CP; except AttributeError:; raise ValidationError('Counterpoise correction mode \'yes\' invalid for database %s.' % (db_name)); else:; ACTV = database.ACTV_CP; elif no.match(str(db_cp)):; pass; else:; raise ValidationError('Counterpoise correction mode \'%s\' not valid.' % (db_cp)). # Option relaxed- whether for non-frozen-monomer interaction energy databases include deformation correction or not?; db_rlxd = 'no'; if 'rlxd' in kwargs:; db_rlxd = kwargs['rlxd']. if yes.match(str(db_rlxd)):; if yes.match(str(db_cp)):; try:; database.ACTV_CPRLX; database.RXNM_CPRLX; except AttributeError:; raise ValidationError('Deformation and counterpoise correction mode \'yes\' invalid for database %s.' % (db_name)); else:; ACTV = database.ACTV_CPRLX; RXNM = database.RXNM_CPRLX; elif no.match(str(db_cp)):; try:; database.ACTV_RLX; except AttributeError:; raise ValidationError('Defo,MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:34215,Energy Efficiency,energy,energy,34215,; else:; kwargs['db_mode'] = 'continuous'; db_mode = kwargs['db_mode']. if (db_mode.lower() == 'continuous'):; pass; elif (db_mode.lower() == 'sow'):; pass; elif (db_mode.lower() == 'reap'):; if 'linkage' in kwargs:; db_linkage = kwargs['linkage']; else:; raise ValidationError('Database execution mode \'reap\' requires a linkage option.'); else:; raise ValidationError('Database execution mode \'%s\' not valid.' % (db_mode)). # Option counterpoise- whether for interaction energy databases run in bsse-corrected or not; db_cp = 'no'; if 'cp' in kwargs:; db_cp = kwargs['cp']. if yes.match(str(db_cp)):; try:; database.ACTV_CP; except AttributeError:; raise ValidationError('Counterpoise correction mode \'yes\' invalid for database %s.' % (db_name)); else:; ACTV = database.ACTV_CP; elif no.match(str(db_cp)):; pass; else:; raise ValidationError('Counterpoise correction mode \'%s\' not valid.' % (db_cp)). # Option relaxed- whether for non-frozen-monomer interaction energy databases include deformation correction or not?; db_rlxd = 'no'; if 'rlxd' in kwargs:; db_rlxd = kwargs['rlxd']. if yes.match(str(db_rlxd)):; if yes.match(str(db_cp)):; try:; database.ACTV_CPRLX; database.RXNM_CPRLX; except AttributeError:; raise ValidationError('Deformation and counterpoise correction mode \'yes\' invalid for database %s.' % (db_name)); else:; ACTV = database.ACTV_CPRLX; RXNM = database.RXNM_CPRLX; elif no.match(str(db_cp)):; try:; database.ACTV_RLX; except AttributeError:; raise ValidationError('Deformation correction mode \'yes\' invalid for database %s.' % (db_name)); else:; ACTV = database.ACTV_RLX; elif no.match(str(db_rlxd)):; pass; else:; raise ValidationError('Deformation correction mode \'%s\' not valid.' % (db_rlxd)). # Option zero-point-correction- whether for thermochem databases jobs are corrected by zpe; db_zpe = 'no'; if 'zpe' in kwargs:; db_zpe = kwargs['zpe']. if yes.match(str(db_zpe)):; raise ValidationError('Zero-point-correction mode \'yes\' not yet implemented.'); eli,MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:35856,Energy Efficiency,energy,energy,35856,"lxd)):; pass; else:; raise ValidationError('Deformation correction mode \'%s\' not valid.' % (db_rlxd)). # Option zero-point-correction- whether for thermochem databases jobs are corrected by zpe; db_zpe = 'no'; if 'zpe' in kwargs:; db_zpe = kwargs['zpe']. if yes.match(str(db_zpe)):; raise ValidationError('Zero-point-correction mode \'yes\' not yet implemented.'); elif no.match(str(db_zpe)):; pass; else:; raise ValidationError('Zero-point-correction \'mode\' %s not valid.' % (db_zpe)). # Option benchmark- whether error statistics computed wrt alternate reference energies; db_benchmark = 'default'; if 'benchmark' in kwargs:; db_benchmark = kwargs['benchmark']. if (db_benchmark.lower() == 'default'):; pass; else:; BIND = p4util.getattr_ignorecase(database, 'BIND_' + db_benchmark); if BIND is None:; raise ValidationError('Special benchmark \'%s\' not available for database %s.' % (db_benchmark, db_name)). # Option tabulate- whether tables of variables other than primary energy method are formed; db_tabulate = []; if 'tabulate' in kwargs:; db_tabulate = kwargs['tabulate']. # Option subset- whether all of the database or just a portion is run; db_subset = HRXN; if 'subset' in kwargs:; db_subset = kwargs['subset']. if isinstance(db_subset, basestring):; if (db_subset.lower() == 'small'):; try:; database.HRXN_SM; except AttributeError:; raise ValidationError('Special subset \'small\' not available for database %s.' % (db_name)); else:; HRXN = database.HRXN_SM; elif (db_subset.lower() == 'large'):; try:; database.HRXN_LG; except AttributeError:; raise ValidationError('Special subset \'large\' not available for database %s.' % (db_name)); else:; HRXN = database.HRXN_LG; elif (db_subset.lower() == 'equilibrium'):; try:; database.HRXN_EQ; except AttributeError:; raise ValidationError('Special subset \'equilibrium\' not available for database %s.' % (db_name)); else:; HRXN = database.HRXN_EQ; else:; HRXN = p4util.getattr_ignorecase(database, db_subset); if HRXN is None:; HRXN =",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:43516,Energy Efficiency,energy,energy,43516,"er_df_basis_elst == 'NONE')):; commands += """"""psi4.set_global_option('DF_BASIS_ELST', '%s')\n"""""" % (user_df_basis_elst); commands += """"""molecule = psi4.get_active_molecule()\n""""""; commands += """"""molecule.update_geometry()\n"""""". if symmetry_override:; commands += """"""molecule.reset_point_group('c1')\n""""""; commands += """"""molecule.fix_orientation(1)\n""""""; commands += """"""molecule.update_geometry()\n"""""". if (openshell_override) and (molecule.multiplicity() != 1):; if user_reference == 'RHF':; commands += """"""psi4.set_global_option('REFERENCE', 'UHF')\n""""""; elif user_reference == 'RKS':; commands += """"""psi4.set_global_option('REFERENCE', 'UKS')\n"""""". commands += """"""psi4.set_global_option('WRITER_FILE_LABEL', '%s')\n"""""" % \; (user_writer_file_label + ('' if user_writer_file_label == '' else '-') + rgt). # all modes need to step through the reagents but all for different purposes; # continuous: defines necessary commands, executes energy(method) call, and collects results into dictionary; # sow: opens individual reagent input file, writes the necessary commands, and writes energy(method) call; # reap: opens individual reagent output file, collects results into a dictionary; if (db_mode.lower() == 'continuous'):; exec(banners); exec(p4util.format_molecule_for_input(GEOS[rgt])); exec(commands); #print 'MOLECULE LIVES %23s %8s %4d %4d %4s' % (rgt, psi4.get_global_option('REFERENCE'),; # molecule.molecular_charge(), molecule.multiplicity(), molecule.schoenflies_symbol()); psi4.set_variable('NATOM', molecule.natom()); psi4.set_variable('NUCLEAR REPULSION ENERGY', molecule.nuclear_repulsion_energy()); if re.match(r'^verify', lowername):; compare_values(DATA['NUCLEAR REPULSION ENERGY'][rgt], psi4.get_variable('NUCLEAR REPULSION ENERGY'),; 4, '%s %.4f' % (rgt, psi4.get_variable('NUCLEAR REPULSION ENERGY'))); ERGT[rgt] = 7.0; else:; ERGT[rgt] = call_function_in_1st_argument(func, **kwargs); #print ERGT[rgt]; psi4.print_variables(); exec(actives); for envv in db_tabulate:; VRGT[rgt][en",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:43661,Energy Efficiency,energy,energy,43661,"er_df_basis_elst == 'NONE')):; commands += """"""psi4.set_global_option('DF_BASIS_ELST', '%s')\n"""""" % (user_df_basis_elst); commands += """"""molecule = psi4.get_active_molecule()\n""""""; commands += """"""molecule.update_geometry()\n"""""". if symmetry_override:; commands += """"""molecule.reset_point_group('c1')\n""""""; commands += """"""molecule.fix_orientation(1)\n""""""; commands += """"""molecule.update_geometry()\n"""""". if (openshell_override) and (molecule.multiplicity() != 1):; if user_reference == 'RHF':; commands += """"""psi4.set_global_option('REFERENCE', 'UHF')\n""""""; elif user_reference == 'RKS':; commands += """"""psi4.set_global_option('REFERENCE', 'UKS')\n"""""". commands += """"""psi4.set_global_option('WRITER_FILE_LABEL', '%s')\n"""""" % \; (user_writer_file_label + ('' if user_writer_file_label == '' else '-') + rgt). # all modes need to step through the reagents but all for different purposes; # continuous: defines necessary commands, executes energy(method) call, and collects results into dictionary; # sow: opens individual reagent input file, writes the necessary commands, and writes energy(method) call; # reap: opens individual reagent output file, collects results into a dictionary; if (db_mode.lower() == 'continuous'):; exec(banners); exec(p4util.format_molecule_for_input(GEOS[rgt])); exec(commands); #print 'MOLECULE LIVES %23s %8s %4d %4d %4s' % (rgt, psi4.get_global_option('REFERENCE'),; # molecule.molecular_charge(), molecule.multiplicity(), molecule.schoenflies_symbol()); psi4.set_variable('NATOM', molecule.natom()); psi4.set_variable('NUCLEAR REPULSION ENERGY', molecule.nuclear_repulsion_energy()); if re.match(r'^verify', lowername):; compare_values(DATA['NUCLEAR REPULSION ENERGY'][rgt], psi4.get_variable('NUCLEAR REPULSION ENERGY'),; 4, '%s %.4f' % (rgt, psi4.get_variable('NUCLEAR REPULSION ENERGY'))); ERGT[rgt] = 7.0; else:; ERGT[rgt] = call_function_in_1st_argument(func, **kwargs); #print ERGT[rgt]; psi4.print_variables(); exec(actives); for envv in db_tabulate:; VRGT[rgt][en",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:44147,Energy Efficiency,ENERGY,ENERGY,44147,"f user_reference == 'RKS':; commands += """"""psi4.set_global_option('REFERENCE', 'UKS')\n"""""". commands += """"""psi4.set_global_option('WRITER_FILE_LABEL', '%s')\n"""""" % \; (user_writer_file_label + ('' if user_writer_file_label == '' else '-') + rgt). # all modes need to step through the reagents but all for different purposes; # continuous: defines necessary commands, executes energy(method) call, and collects results into dictionary; # sow: opens individual reagent input file, writes the necessary commands, and writes energy(method) call; # reap: opens individual reagent output file, collects results into a dictionary; if (db_mode.lower() == 'continuous'):; exec(banners); exec(p4util.format_molecule_for_input(GEOS[rgt])); exec(commands); #print 'MOLECULE LIVES %23s %8s %4d %4d %4s' % (rgt, psi4.get_global_option('REFERENCE'),; # molecule.molecular_charge(), molecule.multiplicity(), molecule.schoenflies_symbol()); psi4.set_variable('NATOM', molecule.natom()); psi4.set_variable('NUCLEAR REPULSION ENERGY', molecule.nuclear_repulsion_energy()); if re.match(r'^verify', lowername):; compare_values(DATA['NUCLEAR REPULSION ENERGY'][rgt], psi4.get_variable('NUCLEAR REPULSION ENERGY'),; 4, '%s %.4f' % (rgt, psi4.get_variable('NUCLEAR REPULSION ENERGY'))); ERGT[rgt] = 7.0; else:; ERGT[rgt] = call_function_in_1st_argument(func, **kwargs); #print ERGT[rgt]; psi4.print_variables(); exec(actives); for envv in db_tabulate:; VRGT[rgt][envv.upper()] = psi4.get_variable(envv); psi4.set_global_option(""REFERENCE"", user_reference); psi4.clean(). elif (db_mode.lower() == 'sow'):; freagent = open('%s.in' % (rgt), 'w'); freagent.write('# This is a psi4 input file auto-generated from the database() wrapper.\n\n'); freagent.write(banners); freagent.write(p4util.format_molecule_for_input(GEOS[rgt])). freagent.write(commands); freagent.write('''\npickle_kw = (""""""'''); pickle.dump(kwargs, freagent); freagent.write('''"""""")\n'''); freagent.write(""""""\nkwargs = pickle.loads(pickle_kw)\n""""""); freagent.w",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:44270,Energy Efficiency,ENERGY,ENERGY,44270,"""""psi4.set_global_option('WRITER_FILE_LABEL', '%s')\n"""""" % \; (user_writer_file_label + ('' if user_writer_file_label == '' else '-') + rgt). # all modes need to step through the reagents but all for different purposes; # continuous: defines necessary commands, executes energy(method) call, and collects results into dictionary; # sow: opens individual reagent input file, writes the necessary commands, and writes energy(method) call; # reap: opens individual reagent output file, collects results into a dictionary; if (db_mode.lower() == 'continuous'):; exec(banners); exec(p4util.format_molecule_for_input(GEOS[rgt])); exec(commands); #print 'MOLECULE LIVES %23s %8s %4d %4d %4s' % (rgt, psi4.get_global_option('REFERENCE'),; # molecule.molecular_charge(), molecule.multiplicity(), molecule.schoenflies_symbol()); psi4.set_variable('NATOM', molecule.natom()); psi4.set_variable('NUCLEAR REPULSION ENERGY', molecule.nuclear_repulsion_energy()); if re.match(r'^verify', lowername):; compare_values(DATA['NUCLEAR REPULSION ENERGY'][rgt], psi4.get_variable('NUCLEAR REPULSION ENERGY'),; 4, '%s %.4f' % (rgt, psi4.get_variable('NUCLEAR REPULSION ENERGY'))); ERGT[rgt] = 7.0; else:; ERGT[rgt] = call_function_in_1st_argument(func, **kwargs); #print ERGT[rgt]; psi4.print_variables(); exec(actives); for envv in db_tabulate:; VRGT[rgt][envv.upper()] = psi4.get_variable(envv); psi4.set_global_option(""REFERENCE"", user_reference); psi4.clean(). elif (db_mode.lower() == 'sow'):; freagent = open('%s.in' % (rgt), 'w'); freagent.write('# This is a psi4 input file auto-generated from the database() wrapper.\n\n'); freagent.write(banners); freagent.write(p4util.format_molecule_for_input(GEOS[rgt])). freagent.write(commands); freagent.write('''\npickle_kw = (""""""'''); pickle.dump(kwargs, freagent); freagent.write('''"""""")\n'''); freagent.write(""""""\nkwargs = pickle.loads(pickle_kw)\n""""""); freagent.write(""""""electronic_energy = %s(**kwargs)\n\n"""""" % (func.__name__)); freagent.write(""""""psi4.print_variable",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:44322,Energy Efficiency,ENERGY,ENERGY,44322,"ter_file_label + ('' if user_writer_file_label == '' else '-') + rgt). # all modes need to step through the reagents but all for different purposes; # continuous: defines necessary commands, executes energy(method) call, and collects results into dictionary; # sow: opens individual reagent input file, writes the necessary commands, and writes energy(method) call; # reap: opens individual reagent output file, collects results into a dictionary; if (db_mode.lower() == 'continuous'):; exec(banners); exec(p4util.format_molecule_for_input(GEOS[rgt])); exec(commands); #print 'MOLECULE LIVES %23s %8s %4d %4d %4s' % (rgt, psi4.get_global_option('REFERENCE'),; # molecule.molecular_charge(), molecule.multiplicity(), molecule.schoenflies_symbol()); psi4.set_variable('NATOM', molecule.natom()); psi4.set_variable('NUCLEAR REPULSION ENERGY', molecule.nuclear_repulsion_energy()); if re.match(r'^verify', lowername):; compare_values(DATA['NUCLEAR REPULSION ENERGY'][rgt], psi4.get_variable('NUCLEAR REPULSION ENERGY'),; 4, '%s %.4f' % (rgt, psi4.get_variable('NUCLEAR REPULSION ENERGY'))); ERGT[rgt] = 7.0; else:; ERGT[rgt] = call_function_in_1st_argument(func, **kwargs); #print ERGT[rgt]; psi4.print_variables(); exec(actives); for envv in db_tabulate:; VRGT[rgt][envv.upper()] = psi4.get_variable(envv); psi4.set_global_option(""REFERENCE"", user_reference); psi4.clean(). elif (db_mode.lower() == 'sow'):; freagent = open('%s.in' % (rgt), 'w'); freagent.write('# This is a psi4 input file auto-generated from the database() wrapper.\n\n'); freagent.write(banners); freagent.write(p4util.format_molecule_for_input(GEOS[rgt])). freagent.write(commands); freagent.write('''\npickle_kw = (""""""'''); pickle.dump(kwargs, freagent); freagent.write('''"""""")\n'''); freagent.write(""""""\nkwargs = pickle.loads(pickle_kw)\n""""""); freagent.write(""""""electronic_energy = %s(**kwargs)\n\n"""""" % (func.__name__)); freagent.write(""""""psi4.print_variables()\n""""""); freagent.write(""""""psi4.print_out('\\nDATABASE RESULT: comput",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:44391,Energy Efficiency,ENERGY,ENERGY,44391," all modes need to step through the reagents but all for different purposes; # continuous: defines necessary commands, executes energy(method) call, and collects results into dictionary; # sow: opens individual reagent input file, writes the necessary commands, and writes energy(method) call; # reap: opens individual reagent output file, collects results into a dictionary; if (db_mode.lower() == 'continuous'):; exec(banners); exec(p4util.format_molecule_for_input(GEOS[rgt])); exec(commands); #print 'MOLECULE LIVES %23s %8s %4d %4d %4s' % (rgt, psi4.get_global_option('REFERENCE'),; # molecule.molecular_charge(), molecule.multiplicity(), molecule.schoenflies_symbol()); psi4.set_variable('NATOM', molecule.natom()); psi4.set_variable('NUCLEAR REPULSION ENERGY', molecule.nuclear_repulsion_energy()); if re.match(r'^verify', lowername):; compare_values(DATA['NUCLEAR REPULSION ENERGY'][rgt], psi4.get_variable('NUCLEAR REPULSION ENERGY'),; 4, '%s %.4f' % (rgt, psi4.get_variable('NUCLEAR REPULSION ENERGY'))); ERGT[rgt] = 7.0; else:; ERGT[rgt] = call_function_in_1st_argument(func, **kwargs); #print ERGT[rgt]; psi4.print_variables(); exec(actives); for envv in db_tabulate:; VRGT[rgt][envv.upper()] = psi4.get_variable(envv); psi4.set_global_option(""REFERENCE"", user_reference); psi4.clean(). elif (db_mode.lower() == 'sow'):; freagent = open('%s.in' % (rgt), 'w'); freagent.write('# This is a psi4 input file auto-generated from the database() wrapper.\n\n'); freagent.write(banners); freagent.write(p4util.format_molecule_for_input(GEOS[rgt])). freagent.write(commands); freagent.write('''\npickle_kw = (""""""'''); pickle.dump(kwargs, freagent); freagent.write('''"""""")\n'''); freagent.write(""""""\nkwargs = pickle.loads(pickle_kw)\n""""""); freagent.write(""""""electronic_energy = %s(**kwargs)\n\n"""""" % (func.__name__)); freagent.write(""""""psi4.print_variables()\n""""""); freagent.write(""""""psi4.print_out('\\nDATABASE RESULT: computation %d for reagent %s """"""; % (os.getpid(), rgt)); freagent.write(""""""yi",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:45404,Energy Efficiency,energy,energy,45404,"Y'))); ERGT[rgt] = 7.0; else:; ERGT[rgt] = call_function_in_1st_argument(func, **kwargs); #print ERGT[rgt]; psi4.print_variables(); exec(actives); for envv in db_tabulate:; VRGT[rgt][envv.upper()] = psi4.get_variable(envv); psi4.set_global_option(""REFERENCE"", user_reference); psi4.clean(). elif (db_mode.lower() == 'sow'):; freagent = open('%s.in' % (rgt), 'w'); freagent.write('# This is a psi4 input file auto-generated from the database() wrapper.\n\n'); freagent.write(banners); freagent.write(p4util.format_molecule_for_input(GEOS[rgt])). freagent.write(commands); freagent.write('''\npickle_kw = (""""""'''); pickle.dump(kwargs, freagent); freagent.write('''"""""")\n'''); freagent.write(""""""\nkwargs = pickle.loads(pickle_kw)\n""""""); freagent.write(""""""electronic_energy = %s(**kwargs)\n\n"""""" % (func.__name__)); freagent.write(""""""psi4.print_variables()\n""""""); freagent.write(""""""psi4.print_out('\\nDATABASE RESULT: computation %d for reagent %s """"""; % (os.getpid(), rgt)); freagent.write(""""""yields electronic energy %20.12f\\n' % (electronic_energy))\n\n""""""); freagent.write(""""""psi4.set_variable('NATOM', molecule.natom())\n""""""); for envv in db_tabulate:; freagent.write(""""""psi4.print_out('DATABASE RESULT: computation %d for reagent %s """"""; % (os.getpid(), rgt)); freagent.write(""""""yields variable value %20.12f for variable %s\\n' % (psi4.get_variable(""""""); freagent.write(""""""'%s'), '%s'))\n"""""" % (envv.upper(), envv.upper())); freagent.close(). elif (db_mode.lower() == 'reap'):; ERGT[rgt] = 0.0; for envv in db_tabulate:; VRGT[rgt][envv.upper()] = 0.0; exec(banners); exec(actives); try:; freagent = open('%s.out' % (rgt), 'r'); except IOError:; psi4.print_out('Warning: Output file \'%s.out\' not found.\n' % (rgt)); psi4.print_out(' Database summary will have 0.0 and **** in its place.\n'); else:; while 1:; line = freagent.readline(); if not line:; if ERGT[rgt] == 0.0:; psi4.print_out('Warning: Output file \'%s.out\' has no DATABASE RESULT line.\n' % (rgt)); psi4.print_out(' Database summar",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:46883,Energy Efficiency,energy,energy,46883," ERGT[rgt] = 0.0; for envv in db_tabulate:; VRGT[rgt][envv.upper()] = 0.0; exec(banners); exec(actives); try:; freagent = open('%s.out' % (rgt), 'r'); except IOError:; psi4.print_out('Warning: Output file \'%s.out\' not found.\n' % (rgt)); psi4.print_out(' Database summary will have 0.0 and **** in its place.\n'); else:; while 1:; line = freagent.readline(); if not line:; if ERGT[rgt] == 0.0:; psi4.print_out('Warning: Output file \'%s.out\' has no DATABASE RESULT line.\n' % (rgt)); psi4.print_out(' Database summary will have 0.0 and **** in its place.\n'); break; s = line.split(); if (len(s) != 0) and (s[0:3] == ['DATABASE', 'RESULT:', 'computation']):; if int(s[3]) != db_linkage:; raise ValidationError('Output file \'%s.out\' has linkage %s incompatible with master.in linkage %s.'; % (rgt, str(s[3]), str(db_linkage))); if s[6] != rgt:; raise ValidationError('Output file \'%s.out\' has nominal affiliation %s incompatible with reagent %s.'; % (rgt, s[6], rgt)); if (s[8:10] == ['electronic', 'energy']):; ERGT[rgt] = float(s[10]); psi4.print_out('DATABASE RESULT: electronic energy = %20.12f\n' % (ERGT[rgt])); elif (s[8:10] == ['variable', 'value']):; for envv in db_tabulate:; envv = envv.upper(); if (s[13:] == envv.split()):; VRGT[rgt][envv] = float(s[10]); psi4.print_out('DATABASE RESULT: variable %s value = %20.12f\n' % (envv, VRGT[rgt][envv])); freagent.close(). # end sow after writing files; if (db_mode.lower() == 'sow'):; return 0.0. # Reap all the necessary reaction computations; psi4.print_out(""\n""); p4util.banner((""Database %s Results"" % (db_name))); psi4.print_out(""\n""). maxactv = []; for rxn in HRXN:; maxactv.append(len(ACTV[dbse + '-' + str(rxn)])); maxrgt = max(maxactv); table_delimit = '-' * (54 + 20 * maxrgt); tables = ''. # find any reactions that are incomplete; FAIL = collections.defaultdict(int); for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn); for i in range(len(ACTV[db_rxn])):; if abs(ERGT[ACTV[db_rxn][i]]) < 1.0e-12:; FAIL[rxn] = 1. # tabulate req",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:46965,Energy Efficiency,energy,energy,46965,"exec(banners); exec(actives); try:; freagent = open('%s.out' % (rgt), 'r'); except IOError:; psi4.print_out('Warning: Output file \'%s.out\' not found.\n' % (rgt)); psi4.print_out(' Database summary will have 0.0 and **** in its place.\n'); else:; while 1:; line = freagent.readline(); if not line:; if ERGT[rgt] == 0.0:; psi4.print_out('Warning: Output file \'%s.out\' has no DATABASE RESULT line.\n' % (rgt)); psi4.print_out(' Database summary will have 0.0 and **** in its place.\n'); break; s = line.split(); if (len(s) != 0) and (s[0:3] == ['DATABASE', 'RESULT:', 'computation']):; if int(s[3]) != db_linkage:; raise ValidationError('Output file \'%s.out\' has linkage %s incompatible with master.in linkage %s.'; % (rgt, str(s[3]), str(db_linkage))); if s[6] != rgt:; raise ValidationError('Output file \'%s.out\' has nominal affiliation %s incompatible with reagent %s.'; % (rgt, s[6], rgt)); if (s[8:10] == ['electronic', 'energy']):; ERGT[rgt] = float(s[10]); psi4.print_out('DATABASE RESULT: electronic energy = %20.12f\n' % (ERGT[rgt])); elif (s[8:10] == ['variable', 'value']):; for envv in db_tabulate:; envv = envv.upper(); if (s[13:] == envv.split()):; VRGT[rgt][envv] = float(s[10]); psi4.print_out('DATABASE RESULT: variable %s value = %20.12f\n' % (envv, VRGT[rgt][envv])); freagent.close(). # end sow after writing files; if (db_mode.lower() == 'sow'):; return 0.0. # Reap all the necessary reaction computations; psi4.print_out(""\n""); p4util.banner((""Database %s Results"" % (db_name))); psi4.print_out(""\n""). maxactv = []; for rxn in HRXN:; maxactv.append(len(ACTV[dbse + '-' + str(rxn)])); maxrgt = max(maxactv); table_delimit = '-' * (54 + 20 * maxrgt); tables = ''. # find any reactions that are incomplete; FAIL = collections.defaultdict(int); for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn); for i in range(len(ACTV[db_rxn])):; if abs(ERGT[ACTV[db_rxn][i]]) < 1.0e-12:; FAIL[rxn] = 1. # tabulate requested process::environment variables; tables += """""" For each VARIABLE requ",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:48098,Energy Efficiency,ENERGY,ENERGY,48098," (ERGT[rgt])); elif (s[8:10] == ['variable', 'value']):; for envv in db_tabulate:; envv = envv.upper(); if (s[13:] == envv.split()):; VRGT[rgt][envv] = float(s[10]); psi4.print_out('DATABASE RESULT: variable %s value = %20.12f\n' % (envv, VRGT[rgt][envv])); freagent.close(). # end sow after writing files; if (db_mode.lower() == 'sow'):; return 0.0. # Reap all the necessary reaction computations; psi4.print_out(""\n""); p4util.banner((""Database %s Results"" % (db_name))); psi4.print_out(""\n""). maxactv = []; for rxn in HRXN:; maxactv.append(len(ACTV[dbse + '-' + str(rxn)])); maxrgt = max(maxactv); table_delimit = '-' * (54 + 20 * maxrgt); tables = ''. # find any reactions that are incomplete; FAIL = collections.defaultdict(int); for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn); for i in range(len(ACTV[db_rxn])):; if abs(ERGT[ACTV[db_rxn][i]]) < 1.0e-12:; FAIL[rxn] = 1. # tabulate requested process::environment variables; tables += """""" For each VARIABLE requested by tabulate, a 'Reaction Value' will be formed from\n""""""; tables += """""" 'Reagent' values according to weightings 'Wt', as for the REQUESTED ENERGY below.\n""""""; tables += """""" Depending on the nature of the variable, this may or may not make any physical sense.\n""""""; for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn); VRXN[db_rxn] = {}. for envv in db_tabulate:; envv = envv.upper(); tables += """"""\n ==> %s <==\n\n"""""" % (envv.title()); tables += tblhead(maxrgt, table_delimit, 2). for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn). if FAIL[rxn]:; tables += """"""\n%23s %8s %8s %8s"""""" % (db_rxn, '', '****', ''); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (VRGT[ACTV[db_rxn][i]][envv], RXNM[db_rxn][ACTV[db_rxn][i]]). else:; VRXN[db_rxn][envv] = 0.0; for i in range(len(ACTV[db_rxn])):; VRXN[db_rxn][envv] += VRGT[ACTV[db_rxn][i]][envv] * RXNM[db_rxn][ACTV[db_rxn][i]]. tables += """"""\n%23s %16.8f """""" % (db_rxn, VRXN[db_rxn][envv]); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (VRGT[ACT",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:49112,Energy Efficiency,energy,energy,49112,""" Depending on the nature of the variable, this may or may not make any physical sense.\n""""""; for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn); VRXN[db_rxn] = {}. for envv in db_tabulate:; envv = envv.upper(); tables += """"""\n ==> %s <==\n\n"""""" % (envv.title()); tables += tblhead(maxrgt, table_delimit, 2). for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn). if FAIL[rxn]:; tables += """"""\n%23s %8s %8s %8s"""""" % (db_rxn, '', '****', ''); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (VRGT[ACTV[db_rxn][i]][envv], RXNM[db_rxn][ACTV[db_rxn][i]]). else:; VRXN[db_rxn][envv] = 0.0; for i in range(len(ACTV[db_rxn])):; VRXN[db_rxn][envv] += VRGT[ACTV[db_rxn][i]][envv] * RXNM[db_rxn][ACTV[db_rxn][i]]. tables += """"""\n%23s %16.8f """""" % (db_rxn, VRXN[db_rxn][envv]); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (VRGT[ACTV[db_rxn][i]][envv], RXNM[db_rxn][ACTV[db_rxn][i]]); tables += """"""\n %s\n"""""" % (table_delimit). # tabulate primary requested energy variable with statistics; count_rxn = 0; minDerror = 100000.0; maxDerror = 0.0; MSDerror = 0.0; MADerror = 0.0; RMSDerror = 0.0. tables += """"""\n ==> %s <==\n\n"""""" % ('Requested Energy'); tables += tblhead(maxrgt, table_delimit, 1); for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn). if FAIL[rxn]:; tables += """"""\n%23s %8.4f %8s %8s"""""" % (db_rxn, BIND[db_rxn], '****', '****'); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (ERGT[ACTV[db_rxn][i]], RXNM[db_rxn][ACTV[db_rxn][i]]). else:; ERXN[db_rxn] = 0.0; for i in range(len(ACTV[db_rxn])):; ERXN[db_rxn] += ERGT[ACTV[db_rxn][i]] * RXNM[db_rxn][ACTV[db_rxn][i]]; error = p4const.psi_hartree2kcalmol * ERXN[db_rxn] - BIND[db_rxn]. tables += """"""\n%23s %8.4f %8.4f %8.4f"""""" % (db_rxn, BIND[db_rxn], p4const.psi_hartree2kcalmol * ERXN[db_rxn], error); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (ERGT[ACTV[db_rxn][i]], RXNM[db_rxn][ACTV[db_rxn][i]]). if abs(error) < abs(minDerror):; minDerror = error; if abs(error) > a",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:49296,Energy Efficiency,Energy,Energy,49296," = envv.upper(); tables += """"""\n ==> %s <==\n\n"""""" % (envv.title()); tables += tblhead(maxrgt, table_delimit, 2). for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn). if FAIL[rxn]:; tables += """"""\n%23s %8s %8s %8s"""""" % (db_rxn, '', '****', ''); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (VRGT[ACTV[db_rxn][i]][envv], RXNM[db_rxn][ACTV[db_rxn][i]]). else:; VRXN[db_rxn][envv] = 0.0; for i in range(len(ACTV[db_rxn])):; VRXN[db_rxn][envv] += VRGT[ACTV[db_rxn][i]][envv] * RXNM[db_rxn][ACTV[db_rxn][i]]. tables += """"""\n%23s %16.8f """""" % (db_rxn, VRXN[db_rxn][envv]); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (VRGT[ACTV[db_rxn][i]][envv], RXNM[db_rxn][ACTV[db_rxn][i]]); tables += """"""\n %s\n"""""" % (table_delimit). # tabulate primary requested energy variable with statistics; count_rxn = 0; minDerror = 100000.0; maxDerror = 0.0; MSDerror = 0.0; MADerror = 0.0; RMSDerror = 0.0. tables += """"""\n ==> %s <==\n\n"""""" % ('Requested Energy'); tables += tblhead(maxrgt, table_delimit, 1); for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn). if FAIL[rxn]:; tables += """"""\n%23s %8.4f %8s %8s"""""" % (db_rxn, BIND[db_rxn], '****', '****'); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (ERGT[ACTV[db_rxn][i]], RXNM[db_rxn][ACTV[db_rxn][i]]). else:; ERXN[db_rxn] = 0.0; for i in range(len(ACTV[db_rxn])):; ERXN[db_rxn] += ERGT[ACTV[db_rxn][i]] * RXNM[db_rxn][ACTV[db_rxn][i]]; error = p4const.psi_hartree2kcalmol * ERXN[db_rxn] - BIND[db_rxn]. tables += """"""\n%23s %8.4f %8.4f %8.4f"""""" % (db_rxn, BIND[db_rxn], p4const.psi_hartree2kcalmol * ERXN[db_rxn], error); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (ERGT[ACTV[db_rxn][i]], RXNM[db_rxn][ACTV[db_rxn][i]]). if abs(error) < abs(minDerror):; minDerror = error; if abs(error) > abs(maxDerror):; maxDerror = error; MSDerror += error; MADerror += abs(error); RMSDerror += error * error; count_rxn += 1; tables += """"""\n %s\n"""""" % (table_delimit). if count_rxn:. MSDerror /= f",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:52117,Energy Efficiency,Energy,Energy,52117," user_reference); if not b_user_reference:; psi4.revoke_global_option_changed('REFERENCE'); psi4.set_global_option('WRITER_FILE_LABEL', user_writer_file_label). DB_RGT.clear(); DB_RGT.update(VRGT); DB_RXN.clear(); DB_RXN.update(VRXN); return finalenergy. [docs]def tblhead(tbl_maxrgt, tbl_delimit, ttype):; r""""""Function that prints the header for the changable-width results tables in db().; *tbl_maxrgt* is the number of reagent columns the table must plan for. *tbl_delimit*; is a string of dashes of the correct length to set off the table. *ttype* is 1 for; tables comparing the computed values to the reference or 2 for simple tabulation; and sum of the computed values. """"""; tbl_str = ''; tbl_str += """""" %s"""""" % (tbl_delimit); if ttype == 1:; tbl_str += """"""\n%23s %19s %8s"""""" % ('Reaction', 'Reaction Energy', 'Error'); elif ttype == 2:; tbl_str += """"""\n%23s %19s %6s"""""" % ('Reaction', 'Reaction Value', ''); for i in range(tbl_maxrgt):; tbl_str += """"""%20s"""""" % ('Reagent ' + str(i + 1)); if ttype == 1:; tbl_str += """"""\n%23s %8s %8s %8s"""""" % ('', 'Ref', 'Calc', '[kcal/mol]'); elif ttype == 2:; tbl_str += """"""\n%54s"""""" % (''); for i in range(tbl_maxrgt):; if ttype == 1:; tbl_str += """"""%20s"""""" % ('[H] Wt'); elif ttype == 2:; tbl_str += """"""%20s"""""" % ('Value Wt'); tbl_str += """"""\n %s"""""" % (tbl_delimit); return tbl_str. ## Aliases ##; db = database. #######################; ## End of Database ##; #######################. ###################################; ## Start of Complete Basis Set ##; ###################################. [docs]def complete_basis_set(name, **kwargs):; r""""""Function to define a multistage energy method from combinations of; basis set extrapolations and delta corrections and condense the; components into a minimum number of calculations. :aliases: cbs(). :returns: (*float*) -- Total electronic energy in Hartrees. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CBS TOTAL ENERGY <CBSTOTALENERGY>`; * :psivar:`CBS REFERENCE ENERGY <CBSREFERENCEENERGY>`; * :psiv",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:52932,Energy Efficiency,energy,energy,52932,"the computed values. """"""; tbl_str = ''; tbl_str += """""" %s"""""" % (tbl_delimit); if ttype == 1:; tbl_str += """"""\n%23s %19s %8s"""""" % ('Reaction', 'Reaction Energy', 'Error'); elif ttype == 2:; tbl_str += """"""\n%23s %19s %6s"""""" % ('Reaction', 'Reaction Value', ''); for i in range(tbl_maxrgt):; tbl_str += """"""%20s"""""" % ('Reagent ' + str(i + 1)); if ttype == 1:; tbl_str += """"""\n%23s %8s %8s %8s"""""" % ('', 'Ref', 'Calc', '[kcal/mol]'); elif ttype == 2:; tbl_str += """"""\n%54s"""""" % (''); for i in range(tbl_maxrgt):; if ttype == 1:; tbl_str += """"""%20s"""""" % ('[H] Wt'); elif ttype == 2:; tbl_str += """"""%20s"""""" % ('Value Wt'); tbl_str += """"""\n %s"""""" % (tbl_delimit); return tbl_str. ## Aliases ##; db = database. #######################; ## End of Database ##; #######################. ###################################; ## Start of Complete Basis Set ##; ###################################. [docs]def complete_basis_set(name, **kwargs):; r""""""Function to define a multistage energy method from combinations of; basis set extrapolations and delta corrections and condense the; components into a minimum number of calculations. :aliases: cbs(). :returns: (*float*) -- Total electronic energy in Hartrees. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CBS TOTAL ENERGY <CBSTOTALENERGY>`; * :psivar:`CBS REFERENCE ENERGY <CBSREFERENCEENERGY>`; * :psivar:`CBS CORRELATION ENERGY <CBSCORRELATIONENERGY>`; * :psivar:`CURRENT ENERGY <CURRENTENERGY>`; * :psivar:`CURRENT REFERENCE ENERGY <CURRENTREFERENCEENERGY>`; * :psivar:`CURRENT CORRELATION ENERGY <CURRENTCORRELATIONENERGY>`. .. caution:: Some features are not yet implemented. Buy a developer a coffee. - Not all methods hooked in through PSI variables, configuration interaction and arbitrary order MP in particular. - No scheme defaults for given basis zeta number, so scheme must be specified explicitly. - No way to tell function to boost fitting basis size for all calculations. - No way to extrapolate def2 family basis sets. - Need to add more ex",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:53140,Energy Efficiency,energy,energy,53140,"ror'); elif ttype == 2:; tbl_str += """"""\n%23s %19s %6s"""""" % ('Reaction', 'Reaction Value', ''); for i in range(tbl_maxrgt):; tbl_str += """"""%20s"""""" % ('Reagent ' + str(i + 1)); if ttype == 1:; tbl_str += """"""\n%23s %8s %8s %8s"""""" % ('', 'Ref', 'Calc', '[kcal/mol]'); elif ttype == 2:; tbl_str += """"""\n%54s"""""" % (''); for i in range(tbl_maxrgt):; if ttype == 1:; tbl_str += """"""%20s"""""" % ('[H] Wt'); elif ttype == 2:; tbl_str += """"""%20s"""""" % ('Value Wt'); tbl_str += """"""\n %s"""""" % (tbl_delimit); return tbl_str. ## Aliases ##; db = database. #######################; ## End of Database ##; #######################. ###################################; ## Start of Complete Basis Set ##; ###################################. [docs]def complete_basis_set(name, **kwargs):; r""""""Function to define a multistage energy method from combinations of; basis set extrapolations and delta corrections and condense the; components into a minimum number of calculations. :aliases: cbs(). :returns: (*float*) -- Total electronic energy in Hartrees. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CBS TOTAL ENERGY <CBSTOTALENERGY>`; * :psivar:`CBS REFERENCE ENERGY <CBSREFERENCEENERGY>`; * :psivar:`CBS CORRELATION ENERGY <CBSCORRELATIONENERGY>`; * :psivar:`CURRENT ENERGY <CURRENTENERGY>`; * :psivar:`CURRENT REFERENCE ENERGY <CURRENTREFERENCEENERGY>`; * :psivar:`CURRENT CORRELATION ENERGY <CURRENTCORRELATIONENERGY>`. .. caution:: Some features are not yet implemented. Buy a developer a coffee. - Not all methods hooked in through PSI variables, configuration interaction and arbitrary order MP in particular. - No scheme defaults for given basis zeta number, so scheme must be specified explicitly. - No way to tell function to boost fitting basis size for all calculations. - No way to extrapolate def2 family basis sets. - Need to add more extrapolation schemes. As represented in the equation below, a CBS energy method is defined in several; sequential stages (scf, corl, delta, delta2, delta3, delta4, d",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:53223,Energy Efficiency,ENERGY,ENERGY,53223,"', 'Calc', '[kcal/mol]'); elif ttype == 2:; tbl_str += """"""\n%54s"""""" % (''); for i in range(tbl_maxrgt):; if ttype == 1:; tbl_str += """"""%20s"""""" % ('[H] Wt'); elif ttype == 2:; tbl_str += """"""%20s"""""" % ('Value Wt'); tbl_str += """"""\n %s"""""" % (tbl_delimit); return tbl_str. ## Aliases ##; db = database. #######################; ## End of Database ##; #######################. ###################################; ## Start of Complete Basis Set ##; ###################################. [docs]def complete_basis_set(name, **kwargs):; r""""""Function to define a multistage energy method from combinations of; basis set extrapolations and delta corrections and condense the; components into a minimum number of calculations. :aliases: cbs(). :returns: (*float*) -- Total electronic energy in Hartrees. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CBS TOTAL ENERGY <CBSTOTALENERGY>`; * :psivar:`CBS REFERENCE ENERGY <CBSREFERENCEENERGY>`; * :psivar:`CBS CORRELATION ENERGY <CBSCORRELATIONENERGY>`; * :psivar:`CURRENT ENERGY <CURRENTENERGY>`; * :psivar:`CURRENT REFERENCE ENERGY <CURRENTREFERENCEENERGY>`; * :psivar:`CURRENT CORRELATION ENERGY <CURRENTCORRELATIONENERGY>`. .. caution:: Some features are not yet implemented. Buy a developer a coffee. - Not all methods hooked in through PSI variables, configuration interaction and arbitrary order MP in particular. - No scheme defaults for given basis zeta number, so scheme must be specified explicitly. - No way to tell function to boost fitting basis size for all calculations. - No way to extrapolate def2 family basis sets. - Need to add more extrapolation schemes. As represented in the equation below, a CBS energy method is defined in several; sequential stages (scf, corl, delta, delta2, delta3, delta4, delta5) covering treatment; of the reference total energy, the correlation energy, a delta correction to the; correlation energy, and a second delta correction, etc.. Each is activated by its; stage_wfn keyword and is only allowed if all pre",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:53274,Energy Efficiency,ENERGY,ENERGY,53274,"', 'Calc', '[kcal/mol]'); elif ttype == 2:; tbl_str += """"""\n%54s"""""" % (''); for i in range(tbl_maxrgt):; if ttype == 1:; tbl_str += """"""%20s"""""" % ('[H] Wt'); elif ttype == 2:; tbl_str += """"""%20s"""""" % ('Value Wt'); tbl_str += """"""\n %s"""""" % (tbl_delimit); return tbl_str. ## Aliases ##; db = database. #######################; ## End of Database ##; #######################. ###################################; ## Start of Complete Basis Set ##; ###################################. [docs]def complete_basis_set(name, **kwargs):; r""""""Function to define a multistage energy method from combinations of; basis set extrapolations and delta corrections and condense the; components into a minimum number of calculations. :aliases: cbs(). :returns: (*float*) -- Total electronic energy in Hartrees. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CBS TOTAL ENERGY <CBSTOTALENERGY>`; * :psivar:`CBS REFERENCE ENERGY <CBSREFERENCEENERGY>`; * :psivar:`CBS CORRELATION ENERGY <CBSCORRELATIONENERGY>`; * :psivar:`CURRENT ENERGY <CURRENTENERGY>`; * :psivar:`CURRENT REFERENCE ENERGY <CURRENTREFERENCEENERGY>`; * :psivar:`CURRENT CORRELATION ENERGY <CURRENTCORRELATIONENERGY>`. .. caution:: Some features are not yet implemented. Buy a developer a coffee. - Not all methods hooked in through PSI variables, configuration interaction and arbitrary order MP in particular. - No scheme defaults for given basis zeta number, so scheme must be specified explicitly. - No way to tell function to boost fitting basis size for all calculations. - No way to extrapolate def2 family basis sets. - Need to add more extrapolation schemes. As represented in the equation below, a CBS energy method is defined in several; sequential stages (scf, corl, delta, delta2, delta3, delta4, delta5) covering treatment; of the reference total energy, the correlation energy, a delta correction to the; correlation energy, and a second delta correction, etc.. Each is activated by its; stage_wfn keyword and is only allowed if all pre",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:53331,Energy Efficiency,ENERGY,ENERGY,53331,"', 'Calc', '[kcal/mol]'); elif ttype == 2:; tbl_str += """"""\n%54s"""""" % (''); for i in range(tbl_maxrgt):; if ttype == 1:; tbl_str += """"""%20s"""""" % ('[H] Wt'); elif ttype == 2:; tbl_str += """"""%20s"""""" % ('Value Wt'); tbl_str += """"""\n %s"""""" % (tbl_delimit); return tbl_str. ## Aliases ##; db = database. #######################; ## End of Database ##; #######################. ###################################; ## Start of Complete Basis Set ##; ###################################. [docs]def complete_basis_set(name, **kwargs):; r""""""Function to define a multistage energy method from combinations of; basis set extrapolations and delta corrections and condense the; components into a minimum number of calculations. :aliases: cbs(). :returns: (*float*) -- Total electronic energy in Hartrees. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CBS TOTAL ENERGY <CBSTOTALENERGY>`; * :psivar:`CBS REFERENCE ENERGY <CBSREFERENCEENERGY>`; * :psivar:`CBS CORRELATION ENERGY <CBSCORRELATIONENERGY>`; * :psivar:`CURRENT ENERGY <CURRENTENERGY>`; * :psivar:`CURRENT REFERENCE ENERGY <CURRENTREFERENCEENERGY>`; * :psivar:`CURRENT CORRELATION ENERGY <CURRENTCORRELATIONENERGY>`. .. caution:: Some features are not yet implemented. Buy a developer a coffee. - Not all methods hooked in through PSI variables, configuration interaction and arbitrary order MP in particular. - No scheme defaults for given basis zeta number, so scheme must be specified explicitly. - No way to tell function to boost fitting basis size for all calculations. - No way to extrapolate def2 family basis sets. - Need to add more extrapolation schemes. As represented in the equation below, a CBS energy method is defined in several; sequential stages (scf, corl, delta, delta2, delta3, delta4, delta5) covering treatment; of the reference total energy, the correlation energy, a delta correction to the; correlation energy, and a second delta correction, etc.. Each is activated by its; stage_wfn keyword and is only allowed if all pre",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:53382,Energy Efficiency,ENERGY,ENERGY,53382,"', 'Calc', '[kcal/mol]'); elif ttype == 2:; tbl_str += """"""\n%54s"""""" % (''); for i in range(tbl_maxrgt):; if ttype == 1:; tbl_str += """"""%20s"""""" % ('[H] Wt'); elif ttype == 2:; tbl_str += """"""%20s"""""" % ('Value Wt'); tbl_str += """"""\n %s"""""" % (tbl_delimit); return tbl_str. ## Aliases ##; db = database. #######################; ## End of Database ##; #######################. ###################################; ## Start of Complete Basis Set ##; ###################################. [docs]def complete_basis_set(name, **kwargs):; r""""""Function to define a multistage energy method from combinations of; basis set extrapolations and delta corrections and condense the; components into a minimum number of calculations. :aliases: cbs(). :returns: (*float*) -- Total electronic energy in Hartrees. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CBS TOTAL ENERGY <CBSTOTALENERGY>`; * :psivar:`CBS REFERENCE ENERGY <CBSREFERENCEENERGY>`; * :psivar:`CBS CORRELATION ENERGY <CBSCORRELATIONENERGY>`; * :psivar:`CURRENT ENERGY <CURRENTENERGY>`; * :psivar:`CURRENT REFERENCE ENERGY <CURRENTREFERENCEENERGY>`; * :psivar:`CURRENT CORRELATION ENERGY <CURRENTCORRELATIONENERGY>`. .. caution:: Some features are not yet implemented. Buy a developer a coffee. - Not all methods hooked in through PSI variables, configuration interaction and arbitrary order MP in particular. - No scheme defaults for given basis zeta number, so scheme must be specified explicitly. - No way to tell function to boost fitting basis size for all calculations. - No way to extrapolate def2 family basis sets. - Need to add more extrapolation schemes. As represented in the equation below, a CBS energy method is defined in several; sequential stages (scf, corl, delta, delta2, delta3, delta4, delta5) covering treatment; of the reference total energy, the correlation energy, a delta correction to the; correlation energy, and a second delta correction, etc.. Each is activated by its; stage_wfn keyword and is only allowed if all pre",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:53436,Energy Efficiency,ENERGY,ENERGY,53436,"', 'Calc', '[kcal/mol]'); elif ttype == 2:; tbl_str += """"""\n%54s"""""" % (''); for i in range(tbl_maxrgt):; if ttype == 1:; tbl_str += """"""%20s"""""" % ('[H] Wt'); elif ttype == 2:; tbl_str += """"""%20s"""""" % ('Value Wt'); tbl_str += """"""\n %s"""""" % (tbl_delimit); return tbl_str. ## Aliases ##; db = database. #######################; ## End of Database ##; #######################. ###################################; ## Start of Complete Basis Set ##; ###################################. [docs]def complete_basis_set(name, **kwargs):; r""""""Function to define a multistage energy method from combinations of; basis set extrapolations and delta corrections and condense the; components into a minimum number of calculations. :aliases: cbs(). :returns: (*float*) -- Total electronic energy in Hartrees. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CBS TOTAL ENERGY <CBSTOTALENERGY>`; * :psivar:`CBS REFERENCE ENERGY <CBSREFERENCEENERGY>`; * :psivar:`CBS CORRELATION ENERGY <CBSCORRELATIONENERGY>`; * :psivar:`CURRENT ENERGY <CURRENTENERGY>`; * :psivar:`CURRENT REFERENCE ENERGY <CURRENTREFERENCEENERGY>`; * :psivar:`CURRENT CORRELATION ENERGY <CURRENTCORRELATIONENERGY>`. .. caution:: Some features are not yet implemented. Buy a developer a coffee. - Not all methods hooked in through PSI variables, configuration interaction and arbitrary order MP in particular. - No scheme defaults for given basis zeta number, so scheme must be specified explicitly. - No way to tell function to boost fitting basis size for all calculations. - No way to extrapolate def2 family basis sets. - Need to add more extrapolation schemes. As represented in the equation below, a CBS energy method is defined in several; sequential stages (scf, corl, delta, delta2, delta3, delta4, delta5) covering treatment; of the reference total energy, the correlation energy, a delta correction to the; correlation energy, and a second delta correction, etc.. Each is activated by its; stage_wfn keyword and is only allowed if all pre",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:53501,Energy Efficiency,ENERGY,ENERGY,53501,"', 'Calc', '[kcal/mol]'); elif ttype == 2:; tbl_str += """"""\n%54s"""""" % (''); for i in range(tbl_maxrgt):; if ttype == 1:; tbl_str += """"""%20s"""""" % ('[H] Wt'); elif ttype == 2:; tbl_str += """"""%20s"""""" % ('Value Wt'); tbl_str += """"""\n %s"""""" % (tbl_delimit); return tbl_str. ## Aliases ##; db = database. #######################; ## End of Database ##; #######################. ###################################; ## Start of Complete Basis Set ##; ###################################. [docs]def complete_basis_set(name, **kwargs):; r""""""Function to define a multistage energy method from combinations of; basis set extrapolations and delta corrections and condense the; components into a minimum number of calculations. :aliases: cbs(). :returns: (*float*) -- Total electronic energy in Hartrees. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CBS TOTAL ENERGY <CBSTOTALENERGY>`; * :psivar:`CBS REFERENCE ENERGY <CBSREFERENCEENERGY>`; * :psivar:`CBS CORRELATION ENERGY <CBSCORRELATIONENERGY>`; * :psivar:`CURRENT ENERGY <CURRENTENERGY>`; * :psivar:`CURRENT REFERENCE ENERGY <CURRENTREFERENCEENERGY>`; * :psivar:`CURRENT CORRELATION ENERGY <CURRENTCORRELATIONENERGY>`. .. caution:: Some features are not yet implemented. Buy a developer a coffee. - Not all methods hooked in through PSI variables, configuration interaction and arbitrary order MP in particular. - No scheme defaults for given basis zeta number, so scheme must be specified explicitly. - No way to tell function to boost fitting basis size for all calculations. - No way to extrapolate def2 family basis sets. - Need to add more extrapolation schemes. As represented in the equation below, a CBS energy method is defined in several; sequential stages (scf, corl, delta, delta2, delta3, delta4, delta5) covering treatment; of the reference total energy, the correlation energy, a delta correction to the; correlation energy, and a second delta correction, etc.. Each is activated by its; stage_wfn keyword and is only allowed if all pre",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:54030,Energy Efficiency,energy,energy,54030," energy in Hartrees. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CBS TOTAL ENERGY <CBSTOTALENERGY>`; * :psivar:`CBS REFERENCE ENERGY <CBSREFERENCEENERGY>`; * :psivar:`CBS CORRELATION ENERGY <CBSCORRELATIONENERGY>`; * :psivar:`CURRENT ENERGY <CURRENTENERGY>`; * :psivar:`CURRENT REFERENCE ENERGY <CURRENTREFERENCEENERGY>`; * :psivar:`CURRENT CORRELATION ENERGY <CURRENTCORRELATIONENERGY>`. .. caution:: Some features are not yet implemented. Buy a developer a coffee. - Not all methods hooked in through PSI variables, configuration interaction and arbitrary order MP in particular. - No scheme defaults for given basis zeta number, so scheme must be specified explicitly. - No way to tell function to boost fitting basis size for all calculations. - No way to extrapolate def2 family basis sets. - Need to add more extrapolation schemes. As represented in the equation below, a CBS energy method is defined in several; sequential stages (scf, corl, delta, delta2, delta3, delta4, delta5) covering treatment; of the reference total energy, the correlation energy, a delta correction to the; correlation energy, and a second delta correction, etc.. Each is activated by its; stage_wfn keyword and is only allowed if all preceding stages are active. .. include:: cbs_eqn.rst. * Energy Methods; The presence of a stage_wfn keyword is the indicator to incorporate; (and check for stage_basis and stage_scheme keywords) and compute; that stage in defining the CBS energy. The cbs() function requires, at a minimum, ``name='scf'`` and ``scf_basis``; keywords to be specified for reference-step only jobs and ``name`` and; ``corl_basis`` keywords for correlated jobs. The following energy methods have been set up for cbs(). .. hlist::; :columns: 5. * scf; * mp2; * mp2.5; * mp3; * mp4(sdq); * mp4; * omp2; * omp3; * ocepa; * cepa0; * cepa(0); * cepa(1); * cepa(3); * acpf; * aqcc; * qcisd; * cc2; * ccsd; * fno-df-ccsd; * bccd; * cc3; * qcisd(t); * ccsd(t); * fno-df-ccsd(t); * bccd(t); * cisd; * c",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:54179,Energy Efficiency,energy,energy,54179," energy in Hartrees. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CBS TOTAL ENERGY <CBSTOTALENERGY>`; * :psivar:`CBS REFERENCE ENERGY <CBSREFERENCEENERGY>`; * :psivar:`CBS CORRELATION ENERGY <CBSCORRELATIONENERGY>`; * :psivar:`CURRENT ENERGY <CURRENTENERGY>`; * :psivar:`CURRENT REFERENCE ENERGY <CURRENTREFERENCEENERGY>`; * :psivar:`CURRENT CORRELATION ENERGY <CURRENTCORRELATIONENERGY>`. .. caution:: Some features are not yet implemented. Buy a developer a coffee. - Not all methods hooked in through PSI variables, configuration interaction and arbitrary order MP in particular. - No scheme defaults for given basis zeta number, so scheme must be specified explicitly. - No way to tell function to boost fitting basis size for all calculations. - No way to extrapolate def2 family basis sets. - Need to add more extrapolation schemes. As represented in the equation below, a CBS energy method is defined in several; sequential stages (scf, corl, delta, delta2, delta3, delta4, delta5) covering treatment; of the reference total energy, the correlation energy, a delta correction to the; correlation energy, and a second delta correction, etc.. Each is activated by its; stage_wfn keyword and is only allowed if all preceding stages are active. .. include:: cbs_eqn.rst. * Energy Methods; The presence of a stage_wfn keyword is the indicator to incorporate; (and check for stage_basis and stage_scheme keywords) and compute; that stage in defining the CBS energy. The cbs() function requires, at a minimum, ``name='scf'`` and ``scf_basis``; keywords to be specified for reference-step only jobs and ``name`` and; ``corl_basis`` keywords for correlated jobs. The following energy methods have been set up for cbs(). .. hlist::; :columns: 5. * scf; * mp2; * mp2.5; * mp3; * mp4(sdq); * mp4; * omp2; * omp3; * ocepa; * cepa0; * cepa(0); * cepa(1); * cepa(3); * acpf; * aqcc; * qcisd; * cc2; * ccsd; * fno-df-ccsd; * bccd; * cc3; * qcisd(t); * ccsd(t); * fno-df-ccsd(t); * bccd(t); * cisd; * c",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:54203,Energy Efficiency,energy,energy,54203," energy in Hartrees. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CBS TOTAL ENERGY <CBSTOTALENERGY>`; * :psivar:`CBS REFERENCE ENERGY <CBSREFERENCEENERGY>`; * :psivar:`CBS CORRELATION ENERGY <CBSCORRELATIONENERGY>`; * :psivar:`CURRENT ENERGY <CURRENTENERGY>`; * :psivar:`CURRENT REFERENCE ENERGY <CURRENTREFERENCEENERGY>`; * :psivar:`CURRENT CORRELATION ENERGY <CURRENTCORRELATIONENERGY>`. .. caution:: Some features are not yet implemented. Buy a developer a coffee. - Not all methods hooked in through PSI variables, configuration interaction and arbitrary order MP in particular. - No scheme defaults for given basis zeta number, so scheme must be specified explicitly. - No way to tell function to boost fitting basis size for all calculations. - No way to extrapolate def2 family basis sets. - Need to add more extrapolation schemes. As represented in the equation below, a CBS energy method is defined in several; sequential stages (scf, corl, delta, delta2, delta3, delta4, delta5) covering treatment; of the reference total energy, the correlation energy, a delta correction to the; correlation energy, and a second delta correction, etc.. Each is activated by its; stage_wfn keyword and is only allowed if all preceding stages are active. .. include:: cbs_eqn.rst. * Energy Methods; The presence of a stage_wfn keyword is the indicator to incorporate; (and check for stage_basis and stage_scheme keywords) and compute; that stage in defining the CBS energy. The cbs() function requires, at a minimum, ``name='scf'`` and ``scf_basis``; keywords to be specified for reference-step only jobs and ``name`` and; ``corl_basis`` keywords for correlated jobs. The following energy methods have been set up for cbs(). .. hlist::; :columns: 5. * scf; * mp2; * mp2.5; * mp3; * mp4(sdq); * mp4; * omp2; * omp3; * ocepa; * cepa0; * cepa(0); * cepa(1); * cepa(3); * acpf; * aqcc; * qcisd; * cc2; * ccsd; * fno-df-ccsd; * bccd; * cc3; * qcisd(t); * ccsd(t); * fno-df-ccsd(t); * bccd(t); * cisd; * c",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:54250,Energy Efficiency,energy,energy,54250," energy in Hartrees. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CBS TOTAL ENERGY <CBSTOTALENERGY>`; * :psivar:`CBS REFERENCE ENERGY <CBSREFERENCEENERGY>`; * :psivar:`CBS CORRELATION ENERGY <CBSCORRELATIONENERGY>`; * :psivar:`CURRENT ENERGY <CURRENTENERGY>`; * :psivar:`CURRENT REFERENCE ENERGY <CURRENTREFERENCEENERGY>`; * :psivar:`CURRENT CORRELATION ENERGY <CURRENTCORRELATIONENERGY>`. .. caution:: Some features are not yet implemented. Buy a developer a coffee. - Not all methods hooked in through PSI variables, configuration interaction and arbitrary order MP in particular. - No scheme defaults for given basis zeta number, so scheme must be specified explicitly. - No way to tell function to boost fitting basis size for all calculations. - No way to extrapolate def2 family basis sets. - Need to add more extrapolation schemes. As represented in the equation below, a CBS energy method is defined in several; sequential stages (scf, corl, delta, delta2, delta3, delta4, delta5) covering treatment; of the reference total energy, the correlation energy, a delta correction to the; correlation energy, and a second delta correction, etc.. Each is activated by its; stage_wfn keyword and is only allowed if all preceding stages are active. .. include:: cbs_eqn.rst. * Energy Methods; The presence of a stage_wfn keyword is the indicator to incorporate; (and check for stage_basis and stage_scheme keywords) and compute; that stage in defining the CBS energy. The cbs() function requires, at a minimum, ``name='scf'`` and ``scf_basis``; keywords to be specified for reference-step only jobs and ``name`` and; ``corl_basis`` keywords for correlated jobs. The following energy methods have been set up for cbs(). .. hlist::; :columns: 5. * scf; * mp2; * mp2.5; * mp3; * mp4(sdq); * mp4; * omp2; * omp3; * ocepa; * cepa0; * cepa(0); * cepa(1); * cepa(3); * acpf; * aqcc; * qcisd; * cc2; * ccsd; * fno-df-ccsd; * bccd; * cc3; * qcisd(t); * ccsd(t); * fno-df-ccsd(t); * bccd(t); * cisd; * c",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:54423,Energy Efficiency,Energy,Energy,54423,"CORRELATIONENERGY>`. .. caution:: Some features are not yet implemented. Buy a developer a coffee. - Not all methods hooked in through PSI variables, configuration interaction and arbitrary order MP in particular. - No scheme defaults for given basis zeta number, so scheme must be specified explicitly. - No way to tell function to boost fitting basis size for all calculations. - No way to extrapolate def2 family basis sets. - Need to add more extrapolation schemes. As represented in the equation below, a CBS energy method is defined in several; sequential stages (scf, corl, delta, delta2, delta3, delta4, delta5) covering treatment; of the reference total energy, the correlation energy, a delta correction to the; correlation energy, and a second delta correction, etc.. Each is activated by its; stage_wfn keyword and is only allowed if all preceding stages are active. .. include:: cbs_eqn.rst. * Energy Methods; The presence of a stage_wfn keyword is the indicator to incorporate; (and check for stage_basis and stage_scheme keywords) and compute; that stage in defining the CBS energy. The cbs() function requires, at a minimum, ``name='scf'`` and ``scf_basis``; keywords to be specified for reference-step only jobs and ``name`` and; ``corl_basis`` keywords for correlated jobs. The following energy methods have been set up for cbs(). .. hlist::; :columns: 5. * scf; * mp2; * mp2.5; * mp3; * mp4(sdq); * mp4; * omp2; * omp3; * ocepa; * cepa0; * cepa(0); * cepa(1); * cepa(3); * acpf; * aqcc; * qcisd; * cc2; * ccsd; * fno-df-ccsd; * bccd; * cc3; * qcisd(t); * ccsd(t); * fno-df-ccsd(t); * bccd(t); * cisd; * cisdt; * cisdtq; * ci\ *n*; * fci; * mrccsd; * mrccsd(t); * mrccsdt; * mrccsdt(q). :type name: string; :param name: ``'scf'`` || ``'ccsd'`` || etc. First argument, usually unlabeled. Indicates the computational method; for the correlation energy, unless only reference step to be performed,; in which case should be ``'scf'``. Overruled if stage_wfn keywords supplied. :type corl",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:54606,Energy Efficiency,energy,energy,54606,"CORRELATIONENERGY>`. .. caution:: Some features are not yet implemented. Buy a developer a coffee. - Not all methods hooked in through PSI variables, configuration interaction and arbitrary order MP in particular. - No scheme defaults for given basis zeta number, so scheme must be specified explicitly. - No way to tell function to boost fitting basis size for all calculations. - No way to extrapolate def2 family basis sets. - Need to add more extrapolation schemes. As represented in the equation below, a CBS energy method is defined in several; sequential stages (scf, corl, delta, delta2, delta3, delta4, delta5) covering treatment; of the reference total energy, the correlation energy, a delta correction to the; correlation energy, and a second delta correction, etc.. Each is activated by its; stage_wfn keyword and is only allowed if all preceding stages are active. .. include:: cbs_eqn.rst. * Energy Methods; The presence of a stage_wfn keyword is the indicator to incorporate; (and check for stage_basis and stage_scheme keywords) and compute; that stage in defining the CBS energy. The cbs() function requires, at a minimum, ``name='scf'`` and ``scf_basis``; keywords to be specified for reference-step only jobs and ``name`` and; ``corl_basis`` keywords for correlated jobs. The following energy methods have been set up for cbs(). .. hlist::; :columns: 5. * scf; * mp2; * mp2.5; * mp3; * mp4(sdq); * mp4; * omp2; * omp3; * ocepa; * cepa0; * cepa(0); * cepa(1); * cepa(3); * acpf; * aqcc; * qcisd; * cc2; * ccsd; * fno-df-ccsd; * bccd; * cc3; * qcisd(t); * ccsd(t); * fno-df-ccsd(t); * bccd(t); * cisd; * cisdt; * cisdtq; * ci\ *n*; * fci; * mrccsd; * mrccsd(t); * mrccsdt; * mrccsdt(q). :type name: string; :param name: ``'scf'`` || ``'ccsd'`` || etc. First argument, usually unlabeled. Indicates the computational method; for the correlation energy, unless only reference step to be performed,; in which case should be ``'scf'``. Overruled if stage_wfn keywords supplied. :type corl",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:54822,Energy Efficiency,energy,energy,54822,"l function to boost fitting basis size for all calculations. - No way to extrapolate def2 family basis sets. - Need to add more extrapolation schemes. As represented in the equation below, a CBS energy method is defined in several; sequential stages (scf, corl, delta, delta2, delta3, delta4, delta5) covering treatment; of the reference total energy, the correlation energy, a delta correction to the; correlation energy, and a second delta correction, etc.. Each is activated by its; stage_wfn keyword and is only allowed if all preceding stages are active. .. include:: cbs_eqn.rst. * Energy Methods; The presence of a stage_wfn keyword is the indicator to incorporate; (and check for stage_basis and stage_scheme keywords) and compute; that stage in defining the CBS energy. The cbs() function requires, at a minimum, ``name='scf'`` and ``scf_basis``; keywords to be specified for reference-step only jobs and ``name`` and; ``corl_basis`` keywords for correlated jobs. The following energy methods have been set up for cbs(). .. hlist::; :columns: 5. * scf; * mp2; * mp2.5; * mp3; * mp4(sdq); * mp4; * omp2; * omp3; * ocepa; * cepa0; * cepa(0); * cepa(1); * cepa(3); * acpf; * aqcc; * qcisd; * cc2; * ccsd; * fno-df-ccsd; * bccd; * cc3; * qcisd(t); * ccsd(t); * fno-df-ccsd(t); * bccd(t); * cisd; * cisdt; * cisdtq; * ci\ *n*; * fci; * mrccsd; * mrccsd(t); * mrccsdt; * mrccsdt(q). :type name: string; :param name: ``'scf'`` || ``'ccsd'`` || etc. First argument, usually unlabeled. Indicates the computational method; for the correlation energy, unless only reference step to be performed,; in which case should be ``'scf'``. Overruled if stage_wfn keywords supplied. :type corl_wfn: string; :param corl_wfn: ``'mp2'`` || ``'ccsd(t)'`` || etc. Indicates the energy method for which the correlation energy is to be; obtained. Can also be specified with ``name`` or as the unlabeled; first argument to the function. :type delta_wfn: string; :param delta_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indi",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:55377,Energy Efficiency,energy,energy,55377,"e. .. include:: cbs_eqn.rst. * Energy Methods; The presence of a stage_wfn keyword is the indicator to incorporate; (and check for stage_basis and stage_scheme keywords) and compute; that stage in defining the CBS energy. The cbs() function requires, at a minimum, ``name='scf'`` and ``scf_basis``; keywords to be specified for reference-step only jobs and ``name`` and; ``corl_basis`` keywords for correlated jobs. The following energy methods have been set up for cbs(). .. hlist::; :columns: 5. * scf; * mp2; * mp2.5; * mp3; * mp4(sdq); * mp4; * omp2; * omp3; * ocepa; * cepa0; * cepa(0); * cepa(1); * cepa(3); * acpf; * aqcc; * qcisd; * cc2; * ccsd; * fno-df-ccsd; * bccd; * cc3; * qcisd(t); * ccsd(t); * fno-df-ccsd(t); * bccd(t); * cisd; * cisdt; * cisdtq; * ci\ *n*; * fci; * mrccsd; * mrccsd(t); * mrccsdt; * mrccsdt(q). :type name: string; :param name: ``'scf'`` || ``'ccsd'`` || etc. First argument, usually unlabeled. Indicates the computational method; for the correlation energy, unless only reference step to be performed,; in which case should be ``'scf'``. Overruled if stage_wfn keywords supplied. :type corl_wfn: string; :param corl_wfn: ``'mp2'`` || ``'ccsd(t)'`` || etc. Indicates the energy method for which the correlation energy is to be; obtained. Can also be specified with ``name`` or as the unlabeled; first argument to the function. :type delta_wfn: string; :param delta_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a delta correction; to the correlation energy is to be obtained. :type delta_wfn_lesser: string; :param delta_wfn_lesser: |dl| ``'mp2'`` |dr| || ``'ccsd'`` || etc. Indicates the inferior energy method for which a delta correction; to the correlation energy is to be obtained. :type delta2_wfn: string; :param delta2_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a second delta correction; to the correlation energy is to be obtained. :type delta2_wfn_lesser: string; ",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:55597,Energy Efficiency,energy,energy,55597,") function requires, at a minimum, ``name='scf'`` and ``scf_basis``; keywords to be specified for reference-step only jobs and ``name`` and; ``corl_basis`` keywords for correlated jobs. The following energy methods have been set up for cbs(). .. hlist::; :columns: 5. * scf; * mp2; * mp2.5; * mp3; * mp4(sdq); * mp4; * omp2; * omp3; * ocepa; * cepa0; * cepa(0); * cepa(1); * cepa(3); * acpf; * aqcc; * qcisd; * cc2; * ccsd; * fno-df-ccsd; * bccd; * cc3; * qcisd(t); * ccsd(t); * fno-df-ccsd(t); * bccd(t); * cisd; * cisdt; * cisdtq; * ci\ *n*; * fci; * mrccsd; * mrccsd(t); * mrccsdt; * mrccsdt(q). :type name: string; :param name: ``'scf'`` || ``'ccsd'`` || etc. First argument, usually unlabeled. Indicates the computational method; for the correlation energy, unless only reference step to be performed,; in which case should be ``'scf'``. Overruled if stage_wfn keywords supplied. :type corl_wfn: string; :param corl_wfn: ``'mp2'`` || ``'ccsd(t)'`` || etc. Indicates the energy method for which the correlation energy is to be; obtained. Can also be specified with ``name`` or as the unlabeled; first argument to the function. :type delta_wfn: string; :param delta_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a delta correction; to the correlation energy is to be obtained. :type delta_wfn_lesser: string; :param delta_wfn_lesser: |dl| ``'mp2'`` |dr| || ``'ccsd'`` || etc. Indicates the inferior energy method for which a delta correction; to the correlation energy is to be obtained. :type delta2_wfn: string; :param delta2_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a second delta correction; to the correlation energy is to be obtained. :type delta2_wfn_lesser: string; :param delta2_wfn_lesser: |dl| ``'mp2'`` |dr| || ``'ccsd(t)'`` || etc. Indicates the inferior energy method for which a second delta correction; to the correlation energy is to be obtained. :type delta3_wfn: string; :param delta3_w",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:55637,Energy Efficiency,energy,energy,55637,") function requires, at a minimum, ``name='scf'`` and ``scf_basis``; keywords to be specified for reference-step only jobs and ``name`` and; ``corl_basis`` keywords for correlated jobs. The following energy methods have been set up for cbs(). .. hlist::; :columns: 5. * scf; * mp2; * mp2.5; * mp3; * mp4(sdq); * mp4; * omp2; * omp3; * ocepa; * cepa0; * cepa(0); * cepa(1); * cepa(3); * acpf; * aqcc; * qcisd; * cc2; * ccsd; * fno-df-ccsd; * bccd; * cc3; * qcisd(t); * ccsd(t); * fno-df-ccsd(t); * bccd(t); * cisd; * cisdt; * cisdtq; * ci\ *n*; * fci; * mrccsd; * mrccsd(t); * mrccsdt; * mrccsdt(q). :type name: string; :param name: ``'scf'`` || ``'ccsd'`` || etc. First argument, usually unlabeled. Indicates the computational method; for the correlation energy, unless only reference step to be performed,; in which case should be ``'scf'``. Overruled if stage_wfn keywords supplied. :type corl_wfn: string; :param corl_wfn: ``'mp2'`` || ``'ccsd(t)'`` || etc. Indicates the energy method for which the correlation energy is to be; obtained. Can also be specified with ``name`` or as the unlabeled; first argument to the function. :type delta_wfn: string; :param delta_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a delta correction; to the correlation energy is to be obtained. :type delta_wfn_lesser: string; :param delta_wfn_lesser: |dl| ``'mp2'`` |dr| || ``'ccsd'`` || etc. Indicates the inferior energy method for which a delta correction; to the correlation energy is to be obtained. :type delta2_wfn: string; :param delta2_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a second delta correction; to the correlation energy is to be obtained. :type delta2_wfn_lesser: string; :param delta2_wfn_lesser: |dl| ``'mp2'`` |dr| || ``'ccsd(t)'`` || etc. Indicates the inferior energy method for which a second delta correction; to the correlation energy is to be obtained. :type delta3_wfn: string; :param delta3_w",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:55857,Energy Efficiency,energy,energy,55857,". * scf; * mp2; * mp2.5; * mp3; * mp4(sdq); * mp4; * omp2; * omp3; * ocepa; * cepa0; * cepa(0); * cepa(1); * cepa(3); * acpf; * aqcc; * qcisd; * cc2; * ccsd; * fno-df-ccsd; * bccd; * cc3; * qcisd(t); * ccsd(t); * fno-df-ccsd(t); * bccd(t); * cisd; * cisdt; * cisdtq; * ci\ *n*; * fci; * mrccsd; * mrccsd(t); * mrccsdt; * mrccsdt(q). :type name: string; :param name: ``'scf'`` || ``'ccsd'`` || etc. First argument, usually unlabeled. Indicates the computational method; for the correlation energy, unless only reference step to be performed,; in which case should be ``'scf'``. Overruled if stage_wfn keywords supplied. :type corl_wfn: string; :param corl_wfn: ``'mp2'`` || ``'ccsd(t)'`` || etc. Indicates the energy method for which the correlation energy is to be; obtained. Can also be specified with ``name`` or as the unlabeled; first argument to the function. :type delta_wfn: string; :param delta_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a delta correction; to the correlation energy is to be obtained. :type delta_wfn_lesser: string; :param delta_wfn_lesser: |dl| ``'mp2'`` |dr| || ``'ccsd'`` || etc. Indicates the inferior energy method for which a delta correction; to the correlation energy is to be obtained. :type delta2_wfn: string; :param delta2_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a second delta correction; to the correlation energy is to be obtained. :type delta2_wfn_lesser: string; :param delta2_wfn_lesser: |dl| ``'mp2'`` |dr| || ``'ccsd(t)'`` || etc. Indicates the inferior energy method for which a second delta correction; to the correlation energy is to be obtained. :type delta3_wfn: string; :param delta3_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a third delta correction; to the correlation energy is to be obtained. :type delta3_wfn_lesser: string; :param delta3_wfn_lesser: |dl| ``'mp2'`` |dr| || ``'ccsd(t)'`` || etc. I",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:55920,Energy Efficiency,energy,energy,55920,". * scf; * mp2; * mp2.5; * mp3; * mp4(sdq); * mp4; * omp2; * omp3; * ocepa; * cepa0; * cepa(0); * cepa(1); * cepa(3); * acpf; * aqcc; * qcisd; * cc2; * ccsd; * fno-df-ccsd; * bccd; * cc3; * qcisd(t); * ccsd(t); * fno-df-ccsd(t); * bccd(t); * cisd; * cisdt; * cisdtq; * ci\ *n*; * fci; * mrccsd; * mrccsd(t); * mrccsdt; * mrccsdt(q). :type name: string; :param name: ``'scf'`` || ``'ccsd'`` || etc. First argument, usually unlabeled. Indicates the computational method; for the correlation energy, unless only reference step to be performed,; in which case should be ``'scf'``. Overruled if stage_wfn keywords supplied. :type corl_wfn: string; :param corl_wfn: ``'mp2'`` || ``'ccsd(t)'`` || etc. Indicates the energy method for which the correlation energy is to be; obtained. Can also be specified with ``name`` or as the unlabeled; first argument to the function. :type delta_wfn: string; :param delta_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a delta correction; to the correlation energy is to be obtained. :type delta_wfn_lesser: string; :param delta_wfn_lesser: |dl| ``'mp2'`` |dr| || ``'ccsd'`` || etc. Indicates the inferior energy method for which a delta correction; to the correlation energy is to be obtained. :type delta2_wfn: string; :param delta2_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a second delta correction; to the correlation energy is to be obtained. :type delta2_wfn_lesser: string; :param delta2_wfn_lesser: |dl| ``'mp2'`` |dr| || ``'ccsd(t)'`` || etc. Indicates the inferior energy method for which a second delta correction; to the correlation energy is to be obtained. :type delta3_wfn: string; :param delta3_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a third delta correction; to the correlation energy is to be obtained. :type delta3_wfn_lesser: string; :param delta3_wfn_lesser: |dl| ``'mp2'`` |dr| || ``'ccsd(t)'`` || etc. I",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:56068,Energy Efficiency,energy,energy,56068," fno-df-ccsd(t); * bccd(t); * cisd; * cisdt; * cisdtq; * ci\ *n*; * fci; * mrccsd; * mrccsd(t); * mrccsdt; * mrccsdt(q). :type name: string; :param name: ``'scf'`` || ``'ccsd'`` || etc. First argument, usually unlabeled. Indicates the computational method; for the correlation energy, unless only reference step to be performed,; in which case should be ``'scf'``. Overruled if stage_wfn keywords supplied. :type corl_wfn: string; :param corl_wfn: ``'mp2'`` || ``'ccsd(t)'`` || etc. Indicates the energy method for which the correlation energy is to be; obtained. Can also be specified with ``name`` or as the unlabeled; first argument to the function. :type delta_wfn: string; :param delta_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a delta correction; to the correlation energy is to be obtained. :type delta_wfn_lesser: string; :param delta_wfn_lesser: |dl| ``'mp2'`` |dr| || ``'ccsd'`` || etc. Indicates the inferior energy method for which a delta correction; to the correlation energy is to be obtained. :type delta2_wfn: string; :param delta2_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a second delta correction; to the correlation energy is to be obtained. :type delta2_wfn_lesser: string; :param delta2_wfn_lesser: |dl| ``'mp2'`` |dr| || ``'ccsd(t)'`` || etc. Indicates the inferior energy method for which a second delta correction; to the correlation energy is to be obtained. :type delta3_wfn: string; :param delta3_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a third delta correction; to the correlation energy is to be obtained. :type delta3_wfn_lesser: string; :param delta3_wfn_lesser: |dl| ``'mp2'`` |dr| || ``'ccsd(t)'`` || etc. Indicates the inferior energy method for which a third delta correction; to the correlation energy is to be obtained. :type delta4_wfn: string; :param delta4_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the ",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:56131,Energy Efficiency,energy,energy,56131," fno-df-ccsd(t); * bccd(t); * cisd; * cisdt; * cisdtq; * ci\ *n*; * fci; * mrccsd; * mrccsd(t); * mrccsdt; * mrccsdt(q). :type name: string; :param name: ``'scf'`` || ``'ccsd'`` || etc. First argument, usually unlabeled. Indicates the computational method; for the correlation energy, unless only reference step to be performed,; in which case should be ``'scf'``. Overruled if stage_wfn keywords supplied. :type corl_wfn: string; :param corl_wfn: ``'mp2'`` || ``'ccsd(t)'`` || etc. Indicates the energy method for which the correlation energy is to be; obtained. Can also be specified with ``name`` or as the unlabeled; first argument to the function. :type delta_wfn: string; :param delta_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a delta correction; to the correlation energy is to be obtained. :type delta_wfn_lesser: string; :param delta_wfn_lesser: |dl| ``'mp2'`` |dr| || ``'ccsd'`` || etc. Indicates the inferior energy method for which a delta correction; to the correlation energy is to be obtained. :type delta2_wfn: string; :param delta2_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a second delta correction; to the correlation energy is to be obtained. :type delta2_wfn_lesser: string; :param delta2_wfn_lesser: |dl| ``'mp2'`` |dr| || ``'ccsd(t)'`` || etc. Indicates the inferior energy method for which a second delta correction; to the correlation energy is to be obtained. :type delta3_wfn: string; :param delta3_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a third delta correction; to the correlation energy is to be obtained. :type delta3_wfn_lesser: string; :param delta3_wfn_lesser: |dl| ``'mp2'`` |dr| || ``'ccsd(t)'`` || etc. Indicates the inferior energy method for which a third delta correction; to the correlation energy is to be obtained. :type delta4_wfn: string; :param delta4_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the ",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:56263,Energy Efficiency,energy,energy,56263,"ent, usually unlabeled. Indicates the computational method; for the correlation energy, unless only reference step to be performed,; in which case should be ``'scf'``. Overruled if stage_wfn keywords supplied. :type corl_wfn: string; :param corl_wfn: ``'mp2'`` || ``'ccsd(t)'`` || etc. Indicates the energy method for which the correlation energy is to be; obtained. Can also be specified with ``name`` or as the unlabeled; first argument to the function. :type delta_wfn: string; :param delta_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a delta correction; to the correlation energy is to be obtained. :type delta_wfn_lesser: string; :param delta_wfn_lesser: |dl| ``'mp2'`` |dr| || ``'ccsd'`` || etc. Indicates the inferior energy method for which a delta correction; to the correlation energy is to be obtained. :type delta2_wfn: string; :param delta2_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a second delta correction; to the correlation energy is to be obtained. :type delta2_wfn_lesser: string; :param delta2_wfn_lesser: |dl| ``'mp2'`` |dr| || ``'ccsd(t)'`` || etc. Indicates the inferior energy method for which a second delta correction; to the correlation energy is to be obtained. :type delta3_wfn: string; :param delta3_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a third delta correction; to the correlation energy is to be obtained. :type delta3_wfn_lesser: string; :param delta3_wfn_lesser: |dl| ``'mp2'`` |dr| || ``'ccsd(t)'`` || etc. Indicates the inferior energy method for which a third delta correction; to the correlation energy is to be obtained. :type delta4_wfn: string; :param delta4_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a fourth delta correction; to the correlation energy is to be obtained. :type delta4_wfn_lesser: string; :param delta4_wfn_lesser: |dl| ``'mp2'`` |dr| || ``'ccsd(t",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:56333,Energy Efficiency,energy,energy,56333,"ent, usually unlabeled. Indicates the computational method; for the correlation energy, unless only reference step to be performed,; in which case should be ``'scf'``. Overruled if stage_wfn keywords supplied. :type corl_wfn: string; :param corl_wfn: ``'mp2'`` || ``'ccsd(t)'`` || etc. Indicates the energy method for which the correlation energy is to be; obtained. Can also be specified with ``name`` or as the unlabeled; first argument to the function. :type delta_wfn: string; :param delta_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a delta correction; to the correlation energy is to be obtained. :type delta_wfn_lesser: string; :param delta_wfn_lesser: |dl| ``'mp2'`` |dr| || ``'ccsd'`` || etc. Indicates the inferior energy method for which a delta correction; to the correlation energy is to be obtained. :type delta2_wfn: string; :param delta2_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a second delta correction; to the correlation energy is to be obtained. :type delta2_wfn_lesser: string; :param delta2_wfn_lesser: |dl| ``'mp2'`` |dr| || ``'ccsd(t)'`` || etc. Indicates the inferior energy method for which a second delta correction; to the correlation energy is to be obtained. :type delta3_wfn: string; :param delta3_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a third delta correction; to the correlation energy is to be obtained. :type delta3_wfn_lesser: string; :param delta3_wfn_lesser: |dl| ``'mp2'`` |dr| || ``'ccsd(t)'`` || etc. Indicates the inferior energy method for which a third delta correction; to the correlation energy is to be obtained. :type delta4_wfn: string; :param delta4_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a fourth delta correction; to the correlation energy is to be obtained. :type delta4_wfn_lesser: string; :param delta4_wfn_lesser: |dl| ``'mp2'`` |dr| || ``'ccsd(t",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:56486,Energy Efficiency,energy,energy,56486,: string; :param corl_wfn: ``'mp2'`` || ``'ccsd(t)'`` || etc. Indicates the energy method for which the correlation energy is to be; obtained. Can also be specified with ``name`` or as the unlabeled; first argument to the function. :type delta_wfn: string; :param delta_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a delta correction; to the correlation energy is to be obtained. :type delta_wfn_lesser: string; :param delta_wfn_lesser: |dl| ``'mp2'`` |dr| || ``'ccsd'`` || etc. Indicates the inferior energy method for which a delta correction; to the correlation energy is to be obtained. :type delta2_wfn: string; :param delta2_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a second delta correction; to the correlation energy is to be obtained. :type delta2_wfn_lesser: string; :param delta2_wfn_lesser: |dl| ``'mp2'`` |dr| || ``'ccsd(t)'`` || etc. Indicates the inferior energy method for which a second delta correction; to the correlation energy is to be obtained. :type delta3_wfn: string; :param delta3_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a third delta correction; to the correlation energy is to be obtained. :type delta3_wfn_lesser: string; :param delta3_wfn_lesser: |dl| ``'mp2'`` |dr| || ``'ccsd(t)'`` || etc. Indicates the inferior energy method for which a third delta correction; to the correlation energy is to be obtained. :type delta4_wfn: string; :param delta4_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a fourth delta correction; to the correlation energy is to be obtained. :type delta4_wfn_lesser: string; :param delta4_wfn_lesser: |dl| ``'mp2'`` |dr| || ``'ccsd(t)'`` || etc. Indicates the inferior energy method for which a fourth delta correction; to the correlation energy is to be obtained. :type delta5_wfn: string; :param delta5_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates t,MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:56556,Energy Efficiency,energy,energy,56556,: string; :param corl_wfn: ``'mp2'`` || ``'ccsd(t)'`` || etc. Indicates the energy method for which the correlation energy is to be; obtained. Can also be specified with ``name`` or as the unlabeled; first argument to the function. :type delta_wfn: string; :param delta_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a delta correction; to the correlation energy is to be obtained. :type delta_wfn_lesser: string; :param delta_wfn_lesser: |dl| ``'mp2'`` |dr| || ``'ccsd'`` || etc. Indicates the inferior energy method for which a delta correction; to the correlation energy is to be obtained. :type delta2_wfn: string; :param delta2_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a second delta correction; to the correlation energy is to be obtained. :type delta2_wfn_lesser: string; :param delta2_wfn_lesser: |dl| ``'mp2'`` |dr| || ``'ccsd(t)'`` || etc. Indicates the inferior energy method for which a second delta correction; to the correlation energy is to be obtained. :type delta3_wfn: string; :param delta3_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a third delta correction; to the correlation energy is to be obtained. :type delta3_wfn_lesser: string; :param delta3_wfn_lesser: |dl| ``'mp2'`` |dr| || ``'ccsd(t)'`` || etc. Indicates the inferior energy method for which a third delta correction; to the correlation energy is to be obtained. :type delta4_wfn: string; :param delta4_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a fourth delta correction; to the correlation energy is to be obtained. :type delta4_wfn_lesser: string; :param delta4_wfn_lesser: |dl| ``'mp2'`` |dr| || ``'ccsd(t)'`` || etc. Indicates the inferior energy method for which a fourth delta correction; to the correlation energy is to be obtained. :type delta5_wfn: string; :param delta5_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates t,MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:56688,Energy Efficiency,energy,energy,56688,irst argument to the function. :type delta_wfn: string; :param delta_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a delta correction; to the correlation energy is to be obtained. :type delta_wfn_lesser: string; :param delta_wfn_lesser: |dl| ``'mp2'`` |dr| || ``'ccsd'`` || etc. Indicates the inferior energy method for which a delta correction; to the correlation energy is to be obtained. :type delta2_wfn: string; :param delta2_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a second delta correction; to the correlation energy is to be obtained. :type delta2_wfn_lesser: string; :param delta2_wfn_lesser: |dl| ``'mp2'`` |dr| || ``'ccsd(t)'`` || etc. Indicates the inferior energy method for which a second delta correction; to the correlation energy is to be obtained. :type delta3_wfn: string; :param delta3_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a third delta correction; to the correlation energy is to be obtained. :type delta3_wfn_lesser: string; :param delta3_wfn_lesser: |dl| ``'mp2'`` |dr| || ``'ccsd(t)'`` || etc. Indicates the inferior energy method for which a third delta correction; to the correlation energy is to be obtained. :type delta4_wfn: string; :param delta4_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a fourth delta correction; to the correlation energy is to be obtained. :type delta4_wfn_lesser: string; :param delta4_wfn_lesser: |dl| ``'mp2'`` |dr| || ``'ccsd(t)'`` || etc. Indicates the inferior energy method for which a fourth delta correction; to the correlation energy is to be obtained. :type delta5_wfn: string; :param delta5_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a fifth delta correction; to the correlation energy is to be obtained. :type delta5_wfn_lesser: string; :param delta5_wfn_lesser: |dl| ``'mp2'`` |dr| || ``'ccsd(t,MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:56757,Energy Efficiency,energy,energy,56757,irst argument to the function. :type delta_wfn: string; :param delta_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a delta correction; to the correlation energy is to be obtained. :type delta_wfn_lesser: string; :param delta_wfn_lesser: |dl| ``'mp2'`` |dr| || ``'ccsd'`` || etc. Indicates the inferior energy method for which a delta correction; to the correlation energy is to be obtained. :type delta2_wfn: string; :param delta2_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a second delta correction; to the correlation energy is to be obtained. :type delta2_wfn_lesser: string; :param delta2_wfn_lesser: |dl| ``'mp2'`` |dr| || ``'ccsd(t)'`` || etc. Indicates the inferior energy method for which a second delta correction; to the correlation energy is to be obtained. :type delta3_wfn: string; :param delta3_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a third delta correction; to the correlation energy is to be obtained. :type delta3_wfn_lesser: string; :param delta3_wfn_lesser: |dl| ``'mp2'`` |dr| || ``'ccsd(t)'`` || etc. Indicates the inferior energy method for which a third delta correction; to the correlation energy is to be obtained. :type delta4_wfn: string; :param delta4_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a fourth delta correction; to the correlation energy is to be obtained. :type delta4_wfn_lesser: string; :param delta4_wfn_lesser: |dl| ``'mp2'`` |dr| || ``'ccsd(t)'`` || etc. Indicates the inferior energy method for which a fourth delta correction; to the correlation energy is to be obtained. :type delta5_wfn: string; :param delta5_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a fifth delta correction; to the correlation energy is to be obtained. :type delta5_wfn_lesser: string; :param delta5_wfn_lesser: |dl| ``'mp2'`` |dr| || ``'ccsd(t,MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:56910,Energy Efficiency,energy,energy,56910," :type delta_wfn_lesser: string; :param delta_wfn_lesser: |dl| ``'mp2'`` |dr| || ``'ccsd'`` || etc. Indicates the inferior energy method for which a delta correction; to the correlation energy is to be obtained. :type delta2_wfn: string; :param delta2_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a second delta correction; to the correlation energy is to be obtained. :type delta2_wfn_lesser: string; :param delta2_wfn_lesser: |dl| ``'mp2'`` |dr| || ``'ccsd(t)'`` || etc. Indicates the inferior energy method for which a second delta correction; to the correlation energy is to be obtained. :type delta3_wfn: string; :param delta3_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a third delta correction; to the correlation energy is to be obtained. :type delta3_wfn_lesser: string; :param delta3_wfn_lesser: |dl| ``'mp2'`` |dr| || ``'ccsd(t)'`` || etc. Indicates the inferior energy method for which a third delta correction; to the correlation energy is to be obtained. :type delta4_wfn: string; :param delta4_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a fourth delta correction; to the correlation energy is to be obtained. :type delta4_wfn_lesser: string; :param delta4_wfn_lesser: |dl| ``'mp2'`` |dr| || ``'ccsd(t)'`` || etc. Indicates the inferior energy method for which a fourth delta correction; to the correlation energy is to be obtained. :type delta5_wfn: string; :param delta5_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a fifth delta correction; to the correlation energy is to be obtained. :type delta5_wfn_lesser: string; :param delta5_wfn_lesser: |dl| ``'mp2'`` |dr| || ``'ccsd(t)'`` || etc. Indicates the inferior energy method for which a fifth delta correction; to the correlation energy is to be obtained. * Basis Sets; Currently, the basis set set through ``set`` commands have no influence; on a ",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:56979,Energy Efficiency,energy,energy,56979," :type delta_wfn_lesser: string; :param delta_wfn_lesser: |dl| ``'mp2'`` |dr| || ``'ccsd'`` || etc. Indicates the inferior energy method for which a delta correction; to the correlation energy is to be obtained. :type delta2_wfn: string; :param delta2_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a second delta correction; to the correlation energy is to be obtained. :type delta2_wfn_lesser: string; :param delta2_wfn_lesser: |dl| ``'mp2'`` |dr| || ``'ccsd(t)'`` || etc. Indicates the inferior energy method for which a second delta correction; to the correlation energy is to be obtained. :type delta3_wfn: string; :param delta3_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a third delta correction; to the correlation energy is to be obtained. :type delta3_wfn_lesser: string; :param delta3_wfn_lesser: |dl| ``'mp2'`` |dr| || ``'ccsd(t)'`` || etc. Indicates the inferior energy method for which a third delta correction; to the correlation energy is to be obtained. :type delta4_wfn: string; :param delta4_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a fourth delta correction; to the correlation energy is to be obtained. :type delta4_wfn_lesser: string; :param delta4_wfn_lesser: |dl| ``'mp2'`` |dr| || ``'ccsd(t)'`` || etc. Indicates the inferior energy method for which a fourth delta correction; to the correlation energy is to be obtained. :type delta5_wfn: string; :param delta5_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a fifth delta correction; to the correlation energy is to be obtained. :type delta5_wfn_lesser: string; :param delta5_wfn_lesser: |dl| ``'mp2'`` |dr| || ``'ccsd(t)'`` || etc. Indicates the inferior energy method for which a fifth delta correction; to the correlation energy is to be obtained. * Basis Sets; Currently, the basis set set through ``set`` commands have no influence; on a ",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:57111,Energy Efficiency,energy,energy,57111,"e obtained. :type delta2_wfn: string; :param delta2_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a second delta correction; to the correlation energy is to be obtained. :type delta2_wfn_lesser: string; :param delta2_wfn_lesser: |dl| ``'mp2'`` |dr| || ``'ccsd(t)'`` || etc. Indicates the inferior energy method for which a second delta correction; to the correlation energy is to be obtained. :type delta3_wfn: string; :param delta3_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a third delta correction; to the correlation energy is to be obtained. :type delta3_wfn_lesser: string; :param delta3_wfn_lesser: |dl| ``'mp2'`` |dr| || ``'ccsd(t)'`` || etc. Indicates the inferior energy method for which a third delta correction; to the correlation energy is to be obtained. :type delta4_wfn: string; :param delta4_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a fourth delta correction; to the correlation energy is to be obtained. :type delta4_wfn_lesser: string; :param delta4_wfn_lesser: |dl| ``'mp2'`` |dr| || ``'ccsd(t)'`` || etc. Indicates the inferior energy method for which a fourth delta correction; to the correlation energy is to be obtained. :type delta5_wfn: string; :param delta5_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a fifth delta correction; to the correlation energy is to be obtained. :type delta5_wfn_lesser: string; :param delta5_wfn_lesser: |dl| ``'mp2'`` |dr| || ``'ccsd(t)'`` || etc. Indicates the inferior energy method for which a fifth delta correction; to the correlation energy is to be obtained. * Basis Sets; Currently, the basis set set through ``set`` commands have no influence; on a cbs calculation. :type scf_basis: :ref:`basis string <apdx:basisElement>`; :param scf_basis: |dl| ``corl_basis`` |dr| || ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the ",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:57181,Energy Efficiency,energy,energy,57181,"e obtained. :type delta2_wfn: string; :param delta2_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a second delta correction; to the correlation energy is to be obtained. :type delta2_wfn_lesser: string; :param delta2_wfn_lesser: |dl| ``'mp2'`` |dr| || ``'ccsd(t)'`` || etc. Indicates the inferior energy method for which a second delta correction; to the correlation energy is to be obtained. :type delta3_wfn: string; :param delta3_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a third delta correction; to the correlation energy is to be obtained. :type delta3_wfn_lesser: string; :param delta3_wfn_lesser: |dl| ``'mp2'`` |dr| || ``'ccsd(t)'`` || etc. Indicates the inferior energy method for which a third delta correction; to the correlation energy is to be obtained. :type delta4_wfn: string; :param delta4_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a fourth delta correction; to the correlation energy is to be obtained. :type delta4_wfn_lesser: string; :param delta4_wfn_lesser: |dl| ``'mp2'`` |dr| || ``'ccsd(t)'`` || etc. Indicates the inferior energy method for which a fourth delta correction; to the correlation energy is to be obtained. :type delta5_wfn: string; :param delta5_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a fifth delta correction; to the correlation energy is to be obtained. :type delta5_wfn_lesser: string; :param delta5_wfn_lesser: |dl| ``'mp2'`` |dr| || ``'ccsd(t)'`` || etc. Indicates the inferior energy method for which a fifth delta correction; to the correlation energy is to be obtained. * Basis Sets; Currently, the basis set set through ``set`` commands have no influence; on a cbs calculation. :type scf_basis: :ref:`basis string <apdx:basisElement>`; :param scf_basis: |dl| ``corl_basis`` |dr| || ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the ",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:57334,Energy Efficiency,energy,energy,57334,"a2_wfn_lesser: string; :param delta2_wfn_lesser: |dl| ``'mp2'`` |dr| || ``'ccsd(t)'`` || etc. Indicates the inferior energy method for which a second delta correction; to the correlation energy is to be obtained. :type delta3_wfn: string; :param delta3_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a third delta correction; to the correlation energy is to be obtained. :type delta3_wfn_lesser: string; :param delta3_wfn_lesser: |dl| ``'mp2'`` |dr| || ``'ccsd(t)'`` || etc. Indicates the inferior energy method for which a third delta correction; to the correlation energy is to be obtained. :type delta4_wfn: string; :param delta4_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a fourth delta correction; to the correlation energy is to be obtained. :type delta4_wfn_lesser: string; :param delta4_wfn_lesser: |dl| ``'mp2'`` |dr| || ``'ccsd(t)'`` || etc. Indicates the inferior energy method for which a fourth delta correction; to the correlation energy is to be obtained. :type delta5_wfn: string; :param delta5_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a fifth delta correction; to the correlation energy is to be obtained. :type delta5_wfn_lesser: string; :param delta5_wfn_lesser: |dl| ``'mp2'`` |dr| || ``'ccsd(t)'`` || etc. Indicates the inferior energy method for which a fifth delta correction; to the correlation energy is to be obtained. * Basis Sets; Currently, the basis set set through ``set`` commands have no influence; on a cbs calculation. :type scf_basis: :ref:`basis string <apdx:basisElement>`; :param scf_basis: |dl| ``corl_basis`` |dr| || ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the reference energy.; If any correlation method is specified, ``scf_basis`` can default; to ``corl_basis``. :type corl_basis: :ref:`basis string <apdx:basisElement>`; :param corl_basis: `",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:57404,Energy Efficiency,energy,energy,57404,"a2_wfn_lesser: string; :param delta2_wfn_lesser: |dl| ``'mp2'`` |dr| || ``'ccsd(t)'`` || etc. Indicates the inferior energy method for which a second delta correction; to the correlation energy is to be obtained. :type delta3_wfn: string; :param delta3_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a third delta correction; to the correlation energy is to be obtained. :type delta3_wfn_lesser: string; :param delta3_wfn_lesser: |dl| ``'mp2'`` |dr| || ``'ccsd(t)'`` || etc. Indicates the inferior energy method for which a third delta correction; to the correlation energy is to be obtained. :type delta4_wfn: string; :param delta4_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a fourth delta correction; to the correlation energy is to be obtained. :type delta4_wfn_lesser: string; :param delta4_wfn_lesser: |dl| ``'mp2'`` |dr| || ``'ccsd(t)'`` || etc. Indicates the inferior energy method for which a fourth delta correction; to the correlation energy is to be obtained. :type delta5_wfn: string; :param delta5_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a fifth delta correction; to the correlation energy is to be obtained. :type delta5_wfn_lesser: string; :param delta5_wfn_lesser: |dl| ``'mp2'`` |dr| || ``'ccsd(t)'`` || etc. Indicates the inferior energy method for which a fifth delta correction; to the correlation energy is to be obtained. * Basis Sets; Currently, the basis set set through ``set`` commands have no influence; on a cbs calculation. :type scf_basis: :ref:`basis string <apdx:basisElement>`; :param scf_basis: |dl| ``corl_basis`` |dr| || ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the reference energy.; If any correlation method is specified, ``scf_basis`` can default; to ``corl_basis``. :type corl_basis: :ref:`basis string <apdx:basisElement>`; :param corl_basis: `",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:57536,Energy Efficiency,energy,energy,57536,"e obtained. :type delta3_wfn: string; :param delta3_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a third delta correction; to the correlation energy is to be obtained. :type delta3_wfn_lesser: string; :param delta3_wfn_lesser: |dl| ``'mp2'`` |dr| || ``'ccsd(t)'`` || etc. Indicates the inferior energy method for which a third delta correction; to the correlation energy is to be obtained. :type delta4_wfn: string; :param delta4_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a fourth delta correction; to the correlation energy is to be obtained. :type delta4_wfn_lesser: string; :param delta4_wfn_lesser: |dl| ``'mp2'`` |dr| || ``'ccsd(t)'`` || etc. Indicates the inferior energy method for which a fourth delta correction; to the correlation energy is to be obtained. :type delta5_wfn: string; :param delta5_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a fifth delta correction; to the correlation energy is to be obtained. :type delta5_wfn_lesser: string; :param delta5_wfn_lesser: |dl| ``'mp2'`` |dr| || ``'ccsd(t)'`` || etc. Indicates the inferior energy method for which a fifth delta correction; to the correlation energy is to be obtained. * Basis Sets; Currently, the basis set set through ``set`` commands have no influence; on a cbs calculation. :type scf_basis: :ref:`basis string <apdx:basisElement>`; :param scf_basis: |dl| ``corl_basis`` |dr| || ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the reference energy.; If any correlation method is specified, ``scf_basis`` can default; to ``corl_basis``. :type corl_basis: :ref:`basis string <apdx:basisElement>`; :param corl_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the correlation energy. :type delta_basis: :ref:`basis string <apdx:basisElement>`; :",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:57605,Energy Efficiency,energy,energy,57605,"e obtained. :type delta3_wfn: string; :param delta3_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a third delta correction; to the correlation energy is to be obtained. :type delta3_wfn_lesser: string; :param delta3_wfn_lesser: |dl| ``'mp2'`` |dr| || ``'ccsd(t)'`` || etc. Indicates the inferior energy method for which a third delta correction; to the correlation energy is to be obtained. :type delta4_wfn: string; :param delta4_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a fourth delta correction; to the correlation energy is to be obtained. :type delta4_wfn_lesser: string; :param delta4_wfn_lesser: |dl| ``'mp2'`` |dr| || ``'ccsd(t)'`` || etc. Indicates the inferior energy method for which a fourth delta correction; to the correlation energy is to be obtained. :type delta5_wfn: string; :param delta5_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a fifth delta correction; to the correlation energy is to be obtained. :type delta5_wfn_lesser: string; :param delta5_wfn_lesser: |dl| ``'mp2'`` |dr| || ``'ccsd(t)'`` || etc. Indicates the inferior energy method for which a fifth delta correction; to the correlation energy is to be obtained. * Basis Sets; Currently, the basis set set through ``set`` commands have no influence; on a cbs calculation. :type scf_basis: :ref:`basis string <apdx:basisElement>`; :param scf_basis: |dl| ``corl_basis`` |dr| || ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the reference energy.; If any correlation method is specified, ``scf_basis`` can default; to ``corl_basis``. :type corl_basis: :ref:`basis string <apdx:basisElement>`; :param corl_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the correlation energy. :type delta_basis: :ref:`basis string <apdx:basisElement>`; :",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:57758,Energy Efficiency,energy,energy,57758,"a3_wfn_lesser: string; :param delta3_wfn_lesser: |dl| ``'mp2'`` |dr| || ``'ccsd(t)'`` || etc. Indicates the inferior energy method for which a third delta correction; to the correlation energy is to be obtained. :type delta4_wfn: string; :param delta4_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a fourth delta correction; to the correlation energy is to be obtained. :type delta4_wfn_lesser: string; :param delta4_wfn_lesser: |dl| ``'mp2'`` |dr| || ``'ccsd(t)'`` || etc. Indicates the inferior energy method for which a fourth delta correction; to the correlation energy is to be obtained. :type delta5_wfn: string; :param delta5_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a fifth delta correction; to the correlation energy is to be obtained. :type delta5_wfn_lesser: string; :param delta5_wfn_lesser: |dl| ``'mp2'`` |dr| || ``'ccsd(t)'`` || etc. Indicates the inferior energy method for which a fifth delta correction; to the correlation energy is to be obtained. * Basis Sets; Currently, the basis set set through ``set`` commands have no influence; on a cbs calculation. :type scf_basis: :ref:`basis string <apdx:basisElement>`; :param scf_basis: |dl| ``corl_basis`` |dr| || ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the reference energy.; If any correlation method is specified, ``scf_basis`` can default; to ``corl_basis``. :type corl_basis: :ref:`basis string <apdx:basisElement>`; :param corl_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the correlation energy. :type delta_basis: :ref:`basis string <apdx:basisElement>`; :param delta_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the delta correction; to the correlation energy. :type delta2_basis: :ref:`basis string ",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:57827,Energy Efficiency,energy,energy,57827,"a3_wfn_lesser: string; :param delta3_wfn_lesser: |dl| ``'mp2'`` |dr| || ``'ccsd(t)'`` || etc. Indicates the inferior energy method for which a third delta correction; to the correlation energy is to be obtained. :type delta4_wfn: string; :param delta4_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a fourth delta correction; to the correlation energy is to be obtained. :type delta4_wfn_lesser: string; :param delta4_wfn_lesser: |dl| ``'mp2'`` |dr| || ``'ccsd(t)'`` || etc. Indicates the inferior energy method for which a fourth delta correction; to the correlation energy is to be obtained. :type delta5_wfn: string; :param delta5_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a fifth delta correction; to the correlation energy is to be obtained. :type delta5_wfn_lesser: string; :param delta5_wfn_lesser: |dl| ``'mp2'`` |dr| || ``'ccsd(t)'`` || etc. Indicates the inferior energy method for which a fifth delta correction; to the correlation energy is to be obtained. * Basis Sets; Currently, the basis set set through ``set`` commands have no influence; on a cbs calculation. :type scf_basis: :ref:`basis string <apdx:basisElement>`; :param scf_basis: |dl| ``corl_basis`` |dr| || ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the reference energy.; If any correlation method is specified, ``scf_basis`` can default; to ``corl_basis``. :type corl_basis: :ref:`basis string <apdx:basisElement>`; :param corl_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the correlation energy. :type delta_basis: :ref:`basis string <apdx:basisElement>`; :param delta_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the delta correction; to the correlation energy. :type delta2_basis: :ref:`basis string ",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:58196,Energy Efficiency,energy,energy,58196,"e correlation energy is to be obtained. :type delta4_wfn_lesser: string; :param delta4_wfn_lesser: |dl| ``'mp2'`` |dr| || ``'ccsd(t)'`` || etc. Indicates the inferior energy method for which a fourth delta correction; to the correlation energy is to be obtained. :type delta5_wfn: string; :param delta5_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a fifth delta correction; to the correlation energy is to be obtained. :type delta5_wfn_lesser: string; :param delta5_wfn_lesser: |dl| ``'mp2'`` |dr| || ``'ccsd(t)'`` || etc. Indicates the inferior energy method for which a fifth delta correction; to the correlation energy is to be obtained. * Basis Sets; Currently, the basis set set through ``set`` commands have no influence; on a cbs calculation. :type scf_basis: :ref:`basis string <apdx:basisElement>`; :param scf_basis: |dl| ``corl_basis`` |dr| || ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the reference energy.; If any correlation method is specified, ``scf_basis`` can default; to ``corl_basis``. :type corl_basis: :ref:`basis string <apdx:basisElement>`; :param corl_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the correlation energy. :type delta_basis: :ref:`basis string <apdx:basisElement>`; :param delta_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the delta correction; to the correlation energy. :type delta2_basis: :ref:`basis string <apdx:basisElement>`; :param delta2_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the second delta correction; to the correlation energy. :type delta3_basis: :ref:`basis string <apdx:basisElement>`; :param delta3_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates t",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:58501,Energy Efficiency,energy,energy,58501,"fn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a fifth delta correction; to the correlation energy is to be obtained. :type delta5_wfn_lesser: string; :param delta5_wfn_lesser: |dl| ``'mp2'`` |dr| || ``'ccsd(t)'`` || etc. Indicates the inferior energy method for which a fifth delta correction; to the correlation energy is to be obtained. * Basis Sets; Currently, the basis set set through ``set`` commands have no influence; on a cbs calculation. :type scf_basis: :ref:`basis string <apdx:basisElement>`; :param scf_basis: |dl| ``corl_basis`` |dr| || ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the reference energy.; If any correlation method is specified, ``scf_basis`` can default; to ``corl_basis``. :type corl_basis: :ref:`basis string <apdx:basisElement>`; :param corl_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the correlation energy. :type delta_basis: :ref:`basis string <apdx:basisElement>`; :param delta_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the delta correction; to the correlation energy. :type delta2_basis: :ref:`basis string <apdx:basisElement>`; :param delta2_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the second delta correction; to the correlation energy. :type delta3_basis: :ref:`basis string <apdx:basisElement>`; :param delta3_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the third delta correction; to the correlation energy. :type delta4_basis: :ref:`basis string <apdx:basisElement>`; :param delta4_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the fourth d",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:58746,Energy Efficiency,energy,energy,58746,"` |dr| || ``'ccsd(t)'`` || etc. Indicates the inferior energy method for which a fifth delta correction; to the correlation energy is to be obtained. * Basis Sets; Currently, the basis set set through ``set`` commands have no influence; on a cbs calculation. :type scf_basis: :ref:`basis string <apdx:basisElement>`; :param scf_basis: |dl| ``corl_basis`` |dr| || ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the reference energy.; If any correlation method is specified, ``scf_basis`` can default; to ``corl_basis``. :type corl_basis: :ref:`basis string <apdx:basisElement>`; :param corl_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the correlation energy. :type delta_basis: :ref:`basis string <apdx:basisElement>`; :param delta_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the delta correction; to the correlation energy. :type delta2_basis: :ref:`basis string <apdx:basisElement>`; :param delta2_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the second delta correction; to the correlation energy. :type delta3_basis: :ref:`basis string <apdx:basisElement>`; :param delta3_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the third delta correction; to the correlation energy. :type delta4_basis: :ref:`basis string <apdx:basisElement>`; :param delta4_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the fourth delta correction; to the correlation energy. :type delta5_basis: :ref:`basis string <apdx:basisElement>`; :param delta5_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets empl",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:59000,Energy Efficiency,energy,energy,59000,"lation. :type scf_basis: :ref:`basis string <apdx:basisElement>`; :param scf_basis: |dl| ``corl_basis`` |dr| || ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the reference energy.; If any correlation method is specified, ``scf_basis`` can default; to ``corl_basis``. :type corl_basis: :ref:`basis string <apdx:basisElement>`; :param corl_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the correlation energy. :type delta_basis: :ref:`basis string <apdx:basisElement>`; :param delta_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the delta correction; to the correlation energy. :type delta2_basis: :ref:`basis string <apdx:basisElement>`; :param delta2_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the second delta correction; to the correlation energy. :type delta3_basis: :ref:`basis string <apdx:basisElement>`; :param delta3_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the third delta correction; to the correlation energy. :type delta4_basis: :ref:`basis string <apdx:basisElement>`; :param delta4_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the fourth delta correction; to the correlation energy. :type delta5_basis: :ref:`basis string <apdx:basisElement>`; :param delta5_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the fifth delta correction; to the correlation energy. * Schemes; Transformations of the energy through basis set extrapolation for each; stage of the CBS definition. A complaint is generated if number of basis; sets in stage_basis does not ",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:59253,Energy Efficiency,energy,energy,59253," any correlation method is specified, ``scf_basis`` can default; to ``corl_basis``. :type corl_basis: :ref:`basis string <apdx:basisElement>`; :param corl_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the correlation energy. :type delta_basis: :ref:`basis string <apdx:basisElement>`; :param delta_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the delta correction; to the correlation energy. :type delta2_basis: :ref:`basis string <apdx:basisElement>`; :param delta2_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the second delta correction; to the correlation energy. :type delta3_basis: :ref:`basis string <apdx:basisElement>`; :param delta3_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the third delta correction; to the correlation energy. :type delta4_basis: :ref:`basis string <apdx:basisElement>`; :param delta4_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the fourth delta correction; to the correlation energy. :type delta5_basis: :ref:`basis string <apdx:basisElement>`; :param delta5_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the fifth delta correction; to the correlation energy. * Schemes; Transformations of the energy through basis set extrapolation for each; stage of the CBS definition. A complaint is generated if number of basis; sets in stage_basis does not exactly satisfy requirements of stage_scheme.; An exception is the default, ``'highest_1'``, which uses the best basis; set available. See `Extrapolation Schemes`_ for all available schemes. :type scf_scheme: function; :param scf_scheme: |dl| ``highest_1",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:59507,Energy Efficiency,energy,energy,59507,"basis sets employed for the correlation energy. :type delta_basis: :ref:`basis string <apdx:basisElement>`; :param delta_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the delta correction; to the correlation energy. :type delta2_basis: :ref:`basis string <apdx:basisElement>`; :param delta2_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the second delta correction; to the correlation energy. :type delta3_basis: :ref:`basis string <apdx:basisElement>`; :param delta3_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the third delta correction; to the correlation energy. :type delta4_basis: :ref:`basis string <apdx:basisElement>`; :param delta4_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the fourth delta correction; to the correlation energy. :type delta5_basis: :ref:`basis string <apdx:basisElement>`; :param delta5_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the fifth delta correction; to the correlation energy. * Schemes; Transformations of the energy through basis set extrapolation for each; stage of the CBS definition. A complaint is generated if number of basis; sets in stage_basis does not exactly satisfy requirements of stage_scheme.; An exception is the default, ``'highest_1'``, which uses the best basis; set available. See `Extrapolation Schemes`_ for all available schemes. :type scf_scheme: function; :param scf_scheme: |dl| ``highest_1`` |dr| || ``scf_xtpl_helgaker_3`` || etc. Indicates the basis set extrapolation scheme to be applied to the reference energy. :type corl_scheme: function; :param corl_scheme: |dl| ``highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the bas",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:59760,Energy Efficiency,energy,energy,59760," correction; to the correlation energy. :type delta2_basis: :ref:`basis string <apdx:basisElement>`; :param delta2_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the second delta correction; to the correlation energy. :type delta3_basis: :ref:`basis string <apdx:basisElement>`; :param delta3_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the third delta correction; to the correlation energy. :type delta4_basis: :ref:`basis string <apdx:basisElement>`; :param delta4_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the fourth delta correction; to the correlation energy. :type delta5_basis: :ref:`basis string <apdx:basisElement>`; :param delta5_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the fifth delta correction; to the correlation energy. * Schemes; Transformations of the energy through basis set extrapolation for each; stage of the CBS definition. A complaint is generated if number of basis; sets in stage_basis does not exactly satisfy requirements of stage_scheme.; An exception is the default, ``'highest_1'``, which uses the best basis; set available. See `Extrapolation Schemes`_ for all available schemes. :type scf_scheme: function; :param scf_scheme: |dl| ``highest_1`` |dr| || ``scf_xtpl_helgaker_3`` || etc. Indicates the basis set extrapolation scheme to be applied to the reference energy. :type corl_scheme: function; :param corl_scheme: |dl| ``highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the correlation energy. :type delta_scheme: function; :param delta_scheme: |dl| ``highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the delta co",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:59802,Energy Efficiency,energy,energy,59802,"elta2_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the second delta correction; to the correlation energy. :type delta3_basis: :ref:`basis string <apdx:basisElement>`; :param delta3_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the third delta correction; to the correlation energy. :type delta4_basis: :ref:`basis string <apdx:basisElement>`; :param delta4_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the fourth delta correction; to the correlation energy. :type delta5_basis: :ref:`basis string <apdx:basisElement>`; :param delta5_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the fifth delta correction; to the correlation energy. * Schemes; Transformations of the energy through basis set extrapolation for each; stage of the CBS definition. A complaint is generated if number of basis; sets in stage_basis does not exactly satisfy requirements of stage_scheme.; An exception is the default, ``'highest_1'``, which uses the best basis; set available. See `Extrapolation Schemes`_ for all available schemes. :type scf_scheme: function; :param scf_scheme: |dl| ``highest_1`` |dr| || ``scf_xtpl_helgaker_3`` || etc. Indicates the basis set extrapolation scheme to be applied to the reference energy. :type corl_scheme: function; :param corl_scheme: |dl| ``highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the correlation energy. :type delta_scheme: function; :param delta_scheme: |dl| ``highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the delta correction; to the correlation energy. :type delta2_scheme: function; :param delta2_scheme: |dl| ``highest_1``",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:60327,Energy Efficiency,energy,energy,60327," string <apdx:basisElement>`; :param delta4_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the fourth delta correction; to the correlation energy. :type delta5_basis: :ref:`basis string <apdx:basisElement>`; :param delta5_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the fifth delta correction; to the correlation energy. * Schemes; Transformations of the energy through basis set extrapolation for each; stage of the CBS definition. A complaint is generated if number of basis; sets in stage_basis does not exactly satisfy requirements of stage_scheme.; An exception is the default, ``'highest_1'``, which uses the best basis; set available. See `Extrapolation Schemes`_ for all available schemes. :type scf_scheme: function; :param scf_scheme: |dl| ``highest_1`` |dr| || ``scf_xtpl_helgaker_3`` || etc. Indicates the basis set extrapolation scheme to be applied to the reference energy. :type corl_scheme: function; :param corl_scheme: |dl| ``highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the correlation energy. :type delta_scheme: function; :param delta_scheme: |dl| ``highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the delta correction; to the correlation energy. :type delta2_scheme: function; :param delta2_scheme: |dl| ``highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the second delta correction; to the correlation energy. :type delta3_scheme: function; :param delta3_scheme: |dl| ``highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the third delta correction; to the correlation energy. :type delta4_scheme: function; :param delta4_scheme: |dl| ``highest_1`` |dr| ||",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:60522,Energy Efficiency,energy,energy,60522,"; to the correlation energy. :type delta5_basis: :ref:`basis string <apdx:basisElement>`; :param delta5_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the fifth delta correction; to the correlation energy. * Schemes; Transformations of the energy through basis set extrapolation for each; stage of the CBS definition. A complaint is generated if number of basis; sets in stage_basis does not exactly satisfy requirements of stage_scheme.; An exception is the default, ``'highest_1'``, which uses the best basis; set available. See `Extrapolation Schemes`_ for all available schemes. :type scf_scheme: function; :param scf_scheme: |dl| ``highest_1`` |dr| || ``scf_xtpl_helgaker_3`` || etc. Indicates the basis set extrapolation scheme to be applied to the reference energy. :type corl_scheme: function; :param corl_scheme: |dl| ``highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the correlation energy. :type delta_scheme: function; :param delta_scheme: |dl| ``highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the delta correction; to the correlation energy. :type delta2_scheme: function; :param delta2_scheme: |dl| ``highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the second delta correction; to the correlation energy. :type delta3_scheme: function; :param delta3_scheme: |dl| ``highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the third delta correction; to the correlation energy. :type delta4_scheme: function; :param delta4_scheme: |dl| ``highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the fourth delta correction; to the correlation energy. :type delta5_scheme: function; :param delt",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:60744,Energy Efficiency,energy,energy,60744,"sets employed for the fifth delta correction; to the correlation energy. * Schemes; Transformations of the energy through basis set extrapolation for each; stage of the CBS definition. A complaint is generated if number of basis; sets in stage_basis does not exactly satisfy requirements of stage_scheme.; An exception is the default, ``'highest_1'``, which uses the best basis; set available. See `Extrapolation Schemes`_ for all available schemes. :type scf_scheme: function; :param scf_scheme: |dl| ``highest_1`` |dr| || ``scf_xtpl_helgaker_3`` || etc. Indicates the basis set extrapolation scheme to be applied to the reference energy. :type corl_scheme: function; :param corl_scheme: |dl| ``highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the correlation energy. :type delta_scheme: function; :param delta_scheme: |dl| ``highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the delta correction; to the correlation energy. :type delta2_scheme: function; :param delta2_scheme: |dl| ``highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the second delta correction; to the correlation energy. :type delta3_scheme: function; :param delta3_scheme: |dl| ``highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the third delta correction; to the correlation energy. :type delta4_scheme: function; :param delta4_scheme: |dl| ``highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the fourth delta correction; to the correlation energy. :type delta5_scheme: function; :param delta5_scheme: |dl| ``highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the fifth delta correction; to the correlation energy. :type molecule: :ref:`",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:60975,Energy Efficiency,energy,energy,60975,"; sets in stage_basis does not exactly satisfy requirements of stage_scheme.; An exception is the default, ``'highest_1'``, which uses the best basis; set available. See `Extrapolation Schemes`_ for all available schemes. :type scf_scheme: function; :param scf_scheme: |dl| ``highest_1`` |dr| || ``scf_xtpl_helgaker_3`` || etc. Indicates the basis set extrapolation scheme to be applied to the reference energy. :type corl_scheme: function; :param corl_scheme: |dl| ``highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the correlation energy. :type delta_scheme: function; :param delta_scheme: |dl| ``highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the delta correction; to the correlation energy. :type delta2_scheme: function; :param delta2_scheme: |dl| ``highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the second delta correction; to the correlation energy. :type delta3_scheme: function; :param delta3_scheme: |dl| ``highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the third delta correction; to the correlation energy. :type delta4_scheme: function; :param delta4_scheme: |dl| ``highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the fourth delta correction; to the correlation energy. :type delta5_scheme: function; :param delta5_scheme: |dl| ``highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the fifth delta correction; to the correlation energy. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :examples:. >>> # [1] replicates with cbs() the simple model chemistry scf/cc-pVDZ: set basis cc-pVDZ energy('s",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:61205,Energy Efficiency,energy,energy,61205,"f_scheme: function; :param scf_scheme: |dl| ``highest_1`` |dr| || ``scf_xtpl_helgaker_3`` || etc. Indicates the basis set extrapolation scheme to be applied to the reference energy. :type corl_scheme: function; :param corl_scheme: |dl| ``highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the correlation energy. :type delta_scheme: function; :param delta_scheme: |dl| ``highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the delta correction; to the correlation energy. :type delta2_scheme: function; :param delta2_scheme: |dl| ``highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the second delta correction; to the correlation energy. :type delta3_scheme: function; :param delta3_scheme: |dl| ``highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the third delta correction; to the correlation energy. :type delta4_scheme: function; :param delta4_scheme: |dl| ``highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the fourth delta correction; to the correlation energy. :type delta5_scheme: function; :param delta5_scheme: |dl| ``highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the fifth delta correction; to the correlation energy. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :examples:. >>> # [1] replicates with cbs() the simple model chemistry scf/cc-pVDZ: set basis cc-pVDZ energy('scf'); >>> cbs('scf', scf_basis='cc-pVDZ'). >>> # [2] replicates with cbs() the simple model chemistry mp2/jun-cc-pVDZ: set basis jun-cc-pVDZ energy('mp2'); >>> cbs('mp2', corl_basis='jun-cc-pVDZ'). >>> # [3] DTQ-zeta extrapolated s",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:61436,Energy Efficiency,energy,energy,61436,"|dl| ``highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the correlation energy. :type delta_scheme: function; :param delta_scheme: |dl| ``highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the delta correction; to the correlation energy. :type delta2_scheme: function; :param delta2_scheme: |dl| ``highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the second delta correction; to the correlation energy. :type delta3_scheme: function; :param delta3_scheme: |dl| ``highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the third delta correction; to the correlation energy. :type delta4_scheme: function; :param delta4_scheme: |dl| ``highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the fourth delta correction; to the correlation energy. :type delta5_scheme: function; :param delta5_scheme: |dl| ``highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the fifth delta correction; to the correlation energy. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :examples:. >>> # [1] replicates with cbs() the simple model chemistry scf/cc-pVDZ: set basis cc-pVDZ energy('scf'); >>> cbs('scf', scf_basis='cc-pVDZ'). >>> # [2] replicates with cbs() the simple model chemistry mp2/jun-cc-pVDZ: set basis jun-cc-pVDZ energy('mp2'); >>> cbs('mp2', corl_basis='jun-cc-pVDZ'). >>> # [3] DTQ-zeta extrapolated scf reference energy; >>> cbs('scf', scf_basis='cc-pV[DTQ]Z', scf_scheme=scf_xtpl_helgaker_3). >>> # [4] DT-zeta extrapolated mp2 correlation energy atop a T-zeta reference; >>> cbs('mp2', corl_basis='cc-pv[dt]z', corl_scheme=corl_",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:61666,Energy Efficiency,energy,energy,61666,"_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the delta correction; to the correlation energy. :type delta2_scheme: function; :param delta2_scheme: |dl| ``highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the second delta correction; to the correlation energy. :type delta3_scheme: function; :param delta3_scheme: |dl| ``highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the third delta correction; to the correlation energy. :type delta4_scheme: function; :param delta4_scheme: |dl| ``highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the fourth delta correction; to the correlation energy. :type delta5_scheme: function; :param delta5_scheme: |dl| ``highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the fifth delta correction; to the correlation energy. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :examples:. >>> # [1] replicates with cbs() the simple model chemistry scf/cc-pVDZ: set basis cc-pVDZ energy('scf'); >>> cbs('scf', scf_basis='cc-pVDZ'). >>> # [2] replicates with cbs() the simple model chemistry mp2/jun-cc-pVDZ: set basis jun-cc-pVDZ energy('mp2'); >>> cbs('mp2', corl_basis='jun-cc-pVDZ'). >>> # [3] DTQ-zeta extrapolated scf reference energy; >>> cbs('scf', scf_basis='cc-pV[DTQ]Z', scf_scheme=scf_xtpl_helgaker_3). >>> # [4] DT-zeta extrapolated mp2 correlation energy atop a T-zeta reference; >>> cbs('mp2', corl_basis='cc-pv[dt]z', corl_scheme=corl_xtpl_helgaker_2). >>> # [5] a DT-zeta extrapolated coupled-cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >>> cbs('mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2,",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:61914,Energy Efficiency,energy,energy,61914,"polation scheme to be applied to the second delta correction; to the correlation energy. :type delta3_scheme: function; :param delta3_scheme: |dl| ``highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the third delta correction; to the correlation energy. :type delta4_scheme: function; :param delta4_scheme: |dl| ``highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the fourth delta correction; to the correlation energy. :type delta5_scheme: function; :param delta5_scheme: |dl| ``highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the fifth delta correction; to the correlation energy. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :examples:. >>> # [1] replicates with cbs() the simple model chemistry scf/cc-pVDZ: set basis cc-pVDZ energy('scf'); >>> cbs('scf', scf_basis='cc-pVDZ'). >>> # [2] replicates with cbs() the simple model chemistry mp2/jun-cc-pVDZ: set basis jun-cc-pVDZ energy('mp2'); >>> cbs('mp2', corl_basis='jun-cc-pVDZ'). >>> # [3] DTQ-zeta extrapolated scf reference energy; >>> cbs('scf', scf_basis='cc-pV[DTQ]Z', scf_scheme=scf_xtpl_helgaker_3). >>> # [4] DT-zeta extrapolated mp2 correlation energy atop a T-zeta reference; >>> cbs('mp2', corl_basis='cc-pv[dt]z', corl_scheme=corl_xtpl_helgaker_2). >>> # [5] a DT-zeta extrapolated coupled-cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >>> cbs('mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2). >>> # [6] a D-zeta ccsd(t) correction atop a DT-zeta extrapolated ccsd cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >>> cbs('mp2', corl_basis",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:62064,Energy Efficiency,energy,energy,62064,"`highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the third delta correction; to the correlation energy. :type delta4_scheme: function; :param delta4_scheme: |dl| ``highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the fourth delta correction; to the correlation energy. :type delta5_scheme: function; :param delta5_scheme: |dl| ``highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the fifth delta correction; to the correlation energy. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :examples:. >>> # [1] replicates with cbs() the simple model chemistry scf/cc-pVDZ: set basis cc-pVDZ energy('scf'); >>> cbs('scf', scf_basis='cc-pVDZ'). >>> # [2] replicates with cbs() the simple model chemistry mp2/jun-cc-pVDZ: set basis jun-cc-pVDZ energy('mp2'); >>> cbs('mp2', corl_basis='jun-cc-pVDZ'). >>> # [3] DTQ-zeta extrapolated scf reference energy; >>> cbs('scf', scf_basis='cc-pV[DTQ]Z', scf_scheme=scf_xtpl_helgaker_3). >>> # [4] DT-zeta extrapolated mp2 correlation energy atop a T-zeta reference; >>> cbs('mp2', corl_basis='cc-pv[dt]z', corl_scheme=corl_xtpl_helgaker_2). >>> # [5] a DT-zeta extrapolated coupled-cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >>> cbs('mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2). >>> # [6] a D-zeta ccsd(t) correction atop a DT-zeta extrapolated ccsd cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >>> cbs('mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2, delta2_wfn='c",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:62167,Energy Efficiency,energy,energy,62167,"n; to the correlation energy. :type delta4_scheme: function; :param delta4_scheme: |dl| ``highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the fourth delta correction; to the correlation energy. :type delta5_scheme: function; :param delta5_scheme: |dl| ``highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the fifth delta correction; to the correlation energy. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :examples:. >>> # [1] replicates with cbs() the simple model chemistry scf/cc-pVDZ: set basis cc-pVDZ energy('scf'); >>> cbs('scf', scf_basis='cc-pVDZ'). >>> # [2] replicates with cbs() the simple model chemistry mp2/jun-cc-pVDZ: set basis jun-cc-pVDZ energy('mp2'); >>> cbs('mp2', corl_basis='jun-cc-pVDZ'). >>> # [3] DTQ-zeta extrapolated scf reference energy; >>> cbs('scf', scf_basis='cc-pV[DTQ]Z', scf_scheme=scf_xtpl_helgaker_3). >>> # [4] DT-zeta extrapolated mp2 correlation energy atop a T-zeta reference; >>> cbs('mp2', corl_basis='cc-pv[dt]z', corl_scheme=corl_xtpl_helgaker_2). >>> # [5] a DT-zeta extrapolated coupled-cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >>> cbs('mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2). >>> # [6] a D-zeta ccsd(t) correction atop a DT-zeta extrapolated ccsd cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >>> cbs('mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2, delta2_wfn='ccsd(t)', delta2_wfn_lesser='ccsd', delta2_basis='aug-cc-pvdz'). >>> # [7] cbs() coupled with database(); >>> database('mp2', 'BASIC', subset=",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:62295,Energy Efficiency,energy,energy,62295,". Indicates the basis set extrapolation scheme to be applied to the fourth delta correction; to the correlation energy. :type delta5_scheme: function; :param delta5_scheme: |dl| ``highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the fifth delta correction; to the correlation energy. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :examples:. >>> # [1] replicates with cbs() the simple model chemistry scf/cc-pVDZ: set basis cc-pVDZ energy('scf'); >>> cbs('scf', scf_basis='cc-pVDZ'). >>> # [2] replicates with cbs() the simple model chemistry mp2/jun-cc-pVDZ: set basis jun-cc-pVDZ energy('mp2'); >>> cbs('mp2', corl_basis='jun-cc-pVDZ'). >>> # [3] DTQ-zeta extrapolated scf reference energy; >>> cbs('scf', scf_basis='cc-pV[DTQ]Z', scf_scheme=scf_xtpl_helgaker_3). >>> # [4] DT-zeta extrapolated mp2 correlation energy atop a T-zeta reference; >>> cbs('mp2', corl_basis='cc-pv[dt]z', corl_scheme=corl_xtpl_helgaker_2). >>> # [5] a DT-zeta extrapolated coupled-cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >>> cbs('mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2). >>> # [6] a D-zeta ccsd(t) correction atop a DT-zeta extrapolated ccsd cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >>> cbs('mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2, delta2_wfn='ccsd(t)', delta2_wfn_lesser='ccsd', delta2_basis='aug-cc-pvdz'). >>> # [7] cbs() coupled with database(); >>> database('mp2', 'BASIC', subset=['h2o','nh3'], symm='on', func=cbs, corl_basis='cc-pV[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='sto-3g'). >",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:62506,Energy Efficiency,energy,energy,62506," etc. Indicates the basis set extrapolation scheme to be applied to the fifth delta correction; to the correlation energy. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :examples:. >>> # [1] replicates with cbs() the simple model chemistry scf/cc-pVDZ: set basis cc-pVDZ energy('scf'); >>> cbs('scf', scf_basis='cc-pVDZ'). >>> # [2] replicates with cbs() the simple model chemistry mp2/jun-cc-pVDZ: set basis jun-cc-pVDZ energy('mp2'); >>> cbs('mp2', corl_basis='jun-cc-pVDZ'). >>> # [3] DTQ-zeta extrapolated scf reference energy; >>> cbs('scf', scf_basis='cc-pV[DTQ]Z', scf_scheme=scf_xtpl_helgaker_3). >>> # [4] DT-zeta extrapolated mp2 correlation energy atop a T-zeta reference; >>> cbs('mp2', corl_basis='cc-pv[dt]z', corl_scheme=corl_xtpl_helgaker_2). >>> # [5] a DT-zeta extrapolated coupled-cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >>> cbs('mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2). >>> # [6] a D-zeta ccsd(t) correction atop a DT-zeta extrapolated ccsd cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >>> cbs('mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2, delta2_wfn='ccsd(t)', delta2_wfn_lesser='ccsd', delta2_basis='aug-cc-pvdz'). >>> # [7] cbs() coupled with database(); >>> database('mp2', 'BASIC', subset=['h2o','nh3'], symm='on', func=cbs, corl_basis='cc-pV[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='sto-3g'). >>> # [8] cbs() coupled with optimize(); >>> optimize('mp2', corl_basis='cc-pV[DT]Z', corl_scheme=corl_xtpl_helgaker_2, func=cbs). """"""; lowername = name.lower(); kwargs = p4util.kwargs_lower(kwargs). # Wrap any positional argumen",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:62837,Energy Efficiency,energy,energy,62837,"s cc-pVDZ energy('scf'); >>> cbs('scf', scf_basis='cc-pVDZ'). >>> # [2] replicates with cbs() the simple model chemistry mp2/jun-cc-pVDZ: set basis jun-cc-pVDZ energy('mp2'); >>> cbs('mp2', corl_basis='jun-cc-pVDZ'). >>> # [3] DTQ-zeta extrapolated scf reference energy; >>> cbs('scf', scf_basis='cc-pV[DTQ]Z', scf_scheme=scf_xtpl_helgaker_3). >>> # [4] DT-zeta extrapolated mp2 correlation energy atop a T-zeta reference; >>> cbs('mp2', corl_basis='cc-pv[dt]z', corl_scheme=corl_xtpl_helgaker_2). >>> # [5] a DT-zeta extrapolated coupled-cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >>> cbs('mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2). >>> # [6] a D-zeta ccsd(t) correction atop a DT-zeta extrapolated ccsd cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >>> cbs('mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2, delta2_wfn='ccsd(t)', delta2_wfn_lesser='ccsd', delta2_basis='aug-cc-pvdz'). >>> # [7] cbs() coupled with database(); >>> database('mp2', 'BASIC', subset=['h2o','nh3'], symm='on', func=cbs, corl_basis='cc-pV[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='sto-3g'). >>> # [8] cbs() coupled with optimize(); >>> optimize('mp2', corl_basis='cc-pV[DT]Z', corl_scheme=corl_xtpl_helgaker_2, func=cbs). """"""; lowername = name.lower(); kwargs = p4util.kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name.lower(). # Establish function to call (only energy makes sense for cbs); if not('cbs_func' in kwargs):; if ('func' in kwargs):; kwargs['cbs_func'] = kwargs['func']; del kwargs['func']; else:; kwargs['cbs_func'] = energy; func = kwargs['cbs_func']",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:63702,Energy Efficiency,energy,energy,63702,"gy atop a Q-zeta reference; >>> cbs('mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2, delta2_wfn='ccsd(t)', delta2_wfn_lesser='ccsd', delta2_basis='aug-cc-pvdz'). >>> # [7] cbs() coupled with database(); >>> database('mp2', 'BASIC', subset=['h2o','nh3'], symm='on', func=cbs, corl_basis='cc-pV[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='sto-3g'). >>> # [8] cbs() coupled with optimize(); >>> optimize('mp2', corl_basis='cc-pV[DT]Z', corl_scheme=corl_xtpl_helgaker_2, func=cbs). """"""; lowername = name.lower(); kwargs = p4util.kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name.lower(). # Establish function to call (only energy makes sense for cbs); if not('cbs_func' in kwargs):; if ('func' in kwargs):; kwargs['cbs_func'] = kwargs['func']; del kwargs['func']; else:; kwargs['cbs_func'] = energy; func = kwargs['cbs_func']; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper complete_basis_set.' % (func.__name__)); if not(func is energy):; raise ValidationError('Wrapper complete_basis_set is unhappy to be calling function \'%s\' instead of \'energy\'.' % (func.__name__)). # Define some quantum chemical knowledge, namely what methods are subsumed in others; VARH = {}; VARH['scf'] = { 'scftot': 'SCF TOTAL ENERGY'}; VARH['oldmp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'oldmp2corl': 'MP2 CORRELATION ENERGY'}; VARH['mp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY'}; VARH['mp2.5'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY'}; VARH['mp3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION E",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:63871,Energy Efficiency,energy,energy,63871,"gy atop a Q-zeta reference; >>> cbs('mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2, delta2_wfn='ccsd(t)', delta2_wfn_lesser='ccsd', delta2_basis='aug-cc-pvdz'). >>> # [7] cbs() coupled with database(); >>> database('mp2', 'BASIC', subset=['h2o','nh3'], symm='on', func=cbs, corl_basis='cc-pV[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='sto-3g'). >>> # [8] cbs() coupled with optimize(); >>> optimize('mp2', corl_basis='cc-pV[DT]Z', corl_scheme=corl_xtpl_helgaker_2, func=cbs). """"""; lowername = name.lower(); kwargs = p4util.kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name.lower(). # Establish function to call (only energy makes sense for cbs); if not('cbs_func' in kwargs):; if ('func' in kwargs):; kwargs['cbs_func'] = kwargs['func']; del kwargs['func']; else:; kwargs['cbs_func'] = energy; func = kwargs['cbs_func']; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper complete_basis_set.' % (func.__name__)); if not(func is energy):; raise ValidationError('Wrapper complete_basis_set is unhappy to be calling function \'%s\' instead of \'energy\'.' % (func.__name__)). # Define some quantum chemical knowledge, namely what methods are subsumed in others; VARH = {}; VARH['scf'] = { 'scftot': 'SCF TOTAL ENERGY'}; VARH['oldmp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'oldmp2corl': 'MP2 CORRELATION ENERGY'}; VARH['mp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY'}; VARH['mp2.5'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY'}; VARH['mp3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION E",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:64054,Energy Efficiency,energy,energy,64054,"z'). >>> # [7] cbs() coupled with database(); >>> database('mp2', 'BASIC', subset=['h2o','nh3'], symm='on', func=cbs, corl_basis='cc-pV[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='sto-3g'). >>> # [8] cbs() coupled with optimize(); >>> optimize('mp2', corl_basis='cc-pV[DT]Z', corl_scheme=corl_xtpl_helgaker_2, func=cbs). """"""; lowername = name.lower(); kwargs = p4util.kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name.lower(). # Establish function to call (only energy makes sense for cbs); if not('cbs_func' in kwargs):; if ('func' in kwargs):; kwargs['cbs_func'] = kwargs['func']; del kwargs['func']; else:; kwargs['cbs_func'] = energy; func = kwargs['cbs_func']; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper complete_basis_set.' % (func.__name__)); if not(func is energy):; raise ValidationError('Wrapper complete_basis_set is unhappy to be calling function \'%s\' instead of \'energy\'.' % (func.__name__)). # Define some quantum chemical knowledge, namely what methods are subsumed in others; VARH = {}; VARH['scf'] = { 'scftot': 'SCF TOTAL ENERGY'}; VARH['oldmp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'oldmp2corl': 'MP2 CORRELATION ENERGY'}; VARH['mp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY'}; VARH['mp2.5'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY'}; VARH['mp3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY'}; VARH['mp4(sdq)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY'}; VARH['mp4'] = { 'scftot': 'SCF TO",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:64168,Energy Efficiency,energy,energy,64168,"z'). >>> # [7] cbs() coupled with database(); >>> database('mp2', 'BASIC', subset=['h2o','nh3'], symm='on', func=cbs, corl_basis='cc-pV[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='sto-3g'). >>> # [8] cbs() coupled with optimize(); >>> optimize('mp2', corl_basis='cc-pV[DT]Z', corl_scheme=corl_xtpl_helgaker_2, func=cbs). """"""; lowername = name.lower(); kwargs = p4util.kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name.lower(). # Establish function to call (only energy makes sense for cbs); if not('cbs_func' in kwargs):; if ('func' in kwargs):; kwargs['cbs_func'] = kwargs['func']; del kwargs['func']; else:; kwargs['cbs_func'] = energy; func = kwargs['cbs_func']; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper complete_basis_set.' % (func.__name__)); if not(func is energy):; raise ValidationError('Wrapper complete_basis_set is unhappy to be calling function \'%s\' instead of \'energy\'.' % (func.__name__)). # Define some quantum chemical knowledge, namely what methods are subsumed in others; VARH = {}; VARH['scf'] = { 'scftot': 'SCF TOTAL ENERGY'}; VARH['oldmp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'oldmp2corl': 'MP2 CORRELATION ENERGY'}; VARH['mp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY'}; VARH['mp2.5'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY'}; VARH['mp3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY'}; VARH['mp4(sdq)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY'}; VARH['mp4'] = { 'scftot': 'SCF TO",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:64333,Energy Efficiency,ENERGY,ENERGY,64333," >>> optimize('mp2', corl_basis='cc-pV[DT]Z', corl_scheme=corl_xtpl_helgaker_2, func=cbs). """"""; lowername = name.lower(); kwargs = p4util.kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name.lower(). # Establish function to call (only energy makes sense for cbs); if not('cbs_func' in kwargs):; if ('func' in kwargs):; kwargs['cbs_func'] = kwargs['func']; del kwargs['func']; else:; kwargs['cbs_func'] = energy; func = kwargs['cbs_func']; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper complete_basis_set.' % (func.__name__)); if not(func is energy):; raise ValidationError('Wrapper complete_basis_set is unhappy to be calling function \'%s\' instead of \'energy\'.' % (func.__name__)). # Define some quantum chemical knowledge, namely what methods are subsumed in others; VARH = {}; VARH['scf'] = { 'scftot': 'SCF TOTAL ENERGY'}; VARH['oldmp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'oldmp2corl': 'MP2 CORRELATION ENERGY'}; VARH['mp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY'}; VARH['mp2.5'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY'}; VARH['mp3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY'}; VARH['mp4(sdq)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY'}; VARH['mp4'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'mp4corl': 'MP4(SDTQ) CORRELATION ENERGY'}; VARH['omp2'] = { 'scftot': 'SCF TOTAL ",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:64383,Energy Efficiency,ENERGY,ENERGY,64383," >>> optimize('mp2', corl_basis='cc-pV[DT]Z', corl_scheme=corl_xtpl_helgaker_2, func=cbs). """"""; lowername = name.lower(); kwargs = p4util.kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name.lower(). # Establish function to call (only energy makes sense for cbs); if not('cbs_func' in kwargs):; if ('func' in kwargs):; kwargs['cbs_func'] = kwargs['func']; del kwargs['func']; else:; kwargs['cbs_func'] = energy; func = kwargs['cbs_func']; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper complete_basis_set.' % (func.__name__)); if not(func is energy):; raise ValidationError('Wrapper complete_basis_set is unhappy to be calling function \'%s\' instead of \'energy\'.' % (func.__name__)). # Define some quantum chemical knowledge, namely what methods are subsumed in others; VARH = {}; VARH['scf'] = { 'scftot': 'SCF TOTAL ENERGY'}; VARH['oldmp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'oldmp2corl': 'MP2 CORRELATION ENERGY'}; VARH['mp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY'}; VARH['mp2.5'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY'}; VARH['mp3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY'}; VARH['mp4(sdq)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY'}; VARH['mp4'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'mp4corl': 'MP4(SDTQ) CORRELATION ENERGY'}; VARH['omp2'] = { 'scftot': 'SCF TOTAL ",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:64424,Energy Efficiency,ENERGY,ENERGY,64424," >>> optimize('mp2', corl_basis='cc-pV[DT]Z', corl_scheme=corl_xtpl_helgaker_2, func=cbs). """"""; lowername = name.lower(); kwargs = p4util.kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name.lower(). # Establish function to call (only energy makes sense for cbs); if not('cbs_func' in kwargs):; if ('func' in kwargs):; kwargs['cbs_func'] = kwargs['func']; del kwargs['func']; else:; kwargs['cbs_func'] = energy; func = kwargs['cbs_func']; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper complete_basis_set.' % (func.__name__)); if not(func is energy):; raise ValidationError('Wrapper complete_basis_set is unhappy to be calling function \'%s\' instead of \'energy\'.' % (func.__name__)). # Define some quantum chemical knowledge, namely what methods are subsumed in others; VARH = {}; VARH['scf'] = { 'scftot': 'SCF TOTAL ENERGY'}; VARH['oldmp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'oldmp2corl': 'MP2 CORRELATION ENERGY'}; VARH['mp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY'}; VARH['mp2.5'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY'}; VARH['mp3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY'}; VARH['mp4(sdq)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY'}; VARH['mp4'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'mp4corl': 'MP4(SDTQ) CORRELATION ENERGY'}; VARH['omp2'] = { 'scftot': 'SCF TOTAL ",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:64471,Energy Efficiency,ENERGY,ENERGY,64471," >>> optimize('mp2', corl_basis='cc-pV[DT]Z', corl_scheme=corl_xtpl_helgaker_2, func=cbs). """"""; lowername = name.lower(); kwargs = p4util.kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name.lower(). # Establish function to call (only energy makes sense for cbs); if not('cbs_func' in kwargs):; if ('func' in kwargs):; kwargs['cbs_func'] = kwargs['func']; del kwargs['func']; else:; kwargs['cbs_func'] = energy; func = kwargs['cbs_func']; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper complete_basis_set.' % (func.__name__)); if not(func is energy):; raise ValidationError('Wrapper complete_basis_set is unhappy to be calling function \'%s\' instead of \'energy\'.' % (func.__name__)). # Define some quantum chemical knowledge, namely what methods are subsumed in others; VARH = {}; VARH['scf'] = { 'scftot': 'SCF TOTAL ENERGY'}; VARH['oldmp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'oldmp2corl': 'MP2 CORRELATION ENERGY'}; VARH['mp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY'}; VARH['mp2.5'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY'}; VARH['mp3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY'}; VARH['mp4(sdq)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY'}; VARH['mp4'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'mp4corl': 'MP4(SDTQ) CORRELATION ENERGY'}; VARH['omp2'] = { 'scftot': 'SCF TOTAL ",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:64509,Energy Efficiency,ENERGY,ENERGY,64509," >>> optimize('mp2', corl_basis='cc-pV[DT]Z', corl_scheme=corl_xtpl_helgaker_2, func=cbs). """"""; lowername = name.lower(); kwargs = p4util.kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name.lower(). # Establish function to call (only energy makes sense for cbs); if not('cbs_func' in kwargs):; if ('func' in kwargs):; kwargs['cbs_func'] = kwargs['func']; del kwargs['func']; else:; kwargs['cbs_func'] = energy; func = kwargs['cbs_func']; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper complete_basis_set.' % (func.__name__)); if not(func is energy):; raise ValidationError('Wrapper complete_basis_set is unhappy to be calling function \'%s\' instead of \'energy\'.' % (func.__name__)). # Define some quantum chemical knowledge, namely what methods are subsumed in others; VARH = {}; VARH['scf'] = { 'scftot': 'SCF TOTAL ENERGY'}; VARH['oldmp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'oldmp2corl': 'MP2 CORRELATION ENERGY'}; VARH['mp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY'}; VARH['mp2.5'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY'}; VARH['mp3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY'}; VARH['mp4(sdq)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY'}; VARH['mp4'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'mp4corl': 'MP4(SDTQ) CORRELATION ENERGY'}; VARH['omp2'] = { 'scftot': 'SCF TOTAL ",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:64558,Energy Efficiency,ENERGY,ENERGY,64558,"r intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name.lower(). # Establish function to call (only energy makes sense for cbs); if not('cbs_func' in kwargs):; if ('func' in kwargs):; kwargs['cbs_func'] = kwargs['func']; del kwargs['func']; else:; kwargs['cbs_func'] = energy; func = kwargs['cbs_func']; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper complete_basis_set.' % (func.__name__)); if not(func is energy):; raise ValidationError('Wrapper complete_basis_set is unhappy to be calling function \'%s\' instead of \'energy\'.' % (func.__name__)). # Define some quantum chemical knowledge, namely what methods are subsumed in others; VARH = {}; VARH['scf'] = { 'scftot': 'SCF TOTAL ENERGY'}; VARH['oldmp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'oldmp2corl': 'MP2 CORRELATION ENERGY'}; VARH['mp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY'}; VARH['mp2.5'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY'}; VARH['mp3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY'}; VARH['mp4(sdq)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY'}; VARH['mp4'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'mp4corl': 'MP4(SDTQ) CORRELATION ENERGY'}; VARH['omp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'omp2corl': 'OMP2 CORRELATION ENERGY'}; VARH['omp3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENER",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:64596,Energy Efficiency,ENERGY,ENERGY,64596,"r intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name.lower(). # Establish function to call (only energy makes sense for cbs); if not('cbs_func' in kwargs):; if ('func' in kwargs):; kwargs['cbs_func'] = kwargs['func']; del kwargs['func']; else:; kwargs['cbs_func'] = energy; func = kwargs['cbs_func']; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper complete_basis_set.' % (func.__name__)); if not(func is energy):; raise ValidationError('Wrapper complete_basis_set is unhappy to be calling function \'%s\' instead of \'energy\'.' % (func.__name__)). # Define some quantum chemical knowledge, namely what methods are subsumed in others; VARH = {}; VARH['scf'] = { 'scftot': 'SCF TOTAL ENERGY'}; VARH['oldmp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'oldmp2corl': 'MP2 CORRELATION ENERGY'}; VARH['mp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY'}; VARH['mp2.5'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY'}; VARH['mp3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY'}; VARH['mp4(sdq)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY'}; VARH['mp4'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'mp4corl': 'MP4(SDTQ) CORRELATION ENERGY'}; VARH['omp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'omp2corl': 'OMP2 CORRELATION ENERGY'}; VARH['omp3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENER",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:64638,Energy Efficiency,ENERGY,ENERGY,64638,"y energy makes sense for cbs); if not('cbs_func' in kwargs):; if ('func' in kwargs):; kwargs['cbs_func'] = kwargs['func']; del kwargs['func']; else:; kwargs['cbs_func'] = energy; func = kwargs['cbs_func']; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper complete_basis_set.' % (func.__name__)); if not(func is energy):; raise ValidationError('Wrapper complete_basis_set is unhappy to be calling function \'%s\' instead of \'energy\'.' % (func.__name__)). # Define some quantum chemical knowledge, namely what methods are subsumed in others; VARH = {}; VARH['scf'] = { 'scftot': 'SCF TOTAL ENERGY'}; VARH['oldmp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'oldmp2corl': 'MP2 CORRELATION ENERGY'}; VARH['mp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY'}; VARH['mp2.5'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY'}; VARH['mp3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY'}; VARH['mp4(sdq)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY'}; VARH['mp4'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'mp4corl': 'MP4(SDTQ) CORRELATION ENERGY'}; VARH['omp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'omp2corl': 'OMP2 CORRELATION ENERGY'}; VARH['omp3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'omp3corl': 'OMP3 CORRELATION ENERGY'}; VARH['ocepa'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY'",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:64676,Energy Efficiency,ENERGY,ENERGY,64676,"y energy makes sense for cbs); if not('cbs_func' in kwargs):; if ('func' in kwargs):; kwargs['cbs_func'] = kwargs['func']; del kwargs['func']; else:; kwargs['cbs_func'] = energy; func = kwargs['cbs_func']; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper complete_basis_set.' % (func.__name__)); if not(func is energy):; raise ValidationError('Wrapper complete_basis_set is unhappy to be calling function \'%s\' instead of \'energy\'.' % (func.__name__)). # Define some quantum chemical knowledge, namely what methods are subsumed in others; VARH = {}; VARH['scf'] = { 'scftot': 'SCF TOTAL ENERGY'}; VARH['oldmp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'oldmp2corl': 'MP2 CORRELATION ENERGY'}; VARH['mp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY'}; VARH['mp2.5'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY'}; VARH['mp3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY'}; VARH['mp4(sdq)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY'}; VARH['mp4'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'mp4corl': 'MP4(SDTQ) CORRELATION ENERGY'}; VARH['omp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'omp2corl': 'OMP2 CORRELATION ENERGY'}; VARH['omp3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'omp3corl': 'OMP3 CORRELATION ENERGY'}; VARH['ocepa'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY'",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:64723,Energy Efficiency,ENERGY,ENERGY,64723,"y energy makes sense for cbs); if not('cbs_func' in kwargs):; if ('func' in kwargs):; kwargs['cbs_func'] = kwargs['func']; del kwargs['func']; else:; kwargs['cbs_func'] = energy; func = kwargs['cbs_func']; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper complete_basis_set.' % (func.__name__)); if not(func is energy):; raise ValidationError('Wrapper complete_basis_set is unhappy to be calling function \'%s\' instead of \'energy\'.' % (func.__name__)). # Define some quantum chemical knowledge, namely what methods are subsumed in others; VARH = {}; VARH['scf'] = { 'scftot': 'SCF TOTAL ENERGY'}; VARH['oldmp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'oldmp2corl': 'MP2 CORRELATION ENERGY'}; VARH['mp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY'}; VARH['mp2.5'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY'}; VARH['mp3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY'}; VARH['mp4(sdq)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY'}; VARH['mp4'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'mp4corl': 'MP4(SDTQ) CORRELATION ENERGY'}; VARH['omp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'omp2corl': 'OMP2 CORRELATION ENERGY'}; VARH['omp3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'omp3corl': 'OMP3 CORRELATION ENERGY'}; VARH['ocepa'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY'",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:64761,Energy Efficiency,ENERGY,ENERGY,64761,"y energy makes sense for cbs); if not('cbs_func' in kwargs):; if ('func' in kwargs):; kwargs['cbs_func'] = kwargs['func']; del kwargs['func']; else:; kwargs['cbs_func'] = energy; func = kwargs['cbs_func']; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper complete_basis_set.' % (func.__name__)); if not(func is energy):; raise ValidationError('Wrapper complete_basis_set is unhappy to be calling function \'%s\' instead of \'energy\'.' % (func.__name__)). # Define some quantum chemical knowledge, namely what methods are subsumed in others; VARH = {}; VARH['scf'] = { 'scftot': 'SCF TOTAL ENERGY'}; VARH['oldmp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'oldmp2corl': 'MP2 CORRELATION ENERGY'}; VARH['mp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY'}; VARH['mp2.5'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY'}; VARH['mp3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY'}; VARH['mp4(sdq)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY'}; VARH['mp4'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'mp4corl': 'MP4(SDTQ) CORRELATION ENERGY'}; VARH['omp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'omp2corl': 'OMP2 CORRELATION ENERGY'}; VARH['omp3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'omp3corl': 'OMP3 CORRELATION ENERGY'}; VARH['ocepa'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY'",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:64803,Energy Efficiency,ENERGY,ENERGY,64803,"] = energy; func = kwargs['cbs_func']; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper complete_basis_set.' % (func.__name__)); if not(func is energy):; raise ValidationError('Wrapper complete_basis_set is unhappy to be calling function \'%s\' instead of \'energy\'.' % (func.__name__)). # Define some quantum chemical knowledge, namely what methods are subsumed in others; VARH = {}; VARH['scf'] = { 'scftot': 'SCF TOTAL ENERGY'}; VARH['oldmp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'oldmp2corl': 'MP2 CORRELATION ENERGY'}; VARH['mp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY'}; VARH['mp2.5'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY'}; VARH['mp3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY'}; VARH['mp4(sdq)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY'}; VARH['mp4'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'mp4corl': 'MP4(SDTQ) CORRELATION ENERGY'}; VARH['omp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'omp2corl': 'OMP2 CORRELATION ENERGY'}; VARH['omp3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'omp3corl': 'OMP3 CORRELATION ENERGY'}; VARH['ocepa'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ocepacorl': 'OCEPA(0) CORRELATION ENERGY'}; VARH['cepa0'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa0corl': 'CEPA(0) CORRELATION",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:64841,Energy Efficiency,ENERGY,ENERGY,64841,"] = energy; func = kwargs['cbs_func']; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper complete_basis_set.' % (func.__name__)); if not(func is energy):; raise ValidationError('Wrapper complete_basis_set is unhappy to be calling function \'%s\' instead of \'energy\'.' % (func.__name__)). # Define some quantum chemical knowledge, namely what methods are subsumed in others; VARH = {}; VARH['scf'] = { 'scftot': 'SCF TOTAL ENERGY'}; VARH['oldmp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'oldmp2corl': 'MP2 CORRELATION ENERGY'}; VARH['mp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY'}; VARH['mp2.5'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY'}; VARH['mp3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY'}; VARH['mp4(sdq)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY'}; VARH['mp4'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'mp4corl': 'MP4(SDTQ) CORRELATION ENERGY'}; VARH['omp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'omp2corl': 'OMP2 CORRELATION ENERGY'}; VARH['omp3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'omp3corl': 'OMP3 CORRELATION ENERGY'}; VARH['ocepa'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ocepacorl': 'OCEPA(0) CORRELATION ENERGY'}; VARH['cepa0'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa0corl': 'CEPA(0) CORRELATION",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:64893,Energy Efficiency,ENERGY,ENERGY,64893,"] = energy; func = kwargs['cbs_func']; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper complete_basis_set.' % (func.__name__)); if not(func is energy):; raise ValidationError('Wrapper complete_basis_set is unhappy to be calling function \'%s\' instead of \'energy\'.' % (func.__name__)). # Define some quantum chemical knowledge, namely what methods are subsumed in others; VARH = {}; VARH['scf'] = { 'scftot': 'SCF TOTAL ENERGY'}; VARH['oldmp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'oldmp2corl': 'MP2 CORRELATION ENERGY'}; VARH['mp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY'}; VARH['mp2.5'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY'}; VARH['mp3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY'}; VARH['mp4(sdq)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY'}; VARH['mp4'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'mp4corl': 'MP4(SDTQ) CORRELATION ENERGY'}; VARH['omp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'omp2corl': 'OMP2 CORRELATION ENERGY'}; VARH['omp3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'omp3corl': 'OMP3 CORRELATION ENERGY'}; VARH['ocepa'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ocepacorl': 'OCEPA(0) CORRELATION ENERGY'}; VARH['cepa0'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa0corl': 'CEPA(0) CORRELATION",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:64931,Energy Efficiency,ENERGY,ENERGY,64931,"] = energy; func = kwargs['cbs_func']; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper complete_basis_set.' % (func.__name__)); if not(func is energy):; raise ValidationError('Wrapper complete_basis_set is unhappy to be calling function \'%s\' instead of \'energy\'.' % (func.__name__)). # Define some quantum chemical knowledge, namely what methods are subsumed in others; VARH = {}; VARH['scf'] = { 'scftot': 'SCF TOTAL ENERGY'}; VARH['oldmp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'oldmp2corl': 'MP2 CORRELATION ENERGY'}; VARH['mp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY'}; VARH['mp2.5'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY'}; VARH['mp3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY'}; VARH['mp4(sdq)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY'}; VARH['mp4'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'mp4corl': 'MP4(SDTQ) CORRELATION ENERGY'}; VARH['omp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'omp2corl': 'OMP2 CORRELATION ENERGY'}; VARH['omp3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'omp3corl': 'OMP3 CORRELATION ENERGY'}; VARH['ocepa'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ocepacorl': 'OCEPA(0) CORRELATION ENERGY'}; VARH['cepa0'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa0corl': 'CEPA(0) CORRELATION",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:64973,Energy Efficiency,ENERGY,ENERGY,64973,"y):; raise ValidationError('Wrapper complete_basis_set is unhappy to be calling function \'%s\' instead of \'energy\'.' % (func.__name__)). # Define some quantum chemical knowledge, namely what methods are subsumed in others; VARH = {}; VARH['scf'] = { 'scftot': 'SCF TOTAL ENERGY'}; VARH['oldmp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'oldmp2corl': 'MP2 CORRELATION ENERGY'}; VARH['mp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY'}; VARH['mp2.5'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY'}; VARH['mp3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY'}; VARH['mp4(sdq)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY'}; VARH['mp4'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'mp4corl': 'MP4(SDTQ) CORRELATION ENERGY'}; VARH['omp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'omp2corl': 'OMP2 CORRELATION ENERGY'}; VARH['omp3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'omp3corl': 'OMP3 CORRELATION ENERGY'}; VARH['ocepa'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ocepacorl': 'OCEPA(0) CORRELATION ENERGY'}; VARH['cepa0'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa0corl': 'CEPA(0) CORRELATION ENERGY'}; VARH['cepa(0)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(0)corl': 'CEPA(0) CORRELATION ENERGY'}; VARH['cepa(1)'] = { 'scftot': 'SCF TOTAL ENER",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:65011,Energy Efficiency,ENERGY,ENERGY,65011,"y):; raise ValidationError('Wrapper complete_basis_set is unhappy to be calling function \'%s\' instead of \'energy\'.' % (func.__name__)). # Define some quantum chemical knowledge, namely what methods are subsumed in others; VARH = {}; VARH['scf'] = { 'scftot': 'SCF TOTAL ENERGY'}; VARH['oldmp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'oldmp2corl': 'MP2 CORRELATION ENERGY'}; VARH['mp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY'}; VARH['mp2.5'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY'}; VARH['mp3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY'}; VARH['mp4(sdq)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY'}; VARH['mp4'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'mp4corl': 'MP4(SDTQ) CORRELATION ENERGY'}; VARH['omp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'omp2corl': 'OMP2 CORRELATION ENERGY'}; VARH['omp3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'omp3corl': 'OMP3 CORRELATION ENERGY'}; VARH['ocepa'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ocepacorl': 'OCEPA(0) CORRELATION ENERGY'}; VARH['cepa0'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa0corl': 'CEPA(0) CORRELATION ENERGY'}; VARH['cepa(0)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(0)corl': 'CEPA(0) CORRELATION ENERGY'}; VARH['cepa(1)'] = { 'scftot': 'SCF TOTAL ENER",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:65059,Energy Efficiency,ENERGY,ENERGY,65059,"y):; raise ValidationError('Wrapper complete_basis_set is unhappy to be calling function \'%s\' instead of \'energy\'.' % (func.__name__)). # Define some quantum chemical knowledge, namely what methods are subsumed in others; VARH = {}; VARH['scf'] = { 'scftot': 'SCF TOTAL ENERGY'}; VARH['oldmp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'oldmp2corl': 'MP2 CORRELATION ENERGY'}; VARH['mp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY'}; VARH['mp2.5'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY'}; VARH['mp3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY'}; VARH['mp4(sdq)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY'}; VARH['mp4'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'mp4corl': 'MP4(SDTQ) CORRELATION ENERGY'}; VARH['omp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'omp2corl': 'OMP2 CORRELATION ENERGY'}; VARH['omp3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'omp3corl': 'OMP3 CORRELATION ENERGY'}; VARH['ocepa'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ocepacorl': 'OCEPA(0) CORRELATION ENERGY'}; VARH['cepa0'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa0corl': 'CEPA(0) CORRELATION ENERGY'}; VARH['cepa(0)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(0)corl': 'CEPA(0) CORRELATION ENERGY'}; VARH['cepa(1)'] = { 'scftot': 'SCF TOTAL ENER",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:65106,Energy Efficiency,ENERGY,ENERGY,65106,"y):; raise ValidationError('Wrapper complete_basis_set is unhappy to be calling function \'%s\' instead of \'energy\'.' % (func.__name__)). # Define some quantum chemical knowledge, namely what methods are subsumed in others; VARH = {}; VARH['scf'] = { 'scftot': 'SCF TOTAL ENERGY'}; VARH['oldmp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'oldmp2corl': 'MP2 CORRELATION ENERGY'}; VARH['mp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY'}; VARH['mp2.5'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY'}; VARH['mp3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY'}; VARH['mp4(sdq)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY'}; VARH['mp4'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'mp4corl': 'MP4(SDTQ) CORRELATION ENERGY'}; VARH['omp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'omp2corl': 'OMP2 CORRELATION ENERGY'}; VARH['omp3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'omp3corl': 'OMP3 CORRELATION ENERGY'}; VARH['ocepa'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ocepacorl': 'OCEPA(0) CORRELATION ENERGY'}; VARH['cepa0'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa0corl': 'CEPA(0) CORRELATION ENERGY'}; VARH['cepa(0)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(0)corl': 'CEPA(0) CORRELATION ENERGY'}; VARH['cepa(1)'] = { 'scftot': 'SCF TOTAL ENER",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:65144,Energy Efficiency,ENERGY,ENERGY,65144,"y):; raise ValidationError('Wrapper complete_basis_set is unhappy to be calling function \'%s\' instead of \'energy\'.' % (func.__name__)). # Define some quantum chemical knowledge, namely what methods are subsumed in others; VARH = {}; VARH['scf'] = { 'scftot': 'SCF TOTAL ENERGY'}; VARH['oldmp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'oldmp2corl': 'MP2 CORRELATION ENERGY'}; VARH['mp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY'}; VARH['mp2.5'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY'}; VARH['mp3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY'}; VARH['mp4(sdq)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY'}; VARH['mp4'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'mp4corl': 'MP4(SDTQ) CORRELATION ENERGY'}; VARH['omp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'omp2corl': 'OMP2 CORRELATION ENERGY'}; VARH['omp3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'omp3corl': 'OMP3 CORRELATION ENERGY'}; VARH['ocepa'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ocepacorl': 'OCEPA(0) CORRELATION ENERGY'}; VARH['cepa0'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa0corl': 'CEPA(0) CORRELATION ENERGY'}; VARH['cepa(0)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(0)corl': 'CEPA(0) CORRELATION ENERGY'}; VARH['cepa(1)'] = { 'scftot': 'SCF TOTAL ENER",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:65186,Energy Efficiency,ENERGY,ENERGY,65186,",; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY'}; VARH['mp4'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'mp4corl': 'MP4(SDTQ) CORRELATION ENERGY'}; VARH['omp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'omp2corl': 'OMP2 CORRELATION ENERGY'}; VARH['omp3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'omp3corl': 'OMP3 CORRELATION ENERGY'}; VARH['ocepa'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ocepacorl': 'OCEPA(0) CORRELATION ENERGY'}; VARH['cepa0'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa0corl': 'CEPA(0) CORRELATION ENERGY'}; VARH['cepa(0)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(0)corl': 'CEPA(0) CORRELATION ENERGY'}; VARH['cepa(1)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(1)corl': 'CEPA(1) CORRELATION ENERGY'}; VARH['cepa(3)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(3)corl': 'CEPA(3) CORRELATION ENERGY'}; VARH['acpf'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'acpfcorl': 'ACPF CORRELATION ENERGY'}; VARH['aqcc'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'aqcccorl': 'AQCC CORRELATION ENERGY'}; VARH['qcisd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'qcisdcorl': 'QCISD CORRELATION ENERGY'}; VARH['cc2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc2corl': 'CC2 CORREL",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:65224,Energy Efficiency,ENERGY,ENERGY,65224,",; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY'}; VARH['mp4'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'mp4corl': 'MP4(SDTQ) CORRELATION ENERGY'}; VARH['omp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'omp2corl': 'OMP2 CORRELATION ENERGY'}; VARH['omp3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'omp3corl': 'OMP3 CORRELATION ENERGY'}; VARH['ocepa'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ocepacorl': 'OCEPA(0) CORRELATION ENERGY'}; VARH['cepa0'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa0corl': 'CEPA(0) CORRELATION ENERGY'}; VARH['cepa(0)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(0)corl': 'CEPA(0) CORRELATION ENERGY'}; VARH['cepa(1)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(1)corl': 'CEPA(1) CORRELATION ENERGY'}; VARH['cepa(3)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(3)corl': 'CEPA(3) CORRELATION ENERGY'}; VARH['acpf'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'acpfcorl': 'ACPF CORRELATION ENERGY'}; VARH['aqcc'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'aqcccorl': 'AQCC CORRELATION ENERGY'}; VARH['qcisd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'qcisdcorl': 'QCISD CORRELATION ENERGY'}; VARH['cc2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc2corl': 'CC2 CORREL",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:65272,Energy Efficiency,ENERGY,ENERGY,65272,",; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY'}; VARH['mp4'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'mp4corl': 'MP4(SDTQ) CORRELATION ENERGY'}; VARH['omp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'omp2corl': 'OMP2 CORRELATION ENERGY'}; VARH['omp3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'omp3corl': 'OMP3 CORRELATION ENERGY'}; VARH['ocepa'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ocepacorl': 'OCEPA(0) CORRELATION ENERGY'}; VARH['cepa0'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa0corl': 'CEPA(0) CORRELATION ENERGY'}; VARH['cepa(0)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(0)corl': 'CEPA(0) CORRELATION ENERGY'}; VARH['cepa(1)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(1)corl': 'CEPA(1) CORRELATION ENERGY'}; VARH['cepa(3)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(3)corl': 'CEPA(3) CORRELATION ENERGY'}; VARH['acpf'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'acpfcorl': 'ACPF CORRELATION ENERGY'}; VARH['aqcc'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'aqcccorl': 'AQCC CORRELATION ENERGY'}; VARH['qcisd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'qcisdcorl': 'QCISD CORRELATION ENERGY'}; VARH['cc2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc2corl': 'CC2 CORREL",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:65316,Energy Efficiency,ENERGY,ENERGY,65316,",; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY'}; VARH['mp4'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'mp4corl': 'MP4(SDTQ) CORRELATION ENERGY'}; VARH['omp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'omp2corl': 'OMP2 CORRELATION ENERGY'}; VARH['omp3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'omp3corl': 'OMP3 CORRELATION ENERGY'}; VARH['ocepa'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ocepacorl': 'OCEPA(0) CORRELATION ENERGY'}; VARH['cepa0'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa0corl': 'CEPA(0) CORRELATION ENERGY'}; VARH['cepa(0)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(0)corl': 'CEPA(0) CORRELATION ENERGY'}; VARH['cepa(1)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(1)corl': 'CEPA(1) CORRELATION ENERGY'}; VARH['cepa(3)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(3)corl': 'CEPA(3) CORRELATION ENERGY'}; VARH['acpf'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'acpfcorl': 'ACPF CORRELATION ENERGY'}; VARH['aqcc'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'aqcccorl': 'AQCC CORRELATION ENERGY'}; VARH['qcisd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'qcisdcorl': 'QCISD CORRELATION ENERGY'}; VARH['cc2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc2corl': 'CC2 CORREL",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:65364,Energy Efficiency,ENERGY,ENERGY,65364,",; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY'}; VARH['mp4'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'mp4corl': 'MP4(SDTQ) CORRELATION ENERGY'}; VARH['omp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'omp2corl': 'OMP2 CORRELATION ENERGY'}; VARH['omp3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'omp3corl': 'OMP3 CORRELATION ENERGY'}; VARH['ocepa'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ocepacorl': 'OCEPA(0) CORRELATION ENERGY'}; VARH['cepa0'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa0corl': 'CEPA(0) CORRELATION ENERGY'}; VARH['cepa(0)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(0)corl': 'CEPA(0) CORRELATION ENERGY'}; VARH['cepa(1)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(1)corl': 'CEPA(1) CORRELATION ENERGY'}; VARH['cepa(3)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(3)corl': 'CEPA(3) CORRELATION ENERGY'}; VARH['acpf'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'acpfcorl': 'ACPF CORRELATION ENERGY'}; VARH['aqcc'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'aqcccorl': 'AQCC CORRELATION ENERGY'}; VARH['qcisd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'qcisdcorl': 'QCISD CORRELATION ENERGY'}; VARH['cc2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc2corl': 'CC2 CORREL",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:65402,Energy Efficiency,ENERGY,ENERGY,65402,",; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY'}; VARH['mp4'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'mp4corl': 'MP4(SDTQ) CORRELATION ENERGY'}; VARH['omp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'omp2corl': 'OMP2 CORRELATION ENERGY'}; VARH['omp3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'omp3corl': 'OMP3 CORRELATION ENERGY'}; VARH['ocepa'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ocepacorl': 'OCEPA(0) CORRELATION ENERGY'}; VARH['cepa0'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa0corl': 'CEPA(0) CORRELATION ENERGY'}; VARH['cepa(0)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(0)corl': 'CEPA(0) CORRELATION ENERGY'}; VARH['cepa(1)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(1)corl': 'CEPA(1) CORRELATION ENERGY'}; VARH['cepa(3)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(3)corl': 'CEPA(3) CORRELATION ENERGY'}; VARH['acpf'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'acpfcorl': 'ACPF CORRELATION ENERGY'}; VARH['aqcc'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'aqcccorl': 'AQCC CORRELATION ENERGY'}; VARH['qcisd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'qcisdcorl': 'QCISD CORRELATION ENERGY'}; VARH['cc2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc2corl': 'CC2 CORREL",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:65442,Energy Efficiency,ENERGY,ENERGY,65442,",; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY'}; VARH['mp4'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'mp4corl': 'MP4(SDTQ) CORRELATION ENERGY'}; VARH['omp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'omp2corl': 'OMP2 CORRELATION ENERGY'}; VARH['omp3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'omp3corl': 'OMP3 CORRELATION ENERGY'}; VARH['ocepa'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ocepacorl': 'OCEPA(0) CORRELATION ENERGY'}; VARH['cepa0'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa0corl': 'CEPA(0) CORRELATION ENERGY'}; VARH['cepa(0)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(0)corl': 'CEPA(0) CORRELATION ENERGY'}; VARH['cepa(1)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(1)corl': 'CEPA(1) CORRELATION ENERGY'}; VARH['cepa(3)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(3)corl': 'CEPA(3) CORRELATION ENERGY'}; VARH['acpf'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'acpfcorl': 'ACPF CORRELATION ENERGY'}; VARH['aqcc'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'aqcccorl': 'AQCC CORRELATION ENERGY'}; VARH['qcisd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'qcisdcorl': 'QCISD CORRELATION ENERGY'}; VARH['cc2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc2corl': 'CC2 CORREL",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:65490,Energy Efficiency,ENERGY,ENERGY,65490,",; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY'}; VARH['mp4'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'mp4corl': 'MP4(SDTQ) CORRELATION ENERGY'}; VARH['omp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'omp2corl': 'OMP2 CORRELATION ENERGY'}; VARH['omp3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'omp3corl': 'OMP3 CORRELATION ENERGY'}; VARH['ocepa'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ocepacorl': 'OCEPA(0) CORRELATION ENERGY'}; VARH['cepa0'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa0corl': 'CEPA(0) CORRELATION ENERGY'}; VARH['cepa(0)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(0)corl': 'CEPA(0) CORRELATION ENERGY'}; VARH['cepa(1)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(1)corl': 'CEPA(1) CORRELATION ENERGY'}; VARH['cepa(3)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(3)corl': 'CEPA(3) CORRELATION ENERGY'}; VARH['acpf'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'acpfcorl': 'ACPF CORRELATION ENERGY'}; VARH['aqcc'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'aqcccorl': 'AQCC CORRELATION ENERGY'}; VARH['qcisd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'qcisdcorl': 'QCISD CORRELATION ENERGY'}; VARH['cc2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc2corl': 'CC2 CORREL",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:65528,Energy Efficiency,ENERGY,ENERGY,65528,",; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY'}; VARH['mp4'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'mp4corl': 'MP4(SDTQ) CORRELATION ENERGY'}; VARH['omp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'omp2corl': 'OMP2 CORRELATION ENERGY'}; VARH['omp3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'omp3corl': 'OMP3 CORRELATION ENERGY'}; VARH['ocepa'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ocepacorl': 'OCEPA(0) CORRELATION ENERGY'}; VARH['cepa0'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa0corl': 'CEPA(0) CORRELATION ENERGY'}; VARH['cepa(0)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(0)corl': 'CEPA(0) CORRELATION ENERGY'}; VARH['cepa(1)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(1)corl': 'CEPA(1) CORRELATION ENERGY'}; VARH['cepa(3)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(3)corl': 'CEPA(3) CORRELATION ENERGY'}; VARH['acpf'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'acpfcorl': 'ACPF CORRELATION ENERGY'}; VARH['aqcc'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'aqcccorl': 'AQCC CORRELATION ENERGY'}; VARH['qcisd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'qcisdcorl': 'QCISD CORRELATION ENERGY'}; VARH['cc2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc2corl': 'CC2 CORREL",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:65566,Energy Efficiency,ENERGY,ENERGY,65566,",; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY'}; VARH['mp4'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'mp4corl': 'MP4(SDTQ) CORRELATION ENERGY'}; VARH['omp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'omp2corl': 'OMP2 CORRELATION ENERGY'}; VARH['omp3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'omp3corl': 'OMP3 CORRELATION ENERGY'}; VARH['ocepa'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ocepacorl': 'OCEPA(0) CORRELATION ENERGY'}; VARH['cepa0'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa0corl': 'CEPA(0) CORRELATION ENERGY'}; VARH['cepa(0)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(0)corl': 'CEPA(0) CORRELATION ENERGY'}; VARH['cepa(1)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(1)corl': 'CEPA(1) CORRELATION ENERGY'}; VARH['cepa(3)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(3)corl': 'CEPA(3) CORRELATION ENERGY'}; VARH['acpf'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'acpfcorl': 'ACPF CORRELATION ENERGY'}; VARH['aqcc'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'aqcccorl': 'AQCC CORRELATION ENERGY'}; VARH['qcisd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'qcisdcorl': 'QCISD CORRELATION ENERGY'}; VARH['cc2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc2corl': 'CC2 CORREL",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:65606,Energy Efficiency,ENERGY,ENERGY,65606,",; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY'}; VARH['mp4'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'mp4corl': 'MP4(SDTQ) CORRELATION ENERGY'}; VARH['omp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'omp2corl': 'OMP2 CORRELATION ENERGY'}; VARH['omp3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'omp3corl': 'OMP3 CORRELATION ENERGY'}; VARH['ocepa'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ocepacorl': 'OCEPA(0) CORRELATION ENERGY'}; VARH['cepa0'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa0corl': 'CEPA(0) CORRELATION ENERGY'}; VARH['cepa(0)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(0)corl': 'CEPA(0) CORRELATION ENERGY'}; VARH['cepa(1)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(1)corl': 'CEPA(1) CORRELATION ENERGY'}; VARH['cepa(3)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(3)corl': 'CEPA(3) CORRELATION ENERGY'}; VARH['acpf'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'acpfcorl': 'ACPF CORRELATION ENERGY'}; VARH['aqcc'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'aqcccorl': 'AQCC CORRELATION ENERGY'}; VARH['qcisd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'qcisdcorl': 'QCISD CORRELATION ENERGY'}; VARH['cc2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc2corl': 'CC2 CORREL",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:65655,Energy Efficiency,ENERGY,ENERGY,65655,",; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY'}; VARH['mp4'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'mp4corl': 'MP4(SDTQ) CORRELATION ENERGY'}; VARH['omp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'omp2corl': 'OMP2 CORRELATION ENERGY'}; VARH['omp3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'omp3corl': 'OMP3 CORRELATION ENERGY'}; VARH['ocepa'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ocepacorl': 'OCEPA(0) CORRELATION ENERGY'}; VARH['cepa0'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa0corl': 'CEPA(0) CORRELATION ENERGY'}; VARH['cepa(0)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(0)corl': 'CEPA(0) CORRELATION ENERGY'}; VARH['cepa(1)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(1)corl': 'CEPA(1) CORRELATION ENERGY'}; VARH['cepa(3)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(3)corl': 'CEPA(3) CORRELATION ENERGY'}; VARH['acpf'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'acpfcorl': 'ACPF CORRELATION ENERGY'}; VARH['aqcc'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'aqcccorl': 'AQCC CORRELATION ENERGY'}; VARH['qcisd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'qcisdcorl': 'QCISD CORRELATION ENERGY'}; VARH['cc2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc2corl': 'CC2 CORREL",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:65693,Energy Efficiency,ENERGY,ENERGY,65693,",; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY'}; VARH['mp4'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'mp4corl': 'MP4(SDTQ) CORRELATION ENERGY'}; VARH['omp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'omp2corl': 'OMP2 CORRELATION ENERGY'}; VARH['omp3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'omp3corl': 'OMP3 CORRELATION ENERGY'}; VARH['ocepa'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ocepacorl': 'OCEPA(0) CORRELATION ENERGY'}; VARH['cepa0'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa0corl': 'CEPA(0) CORRELATION ENERGY'}; VARH['cepa(0)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(0)corl': 'CEPA(0) CORRELATION ENERGY'}; VARH['cepa(1)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(1)corl': 'CEPA(1) CORRELATION ENERGY'}; VARH['cepa(3)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(3)corl': 'CEPA(3) CORRELATION ENERGY'}; VARH['acpf'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'acpfcorl': 'ACPF CORRELATION ENERGY'}; VARH['aqcc'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'aqcccorl': 'AQCC CORRELATION ENERGY'}; VARH['qcisd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'qcisdcorl': 'QCISD CORRELATION ENERGY'}; VARH['cc2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc2corl': 'CC2 CORREL",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:65738,Energy Efficiency,ENERGY,ENERGY,65738,",; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY'}; VARH['mp4'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'mp4corl': 'MP4(SDTQ) CORRELATION ENERGY'}; VARH['omp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'omp2corl': 'OMP2 CORRELATION ENERGY'}; VARH['omp3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'omp3corl': 'OMP3 CORRELATION ENERGY'}; VARH['ocepa'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ocepacorl': 'OCEPA(0) CORRELATION ENERGY'}; VARH['cepa0'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa0corl': 'CEPA(0) CORRELATION ENERGY'}; VARH['cepa(0)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(0)corl': 'CEPA(0) CORRELATION ENERGY'}; VARH['cepa(1)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(1)corl': 'CEPA(1) CORRELATION ENERGY'}; VARH['cepa(3)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(3)corl': 'CEPA(3) CORRELATION ENERGY'}; VARH['acpf'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'acpfcorl': 'ACPF CORRELATION ENERGY'}; VARH['aqcc'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'aqcccorl': 'AQCC CORRELATION ENERGY'}; VARH['qcisd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'qcisdcorl': 'QCISD CORRELATION ENERGY'}; VARH['cc2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc2corl': 'CC2 CORREL",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:65787,Energy Efficiency,ENERGY,ENERGY,65787,",; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY'}; VARH['mp4'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'mp4corl': 'MP4(SDTQ) CORRELATION ENERGY'}; VARH['omp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'omp2corl': 'OMP2 CORRELATION ENERGY'}; VARH['omp3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'omp3corl': 'OMP3 CORRELATION ENERGY'}; VARH['ocepa'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ocepacorl': 'OCEPA(0) CORRELATION ENERGY'}; VARH['cepa0'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa0corl': 'CEPA(0) CORRELATION ENERGY'}; VARH['cepa(0)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(0)corl': 'CEPA(0) CORRELATION ENERGY'}; VARH['cepa(1)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(1)corl': 'CEPA(1) CORRELATION ENERGY'}; VARH['cepa(3)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(3)corl': 'CEPA(3) CORRELATION ENERGY'}; VARH['acpf'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'acpfcorl': 'ACPF CORRELATION ENERGY'}; VARH['aqcc'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'aqcccorl': 'AQCC CORRELATION ENERGY'}; VARH['qcisd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'qcisdcorl': 'QCISD CORRELATION ENERGY'}; VARH['cc2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc2corl': 'CC2 CORREL",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:65825,Energy Efficiency,ENERGY,ENERGY,65825,",; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY'}; VARH['mp4'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'mp4corl': 'MP4(SDTQ) CORRELATION ENERGY'}; VARH['omp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'omp2corl': 'OMP2 CORRELATION ENERGY'}; VARH['omp3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'omp3corl': 'OMP3 CORRELATION ENERGY'}; VARH['ocepa'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ocepacorl': 'OCEPA(0) CORRELATION ENERGY'}; VARH['cepa0'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa0corl': 'CEPA(0) CORRELATION ENERGY'}; VARH['cepa(0)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(0)corl': 'CEPA(0) CORRELATION ENERGY'}; VARH['cepa(1)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(1)corl': 'CEPA(1) CORRELATION ENERGY'}; VARH['cepa(3)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(3)corl': 'CEPA(3) CORRELATION ENERGY'}; VARH['acpf'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'acpfcorl': 'ACPF CORRELATION ENERGY'}; VARH['aqcc'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'aqcccorl': 'AQCC CORRELATION ENERGY'}; VARH['qcisd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'qcisdcorl': 'QCISD CORRELATION ENERGY'}; VARH['cc2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc2corl': 'CC2 CORREL",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:65869,Energy Efficiency,ENERGY,ENERGY,65869,",; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY'}; VARH['mp4'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'mp4corl': 'MP4(SDTQ) CORRELATION ENERGY'}; VARH['omp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'omp2corl': 'OMP2 CORRELATION ENERGY'}; VARH['omp3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'omp3corl': 'OMP3 CORRELATION ENERGY'}; VARH['ocepa'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ocepacorl': 'OCEPA(0) CORRELATION ENERGY'}; VARH['cepa0'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa0corl': 'CEPA(0) CORRELATION ENERGY'}; VARH['cepa(0)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(0)corl': 'CEPA(0) CORRELATION ENERGY'}; VARH['cepa(1)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(1)corl': 'CEPA(1) CORRELATION ENERGY'}; VARH['cepa(3)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(3)corl': 'CEPA(3) CORRELATION ENERGY'}; VARH['acpf'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'acpfcorl': 'ACPF CORRELATION ENERGY'}; VARH['aqcc'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'aqcccorl': 'AQCC CORRELATION ENERGY'}; VARH['qcisd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'qcisdcorl': 'QCISD CORRELATION ENERGY'}; VARH['cc2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc2corl': 'CC2 CORREL",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:65920,Energy Efficiency,ENERGY,ENERGY,65920,",; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY'}; VARH['mp4'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'mp4corl': 'MP4(SDTQ) CORRELATION ENERGY'}; VARH['omp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'omp2corl': 'OMP2 CORRELATION ENERGY'}; VARH['omp3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'omp3corl': 'OMP3 CORRELATION ENERGY'}; VARH['ocepa'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ocepacorl': 'OCEPA(0) CORRELATION ENERGY'}; VARH['cepa0'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa0corl': 'CEPA(0) CORRELATION ENERGY'}; VARH['cepa(0)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(0)corl': 'CEPA(0) CORRELATION ENERGY'}; VARH['cepa(1)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(1)corl': 'CEPA(1) CORRELATION ENERGY'}; VARH['cepa(3)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(3)corl': 'CEPA(3) CORRELATION ENERGY'}; VARH['acpf'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'acpfcorl': 'ACPF CORRELATION ENERGY'}; VARH['aqcc'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'aqcccorl': 'AQCC CORRELATION ENERGY'}; VARH['qcisd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'qcisdcorl': 'QCISD CORRELATION ENERGY'}; VARH['cc2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc2corl': 'CC2 CORREL",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:65958,Energy Efficiency,ENERGY,ENERGY,65958,",; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY'}; VARH['mp4'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'mp4corl': 'MP4(SDTQ) CORRELATION ENERGY'}; VARH['omp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'omp2corl': 'OMP2 CORRELATION ENERGY'}; VARH['omp3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'omp3corl': 'OMP3 CORRELATION ENERGY'}; VARH['ocepa'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ocepacorl': 'OCEPA(0) CORRELATION ENERGY'}; VARH['cepa0'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa0corl': 'CEPA(0) CORRELATION ENERGY'}; VARH['cepa(0)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(0)corl': 'CEPA(0) CORRELATION ENERGY'}; VARH['cepa(1)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(1)corl': 'CEPA(1) CORRELATION ENERGY'}; VARH['cepa(3)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(3)corl': 'CEPA(3) CORRELATION ENERGY'}; VARH['acpf'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'acpfcorl': 'ACPF CORRELATION ENERGY'}; VARH['aqcc'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'aqcccorl': 'AQCC CORRELATION ENERGY'}; VARH['qcisd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'qcisdcorl': 'QCISD CORRELATION ENERGY'}; VARH['cc2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc2corl': 'CC2 CORREL",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:66004,Energy Efficiency,ENERGY,ENERGY,66004,",; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY'}; VARH['mp4'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'mp4corl': 'MP4(SDTQ) CORRELATION ENERGY'}; VARH['omp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'omp2corl': 'OMP2 CORRELATION ENERGY'}; VARH['omp3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'omp3corl': 'OMP3 CORRELATION ENERGY'}; VARH['ocepa'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ocepacorl': 'OCEPA(0) CORRELATION ENERGY'}; VARH['cepa0'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa0corl': 'CEPA(0) CORRELATION ENERGY'}; VARH['cepa(0)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(0)corl': 'CEPA(0) CORRELATION ENERGY'}; VARH['cepa(1)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(1)corl': 'CEPA(1) CORRELATION ENERGY'}; VARH['cepa(3)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(3)corl': 'CEPA(3) CORRELATION ENERGY'}; VARH['acpf'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'acpfcorl': 'ACPF CORRELATION ENERGY'}; VARH['aqcc'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'aqcccorl': 'AQCC CORRELATION ENERGY'}; VARH['qcisd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'qcisdcorl': 'QCISD CORRELATION ENERGY'}; VARH['cc2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc2corl': 'CC2 CORREL",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:66055,Energy Efficiency,ENERGY,ENERGY,66055,",; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY'}; VARH['mp4'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'mp4corl': 'MP4(SDTQ) CORRELATION ENERGY'}; VARH['omp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'omp2corl': 'OMP2 CORRELATION ENERGY'}; VARH['omp3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'omp3corl': 'OMP3 CORRELATION ENERGY'}; VARH['ocepa'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ocepacorl': 'OCEPA(0) CORRELATION ENERGY'}; VARH['cepa0'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa0corl': 'CEPA(0) CORRELATION ENERGY'}; VARH['cepa(0)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(0)corl': 'CEPA(0) CORRELATION ENERGY'}; VARH['cepa(1)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(1)corl': 'CEPA(1) CORRELATION ENERGY'}; VARH['cepa(3)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(3)corl': 'CEPA(3) CORRELATION ENERGY'}; VARH['acpf'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'acpfcorl': 'ACPF CORRELATION ENERGY'}; VARH['aqcc'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'aqcccorl': 'AQCC CORRELATION ENERGY'}; VARH['qcisd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'qcisdcorl': 'QCISD CORRELATION ENERGY'}; VARH['cc2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc2corl': 'CC2 CORREL",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:66093,Energy Efficiency,ENERGY,ENERGY,66093,",; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY'}; VARH['mp4'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'mp4corl': 'MP4(SDTQ) CORRELATION ENERGY'}; VARH['omp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'omp2corl': 'OMP2 CORRELATION ENERGY'}; VARH['omp3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'omp3corl': 'OMP3 CORRELATION ENERGY'}; VARH['ocepa'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ocepacorl': 'OCEPA(0) CORRELATION ENERGY'}; VARH['cepa0'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa0corl': 'CEPA(0) CORRELATION ENERGY'}; VARH['cepa(0)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(0)corl': 'CEPA(0) CORRELATION ENERGY'}; VARH['cepa(1)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(1)corl': 'CEPA(1) CORRELATION ENERGY'}; VARH['cepa(3)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(3)corl': 'CEPA(3) CORRELATION ENERGY'}; VARH['acpf'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'acpfcorl': 'ACPF CORRELATION ENERGY'}; VARH['aqcc'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'aqcccorl': 'AQCC CORRELATION ENERGY'}; VARH['qcisd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'qcisdcorl': 'QCISD CORRELATION ENERGY'}; VARH['cc2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc2corl': 'CC2 CORREL",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:66139,Energy Efficiency,ENERGY,ENERGY,66139,",; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY'}; VARH['mp4'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'mp4corl': 'MP4(SDTQ) CORRELATION ENERGY'}; VARH['omp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'omp2corl': 'OMP2 CORRELATION ENERGY'}; VARH['omp3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'omp3corl': 'OMP3 CORRELATION ENERGY'}; VARH['ocepa'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ocepacorl': 'OCEPA(0) CORRELATION ENERGY'}; VARH['cepa0'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa0corl': 'CEPA(0) CORRELATION ENERGY'}; VARH['cepa(0)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(0)corl': 'CEPA(0) CORRELATION ENERGY'}; VARH['cepa(1)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(1)corl': 'CEPA(1) CORRELATION ENERGY'}; VARH['cepa(3)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(3)corl': 'CEPA(3) CORRELATION ENERGY'}; VARH['acpf'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'acpfcorl': 'ACPF CORRELATION ENERGY'}; VARH['aqcc'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'aqcccorl': 'AQCC CORRELATION ENERGY'}; VARH['qcisd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'qcisdcorl': 'QCISD CORRELATION ENERGY'}; VARH['cc2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc2corl': 'CC2 CORREL",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:66190,Energy Efficiency,ENERGY,ENERGY,66190,",; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY'}; VARH['mp4'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'mp4corl': 'MP4(SDTQ) CORRELATION ENERGY'}; VARH['omp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'omp2corl': 'OMP2 CORRELATION ENERGY'}; VARH['omp3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'omp3corl': 'OMP3 CORRELATION ENERGY'}; VARH['ocepa'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ocepacorl': 'OCEPA(0) CORRELATION ENERGY'}; VARH['cepa0'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa0corl': 'CEPA(0) CORRELATION ENERGY'}; VARH['cepa(0)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(0)corl': 'CEPA(0) CORRELATION ENERGY'}; VARH['cepa(1)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(1)corl': 'CEPA(1) CORRELATION ENERGY'}; VARH['cepa(3)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(3)corl': 'CEPA(3) CORRELATION ENERGY'}; VARH['acpf'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'acpfcorl': 'ACPF CORRELATION ENERGY'}; VARH['aqcc'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'aqcccorl': 'AQCC CORRELATION ENERGY'}; VARH['qcisd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'qcisdcorl': 'QCISD CORRELATION ENERGY'}; VARH['cc2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc2corl': 'CC2 CORREL",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:66228,Energy Efficiency,ENERGY,ENERGY,66228,",; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY'}; VARH['mp4'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'mp4corl': 'MP4(SDTQ) CORRELATION ENERGY'}; VARH['omp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'omp2corl': 'OMP2 CORRELATION ENERGY'}; VARH['omp3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'omp3corl': 'OMP3 CORRELATION ENERGY'}; VARH['ocepa'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ocepacorl': 'OCEPA(0) CORRELATION ENERGY'}; VARH['cepa0'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa0corl': 'CEPA(0) CORRELATION ENERGY'}; VARH['cepa(0)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(0)corl': 'CEPA(0) CORRELATION ENERGY'}; VARH['cepa(1)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(1)corl': 'CEPA(1) CORRELATION ENERGY'}; VARH['cepa(3)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(3)corl': 'CEPA(3) CORRELATION ENERGY'}; VARH['acpf'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'acpfcorl': 'ACPF CORRELATION ENERGY'}; VARH['aqcc'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'aqcccorl': 'AQCC CORRELATION ENERGY'}; VARH['qcisd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'qcisdcorl': 'QCISD CORRELATION ENERGY'}; VARH['cc2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc2corl': 'CC2 CORREL",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:66274,Energy Efficiency,ENERGY,ENERGY,66274,",; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY'}; VARH['mp4'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'mp4corl': 'MP4(SDTQ) CORRELATION ENERGY'}; VARH['omp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'omp2corl': 'OMP2 CORRELATION ENERGY'}; VARH['omp3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'omp3corl': 'OMP3 CORRELATION ENERGY'}; VARH['ocepa'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ocepacorl': 'OCEPA(0) CORRELATION ENERGY'}; VARH['cepa0'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa0corl': 'CEPA(0) CORRELATION ENERGY'}; VARH['cepa(0)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(0)corl': 'CEPA(0) CORRELATION ENERGY'}; VARH['cepa(1)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(1)corl': 'CEPA(1) CORRELATION ENERGY'}; VARH['cepa(3)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(3)corl': 'CEPA(3) CORRELATION ENERGY'}; VARH['acpf'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'acpfcorl': 'ACPF CORRELATION ENERGY'}; VARH['aqcc'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'aqcccorl': 'AQCC CORRELATION ENERGY'}; VARH['qcisd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'qcisdcorl': 'QCISD CORRELATION ENERGY'}; VARH['cc2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc2corl': 'CC2 CORREL",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:66322,Energy Efficiency,ENERGY,ENERGY,66322,",; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY'}; VARH['mp4'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'mp4corl': 'MP4(SDTQ) CORRELATION ENERGY'}; VARH['omp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'omp2corl': 'OMP2 CORRELATION ENERGY'}; VARH['omp3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'omp3corl': 'OMP3 CORRELATION ENERGY'}; VARH['ocepa'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ocepacorl': 'OCEPA(0) CORRELATION ENERGY'}; VARH['cepa0'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa0corl': 'CEPA(0) CORRELATION ENERGY'}; VARH['cepa(0)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(0)corl': 'CEPA(0) CORRELATION ENERGY'}; VARH['cepa(1)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(1)corl': 'CEPA(1) CORRELATION ENERGY'}; VARH['cepa(3)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(3)corl': 'CEPA(3) CORRELATION ENERGY'}; VARH['acpf'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'acpfcorl': 'ACPF CORRELATION ENERGY'}; VARH['aqcc'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'aqcccorl': 'AQCC CORRELATION ENERGY'}; VARH['qcisd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'qcisdcorl': 'QCISD CORRELATION ENERGY'}; VARH['cc2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc2corl': 'CC2 CORREL",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:66360,Energy Efficiency,ENERGY,ENERGY,66360,",; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY'}; VARH['mp4'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'mp4corl': 'MP4(SDTQ) CORRELATION ENERGY'}; VARH['omp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'omp2corl': 'OMP2 CORRELATION ENERGY'}; VARH['omp3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'omp3corl': 'OMP3 CORRELATION ENERGY'}; VARH['ocepa'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ocepacorl': 'OCEPA(0) CORRELATION ENERGY'}; VARH['cepa0'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa0corl': 'CEPA(0) CORRELATION ENERGY'}; VARH['cepa(0)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(0)corl': 'CEPA(0) CORRELATION ENERGY'}; VARH['cepa(1)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(1)corl': 'CEPA(1) CORRELATION ENERGY'}; VARH['cepa(3)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(3)corl': 'CEPA(3) CORRELATION ENERGY'}; VARH['acpf'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'acpfcorl': 'ACPF CORRELATION ENERGY'}; VARH['aqcc'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'aqcccorl': 'AQCC CORRELATION ENERGY'}; VARH['qcisd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'qcisdcorl': 'QCISD CORRELATION ENERGY'}; VARH['cc2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc2corl': 'CC2 CORREL",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:66400,Energy Efficiency,ENERGY,ENERGY,66400,",; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY'}; VARH['mp4'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'mp4corl': 'MP4(SDTQ) CORRELATION ENERGY'}; VARH['omp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'omp2corl': 'OMP2 CORRELATION ENERGY'}; VARH['omp3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'omp3corl': 'OMP3 CORRELATION ENERGY'}; VARH['ocepa'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ocepacorl': 'OCEPA(0) CORRELATION ENERGY'}; VARH['cepa0'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa0corl': 'CEPA(0) CORRELATION ENERGY'}; VARH['cepa(0)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(0)corl': 'CEPA(0) CORRELATION ENERGY'}; VARH['cepa(1)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(1)corl': 'CEPA(1) CORRELATION ENERGY'}; VARH['cepa(3)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(3)corl': 'CEPA(3) CORRELATION ENERGY'}; VARH['acpf'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'acpfcorl': 'ACPF CORRELATION ENERGY'}; VARH['aqcc'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'aqcccorl': 'AQCC CORRELATION ENERGY'}; VARH['qcisd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'qcisdcorl': 'QCISD CORRELATION ENERGY'}; VARH['cc2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc2corl': 'CC2 CORREL",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:66448,Energy Efficiency,ENERGY,ENERGY,66448,",; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY'}; VARH['mp4'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'mp4corl': 'MP4(SDTQ) CORRELATION ENERGY'}; VARH['omp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'omp2corl': 'OMP2 CORRELATION ENERGY'}; VARH['omp3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'omp3corl': 'OMP3 CORRELATION ENERGY'}; VARH['ocepa'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ocepacorl': 'OCEPA(0) CORRELATION ENERGY'}; VARH['cepa0'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa0corl': 'CEPA(0) CORRELATION ENERGY'}; VARH['cepa(0)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(0)corl': 'CEPA(0) CORRELATION ENERGY'}; VARH['cepa(1)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(1)corl': 'CEPA(1) CORRELATION ENERGY'}; VARH['cepa(3)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(3)corl': 'CEPA(3) CORRELATION ENERGY'}; VARH['acpf'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'acpfcorl': 'ACPF CORRELATION ENERGY'}; VARH['aqcc'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'aqcccorl': 'AQCC CORRELATION ENERGY'}; VARH['qcisd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'qcisdcorl': 'QCISD CORRELATION ENERGY'}; VARH['cc2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc2corl': 'CC2 CORREL",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:66486,Energy Efficiency,ENERGY,ENERGY,66486,",; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY'}; VARH['mp4'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'mp4corl': 'MP4(SDTQ) CORRELATION ENERGY'}; VARH['omp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'omp2corl': 'OMP2 CORRELATION ENERGY'}; VARH['omp3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'omp3corl': 'OMP3 CORRELATION ENERGY'}; VARH['ocepa'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ocepacorl': 'OCEPA(0) CORRELATION ENERGY'}; VARH['cepa0'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa0corl': 'CEPA(0) CORRELATION ENERGY'}; VARH['cepa(0)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(0)corl': 'CEPA(0) CORRELATION ENERGY'}; VARH['cepa(1)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(1)corl': 'CEPA(1) CORRELATION ENERGY'}; VARH['cepa(3)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(3)corl': 'CEPA(3) CORRELATION ENERGY'}; VARH['acpf'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'acpfcorl': 'ACPF CORRELATION ENERGY'}; VARH['aqcc'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'aqcccorl': 'AQCC CORRELATION ENERGY'}; VARH['qcisd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'qcisdcorl': 'QCISD CORRELATION ENERGY'}; VARH['cc2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc2corl': 'CC2 CORREL",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:66526,Energy Efficiency,ENERGY,ENERGY,66526,",; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY'}; VARH['mp4'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'mp4corl': 'MP4(SDTQ) CORRELATION ENERGY'}; VARH['omp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'omp2corl': 'OMP2 CORRELATION ENERGY'}; VARH['omp3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'omp3corl': 'OMP3 CORRELATION ENERGY'}; VARH['ocepa'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ocepacorl': 'OCEPA(0) CORRELATION ENERGY'}; VARH['cepa0'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa0corl': 'CEPA(0) CORRELATION ENERGY'}; VARH['cepa(0)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(0)corl': 'CEPA(0) CORRELATION ENERGY'}; VARH['cepa(1)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(1)corl': 'CEPA(1) CORRELATION ENERGY'}; VARH['cepa(3)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(3)corl': 'CEPA(3) CORRELATION ENERGY'}; VARH['acpf'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'acpfcorl': 'ACPF CORRELATION ENERGY'}; VARH['aqcc'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'aqcccorl': 'AQCC CORRELATION ENERGY'}; VARH['qcisd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'qcisdcorl': 'QCISD CORRELATION ENERGY'}; VARH['cc2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc2corl': 'CC2 CORREL",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:66575,Energy Efficiency,ENERGY,ENERGY,66575,",; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY'}; VARH['mp4'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'mp4corl': 'MP4(SDTQ) CORRELATION ENERGY'}; VARH['omp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'omp2corl': 'OMP2 CORRELATION ENERGY'}; VARH['omp3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'omp3corl': 'OMP3 CORRELATION ENERGY'}; VARH['ocepa'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ocepacorl': 'OCEPA(0) CORRELATION ENERGY'}; VARH['cepa0'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa0corl': 'CEPA(0) CORRELATION ENERGY'}; VARH['cepa(0)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(0)corl': 'CEPA(0) CORRELATION ENERGY'}; VARH['cepa(1)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(1)corl': 'CEPA(1) CORRELATION ENERGY'}; VARH['cepa(3)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(3)corl': 'CEPA(3) CORRELATION ENERGY'}; VARH['acpf'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'acpfcorl': 'ACPF CORRELATION ENERGY'}; VARH['aqcc'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'aqcccorl': 'AQCC CORRELATION ENERGY'}; VARH['qcisd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'qcisdcorl': 'QCISD CORRELATION ENERGY'}; VARH['cc2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc2corl': 'CC2 CORREL",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:66613,Energy Efficiency,ENERGY,ENERGY,66613,",; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY'}; VARH['mp4'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'mp4corl': 'MP4(SDTQ) CORRELATION ENERGY'}; VARH['omp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'omp2corl': 'OMP2 CORRELATION ENERGY'}; VARH['omp3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'omp3corl': 'OMP3 CORRELATION ENERGY'}; VARH['ocepa'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ocepacorl': 'OCEPA(0) CORRELATION ENERGY'}; VARH['cepa0'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa0corl': 'CEPA(0) CORRELATION ENERGY'}; VARH['cepa(0)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(0)corl': 'CEPA(0) CORRELATION ENERGY'}; VARH['cepa(1)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(1)corl': 'CEPA(1) CORRELATION ENERGY'}; VARH['cepa(3)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(3)corl': 'CEPA(3) CORRELATION ENERGY'}; VARH['acpf'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'acpfcorl': 'ACPF CORRELATION ENERGY'}; VARH['aqcc'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'aqcccorl': 'AQCC CORRELATION ENERGY'}; VARH['qcisd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'qcisdcorl': 'QCISD CORRELATION ENERGY'}; VARH['cc2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc2corl': 'CC2 CORREL",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:66655,Energy Efficiency,ENERGY,ENERGY,66655,": 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(3)corl': 'CEPA(3) CORRELATION ENERGY'}; VARH['acpf'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'acpfcorl': 'ACPF CORRELATION ENERGY'}; VARH['aqcc'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'aqcccorl': 'AQCC CORRELATION ENERGY'}; VARH['qcisd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'qcisdcorl': 'QCISD CORRELATION ENERGY'}; VARH['cc2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc2corl': 'CC2 CORRELATION ENERGY'}; VARH['ccsd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY'}; VARH['bccd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'bccdcorl': 'CCSD CORRELATION ENERGY'}; VARH['cc3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc3corl': 'CC3 CORRELATION ENERGY'}; VARH['fno-df-ccsd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'fno-df-ccsdcorl': 'CCSD CORRELATION ENERGY'}; VARH['fno-df-ccsd(t)'] = {'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'fno-df-ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['qcisd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'qcisdcorl': 'QCISD CORRELATION ENERGY',; 'qcisd(t)corl': 'QCISD(T) CORRELATION ENERGY'}; VARH['ccsd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['bccd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATI",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:66693,Energy Efficiency,ENERGY,ENERGY,66693,": 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(3)corl': 'CEPA(3) CORRELATION ENERGY'}; VARH['acpf'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'acpfcorl': 'ACPF CORRELATION ENERGY'}; VARH['aqcc'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'aqcccorl': 'AQCC CORRELATION ENERGY'}; VARH['qcisd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'qcisdcorl': 'QCISD CORRELATION ENERGY'}; VARH['cc2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc2corl': 'CC2 CORRELATION ENERGY'}; VARH['ccsd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY'}; VARH['bccd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'bccdcorl': 'CCSD CORRELATION ENERGY'}; VARH['cc3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc3corl': 'CC3 CORRELATION ENERGY'}; VARH['fno-df-ccsd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'fno-df-ccsdcorl': 'CCSD CORRELATION ENERGY'}; VARH['fno-df-ccsd(t)'] = {'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'fno-df-ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['qcisd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'qcisdcorl': 'QCISD CORRELATION ENERGY',; 'qcisd(t)corl': 'QCISD(T) CORRELATION ENERGY'}; VARH['ccsd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['bccd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATI",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:66741,Energy Efficiency,ENERGY,ENERGY,66741,": 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(3)corl': 'CEPA(3) CORRELATION ENERGY'}; VARH['acpf'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'acpfcorl': 'ACPF CORRELATION ENERGY'}; VARH['aqcc'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'aqcccorl': 'AQCC CORRELATION ENERGY'}; VARH['qcisd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'qcisdcorl': 'QCISD CORRELATION ENERGY'}; VARH['cc2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc2corl': 'CC2 CORRELATION ENERGY'}; VARH['ccsd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY'}; VARH['bccd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'bccdcorl': 'CCSD CORRELATION ENERGY'}; VARH['cc3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc3corl': 'CC3 CORRELATION ENERGY'}; VARH['fno-df-ccsd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'fno-df-ccsdcorl': 'CCSD CORRELATION ENERGY'}; VARH['fno-df-ccsd(t)'] = {'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'fno-df-ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['qcisd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'qcisdcorl': 'QCISD CORRELATION ENERGY',; 'qcisd(t)corl': 'QCISD(T) CORRELATION ENERGY'}; VARH['ccsd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['bccd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATI",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:66783,Energy Efficiency,ENERGY,ENERGY,66783,": 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(3)corl': 'CEPA(3) CORRELATION ENERGY'}; VARH['acpf'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'acpfcorl': 'ACPF CORRELATION ENERGY'}; VARH['aqcc'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'aqcccorl': 'AQCC CORRELATION ENERGY'}; VARH['qcisd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'qcisdcorl': 'QCISD CORRELATION ENERGY'}; VARH['cc2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc2corl': 'CC2 CORRELATION ENERGY'}; VARH['ccsd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY'}; VARH['bccd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'bccdcorl': 'CCSD CORRELATION ENERGY'}; VARH['cc3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc3corl': 'CC3 CORRELATION ENERGY'}; VARH['fno-df-ccsd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'fno-df-ccsdcorl': 'CCSD CORRELATION ENERGY'}; VARH['fno-df-ccsd(t)'] = {'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'fno-df-ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['qcisd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'qcisdcorl': 'QCISD CORRELATION ENERGY',; 'qcisd(t)corl': 'QCISD(T) CORRELATION ENERGY'}; VARH['ccsd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['bccd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATI",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:66830,Energy Efficiency,ENERGY,ENERGY,66830,": 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(3)corl': 'CEPA(3) CORRELATION ENERGY'}; VARH['acpf'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'acpfcorl': 'ACPF CORRELATION ENERGY'}; VARH['aqcc'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'aqcccorl': 'AQCC CORRELATION ENERGY'}; VARH['qcisd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'qcisdcorl': 'QCISD CORRELATION ENERGY'}; VARH['cc2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc2corl': 'CC2 CORRELATION ENERGY'}; VARH['ccsd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY'}; VARH['bccd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'bccdcorl': 'CCSD CORRELATION ENERGY'}; VARH['cc3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc3corl': 'CC3 CORRELATION ENERGY'}; VARH['fno-df-ccsd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'fno-df-ccsdcorl': 'CCSD CORRELATION ENERGY'}; VARH['fno-df-ccsd(t)'] = {'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'fno-df-ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['qcisd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'qcisdcorl': 'QCISD CORRELATION ENERGY',; 'qcisd(t)corl': 'QCISD(T) CORRELATION ENERGY'}; VARH['ccsd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['bccd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATI",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:66868,Energy Efficiency,ENERGY,ENERGY,66868,": 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(3)corl': 'CEPA(3) CORRELATION ENERGY'}; VARH['acpf'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'acpfcorl': 'ACPF CORRELATION ENERGY'}; VARH['aqcc'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'aqcccorl': 'AQCC CORRELATION ENERGY'}; VARH['qcisd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'qcisdcorl': 'QCISD CORRELATION ENERGY'}; VARH['cc2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc2corl': 'CC2 CORRELATION ENERGY'}; VARH['ccsd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY'}; VARH['bccd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'bccdcorl': 'CCSD CORRELATION ENERGY'}; VARH['cc3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc3corl': 'CC3 CORRELATION ENERGY'}; VARH['fno-df-ccsd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'fno-df-ccsdcorl': 'CCSD CORRELATION ENERGY'}; VARH['fno-df-ccsd(t)'] = {'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'fno-df-ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['qcisd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'qcisdcorl': 'QCISD CORRELATION ENERGY',; 'qcisd(t)corl': 'QCISD(T) CORRELATION ENERGY'}; VARH['ccsd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['bccd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATI",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:66906,Energy Efficiency,ENERGY,ENERGY,66906,": 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(3)corl': 'CEPA(3) CORRELATION ENERGY'}; VARH['acpf'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'acpfcorl': 'ACPF CORRELATION ENERGY'}; VARH['aqcc'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'aqcccorl': 'AQCC CORRELATION ENERGY'}; VARH['qcisd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'qcisdcorl': 'QCISD CORRELATION ENERGY'}; VARH['cc2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc2corl': 'CC2 CORRELATION ENERGY'}; VARH['ccsd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY'}; VARH['bccd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'bccdcorl': 'CCSD CORRELATION ENERGY'}; VARH['cc3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc3corl': 'CC3 CORRELATION ENERGY'}; VARH['fno-df-ccsd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'fno-df-ccsdcorl': 'CCSD CORRELATION ENERGY'}; VARH['fno-df-ccsd(t)'] = {'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'fno-df-ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['qcisd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'qcisdcorl': 'QCISD CORRELATION ENERGY',; 'qcisd(t)corl': 'QCISD(T) CORRELATION ENERGY'}; VARH['ccsd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['bccd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATI",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:66954,Energy Efficiency,ENERGY,ENERGY,66954,": 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(3)corl': 'CEPA(3) CORRELATION ENERGY'}; VARH['acpf'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'acpfcorl': 'ACPF CORRELATION ENERGY'}; VARH['aqcc'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'aqcccorl': 'AQCC CORRELATION ENERGY'}; VARH['qcisd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'qcisdcorl': 'QCISD CORRELATION ENERGY'}; VARH['cc2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc2corl': 'CC2 CORRELATION ENERGY'}; VARH['ccsd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY'}; VARH['bccd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'bccdcorl': 'CCSD CORRELATION ENERGY'}; VARH['cc3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc3corl': 'CC3 CORRELATION ENERGY'}; VARH['fno-df-ccsd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'fno-df-ccsdcorl': 'CCSD CORRELATION ENERGY'}; VARH['fno-df-ccsd(t)'] = {'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'fno-df-ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['qcisd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'qcisdcorl': 'QCISD CORRELATION ENERGY',; 'qcisd(t)corl': 'QCISD(T) CORRELATION ENERGY'}; VARH['ccsd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['bccd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATI",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:66992,Energy Efficiency,ENERGY,ENERGY,66992,": 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(3)corl': 'CEPA(3) CORRELATION ENERGY'}; VARH['acpf'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'acpfcorl': 'ACPF CORRELATION ENERGY'}; VARH['aqcc'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'aqcccorl': 'AQCC CORRELATION ENERGY'}; VARH['qcisd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'qcisdcorl': 'QCISD CORRELATION ENERGY'}; VARH['cc2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc2corl': 'CC2 CORRELATION ENERGY'}; VARH['ccsd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY'}; VARH['bccd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'bccdcorl': 'CCSD CORRELATION ENERGY'}; VARH['cc3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc3corl': 'CC3 CORRELATION ENERGY'}; VARH['fno-df-ccsd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'fno-df-ccsdcorl': 'CCSD CORRELATION ENERGY'}; VARH['fno-df-ccsd(t)'] = {'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'fno-df-ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['qcisd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'qcisdcorl': 'QCISD CORRELATION ENERGY',; 'qcisd(t)corl': 'QCISD(T) CORRELATION ENERGY'}; VARH['ccsd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['bccd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATI",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:67032,Energy Efficiency,ENERGY,ENERGY,67032,": 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(3)corl': 'CEPA(3) CORRELATION ENERGY'}; VARH['acpf'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'acpfcorl': 'ACPF CORRELATION ENERGY'}; VARH['aqcc'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'aqcccorl': 'AQCC CORRELATION ENERGY'}; VARH['qcisd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'qcisdcorl': 'QCISD CORRELATION ENERGY'}; VARH['cc2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc2corl': 'CC2 CORRELATION ENERGY'}; VARH['ccsd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY'}; VARH['bccd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'bccdcorl': 'CCSD CORRELATION ENERGY'}; VARH['cc3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc3corl': 'CC3 CORRELATION ENERGY'}; VARH['fno-df-ccsd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'fno-df-ccsdcorl': 'CCSD CORRELATION ENERGY'}; VARH['fno-df-ccsd(t)'] = {'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'fno-df-ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['qcisd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'qcisdcorl': 'QCISD CORRELATION ENERGY',; 'qcisd(t)corl': 'QCISD(T) CORRELATION ENERGY'}; VARH['ccsd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['bccd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATI",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:67080,Energy Efficiency,ENERGY,ENERGY,67080,": 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(3)corl': 'CEPA(3) CORRELATION ENERGY'}; VARH['acpf'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'acpfcorl': 'ACPF CORRELATION ENERGY'}; VARH['aqcc'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'aqcccorl': 'AQCC CORRELATION ENERGY'}; VARH['qcisd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'qcisdcorl': 'QCISD CORRELATION ENERGY'}; VARH['cc2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc2corl': 'CC2 CORRELATION ENERGY'}; VARH['ccsd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY'}; VARH['bccd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'bccdcorl': 'CCSD CORRELATION ENERGY'}; VARH['cc3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc3corl': 'CC3 CORRELATION ENERGY'}; VARH['fno-df-ccsd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'fno-df-ccsdcorl': 'CCSD CORRELATION ENERGY'}; VARH['fno-df-ccsd(t)'] = {'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'fno-df-ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['qcisd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'qcisdcorl': 'QCISD CORRELATION ENERGY',; 'qcisd(t)corl': 'QCISD(T) CORRELATION ENERGY'}; VARH['ccsd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['bccd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATI",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:67118,Energy Efficiency,ENERGY,ENERGY,67118,": 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(3)corl': 'CEPA(3) CORRELATION ENERGY'}; VARH['acpf'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'acpfcorl': 'ACPF CORRELATION ENERGY'}; VARH['aqcc'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'aqcccorl': 'AQCC CORRELATION ENERGY'}; VARH['qcisd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'qcisdcorl': 'QCISD CORRELATION ENERGY'}; VARH['cc2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc2corl': 'CC2 CORRELATION ENERGY'}; VARH['ccsd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY'}; VARH['bccd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'bccdcorl': 'CCSD CORRELATION ENERGY'}; VARH['cc3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc3corl': 'CC3 CORRELATION ENERGY'}; VARH['fno-df-ccsd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'fno-df-ccsdcorl': 'CCSD CORRELATION ENERGY'}; VARH['fno-df-ccsd(t)'] = {'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'fno-df-ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['qcisd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'qcisdcorl': 'QCISD CORRELATION ENERGY',; 'qcisd(t)corl': 'QCISD(T) CORRELATION ENERGY'}; VARH['ccsd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['bccd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATI",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:67158,Energy Efficiency,ENERGY,ENERGY,67158,": 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(3)corl': 'CEPA(3) CORRELATION ENERGY'}; VARH['acpf'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'acpfcorl': 'ACPF CORRELATION ENERGY'}; VARH['aqcc'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'aqcccorl': 'AQCC CORRELATION ENERGY'}; VARH['qcisd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'qcisdcorl': 'QCISD CORRELATION ENERGY'}; VARH['cc2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc2corl': 'CC2 CORRELATION ENERGY'}; VARH['ccsd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY'}; VARH['bccd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'bccdcorl': 'CCSD CORRELATION ENERGY'}; VARH['cc3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc3corl': 'CC3 CORRELATION ENERGY'}; VARH['fno-df-ccsd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'fno-df-ccsdcorl': 'CCSD CORRELATION ENERGY'}; VARH['fno-df-ccsd(t)'] = {'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'fno-df-ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['qcisd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'qcisdcorl': 'QCISD CORRELATION ENERGY',; 'qcisd(t)corl': 'QCISD(T) CORRELATION ENERGY'}; VARH['ccsd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['bccd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATI",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:67205,Energy Efficiency,ENERGY,ENERGY,67205,": 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(3)corl': 'CEPA(3) CORRELATION ENERGY'}; VARH['acpf'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'acpfcorl': 'ACPF CORRELATION ENERGY'}; VARH['aqcc'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'aqcccorl': 'AQCC CORRELATION ENERGY'}; VARH['qcisd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'qcisdcorl': 'QCISD CORRELATION ENERGY'}; VARH['cc2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc2corl': 'CC2 CORRELATION ENERGY'}; VARH['ccsd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY'}; VARH['bccd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'bccdcorl': 'CCSD CORRELATION ENERGY'}; VARH['cc3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc3corl': 'CC3 CORRELATION ENERGY'}; VARH['fno-df-ccsd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'fno-df-ccsdcorl': 'CCSD CORRELATION ENERGY'}; VARH['fno-df-ccsd(t)'] = {'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'fno-df-ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['qcisd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'qcisdcorl': 'QCISD CORRELATION ENERGY',; 'qcisd(t)corl': 'QCISD(T) CORRELATION ENERGY'}; VARH['ccsd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['bccd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATI",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:67243,Energy Efficiency,ENERGY,ENERGY,67243,": 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(3)corl': 'CEPA(3) CORRELATION ENERGY'}; VARH['acpf'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'acpfcorl': 'ACPF CORRELATION ENERGY'}; VARH['aqcc'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'aqcccorl': 'AQCC CORRELATION ENERGY'}; VARH['qcisd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'qcisdcorl': 'QCISD CORRELATION ENERGY'}; VARH['cc2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc2corl': 'CC2 CORRELATION ENERGY'}; VARH['ccsd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY'}; VARH['bccd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'bccdcorl': 'CCSD CORRELATION ENERGY'}; VARH['cc3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc3corl': 'CC3 CORRELATION ENERGY'}; VARH['fno-df-ccsd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'fno-df-ccsdcorl': 'CCSD CORRELATION ENERGY'}; VARH['fno-df-ccsd(t)'] = {'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'fno-df-ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['qcisd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'qcisdcorl': 'QCISD CORRELATION ENERGY',; 'qcisd(t)corl': 'QCISD(T) CORRELATION ENERGY'}; VARH['ccsd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['bccd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATI",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:67281,Energy Efficiency,ENERGY,ENERGY,67281,": 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(3)corl': 'CEPA(3) CORRELATION ENERGY'}; VARH['acpf'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'acpfcorl': 'ACPF CORRELATION ENERGY'}; VARH['aqcc'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'aqcccorl': 'AQCC CORRELATION ENERGY'}; VARH['qcisd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'qcisdcorl': 'QCISD CORRELATION ENERGY'}; VARH['cc2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc2corl': 'CC2 CORRELATION ENERGY'}; VARH['ccsd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY'}; VARH['bccd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'bccdcorl': 'CCSD CORRELATION ENERGY'}; VARH['cc3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc3corl': 'CC3 CORRELATION ENERGY'}; VARH['fno-df-ccsd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'fno-df-ccsdcorl': 'CCSD CORRELATION ENERGY'}; VARH['fno-df-ccsd(t)'] = {'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'fno-df-ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['qcisd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'qcisdcorl': 'QCISD CORRELATION ENERGY',; 'qcisd(t)corl': 'QCISD(T) CORRELATION ENERGY'}; VARH['ccsd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['bccd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATI",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:67336,Energy Efficiency,ENERGY,ENERGY,67336,": 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(3)corl': 'CEPA(3) CORRELATION ENERGY'}; VARH['acpf'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'acpfcorl': 'ACPF CORRELATION ENERGY'}; VARH['aqcc'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'aqcccorl': 'AQCC CORRELATION ENERGY'}; VARH['qcisd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'qcisdcorl': 'QCISD CORRELATION ENERGY'}; VARH['cc2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc2corl': 'CC2 CORRELATION ENERGY'}; VARH['ccsd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY'}; VARH['bccd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'bccdcorl': 'CCSD CORRELATION ENERGY'}; VARH['cc3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc3corl': 'CC3 CORRELATION ENERGY'}; VARH['fno-df-ccsd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'fno-df-ccsdcorl': 'CCSD CORRELATION ENERGY'}; VARH['fno-df-ccsd(t)'] = {'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'fno-df-ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['qcisd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'qcisdcorl': 'QCISD CORRELATION ENERGY',; 'qcisd(t)corl': 'QCISD(T) CORRELATION ENERGY'}; VARH['ccsd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['bccd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATI",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:67374,Energy Efficiency,ENERGY,ENERGY,67374,": 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(3)corl': 'CEPA(3) CORRELATION ENERGY'}; VARH['acpf'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'acpfcorl': 'ACPF CORRELATION ENERGY'}; VARH['aqcc'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'aqcccorl': 'AQCC CORRELATION ENERGY'}; VARH['qcisd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'qcisdcorl': 'QCISD CORRELATION ENERGY'}; VARH['cc2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc2corl': 'CC2 CORRELATION ENERGY'}; VARH['ccsd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY'}; VARH['bccd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'bccdcorl': 'CCSD CORRELATION ENERGY'}; VARH['cc3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc3corl': 'CC3 CORRELATION ENERGY'}; VARH['fno-df-ccsd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'fno-df-ccsdcorl': 'CCSD CORRELATION ENERGY'}; VARH['fno-df-ccsd(t)'] = {'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'fno-df-ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['qcisd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'qcisdcorl': 'QCISD CORRELATION ENERGY',; 'qcisd(t)corl': 'QCISD(T) CORRELATION ENERGY'}; VARH['ccsd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['bccd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATI",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:67421,Energy Efficiency,ENERGY,ENERGY,67421,": 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(3)corl': 'CEPA(3) CORRELATION ENERGY'}; VARH['acpf'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'acpfcorl': 'ACPF CORRELATION ENERGY'}; VARH['aqcc'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'aqcccorl': 'AQCC CORRELATION ENERGY'}; VARH['qcisd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'qcisdcorl': 'QCISD CORRELATION ENERGY'}; VARH['cc2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc2corl': 'CC2 CORRELATION ENERGY'}; VARH['ccsd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY'}; VARH['bccd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'bccdcorl': 'CCSD CORRELATION ENERGY'}; VARH['cc3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc3corl': 'CC3 CORRELATION ENERGY'}; VARH['fno-df-ccsd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'fno-df-ccsdcorl': 'CCSD CORRELATION ENERGY'}; VARH['fno-df-ccsd(t)'] = {'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'fno-df-ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['qcisd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'qcisdcorl': 'QCISD CORRELATION ENERGY',; 'qcisd(t)corl': 'QCISD(T) CORRELATION ENERGY'}; VARH['ccsd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['bccd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATI",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:67478,Energy Efficiency,ENERGY,ENERGY,67478,": 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(3)corl': 'CEPA(3) CORRELATION ENERGY'}; VARH['acpf'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'acpfcorl': 'ACPF CORRELATION ENERGY'}; VARH['aqcc'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'aqcccorl': 'AQCC CORRELATION ENERGY'}; VARH['qcisd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'qcisdcorl': 'QCISD CORRELATION ENERGY'}; VARH['cc2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc2corl': 'CC2 CORRELATION ENERGY'}; VARH['ccsd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY'}; VARH['bccd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'bccdcorl': 'CCSD CORRELATION ENERGY'}; VARH['cc3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc3corl': 'CC3 CORRELATION ENERGY'}; VARH['fno-df-ccsd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'fno-df-ccsdcorl': 'CCSD CORRELATION ENERGY'}; VARH['fno-df-ccsd(t)'] = {'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'fno-df-ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['qcisd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'qcisdcorl': 'QCISD CORRELATION ENERGY',; 'qcisd(t)corl': 'QCISD(T) CORRELATION ENERGY'}; VARH['ccsd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['bccd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATI",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:67516,Energy Efficiency,ENERGY,ENERGY,67516,": 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(3)corl': 'CEPA(3) CORRELATION ENERGY'}; VARH['acpf'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'acpfcorl': 'ACPF CORRELATION ENERGY'}; VARH['aqcc'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'aqcccorl': 'AQCC CORRELATION ENERGY'}; VARH['qcisd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'qcisdcorl': 'QCISD CORRELATION ENERGY'}; VARH['cc2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc2corl': 'CC2 CORRELATION ENERGY'}; VARH['ccsd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY'}; VARH['bccd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'bccdcorl': 'CCSD CORRELATION ENERGY'}; VARH['cc3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc3corl': 'CC3 CORRELATION ENERGY'}; VARH['fno-df-ccsd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'fno-df-ccsdcorl': 'CCSD CORRELATION ENERGY'}; VARH['fno-df-ccsd(t)'] = {'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'fno-df-ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['qcisd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'qcisdcorl': 'QCISD CORRELATION ENERGY',; 'qcisd(t)corl': 'QCISD(T) CORRELATION ENERGY'}; VARH['ccsd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['bccd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATI",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:67556,Energy Efficiency,ENERGY,ENERGY,67556,": 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(3)corl': 'CEPA(3) CORRELATION ENERGY'}; VARH['acpf'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'acpfcorl': 'ACPF CORRELATION ENERGY'}; VARH['aqcc'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'aqcccorl': 'AQCC CORRELATION ENERGY'}; VARH['qcisd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'qcisdcorl': 'QCISD CORRELATION ENERGY'}; VARH['cc2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc2corl': 'CC2 CORRELATION ENERGY'}; VARH['ccsd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY'}; VARH['bccd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'bccdcorl': 'CCSD CORRELATION ENERGY'}; VARH['cc3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc3corl': 'CC3 CORRELATION ENERGY'}; VARH['fno-df-ccsd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'fno-df-ccsdcorl': 'CCSD CORRELATION ENERGY'}; VARH['fno-df-ccsd(t)'] = {'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'fno-df-ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['qcisd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'qcisdcorl': 'QCISD CORRELATION ENERGY',; 'qcisd(t)corl': 'QCISD(T) CORRELATION ENERGY'}; VARH['ccsd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['bccd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATI",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:67609,Energy Efficiency,ENERGY,ENERGY,67609,": 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(3)corl': 'CEPA(3) CORRELATION ENERGY'}; VARH['acpf'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'acpfcorl': 'ACPF CORRELATION ENERGY'}; VARH['aqcc'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'aqcccorl': 'AQCC CORRELATION ENERGY'}; VARH['qcisd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'qcisdcorl': 'QCISD CORRELATION ENERGY'}; VARH['cc2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc2corl': 'CC2 CORRELATION ENERGY'}; VARH['ccsd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY'}; VARH['bccd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'bccdcorl': 'CCSD CORRELATION ENERGY'}; VARH['cc3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc3corl': 'CC3 CORRELATION ENERGY'}; VARH['fno-df-ccsd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'fno-df-ccsdcorl': 'CCSD CORRELATION ENERGY'}; VARH['fno-df-ccsd(t)'] = {'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'fno-df-ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['qcisd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'qcisdcorl': 'QCISD CORRELATION ENERGY',; 'qcisd(t)corl': 'QCISD(T) CORRELATION ENERGY'}; VARH['ccsd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['bccd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATI",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:67661,Energy Efficiency,ENERGY,ENERGY,67661,": 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(3)corl': 'CEPA(3) CORRELATION ENERGY'}; VARH['acpf'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'acpfcorl': 'ACPF CORRELATION ENERGY'}; VARH['aqcc'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'aqcccorl': 'AQCC CORRELATION ENERGY'}; VARH['qcisd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'qcisdcorl': 'QCISD CORRELATION ENERGY'}; VARH['cc2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc2corl': 'CC2 CORRELATION ENERGY'}; VARH['ccsd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY'}; VARH['bccd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'bccdcorl': 'CCSD CORRELATION ENERGY'}; VARH['cc3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc3corl': 'CC3 CORRELATION ENERGY'}; VARH['fno-df-ccsd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'fno-df-ccsdcorl': 'CCSD CORRELATION ENERGY'}; VARH['fno-df-ccsd(t)'] = {'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'fno-df-ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['qcisd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'qcisdcorl': 'QCISD CORRELATION ENERGY',; 'qcisd(t)corl': 'QCISD(T) CORRELATION ENERGY'}; VARH['ccsd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['bccd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATI",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:67699,Energy Efficiency,ENERGY,ENERGY,67699,": 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa(3)corl': 'CEPA(3) CORRELATION ENERGY'}; VARH['acpf'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'acpfcorl': 'ACPF CORRELATION ENERGY'}; VARH['aqcc'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'aqcccorl': 'AQCC CORRELATION ENERGY'}; VARH['qcisd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'qcisdcorl': 'QCISD CORRELATION ENERGY'}; VARH['cc2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc2corl': 'CC2 CORRELATION ENERGY'}; VARH['ccsd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY'}; VARH['bccd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'bccdcorl': 'CCSD CORRELATION ENERGY'}; VARH['cc3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc3corl': 'CC3 CORRELATION ENERGY'}; VARH['fno-df-ccsd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'fno-df-ccsdcorl': 'CCSD CORRELATION ENERGY'}; VARH['fno-df-ccsd(t)'] = {'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'fno-df-ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['qcisd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'qcisdcorl': 'QCISD CORRELATION ENERGY',; 'qcisd(t)corl': 'QCISD(T) CORRELATION ENERGY'}; VARH['ccsd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['bccd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATI",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:67741,Energy Efficiency,ENERGY,ENERGY,67741,"l': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'fno-df-ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['qcisd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'qcisdcorl': 'QCISD CORRELATION ENERGY',; 'qcisd(t)corl': 'QCISD(T) CORRELATION ENERGY'}; VARH['ccsd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['bccd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'bccd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['cisd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'cisdcorl': 'CISD CORRELATION ENERGY'}; VARH['cisdt'] = { 'scftot': 'SCF TOTAL ENERGY',; 'cisdtcorl': 'CISDT CORRELATION ENERGY'}; VARH['cisdtq'] = { 'scftot': 'SCF TOTAL ENERGY',; 'cisdtqcorl': 'CISDTQ CORRELATION ENERGY'}; VARH['fci'] = { 'scftot': 'SCF TOTAL ENERGY',; 'fcicorl': 'FCI CORRELATION ENERGY'}; VARH['mrccsd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mrccsdcorl': 'CCSD CORRELATION ENERGY'}; VARH['mrccsd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mrccsdcorl': 'CCSD CORRELATION ENERGY',; 'mrccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['mrccsdt'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mrccsdtcorl': 'CCSDT CORRELATION ENERGY'}; VARH['mrccsdt(q)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mrccsdtcorl': 'CCSDT CORRELATION ENERGY',; 'mrccsdt(q)corl': 'CCSDT(Q) CORRELATION ENERGY'}. for cilevel in range(2, 99):; VARH['ci%s' % (str(cilevel))] = {; 'scftot': 'SCF TOTAL ENERGY',; 'ci%scorl' % (str(cilevel)): 'CI CORRELATION ENERGY'}. finalenergy = 0.0; do_scf = 1; do_corl = 0; do_delta = 0; do_delta2 = 0; do_delt",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:67779,Energy Efficiency,ENERGY,ENERGY,67779,"l': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'fno-df-ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['qcisd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'qcisdcorl': 'QCISD CORRELATION ENERGY',; 'qcisd(t)corl': 'QCISD(T) CORRELATION ENERGY'}; VARH['ccsd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['bccd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'bccd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['cisd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'cisdcorl': 'CISD CORRELATION ENERGY'}; VARH['cisdt'] = { 'scftot': 'SCF TOTAL ENERGY',; 'cisdtcorl': 'CISDT CORRELATION ENERGY'}; VARH['cisdtq'] = { 'scftot': 'SCF TOTAL ENERGY',; 'cisdtqcorl': 'CISDTQ CORRELATION ENERGY'}; VARH['fci'] = { 'scftot': 'SCF TOTAL ENERGY',; 'fcicorl': 'FCI CORRELATION ENERGY'}; VARH['mrccsd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mrccsdcorl': 'CCSD CORRELATION ENERGY'}; VARH['mrccsd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mrccsdcorl': 'CCSD CORRELATION ENERGY',; 'mrccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['mrccsdt'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mrccsdtcorl': 'CCSDT CORRELATION ENERGY'}; VARH['mrccsdt(q)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mrccsdtcorl': 'CCSDT CORRELATION ENERGY',; 'mrccsdt(q)corl': 'CCSDT(Q) CORRELATION ENERGY'}. for cilevel in range(2, 99):; VARH['ci%s' % (str(cilevel))] = {; 'scftot': 'SCF TOTAL ENERGY',; 'ci%scorl' % (str(cilevel)): 'CI CORRELATION ENERGY'}. finalenergy = 0.0; do_scf = 1; do_corl = 0; do_delta = 0; do_delta2 = 0; do_delt",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:67827,Energy Efficiency,ENERGY,ENERGY,67827,"l': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'fno-df-ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['qcisd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'qcisdcorl': 'QCISD CORRELATION ENERGY',; 'qcisd(t)corl': 'QCISD(T) CORRELATION ENERGY'}; VARH['ccsd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['bccd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'bccd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['cisd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'cisdcorl': 'CISD CORRELATION ENERGY'}; VARH['cisdt'] = { 'scftot': 'SCF TOTAL ENERGY',; 'cisdtcorl': 'CISDT CORRELATION ENERGY'}; VARH['cisdtq'] = { 'scftot': 'SCF TOTAL ENERGY',; 'cisdtqcorl': 'CISDTQ CORRELATION ENERGY'}; VARH['fci'] = { 'scftot': 'SCF TOTAL ENERGY',; 'fcicorl': 'FCI CORRELATION ENERGY'}; VARH['mrccsd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mrccsdcorl': 'CCSD CORRELATION ENERGY'}; VARH['mrccsd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mrccsdcorl': 'CCSD CORRELATION ENERGY',; 'mrccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['mrccsdt'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mrccsdtcorl': 'CCSDT CORRELATION ENERGY'}; VARH['mrccsdt(q)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mrccsdtcorl': 'CCSDT CORRELATION ENERGY',; 'mrccsdt(q)corl': 'CCSDT(Q) CORRELATION ENERGY'}. for cilevel in range(2, 99):; VARH['ci%s' % (str(cilevel))] = {; 'scftot': 'SCF TOTAL ENERGY',; 'ci%scorl' % (str(cilevel)): 'CI CORRELATION ENERGY'}. finalenergy = 0.0; do_scf = 1; do_corl = 0; do_delta = 0; do_delta2 = 0; do_delt",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:67869,Energy Efficiency,ENERGY,ENERGY,67869,"l': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'fno-df-ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['qcisd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'qcisdcorl': 'QCISD CORRELATION ENERGY',; 'qcisd(t)corl': 'QCISD(T) CORRELATION ENERGY'}; VARH['ccsd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['bccd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'bccd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['cisd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'cisdcorl': 'CISD CORRELATION ENERGY'}; VARH['cisdt'] = { 'scftot': 'SCF TOTAL ENERGY',; 'cisdtcorl': 'CISDT CORRELATION ENERGY'}; VARH['cisdtq'] = { 'scftot': 'SCF TOTAL ENERGY',; 'cisdtqcorl': 'CISDTQ CORRELATION ENERGY'}; VARH['fci'] = { 'scftot': 'SCF TOTAL ENERGY',; 'fcicorl': 'FCI CORRELATION ENERGY'}; VARH['mrccsd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mrccsdcorl': 'CCSD CORRELATION ENERGY'}; VARH['mrccsd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mrccsdcorl': 'CCSD CORRELATION ENERGY',; 'mrccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['mrccsdt'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mrccsdtcorl': 'CCSDT CORRELATION ENERGY'}; VARH['mrccsdt(q)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mrccsdtcorl': 'CCSDT CORRELATION ENERGY',; 'mrccsdt(q)corl': 'CCSDT(Q) CORRELATION ENERGY'}. for cilevel in range(2, 99):; VARH['ci%s' % (str(cilevel))] = {; 'scftot': 'SCF TOTAL ENERGY',; 'ci%scorl' % (str(cilevel)): 'CI CORRELATION ENERGY'}. finalenergy = 0.0; do_scf = 1; do_corl = 0; do_delta = 0; do_delta2 = 0; do_delt",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:67917,Energy Efficiency,ENERGY,ENERGY,67917,"l': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'fno-df-ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['qcisd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'qcisdcorl': 'QCISD CORRELATION ENERGY',; 'qcisd(t)corl': 'QCISD(T) CORRELATION ENERGY'}; VARH['ccsd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['bccd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'bccd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['cisd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'cisdcorl': 'CISD CORRELATION ENERGY'}; VARH['cisdt'] = { 'scftot': 'SCF TOTAL ENERGY',; 'cisdtcorl': 'CISDT CORRELATION ENERGY'}; VARH['cisdtq'] = { 'scftot': 'SCF TOTAL ENERGY',; 'cisdtqcorl': 'CISDTQ CORRELATION ENERGY'}; VARH['fci'] = { 'scftot': 'SCF TOTAL ENERGY',; 'fcicorl': 'FCI CORRELATION ENERGY'}; VARH['mrccsd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mrccsdcorl': 'CCSD CORRELATION ENERGY'}; VARH['mrccsd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mrccsdcorl': 'CCSD CORRELATION ENERGY',; 'mrccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['mrccsdt'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mrccsdtcorl': 'CCSDT CORRELATION ENERGY'}; VARH['mrccsdt(q)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mrccsdtcorl': 'CCSDT CORRELATION ENERGY',; 'mrccsdt(q)corl': 'CCSDT(Q) CORRELATION ENERGY'}. for cilevel in range(2, 99):; VARH['ci%s' % (str(cilevel))] = {; 'scftot': 'SCF TOTAL ENERGY',; 'ci%scorl' % (str(cilevel)): 'CI CORRELATION ENERGY'}. finalenergy = 0.0; do_scf = 1; do_corl = 0; do_delta = 0; do_delta2 = 0; do_delt",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:67968,Energy Efficiency,ENERGY,ENERGY,67968,"l': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'fno-df-ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['qcisd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'qcisdcorl': 'QCISD CORRELATION ENERGY',; 'qcisd(t)corl': 'QCISD(T) CORRELATION ENERGY'}; VARH['ccsd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['bccd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'bccd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['cisd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'cisdcorl': 'CISD CORRELATION ENERGY'}; VARH['cisdt'] = { 'scftot': 'SCF TOTAL ENERGY',; 'cisdtcorl': 'CISDT CORRELATION ENERGY'}; VARH['cisdtq'] = { 'scftot': 'SCF TOTAL ENERGY',; 'cisdtqcorl': 'CISDTQ CORRELATION ENERGY'}; VARH['fci'] = { 'scftot': 'SCF TOTAL ENERGY',; 'fcicorl': 'FCI CORRELATION ENERGY'}; VARH['mrccsd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mrccsdcorl': 'CCSD CORRELATION ENERGY'}; VARH['mrccsd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mrccsdcorl': 'CCSD CORRELATION ENERGY',; 'mrccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['mrccsdt'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mrccsdtcorl': 'CCSDT CORRELATION ENERGY'}; VARH['mrccsdt(q)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mrccsdtcorl': 'CCSDT CORRELATION ENERGY',; 'mrccsdt(q)corl': 'CCSDT(Q) CORRELATION ENERGY'}. for cilevel in range(2, 99):; VARH['ci%s' % (str(cilevel))] = {; 'scftot': 'SCF TOTAL ENERGY',; 'ci%scorl' % (str(cilevel)): 'CI CORRELATION ENERGY'}. finalenergy = 0.0; do_scf = 1; do_corl = 0; do_delta = 0; do_delta2 = 0; do_delt",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:68006,Energy Efficiency,ENERGY,ENERGY,68006,"l': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'fno-df-ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['qcisd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'qcisdcorl': 'QCISD CORRELATION ENERGY',; 'qcisd(t)corl': 'QCISD(T) CORRELATION ENERGY'}; VARH['ccsd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['bccd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'bccd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['cisd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'cisdcorl': 'CISD CORRELATION ENERGY'}; VARH['cisdt'] = { 'scftot': 'SCF TOTAL ENERGY',; 'cisdtcorl': 'CISDT CORRELATION ENERGY'}; VARH['cisdtq'] = { 'scftot': 'SCF TOTAL ENERGY',; 'cisdtqcorl': 'CISDTQ CORRELATION ENERGY'}; VARH['fci'] = { 'scftot': 'SCF TOTAL ENERGY',; 'fcicorl': 'FCI CORRELATION ENERGY'}; VARH['mrccsd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mrccsdcorl': 'CCSD CORRELATION ENERGY'}; VARH['mrccsd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mrccsdcorl': 'CCSD CORRELATION ENERGY',; 'mrccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['mrccsdt'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mrccsdtcorl': 'CCSDT CORRELATION ENERGY'}; VARH['mrccsdt(q)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mrccsdtcorl': 'CCSDT CORRELATION ENERGY',; 'mrccsdt(q)corl': 'CCSDT(Q) CORRELATION ENERGY'}. for cilevel in range(2, 99):; VARH['ci%s' % (str(cilevel))] = {; 'scftot': 'SCF TOTAL ENERGY',; 'ci%scorl' % (str(cilevel)): 'CI CORRELATION ENERGY'}. finalenergy = 0.0; do_scf = 1; do_corl = 0; do_delta = 0; do_delta2 = 0; do_delt",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:68046,Energy Efficiency,ENERGY,ENERGY,68046,"l': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'fno-df-ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['qcisd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'qcisdcorl': 'QCISD CORRELATION ENERGY',; 'qcisd(t)corl': 'QCISD(T) CORRELATION ENERGY'}; VARH['ccsd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['bccd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'bccd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['cisd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'cisdcorl': 'CISD CORRELATION ENERGY'}; VARH['cisdt'] = { 'scftot': 'SCF TOTAL ENERGY',; 'cisdtcorl': 'CISDT CORRELATION ENERGY'}; VARH['cisdtq'] = { 'scftot': 'SCF TOTAL ENERGY',; 'cisdtqcorl': 'CISDTQ CORRELATION ENERGY'}; VARH['fci'] = { 'scftot': 'SCF TOTAL ENERGY',; 'fcicorl': 'FCI CORRELATION ENERGY'}; VARH['mrccsd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mrccsdcorl': 'CCSD CORRELATION ENERGY'}; VARH['mrccsd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mrccsdcorl': 'CCSD CORRELATION ENERGY',; 'mrccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['mrccsdt'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mrccsdtcorl': 'CCSDT CORRELATION ENERGY'}; VARH['mrccsdt(q)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mrccsdtcorl': 'CCSDT CORRELATION ENERGY',; 'mrccsdt(q)corl': 'CCSDT(Q) CORRELATION ENERGY'}. for cilevel in range(2, 99):; VARH['ci%s' % (str(cilevel))] = {; 'scftot': 'SCF TOTAL ENERGY',; 'ci%scorl' % (str(cilevel)): 'CI CORRELATION ENERGY'}. finalenergy = 0.0; do_scf = 1; do_corl = 0; do_delta = 0; do_delta2 = 0; do_delt",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:68092,Energy Efficiency,ENERGY,ENERGY,68092,"l': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'fno-df-ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['qcisd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'qcisdcorl': 'QCISD CORRELATION ENERGY',; 'qcisd(t)corl': 'QCISD(T) CORRELATION ENERGY'}; VARH['ccsd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['bccd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'bccd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['cisd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'cisdcorl': 'CISD CORRELATION ENERGY'}; VARH['cisdt'] = { 'scftot': 'SCF TOTAL ENERGY',; 'cisdtcorl': 'CISDT CORRELATION ENERGY'}; VARH['cisdtq'] = { 'scftot': 'SCF TOTAL ENERGY',; 'cisdtqcorl': 'CISDTQ CORRELATION ENERGY'}; VARH['fci'] = { 'scftot': 'SCF TOTAL ENERGY',; 'fcicorl': 'FCI CORRELATION ENERGY'}; VARH['mrccsd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mrccsdcorl': 'CCSD CORRELATION ENERGY'}; VARH['mrccsd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mrccsdcorl': 'CCSD CORRELATION ENERGY',; 'mrccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['mrccsdt'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mrccsdtcorl': 'CCSDT CORRELATION ENERGY'}; VARH['mrccsdt(q)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mrccsdtcorl': 'CCSDT CORRELATION ENERGY',; 'mrccsdt(q)corl': 'CCSDT(Q) CORRELATION ENERGY'}. for cilevel in range(2, 99):; VARH['ci%s' % (str(cilevel))] = {; 'scftot': 'SCF TOTAL ENERGY',; 'ci%scorl' % (str(cilevel)): 'CI CORRELATION ENERGY'}. finalenergy = 0.0; do_scf = 1; do_corl = 0; do_delta = 0; do_delta2 = 0; do_delt",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:68143,Energy Efficiency,ENERGY,ENERGY,68143,"l': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'fno-df-ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['qcisd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'qcisdcorl': 'QCISD CORRELATION ENERGY',; 'qcisd(t)corl': 'QCISD(T) CORRELATION ENERGY'}; VARH['ccsd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['bccd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'bccd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['cisd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'cisdcorl': 'CISD CORRELATION ENERGY'}; VARH['cisdt'] = { 'scftot': 'SCF TOTAL ENERGY',; 'cisdtcorl': 'CISDT CORRELATION ENERGY'}; VARH['cisdtq'] = { 'scftot': 'SCF TOTAL ENERGY',; 'cisdtqcorl': 'CISDTQ CORRELATION ENERGY'}; VARH['fci'] = { 'scftot': 'SCF TOTAL ENERGY',; 'fcicorl': 'FCI CORRELATION ENERGY'}; VARH['mrccsd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mrccsdcorl': 'CCSD CORRELATION ENERGY'}; VARH['mrccsd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mrccsdcorl': 'CCSD CORRELATION ENERGY',; 'mrccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['mrccsdt'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mrccsdtcorl': 'CCSDT CORRELATION ENERGY'}; VARH['mrccsdt(q)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mrccsdtcorl': 'CCSDT CORRELATION ENERGY',; 'mrccsdt(q)corl': 'CCSDT(Q) CORRELATION ENERGY'}. for cilevel in range(2, 99):; VARH['ci%s' % (str(cilevel))] = {; 'scftot': 'SCF TOTAL ENERGY',; 'ci%scorl' % (str(cilevel)): 'CI CORRELATION ENERGY'}. finalenergy = 0.0; do_scf = 1; do_corl = 0; do_delta = 0; do_delta2 = 0; do_delt",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:68181,Energy Efficiency,ENERGY,ENERGY,68181,"l': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'fno-df-ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['qcisd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'qcisdcorl': 'QCISD CORRELATION ENERGY',; 'qcisd(t)corl': 'QCISD(T) CORRELATION ENERGY'}; VARH['ccsd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['bccd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'bccd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['cisd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'cisdcorl': 'CISD CORRELATION ENERGY'}; VARH['cisdt'] = { 'scftot': 'SCF TOTAL ENERGY',; 'cisdtcorl': 'CISDT CORRELATION ENERGY'}; VARH['cisdtq'] = { 'scftot': 'SCF TOTAL ENERGY',; 'cisdtqcorl': 'CISDTQ CORRELATION ENERGY'}; VARH['fci'] = { 'scftot': 'SCF TOTAL ENERGY',; 'fcicorl': 'FCI CORRELATION ENERGY'}; VARH['mrccsd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mrccsdcorl': 'CCSD CORRELATION ENERGY'}; VARH['mrccsd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mrccsdcorl': 'CCSD CORRELATION ENERGY',; 'mrccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['mrccsdt'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mrccsdtcorl': 'CCSDT CORRELATION ENERGY'}; VARH['mrccsdt(q)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mrccsdtcorl': 'CCSDT CORRELATION ENERGY',; 'mrccsdt(q)corl': 'CCSDT(Q) CORRELATION ENERGY'}. for cilevel in range(2, 99):; VARH['ci%s' % (str(cilevel))] = {; 'scftot': 'SCF TOTAL ENERGY',; 'ci%scorl' % (str(cilevel)): 'CI CORRELATION ENERGY'}. finalenergy = 0.0; do_scf = 1; do_corl = 0; do_delta = 0; do_delta2 = 0; do_delt",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:68221,Energy Efficiency,ENERGY,ENERGY,68221,"l': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'fno-df-ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['qcisd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'qcisdcorl': 'QCISD CORRELATION ENERGY',; 'qcisd(t)corl': 'QCISD(T) CORRELATION ENERGY'}; VARH['ccsd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['bccd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'bccd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['cisd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'cisdcorl': 'CISD CORRELATION ENERGY'}; VARH['cisdt'] = { 'scftot': 'SCF TOTAL ENERGY',; 'cisdtcorl': 'CISDT CORRELATION ENERGY'}; VARH['cisdtq'] = { 'scftot': 'SCF TOTAL ENERGY',; 'cisdtqcorl': 'CISDTQ CORRELATION ENERGY'}; VARH['fci'] = { 'scftot': 'SCF TOTAL ENERGY',; 'fcicorl': 'FCI CORRELATION ENERGY'}; VARH['mrccsd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mrccsdcorl': 'CCSD CORRELATION ENERGY'}; VARH['mrccsd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mrccsdcorl': 'CCSD CORRELATION ENERGY',; 'mrccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['mrccsdt'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mrccsdtcorl': 'CCSDT CORRELATION ENERGY'}; VARH['mrccsdt(q)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mrccsdtcorl': 'CCSDT CORRELATION ENERGY',; 'mrccsdt(q)corl': 'CCSDT(Q) CORRELATION ENERGY'}. for cilevel in range(2, 99):; VARH['ci%s' % (str(cilevel))] = {; 'scftot': 'SCF TOTAL ENERGY',; 'ci%scorl' % (str(cilevel)): 'CI CORRELATION ENERGY'}. finalenergy = 0.0; do_scf = 1; do_corl = 0; do_delta = 0; do_delta2 = 0; do_delt",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:68267,Energy Efficiency,ENERGY,ENERGY,68267,"l': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'fno-df-ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['qcisd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'qcisdcorl': 'QCISD CORRELATION ENERGY',; 'qcisd(t)corl': 'QCISD(T) CORRELATION ENERGY'}; VARH['ccsd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['bccd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'bccd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['cisd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'cisdcorl': 'CISD CORRELATION ENERGY'}; VARH['cisdt'] = { 'scftot': 'SCF TOTAL ENERGY',; 'cisdtcorl': 'CISDT CORRELATION ENERGY'}; VARH['cisdtq'] = { 'scftot': 'SCF TOTAL ENERGY',; 'cisdtqcorl': 'CISDTQ CORRELATION ENERGY'}; VARH['fci'] = { 'scftot': 'SCF TOTAL ENERGY',; 'fcicorl': 'FCI CORRELATION ENERGY'}; VARH['mrccsd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mrccsdcorl': 'CCSD CORRELATION ENERGY'}; VARH['mrccsd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mrccsdcorl': 'CCSD CORRELATION ENERGY',; 'mrccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['mrccsdt'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mrccsdtcorl': 'CCSDT CORRELATION ENERGY'}; VARH['mrccsdt(q)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mrccsdtcorl': 'CCSDT CORRELATION ENERGY',; 'mrccsdt(q)corl': 'CCSDT(Q) CORRELATION ENERGY'}. for cilevel in range(2, 99):; VARH['ci%s' % (str(cilevel))] = {; 'scftot': 'SCF TOTAL ENERGY',; 'ci%scorl' % (str(cilevel)): 'CI CORRELATION ENERGY'}. finalenergy = 0.0; do_scf = 1; do_corl = 0; do_delta = 0; do_delta2 = 0; do_delt",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:68315,Energy Efficiency,ENERGY,ENERGY,68315,"l': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'fno-df-ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['qcisd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'qcisdcorl': 'QCISD CORRELATION ENERGY',; 'qcisd(t)corl': 'QCISD(T) CORRELATION ENERGY'}; VARH['ccsd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['bccd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'bccd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['cisd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'cisdcorl': 'CISD CORRELATION ENERGY'}; VARH['cisdt'] = { 'scftot': 'SCF TOTAL ENERGY',; 'cisdtcorl': 'CISDT CORRELATION ENERGY'}; VARH['cisdtq'] = { 'scftot': 'SCF TOTAL ENERGY',; 'cisdtqcorl': 'CISDTQ CORRELATION ENERGY'}; VARH['fci'] = { 'scftot': 'SCF TOTAL ENERGY',; 'fcicorl': 'FCI CORRELATION ENERGY'}; VARH['mrccsd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mrccsdcorl': 'CCSD CORRELATION ENERGY'}; VARH['mrccsd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mrccsdcorl': 'CCSD CORRELATION ENERGY',; 'mrccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['mrccsdt'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mrccsdtcorl': 'CCSDT CORRELATION ENERGY'}; VARH['mrccsdt(q)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mrccsdtcorl': 'CCSDT CORRELATION ENERGY',; 'mrccsdt(q)corl': 'CCSDT(Q) CORRELATION ENERGY'}. for cilevel in range(2, 99):; VARH['ci%s' % (str(cilevel))] = {; 'scftot': 'SCF TOTAL ENERGY',; 'ci%scorl' % (str(cilevel)): 'CI CORRELATION ENERGY'}. finalenergy = 0.0; do_scf = 1; do_corl = 0; do_delta = 0; do_delta2 = 0; do_delt",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:68355,Energy Efficiency,ENERGY,ENERGY,68355,"l': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'fno-df-ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['qcisd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'qcisdcorl': 'QCISD CORRELATION ENERGY',; 'qcisd(t)corl': 'QCISD(T) CORRELATION ENERGY'}; VARH['ccsd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['bccd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'bccd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['cisd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'cisdcorl': 'CISD CORRELATION ENERGY'}; VARH['cisdt'] = { 'scftot': 'SCF TOTAL ENERGY',; 'cisdtcorl': 'CISDT CORRELATION ENERGY'}; VARH['cisdtq'] = { 'scftot': 'SCF TOTAL ENERGY',; 'cisdtqcorl': 'CISDTQ CORRELATION ENERGY'}; VARH['fci'] = { 'scftot': 'SCF TOTAL ENERGY',; 'fcicorl': 'FCI CORRELATION ENERGY'}; VARH['mrccsd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mrccsdcorl': 'CCSD CORRELATION ENERGY'}; VARH['mrccsd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mrccsdcorl': 'CCSD CORRELATION ENERGY',; 'mrccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['mrccsdt'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mrccsdtcorl': 'CCSDT CORRELATION ENERGY'}; VARH['mrccsdt(q)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mrccsdtcorl': 'CCSDT CORRELATION ENERGY',; 'mrccsdt(q)corl': 'CCSDT(Q) CORRELATION ENERGY'}. for cilevel in range(2, 99):; VARH['ci%s' % (str(cilevel))] = {; 'scftot': 'SCF TOTAL ENERGY',; 'ci%scorl' % (str(cilevel)): 'CI CORRELATION ENERGY'}. finalenergy = 0.0; do_scf = 1; do_corl = 0; do_delta = 0; do_delta2 = 0; do_delt",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:68404,Energy Efficiency,ENERGY,ENERGY,68404,"l': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'fno-df-ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['qcisd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'qcisdcorl': 'QCISD CORRELATION ENERGY',; 'qcisd(t)corl': 'QCISD(T) CORRELATION ENERGY'}; VARH['ccsd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['bccd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'bccd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['cisd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'cisdcorl': 'CISD CORRELATION ENERGY'}; VARH['cisdt'] = { 'scftot': 'SCF TOTAL ENERGY',; 'cisdtcorl': 'CISDT CORRELATION ENERGY'}; VARH['cisdtq'] = { 'scftot': 'SCF TOTAL ENERGY',; 'cisdtqcorl': 'CISDTQ CORRELATION ENERGY'}; VARH['fci'] = { 'scftot': 'SCF TOTAL ENERGY',; 'fcicorl': 'FCI CORRELATION ENERGY'}; VARH['mrccsd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mrccsdcorl': 'CCSD CORRELATION ENERGY'}; VARH['mrccsd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mrccsdcorl': 'CCSD CORRELATION ENERGY',; 'mrccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['mrccsdt'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mrccsdtcorl': 'CCSDT CORRELATION ENERGY'}; VARH['mrccsdt(q)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mrccsdtcorl': 'CCSDT CORRELATION ENERGY',; 'mrccsdt(q)corl': 'CCSDT(Q) CORRELATION ENERGY'}. for cilevel in range(2, 99):; VARH['ci%s' % (str(cilevel))] = {; 'scftot': 'SCF TOTAL ENERGY',; 'ci%scorl' % (str(cilevel)): 'CI CORRELATION ENERGY'}. finalenergy = 0.0; do_scf = 1; do_corl = 0; do_delta = 0; do_delta2 = 0; do_delt",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:68446,Energy Efficiency,ENERGY,ENERGY,68446,"l': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'fno-df-ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['qcisd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'qcisdcorl': 'QCISD CORRELATION ENERGY',; 'qcisd(t)corl': 'QCISD(T) CORRELATION ENERGY'}; VARH['ccsd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['bccd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'bccd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['cisd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'cisdcorl': 'CISD CORRELATION ENERGY'}; VARH['cisdt'] = { 'scftot': 'SCF TOTAL ENERGY',; 'cisdtcorl': 'CISDT CORRELATION ENERGY'}; VARH['cisdtq'] = { 'scftot': 'SCF TOTAL ENERGY',; 'cisdtqcorl': 'CISDTQ CORRELATION ENERGY'}; VARH['fci'] = { 'scftot': 'SCF TOTAL ENERGY',; 'fcicorl': 'FCI CORRELATION ENERGY'}; VARH['mrccsd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mrccsdcorl': 'CCSD CORRELATION ENERGY'}; VARH['mrccsd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mrccsdcorl': 'CCSD CORRELATION ENERGY',; 'mrccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['mrccsdt'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mrccsdtcorl': 'CCSDT CORRELATION ENERGY'}; VARH['mrccsdt(q)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mrccsdtcorl': 'CCSDT CORRELATION ENERGY',; 'mrccsdt(q)corl': 'CCSDT(Q) CORRELATION ENERGY'}. for cilevel in range(2, 99):; VARH['ci%s' % (str(cilevel))] = {; 'scftot': 'SCF TOTAL ENERGY',; 'ci%scorl' % (str(cilevel)): 'CI CORRELATION ENERGY'}. finalenergy = 0.0; do_scf = 1; do_corl = 0; do_delta = 0; do_delta2 = 0; do_delt",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:68496,Energy Efficiency,ENERGY,ENERGY,68496,"l': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'fno-df-ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['qcisd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'qcisdcorl': 'QCISD CORRELATION ENERGY',; 'qcisd(t)corl': 'QCISD(T) CORRELATION ENERGY'}; VARH['ccsd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['bccd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'bccd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['cisd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'cisdcorl': 'CISD CORRELATION ENERGY'}; VARH['cisdt'] = { 'scftot': 'SCF TOTAL ENERGY',; 'cisdtcorl': 'CISDT CORRELATION ENERGY'}; VARH['cisdtq'] = { 'scftot': 'SCF TOTAL ENERGY',; 'cisdtqcorl': 'CISDTQ CORRELATION ENERGY'}; VARH['fci'] = { 'scftot': 'SCF TOTAL ENERGY',; 'fcicorl': 'FCI CORRELATION ENERGY'}; VARH['mrccsd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mrccsdcorl': 'CCSD CORRELATION ENERGY'}; VARH['mrccsd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mrccsdcorl': 'CCSD CORRELATION ENERGY',; 'mrccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['mrccsdt'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mrccsdtcorl': 'CCSDT CORRELATION ENERGY'}; VARH['mrccsdt(q)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mrccsdtcorl': 'CCSDT CORRELATION ENERGY',; 'mrccsdt(q)corl': 'CCSDT(Q) CORRELATION ENERGY'}. for cilevel in range(2, 99):; VARH['ci%s' % (str(cilevel))] = {; 'scftot': 'SCF TOTAL ENERGY',; 'ci%scorl' % (str(cilevel)): 'CI CORRELATION ENERGY'}. finalenergy = 0.0; do_scf = 1; do_corl = 0; do_delta = 0; do_delta2 = 0; do_delt",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:68540,Energy Efficiency,ENERGY,ENERGY,68540,"l': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'fno-df-ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['qcisd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'qcisdcorl': 'QCISD CORRELATION ENERGY',; 'qcisd(t)corl': 'QCISD(T) CORRELATION ENERGY'}; VARH['ccsd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['bccd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'bccd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['cisd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'cisdcorl': 'CISD CORRELATION ENERGY'}; VARH['cisdt'] = { 'scftot': 'SCF TOTAL ENERGY',; 'cisdtcorl': 'CISDT CORRELATION ENERGY'}; VARH['cisdtq'] = { 'scftot': 'SCF TOTAL ENERGY',; 'cisdtqcorl': 'CISDTQ CORRELATION ENERGY'}; VARH['fci'] = { 'scftot': 'SCF TOTAL ENERGY',; 'fcicorl': 'FCI CORRELATION ENERGY'}; VARH['mrccsd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mrccsdcorl': 'CCSD CORRELATION ENERGY'}; VARH['mrccsd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mrccsdcorl': 'CCSD CORRELATION ENERGY',; 'mrccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['mrccsdt'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mrccsdtcorl': 'CCSDT CORRELATION ENERGY'}; VARH['mrccsdt(q)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mrccsdtcorl': 'CCSDT CORRELATION ENERGY',; 'mrccsdt(q)corl': 'CCSDT(Q) CORRELATION ENERGY'}. for cilevel in range(2, 99):; VARH['ci%s' % (str(cilevel))] = {; 'scftot': 'SCF TOTAL ENERGY',; 'ci%scorl' % (str(cilevel)): 'CI CORRELATION ENERGY'}. finalenergy = 0.0; do_scf = 1; do_corl = 0; do_delta = 0; do_delta2 = 0; do_delt",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:68587,Energy Efficiency,ENERGY,ENERGY,68587,"l': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'fno-df-ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['qcisd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'qcisdcorl': 'QCISD CORRELATION ENERGY',; 'qcisd(t)corl': 'QCISD(T) CORRELATION ENERGY'}; VARH['ccsd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['bccd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'bccd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['cisd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'cisdcorl': 'CISD CORRELATION ENERGY'}; VARH['cisdt'] = { 'scftot': 'SCF TOTAL ENERGY',; 'cisdtcorl': 'CISDT CORRELATION ENERGY'}; VARH['cisdtq'] = { 'scftot': 'SCF TOTAL ENERGY',; 'cisdtqcorl': 'CISDTQ CORRELATION ENERGY'}; VARH['fci'] = { 'scftot': 'SCF TOTAL ENERGY',; 'fcicorl': 'FCI CORRELATION ENERGY'}; VARH['mrccsd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mrccsdcorl': 'CCSD CORRELATION ENERGY'}; VARH['mrccsd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mrccsdcorl': 'CCSD CORRELATION ENERGY',; 'mrccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['mrccsdt'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mrccsdtcorl': 'CCSDT CORRELATION ENERGY'}; VARH['mrccsdt(q)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mrccsdtcorl': 'CCSDT CORRELATION ENERGY',; 'mrccsdt(q)corl': 'CCSDT(Q) CORRELATION ENERGY'}. for cilevel in range(2, 99):; VARH['ci%s' % (str(cilevel))] = {; 'scftot': 'SCF TOTAL ENERGY',; 'ci%scorl' % (str(cilevel)): 'CI CORRELATION ENERGY'}. finalenergy = 0.0; do_scf = 1; do_corl = 0; do_delta = 0; do_delta2 = 0; do_delt",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:68625,Energy Efficiency,ENERGY,ENERGY,68625,"l': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'fno-df-ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['qcisd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'qcisdcorl': 'QCISD CORRELATION ENERGY',; 'qcisd(t)corl': 'QCISD(T) CORRELATION ENERGY'}; VARH['ccsd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['bccd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'bccd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['cisd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'cisdcorl': 'CISD CORRELATION ENERGY'}; VARH['cisdt'] = { 'scftot': 'SCF TOTAL ENERGY',; 'cisdtcorl': 'CISDT CORRELATION ENERGY'}; VARH['cisdtq'] = { 'scftot': 'SCF TOTAL ENERGY',; 'cisdtqcorl': 'CISDTQ CORRELATION ENERGY'}; VARH['fci'] = { 'scftot': 'SCF TOTAL ENERGY',; 'fcicorl': 'FCI CORRELATION ENERGY'}; VARH['mrccsd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mrccsdcorl': 'CCSD CORRELATION ENERGY'}; VARH['mrccsd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mrccsdcorl': 'CCSD CORRELATION ENERGY',; 'mrccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['mrccsdt'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mrccsdtcorl': 'CCSDT CORRELATION ENERGY'}; VARH['mrccsdt(q)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mrccsdtcorl': 'CCSDT CORRELATION ENERGY',; 'mrccsdt(q)corl': 'CCSDT(Q) CORRELATION ENERGY'}. for cilevel in range(2, 99):; VARH['ci%s' % (str(cilevel))] = {; 'scftot': 'SCF TOTAL ENERGY',; 'ci%scorl' % (str(cilevel)): 'CI CORRELATION ENERGY'}. finalenergy = 0.0; do_scf = 1; do_corl = 0; do_delta = 0; do_delta2 = 0; do_delt",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:68675,Energy Efficiency,ENERGY,ENERGY,68675,"l': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'fno-df-ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['qcisd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'qcisdcorl': 'QCISD CORRELATION ENERGY',; 'qcisd(t)corl': 'QCISD(T) CORRELATION ENERGY'}; VARH['ccsd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['bccd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'bccd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['cisd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'cisdcorl': 'CISD CORRELATION ENERGY'}; VARH['cisdt'] = { 'scftot': 'SCF TOTAL ENERGY',; 'cisdtcorl': 'CISDT CORRELATION ENERGY'}; VARH['cisdtq'] = { 'scftot': 'SCF TOTAL ENERGY',; 'cisdtqcorl': 'CISDTQ CORRELATION ENERGY'}; VARH['fci'] = { 'scftot': 'SCF TOTAL ENERGY',; 'fcicorl': 'FCI CORRELATION ENERGY'}; VARH['mrccsd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mrccsdcorl': 'CCSD CORRELATION ENERGY'}; VARH['mrccsd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mrccsdcorl': 'CCSD CORRELATION ENERGY',; 'mrccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['mrccsdt'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mrccsdtcorl': 'CCSDT CORRELATION ENERGY'}; VARH['mrccsdt(q)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mrccsdtcorl': 'CCSDT CORRELATION ENERGY',; 'mrccsdt(q)corl': 'CCSDT(Q) CORRELATION ENERGY'}. for cilevel in range(2, 99):; VARH['ci%s' % (str(cilevel))] = {; 'scftot': 'SCF TOTAL ENERGY',; 'ci%scorl' % (str(cilevel)): 'CI CORRELATION ENERGY'}. finalenergy = 0.0; do_scf = 1; do_corl = 0; do_delta = 0; do_delta2 = 0; do_delt",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:68713,Energy Efficiency,ENERGY,ENERGY,68713,"l': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'fno-df-ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['qcisd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'qcisdcorl': 'QCISD CORRELATION ENERGY',; 'qcisd(t)corl': 'QCISD(T) CORRELATION ENERGY'}; VARH['ccsd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['bccd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'bccd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['cisd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'cisdcorl': 'CISD CORRELATION ENERGY'}; VARH['cisdt'] = { 'scftot': 'SCF TOTAL ENERGY',; 'cisdtcorl': 'CISDT CORRELATION ENERGY'}; VARH['cisdtq'] = { 'scftot': 'SCF TOTAL ENERGY',; 'cisdtqcorl': 'CISDTQ CORRELATION ENERGY'}; VARH['fci'] = { 'scftot': 'SCF TOTAL ENERGY',; 'fcicorl': 'FCI CORRELATION ENERGY'}; VARH['mrccsd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mrccsdcorl': 'CCSD CORRELATION ENERGY'}; VARH['mrccsd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mrccsdcorl': 'CCSD CORRELATION ENERGY',; 'mrccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['mrccsdt'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mrccsdtcorl': 'CCSDT CORRELATION ENERGY'}; VARH['mrccsdt(q)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mrccsdtcorl': 'CCSDT CORRELATION ENERGY',; 'mrccsdt(q)corl': 'CCSDT(Q) CORRELATION ENERGY'}. for cilevel in range(2, 99):; VARH['ci%s' % (str(cilevel))] = {; 'scftot': 'SCF TOTAL ENERGY',; 'ci%scorl' % (str(cilevel)): 'CI CORRELATION ENERGY'}. finalenergy = 0.0; do_scf = 1; do_corl = 0; do_delta = 0; do_delta2 = 0; do_delt",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:68755,Energy Efficiency,ENERGY,ENERGY,68755,"l': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'fno-df-ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['qcisd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'qcisdcorl': 'QCISD CORRELATION ENERGY',; 'qcisd(t)corl': 'QCISD(T) CORRELATION ENERGY'}; VARH['ccsd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['bccd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'bccd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['cisd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'cisdcorl': 'CISD CORRELATION ENERGY'}; VARH['cisdt'] = { 'scftot': 'SCF TOTAL ENERGY',; 'cisdtcorl': 'CISDT CORRELATION ENERGY'}; VARH['cisdtq'] = { 'scftot': 'SCF TOTAL ENERGY',; 'cisdtqcorl': 'CISDTQ CORRELATION ENERGY'}; VARH['fci'] = { 'scftot': 'SCF TOTAL ENERGY',; 'fcicorl': 'FCI CORRELATION ENERGY'}; VARH['mrccsd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mrccsdcorl': 'CCSD CORRELATION ENERGY'}; VARH['mrccsd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mrccsdcorl': 'CCSD CORRELATION ENERGY',; 'mrccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['mrccsdt'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mrccsdtcorl': 'CCSDT CORRELATION ENERGY'}; VARH['mrccsdt(q)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mrccsdtcorl': 'CCSDT CORRELATION ENERGY',; 'mrccsdt(q)corl': 'CCSDT(Q) CORRELATION ENERGY'}. for cilevel in range(2, 99):; VARH['ci%s' % (str(cilevel))] = {; 'scftot': 'SCF TOTAL ENERGY',; 'ci%scorl' % (str(cilevel)): 'CI CORRELATION ENERGY'}. finalenergy = 0.0; do_scf = 1; do_corl = 0; do_delta = 0; do_delta2 = 0; do_delt",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:68808,Energy Efficiency,ENERGY,ENERGY,68808,"l': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'fno-df-ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['qcisd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'qcisdcorl': 'QCISD CORRELATION ENERGY',; 'qcisd(t)corl': 'QCISD(T) CORRELATION ENERGY'}; VARH['ccsd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['bccd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'bccd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['cisd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'cisdcorl': 'CISD CORRELATION ENERGY'}; VARH['cisdt'] = { 'scftot': 'SCF TOTAL ENERGY',; 'cisdtcorl': 'CISDT CORRELATION ENERGY'}; VARH['cisdtq'] = { 'scftot': 'SCF TOTAL ENERGY',; 'cisdtqcorl': 'CISDTQ CORRELATION ENERGY'}; VARH['fci'] = { 'scftot': 'SCF TOTAL ENERGY',; 'fcicorl': 'FCI CORRELATION ENERGY'}; VARH['mrccsd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mrccsdcorl': 'CCSD CORRELATION ENERGY'}; VARH['mrccsd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mrccsdcorl': 'CCSD CORRELATION ENERGY',; 'mrccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['mrccsdt'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mrccsdtcorl': 'CCSDT CORRELATION ENERGY'}; VARH['mrccsdt(q)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mrccsdtcorl': 'CCSDT CORRELATION ENERGY',; 'mrccsdt(q)corl': 'CCSDT(Q) CORRELATION ENERGY'}. for cilevel in range(2, 99):; VARH['ci%s' % (str(cilevel))] = {; 'scftot': 'SCF TOTAL ENERGY',; 'ci%scorl' % (str(cilevel)): 'CI CORRELATION ENERGY'}. finalenergy = 0.0; do_scf = 1; do_corl = 0; do_delta = 0; do_delta2 = 0; do_delt",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:68846,Energy Efficiency,ENERGY,ENERGY,68846,"l': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'fno-df-ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['qcisd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'qcisdcorl': 'QCISD CORRELATION ENERGY',; 'qcisd(t)corl': 'QCISD(T) CORRELATION ENERGY'}; VARH['ccsd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['bccd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'bccd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['cisd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'cisdcorl': 'CISD CORRELATION ENERGY'}; VARH['cisdt'] = { 'scftot': 'SCF TOTAL ENERGY',; 'cisdtcorl': 'CISDT CORRELATION ENERGY'}; VARH['cisdtq'] = { 'scftot': 'SCF TOTAL ENERGY',; 'cisdtqcorl': 'CISDTQ CORRELATION ENERGY'}; VARH['fci'] = { 'scftot': 'SCF TOTAL ENERGY',; 'fcicorl': 'FCI CORRELATION ENERGY'}; VARH['mrccsd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mrccsdcorl': 'CCSD CORRELATION ENERGY'}; VARH['mrccsd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mrccsdcorl': 'CCSD CORRELATION ENERGY',; 'mrccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['mrccsdt'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mrccsdtcorl': 'CCSDT CORRELATION ENERGY'}; VARH['mrccsdt(q)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mrccsdtcorl': 'CCSDT CORRELATION ENERGY',; 'mrccsdt(q)corl': 'CCSDT(Q) CORRELATION ENERGY'}. for cilevel in range(2, 99):; VARH['ci%s' % (str(cilevel))] = {; 'scftot': 'SCF TOTAL ENERGY',; 'ci%scorl' % (str(cilevel)): 'CI CORRELATION ENERGY'}. finalenergy = 0.0; do_scf = 1; do_corl = 0; do_delta = 0; do_delta2 = 0; do_delt",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:68888,Energy Efficiency,ENERGY,ENERGY,68888,"l': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'fno-df-ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['qcisd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'qcisdcorl': 'QCISD CORRELATION ENERGY',; 'qcisd(t)corl': 'QCISD(T) CORRELATION ENERGY'}; VARH['ccsd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['bccd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'bccd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['cisd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'cisdcorl': 'CISD CORRELATION ENERGY'}; VARH['cisdt'] = { 'scftot': 'SCF TOTAL ENERGY',; 'cisdtcorl': 'CISDT CORRELATION ENERGY'}; VARH['cisdtq'] = { 'scftot': 'SCF TOTAL ENERGY',; 'cisdtqcorl': 'CISDTQ CORRELATION ENERGY'}; VARH['fci'] = { 'scftot': 'SCF TOTAL ENERGY',; 'fcicorl': 'FCI CORRELATION ENERGY'}; VARH['mrccsd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mrccsdcorl': 'CCSD CORRELATION ENERGY'}; VARH['mrccsd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mrccsdcorl': 'CCSD CORRELATION ENERGY',; 'mrccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['mrccsdt'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mrccsdtcorl': 'CCSDT CORRELATION ENERGY'}; VARH['mrccsdt(q)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mrccsdtcorl': 'CCSDT CORRELATION ENERGY',; 'mrccsdt(q)corl': 'CCSDT(Q) CORRELATION ENERGY'}. for cilevel in range(2, 99):; VARH['ci%s' % (str(cilevel))] = {; 'scftot': 'SCF TOTAL ENERGY',; 'ci%scorl' % (str(cilevel)): 'CI CORRELATION ENERGY'}. finalenergy = 0.0; do_scf = 1; do_corl = 0; do_delta = 0; do_delta2 = 0; do_delt",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:68936,Energy Efficiency,ENERGY,ENERGY,68936,"l': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'fno-df-ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['qcisd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'qcisdcorl': 'QCISD CORRELATION ENERGY',; 'qcisd(t)corl': 'QCISD(T) CORRELATION ENERGY'}; VARH['ccsd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['bccd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'bccd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['cisd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'cisdcorl': 'CISD CORRELATION ENERGY'}; VARH['cisdt'] = { 'scftot': 'SCF TOTAL ENERGY',; 'cisdtcorl': 'CISDT CORRELATION ENERGY'}; VARH['cisdtq'] = { 'scftot': 'SCF TOTAL ENERGY',; 'cisdtqcorl': 'CISDTQ CORRELATION ENERGY'}; VARH['fci'] = { 'scftot': 'SCF TOTAL ENERGY',; 'fcicorl': 'FCI CORRELATION ENERGY'}; VARH['mrccsd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mrccsdcorl': 'CCSD CORRELATION ENERGY'}; VARH['mrccsd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mrccsdcorl': 'CCSD CORRELATION ENERGY',; 'mrccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['mrccsdt'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mrccsdtcorl': 'CCSDT CORRELATION ENERGY'}; VARH['mrccsdt(q)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mrccsdtcorl': 'CCSDT CORRELATION ENERGY',; 'mrccsdt(q)corl': 'CCSDT(Q) CORRELATION ENERGY'}. for cilevel in range(2, 99):; VARH['ci%s' % (str(cilevel))] = {; 'scftot': 'SCF TOTAL ENERGY',; 'ci%scorl' % (str(cilevel)): 'CI CORRELATION ENERGY'}. finalenergy = 0.0; do_scf = 1; do_corl = 0; do_delta = 0; do_delta2 = 0; do_delt",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:68987,Energy Efficiency,ENERGY,ENERGY,68987,"l': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'fno-df-ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['qcisd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'qcisdcorl': 'QCISD CORRELATION ENERGY',; 'qcisd(t)corl': 'QCISD(T) CORRELATION ENERGY'}; VARH['ccsd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['bccd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'bccd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['cisd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'cisdcorl': 'CISD CORRELATION ENERGY'}; VARH['cisdt'] = { 'scftot': 'SCF TOTAL ENERGY',; 'cisdtcorl': 'CISDT CORRELATION ENERGY'}; VARH['cisdtq'] = { 'scftot': 'SCF TOTAL ENERGY',; 'cisdtqcorl': 'CISDTQ CORRELATION ENERGY'}; VARH['fci'] = { 'scftot': 'SCF TOTAL ENERGY',; 'fcicorl': 'FCI CORRELATION ENERGY'}; VARH['mrccsd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mrccsdcorl': 'CCSD CORRELATION ENERGY'}; VARH['mrccsd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mrccsdcorl': 'CCSD CORRELATION ENERGY',; 'mrccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['mrccsdt'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mrccsdtcorl': 'CCSDT CORRELATION ENERGY'}; VARH['mrccsdt(q)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mrccsdtcorl': 'CCSDT CORRELATION ENERGY',; 'mrccsdt(q)corl': 'CCSDT(Q) CORRELATION ENERGY'}. for cilevel in range(2, 99):; VARH['ci%s' % (str(cilevel))] = {; 'scftot': 'SCF TOTAL ENERGY',; 'ci%scorl' % (str(cilevel)): 'CI CORRELATION ENERGY'}. finalenergy = 0.0; do_scf = 1; do_corl = 0; do_delta = 0; do_delta2 = 0; do_delt",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:69025,Energy Efficiency,ENERGY,ENERGY,69025,"l': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'fno-df-ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['qcisd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'qcisdcorl': 'QCISD CORRELATION ENERGY',; 'qcisd(t)corl': 'QCISD(T) CORRELATION ENERGY'}; VARH['ccsd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['bccd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'bccd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['cisd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'cisdcorl': 'CISD CORRELATION ENERGY'}; VARH['cisdt'] = { 'scftot': 'SCF TOTAL ENERGY',; 'cisdtcorl': 'CISDT CORRELATION ENERGY'}; VARH['cisdtq'] = { 'scftot': 'SCF TOTAL ENERGY',; 'cisdtqcorl': 'CISDTQ CORRELATION ENERGY'}; VARH['fci'] = { 'scftot': 'SCF TOTAL ENERGY',; 'fcicorl': 'FCI CORRELATION ENERGY'}; VARH['mrccsd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mrccsdcorl': 'CCSD CORRELATION ENERGY'}; VARH['mrccsd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mrccsdcorl': 'CCSD CORRELATION ENERGY',; 'mrccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['mrccsdt'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mrccsdtcorl': 'CCSDT CORRELATION ENERGY'}; VARH['mrccsdt(q)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mrccsdtcorl': 'CCSDT CORRELATION ENERGY',; 'mrccsdt(q)corl': 'CCSDT(Q) CORRELATION ENERGY'}. for cilevel in range(2, 99):; VARH['ci%s' % (str(cilevel))] = {; 'scftot': 'SCF TOTAL ENERGY',; 'ci%scorl' % (str(cilevel)): 'CI CORRELATION ENERGY'}. finalenergy = 0.0; do_scf = 1; do_corl = 0; do_delta = 0; do_delta2 = 0; do_delt",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:69069,Energy Efficiency,ENERGY,ENERGY,69069,"l': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'fno-df-ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['qcisd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'qcisdcorl': 'QCISD CORRELATION ENERGY',; 'qcisd(t)corl': 'QCISD(T) CORRELATION ENERGY'}; VARH['ccsd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['bccd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'bccd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['cisd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'cisdcorl': 'CISD CORRELATION ENERGY'}; VARH['cisdt'] = { 'scftot': 'SCF TOTAL ENERGY',; 'cisdtcorl': 'CISDT CORRELATION ENERGY'}; VARH['cisdtq'] = { 'scftot': 'SCF TOTAL ENERGY',; 'cisdtqcorl': 'CISDTQ CORRELATION ENERGY'}; VARH['fci'] = { 'scftot': 'SCF TOTAL ENERGY',; 'fcicorl': 'FCI CORRELATION ENERGY'}; VARH['mrccsd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mrccsdcorl': 'CCSD CORRELATION ENERGY'}; VARH['mrccsd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mrccsdcorl': 'CCSD CORRELATION ENERGY',; 'mrccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['mrccsdt'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mrccsdtcorl': 'CCSDT CORRELATION ENERGY'}; VARH['mrccsdt(q)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mrccsdtcorl': 'CCSDT CORRELATION ENERGY',; 'mrccsdt(q)corl': 'CCSDT(Q) CORRELATION ENERGY'}. for cilevel in range(2, 99):; VARH['ci%s' % (str(cilevel))] = {; 'scftot': 'SCF TOTAL ENERGY',; 'ci%scorl' % (str(cilevel)): 'CI CORRELATION ENERGY'}. finalenergy = 0.0; do_scf = 1; do_corl = 0; do_delta = 0; do_delta2 = 0; do_delt",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:69123,Energy Efficiency,ENERGY,ENERGY,69123,"l': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'fno-df-ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['qcisd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'qcisdcorl': 'QCISD CORRELATION ENERGY',; 'qcisd(t)corl': 'QCISD(T) CORRELATION ENERGY'}; VARH['ccsd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['bccd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'bccd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['cisd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'cisdcorl': 'CISD CORRELATION ENERGY'}; VARH['cisdt'] = { 'scftot': 'SCF TOTAL ENERGY',; 'cisdtcorl': 'CISDT CORRELATION ENERGY'}; VARH['cisdtq'] = { 'scftot': 'SCF TOTAL ENERGY',; 'cisdtqcorl': 'CISDTQ CORRELATION ENERGY'}; VARH['fci'] = { 'scftot': 'SCF TOTAL ENERGY',; 'fcicorl': 'FCI CORRELATION ENERGY'}; VARH['mrccsd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mrccsdcorl': 'CCSD CORRELATION ENERGY'}; VARH['mrccsd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mrccsdcorl': 'CCSD CORRELATION ENERGY',; 'mrccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['mrccsdt'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mrccsdtcorl': 'CCSDT CORRELATION ENERGY'}; VARH['mrccsdt(q)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mrccsdtcorl': 'CCSDT CORRELATION ENERGY',; 'mrccsdt(q)corl': 'CCSDT(Q) CORRELATION ENERGY'}. for cilevel in range(2, 99):; VARH['ci%s' % (str(cilevel))] = {; 'scftot': 'SCF TOTAL ENERGY',; 'ci%scorl' % (str(cilevel)): 'CI CORRELATION ENERGY'}. finalenergy = 0.0; do_scf = 1; do_corl = 0; do_delta = 0; do_delta2 = 0; do_delt",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:69161,Energy Efficiency,ENERGY,ENERGY,69161,"l': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'fno-df-ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['qcisd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'qcisdcorl': 'QCISD CORRELATION ENERGY',; 'qcisd(t)corl': 'QCISD(T) CORRELATION ENERGY'}; VARH['ccsd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['bccd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'bccd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['cisd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'cisdcorl': 'CISD CORRELATION ENERGY'}; VARH['cisdt'] = { 'scftot': 'SCF TOTAL ENERGY',; 'cisdtcorl': 'CISDT CORRELATION ENERGY'}; VARH['cisdtq'] = { 'scftot': 'SCF TOTAL ENERGY',; 'cisdtqcorl': 'CISDTQ CORRELATION ENERGY'}; VARH['fci'] = { 'scftot': 'SCF TOTAL ENERGY',; 'fcicorl': 'FCI CORRELATION ENERGY'}; VARH['mrccsd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mrccsdcorl': 'CCSD CORRELATION ENERGY'}; VARH['mrccsd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mrccsdcorl': 'CCSD CORRELATION ENERGY',; 'mrccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['mrccsdt'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mrccsdtcorl': 'CCSDT CORRELATION ENERGY'}; VARH['mrccsdt(q)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mrccsdtcorl': 'CCSDT CORRELATION ENERGY',; 'mrccsdt(q)corl': 'CCSDT(Q) CORRELATION ENERGY'}. for cilevel in range(2, 99):; VARH['ci%s' % (str(cilevel))] = {; 'scftot': 'SCF TOTAL ENERGY',; 'ci%scorl' % (str(cilevel)): 'CI CORRELATION ENERGY'}. finalenergy = 0.0; do_scf = 1; do_corl = 0; do_delta = 0; do_delta2 = 0; do_delt",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:69205,Energy Efficiency,ENERGY,ENERGY,69205,"l': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'fno-df-ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['qcisd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'qcisdcorl': 'QCISD CORRELATION ENERGY',; 'qcisd(t)corl': 'QCISD(T) CORRELATION ENERGY'}; VARH['ccsd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['bccd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'bccd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['cisd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'cisdcorl': 'CISD CORRELATION ENERGY'}; VARH['cisdt'] = { 'scftot': 'SCF TOTAL ENERGY',; 'cisdtcorl': 'CISDT CORRELATION ENERGY'}; VARH['cisdtq'] = { 'scftot': 'SCF TOTAL ENERGY',; 'cisdtqcorl': 'CISDTQ CORRELATION ENERGY'}; VARH['fci'] = { 'scftot': 'SCF TOTAL ENERGY',; 'fcicorl': 'FCI CORRELATION ENERGY'}; VARH['mrccsd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mrccsdcorl': 'CCSD CORRELATION ENERGY'}; VARH['mrccsd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mrccsdcorl': 'CCSD CORRELATION ENERGY',; 'mrccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['mrccsdt'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mrccsdtcorl': 'CCSDT CORRELATION ENERGY'}; VARH['mrccsdt(q)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mrccsdtcorl': 'CCSDT CORRELATION ENERGY',; 'mrccsdt(q)corl': 'CCSDT(Q) CORRELATION ENERGY'}. for cilevel in range(2, 99):; VARH['ci%s' % (str(cilevel))] = {; 'scftot': 'SCF TOTAL ENERGY',; 'ci%scorl' % (str(cilevel)): 'CI CORRELATION ENERGY'}. finalenergy = 0.0; do_scf = 1; do_corl = 0; do_delta = 0; do_delta2 = 0; do_delt",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:69255,Energy Efficiency,ENERGY,ENERGY,69255,"l': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'fno-df-ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['qcisd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'qcisdcorl': 'QCISD CORRELATION ENERGY',; 'qcisd(t)corl': 'QCISD(T) CORRELATION ENERGY'}; VARH['ccsd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['bccd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'bccd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['cisd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'cisdcorl': 'CISD CORRELATION ENERGY'}; VARH['cisdt'] = { 'scftot': 'SCF TOTAL ENERGY',; 'cisdtcorl': 'CISDT CORRELATION ENERGY'}; VARH['cisdtq'] = { 'scftot': 'SCF TOTAL ENERGY',; 'cisdtqcorl': 'CISDTQ CORRELATION ENERGY'}; VARH['fci'] = { 'scftot': 'SCF TOTAL ENERGY',; 'fcicorl': 'FCI CORRELATION ENERGY'}; VARH['mrccsd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mrccsdcorl': 'CCSD CORRELATION ENERGY'}; VARH['mrccsd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mrccsdcorl': 'CCSD CORRELATION ENERGY',; 'mrccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['mrccsdt'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mrccsdtcorl': 'CCSDT CORRELATION ENERGY'}; VARH['mrccsdt(q)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mrccsdtcorl': 'CCSDT CORRELATION ENERGY',; 'mrccsdt(q)corl': 'CCSDT(Q) CORRELATION ENERGY'}. for cilevel in range(2, 99):; VARH['ci%s' % (str(cilevel))] = {; 'scftot': 'SCF TOTAL ENERGY',; 'ci%scorl' % (str(cilevel)): 'CI CORRELATION ENERGY'}. finalenergy = 0.0; do_scf = 1; do_corl = 0; do_delta = 0; do_delta2 = 0; do_delt",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:69351,Energy Efficiency,ENERGY,ENERGY,69351,"ISD CORRELATION ENERGY'}; VARH['cisdt'] = { 'scftot': 'SCF TOTAL ENERGY',; 'cisdtcorl': 'CISDT CORRELATION ENERGY'}; VARH['cisdtq'] = { 'scftot': 'SCF TOTAL ENERGY',; 'cisdtqcorl': 'CISDTQ CORRELATION ENERGY'}; VARH['fci'] = { 'scftot': 'SCF TOTAL ENERGY',; 'fcicorl': 'FCI CORRELATION ENERGY'}; VARH['mrccsd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mrccsdcorl': 'CCSD CORRELATION ENERGY'}; VARH['mrccsd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mrccsdcorl': 'CCSD CORRELATION ENERGY',; 'mrccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['mrccsdt'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mrccsdtcorl': 'CCSDT CORRELATION ENERGY'}; VARH['mrccsdt(q)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mrccsdtcorl': 'CCSDT CORRELATION ENERGY',; 'mrccsdt(q)corl': 'CCSDT(Q) CORRELATION ENERGY'}. for cilevel in range(2, 99):; VARH['ci%s' % (str(cilevel))] = {; 'scftot': 'SCF TOTAL ENERGY',; 'ci%scorl' % (str(cilevel)): 'CI CORRELATION ENERGY'}. finalenergy = 0.0; do_scf = 1; do_corl = 0; do_delta = 0; do_delta2 = 0; do_delta3 = 0; do_delta4 = 0; do_delta5 = 0. # Must collect (here) and set (below) basis sets after every new molecule activation; b_user_basis = psi4.has_global_option_changed('BASIS'); user_basis = psi4.get_global_option('BASIS'); #user_df_basis_scf = psi4.get_option('DF_BASIS_SCF'); #user_df_basis_mp2 = psi4.get_option('DF_BASIS_MP2'); #user_df_basis_cc = psi4.get_option('DF_BASIS_CC'); #user_df_basis_sapt = psi4.get_option('DF_BASIS_SAPT'); #user_df_basis_elst = psi4.get_option('DF_BASIS_ELST'); b_user_wfn = psi4.has_global_option_changed('WFN'); user_wfn = psi4.get_global_option('WFN'). user_writer_file_label = psi4.get_global_option('WRITER_FILE_LABEL'). # Make sure the molecule the user provided is the active one; if 'molecule' in kwargs:; activate(kwargs['molecule']); del kwargs['molecule']; molecule = psi4.get_active_molecule(); m",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:69406,Energy Efficiency,ENERGY,ENERGY,69406,"ISD CORRELATION ENERGY'}; VARH['cisdt'] = { 'scftot': 'SCF TOTAL ENERGY',; 'cisdtcorl': 'CISDT CORRELATION ENERGY'}; VARH['cisdtq'] = { 'scftot': 'SCF TOTAL ENERGY',; 'cisdtqcorl': 'CISDTQ CORRELATION ENERGY'}; VARH['fci'] = { 'scftot': 'SCF TOTAL ENERGY',; 'fcicorl': 'FCI CORRELATION ENERGY'}; VARH['mrccsd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mrccsdcorl': 'CCSD CORRELATION ENERGY'}; VARH['mrccsd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mrccsdcorl': 'CCSD CORRELATION ENERGY',; 'mrccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['mrccsdt'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mrccsdtcorl': 'CCSDT CORRELATION ENERGY'}; VARH['mrccsdt(q)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mrccsdtcorl': 'CCSDT CORRELATION ENERGY',; 'mrccsdt(q)corl': 'CCSDT(Q) CORRELATION ENERGY'}. for cilevel in range(2, 99):; VARH['ci%s' % (str(cilevel))] = {; 'scftot': 'SCF TOTAL ENERGY',; 'ci%scorl' % (str(cilevel)): 'CI CORRELATION ENERGY'}. finalenergy = 0.0; do_scf = 1; do_corl = 0; do_delta = 0; do_delta2 = 0; do_delta3 = 0; do_delta4 = 0; do_delta5 = 0. # Must collect (here) and set (below) basis sets after every new molecule activation; b_user_basis = psi4.has_global_option_changed('BASIS'); user_basis = psi4.get_global_option('BASIS'); #user_df_basis_scf = psi4.get_option('DF_BASIS_SCF'); #user_df_basis_mp2 = psi4.get_option('DF_BASIS_MP2'); #user_df_basis_cc = psi4.get_option('DF_BASIS_CC'); #user_df_basis_sapt = psi4.get_option('DF_BASIS_SAPT'); #user_df_basis_elst = psi4.get_option('DF_BASIS_ELST'); b_user_wfn = psi4.has_global_option_changed('WFN'); user_wfn = psi4.get_global_option('WFN'). user_writer_file_label = psi4.get_global_option('WRITER_FILE_LABEL'). # Make sure the molecule the user provided is the active one; if 'molecule' in kwargs:; activate(kwargs['molecule']); del kwargs['molecule']; molecule = psi4.get_active_molecule(); m",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:70468,Energy Efficiency,energy,energy,70468,"do_delta5 = 0. # Must collect (here) and set (below) basis sets after every new molecule activation; b_user_basis = psi4.has_global_option_changed('BASIS'); user_basis = psi4.get_global_option('BASIS'); #user_df_basis_scf = psi4.get_option('DF_BASIS_SCF'); #user_df_basis_mp2 = psi4.get_option('DF_BASIS_MP2'); #user_df_basis_cc = psi4.get_option('DF_BASIS_CC'); #user_df_basis_sapt = psi4.get_option('DF_BASIS_SAPT'); #user_df_basis_elst = psi4.get_option('DF_BASIS_ELST'); b_user_wfn = psi4.has_global_option_changed('WFN'); user_wfn = psi4.get_global_option('WFN'). user_writer_file_label = psi4.get_global_option('WRITER_FILE_LABEL'). # Make sure the molecule the user provided is the active one; if 'molecule' in kwargs:; activate(kwargs['molecule']); del kwargs['molecule']; molecule = psi4.get_active_molecule(); molecule.update_geometry(); psi4.set_global_option(""BASIS"", psi4.get_global_option(""BASIS"")). # Establish method for correlation energy; if 'name' in kwargs:; if (lowername == 'scf') or (lowername == 'df-scf'):; pass; else:; do_corl = 1; cbs_corl_wfn = kwargs['name'].lower(); if 'corl_wfn' in kwargs:; do_corl = 1; cbs_corl_wfn = kwargs['corl_wfn'].lower(); if do_corl:; if not (cbs_corl_wfn in VARH.keys()):; raise ValidationError('Requested CORL method \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_corl_wfn)). # Establish method for delta correction energy; if 'delta_wfn' in kwargs:; do_delta = 1; cbs_delta_wfn = kwargs['delta_wfn'].lower(); if not (cbs_delta_wfn in VARH.keys()):; raise ValidationError('Requested DELTA method \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta_wfn)). if 'delta_wfn_lesser' in kwargs:; cbs_delta_wfn_lesser = kwargs['delta_wfn_lesser'].lower(); else:; cbs_delta_wfn_lesser = 'mp2'; if not (cbs_delta_wfn_lesser in VARH.keys()):; raise ValidationError('Requested DELTA method lesser \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta_wfn_lesser)). # Est",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:70922,Energy Efficiency,energy,energy,70922,"df_basis_elst = psi4.get_option('DF_BASIS_ELST'); b_user_wfn = psi4.has_global_option_changed('WFN'); user_wfn = psi4.get_global_option('WFN'). user_writer_file_label = psi4.get_global_option('WRITER_FILE_LABEL'). # Make sure the molecule the user provided is the active one; if 'molecule' in kwargs:; activate(kwargs['molecule']); del kwargs['molecule']; molecule = psi4.get_active_molecule(); molecule.update_geometry(); psi4.set_global_option(""BASIS"", psi4.get_global_option(""BASIS"")). # Establish method for correlation energy; if 'name' in kwargs:; if (lowername == 'scf') or (lowername == 'df-scf'):; pass; else:; do_corl = 1; cbs_corl_wfn = kwargs['name'].lower(); if 'corl_wfn' in kwargs:; do_corl = 1; cbs_corl_wfn = kwargs['corl_wfn'].lower(); if do_corl:; if not (cbs_corl_wfn in VARH.keys()):; raise ValidationError('Requested CORL method \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_corl_wfn)). # Establish method for delta correction energy; if 'delta_wfn' in kwargs:; do_delta = 1; cbs_delta_wfn = kwargs['delta_wfn'].lower(); if not (cbs_delta_wfn in VARH.keys()):; raise ValidationError('Requested DELTA method \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta_wfn)). if 'delta_wfn_lesser' in kwargs:; cbs_delta_wfn_lesser = kwargs['delta_wfn_lesser'].lower(); else:; cbs_delta_wfn_lesser = 'mp2'; if not (cbs_delta_wfn_lesser in VARH.keys()):; raise ValidationError('Requested DELTA method lesser \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta_wfn_lesser)). # Establish method for second delta correction energy; if 'delta2_wfn' in kwargs:; do_delta2 = 1; cbs_delta2_wfn = kwargs['delta2_wfn'].lower(); if not (cbs_delta2_wfn in VARH.keys()):; raise ValidationError('Requested DELTA2 method \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta2_wfn)). if 'delta2_wfn_lesser' in kwargs:; cbs_delta2_wfn_lesser = kwargs['delta2_wfn_lesser'].lower(); else:; cbs_",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:71562,Energy Efficiency,energy,energy,71562,orl_wfn = kwargs['name'].lower(); if 'corl_wfn' in kwargs:; do_corl = 1; cbs_corl_wfn = kwargs['corl_wfn'].lower(); if do_corl:; if not (cbs_corl_wfn in VARH.keys()):; raise ValidationError('Requested CORL method \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_corl_wfn)). # Establish method for delta correction energy; if 'delta_wfn' in kwargs:; do_delta = 1; cbs_delta_wfn = kwargs['delta_wfn'].lower(); if not (cbs_delta_wfn in VARH.keys()):; raise ValidationError('Requested DELTA method \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta_wfn)). if 'delta_wfn_lesser' in kwargs:; cbs_delta_wfn_lesser = kwargs['delta_wfn_lesser'].lower(); else:; cbs_delta_wfn_lesser = 'mp2'; if not (cbs_delta_wfn_lesser in VARH.keys()):; raise ValidationError('Requested DELTA method lesser \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta_wfn_lesser)). # Establish method for second delta correction energy; if 'delta2_wfn' in kwargs:; do_delta2 = 1; cbs_delta2_wfn = kwargs['delta2_wfn'].lower(); if not (cbs_delta2_wfn in VARH.keys()):; raise ValidationError('Requested DELTA2 method \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta2_wfn)). if 'delta2_wfn_lesser' in kwargs:; cbs_delta2_wfn_lesser = kwargs['delta2_wfn_lesser'].lower(); else:; cbs_delta2_wfn_lesser = 'mp2'; if not (cbs_delta2_wfn_lesser in VARH.keys()):; raise ValidationError('Requested DELTA2 method lesser \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta2_wfn_lesser)). # Establish method for third delta correction energy; if 'delta3_wfn' in kwargs:; do_delta3 = 1; cbs_delta3_wfn = kwargs['delta3_wfn'].lower(); if not (cbs_delta3_wfn in VARH.keys()):; raise ValidationError('Requested DELTA3 method \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta3_wfn)). if 'delta3_wfn_lesser' in kwargs:; cbs_delta3_wfn_lesser = kwargs['delta3_wfn_lesser'].lower(,MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:72215,Energy Efficiency,energy,energy,72215,n_lesser = kwargs['delta_wfn_lesser'].lower(); else:; cbs_delta_wfn_lesser = 'mp2'; if not (cbs_delta_wfn_lesser in VARH.keys()):; raise ValidationError('Requested DELTA method lesser \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta_wfn_lesser)). # Establish method for second delta correction energy; if 'delta2_wfn' in kwargs:; do_delta2 = 1; cbs_delta2_wfn = kwargs['delta2_wfn'].lower(); if not (cbs_delta2_wfn in VARH.keys()):; raise ValidationError('Requested DELTA2 method \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta2_wfn)). if 'delta2_wfn_lesser' in kwargs:; cbs_delta2_wfn_lesser = kwargs['delta2_wfn_lesser'].lower(); else:; cbs_delta2_wfn_lesser = 'mp2'; if not (cbs_delta2_wfn_lesser in VARH.keys()):; raise ValidationError('Requested DELTA2 method lesser \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta2_wfn_lesser)). # Establish method for third delta correction energy; if 'delta3_wfn' in kwargs:; do_delta3 = 1; cbs_delta3_wfn = kwargs['delta3_wfn'].lower(); if not (cbs_delta3_wfn in VARH.keys()):; raise ValidationError('Requested DELTA3 method \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta3_wfn)). if 'delta3_wfn_lesser' in kwargs:; cbs_delta3_wfn_lesser = kwargs['delta3_wfn_lesser'].lower(); else:; cbs_delta3_wfn_lesser = 'mp2'; if not (cbs_delta3_wfn_lesser in VARH.keys()):; raise ValidationError('Requested DELTA3 method lesser \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta3_wfn_lesser)). # Establish method for fourth delta correction energy; if 'delta4_wfn' in kwargs:; do_delta4 = 1; cbs_delta4_wfn = kwargs['delta4_wfn'].lower(); if not (cbs_delta4_wfn in VARH.keys()):; raise ValidationError('Requested DELTA4 method \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta4_wfn)). if 'delta4_wfn_lesser' in kwargs:; cbs_delta4_wfn_lesser = kwargs['delta4_wfn_lesser'].lower,MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:72869,Energy Efficiency,energy,energy,72869,sser = kwargs['delta2_wfn_lesser'].lower(); else:; cbs_delta2_wfn_lesser = 'mp2'; if not (cbs_delta2_wfn_lesser in VARH.keys()):; raise ValidationError('Requested DELTA2 method lesser \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta2_wfn_lesser)). # Establish method for third delta correction energy; if 'delta3_wfn' in kwargs:; do_delta3 = 1; cbs_delta3_wfn = kwargs['delta3_wfn'].lower(); if not (cbs_delta3_wfn in VARH.keys()):; raise ValidationError('Requested DELTA3 method \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta3_wfn)). if 'delta3_wfn_lesser' in kwargs:; cbs_delta3_wfn_lesser = kwargs['delta3_wfn_lesser'].lower(); else:; cbs_delta3_wfn_lesser = 'mp2'; if not (cbs_delta3_wfn_lesser in VARH.keys()):; raise ValidationError('Requested DELTA3 method lesser \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta3_wfn_lesser)). # Establish method for fourth delta correction energy; if 'delta4_wfn' in kwargs:; do_delta4 = 1; cbs_delta4_wfn = kwargs['delta4_wfn'].lower(); if not (cbs_delta4_wfn in VARH.keys()):; raise ValidationError('Requested DELTA4 method \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta4_wfn)). if 'delta4_wfn_lesser' in kwargs:; cbs_delta4_wfn_lesser = kwargs['delta4_wfn_lesser'].lower(); else:; cbs_delta4_wfn_lesser = 'mp2'; if not (cbs_delta4_wfn_lesser in VARH.keys()):; raise ValidationError('Requested DELTA4 method lesser \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta4_wfn_lesser)). # Establish method for fifth delta correction energy; if 'delta5_wfn' in kwargs:; do_delta5 = 1; cbs_delta5_wfn = kwargs['delta5_wfn'].lower(); if not (cbs_delta5_wfn in VARH.keys()):; raise ValidationError('Requested DELTA5 method \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta5_wfn)). if 'delta5_wfn_lesser' in kwargs:; cbs_delta5_wfn_lesser = kwargs['delta5_wfn_lesser'].lower(,MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:73522,Energy Efficiency,energy,energy,73522,ser = kwargs['delta3_wfn_lesser'].lower(); else:; cbs_delta3_wfn_lesser = 'mp2'; if not (cbs_delta3_wfn_lesser in VARH.keys()):; raise ValidationError('Requested DELTA3 method lesser \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta3_wfn_lesser)). # Establish method for fourth delta correction energy; if 'delta4_wfn' in kwargs:; do_delta4 = 1; cbs_delta4_wfn = kwargs['delta4_wfn'].lower(); if not (cbs_delta4_wfn in VARH.keys()):; raise ValidationError('Requested DELTA4 method \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta4_wfn)). if 'delta4_wfn_lesser' in kwargs:; cbs_delta4_wfn_lesser = kwargs['delta4_wfn_lesser'].lower(); else:; cbs_delta4_wfn_lesser = 'mp2'; if not (cbs_delta4_wfn_lesser in VARH.keys()):; raise ValidationError('Requested DELTA4 method lesser \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta4_wfn_lesser)). # Establish method for fifth delta correction energy; if 'delta5_wfn' in kwargs:; do_delta5 = 1; cbs_delta5_wfn = kwargs['delta5_wfn'].lower(); if not (cbs_delta5_wfn in VARH.keys()):; raise ValidationError('Requested DELTA5 method \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta5_wfn)). if 'delta5_wfn_lesser' in kwargs:; cbs_delta5_wfn_lesser = kwargs['delta5_wfn_lesser'].lower(); else:; cbs_delta5_wfn_lesser = 'mp2'; if not (cbs_delta5_wfn_lesser in VARH.keys()):; raise ValidationError('Requested DELTA5 method lesser \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta5_wfn_lesser)). # Check that user isn't skipping steps in scf + corl + delta + delta2 sequence; if do_scf and not do_corl and not do_delta and not do_delta2 and not do_delta3 and not do_delta4 and not do_delta5:; pass; elif do_scf and do_corl and not do_delta and not do_delta2 and not do_delta3 and not do_delta4 and not do_delta5:; pass; elif do_scf and do_corl and do_delta and not do_delta2 and not do_delta3 and not do_delta4,MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:75299,Energy Efficiency,energy,energy,75299,"pass; elif do_scf and do_corl and not do_delta and not do_delta2 and not do_delta3 and not do_delta4 and not do_delta5:; pass; elif do_scf and do_corl and do_delta and not do_delta2 and not do_delta3 and not do_delta4 and not do_delta5:; pass; elif do_scf and do_corl and do_delta and do_delta2 and not do_delta3 and not do_delta4 and not do_delta5:; pass; elif do_scf and do_corl and do_delta and do_delta2 and do_delta3 and not do_delta4 and not do_delta5:; pass; elif do_scf and do_corl and do_delta and do_delta2 and do_delta3 and do_delta4 and not do_delta5:; pass; elif do_scf and do_corl and do_delta and do_delta2 and do_delta3 and do_delta4 and do_delta5:; pass; else:; raise ValidationError('Requested scf (%s) + corl (%s) + delta (%s) + delta2 (%s) + delta3 (%s) + delta4 (%s) + delta5 (%s) not valid. These steps are cummulative.' %; (do_scf, do_corl, do_delta, do_delta2, do_delta3, do_delta4, do_delta5)). # Establish list of valid basis sets for correlation energy; if do_corl:; if 'corl_basis' in kwargs:; BSTC, ZETC = validate_bracketed_basis(kwargs['corl_basis'].lower()); else:; raise ValidationError('CORL basis sets through keyword \'%s\' are required.' % ('corl_basis')). # Establish list of valid basis sets for scf energy; if 'scf_basis' in kwargs:; BSTR, ZETR = validate_bracketed_basis(kwargs['scf_basis'].lower()); else:; if do_corl:; BSTR = BSTC[:]; ZETR = ZETC[:]; else:; raise ValidationError('SCF basis sets through keyword \'%s\' are required. Or perhaps you forgot the \'%s\'.' % ('scf_basis', 'corl_wfn')). # Establish list of valid basis sets for delta correction energy; if do_delta:; if 'delta_basis' in kwargs:; BSTD, ZETD = validate_bracketed_basis(kwargs['delta_basis'].lower()); else:; raise ValidationError('DELTA basis sets through keyword \'%s\' are required.' % ('delta_basis')). # Establish list of valid basis sets for second delta correction energy; if do_delta2:; if 'delta2_basis' in kwargs:; BSTD2, ZETD2 = validate_bracketed_basis(kwargs['delta2_ba",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:75565,Energy Efficiency,energy,energy,75565,"_corl and do_delta and do_delta2 and not do_delta3 and not do_delta4 and not do_delta5:; pass; elif do_scf and do_corl and do_delta and do_delta2 and do_delta3 and not do_delta4 and not do_delta5:; pass; elif do_scf and do_corl and do_delta and do_delta2 and do_delta3 and do_delta4 and not do_delta5:; pass; elif do_scf and do_corl and do_delta and do_delta2 and do_delta3 and do_delta4 and do_delta5:; pass; else:; raise ValidationError('Requested scf (%s) + corl (%s) + delta (%s) + delta2 (%s) + delta3 (%s) + delta4 (%s) + delta5 (%s) not valid. These steps are cummulative.' %; (do_scf, do_corl, do_delta, do_delta2, do_delta3, do_delta4, do_delta5)). # Establish list of valid basis sets for correlation energy; if do_corl:; if 'corl_basis' in kwargs:; BSTC, ZETC = validate_bracketed_basis(kwargs['corl_basis'].lower()); else:; raise ValidationError('CORL basis sets through keyword \'%s\' are required.' % ('corl_basis')). # Establish list of valid basis sets for scf energy; if 'scf_basis' in kwargs:; BSTR, ZETR = validate_bracketed_basis(kwargs['scf_basis'].lower()); else:; if do_corl:; BSTR = BSTC[:]; ZETR = ZETC[:]; else:; raise ValidationError('SCF basis sets through keyword \'%s\' are required. Or perhaps you forgot the \'%s\'.' % ('scf_basis', 'corl_wfn')). # Establish list of valid basis sets for delta correction energy; if do_delta:; if 'delta_basis' in kwargs:; BSTD, ZETD = validate_bracketed_basis(kwargs['delta_basis'].lower()); else:; raise ValidationError('DELTA basis sets through keyword \'%s\' are required.' % ('delta_basis')). # Establish list of valid basis sets for second delta correction energy; if do_delta2:; if 'delta2_basis' in kwargs:; BSTD2, ZETD2 = validate_bracketed_basis(kwargs['delta2_basis'].lower()); else:; raise ValidationError('DELTA2 basis sets through keyword \'%s\' are required.' % ('delta2_basis')). # Establish list of valid basis sets for third delta correction energy; if do_delta3:; if 'delta3_basis' in kwargs:; BSTD3, ZETD3 = validate",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:75925,Energy Efficiency,energy,energy,75925," do_delta3 and do_delta4 and do_delta5:; pass; else:; raise ValidationError('Requested scf (%s) + corl (%s) + delta (%s) + delta2 (%s) + delta3 (%s) + delta4 (%s) + delta5 (%s) not valid. These steps are cummulative.' %; (do_scf, do_corl, do_delta, do_delta2, do_delta3, do_delta4, do_delta5)). # Establish list of valid basis sets for correlation energy; if do_corl:; if 'corl_basis' in kwargs:; BSTC, ZETC = validate_bracketed_basis(kwargs['corl_basis'].lower()); else:; raise ValidationError('CORL basis sets through keyword \'%s\' are required.' % ('corl_basis')). # Establish list of valid basis sets for scf energy; if 'scf_basis' in kwargs:; BSTR, ZETR = validate_bracketed_basis(kwargs['scf_basis'].lower()); else:; if do_corl:; BSTR = BSTC[:]; ZETR = ZETC[:]; else:; raise ValidationError('SCF basis sets through keyword \'%s\' are required. Or perhaps you forgot the \'%s\'.' % ('scf_basis', 'corl_wfn')). # Establish list of valid basis sets for delta correction energy; if do_delta:; if 'delta_basis' in kwargs:; BSTD, ZETD = validate_bracketed_basis(kwargs['delta_basis'].lower()); else:; raise ValidationError('DELTA basis sets through keyword \'%s\' are required.' % ('delta_basis')). # Establish list of valid basis sets for second delta correction energy; if do_delta2:; if 'delta2_basis' in kwargs:; BSTD2, ZETD2 = validate_bracketed_basis(kwargs['delta2_basis'].lower()); else:; raise ValidationError('DELTA2 basis sets through keyword \'%s\' are required.' % ('delta2_basis')). # Establish list of valid basis sets for third delta correction energy; if do_delta3:; if 'delta3_basis' in kwargs:; BSTD3, ZETD3 = validate_bracketed_basis(kwargs['delta3_basis'].lower()); else:; raise ValidationError('DELTA3 basis sets through keyword \'%s\' are required.' % ('delta3_basis')). # Establish list of valid basis sets for fourth delta correction energy; if do_delta4:; if 'delta4_basis' in kwargs:; BSTD4, ZETD4 = validate_bracketed_basis(kwargs['delta4_basis'].lower()); else:; raise V",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:76216,Energy Efficiency,energy,energy,76216,"5)). # Establish list of valid basis sets for correlation energy; if do_corl:; if 'corl_basis' in kwargs:; BSTC, ZETC = validate_bracketed_basis(kwargs['corl_basis'].lower()); else:; raise ValidationError('CORL basis sets through keyword \'%s\' are required.' % ('corl_basis')). # Establish list of valid basis sets for scf energy; if 'scf_basis' in kwargs:; BSTR, ZETR = validate_bracketed_basis(kwargs['scf_basis'].lower()); else:; if do_corl:; BSTR = BSTC[:]; ZETR = ZETC[:]; else:; raise ValidationError('SCF basis sets through keyword \'%s\' are required. Or perhaps you forgot the \'%s\'.' % ('scf_basis', 'corl_wfn')). # Establish list of valid basis sets for delta correction energy; if do_delta:; if 'delta_basis' in kwargs:; BSTD, ZETD = validate_bracketed_basis(kwargs['delta_basis'].lower()); else:; raise ValidationError('DELTA basis sets through keyword \'%s\' are required.' % ('delta_basis')). # Establish list of valid basis sets for second delta correction energy; if do_delta2:; if 'delta2_basis' in kwargs:; BSTD2, ZETD2 = validate_bracketed_basis(kwargs['delta2_basis'].lower()); else:; raise ValidationError('DELTA2 basis sets through keyword \'%s\' are required.' % ('delta2_basis')). # Establish list of valid basis sets for third delta correction energy; if do_delta3:; if 'delta3_basis' in kwargs:; BSTD3, ZETD3 = validate_bracketed_basis(kwargs['delta3_basis'].lower()); else:; raise ValidationError('DELTA3 basis sets through keyword \'%s\' are required.' % ('delta3_basis')). # Establish list of valid basis sets for fourth delta correction energy; if do_delta4:; if 'delta4_basis' in kwargs:; BSTD4, ZETD4 = validate_bracketed_basis(kwargs['delta4_basis'].lower()); else:; raise ValidationError('DELTA4 basis sets through keyword \'%s\' are required.' % ('delta4_basis')). # Establish list of valid basis sets for fifth delta correction energy; if do_delta5:; if 'delta5_basis' in kwargs:; BSTD5, ZETD5 = validate_bracketed_basis(kwargs['delta5_basis'].lower()); else:; ",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:76513,Energy Efficiency,energy,energy,76513,"f valid basis sets for scf energy; if 'scf_basis' in kwargs:; BSTR, ZETR = validate_bracketed_basis(kwargs['scf_basis'].lower()); else:; if do_corl:; BSTR = BSTC[:]; ZETR = ZETC[:]; else:; raise ValidationError('SCF basis sets through keyword \'%s\' are required. Or perhaps you forgot the \'%s\'.' % ('scf_basis', 'corl_wfn')). # Establish list of valid basis sets for delta correction energy; if do_delta:; if 'delta_basis' in kwargs:; BSTD, ZETD = validate_bracketed_basis(kwargs['delta_basis'].lower()); else:; raise ValidationError('DELTA basis sets through keyword \'%s\' are required.' % ('delta_basis')). # Establish list of valid basis sets for second delta correction energy; if do_delta2:; if 'delta2_basis' in kwargs:; BSTD2, ZETD2 = validate_bracketed_basis(kwargs['delta2_basis'].lower()); else:; raise ValidationError('DELTA2 basis sets through keyword \'%s\' are required.' % ('delta2_basis')). # Establish list of valid basis sets for third delta correction energy; if do_delta3:; if 'delta3_basis' in kwargs:; BSTD3, ZETD3 = validate_bracketed_basis(kwargs['delta3_basis'].lower()); else:; raise ValidationError('DELTA3 basis sets through keyword \'%s\' are required.' % ('delta3_basis')). # Establish list of valid basis sets for fourth delta correction energy; if do_delta4:; if 'delta4_basis' in kwargs:; BSTD4, ZETD4 = validate_bracketed_basis(kwargs['delta4_basis'].lower()); else:; raise ValidationError('DELTA4 basis sets through keyword \'%s\' are required.' % ('delta4_basis')). # Establish list of valid basis sets for fifth delta correction energy; if do_delta5:; if 'delta5_basis' in kwargs:; BSTD5, ZETD5 = validate_bracketed_basis(kwargs['delta5_basis'].lower()); else:; raise ValidationError('DELTA5 basis sets through keyword \'%s\' are required.' % ('delta5_basis')). # Establish treatment for scf energy (validity check useless since python will catch it long before here); cbs_scf_scheme = highest_1; if 'scf_scheme' in kwargs:; cbs_scf_scheme = kwargs['scf_scheme",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:76811,Energy Efficiency,energy,energy,76811," % ('scf_basis', 'corl_wfn')). # Establish list of valid basis sets for delta correction energy; if do_delta:; if 'delta_basis' in kwargs:; BSTD, ZETD = validate_bracketed_basis(kwargs['delta_basis'].lower()); else:; raise ValidationError('DELTA basis sets through keyword \'%s\' are required.' % ('delta_basis')). # Establish list of valid basis sets for second delta correction energy; if do_delta2:; if 'delta2_basis' in kwargs:; BSTD2, ZETD2 = validate_bracketed_basis(kwargs['delta2_basis'].lower()); else:; raise ValidationError('DELTA2 basis sets through keyword \'%s\' are required.' % ('delta2_basis')). # Establish list of valid basis sets for third delta correction energy; if do_delta3:; if 'delta3_basis' in kwargs:; BSTD3, ZETD3 = validate_bracketed_basis(kwargs['delta3_basis'].lower()); else:; raise ValidationError('DELTA3 basis sets through keyword \'%s\' are required.' % ('delta3_basis')). # Establish list of valid basis sets for fourth delta correction energy; if do_delta4:; if 'delta4_basis' in kwargs:; BSTD4, ZETD4 = validate_bracketed_basis(kwargs['delta4_basis'].lower()); else:; raise ValidationError('DELTA4 basis sets through keyword \'%s\' are required.' % ('delta4_basis')). # Establish list of valid basis sets for fifth delta correction energy; if do_delta5:; if 'delta5_basis' in kwargs:; BSTD5, ZETD5 = validate_bracketed_basis(kwargs['delta5_basis'].lower()); else:; raise ValidationError('DELTA5 basis sets through keyword \'%s\' are required.' % ('delta5_basis')). # Establish treatment for scf energy (validity check useless since python will catch it long before here); cbs_scf_scheme = highest_1; if 'scf_scheme' in kwargs:; cbs_scf_scheme = kwargs['scf_scheme']. # Establish treatment for correlation energy; cbs_corl_scheme = highest_1; if 'corl_scheme' in kwargs:; cbs_corl_scheme = kwargs['corl_scheme']. # Establish treatment for delta correction energy; cbs_delta_scheme = highest_1; if 'delta_scheme' in kwargs:; cbs_delta_scheme = kwargs['delta_sche",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:77108,Energy Efficiency,energy,energy,77108,"('delta_basis')). # Establish list of valid basis sets for second delta correction energy; if do_delta2:; if 'delta2_basis' in kwargs:; BSTD2, ZETD2 = validate_bracketed_basis(kwargs['delta2_basis'].lower()); else:; raise ValidationError('DELTA2 basis sets through keyword \'%s\' are required.' % ('delta2_basis')). # Establish list of valid basis sets for third delta correction energy; if do_delta3:; if 'delta3_basis' in kwargs:; BSTD3, ZETD3 = validate_bracketed_basis(kwargs['delta3_basis'].lower()); else:; raise ValidationError('DELTA3 basis sets through keyword \'%s\' are required.' % ('delta3_basis')). # Establish list of valid basis sets for fourth delta correction energy; if do_delta4:; if 'delta4_basis' in kwargs:; BSTD4, ZETD4 = validate_bracketed_basis(kwargs['delta4_basis'].lower()); else:; raise ValidationError('DELTA4 basis sets through keyword \'%s\' are required.' % ('delta4_basis')). # Establish list of valid basis sets for fifth delta correction energy; if do_delta5:; if 'delta5_basis' in kwargs:; BSTD5, ZETD5 = validate_bracketed_basis(kwargs['delta5_basis'].lower()); else:; raise ValidationError('DELTA5 basis sets through keyword \'%s\' are required.' % ('delta5_basis')). # Establish treatment for scf energy (validity check useless since python will catch it long before here); cbs_scf_scheme = highest_1; if 'scf_scheme' in kwargs:; cbs_scf_scheme = kwargs['scf_scheme']. # Establish treatment for correlation energy; cbs_corl_scheme = highest_1; if 'corl_scheme' in kwargs:; cbs_corl_scheme = kwargs['corl_scheme']. # Establish treatment for delta correction energy; cbs_delta_scheme = highest_1; if 'delta_scheme' in kwargs:; cbs_delta_scheme = kwargs['delta_scheme']. # Establish treatment for delta2 correction energy; cbs_delta2_scheme = highest_1; if 'delta2_scheme' in kwargs:; cbs_delta2_scheme = kwargs['delta2_scheme']. # Establish treatment for delta3 correction energy; cbs_delta3_scheme = highest_1; if 'delta3_scheme' in kwargs:; cbs_delta3_scheme =",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:77371,Energy Efficiency,energy,energy,77371,"sis')). # Establish list of valid basis sets for third delta correction energy; if do_delta3:; if 'delta3_basis' in kwargs:; BSTD3, ZETD3 = validate_bracketed_basis(kwargs['delta3_basis'].lower()); else:; raise ValidationError('DELTA3 basis sets through keyword \'%s\' are required.' % ('delta3_basis')). # Establish list of valid basis sets for fourth delta correction energy; if do_delta4:; if 'delta4_basis' in kwargs:; BSTD4, ZETD4 = validate_bracketed_basis(kwargs['delta4_basis'].lower()); else:; raise ValidationError('DELTA4 basis sets through keyword \'%s\' are required.' % ('delta4_basis')). # Establish list of valid basis sets for fifth delta correction energy; if do_delta5:; if 'delta5_basis' in kwargs:; BSTD5, ZETD5 = validate_bracketed_basis(kwargs['delta5_basis'].lower()); else:; raise ValidationError('DELTA5 basis sets through keyword \'%s\' are required.' % ('delta5_basis')). # Establish treatment for scf energy (validity check useless since python will catch it long before here); cbs_scf_scheme = highest_1; if 'scf_scheme' in kwargs:; cbs_scf_scheme = kwargs['scf_scheme']. # Establish treatment for correlation energy; cbs_corl_scheme = highest_1; if 'corl_scheme' in kwargs:; cbs_corl_scheme = kwargs['corl_scheme']. # Establish treatment for delta correction energy; cbs_delta_scheme = highest_1; if 'delta_scheme' in kwargs:; cbs_delta_scheme = kwargs['delta_scheme']. # Establish treatment for delta2 correction energy; cbs_delta2_scheme = highest_1; if 'delta2_scheme' in kwargs:; cbs_delta2_scheme = kwargs['delta2_scheme']. # Establish treatment for delta3 correction energy; cbs_delta3_scheme = highest_1; if 'delta3_scheme' in kwargs:; cbs_delta3_scheme = kwargs['delta3_scheme']. # Establish treatment for delta4 correction energy; cbs_delta4_scheme = highest_1; if 'delta4_scheme' in kwargs:; cbs_delta4_scheme = kwargs['delta4_scheme']. # Establish treatment for delta5 correction energy; cbs_delta5_scheme = highest_1; if 'delta5_scheme' in kwargs:; cbs_delt",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:77581,Energy Efficiency,energy,energy,77581,"delta3_basis'].lower()); else:; raise ValidationError('DELTA3 basis sets through keyword \'%s\' are required.' % ('delta3_basis')). # Establish list of valid basis sets for fourth delta correction energy; if do_delta4:; if 'delta4_basis' in kwargs:; BSTD4, ZETD4 = validate_bracketed_basis(kwargs['delta4_basis'].lower()); else:; raise ValidationError('DELTA4 basis sets through keyword \'%s\' are required.' % ('delta4_basis')). # Establish list of valid basis sets for fifth delta correction energy; if do_delta5:; if 'delta5_basis' in kwargs:; BSTD5, ZETD5 = validate_bracketed_basis(kwargs['delta5_basis'].lower()); else:; raise ValidationError('DELTA5 basis sets through keyword \'%s\' are required.' % ('delta5_basis')). # Establish treatment for scf energy (validity check useless since python will catch it long before here); cbs_scf_scheme = highest_1; if 'scf_scheme' in kwargs:; cbs_scf_scheme = kwargs['scf_scheme']. # Establish treatment for correlation energy; cbs_corl_scheme = highest_1; if 'corl_scheme' in kwargs:; cbs_corl_scheme = kwargs['corl_scheme']. # Establish treatment for delta correction energy; cbs_delta_scheme = highest_1; if 'delta_scheme' in kwargs:; cbs_delta_scheme = kwargs['delta_scheme']. # Establish treatment for delta2 correction energy; cbs_delta2_scheme = highest_1; if 'delta2_scheme' in kwargs:; cbs_delta2_scheme = kwargs['delta2_scheme']. # Establish treatment for delta3 correction energy; cbs_delta3_scheme = highest_1; if 'delta3_scheme' in kwargs:; cbs_delta3_scheme = kwargs['delta3_scheme']. # Establish treatment for delta4 correction energy; cbs_delta4_scheme = highest_1; if 'delta4_scheme' in kwargs:; cbs_delta4_scheme = kwargs['delta4_scheme']. # Establish treatment for delta5 correction energy; cbs_delta5_scheme = highest_1; if 'delta5_scheme' in kwargs:; cbs_delta5_scheme = kwargs['delta5_scheme']. # Build string of title banner; cbsbanners = ''; cbsbanners += """"""psi4.print_out('\\n')\n""""""; cbsbanners += """"""p4util.banner(' CBS Setup ",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:77731,Energy Efficiency,energy,energy,77731,"f valid basis sets for fourth delta correction energy; if do_delta4:; if 'delta4_basis' in kwargs:; BSTD4, ZETD4 = validate_bracketed_basis(kwargs['delta4_basis'].lower()); else:; raise ValidationError('DELTA4 basis sets through keyword \'%s\' are required.' % ('delta4_basis')). # Establish list of valid basis sets for fifth delta correction energy; if do_delta5:; if 'delta5_basis' in kwargs:; BSTD5, ZETD5 = validate_bracketed_basis(kwargs['delta5_basis'].lower()); else:; raise ValidationError('DELTA5 basis sets through keyword \'%s\' are required.' % ('delta5_basis')). # Establish treatment for scf energy (validity check useless since python will catch it long before here); cbs_scf_scheme = highest_1; if 'scf_scheme' in kwargs:; cbs_scf_scheme = kwargs['scf_scheme']. # Establish treatment for correlation energy; cbs_corl_scheme = highest_1; if 'corl_scheme' in kwargs:; cbs_corl_scheme = kwargs['corl_scheme']. # Establish treatment for delta correction energy; cbs_delta_scheme = highest_1; if 'delta_scheme' in kwargs:; cbs_delta_scheme = kwargs['delta_scheme']. # Establish treatment for delta2 correction energy; cbs_delta2_scheme = highest_1; if 'delta2_scheme' in kwargs:; cbs_delta2_scheme = kwargs['delta2_scheme']. # Establish treatment for delta3 correction energy; cbs_delta3_scheme = highest_1; if 'delta3_scheme' in kwargs:; cbs_delta3_scheme = kwargs['delta3_scheme']. # Establish treatment for delta4 correction energy; cbs_delta4_scheme = highest_1; if 'delta4_scheme' in kwargs:; cbs_delta4_scheme = kwargs['delta4_scheme']. # Establish treatment for delta5 correction energy; cbs_delta5_scheme = highest_1; if 'delta5_scheme' in kwargs:; cbs_delta5_scheme = kwargs['delta5_scheme']. # Build string of title banner; cbsbanners = ''; cbsbanners += """"""psi4.print_out('\\n')\n""""""; cbsbanners += """"""p4util.banner(' CBS Setup ')\n""""""; cbsbanners += """"""psi4.print_out('\\n')\n\n""""""; exec(cbsbanners). # Call schemes for each portion of total energy to 'place orders' for calcu",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:77886,Energy Efficiency,energy,energy,77886,"asis'].lower()); else:; raise ValidationError('DELTA4 basis sets through keyword \'%s\' are required.' % ('delta4_basis')). # Establish list of valid basis sets for fifth delta correction energy; if do_delta5:; if 'delta5_basis' in kwargs:; BSTD5, ZETD5 = validate_bracketed_basis(kwargs['delta5_basis'].lower()); else:; raise ValidationError('DELTA5 basis sets through keyword \'%s\' are required.' % ('delta5_basis')). # Establish treatment for scf energy (validity check useless since python will catch it long before here); cbs_scf_scheme = highest_1; if 'scf_scheme' in kwargs:; cbs_scf_scheme = kwargs['scf_scheme']. # Establish treatment for correlation energy; cbs_corl_scheme = highest_1; if 'corl_scheme' in kwargs:; cbs_corl_scheme = kwargs['corl_scheme']. # Establish treatment for delta correction energy; cbs_delta_scheme = highest_1; if 'delta_scheme' in kwargs:; cbs_delta_scheme = kwargs['delta_scheme']. # Establish treatment for delta2 correction energy; cbs_delta2_scheme = highest_1; if 'delta2_scheme' in kwargs:; cbs_delta2_scheme = kwargs['delta2_scheme']. # Establish treatment for delta3 correction energy; cbs_delta3_scheme = highest_1; if 'delta3_scheme' in kwargs:; cbs_delta3_scheme = kwargs['delta3_scheme']. # Establish treatment for delta4 correction energy; cbs_delta4_scheme = highest_1; if 'delta4_scheme' in kwargs:; cbs_delta4_scheme = kwargs['delta4_scheme']. # Establish treatment for delta5 correction energy; cbs_delta5_scheme = highest_1; if 'delta5_scheme' in kwargs:; cbs_delta5_scheme = kwargs['delta5_scheme']. # Build string of title banner; cbsbanners = ''; cbsbanners += """"""psi4.print_out('\\n')\n""""""; cbsbanners += """"""p4util.banner(' CBS Setup ')\n""""""; cbsbanners += """"""psi4.print_out('\\n')\n\n""""""; exec(cbsbanners). # Call schemes for each portion of total energy to 'place orders' for calculations needed; d_fields = ['d_stage', 'd_scheme', 'd_basis', 'd_wfn', 'd_need', 'd_coef', 'd_energy']; f_fields = ['f_wfn', 'f_portion', 'f_basis', 'f_zeta'",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:78045,Energy Efficiency,energy,energy,78045,"s for fifth delta correction energy; if do_delta5:; if 'delta5_basis' in kwargs:; BSTD5, ZETD5 = validate_bracketed_basis(kwargs['delta5_basis'].lower()); else:; raise ValidationError('DELTA5 basis sets through keyword \'%s\' are required.' % ('delta5_basis')). # Establish treatment for scf energy (validity check useless since python will catch it long before here); cbs_scf_scheme = highest_1; if 'scf_scheme' in kwargs:; cbs_scf_scheme = kwargs['scf_scheme']. # Establish treatment for correlation energy; cbs_corl_scheme = highest_1; if 'corl_scheme' in kwargs:; cbs_corl_scheme = kwargs['corl_scheme']. # Establish treatment for delta correction energy; cbs_delta_scheme = highest_1; if 'delta_scheme' in kwargs:; cbs_delta_scheme = kwargs['delta_scheme']. # Establish treatment for delta2 correction energy; cbs_delta2_scheme = highest_1; if 'delta2_scheme' in kwargs:; cbs_delta2_scheme = kwargs['delta2_scheme']. # Establish treatment for delta3 correction energy; cbs_delta3_scheme = highest_1; if 'delta3_scheme' in kwargs:; cbs_delta3_scheme = kwargs['delta3_scheme']. # Establish treatment for delta4 correction energy; cbs_delta4_scheme = highest_1; if 'delta4_scheme' in kwargs:; cbs_delta4_scheme = kwargs['delta4_scheme']. # Establish treatment for delta5 correction energy; cbs_delta5_scheme = highest_1; if 'delta5_scheme' in kwargs:; cbs_delta5_scheme = kwargs['delta5_scheme']. # Build string of title banner; cbsbanners = ''; cbsbanners += """"""psi4.print_out('\\n')\n""""""; cbsbanners += """"""p4util.banner(' CBS Setup ')\n""""""; cbsbanners += """"""psi4.print_out('\\n')\n\n""""""; exec(cbsbanners). # Call schemes for each portion of total energy to 'place orders' for calculations needed; d_fields = ['d_stage', 'd_scheme', 'd_basis', 'd_wfn', 'd_need', 'd_coef', 'd_energy']; f_fields = ['f_wfn', 'f_portion', 'f_basis', 'f_zeta', 'f_energy']; GRAND_NEED = []; MODELCHEM = []; bstring = ''; if do_scf:; NEED = call_function_in_1st_argument(cbs_scf_scheme,; mode='requisition', basisname=B",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:78204,Energy Efficiency,energy,energy,78204,":; raise ValidationError('DELTA5 basis sets through keyword \'%s\' are required.' % ('delta5_basis')). # Establish treatment for scf energy (validity check useless since python will catch it long before here); cbs_scf_scheme = highest_1; if 'scf_scheme' in kwargs:; cbs_scf_scheme = kwargs['scf_scheme']. # Establish treatment for correlation energy; cbs_corl_scheme = highest_1; if 'corl_scheme' in kwargs:; cbs_corl_scheme = kwargs['corl_scheme']. # Establish treatment for delta correction energy; cbs_delta_scheme = highest_1; if 'delta_scheme' in kwargs:; cbs_delta_scheme = kwargs['delta_scheme']. # Establish treatment for delta2 correction energy; cbs_delta2_scheme = highest_1; if 'delta2_scheme' in kwargs:; cbs_delta2_scheme = kwargs['delta2_scheme']. # Establish treatment for delta3 correction energy; cbs_delta3_scheme = highest_1; if 'delta3_scheme' in kwargs:; cbs_delta3_scheme = kwargs['delta3_scheme']. # Establish treatment for delta4 correction energy; cbs_delta4_scheme = highest_1; if 'delta4_scheme' in kwargs:; cbs_delta4_scheme = kwargs['delta4_scheme']. # Establish treatment for delta5 correction energy; cbs_delta5_scheme = highest_1; if 'delta5_scheme' in kwargs:; cbs_delta5_scheme = kwargs['delta5_scheme']. # Build string of title banner; cbsbanners = ''; cbsbanners += """"""psi4.print_out('\\n')\n""""""; cbsbanners += """"""p4util.banner(' CBS Setup ')\n""""""; cbsbanners += """"""psi4.print_out('\\n')\n\n""""""; exec(cbsbanners). # Call schemes for each portion of total energy to 'place orders' for calculations needed; d_fields = ['d_stage', 'd_scheme', 'd_basis', 'd_wfn', 'd_need', 'd_coef', 'd_energy']; f_fields = ['f_wfn', 'f_portion', 'f_basis', 'f_zeta', 'f_energy']; GRAND_NEED = []; MODELCHEM = []; bstring = ''; if do_scf:; NEED = call_function_in_1st_argument(cbs_scf_scheme,; mode='requisition', basisname=BSTR, basiszeta=ZETR, wfnname='scf'); GRAND_NEED.append(dict(zip(d_fields, ['scf', cbs_scf_scheme, reconstitute_bracketed_basis(NEED), 'scf', NEED, +1, 0.0]))).",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:78363,Energy Efficiency,energy,energy,78363,"less since python will catch it long before here); cbs_scf_scheme = highest_1; if 'scf_scheme' in kwargs:; cbs_scf_scheme = kwargs['scf_scheme']. # Establish treatment for correlation energy; cbs_corl_scheme = highest_1; if 'corl_scheme' in kwargs:; cbs_corl_scheme = kwargs['corl_scheme']. # Establish treatment for delta correction energy; cbs_delta_scheme = highest_1; if 'delta_scheme' in kwargs:; cbs_delta_scheme = kwargs['delta_scheme']. # Establish treatment for delta2 correction energy; cbs_delta2_scheme = highest_1; if 'delta2_scheme' in kwargs:; cbs_delta2_scheme = kwargs['delta2_scheme']. # Establish treatment for delta3 correction energy; cbs_delta3_scheme = highest_1; if 'delta3_scheme' in kwargs:; cbs_delta3_scheme = kwargs['delta3_scheme']. # Establish treatment for delta4 correction energy; cbs_delta4_scheme = highest_1; if 'delta4_scheme' in kwargs:; cbs_delta4_scheme = kwargs['delta4_scheme']. # Establish treatment for delta5 correction energy; cbs_delta5_scheme = highest_1; if 'delta5_scheme' in kwargs:; cbs_delta5_scheme = kwargs['delta5_scheme']. # Build string of title banner; cbsbanners = ''; cbsbanners += """"""psi4.print_out('\\n')\n""""""; cbsbanners += """"""p4util.banner(' CBS Setup ')\n""""""; cbsbanners += """"""psi4.print_out('\\n')\n\n""""""; exec(cbsbanners). # Call schemes for each portion of total energy to 'place orders' for calculations needed; d_fields = ['d_stage', 'd_scheme', 'd_basis', 'd_wfn', 'd_need', 'd_coef', 'd_energy']; f_fields = ['f_wfn', 'f_portion', 'f_basis', 'f_zeta', 'f_energy']; GRAND_NEED = []; MODELCHEM = []; bstring = ''; if do_scf:; NEED = call_function_in_1st_argument(cbs_scf_scheme,; mode='requisition', basisname=BSTR, basiszeta=ZETR, wfnname='scf'); GRAND_NEED.append(dict(zip(d_fields, ['scf', cbs_scf_scheme, reconstitute_bracketed_basis(NEED), 'scf', NEED, +1, 0.0]))). if do_corl:; NEED = call_function_in_1st_argument(cbs_corl_scheme,; mode='requisition', basisname=BSTC, basiszeta=ZETC, wfnname=cbs_corl_wfn); GRAND_NEED.appe",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:78730,Energy Efficiency,energy,energy,78730,"eme = highest_1; if 'delta2_scheme' in kwargs:; cbs_delta2_scheme = kwargs['delta2_scheme']. # Establish treatment for delta3 correction energy; cbs_delta3_scheme = highest_1; if 'delta3_scheme' in kwargs:; cbs_delta3_scheme = kwargs['delta3_scheme']. # Establish treatment for delta4 correction energy; cbs_delta4_scheme = highest_1; if 'delta4_scheme' in kwargs:; cbs_delta4_scheme = kwargs['delta4_scheme']. # Establish treatment for delta5 correction energy; cbs_delta5_scheme = highest_1; if 'delta5_scheme' in kwargs:; cbs_delta5_scheme = kwargs['delta5_scheme']. # Build string of title banner; cbsbanners = ''; cbsbanners += """"""psi4.print_out('\\n')\n""""""; cbsbanners += """"""p4util.banner(' CBS Setup ')\n""""""; cbsbanners += """"""psi4.print_out('\\n')\n\n""""""; exec(cbsbanners). # Call schemes for each portion of total energy to 'place orders' for calculations needed; d_fields = ['d_stage', 'd_scheme', 'd_basis', 'd_wfn', 'd_need', 'd_coef', 'd_energy']; f_fields = ['f_wfn', 'f_portion', 'f_basis', 'f_zeta', 'f_energy']; GRAND_NEED = []; MODELCHEM = []; bstring = ''; if do_scf:; NEED = call_function_in_1st_argument(cbs_scf_scheme,; mode='requisition', basisname=BSTR, basiszeta=ZETR, wfnname='scf'); GRAND_NEED.append(dict(zip(d_fields, ['scf', cbs_scf_scheme, reconstitute_bracketed_basis(NEED), 'scf', NEED, +1, 0.0]))). if do_corl:; NEED = call_function_in_1st_argument(cbs_corl_scheme,; mode='requisition', basisname=BSTC, basiszeta=ZETC, wfnname=cbs_corl_wfn); GRAND_NEED.append(dict(zip(d_fields, ['corl', cbs_corl_scheme, reconstitute_bracketed_basis(NEED), cbs_corl_wfn, NEED, +1, 0.0]))). if do_delta:; NEED = call_function_in_1st_argument(cbs_delta_scheme,; mode='requisition', basisname=BSTD, basiszeta=ZETD, wfnname=cbs_delta_wfn); GRAND_NEED.append(dict(zip(d_fields, ['delta', cbs_delta_scheme, reconstitute_bracketed_basis(NEED), cbs_delta_wfn, NEED, +1, 0.0]))). NEED = call_function_in_1st_argument(cbs_delta_scheme,; mode='requisition', basisname=BSTD, basiszeta=ZETD, wfnn",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:84991,Energy Efficiency,energy,energy,84991,"or %s\n"""""" % (mc['f_wfn'], mc['f_basis'], VARH[mc['f_wfn']][mc['f_wfn']+mc['f_portion']]); psi4.print_out(instructions). psioh = psi4.IOManager.shared_object(); psioh.set_specific_retention(p4const.PSIF_SCF_MOS, True). # Run necessary computations; for mc in JOBS:; kwargs['name'] = mc['f_wfn']. # Build string of title banner; cbsbanners = ''; cbsbanners += """"""psi4.print_out('\\n')\n""""""; cbsbanners += """"""p4util.banner(' CBS Computation: %s / %s ')\n"""""" % (mc['f_wfn'].upper(), mc['f_basis'].upper()); cbsbanners += """"""psi4.print_out('\\n')\n\n""""""; exec(cbsbanners). # Build string of molecule and commands that are dependent on the database; commands = '\n'; commands += """"""\npsi4.set_global_option('BASIS', '%s')\n"""""" % (mc['f_basis']); commands += """"""psi4.set_global_option('WRITER_FILE_LABEL', '%s')\n"""""" % \; (user_writer_file_label + ('' if user_writer_file_label == '' else '-') + mc['f_wfn'].lower() + '-' + mc['f_basis'].lower()). exec(commands). # Make energy() call; mc['f_energy'] = call_function_in_1st_argument(func, **kwargs). # Fill in energies for subsumed methods; for menial in VARH[mc['f_wfn']]:; temp_wfn, temp_portion = split_menial(menial); for job in JOBS_EXT:; if (temp_wfn == job['f_wfn']) and (temp_portion == job['f_portion']) and (mc['f_basis'] == job['f_basis']):; job['f_energy'] = psi4.get_variable(VARH[temp_wfn][menial]). psi4.clean(). psioh.set_specific_retention(p4const.PSIF_SCF_MOS, False). # Build string of title banner; cbsbanners = ''; cbsbanners += """"""psi4.print_out('\\n')\n""""""; cbsbanners += """"""p4util.banner(' CBS Results ')\n""""""; cbsbanners += """"""psi4.print_out('\\n')\n\n""""""; exec(cbsbanners). # Insert obtained energies into the array that stores the cbs stages; for stage in GRAND_NEED:; for lvl in stage['d_need'].items():; MODELCHEM.append(lvl[1]). for job in JOBS_EXT:; if ((lvl[1]['f_wfn'] == job['f_wfn']) and (lvl[1]['f_portion'] == job['f_portion']) and; (lvl[1]['f_basis'] == job['f_basis'])):; lvl[1]['f_energy'] = job['f_energy']. for sta",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:86463,Energy Efficiency,Energy,Energy,86463,"se). # Build string of title banner; cbsbanners = ''; cbsbanners += """"""psi4.print_out('\\n')\n""""""; cbsbanners += """"""p4util.banner(' CBS Results ')\n""""""; cbsbanners += """"""psi4.print_out('\\n')\n\n""""""; exec(cbsbanners). # Insert obtained energies into the array that stores the cbs stages; for stage in GRAND_NEED:; for lvl in stage['d_need'].items():; MODELCHEM.append(lvl[1]). for job in JOBS_EXT:; if ((lvl[1]['f_wfn'] == job['f_wfn']) and (lvl[1]['f_portion'] == job['f_portion']) and; (lvl[1]['f_basis'] == job['f_basis'])):; lvl[1]['f_energy'] = job['f_energy']. for stage in GRAND_NEED:; stage['d_energy'] = call_function_in_1st_argument(stage['d_scheme'], needname=stage['d_need'], mode='evaluate'); finalenergy += stage['d_energy'] * stage['d_coef']. # Build string of results table; table_delimit = ' ' + '-' * 105 + '\n'; tables = ''; tables += """"""\n ==> %s <==\n\n"""""" % ('Components'); tables += table_delimit; tables += """""" %6s %20s %1s %-26s %3s %16s %-s\n"""""" % ('', 'Method', '/', 'Basis', 'Rqd', 'Energy [H]', 'Variable'); tables += table_delimit; for job in JOBS_EXT:; star = ''; for mc in MODELCHEM:; if (job['f_wfn'] == mc['f_wfn']) and (job['f_basis'] == mc['f_basis']):; star = '*'; tables += """""" %6s %20s %1s %-27s %2s %16.8f %-s\n"""""" % ('', job['f_wfn'],; '/', job['f_basis'], star, job['f_energy'], VARH[job['f_wfn']][job['f_wfn'] + job['f_portion']]); tables += table_delimit. tables += """"""\n ==> %s <==\n\n"""""" % ('Stages'); tables += table_delimit; tables += """""" %6s %20s %1s %-27s %2s %16s %-s\n"""""" % ('Stage', 'Method', '/', 'Basis', 'Wt', 'Energy [H]', 'Scheme'); tables += table_delimit; for stage in GRAND_NEED:; tables += """""" %6s %20s %1s %-27s %2d %16.8f %-s\n"""""" % (stage['d_stage'], stage['d_wfn'],; '/', stage['d_basis'], stage['d_coef'], stage['d_energy'], stage['d_scheme'].__name__); tables += table_delimit. tables += """"""\n ==> %s <==\n\n"""""" % ('CBS'); tables += table_delimit; tables += """""" %6s %20s %1s %-27s %2s %16s %-s\n"""""" % ('Stage', 'Method', '/', 'Basis",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:87019,Energy Efficiency,Energy,Energy,87019,"ergy'] = job['f_energy']. for stage in GRAND_NEED:; stage['d_energy'] = call_function_in_1st_argument(stage['d_scheme'], needname=stage['d_need'], mode='evaluate'); finalenergy += stage['d_energy'] * stage['d_coef']. # Build string of results table; table_delimit = ' ' + '-' * 105 + '\n'; tables = ''; tables += """"""\n ==> %s <==\n\n"""""" % ('Components'); tables += table_delimit; tables += """""" %6s %20s %1s %-26s %3s %16s %-s\n"""""" % ('', 'Method', '/', 'Basis', 'Rqd', 'Energy [H]', 'Variable'); tables += table_delimit; for job in JOBS_EXT:; star = ''; for mc in MODELCHEM:; if (job['f_wfn'] == mc['f_wfn']) and (job['f_basis'] == mc['f_basis']):; star = '*'; tables += """""" %6s %20s %1s %-27s %2s %16.8f %-s\n"""""" % ('', job['f_wfn'],; '/', job['f_basis'], star, job['f_energy'], VARH[job['f_wfn']][job['f_wfn'] + job['f_portion']]); tables += table_delimit. tables += """"""\n ==> %s <==\n\n"""""" % ('Stages'); tables += table_delimit; tables += """""" %6s %20s %1s %-27s %2s %16s %-s\n"""""" % ('Stage', 'Method', '/', 'Basis', 'Wt', 'Energy [H]', 'Scheme'); tables += table_delimit; for stage in GRAND_NEED:; tables += """""" %6s %20s %1s %-27s %2d %16.8f %-s\n"""""" % (stage['d_stage'], stage['d_wfn'],; '/', stage['d_basis'], stage['d_coef'], stage['d_energy'], stage['d_scheme'].__name__); tables += table_delimit. tables += """"""\n ==> %s <==\n\n"""""" % ('CBS'); tables += table_delimit; tables += """""" %6s %20s %1s %-27s %2s %16s %-s\n"""""" % ('Stage', 'Method', '/', 'Basis', '', 'Energy [H]', 'Scheme'); tables += table_delimit; if do_scf:; tables += """""" %6s %20s %1s %-27s %2s %16.8f %-s\n"""""" % (GRAND_NEED[0]['d_stage'], GRAND_NEED[0]['d_wfn'],; '/', GRAND_NEED[0]['d_basis'], '', GRAND_NEED[0]['d_energy'], GRAND_NEED[0]['d_scheme'].__name__); if do_corl:; tables += """""" %6s %20s %1s %-27s %2s %16.8f %-s\n"""""" % (GRAND_NEED[1]['d_stage'], GRAND_NEED[1]['d_wfn'],; '/', GRAND_NEED[1]['d_basis'], '', GRAND_NEED[1]['d_energy'], GRAND_NEED[1]['d_scheme'].__name__); if do_delta:; tables += """""" %6s %20s %1s %-27s ",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:87460,Energy Efficiency,Energy,Energy,87460,", 'Method', '/', 'Basis', 'Rqd', 'Energy [H]', 'Variable'); tables += table_delimit; for job in JOBS_EXT:; star = ''; for mc in MODELCHEM:; if (job['f_wfn'] == mc['f_wfn']) and (job['f_basis'] == mc['f_basis']):; star = '*'; tables += """""" %6s %20s %1s %-27s %2s %16.8f %-s\n"""""" % ('', job['f_wfn'],; '/', job['f_basis'], star, job['f_energy'], VARH[job['f_wfn']][job['f_wfn'] + job['f_portion']]); tables += table_delimit. tables += """"""\n ==> %s <==\n\n"""""" % ('Stages'); tables += table_delimit; tables += """""" %6s %20s %1s %-27s %2s %16s %-s\n"""""" % ('Stage', 'Method', '/', 'Basis', 'Wt', 'Energy [H]', 'Scheme'); tables += table_delimit; for stage in GRAND_NEED:; tables += """""" %6s %20s %1s %-27s %2d %16.8f %-s\n"""""" % (stage['d_stage'], stage['d_wfn'],; '/', stage['d_basis'], stage['d_coef'], stage['d_energy'], stage['d_scheme'].__name__); tables += table_delimit. tables += """"""\n ==> %s <==\n\n"""""" % ('CBS'); tables += table_delimit; tables += """""" %6s %20s %1s %-27s %2s %16s %-s\n"""""" % ('Stage', 'Method', '/', 'Basis', '', 'Energy [H]', 'Scheme'); tables += table_delimit; if do_scf:; tables += """""" %6s %20s %1s %-27s %2s %16.8f %-s\n"""""" % (GRAND_NEED[0]['d_stage'], GRAND_NEED[0]['d_wfn'],; '/', GRAND_NEED[0]['d_basis'], '', GRAND_NEED[0]['d_energy'], GRAND_NEED[0]['d_scheme'].__name__); if do_corl:; tables += """""" %6s %20s %1s %-27s %2s %16.8f %-s\n"""""" % (GRAND_NEED[1]['d_stage'], GRAND_NEED[1]['d_wfn'],; '/', GRAND_NEED[1]['d_basis'], '', GRAND_NEED[1]['d_energy'], GRAND_NEED[1]['d_scheme'].__name__); if do_delta:; tables += """""" %6s %20s %1s %-27s %2s %16.8f %-s\n"""""" % (GRAND_NEED[2]['d_stage'], GRAND_NEED[2]['d_wfn'] + ' - ' + GRAND_NEED[3]['d_wfn'],; '/', GRAND_NEED[2]['d_basis'], '', GRAND_NEED[2]['d_energy'] - GRAND_NEED[3]['d_energy'], GRAND_NEED[2]['d_scheme'].__name__); if do_delta2:; tables += """""" %6s %20s %1s %-27s %2s %16.8f %-s\n"""""" % (GRAND_NEED[4]['d_stage'], GRAND_NEED[4]['d_wfn'] + ' - ' + GRAND_NEED[5]['d_wfn'],; '/', GRAND_NEED[4]['d_basis'], '', GRAND_NEED[4]",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:89922,Energy Efficiency,ENERGY,ENERGY,89922,"ED[9]['d_wfn'],; '/', GRAND_NEED[8]['d_basis'], '', GRAND_NEED[8]['d_energy'] - GRAND_NEED[9]['d_energy'], GRAND_NEED[8]['d_scheme'].__name__); if do_delta5:; tables += """""" %6s %20s %1s %-27s %2s %16.8f %-s\n"""""" % (GRAND_NEED[10]['d_stage'], GRAND_NEED[10]['d_wfn'] + ' - ' + GRAND_NEED[11]['d_wfn'],; '/', GRAND_NEED[10]['d_basis'], '', GRAND_NEED[10]['d_energy'] - GRAND_NEED[11]['d_energy'], GRAND_NEED[10]['d_scheme'].__name__); tables += """""" %6s %20s %1s %-27s %2s %16.8f %-s\n"""""" % ('total', 'CBS', '', '', '', finalenergy, ''); tables += table_delimit. #print tables; psi4.print_out(tables). # Restore molecule and options; #psi4.set_local_option('SCF', ""WFN"", user_wfn) # TODO refuses to set global option WFN - rejects SCF as option; psi4.set_global_option('BASIS', user_basis). psi4.set_global_option('WFN', user_wfn); if not b_user_wfn:; psi4.revoke_global_option_changed('WFN'). psi4.set_global_option('WRITER_FILE_LABEL', user_writer_file_label). psi4.set_variable('CBS REFERENCE ENERGY', GRAND_NEED[0]['d_energy']); psi4.set_variable('CBS CORRELATION ENERGY', finalenergy - GRAND_NEED[0]['d_energy']); psi4.set_variable('CBS TOTAL ENERGY', finalenergy); psi4.set_variable('CURRENT REFERENCE ENERGY', GRAND_NEED[0]['d_energy']); psi4.set_variable('CURRENT CORRELATION ENERGY', finalenergy - GRAND_NEED[0]['d_energy']); psi4.set_variable('CURRENT ENERGY', finalenergy); return finalenergy. # Transform and validate basis sets from 'cc-pV[Q5]Z' into [cc-pVQZ, cc-pV5Z] and [4, 5]; [docs]def validate_bracketed_basis(basisstring):; r""""""Function to transform and validate basis sets for cbs(). A basis set with no; paired square brackets is passed through with zeta level 0 (e.g., '6-31+G(d,p)'; is returned as [6-31+G(d,p)] and [0]). A basis set with square brackets is; checked for sensible sequence and Dunning-ness and returned as separate basis; sets (e.g., 'cc-pV[Q5]Z' is returned as [cc-pVQZ, cc-pV5Z] and [4, 5]). Note; that this function has no communication with the basis set lib",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:89994,Energy Efficiency,ENERGY,ENERGY,89994,"- GRAND_NEED[9]['d_energy'], GRAND_NEED[8]['d_scheme'].__name__); if do_delta5:; tables += """""" %6s %20s %1s %-27s %2s %16.8f %-s\n"""""" % (GRAND_NEED[10]['d_stage'], GRAND_NEED[10]['d_wfn'] + ' - ' + GRAND_NEED[11]['d_wfn'],; '/', GRAND_NEED[10]['d_basis'], '', GRAND_NEED[10]['d_energy'] - GRAND_NEED[11]['d_energy'], GRAND_NEED[10]['d_scheme'].__name__); tables += """""" %6s %20s %1s %-27s %2s %16.8f %-s\n"""""" % ('total', 'CBS', '', '', '', finalenergy, ''); tables += table_delimit. #print tables; psi4.print_out(tables). # Restore molecule and options; #psi4.set_local_option('SCF', ""WFN"", user_wfn) # TODO refuses to set global option WFN - rejects SCF as option; psi4.set_global_option('BASIS', user_basis). psi4.set_global_option('WFN', user_wfn); if not b_user_wfn:; psi4.revoke_global_option_changed('WFN'). psi4.set_global_option('WRITER_FILE_LABEL', user_writer_file_label). psi4.set_variable('CBS REFERENCE ENERGY', GRAND_NEED[0]['d_energy']); psi4.set_variable('CBS CORRELATION ENERGY', finalenergy - GRAND_NEED[0]['d_energy']); psi4.set_variable('CBS TOTAL ENERGY', finalenergy); psi4.set_variable('CURRENT REFERENCE ENERGY', GRAND_NEED[0]['d_energy']); psi4.set_variable('CURRENT CORRELATION ENERGY', finalenergy - GRAND_NEED[0]['d_energy']); psi4.set_variable('CURRENT ENERGY', finalenergy); return finalenergy. # Transform and validate basis sets from 'cc-pV[Q5]Z' into [cc-pVQZ, cc-pV5Z] and [4, 5]; [docs]def validate_bracketed_basis(basisstring):; r""""""Function to transform and validate basis sets for cbs(). A basis set with no; paired square brackets is passed through with zeta level 0 (e.g., '6-31+G(d,p)'; is returned as [6-31+G(d,p)] and [0]). A basis set with square brackets is; checked for sensible sequence and Dunning-ness and returned as separate basis; sets (e.g., 'cc-pV[Q5]Z' is returned as [cc-pVQZ, cc-pV5Z] and [4, 5]). Note; that this function has no communication with the basis set library to check; if the basis actually exists. Used by :py:func:`~wrappers.compl",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:90074,Energy Efficiency,ENERGY,ENERGY,90074,"do_delta5:; tables += """""" %6s %20s %1s %-27s %2s %16.8f %-s\n"""""" % (GRAND_NEED[10]['d_stage'], GRAND_NEED[10]['d_wfn'] + ' - ' + GRAND_NEED[11]['d_wfn'],; '/', GRAND_NEED[10]['d_basis'], '', GRAND_NEED[10]['d_energy'] - GRAND_NEED[11]['d_energy'], GRAND_NEED[10]['d_scheme'].__name__); tables += """""" %6s %20s %1s %-27s %2s %16.8f %-s\n"""""" % ('total', 'CBS', '', '', '', finalenergy, ''); tables += table_delimit. #print tables; psi4.print_out(tables). # Restore molecule and options; #psi4.set_local_option('SCF', ""WFN"", user_wfn) # TODO refuses to set global option WFN - rejects SCF as option; psi4.set_global_option('BASIS', user_basis). psi4.set_global_option('WFN', user_wfn); if not b_user_wfn:; psi4.revoke_global_option_changed('WFN'). psi4.set_global_option('WRITER_FILE_LABEL', user_writer_file_label). psi4.set_variable('CBS REFERENCE ENERGY', GRAND_NEED[0]['d_energy']); psi4.set_variable('CBS CORRELATION ENERGY', finalenergy - GRAND_NEED[0]['d_energy']); psi4.set_variable('CBS TOTAL ENERGY', finalenergy); psi4.set_variable('CURRENT REFERENCE ENERGY', GRAND_NEED[0]['d_energy']); psi4.set_variable('CURRENT CORRELATION ENERGY', finalenergy - GRAND_NEED[0]['d_energy']); psi4.set_variable('CURRENT ENERGY', finalenergy); return finalenergy. # Transform and validate basis sets from 'cc-pV[Q5]Z' into [cc-pVQZ, cc-pV5Z] and [4, 5]; [docs]def validate_bracketed_basis(basisstring):; r""""""Function to transform and validate basis sets for cbs(). A basis set with no; paired square brackets is passed through with zeta level 0 (e.g., '6-31+G(d,p)'; is returned as [6-31+G(d,p)] and [0]). A basis set with square brackets is; checked for sensible sequence and Dunning-ness and returned as separate basis; sets (e.g., 'cc-pV[Q5]Z' is returned as [cc-pVQZ, cc-pV5Z] and [4, 5]). Note; that this function has no communication with the basis set library to check; if the basis actually exists. Used by :py:func:`~wrappers.complete_basis_set`. """"""; ZETA = ['d', 't', 'q', '5', '6']; BSET = []; ZSE",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:90134,Energy Efficiency,ENERGY,ENERGY,90134,""" % (GRAND_NEED[10]['d_stage'], GRAND_NEED[10]['d_wfn'] + ' - ' + GRAND_NEED[11]['d_wfn'],; '/', GRAND_NEED[10]['d_basis'], '', GRAND_NEED[10]['d_energy'] - GRAND_NEED[11]['d_energy'], GRAND_NEED[10]['d_scheme'].__name__); tables += """""" %6s %20s %1s %-27s %2s %16.8f %-s\n"""""" % ('total', 'CBS', '', '', '', finalenergy, ''); tables += table_delimit. #print tables; psi4.print_out(tables). # Restore molecule and options; #psi4.set_local_option('SCF', ""WFN"", user_wfn) # TODO refuses to set global option WFN - rejects SCF as option; psi4.set_global_option('BASIS', user_basis). psi4.set_global_option('WFN', user_wfn); if not b_user_wfn:; psi4.revoke_global_option_changed('WFN'). psi4.set_global_option('WRITER_FILE_LABEL', user_writer_file_label). psi4.set_variable('CBS REFERENCE ENERGY', GRAND_NEED[0]['d_energy']); psi4.set_variable('CBS CORRELATION ENERGY', finalenergy - GRAND_NEED[0]['d_energy']); psi4.set_variable('CBS TOTAL ENERGY', finalenergy); psi4.set_variable('CURRENT REFERENCE ENERGY', GRAND_NEED[0]['d_energy']); psi4.set_variable('CURRENT CORRELATION ENERGY', finalenergy - GRAND_NEED[0]['d_energy']); psi4.set_variable('CURRENT ENERGY', finalenergy); return finalenergy. # Transform and validate basis sets from 'cc-pV[Q5]Z' into [cc-pVQZ, cc-pV5Z] and [4, 5]; [docs]def validate_bracketed_basis(basisstring):; r""""""Function to transform and validate basis sets for cbs(). A basis set with no; paired square brackets is passed through with zeta level 0 (e.g., '6-31+G(d,p)'; is returned as [6-31+G(d,p)] and [0]). A basis set with square brackets is; checked for sensible sequence and Dunning-ness and returned as separate basis; sets (e.g., 'cc-pV[Q5]Z' is returned as [cc-pVQZ, cc-pV5Z] and [4, 5]). Note; that this function has no communication with the basis set library to check; if the basis actually exists. Used by :py:func:`~wrappers.complete_basis_set`. """"""; ZETA = ['d', 't', 'q', '5', '6']; BSET = []; ZSET = []; if re.match(r'.*cc-.*\[.*\].*z$', basisstring, flags=re",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:90210,Energy Efficiency,ENERGY,ENERGY,90210,"d_wfn'],; '/', GRAND_NEED[10]['d_basis'], '', GRAND_NEED[10]['d_energy'] - GRAND_NEED[11]['d_energy'], GRAND_NEED[10]['d_scheme'].__name__); tables += """""" %6s %20s %1s %-27s %2s %16.8f %-s\n"""""" % ('total', 'CBS', '', '', '', finalenergy, ''); tables += table_delimit. #print tables; psi4.print_out(tables). # Restore molecule and options; #psi4.set_local_option('SCF', ""WFN"", user_wfn) # TODO refuses to set global option WFN - rejects SCF as option; psi4.set_global_option('BASIS', user_basis). psi4.set_global_option('WFN', user_wfn); if not b_user_wfn:; psi4.revoke_global_option_changed('WFN'). psi4.set_global_option('WRITER_FILE_LABEL', user_writer_file_label). psi4.set_variable('CBS REFERENCE ENERGY', GRAND_NEED[0]['d_energy']); psi4.set_variable('CBS CORRELATION ENERGY', finalenergy - GRAND_NEED[0]['d_energy']); psi4.set_variable('CBS TOTAL ENERGY', finalenergy); psi4.set_variable('CURRENT REFERENCE ENERGY', GRAND_NEED[0]['d_energy']); psi4.set_variable('CURRENT CORRELATION ENERGY', finalenergy - GRAND_NEED[0]['d_energy']); psi4.set_variable('CURRENT ENERGY', finalenergy); return finalenergy. # Transform and validate basis sets from 'cc-pV[Q5]Z' into [cc-pVQZ, cc-pV5Z] and [4, 5]; [docs]def validate_bracketed_basis(basisstring):; r""""""Function to transform and validate basis sets for cbs(). A basis set with no; paired square brackets is passed through with zeta level 0 (e.g., '6-31+G(d,p)'; is returned as [6-31+G(d,p)] and [0]). A basis set with square brackets is; checked for sensible sequence and Dunning-ness and returned as separate basis; sets (e.g., 'cc-pV[Q5]Z' is returned as [cc-pVQZ, cc-pV5Z] and [4, 5]). Note; that this function has no communication with the basis set library to check; if the basis actually exists. Used by :py:func:`~wrappers.complete_basis_set`. """"""; ZETA = ['d', 't', 'q', '5', '6']; BSET = []; ZSET = []; if re.match(r'.*cc-.*\[.*\].*z$', basisstring, flags=re.IGNORECASE):; basispattern = re.compile(r'^(.*)\[(.*)\](.*)$'); basisname = basis",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:90288,Energy Efficiency,ENERGY,ENERGY,90288,"AND_NEED[11]['d_energy'], GRAND_NEED[10]['d_scheme'].__name__); tables += """""" %6s %20s %1s %-27s %2s %16.8f %-s\n"""""" % ('total', 'CBS', '', '', '', finalenergy, ''); tables += table_delimit. #print tables; psi4.print_out(tables). # Restore molecule and options; #psi4.set_local_option('SCF', ""WFN"", user_wfn) # TODO refuses to set global option WFN - rejects SCF as option; psi4.set_global_option('BASIS', user_basis). psi4.set_global_option('WFN', user_wfn); if not b_user_wfn:; psi4.revoke_global_option_changed('WFN'). psi4.set_global_option('WRITER_FILE_LABEL', user_writer_file_label). psi4.set_variable('CBS REFERENCE ENERGY', GRAND_NEED[0]['d_energy']); psi4.set_variable('CBS CORRELATION ENERGY', finalenergy - GRAND_NEED[0]['d_energy']); psi4.set_variable('CBS TOTAL ENERGY', finalenergy); psi4.set_variable('CURRENT REFERENCE ENERGY', GRAND_NEED[0]['d_energy']); psi4.set_variable('CURRENT CORRELATION ENERGY', finalenergy - GRAND_NEED[0]['d_energy']); psi4.set_variable('CURRENT ENERGY', finalenergy); return finalenergy. # Transform and validate basis sets from 'cc-pV[Q5]Z' into [cc-pVQZ, cc-pV5Z] and [4, 5]; [docs]def validate_bracketed_basis(basisstring):; r""""""Function to transform and validate basis sets for cbs(). A basis set with no; paired square brackets is passed through with zeta level 0 (e.g., '6-31+G(d,p)'; is returned as [6-31+G(d,p)] and [0]). A basis set with square brackets is; checked for sensible sequence and Dunning-ness and returned as separate basis; sets (e.g., 'cc-pV[Q5]Z' is returned as [cc-pVQZ, cc-pV5Z] and [4, 5]). Note; that this function has no communication with the basis set library to check; if the basis actually exists. Used by :py:func:`~wrappers.complete_basis_set`. """"""; ZETA = ['d', 't', 'q', '5', '6']; BSET = []; ZSET = []; if re.match(r'.*cc-.*\[.*\].*z$', basisstring, flags=re.IGNORECASE):; basispattern = re.compile(r'^(.*)\[(.*)\](.*)$'); basisname = basispattern.match(basisstring); for b in basisname.group(2):; if b not in ZETA:; ",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:93211,Energy Efficiency,energy,energypiece,93211,"z' from array [cc-pvqz, cc-pv5z]). The; basis set array is extracted from the *f_basis* field of a *NEED* dictionary in; :py:func:`~wrappers.complete_basis_set`. Result is used to print a nicely; formatted basis set string in the results table. """"""; ZETA = {'d': 2, 't': 3, 'q': 4, '5': 5, '6': 6}; ZSET = [''] * len(ZETA); BSET = []. for lvl in needarray.items():; BSET.append(lvl[1]['f_basis']). if (len(BSET) == 1):; basisstring = BSET[0]; else:; indx = 0; while indx < len(BSET[0]):; if (BSET[0][indx] != BSET[1][indx]):; zetaindx = indx; indx += 1; for basis in BSET:; ZSET[ZETA[basis[zetaindx]] - 2] = basis[zetaindx]. pre = BSET[0][:zetaindx]; post = BSET[0][zetaindx + 1:]; basisstring = pre + '[' + ''.join(ZSET) + ']' + post. return basisstring. [docs]def highest_1(**largs):; r""""""Scheme for total or correlation energies with a single basis or the highest; zeta-level among an array of bases. Used by :py:func:`~wrappers.complete_basis_set`. .. math:: E_{total}^X = E_{total}^X. """"""; energypiece = 0.0; functionname = sys._getframe().f_code.co_name; f_fields = ['f_wfn', 'f_portion', 'f_basis', 'f_zeta', 'f_energy']; [mode, NEED, wfnname, BSET, ZSET] = validate_scheme_args(functionname, **largs). if (mode == 'requisition'):. # Impose restrictions on zeta sequence; if (len(ZSET) == 0):; raise ValidationError('Call to \'%s\' not valid with \'%s\' basis sets.' % (functionname, len(ZSET))). # Return array that logs the requisite jobs; if (wfnname == 'scf'):; portion = 'tot'; else:; portion = 'corl'; NEED = {'HI': dict(zip(f_fields, [wfnname, portion, BSET[len(ZSET) - 1], ZSET[len(ZSET) - 1], 0.0]))}. return NEED. elif (mode == 'evaluate'):. # Extract required energies and zeta integers from array; # Compute extrapolated energy; energypiece = NEED['HI']['f_energy']. # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += """"""\n ==> %s <==\n\n"""""" % (functionname); if (NEED['HI']['f_wfn'] == 'scf'):; cbsscheme += """""" HI-zeta (%s) Total Energy: %16.8f\n"""""" % (s",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:93956,Energy Efficiency,energy,energy,93956," + ']' + post. return basisstring. [docs]def highest_1(**largs):; r""""""Scheme for total or correlation energies with a single basis or the highest; zeta-level among an array of bases. Used by :py:func:`~wrappers.complete_basis_set`. .. math:: E_{total}^X = E_{total}^X. """"""; energypiece = 0.0; functionname = sys._getframe().f_code.co_name; f_fields = ['f_wfn', 'f_portion', 'f_basis', 'f_zeta', 'f_energy']; [mode, NEED, wfnname, BSET, ZSET] = validate_scheme_args(functionname, **largs). if (mode == 'requisition'):. # Impose restrictions on zeta sequence; if (len(ZSET) == 0):; raise ValidationError('Call to \'%s\' not valid with \'%s\' basis sets.' % (functionname, len(ZSET))). # Return array that logs the requisite jobs; if (wfnname == 'scf'):; portion = 'tot'; else:; portion = 'corl'; NEED = {'HI': dict(zip(f_fields, [wfnname, portion, BSET[len(ZSET) - 1], ZSET[len(ZSET) - 1], 0.0]))}. return NEED. elif (mode == 'evaluate'):. # Extract required energies and zeta integers from array; # Compute extrapolated energy; energypiece = NEED['HI']['f_energy']. # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += """"""\n ==> %s <==\n\n"""""" % (functionname); if (NEED['HI']['f_wfn'] == 'scf'):; cbsscheme += """""" HI-zeta (%s) Total Energy: %16.8f\n"""""" % (str(NEED['HI']['f_zeta']), energypiece); else:; cbsscheme += """""" HI-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(NEED['HI']['f_zeta']), energypiece); psi4.print_out(cbsscheme). return energypiece. # Solution equation in LaTeX: $E_{corl}^{\infty} = \frac{E_{corl}^{X} X^3 - E_{corl}^{X-1} (X-1)^3}{X^3 - (X-1)^3}$; # Solution equation in LaTeX: $\beta = \frac{E_{corl}^{X} - E_{corl}^{X-1}}{X^{-3} - (X-1)^{-3}}$; [docs]def corl_xtpl_helgaker_2(**largs):; r""""""Extrapolation scheme for correlation energies with two adjacent zeta-level bases.; Used by :py:func:`~wrappers.complete_basis_set`. .. math:: E_{corl}^X = E_{corl}^{\infty} + \beta X^{-3}. """"""; energypiece = 0.0; functionname = sys._getframe().f_code.co_name; ",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:93964,Energy Efficiency,energy,energypiece,93964," + ']' + post. return basisstring. [docs]def highest_1(**largs):; r""""""Scheme for total or correlation energies with a single basis or the highest; zeta-level among an array of bases. Used by :py:func:`~wrappers.complete_basis_set`. .. math:: E_{total}^X = E_{total}^X. """"""; energypiece = 0.0; functionname = sys._getframe().f_code.co_name; f_fields = ['f_wfn', 'f_portion', 'f_basis', 'f_zeta', 'f_energy']; [mode, NEED, wfnname, BSET, ZSET] = validate_scheme_args(functionname, **largs). if (mode == 'requisition'):. # Impose restrictions on zeta sequence; if (len(ZSET) == 0):; raise ValidationError('Call to \'%s\' not valid with \'%s\' basis sets.' % (functionname, len(ZSET))). # Return array that logs the requisite jobs; if (wfnname == 'scf'):; portion = 'tot'; else:; portion = 'corl'; NEED = {'HI': dict(zip(f_fields, [wfnname, portion, BSET[len(ZSET) - 1], ZSET[len(ZSET) - 1], 0.0]))}. return NEED. elif (mode == 'evaluate'):. # Extract required energies and zeta integers from array; # Compute extrapolated energy; energypiece = NEED['HI']['f_energy']. # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += """"""\n ==> %s <==\n\n"""""" % (functionname); if (NEED['HI']['f_wfn'] == 'scf'):; cbsscheme += """""" HI-zeta (%s) Total Energy: %16.8f\n"""""" % (str(NEED['HI']['f_zeta']), energypiece); else:; cbsscheme += """""" HI-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(NEED['HI']['f_zeta']), energypiece); psi4.print_out(cbsscheme). return energypiece. # Solution equation in LaTeX: $E_{corl}^{\infty} = \frac{E_{corl}^{X} X^3 - E_{corl}^{X-1} (X-1)^3}{X^3 - (X-1)^3}$; # Solution equation in LaTeX: $\beta = \frac{E_{corl}^{X} - E_{corl}^{X-1}}{X^{-3} - (X-1)^{-3}}$; [docs]def corl_xtpl_helgaker_2(**largs):; r""""""Extrapolation scheme for correlation energies with two adjacent zeta-level bases.; Used by :py:func:`~wrappers.complete_basis_set`. .. math:: E_{corl}^X = E_{corl}^{\infty} + \beta X^{-3}. """"""; energypiece = 0.0; functionname = sys._getframe().f_code.co_name; ",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:94192,Energy Efficiency,Energy,Energy,94192,"n array of bases. Used by :py:func:`~wrappers.complete_basis_set`. .. math:: E_{total}^X = E_{total}^X. """"""; energypiece = 0.0; functionname = sys._getframe().f_code.co_name; f_fields = ['f_wfn', 'f_portion', 'f_basis', 'f_zeta', 'f_energy']; [mode, NEED, wfnname, BSET, ZSET] = validate_scheme_args(functionname, **largs). if (mode == 'requisition'):. # Impose restrictions on zeta sequence; if (len(ZSET) == 0):; raise ValidationError('Call to \'%s\' not valid with \'%s\' basis sets.' % (functionname, len(ZSET))). # Return array that logs the requisite jobs; if (wfnname == 'scf'):; portion = 'tot'; else:; portion = 'corl'; NEED = {'HI': dict(zip(f_fields, [wfnname, portion, BSET[len(ZSET) - 1], ZSET[len(ZSET) - 1], 0.0]))}. return NEED. elif (mode == 'evaluate'):. # Extract required energies and zeta integers from array; # Compute extrapolated energy; energypiece = NEED['HI']['f_energy']. # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += """"""\n ==> %s <==\n\n"""""" % (functionname); if (NEED['HI']['f_wfn'] == 'scf'):; cbsscheme += """""" HI-zeta (%s) Total Energy: %16.8f\n"""""" % (str(NEED['HI']['f_zeta']), energypiece); else:; cbsscheme += """""" HI-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(NEED['HI']['f_zeta']), energypiece); psi4.print_out(cbsscheme). return energypiece. # Solution equation in LaTeX: $E_{corl}^{\infty} = \frac{E_{corl}^{X} X^3 - E_{corl}^{X-1} (X-1)^3}{X^3 - (X-1)^3}$; # Solution equation in LaTeX: $\beta = \frac{E_{corl}^{X} - E_{corl}^{X-1}}{X^{-3} - (X-1)^{-3}}$; [docs]def corl_xtpl_helgaker_2(**largs):; r""""""Extrapolation scheme for correlation energies with two adjacent zeta-level bases.; Used by :py:func:`~wrappers.complete_basis_set`. .. math:: E_{corl}^X = E_{corl}^{\infty} + \beta X^{-3}. """"""; energypiece = 0.0; functionname = sys._getframe().f_code.co_name; f_fields = ['f_wfn', 'f_portion', 'f_basis', 'f_zeta', 'f_energy']; [mode, NEED, wfnname, BSET, ZSET] = validate_scheme_args(functionname, **largs). if (mode == 'req",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:94242,Energy Efficiency,energy,energypiece,94242,".f_code.co_name; f_fields = ['f_wfn', 'f_portion', 'f_basis', 'f_zeta', 'f_energy']; [mode, NEED, wfnname, BSET, ZSET] = validate_scheme_args(functionname, **largs). if (mode == 'requisition'):. # Impose restrictions on zeta sequence; if (len(ZSET) == 0):; raise ValidationError('Call to \'%s\' not valid with \'%s\' basis sets.' % (functionname, len(ZSET))). # Return array that logs the requisite jobs; if (wfnname == 'scf'):; portion = 'tot'; else:; portion = 'corl'; NEED = {'HI': dict(zip(f_fields, [wfnname, portion, BSET[len(ZSET) - 1], ZSET[len(ZSET) - 1], 0.0]))}. return NEED. elif (mode == 'evaluate'):. # Extract required energies and zeta integers from array; # Compute extrapolated energy; energypiece = NEED['HI']['f_energy']. # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += """"""\n ==> %s <==\n\n"""""" % (functionname); if (NEED['HI']['f_wfn'] == 'scf'):; cbsscheme += """""" HI-zeta (%s) Total Energy: %16.8f\n"""""" % (str(NEED['HI']['f_zeta']), energypiece); else:; cbsscheme += """""" HI-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(NEED['HI']['f_zeta']), energypiece); psi4.print_out(cbsscheme). return energypiece. # Solution equation in LaTeX: $E_{corl}^{\infty} = \frac{E_{corl}^{X} X^3 - E_{corl}^{X-1} (X-1)^3}{X^3 - (X-1)^3}$; # Solution equation in LaTeX: $\beta = \frac{E_{corl}^{X} - E_{corl}^{X-1}}{X^{-3} - (X-1)^{-3}}$; [docs]def corl_xtpl_helgaker_2(**largs):; r""""""Extrapolation scheme for correlation energies with two adjacent zeta-level bases.; Used by :py:func:`~wrappers.complete_basis_set`. .. math:: E_{corl}^X = E_{corl}^{\infty} + \beta X^{-3}. """"""; energypiece = 0.0; functionname = sys._getframe().f_code.co_name; f_fields = ['f_wfn', 'f_portion', 'f_basis', 'f_zeta', 'f_energy']; [mode, NEED, wfnname, BSET, ZSET] = validate_scheme_args(functionname, **largs). if (mode == 'requisition'):. # Impose restrictions on zeta sequence; if (len(ZSET) != 2):; raise ValidationError('Call to \'%s\' not valid with \'%s\' basis sets.' % (functio",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:94305,Energy Efficiency,Energy,Energy,94305,".f_code.co_name; f_fields = ['f_wfn', 'f_portion', 'f_basis', 'f_zeta', 'f_energy']; [mode, NEED, wfnname, BSET, ZSET] = validate_scheme_args(functionname, **largs). if (mode == 'requisition'):. # Impose restrictions on zeta sequence; if (len(ZSET) == 0):; raise ValidationError('Call to \'%s\' not valid with \'%s\' basis sets.' % (functionname, len(ZSET))). # Return array that logs the requisite jobs; if (wfnname == 'scf'):; portion = 'tot'; else:; portion = 'corl'; NEED = {'HI': dict(zip(f_fields, [wfnname, portion, BSET[len(ZSET) - 1], ZSET[len(ZSET) - 1], 0.0]))}. return NEED. elif (mode == 'evaluate'):. # Extract required energies and zeta integers from array; # Compute extrapolated energy; energypiece = NEED['HI']['f_energy']. # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += """"""\n ==> %s <==\n\n"""""" % (functionname); if (NEED['HI']['f_wfn'] == 'scf'):; cbsscheme += """""" HI-zeta (%s) Total Energy: %16.8f\n"""""" % (str(NEED['HI']['f_zeta']), energypiece); else:; cbsscheme += """""" HI-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(NEED['HI']['f_zeta']), energypiece); psi4.print_out(cbsscheme). return energypiece. # Solution equation in LaTeX: $E_{corl}^{\infty} = \frac{E_{corl}^{X} X^3 - E_{corl}^{X-1} (X-1)^3}{X^3 - (X-1)^3}$; # Solution equation in LaTeX: $\beta = \frac{E_{corl}^{X} - E_{corl}^{X-1}}{X^{-3} - (X-1)^{-3}}$; [docs]def corl_xtpl_helgaker_2(**largs):; r""""""Extrapolation scheme for correlation energies with two adjacent zeta-level bases.; Used by :py:func:`~wrappers.complete_basis_set`. .. math:: E_{corl}^X = E_{corl}^{\infty} + \beta X^{-3}. """"""; energypiece = 0.0; functionname = sys._getframe().f_code.co_name; f_fields = ['f_wfn', 'f_portion', 'f_basis', 'f_zeta', 'f_energy']; [mode, NEED, wfnname, BSET, ZSET] = validate_scheme_args(functionname, **largs). if (mode == 'requisition'):. # Impose restrictions on zeta sequence; if (len(ZSET) != 2):; raise ValidationError('Call to \'%s\' not valid with \'%s\' basis sets.' % (functio",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:94355,Energy Efficiency,energy,energypiece,94355,"[mode, NEED, wfnname, BSET, ZSET] = validate_scheme_args(functionname, **largs). if (mode == 'requisition'):. # Impose restrictions on zeta sequence; if (len(ZSET) == 0):; raise ValidationError('Call to \'%s\' not valid with \'%s\' basis sets.' % (functionname, len(ZSET))). # Return array that logs the requisite jobs; if (wfnname == 'scf'):; portion = 'tot'; else:; portion = 'corl'; NEED = {'HI': dict(zip(f_fields, [wfnname, portion, BSET[len(ZSET) - 1], ZSET[len(ZSET) - 1], 0.0]))}. return NEED. elif (mode == 'evaluate'):. # Extract required energies and zeta integers from array; # Compute extrapolated energy; energypiece = NEED['HI']['f_energy']. # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += """"""\n ==> %s <==\n\n"""""" % (functionname); if (NEED['HI']['f_wfn'] == 'scf'):; cbsscheme += """""" HI-zeta (%s) Total Energy: %16.8f\n"""""" % (str(NEED['HI']['f_zeta']), energypiece); else:; cbsscheme += """""" HI-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(NEED['HI']['f_zeta']), energypiece); psi4.print_out(cbsscheme). return energypiece. # Solution equation in LaTeX: $E_{corl}^{\infty} = \frac{E_{corl}^{X} X^3 - E_{corl}^{X-1} (X-1)^3}{X^3 - (X-1)^3}$; # Solution equation in LaTeX: $\beta = \frac{E_{corl}^{X} - E_{corl}^{X-1}}{X^{-3} - (X-1)^{-3}}$; [docs]def corl_xtpl_helgaker_2(**largs):; r""""""Extrapolation scheme for correlation energies with two adjacent zeta-level bases.; Used by :py:func:`~wrappers.complete_basis_set`. .. math:: E_{corl}^X = E_{corl}^{\infty} + \beta X^{-3}. """"""; energypiece = 0.0; functionname = sys._getframe().f_code.co_name; f_fields = ['f_wfn', 'f_portion', 'f_basis', 'f_zeta', 'f_energy']; [mode, NEED, wfnname, BSET, ZSET] = validate_scheme_args(functionname, **largs). if (mode == 'requisition'):. # Impose restrictions on zeta sequence; if (len(ZSET) != 2):; raise ValidationError('Call to \'%s\' not valid with \'%s\' basis sets.' % (functionname, len(ZSET))). # Return array that logs the requisite jobs; NEED = {'HI': dict(z",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:94403,Energy Efficiency,energy,energypiece,94403,"ctionname, **largs). if (mode == 'requisition'):. # Impose restrictions on zeta sequence; if (len(ZSET) == 0):; raise ValidationError('Call to \'%s\' not valid with \'%s\' basis sets.' % (functionname, len(ZSET))). # Return array that logs the requisite jobs; if (wfnname == 'scf'):; portion = 'tot'; else:; portion = 'corl'; NEED = {'HI': dict(zip(f_fields, [wfnname, portion, BSET[len(ZSET) - 1], ZSET[len(ZSET) - 1], 0.0]))}. return NEED. elif (mode == 'evaluate'):. # Extract required energies and zeta integers from array; # Compute extrapolated energy; energypiece = NEED['HI']['f_energy']. # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += """"""\n ==> %s <==\n\n"""""" % (functionname); if (NEED['HI']['f_wfn'] == 'scf'):; cbsscheme += """""" HI-zeta (%s) Total Energy: %16.8f\n"""""" % (str(NEED['HI']['f_zeta']), energypiece); else:; cbsscheme += """""" HI-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(NEED['HI']['f_zeta']), energypiece); psi4.print_out(cbsscheme). return energypiece. # Solution equation in LaTeX: $E_{corl}^{\infty} = \frac{E_{corl}^{X} X^3 - E_{corl}^{X-1} (X-1)^3}{X^3 - (X-1)^3}$; # Solution equation in LaTeX: $\beta = \frac{E_{corl}^{X} - E_{corl}^{X-1}}{X^{-3} - (X-1)^{-3}}$; [docs]def corl_xtpl_helgaker_2(**largs):; r""""""Extrapolation scheme for correlation energies with two adjacent zeta-level bases.; Used by :py:func:`~wrappers.complete_basis_set`. .. math:: E_{corl}^X = E_{corl}^{\infty} + \beta X^{-3}. """"""; energypiece = 0.0; functionname = sys._getframe().f_code.co_name; f_fields = ['f_wfn', 'f_portion', 'f_basis', 'f_zeta', 'f_energy']; [mode, NEED, wfnname, BSET, ZSET] = validate_scheme_args(functionname, **largs). if (mode == 'requisition'):. # Impose restrictions on zeta sequence; if (len(ZSET) != 2):; raise ValidationError('Call to \'%s\' not valid with \'%s\' basis sets.' % (functionname, len(ZSET))). # Return array that logs the requisite jobs; NEED = {'HI': dict(zip(f_fields, [wfnname, 'corl', BSET[1], ZSET[1], 0.0])),; '",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:94872,Energy Efficiency,energy,energypiece,94872,"Extract required energies and zeta integers from array; # Compute extrapolated energy; energypiece = NEED['HI']['f_energy']. # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += """"""\n ==> %s <==\n\n"""""" % (functionname); if (NEED['HI']['f_wfn'] == 'scf'):; cbsscheme += """""" HI-zeta (%s) Total Energy: %16.8f\n"""""" % (str(NEED['HI']['f_zeta']), energypiece); else:; cbsscheme += """""" HI-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(NEED['HI']['f_zeta']), energypiece); psi4.print_out(cbsscheme). return energypiece. # Solution equation in LaTeX: $E_{corl}^{\infty} = \frac{E_{corl}^{X} X^3 - E_{corl}^{X-1} (X-1)^3}{X^3 - (X-1)^3}$; # Solution equation in LaTeX: $\beta = \frac{E_{corl}^{X} - E_{corl}^{X-1}}{X^{-3} - (X-1)^{-3}}$; [docs]def corl_xtpl_helgaker_2(**largs):; r""""""Extrapolation scheme for correlation energies with two adjacent zeta-level bases.; Used by :py:func:`~wrappers.complete_basis_set`. .. math:: E_{corl}^X = E_{corl}^{\infty} + \beta X^{-3}. """"""; energypiece = 0.0; functionname = sys._getframe().f_code.co_name; f_fields = ['f_wfn', 'f_portion', 'f_basis', 'f_zeta', 'f_energy']; [mode, NEED, wfnname, BSET, ZSET] = validate_scheme_args(functionname, **largs). if (mode == 'requisition'):. # Impose restrictions on zeta sequence; if (len(ZSET) != 2):; raise ValidationError('Call to \'%s\' not valid with \'%s\' basis sets.' % (functionname, len(ZSET))). # Return array that logs the requisite jobs; NEED = {'HI': dict(zip(f_fields, [wfnname, 'corl', BSET[1], ZSET[1], 0.0])),; 'LO': dict(zip(f_fields, [wfnname, 'corl', BSET[0], ZSET[0], 0.0]))}. return NEED. elif (mode == 'evaluate'):. # Extract required energies and zeta integers from array; eHI = NEED['HI']['f_energy']; zHI = NEED['HI']['f_zeta']; eLO = NEED['LO']['f_energy']; zLO = NEED['LO']['f_zeta']. # Compute extrapolated energy; energypiece = (eHI * zHI ** 3 - eLO * zLO ** 3) / (zHI ** 3 - zLO ** 3); beta = (eHI - eLO) / (zHI ** (-3) - zLO ** (-3)). # Output string with extrapolation",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:95712,Energy Efficiency,energy,energy,95712," by :py:func:`~wrappers.complete_basis_set`. .. math:: E_{corl}^X = E_{corl}^{\infty} + \beta X^{-3}. """"""; energypiece = 0.0; functionname = sys._getframe().f_code.co_name; f_fields = ['f_wfn', 'f_portion', 'f_basis', 'f_zeta', 'f_energy']; [mode, NEED, wfnname, BSET, ZSET] = validate_scheme_args(functionname, **largs). if (mode == 'requisition'):. # Impose restrictions on zeta sequence; if (len(ZSET) != 2):; raise ValidationError('Call to \'%s\' not valid with \'%s\' basis sets.' % (functionname, len(ZSET))). # Return array that logs the requisite jobs; NEED = {'HI': dict(zip(f_fields, [wfnname, 'corl', BSET[1], ZSET[1], 0.0])),; 'LO': dict(zip(f_fields, [wfnname, 'corl', BSET[0], ZSET[0], 0.0]))}. return NEED. elif (mode == 'evaluate'):. # Extract required energies and zeta integers from array; eHI = NEED['HI']['f_energy']; zHI = NEED['HI']['f_zeta']; eLO = NEED['LO']['f_energy']; zLO = NEED['LO']['f_zeta']. # Compute extrapolated energy; energypiece = (eHI * zHI ** 3 - eLO * zLO ** 3) / (zHI ** 3 - zLO ** 3); beta = (eHI - eLO) / (zHI ** (-3) - zLO ** (-3)). # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += """"""\n ==> %s <==\n\n"""""" % (functionname); cbsscheme += """""" LO-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zLO), eLO); cbsscheme += """""" HI-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zHI), eHI); cbsscheme += """""" Extrapolated Correlation Energy: %16.8f\n"""""" % (energypiece); cbsscheme += """""" Beta (coefficient) Value: %16.8f\n"""""" % (beta); psi4.print_out(cbsscheme). return energypiece. [docs]def scf_xtpl_helgaker_3(**largs):; r""""""Extrapolation scheme for reference energies with three adjacent zeta-level bases.; Used by :py:func:`~wrappers.complete_basis_set`. .. math:: E_{total}^X = E_{total}^{\infty} + \beta e^{-\alpha X}. """"""; energypiece = 0.0; functionname = sys._getframe().f_code.co_name; f_fields = ['f_wfn', 'f_portion', 'f_basis', 'f_zeta', 'f_energy']; [mode, NEED, wfnname, BSET, ZSET] = validate_scheme_args(functionname",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:95720,Energy Efficiency,energy,energypiece,95720," by :py:func:`~wrappers.complete_basis_set`. .. math:: E_{corl}^X = E_{corl}^{\infty} + \beta X^{-3}. """"""; energypiece = 0.0; functionname = sys._getframe().f_code.co_name; f_fields = ['f_wfn', 'f_portion', 'f_basis', 'f_zeta', 'f_energy']; [mode, NEED, wfnname, BSET, ZSET] = validate_scheme_args(functionname, **largs). if (mode == 'requisition'):. # Impose restrictions on zeta sequence; if (len(ZSET) != 2):; raise ValidationError('Call to \'%s\' not valid with \'%s\' basis sets.' % (functionname, len(ZSET))). # Return array that logs the requisite jobs; NEED = {'HI': dict(zip(f_fields, [wfnname, 'corl', BSET[1], ZSET[1], 0.0])),; 'LO': dict(zip(f_fields, [wfnname, 'corl', BSET[0], ZSET[0], 0.0]))}. return NEED. elif (mode == 'evaluate'):. # Extract required energies and zeta integers from array; eHI = NEED['HI']['f_energy']; zHI = NEED['HI']['f_zeta']; eLO = NEED['LO']['f_energy']; zLO = NEED['LO']['f_zeta']. # Compute extrapolated energy; energypiece = (eHI * zHI ** 3 - eLO * zLO ** 3) / (zHI ** 3 - zLO ** 3); beta = (eHI - eLO) / (zHI ** (-3) - zLO ** (-3)). # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += """"""\n ==> %s <==\n\n"""""" % (functionname); cbsscheme += """""" LO-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zLO), eLO); cbsscheme += """""" HI-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zHI), eHI); cbsscheme += """""" Extrapolated Correlation Energy: %16.8f\n"""""" % (energypiece); cbsscheme += """""" Beta (coefficient) Value: %16.8f\n"""""" % (beta); psi4.print_out(cbsscheme). return energypiece. [docs]def scf_xtpl_helgaker_3(**largs):; r""""""Extrapolation scheme for reference energies with three adjacent zeta-level bases.; Used by :py:func:`~wrappers.complete_basis_set`. .. math:: E_{total}^X = E_{total}^{\infty} + \beta e^{-\alpha X}. """"""; energypiece = 0.0; functionname = sys._getframe().f_code.co_name; f_fields = ['f_wfn', 'f_portion', 'f_basis', 'f_zeta', 'f_energy']; [mode, NEED, wfnname, BSET, ZSET] = validate_scheme_args(functionname",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:96003,Energy Efficiency,Energy,Energy,96003,".co_name; f_fields = ['f_wfn', 'f_portion', 'f_basis', 'f_zeta', 'f_energy']; [mode, NEED, wfnname, BSET, ZSET] = validate_scheme_args(functionname, **largs). if (mode == 'requisition'):. # Impose restrictions on zeta sequence; if (len(ZSET) != 2):; raise ValidationError('Call to \'%s\' not valid with \'%s\' basis sets.' % (functionname, len(ZSET))). # Return array that logs the requisite jobs; NEED = {'HI': dict(zip(f_fields, [wfnname, 'corl', BSET[1], ZSET[1], 0.0])),; 'LO': dict(zip(f_fields, [wfnname, 'corl', BSET[0], ZSET[0], 0.0]))}. return NEED. elif (mode == 'evaluate'):. # Extract required energies and zeta integers from array; eHI = NEED['HI']['f_energy']; zHI = NEED['HI']['f_zeta']; eLO = NEED['LO']['f_energy']; zLO = NEED['LO']['f_zeta']. # Compute extrapolated energy; energypiece = (eHI * zHI ** 3 - eLO * zLO ** 3) / (zHI ** 3 - zLO ** 3); beta = (eHI - eLO) / (zHI ** (-3) - zLO ** (-3)). # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += """"""\n ==> %s <==\n\n"""""" % (functionname); cbsscheme += """""" LO-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zLO), eLO); cbsscheme += """""" HI-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zHI), eHI); cbsscheme += """""" Extrapolated Correlation Energy: %16.8f\n"""""" % (energypiece); cbsscheme += """""" Beta (coefficient) Value: %16.8f\n"""""" % (beta); psi4.print_out(cbsscheme). return energypiece. [docs]def scf_xtpl_helgaker_3(**largs):; r""""""Extrapolation scheme for reference energies with three adjacent zeta-level bases.; Used by :py:func:`~wrappers.complete_basis_set`. .. math:: E_{total}^X = E_{total}^{\infty} + \beta e^{-\alpha X}. """"""; energypiece = 0.0; functionname = sys._getframe().f_code.co_name; f_fields = ['f_wfn', 'f_portion', 'f_basis', 'f_zeta', 'f_energy']; [mode, NEED, wfnname, BSET, ZSET] = validate_scheme_args(functionname, **largs). if (mode == 'requisition'):. # Impose restrictions on zeta sequence; if (len(ZSET) != 3):; raise ValidationError('Call to \'%s\' not valid with \'%s\' b",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:96084,Energy Efficiency,Energy,Energy,96084,"me_args(functionname, **largs). if (mode == 'requisition'):. # Impose restrictions on zeta sequence; if (len(ZSET) != 2):; raise ValidationError('Call to \'%s\' not valid with \'%s\' basis sets.' % (functionname, len(ZSET))). # Return array that logs the requisite jobs; NEED = {'HI': dict(zip(f_fields, [wfnname, 'corl', BSET[1], ZSET[1], 0.0])),; 'LO': dict(zip(f_fields, [wfnname, 'corl', BSET[0], ZSET[0], 0.0]))}. return NEED. elif (mode == 'evaluate'):. # Extract required energies and zeta integers from array; eHI = NEED['HI']['f_energy']; zHI = NEED['HI']['f_zeta']; eLO = NEED['LO']['f_energy']; zLO = NEED['LO']['f_zeta']. # Compute extrapolated energy; energypiece = (eHI * zHI ** 3 - eLO * zLO ** 3) / (zHI ** 3 - zLO ** 3); beta = (eHI - eLO) / (zHI ** (-3) - zLO ** (-3)). # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += """"""\n ==> %s <==\n\n"""""" % (functionname); cbsscheme += """""" LO-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zLO), eLO); cbsscheme += """""" HI-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zHI), eHI); cbsscheme += """""" Extrapolated Correlation Energy: %16.8f\n"""""" % (energypiece); cbsscheme += """""" Beta (coefficient) Value: %16.8f\n"""""" % (beta); psi4.print_out(cbsscheme). return energypiece. [docs]def scf_xtpl_helgaker_3(**largs):; r""""""Extrapolation scheme for reference energies with three adjacent zeta-level bases.; Used by :py:func:`~wrappers.complete_basis_set`. .. math:: E_{total}^X = E_{total}^{\infty} + \beta e^{-\alpha X}. """"""; energypiece = 0.0; functionname = sys._getframe().f_code.co_name; f_fields = ['f_wfn', 'f_portion', 'f_basis', 'f_zeta', 'f_energy']; [mode, NEED, wfnname, BSET, ZSET] = validate_scheme_args(functionname, **largs). if (mode == 'requisition'):. # Impose restrictions on zeta sequence; if (len(ZSET) != 3):; raise ValidationError('Call to \'%s\' not valid with \'%s\' basis sets.' % (functionname, len(ZSET))). # Return array that logs the requisite jobs; NEED = {'HI': dict(zip(f_fields, [wfnnam",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:96165,Energy Efficiency,Energy,Energy,96165,"s on zeta sequence; if (len(ZSET) != 2):; raise ValidationError('Call to \'%s\' not valid with \'%s\' basis sets.' % (functionname, len(ZSET))). # Return array that logs the requisite jobs; NEED = {'HI': dict(zip(f_fields, [wfnname, 'corl', BSET[1], ZSET[1], 0.0])),; 'LO': dict(zip(f_fields, [wfnname, 'corl', BSET[0], ZSET[0], 0.0]))}. return NEED. elif (mode == 'evaluate'):. # Extract required energies and zeta integers from array; eHI = NEED['HI']['f_energy']; zHI = NEED['HI']['f_zeta']; eLO = NEED['LO']['f_energy']; zLO = NEED['LO']['f_zeta']. # Compute extrapolated energy; energypiece = (eHI * zHI ** 3 - eLO * zLO ** 3) / (zHI ** 3 - zLO ** 3); beta = (eHI - eLO) / (zHI ** (-3) - zLO ** (-3)). # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += """"""\n ==> %s <==\n\n"""""" % (functionname); cbsscheme += """""" LO-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zLO), eLO); cbsscheme += """""" HI-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zHI), eHI); cbsscheme += """""" Extrapolated Correlation Energy: %16.8f\n"""""" % (energypiece); cbsscheme += """""" Beta (coefficient) Value: %16.8f\n"""""" % (beta); psi4.print_out(cbsscheme). return energypiece. [docs]def scf_xtpl_helgaker_3(**largs):; r""""""Extrapolation scheme for reference energies with three adjacent zeta-level bases.; Used by :py:func:`~wrappers.complete_basis_set`. .. math:: E_{total}^X = E_{total}^{\infty} + \beta e^{-\alpha X}. """"""; energypiece = 0.0; functionname = sys._getframe().f_code.co_name; f_fields = ['f_wfn', 'f_portion', 'f_basis', 'f_zeta', 'f_energy']; [mode, NEED, wfnname, BSET, ZSET] = validate_scheme_args(functionname, **largs). if (mode == 'requisition'):. # Impose restrictions on zeta sequence; if (len(ZSET) != 3):; raise ValidationError('Call to \'%s\' not valid with \'%s\' basis sets.' % (functionname, len(ZSET))). # Return array that logs the requisite jobs; NEED = {'HI': dict(zip(f_fields, [wfnname, 'tot', BSET[2], ZSET[2], 0.0])),; 'MD': dict(zip(f_fields, [wfnname, 'tot', BS",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:96188,Energy Efficiency,energy,energypiece,96188,"\' not valid with \'%s\' basis sets.' % (functionname, len(ZSET))). # Return array that logs the requisite jobs; NEED = {'HI': dict(zip(f_fields, [wfnname, 'corl', BSET[1], ZSET[1], 0.0])),; 'LO': dict(zip(f_fields, [wfnname, 'corl', BSET[0], ZSET[0], 0.0]))}. return NEED. elif (mode == 'evaluate'):. # Extract required energies and zeta integers from array; eHI = NEED['HI']['f_energy']; zHI = NEED['HI']['f_zeta']; eLO = NEED['LO']['f_energy']; zLO = NEED['LO']['f_zeta']. # Compute extrapolated energy; energypiece = (eHI * zHI ** 3 - eLO * zLO ** 3) / (zHI ** 3 - zLO ** 3); beta = (eHI - eLO) / (zHI ** (-3) - zLO ** (-3)). # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += """"""\n ==> %s <==\n\n"""""" % (functionname); cbsscheme += """""" LO-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zLO), eLO); cbsscheme += """""" HI-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zHI), eHI); cbsscheme += """""" Extrapolated Correlation Energy: %16.8f\n"""""" % (energypiece); cbsscheme += """""" Beta (coefficient) Value: %16.8f\n"""""" % (beta); psi4.print_out(cbsscheme). return energypiece. [docs]def scf_xtpl_helgaker_3(**largs):; r""""""Extrapolation scheme for reference energies with three adjacent zeta-level bases.; Used by :py:func:`~wrappers.complete_basis_set`. .. math:: E_{total}^X = E_{total}^{\infty} + \beta e^{-\alpha X}. """"""; energypiece = 0.0; functionname = sys._getframe().f_code.co_name; f_fields = ['f_wfn', 'f_portion', 'f_basis', 'f_zeta', 'f_energy']; [mode, NEED, wfnname, BSET, ZSET] = validate_scheme_args(functionname, **largs). if (mode == 'requisition'):. # Impose restrictions on zeta sequence; if (len(ZSET) != 3):; raise ValidationError('Call to \'%s\' not valid with \'%s\' basis sets.' % (functionname, len(ZSET))). # Return array that logs the requisite jobs; NEED = {'HI': dict(zip(f_fields, [wfnname, 'tot', BSET[2], ZSET[2], 0.0])),; 'MD': dict(zip(f_fields, [wfnname, 'tot', BSET[1], ZSET[1], 0.0])),; 'LO': dict(zip(f_fields, [wfnname, 'tot', BSET[0], ",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:96301,Energy Efficiency,energy,energypiece,96301,"gs the requisite jobs; NEED = {'HI': dict(zip(f_fields, [wfnname, 'corl', BSET[1], ZSET[1], 0.0])),; 'LO': dict(zip(f_fields, [wfnname, 'corl', BSET[0], ZSET[0], 0.0]))}. return NEED. elif (mode == 'evaluate'):. # Extract required energies and zeta integers from array; eHI = NEED['HI']['f_energy']; zHI = NEED['HI']['f_zeta']; eLO = NEED['LO']['f_energy']; zLO = NEED['LO']['f_zeta']. # Compute extrapolated energy; energypiece = (eHI * zHI ** 3 - eLO * zLO ** 3) / (zHI ** 3 - zLO ** 3); beta = (eHI - eLO) / (zHI ** (-3) - zLO ** (-3)). # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += """"""\n ==> %s <==\n\n"""""" % (functionname); cbsscheme += """""" LO-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zLO), eLO); cbsscheme += """""" HI-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zHI), eHI); cbsscheme += """""" Extrapolated Correlation Energy: %16.8f\n"""""" % (energypiece); cbsscheme += """""" Beta (coefficient) Value: %16.8f\n"""""" % (beta); psi4.print_out(cbsscheme). return energypiece. [docs]def scf_xtpl_helgaker_3(**largs):; r""""""Extrapolation scheme for reference energies with three adjacent zeta-level bases.; Used by :py:func:`~wrappers.complete_basis_set`. .. math:: E_{total}^X = E_{total}^{\infty} + \beta e^{-\alpha X}. """"""; energypiece = 0.0; functionname = sys._getframe().f_code.co_name; f_fields = ['f_wfn', 'f_portion', 'f_basis', 'f_zeta', 'f_energy']; [mode, NEED, wfnname, BSET, ZSET] = validate_scheme_args(functionname, **largs). if (mode == 'requisition'):. # Impose restrictions on zeta sequence; if (len(ZSET) != 3):; raise ValidationError('Call to \'%s\' not valid with \'%s\' basis sets.' % (functionname, len(ZSET))). # Return array that logs the requisite jobs; NEED = {'HI': dict(zip(f_fields, [wfnname, 'tot', BSET[2], ZSET[2], 0.0])),; 'MD': dict(zip(f_fields, [wfnname, 'tot', BSET[1], ZSET[1], 0.0])),; 'LO': dict(zip(f_fields, [wfnname, 'tot', BSET[0], ZSET[0], 0.0]))}. return NEED. elif (mode == 'evaluate'):. # Extract required energies and",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:96562,Energy Efficiency,energy,energypiece,96562,"rray; eHI = NEED['HI']['f_energy']; zHI = NEED['HI']['f_zeta']; eLO = NEED['LO']['f_energy']; zLO = NEED['LO']['f_zeta']. # Compute extrapolated energy; energypiece = (eHI * zHI ** 3 - eLO * zLO ** 3) / (zHI ** 3 - zLO ** 3); beta = (eHI - eLO) / (zHI ** (-3) - zLO ** (-3)). # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += """"""\n ==> %s <==\n\n"""""" % (functionname); cbsscheme += """""" LO-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zLO), eLO); cbsscheme += """""" HI-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zHI), eHI); cbsscheme += """""" Extrapolated Correlation Energy: %16.8f\n"""""" % (energypiece); cbsscheme += """""" Beta (coefficient) Value: %16.8f\n"""""" % (beta); psi4.print_out(cbsscheme). return energypiece. [docs]def scf_xtpl_helgaker_3(**largs):; r""""""Extrapolation scheme for reference energies with three adjacent zeta-level bases.; Used by :py:func:`~wrappers.complete_basis_set`. .. math:: E_{total}^X = E_{total}^{\infty} + \beta e^{-\alpha X}. """"""; energypiece = 0.0; functionname = sys._getframe().f_code.co_name; f_fields = ['f_wfn', 'f_portion', 'f_basis', 'f_zeta', 'f_energy']; [mode, NEED, wfnname, BSET, ZSET] = validate_scheme_args(functionname, **largs). if (mode == 'requisition'):. # Impose restrictions on zeta sequence; if (len(ZSET) != 3):; raise ValidationError('Call to \'%s\' not valid with \'%s\' basis sets.' % (functionname, len(ZSET))). # Return array that logs the requisite jobs; NEED = {'HI': dict(zip(f_fields, [wfnname, 'tot', BSET[2], ZSET[2], 0.0])),; 'MD': dict(zip(f_fields, [wfnname, 'tot', BSET[1], ZSET[1], 0.0])),; 'LO': dict(zip(f_fields, [wfnname, 'tot', BSET[0], ZSET[0], 0.0]))}. return NEED. elif (mode == 'evaluate'):. # Extract required energies and zeta integers from array; eHI = NEED['HI']['f_energy']; eMD = NEED['MD']['f_energy']; eLO = NEED['LO']['f_energy']; zHI = NEED['HI']['f_zeta']; zMD = NEED['MD']['f_zeta']; zLO = NEED['LO']['f_zeta']. # Compute extrapolated energy; ratio = (eHI - eMD) / (eMD - eLO",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:97527,Energy Efficiency,energy,energy,97527,"-\alpha X}. """"""; energypiece = 0.0; functionname = sys._getframe().f_code.co_name; f_fields = ['f_wfn', 'f_portion', 'f_basis', 'f_zeta', 'f_energy']; [mode, NEED, wfnname, BSET, ZSET] = validate_scheme_args(functionname, **largs). if (mode == 'requisition'):. # Impose restrictions on zeta sequence; if (len(ZSET) != 3):; raise ValidationError('Call to \'%s\' not valid with \'%s\' basis sets.' % (functionname, len(ZSET))). # Return array that logs the requisite jobs; NEED = {'HI': dict(zip(f_fields, [wfnname, 'tot', BSET[2], ZSET[2], 0.0])),; 'MD': dict(zip(f_fields, [wfnname, 'tot', BSET[1], ZSET[1], 0.0])),; 'LO': dict(zip(f_fields, [wfnname, 'tot', BSET[0], ZSET[0], 0.0]))}. return NEED. elif (mode == 'evaluate'):. # Extract required energies and zeta integers from array; eHI = NEED['HI']['f_energy']; eMD = NEED['MD']['f_energy']; eLO = NEED['LO']['f_energy']; zHI = NEED['HI']['f_zeta']; zMD = NEED['MD']['f_zeta']; zLO = NEED['LO']['f_zeta']. # Compute extrapolated energy; ratio = (eHI - eMD) / (eMD - eLO); alpha = -1 * math.log(ratio); beta = (eHI - eMD) / (math.exp(-1 * alpha * zMD) * (ratio - 1)); energypiece = eHI - beta * math.exp(-1 * alpha * zHI). # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += """"""\n ==> %s <==\n\n"""""" % (functionname); cbsscheme += """""" LO-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zLO), eLO); cbsscheme += """""" MD-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zMD), eMD); cbsscheme += """""" HI-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zHI), eHI); cbsscheme += """""" Extrapolated Correlation Energy: %16.8f\n"""""" % (energypiece); cbsscheme += """""" Alpha (exponent) Value: %16.8f\n"""""" % (alpha); cbsscheme += """""" Beta (coefficient) Value: %16.8f\n"""""" % (beta); psi4.print_out(cbsscheme). return energypiece. [docs]def scf_xtpl_helgaker_2(**largs):; r""""""Extrapolation scheme for reference energies with two adjacent zeta-level bases.; Used by :py:func:`~wrappers.complete_basis_set`. .. math:: E_{total}^X = E_{total}^{",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:97665,Energy Efficiency,energy,energypiece,97665,"'f_basis', 'f_zeta', 'f_energy']; [mode, NEED, wfnname, BSET, ZSET] = validate_scheme_args(functionname, **largs). if (mode == 'requisition'):. # Impose restrictions on zeta sequence; if (len(ZSET) != 3):; raise ValidationError('Call to \'%s\' not valid with \'%s\' basis sets.' % (functionname, len(ZSET))). # Return array that logs the requisite jobs; NEED = {'HI': dict(zip(f_fields, [wfnname, 'tot', BSET[2], ZSET[2], 0.0])),; 'MD': dict(zip(f_fields, [wfnname, 'tot', BSET[1], ZSET[1], 0.0])),; 'LO': dict(zip(f_fields, [wfnname, 'tot', BSET[0], ZSET[0], 0.0]))}. return NEED. elif (mode == 'evaluate'):. # Extract required energies and zeta integers from array; eHI = NEED['HI']['f_energy']; eMD = NEED['MD']['f_energy']; eLO = NEED['LO']['f_energy']; zHI = NEED['HI']['f_zeta']; zMD = NEED['MD']['f_zeta']; zLO = NEED['LO']['f_zeta']. # Compute extrapolated energy; ratio = (eHI - eMD) / (eMD - eLO); alpha = -1 * math.log(ratio); beta = (eHI - eMD) / (math.exp(-1 * alpha * zMD) * (ratio - 1)); energypiece = eHI - beta * math.exp(-1 * alpha * zHI). # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += """"""\n ==> %s <==\n\n"""""" % (functionname); cbsscheme += """""" LO-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zLO), eLO); cbsscheme += """""" MD-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zMD), eMD); cbsscheme += """""" HI-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zHI), eHI); cbsscheme += """""" Extrapolated Correlation Energy: %16.8f\n"""""" % (energypiece); cbsscheme += """""" Alpha (exponent) Value: %16.8f\n"""""" % (alpha); cbsscheme += """""" Beta (coefficient) Value: %16.8f\n"""""" % (beta); psi4.print_out(cbsscheme). return energypiece. [docs]def scf_xtpl_helgaker_2(**largs):; r""""""Extrapolation scheme for reference energies with two adjacent zeta-level bases.; Used by :py:func:`~wrappers.complete_basis_set`. .. math:: E_{total}^X = E_{total}^{\infty} + \beta e^{-\alpha X}, \alpha = 1.63. """"""; energypiece = 0.0; functionname = sys._getframe().f_code.co_name;",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:97880,Energy Efficiency,Energy,Energy,97880," # Impose restrictions on zeta sequence; if (len(ZSET) != 3):; raise ValidationError('Call to \'%s\' not valid with \'%s\' basis sets.' % (functionname, len(ZSET))). # Return array that logs the requisite jobs; NEED = {'HI': dict(zip(f_fields, [wfnname, 'tot', BSET[2], ZSET[2], 0.0])),; 'MD': dict(zip(f_fields, [wfnname, 'tot', BSET[1], ZSET[1], 0.0])),; 'LO': dict(zip(f_fields, [wfnname, 'tot', BSET[0], ZSET[0], 0.0]))}. return NEED. elif (mode == 'evaluate'):. # Extract required energies and zeta integers from array; eHI = NEED['HI']['f_energy']; eMD = NEED['MD']['f_energy']; eLO = NEED['LO']['f_energy']; zHI = NEED['HI']['f_zeta']; zMD = NEED['MD']['f_zeta']; zLO = NEED['LO']['f_zeta']. # Compute extrapolated energy; ratio = (eHI - eMD) / (eMD - eLO); alpha = -1 * math.log(ratio); beta = (eHI - eMD) / (math.exp(-1 * alpha * zMD) * (ratio - 1)); energypiece = eHI - beta * math.exp(-1 * alpha * zHI). # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += """"""\n ==> %s <==\n\n"""""" % (functionname); cbsscheme += """""" LO-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zLO), eLO); cbsscheme += """""" MD-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zMD), eMD); cbsscheme += """""" HI-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zHI), eHI); cbsscheme += """""" Extrapolated Correlation Energy: %16.8f\n"""""" % (energypiece); cbsscheme += """""" Alpha (exponent) Value: %16.8f\n"""""" % (alpha); cbsscheme += """""" Beta (coefficient) Value: %16.8f\n"""""" % (beta); psi4.print_out(cbsscheme). return energypiece. [docs]def scf_xtpl_helgaker_2(**largs):; r""""""Extrapolation scheme for reference energies with two adjacent zeta-level bases.; Used by :py:func:`~wrappers.complete_basis_set`. .. math:: E_{total}^X = E_{total}^{\infty} + \beta e^{-\alpha X}, \alpha = 1.63. """"""; energypiece = 0.0; functionname = sys._getframe().f_code.co_name; f_fields = ['f_wfn', 'f_portion', 'f_basis', 'f_zeta', 'f_energy']; [mode, NEED, wfnname, BSET, ZSET] = validate_scheme_args(functionname, **la",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:97961,Energy Efficiency,Energy,Energy,97961,"s sets.' % (functionname, len(ZSET))). # Return array that logs the requisite jobs; NEED = {'HI': dict(zip(f_fields, [wfnname, 'tot', BSET[2], ZSET[2], 0.0])),; 'MD': dict(zip(f_fields, [wfnname, 'tot', BSET[1], ZSET[1], 0.0])),; 'LO': dict(zip(f_fields, [wfnname, 'tot', BSET[0], ZSET[0], 0.0]))}. return NEED. elif (mode == 'evaluate'):. # Extract required energies and zeta integers from array; eHI = NEED['HI']['f_energy']; eMD = NEED['MD']['f_energy']; eLO = NEED['LO']['f_energy']; zHI = NEED['HI']['f_zeta']; zMD = NEED['MD']['f_zeta']; zLO = NEED['LO']['f_zeta']. # Compute extrapolated energy; ratio = (eHI - eMD) / (eMD - eLO); alpha = -1 * math.log(ratio); beta = (eHI - eMD) / (math.exp(-1 * alpha * zMD) * (ratio - 1)); energypiece = eHI - beta * math.exp(-1 * alpha * zHI). # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += """"""\n ==> %s <==\n\n"""""" % (functionname); cbsscheme += """""" LO-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zLO), eLO); cbsscheme += """""" MD-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zMD), eMD); cbsscheme += """""" HI-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zHI), eHI); cbsscheme += """""" Extrapolated Correlation Energy: %16.8f\n"""""" % (energypiece); cbsscheme += """""" Alpha (exponent) Value: %16.8f\n"""""" % (alpha); cbsscheme += """""" Beta (coefficient) Value: %16.8f\n"""""" % (beta); psi4.print_out(cbsscheme). return energypiece. [docs]def scf_xtpl_helgaker_2(**largs):; r""""""Extrapolation scheme for reference energies with two adjacent zeta-level bases.; Used by :py:func:`~wrappers.complete_basis_set`. .. math:: E_{total}^X = E_{total}^{\infty} + \beta e^{-\alpha X}, \alpha = 1.63. """"""; energypiece = 0.0; functionname = sys._getframe().f_code.co_name; f_fields = ['f_wfn', 'f_portion', 'f_basis', 'f_zeta', 'f_energy']; [mode, NEED, wfnname, BSET, ZSET] = validate_scheme_args(functionname, **largs). if (mode == 'requisition'):. # Impose restrictions on zeta sequence; if (len(ZSET) != 2):; raise ValidationError('Call to",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:98042,Energy Efficiency,Energy,Energy,98042,"s; NEED = {'HI': dict(zip(f_fields, [wfnname, 'tot', BSET[2], ZSET[2], 0.0])),; 'MD': dict(zip(f_fields, [wfnname, 'tot', BSET[1], ZSET[1], 0.0])),; 'LO': dict(zip(f_fields, [wfnname, 'tot', BSET[0], ZSET[0], 0.0]))}. return NEED. elif (mode == 'evaluate'):. # Extract required energies and zeta integers from array; eHI = NEED['HI']['f_energy']; eMD = NEED['MD']['f_energy']; eLO = NEED['LO']['f_energy']; zHI = NEED['HI']['f_zeta']; zMD = NEED['MD']['f_zeta']; zLO = NEED['LO']['f_zeta']. # Compute extrapolated energy; ratio = (eHI - eMD) / (eMD - eLO); alpha = -1 * math.log(ratio); beta = (eHI - eMD) / (math.exp(-1 * alpha * zMD) * (ratio - 1)); energypiece = eHI - beta * math.exp(-1 * alpha * zHI). # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += """"""\n ==> %s <==\n\n"""""" % (functionname); cbsscheme += """""" LO-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zLO), eLO); cbsscheme += """""" MD-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zMD), eMD); cbsscheme += """""" HI-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zHI), eHI); cbsscheme += """""" Extrapolated Correlation Energy: %16.8f\n"""""" % (energypiece); cbsscheme += """""" Alpha (exponent) Value: %16.8f\n"""""" % (alpha); cbsscheme += """""" Beta (coefficient) Value: %16.8f\n"""""" % (beta); psi4.print_out(cbsscheme). return energypiece. [docs]def scf_xtpl_helgaker_2(**largs):; r""""""Extrapolation scheme for reference energies with two adjacent zeta-level bases.; Used by :py:func:`~wrappers.complete_basis_set`. .. math:: E_{total}^X = E_{total}^{\infty} + \beta e^{-\alpha X}, \alpha = 1.63. """"""; energypiece = 0.0; functionname = sys._getframe().f_code.co_name; f_fields = ['f_wfn', 'f_portion', 'f_basis', 'f_zeta', 'f_energy']; [mode, NEED, wfnname, BSET, ZSET] = validate_scheme_args(functionname, **largs). if (mode == 'requisition'):. # Impose restrictions on zeta sequence; if (len(ZSET) != 2):; raise ValidationError('Call to \'%s\' not valid with \'%s\' basis sets.' % (functionname, len(ZSET))). # Return",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:98123,Energy Efficiency,Energy,Energy,98123,"MD': dict(zip(f_fields, [wfnname, 'tot', BSET[1], ZSET[1], 0.0])),; 'LO': dict(zip(f_fields, [wfnname, 'tot', BSET[0], ZSET[0], 0.0]))}. return NEED. elif (mode == 'evaluate'):. # Extract required energies and zeta integers from array; eHI = NEED['HI']['f_energy']; eMD = NEED['MD']['f_energy']; eLO = NEED['LO']['f_energy']; zHI = NEED['HI']['f_zeta']; zMD = NEED['MD']['f_zeta']; zLO = NEED['LO']['f_zeta']. # Compute extrapolated energy; ratio = (eHI - eMD) / (eMD - eLO); alpha = -1 * math.log(ratio); beta = (eHI - eMD) / (math.exp(-1 * alpha * zMD) * (ratio - 1)); energypiece = eHI - beta * math.exp(-1 * alpha * zHI). # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += """"""\n ==> %s <==\n\n"""""" % (functionname); cbsscheme += """""" LO-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zLO), eLO); cbsscheme += """""" MD-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zMD), eMD); cbsscheme += """""" HI-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zHI), eHI); cbsscheme += """""" Extrapolated Correlation Energy: %16.8f\n"""""" % (energypiece); cbsscheme += """""" Alpha (exponent) Value: %16.8f\n"""""" % (alpha); cbsscheme += """""" Beta (coefficient) Value: %16.8f\n"""""" % (beta); psi4.print_out(cbsscheme). return energypiece. [docs]def scf_xtpl_helgaker_2(**largs):; r""""""Extrapolation scheme for reference energies with two adjacent zeta-level bases.; Used by :py:func:`~wrappers.complete_basis_set`. .. math:: E_{total}^X = E_{total}^{\infty} + \beta e^{-\alpha X}, \alpha = 1.63. """"""; energypiece = 0.0; functionname = sys._getframe().f_code.co_name; f_fields = ['f_wfn', 'f_portion', 'f_basis', 'f_zeta', 'f_energy']; [mode, NEED, wfnname, BSET, ZSET] = validate_scheme_args(functionname, **largs). if (mode == 'requisition'):. # Impose restrictions on zeta sequence; if (len(ZSET) != 2):; raise ValidationError('Call to \'%s\' not valid with \'%s\' basis sets.' % (functionname, len(ZSET))). # Return array that logs the requisite jobs; NEED = {'HI': dict(zip(f_fields, [wfnname, '",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:98146,Energy Efficiency,energy,energypiece,98146,"ct(zip(f_fields, [wfnname, 'tot', BSET[0], ZSET[0], 0.0]))}. return NEED. elif (mode == 'evaluate'):. # Extract required energies and zeta integers from array; eHI = NEED['HI']['f_energy']; eMD = NEED['MD']['f_energy']; eLO = NEED['LO']['f_energy']; zHI = NEED['HI']['f_zeta']; zMD = NEED['MD']['f_zeta']; zLO = NEED['LO']['f_zeta']. # Compute extrapolated energy; ratio = (eHI - eMD) / (eMD - eLO); alpha = -1 * math.log(ratio); beta = (eHI - eMD) / (math.exp(-1 * alpha * zMD) * (ratio - 1)); energypiece = eHI - beta * math.exp(-1 * alpha * zHI). # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += """"""\n ==> %s <==\n\n"""""" % (functionname); cbsscheme += """""" LO-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zLO), eLO); cbsscheme += """""" MD-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zMD), eMD); cbsscheme += """""" HI-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zHI), eHI); cbsscheme += """""" Extrapolated Correlation Energy: %16.8f\n"""""" % (energypiece); cbsscheme += """""" Alpha (exponent) Value: %16.8f\n"""""" % (alpha); cbsscheme += """""" Beta (coefficient) Value: %16.8f\n"""""" % (beta); psi4.print_out(cbsscheme). return energypiece. [docs]def scf_xtpl_helgaker_2(**largs):; r""""""Extrapolation scheme for reference energies with two adjacent zeta-level bases.; Used by :py:func:`~wrappers.complete_basis_set`. .. math:: E_{total}^X = E_{total}^{\infty} + \beta e^{-\alpha X}, \alpha = 1.63. """"""; energypiece = 0.0; functionname = sys._getframe().f_code.co_name; f_fields = ['f_wfn', 'f_portion', 'f_basis', 'f_zeta', 'f_energy']; [mode, NEED, wfnname, BSET, ZSET] = validate_scheme_args(functionname, **largs). if (mode == 'requisition'):. # Impose restrictions on zeta sequence; if (len(ZSET) != 2):; raise ValidationError('Call to \'%s\' not valid with \'%s\' basis sets.' % (functionname, len(ZSET))). # Return array that logs the requisite jobs; NEED = {'HI': dict(zip(f_fields, [wfnname, 'tot', BSET[1], ZSET[1], 0.0])),; 'LO': dict(zip(f_fields, [wfnname, 'tot', ",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:98323,Energy Efficiency,energy,energypiece,98323,"ray; eHI = NEED['HI']['f_energy']; eMD = NEED['MD']['f_energy']; eLO = NEED['LO']['f_energy']; zHI = NEED['HI']['f_zeta']; zMD = NEED['MD']['f_zeta']; zLO = NEED['LO']['f_zeta']. # Compute extrapolated energy; ratio = (eHI - eMD) / (eMD - eLO); alpha = -1 * math.log(ratio); beta = (eHI - eMD) / (math.exp(-1 * alpha * zMD) * (ratio - 1)); energypiece = eHI - beta * math.exp(-1 * alpha * zHI). # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += """"""\n ==> %s <==\n\n"""""" % (functionname); cbsscheme += """""" LO-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zLO), eLO); cbsscheme += """""" MD-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zMD), eMD); cbsscheme += """""" HI-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zHI), eHI); cbsscheme += """""" Extrapolated Correlation Energy: %16.8f\n"""""" % (energypiece); cbsscheme += """""" Alpha (exponent) Value: %16.8f\n"""""" % (alpha); cbsscheme += """""" Beta (coefficient) Value: %16.8f\n"""""" % (beta); psi4.print_out(cbsscheme). return energypiece. [docs]def scf_xtpl_helgaker_2(**largs):; r""""""Extrapolation scheme for reference energies with two adjacent zeta-level bases.; Used by :py:func:`~wrappers.complete_basis_set`. .. math:: E_{total}^X = E_{total}^{\infty} + \beta e^{-\alpha X}, \alpha = 1.63. """"""; energypiece = 0.0; functionname = sys._getframe().f_code.co_name; f_fields = ['f_wfn', 'f_portion', 'f_basis', 'f_zeta', 'f_energy']; [mode, NEED, wfnname, BSET, ZSET] = validate_scheme_args(functionname, **largs). if (mode == 'requisition'):. # Impose restrictions on zeta sequence; if (len(ZSET) != 2):; raise ValidationError('Call to \'%s\' not valid with \'%s\' basis sets.' % (functionname, len(ZSET))). # Return array that logs the requisite jobs; NEED = {'HI': dict(zip(f_fields, [wfnname, 'tot', BSET[1], ZSET[1], 0.0])),; 'LO': dict(zip(f_fields, [wfnname, 'tot', BSET[0], ZSET[0], 0.0]))}. return NEED. elif (mode == 'evaluate'):. # Extract required energies and zeta integers from array; eHI = NEED['HI']['f_energy'];",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:98597,Energy Efficiency,energy,energypiece,98597,"ta = (eHI - eMD) / (math.exp(-1 * alpha * zMD) * (ratio - 1)); energypiece = eHI - beta * math.exp(-1 * alpha * zHI). # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += """"""\n ==> %s <==\n\n"""""" % (functionname); cbsscheme += """""" LO-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zLO), eLO); cbsscheme += """""" MD-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zMD), eMD); cbsscheme += """""" HI-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zHI), eHI); cbsscheme += """""" Extrapolated Correlation Energy: %16.8f\n"""""" % (energypiece); cbsscheme += """""" Alpha (exponent) Value: %16.8f\n"""""" % (alpha); cbsscheme += """""" Beta (coefficient) Value: %16.8f\n"""""" % (beta); psi4.print_out(cbsscheme). return energypiece. [docs]def scf_xtpl_helgaker_2(**largs):; r""""""Extrapolation scheme for reference energies with two adjacent zeta-level bases.; Used by :py:func:`~wrappers.complete_basis_set`. .. math:: E_{total}^X = E_{total}^{\infty} + \beta e^{-\alpha X}, \alpha = 1.63. """"""; energypiece = 0.0; functionname = sys._getframe().f_code.co_name; f_fields = ['f_wfn', 'f_portion', 'f_basis', 'f_zeta', 'f_energy']; [mode, NEED, wfnname, BSET, ZSET] = validate_scheme_args(functionname, **largs). if (mode == 'requisition'):. # Impose restrictions on zeta sequence; if (len(ZSET) != 2):; raise ValidationError('Call to \'%s\' not valid with \'%s\' basis sets.' % (functionname, len(ZSET))). # Return array that logs the requisite jobs; NEED = {'HI': dict(zip(f_fields, [wfnname, 'tot', BSET[1], ZSET[1], 0.0])),; 'LO': dict(zip(f_fields, [wfnname, 'tot', BSET[0], ZSET[0], 0.0]))}. return NEED. elif (mode == 'evaluate'):. # Extract required energies and zeta integers from array; eHI = NEED['HI']['f_energy']; eLO = NEED['LO']['f_energy']; zHI = NEED['HI']['f_zeta']; zLO = NEED['LO']['f_zeta']. # LAB TODO add ability to pass alternate parameter values in. # Return extrapolated energy; alpha = 1.63; beta = (eHI - eLO) / (math.exp(-1 * alpha * zLO) * (math.exp(-1 * alpha) - 1)); ener",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:99496,Energy Efficiency,energy,energy,99496,"plete_basis_set`. .. math:: E_{total}^X = E_{total}^{\infty} + \beta e^{-\alpha X}, \alpha = 1.63. """"""; energypiece = 0.0; functionname = sys._getframe().f_code.co_name; f_fields = ['f_wfn', 'f_portion', 'f_basis', 'f_zeta', 'f_energy']; [mode, NEED, wfnname, BSET, ZSET] = validate_scheme_args(functionname, **largs). if (mode == 'requisition'):. # Impose restrictions on zeta sequence; if (len(ZSET) != 2):; raise ValidationError('Call to \'%s\' not valid with \'%s\' basis sets.' % (functionname, len(ZSET))). # Return array that logs the requisite jobs; NEED = {'HI': dict(zip(f_fields, [wfnname, 'tot', BSET[1], ZSET[1], 0.0])),; 'LO': dict(zip(f_fields, [wfnname, 'tot', BSET[0], ZSET[0], 0.0]))}. return NEED. elif (mode == 'evaluate'):. # Extract required energies and zeta integers from array; eHI = NEED['HI']['f_energy']; eLO = NEED['LO']['f_energy']; zHI = NEED['HI']['f_zeta']; zLO = NEED['LO']['f_zeta']. # LAB TODO add ability to pass alternate parameter values in. # Return extrapolated energy; alpha = 1.63; beta = (eHI - eLO) / (math.exp(-1 * alpha * zLO) * (math.exp(-1 * alpha) - 1)); energypiece = eHI - beta * math.exp(-1 * alpha * zHI). # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += """"""\n ==> %s <==\n\n"""""" % (functionname); cbsscheme += """""" LO-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zLO), eLO); cbsscheme += """""" HI-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zHI), eHI); cbsscheme += """""" Extrapolated Correlation Energy: %16.8f\n"""""" % (energypiece); cbsscheme += """""" Alpha (exponent) Value: %16.8f\n"""""" % (alpha); cbsscheme += """""" Beta (coefficient) Value: %16.8f\n"""""" % (beta); psi4.print_out(cbsscheme). return energypiece. [docs]def validate_scheme_args(functionname, **largs):; r""""""Function called by each extrapolation scheme in :py:func:`~wrappers.complete_basis_set`.; Checks that all the input arguments are present and suitable so that; the scheme function can focus on defining the extrapolation. """"""; mode = ''; NEED = []",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:99598,Energy Efficiency,energy,energypiece,99598,"ypiece = 0.0; functionname = sys._getframe().f_code.co_name; f_fields = ['f_wfn', 'f_portion', 'f_basis', 'f_zeta', 'f_energy']; [mode, NEED, wfnname, BSET, ZSET] = validate_scheme_args(functionname, **largs). if (mode == 'requisition'):. # Impose restrictions on zeta sequence; if (len(ZSET) != 2):; raise ValidationError('Call to \'%s\' not valid with \'%s\' basis sets.' % (functionname, len(ZSET))). # Return array that logs the requisite jobs; NEED = {'HI': dict(zip(f_fields, [wfnname, 'tot', BSET[1], ZSET[1], 0.0])),; 'LO': dict(zip(f_fields, [wfnname, 'tot', BSET[0], ZSET[0], 0.0]))}. return NEED. elif (mode == 'evaluate'):. # Extract required energies and zeta integers from array; eHI = NEED['HI']['f_energy']; eLO = NEED['LO']['f_energy']; zHI = NEED['HI']['f_zeta']; zLO = NEED['LO']['f_zeta']. # LAB TODO add ability to pass alternate parameter values in. # Return extrapolated energy; alpha = 1.63; beta = (eHI - eLO) / (math.exp(-1 * alpha * zLO) * (math.exp(-1 * alpha) - 1)); energypiece = eHI - beta * math.exp(-1 * alpha * zHI). # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += """"""\n ==> %s <==\n\n"""""" % (functionname); cbsscheme += """""" LO-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zLO), eLO); cbsscheme += """""" HI-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zHI), eHI); cbsscheme += """""" Extrapolated Correlation Energy: %16.8f\n"""""" % (energypiece); cbsscheme += """""" Alpha (exponent) Value: %16.8f\n"""""" % (alpha); cbsscheme += """""" Beta (coefficient) Value: %16.8f\n"""""" % (beta); psi4.print_out(cbsscheme). return energypiece. [docs]def validate_scheme_args(functionname, **largs):; r""""""Function called by each extrapolation scheme in :py:func:`~wrappers.complete_basis_set`.; Checks that all the input arguments are present and suitable so that; the scheme function can focus on defining the extrapolation. """"""; mode = ''; NEED = []; wfnname = ''; BSET = []; ZSET = []. # Mode where function fills out a form NEED with the computations neede",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:99813,Energy Efficiency,Energy,Energy,99813,"NEED, wfnname, BSET, ZSET] = validate_scheme_args(functionname, **largs). if (mode == 'requisition'):. # Impose restrictions on zeta sequence; if (len(ZSET) != 2):; raise ValidationError('Call to \'%s\' not valid with \'%s\' basis sets.' % (functionname, len(ZSET))). # Return array that logs the requisite jobs; NEED = {'HI': dict(zip(f_fields, [wfnname, 'tot', BSET[1], ZSET[1], 0.0])),; 'LO': dict(zip(f_fields, [wfnname, 'tot', BSET[0], ZSET[0], 0.0]))}. return NEED. elif (mode == 'evaluate'):. # Extract required energies and zeta integers from array; eHI = NEED['HI']['f_energy']; eLO = NEED['LO']['f_energy']; zHI = NEED['HI']['f_zeta']; zLO = NEED['LO']['f_zeta']. # LAB TODO add ability to pass alternate parameter values in. # Return extrapolated energy; alpha = 1.63; beta = (eHI - eLO) / (math.exp(-1 * alpha * zLO) * (math.exp(-1 * alpha) - 1)); energypiece = eHI - beta * math.exp(-1 * alpha * zHI). # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += """"""\n ==> %s <==\n\n"""""" % (functionname); cbsscheme += """""" LO-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zLO), eLO); cbsscheme += """""" HI-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zHI), eHI); cbsscheme += """""" Extrapolated Correlation Energy: %16.8f\n"""""" % (energypiece); cbsscheme += """""" Alpha (exponent) Value: %16.8f\n"""""" % (alpha); cbsscheme += """""" Beta (coefficient) Value: %16.8f\n"""""" % (beta); psi4.print_out(cbsscheme). return energypiece. [docs]def validate_scheme_args(functionname, **largs):; r""""""Function called by each extrapolation scheme in :py:func:`~wrappers.complete_basis_set`.; Checks that all the input arguments are present and suitable so that; the scheme function can focus on defining the extrapolation. """"""; mode = ''; NEED = []; wfnname = ''; BSET = []; ZSET = []. # Mode where function fills out a form NEED with the computations needed to fulfill its call; if (largs['mode'].lower() == 'requisition'):; mode = largs['mode'].lower(). if 'wfnname' in largs:; wfnname = lar",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:99894,Energy Efficiency,Energy,Energy,99894," zeta sequence; if (len(ZSET) != 2):; raise ValidationError('Call to \'%s\' not valid with \'%s\' basis sets.' % (functionname, len(ZSET))). # Return array that logs the requisite jobs; NEED = {'HI': dict(zip(f_fields, [wfnname, 'tot', BSET[1], ZSET[1], 0.0])),; 'LO': dict(zip(f_fields, [wfnname, 'tot', BSET[0], ZSET[0], 0.0]))}. return NEED. elif (mode == 'evaluate'):. # Extract required energies and zeta integers from array; eHI = NEED['HI']['f_energy']; eLO = NEED['LO']['f_energy']; zHI = NEED['HI']['f_zeta']; zLO = NEED['LO']['f_zeta']. # LAB TODO add ability to pass alternate parameter values in. # Return extrapolated energy; alpha = 1.63; beta = (eHI - eLO) / (math.exp(-1 * alpha * zLO) * (math.exp(-1 * alpha) - 1)); energypiece = eHI - beta * math.exp(-1 * alpha * zHI). # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += """"""\n ==> %s <==\n\n"""""" % (functionname); cbsscheme += """""" LO-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zLO), eLO); cbsscheme += """""" HI-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zHI), eHI); cbsscheme += """""" Extrapolated Correlation Energy: %16.8f\n"""""" % (energypiece); cbsscheme += """""" Alpha (exponent) Value: %16.8f\n"""""" % (alpha); cbsscheme += """""" Beta (coefficient) Value: %16.8f\n"""""" % (beta); psi4.print_out(cbsscheme). return energypiece. [docs]def validate_scheme_args(functionname, **largs):; r""""""Function called by each extrapolation scheme in :py:func:`~wrappers.complete_basis_set`.; Checks that all the input arguments are present and suitable so that; the scheme function can focus on defining the extrapolation. """"""; mode = ''; NEED = []; wfnname = ''; BSET = []; ZSET = []. # Mode where function fills out a form NEED with the computations needed to fulfill its call; if (largs['mode'].lower() == 'requisition'):; mode = largs['mode'].lower(). if 'wfnname' in largs:; wfnname = largs['wfnname']; else:; raise ValidationError('Call to \'%s\' has keyword \'wfnname\' missing.' % (functionname)). if re.match(r'",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:99975,Energy Efficiency,Energy,Energy,99975,"alid with \'%s\' basis sets.' % (functionname, len(ZSET))). # Return array that logs the requisite jobs; NEED = {'HI': dict(zip(f_fields, [wfnname, 'tot', BSET[1], ZSET[1], 0.0])),; 'LO': dict(zip(f_fields, [wfnname, 'tot', BSET[0], ZSET[0], 0.0]))}. return NEED. elif (mode == 'evaluate'):. # Extract required energies and zeta integers from array; eHI = NEED['HI']['f_energy']; eLO = NEED['LO']['f_energy']; zHI = NEED['HI']['f_zeta']; zLO = NEED['LO']['f_zeta']. # LAB TODO add ability to pass alternate parameter values in. # Return extrapolated energy; alpha = 1.63; beta = (eHI - eLO) / (math.exp(-1 * alpha * zLO) * (math.exp(-1 * alpha) - 1)); energypiece = eHI - beta * math.exp(-1 * alpha * zHI). # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += """"""\n ==> %s <==\n\n"""""" % (functionname); cbsscheme += """""" LO-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zLO), eLO); cbsscheme += """""" HI-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zHI), eHI); cbsscheme += """""" Extrapolated Correlation Energy: %16.8f\n"""""" % (energypiece); cbsscheme += """""" Alpha (exponent) Value: %16.8f\n"""""" % (alpha); cbsscheme += """""" Beta (coefficient) Value: %16.8f\n"""""" % (beta); psi4.print_out(cbsscheme). return energypiece. [docs]def validate_scheme_args(functionname, **largs):; r""""""Function called by each extrapolation scheme in :py:func:`~wrappers.complete_basis_set`.; Checks that all the input arguments are present and suitable so that; the scheme function can focus on defining the extrapolation. """"""; mode = ''; NEED = []; wfnname = ''; BSET = []; ZSET = []. # Mode where function fills out a form NEED with the computations needed to fulfill its call; if (largs['mode'].lower() == 'requisition'):; mode = largs['mode'].lower(). if 'wfnname' in largs:; wfnname = largs['wfnname']; else:; raise ValidationError('Call to \'%s\' has keyword \'wfnname\' missing.' % (functionname)). if re.match(r'scf_.*$', functionname) and (wfnname != 'scf'):; raise ValidationError('Call to \",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:99998,Energy Efficiency,energy,energypiece,99998,"hat logs the requisite jobs; NEED = {'HI': dict(zip(f_fields, [wfnname, 'tot', BSET[1], ZSET[1], 0.0])),; 'LO': dict(zip(f_fields, [wfnname, 'tot', BSET[0], ZSET[0], 0.0]))}. return NEED. elif (mode == 'evaluate'):. # Extract required energies and zeta integers from array; eHI = NEED['HI']['f_energy']; eLO = NEED['LO']['f_energy']; zHI = NEED['HI']['f_zeta']; zLO = NEED['LO']['f_zeta']. # LAB TODO add ability to pass alternate parameter values in. # Return extrapolated energy; alpha = 1.63; beta = (eHI - eLO) / (math.exp(-1 * alpha * zLO) * (math.exp(-1 * alpha) - 1)); energypiece = eHI - beta * math.exp(-1 * alpha * zHI). # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += """"""\n ==> %s <==\n\n"""""" % (functionname); cbsscheme += """""" LO-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zLO), eLO); cbsscheme += """""" HI-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zHI), eHI); cbsscheme += """""" Extrapolated Correlation Energy: %16.8f\n"""""" % (energypiece); cbsscheme += """""" Alpha (exponent) Value: %16.8f\n"""""" % (alpha); cbsscheme += """""" Beta (coefficient) Value: %16.8f\n"""""" % (beta); psi4.print_out(cbsscheme). return energypiece. [docs]def validate_scheme_args(functionname, **largs):; r""""""Function called by each extrapolation scheme in :py:func:`~wrappers.complete_basis_set`.; Checks that all the input arguments are present and suitable so that; the scheme function can focus on defining the extrapolation. """"""; mode = ''; NEED = []; wfnname = ''; BSET = []; ZSET = []. # Mode where function fills out a form NEED with the computations needed to fulfill its call; if (largs['mode'].lower() == 'requisition'):; mode = largs['mode'].lower(). if 'wfnname' in largs:; wfnname = largs['wfnname']; else:; raise ValidationError('Call to \'%s\' has keyword \'wfnname\' missing.' % (functionname)). if re.match(r'scf_.*$', functionname) and (wfnname != 'scf'):; raise ValidationError('Call to \'%s\' is intended for scf portion of calculation.' % (functionname)); if re",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:100175,Energy Efficiency,energy,energypiece,100175,", ZSET[0], 0.0]))}. return NEED. elif (mode == 'evaluate'):. # Extract required energies and zeta integers from array; eHI = NEED['HI']['f_energy']; eLO = NEED['LO']['f_energy']; zHI = NEED['HI']['f_zeta']; zLO = NEED['LO']['f_zeta']. # LAB TODO add ability to pass alternate parameter values in. # Return extrapolated energy; alpha = 1.63; beta = (eHI - eLO) / (math.exp(-1 * alpha * zLO) * (math.exp(-1 * alpha) - 1)); energypiece = eHI - beta * math.exp(-1 * alpha * zHI). # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += """"""\n ==> %s <==\n\n"""""" % (functionname); cbsscheme += """""" LO-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zLO), eLO); cbsscheme += """""" HI-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zHI), eHI); cbsscheme += """""" Extrapolated Correlation Energy: %16.8f\n"""""" % (energypiece); cbsscheme += """""" Alpha (exponent) Value: %16.8f\n"""""" % (alpha); cbsscheme += """""" Beta (coefficient) Value: %16.8f\n"""""" % (beta); psi4.print_out(cbsscheme). return energypiece. [docs]def validate_scheme_args(functionname, **largs):; r""""""Function called by each extrapolation scheme in :py:func:`~wrappers.complete_basis_set`.; Checks that all the input arguments are present and suitable so that; the scheme function can focus on defining the extrapolation. """"""; mode = ''; NEED = []; wfnname = ''; BSET = []; ZSET = []. # Mode where function fills out a form NEED with the computations needed to fulfill its call; if (largs['mode'].lower() == 'requisition'):; mode = largs['mode'].lower(). if 'wfnname' in largs:; wfnname = largs['wfnname']; else:; raise ValidationError('Call to \'%s\' has keyword \'wfnname\' missing.' % (functionname)). if re.match(r'scf_.*$', functionname) and (wfnname != 'scf'):; raise ValidationError('Call to \'%s\' is intended for scf portion of calculation.' % (functionname)); if re.match(r'corl_.*$', functionname) and (wfnname == 'scf'):; raise ValidationError('Call to \'%s\' is not intended for scf portion of calculation.' % (functi",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:3,Integrability,wrap,wrappers,3,". wrappers  PSI4 [beta5] documentation. Navigation. index. modules  . toc  ; PSI4 [beta5]  ; Module code . Source code for wrappers; #; #@BEGIN LICENSE; #; # PSI4: an ab initio quantum chemistry software package; #; # This program is free software; you can redistribute it and/or modify; # it under the terms of the GNU General Public License as published by; # the Free Software Foundation; either version 2 of the License, or; # (at your option) any later version.; #; # This program is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU General Public License for more details.; #; # You should have received a copy of the GNU General Public License along; # with this program; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; #@END LICENSE; #. """"""Module with functions that call the four main :py:mod:`driver`; functions: :py:mod:`driver.energy`, :py:mod:`driver.optimize`,; :py:mod:`driver.response`, and :py:mod:`driver.frequency`. """"""; import re; import os; import math; import warnings; import pickle; import copy; import collections; import psi4; import p4const; import p4util; from driver import *; #from extend_Molecule import *; from molutil import *; from p4regex import *; # never import aliases into this file. # Function to make calls among wrappers(), energy(), optimize(), etc.; [docs]def call_function_in_1st_argument(funcarg, **largs):; r""""""Function to make primary function call to energy(), opt(), etc.; with options dictionary *largs*.; Useful when *funcarg* to call is stored in variable. """"""; return funcarg(**largs). [docs]def convert(p, symbol):; if symbol[p] == 'H':; d = 1.001; if symbol[p] == 'He':; d = 1.012; if symbol[p] == 'Li':; d = 0.825; if symbol[p] == 'Be':; d = 1.408; if symbol[p] == 'B':; d = 1.485; if symbol[p] == 'C':; d = 1.452; if symbol[p] ",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:131,Integrability,wrap,wrappers,131,". wrappers  PSI4 [beta5] documentation. Navigation. index. modules  . toc  ; PSI4 [beta5]  ; Module code . Source code for wrappers; #; #@BEGIN LICENSE; #; # PSI4: an ab initio quantum chemistry software package; #; # This program is free software; you can redistribute it and/or modify; # it under the terms of the GNU General Public License as published by; # the Free Software Foundation; either version 2 of the License, or; # (at your option) any later version.; #; # This program is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU General Public License for more details.; #; # You should have received a copy of the GNU General Public License along; # with this program; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; #@END LICENSE; #. """"""Module with functions that call the four main :py:mod:`driver`; functions: :py:mod:`driver.energy`, :py:mod:`driver.optimize`,; :py:mod:`driver.response`, and :py:mod:`driver.frequency`. """"""; import re; import os; import math; import warnings; import pickle; import copy; import collections; import psi4; import p4const; import p4util; from driver import *; #from extend_Molecule import *; from molutil import *; from p4regex import *; # never import aliases into this file. # Function to make calls among wrappers(), energy(), optimize(), etc.; [docs]def call_function_in_1st_argument(funcarg, **largs):; r""""""Function to make primary function call to energy(), opt(), etc.; with options dictionary *largs*.; Useful when *funcarg* to call is stored in variable. """"""; return funcarg(**largs). [docs]def convert(p, symbol):; if symbol[p] == 'H':; d = 1.001; if symbol[p] == 'He':; d = 1.012; if symbol[p] == 'Li':; d = 0.825; if symbol[p] == 'Be':; d = 1.408; if symbol[p] == 'B':; d = 1.485; if symbol[p] == 'C':; d = 1.452; if symbol[p] ",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:1470,Integrability,wrap,wrappers,1470,".; #; # This program is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU General Public License for more details.; #; # You should have received a copy of the GNU General Public License along; # with this program; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; #@END LICENSE; #. """"""Module with functions that call the four main :py:mod:`driver`; functions: :py:mod:`driver.energy`, :py:mod:`driver.optimize`,; :py:mod:`driver.response`, and :py:mod:`driver.frequency`. """"""; import re; import os; import math; import warnings; import pickle; import copy; import collections; import psi4; import p4const; import p4util; from driver import *; #from extend_Molecule import *; from molutil import *; from p4regex import *; # never import aliases into this file. # Function to make calls among wrappers(), energy(), optimize(), etc.; [docs]def call_function_in_1st_argument(funcarg, **largs):; r""""""Function to make primary function call to energy(), opt(), etc.; with options dictionary *largs*.; Useful when *funcarg* to call is stored in variable. """"""; return funcarg(**largs). [docs]def convert(p, symbol):; if symbol[p] == 'H':; d = 1.001; if symbol[p] == 'He':; d = 1.012; if symbol[p] == 'Li':; d = 0.825; if symbol[p] == 'Be':; d = 1.408; if symbol[p] == 'B':; d = 1.485; if symbol[p] == 'C':; d = 1.452; if symbol[p] == 'N':; d = 1.397; if symbol[p] == 'O':; d = 1.342; if symbol[p] == 'F':; d = 1.287; if symbol[p] == 'Ne':; d = 1.243; if symbol[p] == 'Na':; d = 1.144; if symbol[p] == 'Mg':; d = 1.364; if symbol[p] == 'Al':; d = 1.639; if symbol[p] == 'Si':; d = 1.716; if symbol[p] == 'P':; d = 1.705; if symbol[p] == 'S':; d = 1.683; if symbol[p] == 'Cl':; d = 1.639; if symbol[p] == 'Ar':; d = 1.595. return d / 1.5. #Automatically detect fragments and build a new molecule for fragm",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:4743,Integrability,Wrap,Wrap,4743,"nvert(i,symbol):; Queue.append(i) # if you find you, put it in the que; White.remove(i) # and remove it from the untouched list; Queue.remove(u) # remove focus from Queue; Black.append(u); Fragment[frag].append(int(u + 1)) # add to group (adding 1 to start; # list at one instead of zero). if(len(White) != 0): # cant move White->Queue if no more exist; Queue.append(White[0]); White.remove(White[0]); frag += 1. new_geom = """"""\n0 1\n""""""; for i in Fragment[0]:; new_geom = new_geom + F[i].lstrip() + """"""\n""""""; new_geom = new_geom + """"""--\n0 1\n""""""; for j in Fragment[1]:; new_geom = new_geom + F[j].lstrip() + """"""\n""""""; new_geom = new_geom + """"""units angstrom\n"""""". new_mol = geometry(new_geom); new_mol.print_out(); psi4.print_out(""Exiting auto_fragments\n""). #######################; ## Start of n_body ##; #######################. [docs]def n_body(name, **kwargs):; lowername = name.lower(); kwargs = p4util.kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name.lower(). # Establish function to call; if not('n_body_func' in kwargs):; if ('func' in kwargs):; kwargs['n_body_func'] = kwargs['func']; del kwargs['func']; else:; kwargs['n_body_func'] = energy; func = kwargs['n_body_func']; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper n_body.' % (func.__name__)); if (func is db):; raise ValidationError('Wrapper n_body is unhappy to be calling function \'%s\'.' % (func.__name__)). # Make sure the molecule the user provided is the active one; if 'molecule' in kwargs:; activate(kwargs['molecule']); del kwargs['molecule']; molecule = psi4.get_active_molecule(); molecule.update_geometry(); psi4.set_global_option(""BASIS"", psi4.get_global_option(""BASIS"")). # N-body run configuration; bsse = 'on'; if 'bsse' in kwargs:; bsse = kwargs['bsse']. max_n_body = molecule.nfragments(); if 'max_n_body' in kwargs:; max_n_body = kwargs['max_n_body']. do_tot",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:4807,Integrability,wrap,wrappers,4807,"nvert(i,symbol):; Queue.append(i) # if you find you, put it in the que; White.remove(i) # and remove it from the untouched list; Queue.remove(u) # remove focus from Queue; Black.append(u); Fragment[frag].append(int(u + 1)) # add to group (adding 1 to start; # list at one instead of zero). if(len(White) != 0): # cant move White->Queue if no more exist; Queue.append(White[0]); White.remove(White[0]); frag += 1. new_geom = """"""\n0 1\n""""""; for i in Fragment[0]:; new_geom = new_geom + F[i].lstrip() + """"""\n""""""; new_geom = new_geom + """"""--\n0 1\n""""""; for j in Fragment[1]:; new_geom = new_geom + F[j].lstrip() + """"""\n""""""; new_geom = new_geom + """"""units angstrom\n"""""". new_mol = geometry(new_geom); new_mol.print_out(); psi4.print_out(""Exiting auto_fragments\n""). #######################; ## Start of n_body ##; #######################. [docs]def n_body(name, **kwargs):; lowername = name.lower(); kwargs = p4util.kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name.lower(). # Establish function to call; if not('n_body_func' in kwargs):; if ('func' in kwargs):; kwargs['n_body_func'] = kwargs['func']; del kwargs['func']; else:; kwargs['n_body_func'] = energy; func = kwargs['n_body_func']; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper n_body.' % (func.__name__)); if (func is db):; raise ValidationError('Wrapper n_body is unhappy to be calling function \'%s\'.' % (func.__name__)). # Make sure the molecule the user provided is the active one; if 'molecule' in kwargs:; activate(kwargs['molecule']); del kwargs['molecule']; molecule = psi4.get_active_molecule(); molecule.update_geometry(); psi4.set_global_option(""BASIS"", psi4.get_global_option(""BASIS"")). # N-body run configuration; bsse = 'on'; if 'bsse' in kwargs:; bsse = kwargs['bsse']. max_n_body = molecule.nfragments(); if 'max_n_body' in kwargs:; max_n_body = kwargs['max_n_body']. do_tot",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:5186,Integrability,wrap,wrapper,5186,"oup (adding 1 to start; # list at one instead of zero). if(len(White) != 0): # cant move White->Queue if no more exist; Queue.append(White[0]); White.remove(White[0]); frag += 1. new_geom = """"""\n0 1\n""""""; for i in Fragment[0]:; new_geom = new_geom + F[i].lstrip() + """"""\n""""""; new_geom = new_geom + """"""--\n0 1\n""""""; for j in Fragment[1]:; new_geom = new_geom + F[j].lstrip() + """"""\n""""""; new_geom = new_geom + """"""units angstrom\n"""""". new_mol = geometry(new_geom); new_mol.print_out(); psi4.print_out(""Exiting auto_fragments\n""). #######################; ## Start of n_body ##; #######################. [docs]def n_body(name, **kwargs):; lowername = name.lower(); kwargs = p4util.kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name.lower(). # Establish function to call; if not('n_body_func' in kwargs):; if ('func' in kwargs):; kwargs['n_body_func'] = kwargs['func']; del kwargs['func']; else:; kwargs['n_body_func'] = energy; func = kwargs['n_body_func']; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper n_body.' % (func.__name__)); if (func is db):; raise ValidationError('Wrapper n_body is unhappy to be calling function \'%s\'.' % (func.__name__)). # Make sure the molecule the user provided is the active one; if 'molecule' in kwargs:; activate(kwargs['molecule']); del kwargs['molecule']; molecule = psi4.get_active_molecule(); molecule.update_geometry(); psi4.set_global_option(""BASIS"", psi4.get_global_option(""BASIS"")). # N-body run configuration; bsse = 'on'; if 'bsse' in kwargs:; bsse = kwargs['bsse']. max_n_body = molecule.nfragments(); if 'max_n_body' in kwargs:; max_n_body = kwargs['max_n_body']. do_total = False; if 'do_total' in kwargs:; do_total = kwargs['do_total']. external = None; external_indices = []; if 'external' in kwargs:; external = kwargs['external']; external_indices = [molecule.nfragments()]; if 'external_monomers' in",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:5264,Integrability,Wrap,Wrapper,5264,"0]:; new_geom = new_geom + F[i].lstrip() + """"""\n""""""; new_geom = new_geom + """"""--\n0 1\n""""""; for j in Fragment[1]:; new_geom = new_geom + F[j].lstrip() + """"""\n""""""; new_geom = new_geom + """"""units angstrom\n"""""". new_mol = geometry(new_geom); new_mol.print_out(); psi4.print_out(""Exiting auto_fragments\n""). #######################; ## Start of n_body ##; #######################. [docs]def n_body(name, **kwargs):; lowername = name.lower(); kwargs = p4util.kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name.lower(). # Establish function to call; if not('n_body_func' in kwargs):; if ('func' in kwargs):; kwargs['n_body_func'] = kwargs['func']; del kwargs['func']; else:; kwargs['n_body_func'] = energy; func = kwargs['n_body_func']; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper n_body.' % (func.__name__)); if (func is db):; raise ValidationError('Wrapper n_body is unhappy to be calling function \'%s\'.' % (func.__name__)). # Make sure the molecule the user provided is the active one; if 'molecule' in kwargs:; activate(kwargs['molecule']); del kwargs['molecule']; molecule = psi4.get_active_molecule(); molecule.update_geometry(); psi4.set_global_option(""BASIS"", psi4.get_global_option(""BASIS"")). # N-body run configuration; bsse = 'on'; if 'bsse' in kwargs:; bsse = kwargs['bsse']. max_n_body = molecule.nfragments(); if 'max_n_body' in kwargs:; max_n_body = kwargs['max_n_body']. do_total = False; if 'do_total' in kwargs:; do_total = kwargs['do_total']. external = None; external_indices = []; if 'external' in kwargs:; external = kwargs['external']; external_indices = [molecule.nfragments()]; if 'external_monomers' in kwargs:; external_indices = kwargs['external_monomers']. # Check input args; if not bsse == 'off' and not bsse == 'on' and not bsse == 'both':; raise ValidationError('n_body: bsse argument is one of on, off, or both'); if ",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:18935,Integrability,Wrap,Wrap,18935,"tes the type of calculation to be performed on the molecule; and each of its monomers. The default performs a single-point; ``energy('name')``, while ``optimize`` perfoms a geometry optimization; on each system, and ``cbs`` performs a compound single-point energy.; If a nested series of python functions is intended; (see :ref:`sec:intercalls`), use keyword ``cp_func`` instead of ``func``. :type check_bsse: :ref:`boolean <op_py_boolean>`; :param check_bsse: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether to additionally compute un-counterpoise corrected; monomers and thus obtain an estimate for the basis set superposition error. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :examples:. >>> # [1] counterpoise-corrected mp2 interaction energy; >>> cp('df-mp2'). """"""; lowername = name.lower(); kwargs = p4util.kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name.lower(). # Establish function to call; if not('cp_func' in kwargs):; if ('func' in kwargs):; kwargs['cp_func'] = kwargs['func']; del kwargs['func']; else:; kwargs['cp_func'] = energy; func = kwargs['cp_func']; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper counterpoise_correct.' % (func.__name__)); if (func is db):; raise ValidationError('Wrapper counterpoise_correct is unhappy to be calling function \'%s\'.' % (func.__name__)). if 'check_bsse' in kwargs and yes.match(str(kwargs['check_bsse'])):; check_bsse = True; else:; check_bsse = False. # Make sure the molecule the user provided is the active one; if 'molecule' in kwargs:; activate(kwargs['molecule']); del kwargs['molecule']; molecule = psi4.get_active_molecule(); molecule.update_geometry(); psi4.set_global_option(""BASIS"", psi4.get_global_option(""BASIS"")). df_ints_io = psi4.get_global_option('DF_INTS_IO'); # inquire if ",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:18999,Integrability,wrap,wrappers,18999,"tes the type of calculation to be performed on the molecule; and each of its monomers. The default performs a single-point; ``energy('name')``, while ``optimize`` perfoms a geometry optimization; on each system, and ``cbs`` performs a compound single-point energy.; If a nested series of python functions is intended; (see :ref:`sec:intercalls`), use keyword ``cp_func`` instead of ``func``. :type check_bsse: :ref:`boolean <op_py_boolean>`; :param check_bsse: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether to additionally compute un-counterpoise corrected; monomers and thus obtain an estimate for the basis set superposition error. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :examples:. >>> # [1] counterpoise-corrected mp2 interaction energy; >>> cp('df-mp2'). """"""; lowername = name.lower(); kwargs = p4util.kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name.lower(). # Establish function to call; if not('cp_func' in kwargs):; if ('func' in kwargs):; kwargs['cp_func'] = kwargs['func']; del kwargs['func']; else:; kwargs['cp_func'] = energy; func = kwargs['cp_func']; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper counterpoise_correct.' % (func.__name__)); if (func is db):; raise ValidationError('Wrapper counterpoise_correct is unhappy to be calling function \'%s\'.' % (func.__name__)). if 'check_bsse' in kwargs and yes.match(str(kwargs['check_bsse'])):; check_bsse = True; else:; check_bsse = False. # Make sure the molecule the user provided is the active one; if 'molecule' in kwargs:; activate(kwargs['molecule']); del kwargs['molecule']; molecule = psi4.get_active_molecule(); molecule.update_geometry(); psi4.set_global_option(""BASIS"", psi4.get_global_option(""BASIS"")). df_ints_io = psi4.get_global_option('DF_INTS_IO'); # inquire if ",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:19362,Integrability,wrap,wrapper,19362,"a compound single-point energy.; If a nested series of python functions is intended; (see :ref:`sec:intercalls`), use keyword ``cp_func`` instead of ``func``. :type check_bsse: :ref:`boolean <op_py_boolean>`; :param check_bsse: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether to additionally compute un-counterpoise corrected; monomers and thus obtain an estimate for the basis set superposition error. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :examples:. >>> # [1] counterpoise-corrected mp2 interaction energy; >>> cp('df-mp2'). """"""; lowername = name.lower(); kwargs = p4util.kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name.lower(). # Establish function to call; if not('cp_func' in kwargs):; if ('func' in kwargs):; kwargs['cp_func'] = kwargs['func']; del kwargs['func']; else:; kwargs['cp_func'] = energy; func = kwargs['cp_func']; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper counterpoise_correct.' % (func.__name__)); if (func is db):; raise ValidationError('Wrapper counterpoise_correct is unhappy to be calling function \'%s\'.' % (func.__name__)). if 'check_bsse' in kwargs and yes.match(str(kwargs['check_bsse'])):; check_bsse = True; else:; check_bsse = False. # Make sure the molecule the user provided is the active one; if 'molecule' in kwargs:; activate(kwargs['molecule']); del kwargs['molecule']; molecule = psi4.get_active_molecule(); molecule.update_geometry(); psi4.set_global_option(""BASIS"", psi4.get_global_option(""BASIS"")). df_ints_io = psi4.get_global_option('DF_INTS_IO'); # inquire if above at all applies to dfmp2 or just scf; psi4.set_global_option('DF_INTS_IO', 'SAVE'); psioh = psi4.IOManager.shared_object(); psioh.set_specific_retention(97, True). activate(molecule); molecule.update_geometry(). psi4.print_out(""\",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:19454,Integrability,Wrap,Wrapper,19454,"`'on'`` || |dl| ``'off'`` |dr|. Indicates whether to additionally compute un-counterpoise corrected; monomers and thus obtain an estimate for the basis set superposition error. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :examples:. >>> # [1] counterpoise-corrected mp2 interaction energy; >>> cp('df-mp2'). """"""; lowername = name.lower(); kwargs = p4util.kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name.lower(). # Establish function to call; if not('cp_func' in kwargs):; if ('func' in kwargs):; kwargs['cp_func'] = kwargs['func']; del kwargs['func']; else:; kwargs['cp_func'] = energy; func = kwargs['cp_func']; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper counterpoise_correct.' % (func.__name__)); if (func is db):; raise ValidationError('Wrapper counterpoise_correct is unhappy to be calling function \'%s\'.' % (func.__name__)). if 'check_bsse' in kwargs and yes.match(str(kwargs['check_bsse'])):; check_bsse = True; else:; check_bsse = False. # Make sure the molecule the user provided is the active one; if 'molecule' in kwargs:; activate(kwargs['molecule']); del kwargs['molecule']; molecule = psi4.get_active_molecule(); molecule.update_geometry(); psi4.set_global_option(""BASIS"", psi4.get_global_option(""BASIS"")). df_ints_io = psi4.get_global_option('DF_INTS_IO'); # inquire if above at all applies to dfmp2 or just scf; psi4.set_global_option('DF_INTS_IO', 'SAVE'); psioh = psi4.IOManager.shared_object(); psioh.set_specific_retention(97, True). activate(molecule); molecule.update_geometry(). psi4.print_out(""\n""); p4util.banner(""CP Computation: Complex.\nFull Basis Set.""); psi4.print_out(""\n""); e_dimer = call_function_in_1st_argument(func, **kwargs); #e_dimer = energy(name, **kwargs). psi4.clean(); psi4.set_global_option('DF_INTS_IO',",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:26087,Integrability,wrap,wrappers,26087,"|dr| || ``optimize`` || ``cbs``. Indicates the type of calculation to be performed on each database; member. The default performs a single-point ``energy('name')``, while; ``optimize`` perfoms a geometry optimization on each reagent, and; ``cbs`` performs a compound single-point energy. If a nested series; of python functions is intended (see :ref:`sec:intercalls`), use; keyword ``db_func`` instead of ``func``. :type mode: string; :param mode: |dl| ``'continuous'`` |dr| || ``'sow'`` || ``'reap'``. Indicates whether the calculations required to complete the; database are to be run in one file (``'continuous'``) or are to be; farmed out in an embarrassingly parallel fashion; (``'sow'``/``'reap'``). For the latter, run an initial job with; ``'sow'`` and follow instructions in its output file. :type cp: :ref:`boolean <op_py_boolean>`; :param cp: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether counterpoise correction is employed in computing; interaction energies. Use this option and NOT the :py:func:`~wrappers.cp`; function for BSSE correction in database(). Option available; (See :ref:`sec:availableDatabases`) only for databases of bimolecular complexes. :type rlxd: :ref:`boolean <op_py_boolean>`; :param rlxd: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether correction for deformation energy is; employed in computing interaction energies. Option available; (See :ref:`sec:availableDatabases`) only for databases of bimolecular complexes; with non-frozen monomers, e.g., HBC6. :type symm: :ref:`boolean <op_py_boolean>`; :param symm: |dl| ``'on'`` |dr| || ``'off'``. Indicates whether the native symmetry of the database reagents is; employed (``'on'``) or whether it is forced to :math:`C_1` symmetry; (``'off'``). Some computational methods (e.g., SAPT) require no; symmetry, and this will be set by database(). :type zpe: :ref:`boolean <op_py_boolean>`; :param zpe: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether zero-point-energy corrections are appended to; single-poin",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:29859,Integrability,Wrap,Wrap,29859,"SCF calculation on short, equilibrium, and long helium dimer; >>> db('scf','RGC10',cast_up='sto-3g',subset=['HeHe-0.85','HeHe-1.0','HeHe-1.5'], tabulate=['scf total energy','natom']). >>> # [2] Counterpoise-corrected interaction energies for three complexes in S22; >>> # Error statistics computed wrt an old benchmark, S22A; >>> database('df-mp2','S22',cp=1,subset=[16,17,8],benchmark='S22A'). >>> # [3] SAPT0 on the neon dimer dissociation curve; >>> db('sapt0',subset='NeNe',cp=0,symm=0,db_name='RGC10'). >>> # [4] Optimize system 1 in database S22, producing tables of scf and mp2 energy; >>> db('mp2','S22',db_func=optimize,subset=[1], tabulate=['mp2 total energy','current energy']). >>> # [5] CCSD on the smallest systems of HTBH, a hydrogen-transfer database; >>> database('ccsd','HTBH',subset='small', tabulate=['ccsd total energy', 'mp2 total energy']). """"""; lowername = name.lower(); kwargs = p4util.kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name.lower(); if not('db_name' in kwargs) and db_name:; kwargs['db_name'] = db_name. # Establish function to call; if not('db_func' in kwargs):; if ('func' in kwargs):; kwargs['db_func'] = kwargs['func']; del kwargs['func']; else:; kwargs['db_func'] = energy; func = kwargs['db_func']; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper database.' % (func.__name__)); if (func is cp):; raise ValidationError('Wrapper database is unhappy to be calling function \'%s\'. Use the cp keyword within database instead.' % (func.__name__)). # Define path and load module for requested database; sys.path.append('%sdatabases' % (psi4.Process.environment[""PSIDATADIR""])); sys.path.append('%s/lib/databases' % psi4.psi_top_srcdir()); database = p4util.import_ignorecase(db_name); if database is None:; psi4.print_out('\nPython module for database %s failed to load\n\n' % (db_name)); psi4.print_out('\nSearc",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:29923,Integrability,wrap,wrappers,29923,"SCF calculation on short, equilibrium, and long helium dimer; >>> db('scf','RGC10',cast_up='sto-3g',subset=['HeHe-0.85','HeHe-1.0','HeHe-1.5'], tabulate=['scf total energy','natom']). >>> # [2] Counterpoise-corrected interaction energies for three complexes in S22; >>> # Error statistics computed wrt an old benchmark, S22A; >>> database('df-mp2','S22',cp=1,subset=[16,17,8],benchmark='S22A'). >>> # [3] SAPT0 on the neon dimer dissociation curve; >>> db('sapt0',subset='NeNe',cp=0,symm=0,db_name='RGC10'). >>> # [4] Optimize system 1 in database S22, producing tables of scf and mp2 energy; >>> db('mp2','S22',db_func=optimize,subset=[1], tabulate=['mp2 total energy','current energy']). >>> # [5] CCSD on the smallest systems of HTBH, a hydrogen-transfer database; >>> database('ccsd','HTBH',subset='small', tabulate=['ccsd total energy', 'mp2 total energy']). """"""; lowername = name.lower(); kwargs = p4util.kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name.lower(); if not('db_name' in kwargs) and db_name:; kwargs['db_name'] = db_name. # Establish function to call; if not('db_func' in kwargs):; if ('func' in kwargs):; kwargs['db_func'] = kwargs['func']; del kwargs['func']; else:; kwargs['db_func'] = energy; func = kwargs['db_func']; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper database.' % (func.__name__)); if (func is cp):; raise ValidationError('Wrapper database is unhappy to be calling function \'%s\'. Use the cp keyword within database instead.' % (func.__name__)). # Define path and load module for requested database; sys.path.append('%sdatabases' % (psi4.Process.environment[""PSIDATADIR""])); sys.path.append('%s/lib/databases' % psi4.psi_top_srcdir()); database = p4util.import_ignorecase(db_name); if database is None:; psi4.print_out('\nPython module for database %s failed to load\n\n' % (db_name)); psi4.print_out('\nSearc",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:30357,Integrability,wrap,wrapper,30357,"wrt an old benchmark, S22A; >>> database('df-mp2','S22',cp=1,subset=[16,17,8],benchmark='S22A'). >>> # [3] SAPT0 on the neon dimer dissociation curve; >>> db('sapt0',subset='NeNe',cp=0,symm=0,db_name='RGC10'). >>> # [4] Optimize system 1 in database S22, producing tables of scf and mp2 energy; >>> db('mp2','S22',db_func=optimize,subset=[1], tabulate=['mp2 total energy','current energy']). >>> # [5] CCSD on the smallest systems of HTBH, a hydrogen-transfer database; >>> database('ccsd','HTBH',subset='small', tabulate=['ccsd total energy', 'mp2 total energy']). """"""; lowername = name.lower(); kwargs = p4util.kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name.lower(); if not('db_name' in kwargs) and db_name:; kwargs['db_name'] = db_name. # Establish function to call; if not('db_func' in kwargs):; if ('func' in kwargs):; kwargs['db_func'] = kwargs['func']; del kwargs['func']; else:; kwargs['db_func'] = energy; func = kwargs['db_func']; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper database.' % (func.__name__)); if (func is cp):; raise ValidationError('Wrapper database is unhappy to be calling function \'%s\'. Use the cp keyword within database instead.' % (func.__name__)). # Define path and load module for requested database; sys.path.append('%sdatabases' % (psi4.Process.environment[""PSIDATADIR""])); sys.path.append('%s/lib/databases' % psi4.psi_top_srcdir()); database = p4util.import_ignorecase(db_name); if database is None:; psi4.print_out('\nPython module for database %s failed to load\n\n' % (db_name)); psi4.print_out('\nSearch path that was tried:\n'); psi4.print_out("", "".join(map(str, sys.path))); raise ValidationError(""Python module loading problem for database "" + str(db_name)); else:; dbse = database.dbse; HRXN = database.HRXN; ACTV = database.ACTV; RXNM = database.RXNM; BIND = database.BIND; TAGL = database.TAGL; ",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:30437,Integrability,Wrap,Wrapper,30437,"4] Optimize system 1 in database S22, producing tables of scf and mp2 energy; >>> db('mp2','S22',db_func=optimize,subset=[1], tabulate=['mp2 total energy','current energy']). >>> # [5] CCSD on the smallest systems of HTBH, a hydrogen-transfer database; >>> database('ccsd','HTBH',subset='small', tabulate=['ccsd total energy', 'mp2 total energy']). """"""; lowername = name.lower(); kwargs = p4util.kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name.lower(); if not('db_name' in kwargs) and db_name:; kwargs['db_name'] = db_name. # Establish function to call; if not('db_func' in kwargs):; if ('func' in kwargs):; kwargs['db_func'] = kwargs['func']; del kwargs['func']; else:; kwargs['db_func'] = energy; func = kwargs['db_func']; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper database.' % (func.__name__)); if (func is cp):; raise ValidationError('Wrapper database is unhappy to be calling function \'%s\'. Use the cp keyword within database instead.' % (func.__name__)). # Define path and load module for requested database; sys.path.append('%sdatabases' % (psi4.Process.environment[""PSIDATADIR""])); sys.path.append('%s/lib/databases' % psi4.psi_top_srcdir()); database = p4util.import_ignorecase(db_name); if database is None:; psi4.print_out('\nPython module for database %s failed to load\n\n' % (db_name)); psi4.print_out('\nSearch path that was tried:\n'); psi4.print_out("", "".join(map(str, sys.path))); raise ValidationError(""Python module loading problem for database "" + str(db_name)); else:; dbse = database.dbse; HRXN = database.HRXN; ACTV = database.ACTV; RXNM = database.RXNM; BIND = database.BIND; TAGL = database.TAGL; GEOS = database.GEOS; try:; DATA = database.DATA; except AttributeError:; DATA = {}. # Must collect (here) and set (below) basis sets after every new molecule activation; user_basis = psi4.get_global_option('BASIS'); ",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:38070,Integrability,wrap,wrapper,38070,"subset \'%s\' not available for database %s.' % (db_subset, db_name)); else:; temp = []; for rxn in db_subset:; if rxn in HRXN:; temp.append(rxn); else:; raise ValidationError('Subset element \'%s\' not a member of database %s.' % (str(rxn), db_name)); HRXN = temp. temp = []; for rxn in HRXN:; temp.append(ACTV['%s-%s' % (dbse, rxn)]); HSYS = p4util.drop_duplicates(sum(temp, [])). # Sow all the necessary reagent computations; psi4.print_out(""\n\n""); p4util.banner((""Database %s Computation"" % (db_name))); psi4.print_out(""\n""). # write index of calcs to output file; if (db_mode.lower() == 'continuous'):; instructions = """"""\n The database single-job procedure has been selected through mode='continuous'.\n""""""; instructions += """""" Calculations for the reagents will proceed in the order below and will be followed\n""""""; instructions += """""" by summary results for the database.\n\n""""""; for rgt in HSYS:; instructions += """""" %-s\n"""""" % (rgt); instructions += """"""\n Alternatively, a farming-out of the database calculations may be accessed through\n""""""; instructions += """""" the database wrapper option mode='sow'/'reap'.\n\n""""""; psi4.print_out(instructions). # write sow/reap instructions and index of calcs to output file and reap input file; if (db_mode.lower() == 'sow'):; instructions = """"""\n The database sow/reap procedure has been selected through mode='sow'. In addition\n""""""; instructions += """""" to this output file (which contains no quantum chemical calculations), this job\n""""""; instructions += """""" has produced a number of input files (%s-*.in) for individual database members\n"""""" % (dbse); instructions += """""" and a single input file (%s-master.in) with a database(mode='reap') command.\n"""""" % (dbse); instructions += """""" The former may look very peculiar since processed and pickled python rather than\n""""""; instructions += """""" raw input is written. Follow the instructions below to continue.\n\n""""""; instructions += """""" (1) Run all of the %s-*.in input files on any variety of comput",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:39727,Integrability,wrap,wrapper,39727,"ap') command.\n"""""" % (dbse); instructions += """""" The former may look very peculiar since processed and pickled python rather than\n""""""; instructions += """""" raw input is written. Follow the instructions below to continue.\n\n""""""; instructions += """""" (1) Run all of the %s-*.in input files on any variety of computer architecture.\n"""""" % (dbse); instructions += """""" The output file names must be as given below.\n\n""""""; for rgt in HSYS:; instructions += """""" psi4 -i %-27s -o %-27s\n"""""" % (rgt + '.in', rgt + '.out'); instructions += """"""\n (2) Gather all the resulting output files in a directory. Place input file\n""""""; instructions += """""" %s-master.in into that directory and run it. The job will be trivial in\n"""""" % (dbse); instructions += """""" length and give summary results for the database in its output file.\n\n""""""; instructions += """""" psi4 -i %-27s -o %-27s\n\n"""""" % (dbse + '-master.in', dbse + '-master.out'); instructions += """""" Alternatively, a single-job execution of the database may be accessed through\n""""""; instructions += """""" the database wrapper option mode='continuous'.\n\n""""""; psi4.print_out(instructions). fmaster = open('%s-master.in' % (dbse), 'w'); fmaster.write('# This is a psi4 input file auto-generated from the database() wrapper.\n\n'); fmaster.write(""database('%s', '%s', mode='reap', cp='%s', rlxd='%s', zpe='%s', benchmark='%s', linkage=%d, subset=%s, tabulate=%s)\n\n"" %; (name, db_name, db_cp, db_rlxd, db_zpe, db_benchmark, os.getpid(), HRXN, db_tabulate)); fmaster.close(). # Loop through chemical systems; ERGT = {}; ERXN = {}; VRGT = {}; VRXN = {}; for rgt in HSYS:; VRGT[rgt] = {}. # extra definition of molecule so that logic in building commands string has something to act on; exec(p4util.format_molecule_for_input(GEOS[rgt])); molecule = psi4.get_active_molecule(). # build string of title banner; banners = ''; banners += """"""psi4.print_out('\\n')\n""""""; banners += """"""p4util.banner(' Database %s Computation: Reagent %s \\n %s')\n"""""" % (db_name, rgt, TAGL[",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:39923,Integrability,wrap,wrapper,39923,"n\n""""""; instructions += """""" (1) Run all of the %s-*.in input files on any variety of computer architecture.\n"""""" % (dbse); instructions += """""" The output file names must be as given below.\n\n""""""; for rgt in HSYS:; instructions += """""" psi4 -i %-27s -o %-27s\n"""""" % (rgt + '.in', rgt + '.out'); instructions += """"""\n (2) Gather all the resulting output files in a directory. Place input file\n""""""; instructions += """""" %s-master.in into that directory and run it. The job will be trivial in\n"""""" % (dbse); instructions += """""" length and give summary results for the database in its output file.\n\n""""""; instructions += """""" psi4 -i %-27s -o %-27s\n\n"""""" % (dbse + '-master.in', dbse + '-master.out'); instructions += """""" Alternatively, a single-job execution of the database may be accessed through\n""""""; instructions += """""" the database wrapper option mode='continuous'.\n\n""""""; psi4.print_out(instructions). fmaster = open('%s-master.in' % (dbse), 'w'); fmaster.write('# This is a psi4 input file auto-generated from the database() wrapper.\n\n'); fmaster.write(""database('%s', '%s', mode='reap', cp='%s', rlxd='%s', zpe='%s', benchmark='%s', linkage=%d, subset=%s, tabulate=%s)\n\n"" %; (name, db_name, db_cp, db_rlxd, db_zpe, db_benchmark, os.getpid(), HRXN, db_tabulate)); fmaster.close(). # Loop through chemical systems; ERGT = {}; ERXN = {}; VRGT = {}; VRXN = {}; for rgt in HSYS:; VRGT[rgt] = {}. # extra definition of molecule so that logic in building commands string has something to act on; exec(p4util.format_molecule_for_input(GEOS[rgt])); molecule = psi4.get_active_molecule(). # build string of title banner; banners = ''; banners += """"""psi4.print_out('\\n')\n""""""; banners += """"""p4util.banner(' Database %s Computation: Reagent %s \\n %s')\n"""""" % (db_name, rgt, TAGL[rgt]); banners += """"""psi4.print_out('\\n')\n\n"""""". # build string of lines that defines contribution of rgt to each rxn; actives = ''; actives += """"""psi4.print_out(' Database Contributions Map:\\n %s\\n')\n"""""" % ('-' * 7",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:41874,Integrability,wrap,wrapper,41874,"rxn; actives = ''; actives += """"""psi4.print_out(' Database Contributions Map:\\n %s\\n')\n"""""" % ('-' * 75); for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn); if rgt in ACTV[db_rxn]:; actives += """"""psi4.print_out(' reagent %s contributes by %.4f to reaction %s\\n')\n"""""" \; % (rgt, RXNM[db_rxn][rgt], db_rxn); actives += """"""psi4.print_out('\\n')\n\n"""""". # build string of commands for options from the input file TODO: handle local options too; commands = ''; commands += """"""\npsi4.set_memory(%s)\n\n"""""" % (user_memory); for chgdopt in psi4.get_global_option_list():; if psi4.has_global_option_changed(chgdopt):; chgdoptval = psi4.get_global_option(chgdopt); #chgdoptval = psi4.get_option(chgdopt); if isinstance(chgdoptval, basestring):; commands += """"""psi4.set_global_option('%s', '%s')\n"""""" % (chgdopt, chgdoptval); elif isinstance(chgdoptval, int) or isinstance(chgdoptval, float):; commands += """"""psi4.set_global_option('%s', %s)\n"""""" % (chgdopt, chgdoptval); else:; raise ValidationError('Option \'%s\' is not of a type (string, int, float, bool) that can be processed by database wrapper.' % (chgdopt)). # build string of molecule and commands that are dependent on the database; commands += '\n'; commands += """"""psi4.set_global_option('BASIS', '%s')\n"""""" % (user_basis); if not((user_df_basis_scf == """") or (user_df_basis_scf == 'NONE')):; commands += """"""psi4.set_global_option('DF_BASIS_SCF', '%s')\n"""""" % (user_df_basis_scf); if not((user_df_basis_mp2 == """") or (user_df_basis_mp2 == 'NONE')):; commands += """"""psi4.set_global_option('DF_BASIS_MP2', '%s')\n"""""" % (user_df_basis_mp2); if not((user_df_basis_sapt == """") or (user_df_basis_sapt == 'NONE')):; commands += """"""psi4.set_global_option('DF_BASIS_SAPT', '%s')\n"""""" % (user_df_basis_sapt); if not((user_df_basis_elst == """") or (user_df_basis_elst == 'NONE')):; commands += """"""psi4.set_global_option('DF_BASIS_ELST', '%s')\n"""""" % (user_df_basis_elst); commands += """"""molecule = psi4.get_active_molecule()\n""""""; commands += """"""molecule.upd",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:41947,Integrability,depend,dependent,41947,"n ACTV[db_rxn]:; actives += """"""psi4.print_out(' reagent %s contributes by %.4f to reaction %s\\n')\n"""""" \; % (rgt, RXNM[db_rxn][rgt], db_rxn); actives += """"""psi4.print_out('\\n')\n\n"""""". # build string of commands for options from the input file TODO: handle local options too; commands = ''; commands += """"""\npsi4.set_memory(%s)\n\n"""""" % (user_memory); for chgdopt in psi4.get_global_option_list():; if psi4.has_global_option_changed(chgdopt):; chgdoptval = psi4.get_global_option(chgdopt); #chgdoptval = psi4.get_option(chgdopt); if isinstance(chgdoptval, basestring):; commands += """"""psi4.set_global_option('%s', '%s')\n"""""" % (chgdopt, chgdoptval); elif isinstance(chgdoptval, int) or isinstance(chgdoptval, float):; commands += """"""psi4.set_global_option('%s', %s)\n"""""" % (chgdopt, chgdoptval); else:; raise ValidationError('Option \'%s\' is not of a type (string, int, float, bool) that can be processed by database wrapper.' % (chgdopt)). # build string of molecule and commands that are dependent on the database; commands += '\n'; commands += """"""psi4.set_global_option('BASIS', '%s')\n"""""" % (user_basis); if not((user_df_basis_scf == """") or (user_df_basis_scf == 'NONE')):; commands += """"""psi4.set_global_option('DF_BASIS_SCF', '%s')\n"""""" % (user_df_basis_scf); if not((user_df_basis_mp2 == """") or (user_df_basis_mp2 == 'NONE')):; commands += """"""psi4.set_global_option('DF_BASIS_MP2', '%s')\n"""""" % (user_df_basis_mp2); if not((user_df_basis_sapt == """") or (user_df_basis_sapt == 'NONE')):; commands += """"""psi4.set_global_option('DF_BASIS_SAPT', '%s')\n"""""" % (user_df_basis_sapt); if not((user_df_basis_elst == """") or (user_df_basis_elst == 'NONE')):; commands += """"""psi4.set_global_option('DF_BASIS_ELST', '%s')\n"""""" % (user_df_basis_elst); commands += """"""molecule = psi4.get_active_molecule()\n""""""; commands += """"""molecule.update_geometry()\n"""""". if symmetry_override:; commands += """"""molecule.reset_point_group('c1')\n""""""; commands += """"""molecule.fix_orientation(1)\n""""""; commands += """"""molec",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:44839,Integrability,wrap,wrapper,44839,"banners); exec(p4util.format_molecule_for_input(GEOS[rgt])); exec(commands); #print 'MOLECULE LIVES %23s %8s %4d %4d %4s' % (rgt, psi4.get_global_option('REFERENCE'),; # molecule.molecular_charge(), molecule.multiplicity(), molecule.schoenflies_symbol()); psi4.set_variable('NATOM', molecule.natom()); psi4.set_variable('NUCLEAR REPULSION ENERGY', molecule.nuclear_repulsion_energy()); if re.match(r'^verify', lowername):; compare_values(DATA['NUCLEAR REPULSION ENERGY'][rgt], psi4.get_variable('NUCLEAR REPULSION ENERGY'),; 4, '%s %.4f' % (rgt, psi4.get_variable('NUCLEAR REPULSION ENERGY'))); ERGT[rgt] = 7.0; else:; ERGT[rgt] = call_function_in_1st_argument(func, **kwargs); #print ERGT[rgt]; psi4.print_variables(); exec(actives); for envv in db_tabulate:; VRGT[rgt][envv.upper()] = psi4.get_variable(envv); psi4.set_global_option(""REFERENCE"", user_reference); psi4.clean(). elif (db_mode.lower() == 'sow'):; freagent = open('%s.in' % (rgt), 'w'); freagent.write('# This is a psi4 input file auto-generated from the database() wrapper.\n\n'); freagent.write(banners); freagent.write(p4util.format_molecule_for_input(GEOS[rgt])). freagent.write(commands); freagent.write('''\npickle_kw = (""""""'''); pickle.dump(kwargs, freagent); freagent.write('''"""""")\n'''); freagent.write(""""""\nkwargs = pickle.loads(pickle_kw)\n""""""); freagent.write(""""""electronic_energy = %s(**kwargs)\n\n"""""" % (func.__name__)); freagent.write(""""""psi4.print_variables()\n""""""); freagent.write(""""""psi4.print_out('\\nDATABASE RESULT: computation %d for reagent %s """"""; % (os.getpid(), rgt)); freagent.write(""""""yields electronic energy %20.12f\\n' % (electronic_energy))\n\n""""""); freagent.write(""""""psi4.set_variable('NATOM', molecule.natom())\n""""""); for envv in db_tabulate:; freagent.write(""""""psi4.print_out('DATABASE RESULT: computation %d for reagent %s """"""; % (os.getpid(), rgt)); freagent.write(""""""yields variable value %20.12f for variable %s\\n' % (psi4.get_variable(""""""); freagent.write(""""""'%s'), '%s'))\n"""""" % (envv.upper(),",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:48132,Integrability,Depend,Depending,48132,"ut('DATABASE RESULT: variable %s value = %20.12f\n' % (envv, VRGT[rgt][envv])); freagent.close(). # end sow after writing files; if (db_mode.lower() == 'sow'):; return 0.0. # Reap all the necessary reaction computations; psi4.print_out(""\n""); p4util.banner((""Database %s Results"" % (db_name))); psi4.print_out(""\n""). maxactv = []; for rxn in HRXN:; maxactv.append(len(ACTV[dbse + '-' + str(rxn)])); maxrgt = max(maxactv); table_delimit = '-' * (54 + 20 * maxrgt); tables = ''. # find any reactions that are incomplete; FAIL = collections.defaultdict(int); for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn); for i in range(len(ACTV[db_rxn])):; if abs(ERGT[ACTV[db_rxn][i]]) < 1.0e-12:; FAIL[rxn] = 1. # tabulate requested process::environment variables; tables += """""" For each VARIABLE requested by tabulate, a 'Reaction Value' will be formed from\n""""""; tables += """""" 'Reagent' values according to weightings 'Wt', as for the REQUESTED ENERGY below.\n""""""; tables += """""" Depending on the nature of the variable, this may or may not make any physical sense.\n""""""; for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn); VRXN[db_rxn] = {}. for envv in db_tabulate:; envv = envv.upper(); tables += """"""\n ==> %s <==\n\n"""""" % (envv.title()); tables += tblhead(maxrgt, table_delimit, 2). for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn). if FAIL[rxn]:; tables += """"""\n%23s %8s %8s %8s"""""" % (db_rxn, '', '****', ''); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (VRGT[ACTV[db_rxn][i]][envv], RXNM[db_rxn][ACTV[db_rxn][i]]). else:; VRXN[db_rxn][envv] = 0.0; for i in range(len(ACTV[db_rxn])):; VRXN[db_rxn][envv] += VRGT[ACTV[db_rxn][i]][envv] * RXNM[db_rxn][ACTV[db_rxn][i]]. tables += """"""\n%23s %16.8f """""" % (db_rxn, VRXN[db_rxn][envv]); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (VRGT[ACTV[db_rxn][i]][envv], RXNM[db_rxn][ACTV[db_rxn][i]]); tables += """"""\n %s\n"""""" % (table_delimit). # tabulate primary requested energy variable with statistics; count_rxn = 0; minD",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:63525,Integrability,Wrap,Wrap,63525,"eme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2). >>> # [6] a D-zeta ccsd(t) correction atop a DT-zeta extrapolated ccsd cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >>> cbs('mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2, delta2_wfn='ccsd(t)', delta2_wfn_lesser='ccsd', delta2_basis='aug-cc-pvdz'). >>> # [7] cbs() coupled with database(); >>> database('mp2', 'BASIC', subset=['h2o','nh3'], symm='on', func=cbs, corl_basis='cc-pV[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='sto-3g'). >>> # [8] cbs() coupled with optimize(); >>> optimize('mp2', corl_basis='cc-pV[DT]Z', corl_scheme=corl_xtpl_helgaker_2, func=cbs). """"""; lowername = name.lower(); kwargs = p4util.kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name.lower(). # Establish function to call (only energy makes sense for cbs); if not('cbs_func' in kwargs):; if ('func' in kwargs):; kwargs['cbs_func'] = kwargs['func']; del kwargs['func']; else:; kwargs['cbs_func'] = energy; func = kwargs['cbs_func']; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper complete_basis_set.' % (func.__name__)); if not(func is energy):; raise ValidationError('Wrapper complete_basis_set is unhappy to be calling function \'%s\' instead of \'energy\'.' % (func.__name__)). # Define some quantum chemical knowledge, namely what methods are subsumed in others; VARH = {}; VARH['scf'] = { 'scftot': 'SCF TOTAL ENERGY'}; VARH['oldmp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'oldmp2corl': 'MP2 CORRELATION ENERGY'}; VARH['mp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY'}; VARH['mp2.5'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORREL",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:63589,Integrability,wrap,wrappers,63589,"eme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2). >>> # [6] a D-zeta ccsd(t) correction atop a DT-zeta extrapolated ccsd cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >>> cbs('mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2, delta2_wfn='ccsd(t)', delta2_wfn_lesser='ccsd', delta2_basis='aug-cc-pvdz'). >>> # [7] cbs() coupled with database(); >>> database('mp2', 'BASIC', subset=['h2o','nh3'], symm='on', func=cbs, corl_basis='cc-pV[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='sto-3g'). >>> # [8] cbs() coupled with optimize(); >>> optimize('mp2', corl_basis='cc-pV[DT]Z', corl_scheme=corl_xtpl_helgaker_2, func=cbs). """"""; lowername = name.lower(); kwargs = p4util.kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name.lower(). # Establish function to call (only energy makes sense for cbs); if not('cbs_func' in kwargs):; if ('func' in kwargs):; kwargs['cbs_func'] = kwargs['func']; del kwargs['func']; else:; kwargs['cbs_func'] = energy; func = kwargs['cbs_func']; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper complete_basis_set.' % (func.__name__)); if not(func is energy):; raise ValidationError('Wrapper complete_basis_set is unhappy to be calling function \'%s\' instead of \'energy\'.' % (func.__name__)). # Define some quantum chemical knowledge, namely what methods are subsumed in others; VARH = {}; VARH['scf'] = { 'scftot': 'SCF TOTAL ENERGY'}; VARH['oldmp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'oldmp2corl': 'MP2 CORRELATION ENERGY'}; VARH['mp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY'}; VARH['mp2.5'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORREL",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:63990,Integrability,wrap,wrapper,63990,"gy atop a Q-zeta reference; >>> cbs('mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2, delta2_wfn='ccsd(t)', delta2_wfn_lesser='ccsd', delta2_basis='aug-cc-pvdz'). >>> # [7] cbs() coupled with database(); >>> database('mp2', 'BASIC', subset=['h2o','nh3'], symm='on', func=cbs, corl_basis='cc-pV[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='sto-3g'). >>> # [8] cbs() coupled with optimize(); >>> optimize('mp2', corl_basis='cc-pV[DT]Z', corl_scheme=corl_xtpl_helgaker_2, func=cbs). """"""; lowername = name.lower(); kwargs = p4util.kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name.lower(). # Establish function to call (only energy makes sense for cbs); if not('cbs_func' in kwargs):; if ('func' in kwargs):; kwargs['cbs_func'] = kwargs['func']; del kwargs['func']; else:; kwargs['cbs_func'] = energy; func = kwargs['cbs_func']; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper complete_basis_set.' % (func.__name__)); if not(func is energy):; raise ValidationError('Wrapper complete_basis_set is unhappy to be calling function \'%s\' instead of \'energy\'.' % (func.__name__)). # Define some quantum chemical knowledge, namely what methods are subsumed in others; VARH = {}; VARH['scf'] = { 'scftot': 'SCF TOTAL ENERGY'}; VARH['oldmp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'oldmp2corl': 'MP2 CORRELATION ENERGY'}; VARH['mp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY'}; VARH['mp2.5'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY'}; VARH['mp3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION E",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:64087,Integrability,Wrap,Wrapper,64087,"z'). >>> # [7] cbs() coupled with database(); >>> database('mp2', 'BASIC', subset=['h2o','nh3'], symm='on', func=cbs, corl_basis='cc-pV[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='sto-3g'). >>> # [8] cbs() coupled with optimize(); >>> optimize('mp2', corl_basis='cc-pV[DT]Z', corl_scheme=corl_xtpl_helgaker_2, func=cbs). """"""; lowername = name.lower(); kwargs = p4util.kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name.lower(). # Establish function to call (only energy makes sense for cbs); if not('cbs_func' in kwargs):; if ('func' in kwargs):; kwargs['cbs_func'] = kwargs['func']; del kwargs['func']; else:; kwargs['cbs_func'] = energy; func = kwargs['cbs_func']; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper complete_basis_set.' % (func.__name__)); if not(func is energy):; raise ValidationError('Wrapper complete_basis_set is unhappy to be calling function \'%s\' instead of \'energy\'.' % (func.__name__)). # Define some quantum chemical knowledge, namely what methods are subsumed in others; VARH = {}; VARH['scf'] = { 'scftot': 'SCF TOTAL ENERGY'}; VARH['oldmp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'oldmp2corl': 'MP2 CORRELATION ENERGY'}; VARH['mp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY'}; VARH['mp2.5'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY'}; VARH['mp3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY'}; VARH['mp4(sdq)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY'}; VARH['mp4'] = { 'scftot': 'SCF TO",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:70839,Integrability,wrap,wrapper,70839,"er_df_basis_cc = psi4.get_option('DF_BASIS_CC'); #user_df_basis_sapt = psi4.get_option('DF_BASIS_SAPT'); #user_df_basis_elst = psi4.get_option('DF_BASIS_ELST'); b_user_wfn = psi4.has_global_option_changed('WFN'); user_wfn = psi4.get_global_option('WFN'). user_writer_file_label = psi4.get_global_option('WRITER_FILE_LABEL'). # Make sure the molecule the user provided is the active one; if 'molecule' in kwargs:; activate(kwargs['molecule']); del kwargs['molecule']; molecule = psi4.get_active_molecule(); molecule.update_geometry(); psi4.set_global_option(""BASIS"", psi4.get_global_option(""BASIS"")). # Establish method for correlation energy; if 'name' in kwargs:; if (lowername == 'scf') or (lowername == 'df-scf'):; pass; else:; do_corl = 1; cbs_corl_wfn = kwargs['name'].lower(); if 'corl_wfn' in kwargs:; do_corl = 1; cbs_corl_wfn = kwargs['corl_wfn'].lower(); if do_corl:; if not (cbs_corl_wfn in VARH.keys()):; raise ValidationError('Requested CORL method \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_corl_wfn)). # Establish method for delta correction energy; if 'delta_wfn' in kwargs:; do_delta = 1; cbs_delta_wfn = kwargs['delta_wfn'].lower(); if not (cbs_delta_wfn in VARH.keys()):; raise ValidationError('Requested DELTA method \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta_wfn)). if 'delta_wfn_lesser' in kwargs:; cbs_delta_wfn_lesser = kwargs['delta_wfn_lesser'].lower(); else:; cbs_delta_wfn_lesser = 'mp2'; if not (cbs_delta_wfn_lesser in VARH.keys()):; raise ValidationError('Requested DELTA method lesser \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta_wfn_lesser)). # Establish method for second delta correction energy; if 'delta2_wfn' in kwargs:; do_delta2 = 1; cbs_delta2_wfn = kwargs['delta2_wfn'].lower(); if not (cbs_delta2_wfn in VARH.keys()):; raise ValidationError('Requested DELTA2 method \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta2_wfn)",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:71146,Integrability,wrap,wrapper,71146,"TER_FILE_LABEL'). # Make sure the molecule the user provided is the active one; if 'molecule' in kwargs:; activate(kwargs['molecule']); del kwargs['molecule']; molecule = psi4.get_active_molecule(); molecule.update_geometry(); psi4.set_global_option(""BASIS"", psi4.get_global_option(""BASIS"")). # Establish method for correlation energy; if 'name' in kwargs:; if (lowername == 'scf') or (lowername == 'df-scf'):; pass; else:; do_corl = 1; cbs_corl_wfn = kwargs['name'].lower(); if 'corl_wfn' in kwargs:; do_corl = 1; cbs_corl_wfn = kwargs['corl_wfn'].lower(); if do_corl:; if not (cbs_corl_wfn in VARH.keys()):; raise ValidationError('Requested CORL method \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_corl_wfn)). # Establish method for delta correction energy; if 'delta_wfn' in kwargs:; do_delta = 1; cbs_delta_wfn = kwargs['delta_wfn'].lower(); if not (cbs_delta_wfn in VARH.keys()):; raise ValidationError('Requested DELTA method \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta_wfn)). if 'delta_wfn_lesser' in kwargs:; cbs_delta_wfn_lesser = kwargs['delta_wfn_lesser'].lower(); else:; cbs_delta_wfn_lesser = 'mp2'; if not (cbs_delta_wfn_lesser in VARH.keys()):; raise ValidationError('Requested DELTA method lesser \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta_wfn_lesser)). # Establish method for second delta correction energy; if 'delta2_wfn' in kwargs:; do_delta2 = 1; cbs_delta2_wfn = kwargs['delta2_wfn'].lower(); if not (cbs_delta2_wfn in VARH.keys()):; raise ValidationError('Requested DELTA2 method \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta2_wfn)). if 'delta2_wfn_lesser' in kwargs:; cbs_delta2_wfn_lesser = kwargs['delta2_wfn_lesser'].lower(); else:; cbs_delta2_wfn_lesser = 'mp2'; if not (cbs_delta2_wfn_lesser in VARH.keys()):; raise ValidationError('Requested DELTA2 method lesser \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' ",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:71464,Integrability,wrap,wrapper,71464,rrelation energy; if 'name' in kwargs:; if (lowername == 'scf') or (lowername == 'df-scf'):; pass; else:; do_corl = 1; cbs_corl_wfn = kwargs['name'].lower(); if 'corl_wfn' in kwargs:; do_corl = 1; cbs_corl_wfn = kwargs['corl_wfn'].lower(); if do_corl:; if not (cbs_corl_wfn in VARH.keys()):; raise ValidationError('Requested CORL method \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_corl_wfn)). # Establish method for delta correction energy; if 'delta_wfn' in kwargs:; do_delta = 1; cbs_delta_wfn = kwargs['delta_wfn'].lower(); if not (cbs_delta_wfn in VARH.keys()):; raise ValidationError('Requested DELTA method \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta_wfn)). if 'delta_wfn_lesser' in kwargs:; cbs_delta_wfn_lesser = kwargs['delta_wfn_lesser'].lower(); else:; cbs_delta_wfn_lesser = 'mp2'; if not (cbs_delta_wfn_lesser in VARH.keys()):; raise ValidationError('Requested DELTA method lesser \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta_wfn_lesser)). # Establish method for second delta correction energy; if 'delta2_wfn' in kwargs:; do_delta2 = 1; cbs_delta2_wfn = kwargs['delta2_wfn'].lower(); if not (cbs_delta2_wfn in VARH.keys()):; raise ValidationError('Requested DELTA2 method \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta2_wfn)). if 'delta2_wfn_lesser' in kwargs:; cbs_delta2_wfn_lesser = kwargs['delta2_wfn_lesser'].lower(); else:; cbs_delta2_wfn_lesser = 'mp2'; if not (cbs_delta2_wfn_lesser in VARH.keys()):; raise ValidationError('Requested DELTA2 method lesser \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta2_wfn_lesser)). # Establish method for third delta correction energy; if 'delta3_wfn' in kwargs:; do_delta3 = 1; cbs_delta3_wfn = kwargs['delta3_wfn'].lower(); if not (cbs_delta3_wfn in VARH.keys()):; raise ValidationError('Requested DELTA3 method \'%s\' is not recognized. Add it to VARH in wrapper.py to ,MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:71792,Integrability,wrap,wrapper,71792,L method \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_corl_wfn)). # Establish method for delta correction energy; if 'delta_wfn' in kwargs:; do_delta = 1; cbs_delta_wfn = kwargs['delta_wfn'].lower(); if not (cbs_delta_wfn in VARH.keys()):; raise ValidationError('Requested DELTA method \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta_wfn)). if 'delta_wfn_lesser' in kwargs:; cbs_delta_wfn_lesser = kwargs['delta_wfn_lesser'].lower(); else:; cbs_delta_wfn_lesser = 'mp2'; if not (cbs_delta_wfn_lesser in VARH.keys()):; raise ValidationError('Requested DELTA method lesser \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta_wfn_lesser)). # Establish method for second delta correction energy; if 'delta2_wfn' in kwargs:; do_delta2 = 1; cbs_delta2_wfn = kwargs['delta2_wfn'].lower(); if not (cbs_delta2_wfn in VARH.keys()):; raise ValidationError('Requested DELTA2 method \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta2_wfn)). if 'delta2_wfn_lesser' in kwargs:; cbs_delta2_wfn_lesser = kwargs['delta2_wfn_lesser'].lower(); else:; cbs_delta2_wfn_lesser = 'mp2'; if not (cbs_delta2_wfn_lesser in VARH.keys()):; raise ValidationError('Requested DELTA2 method lesser \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta2_wfn_lesser)). # Establish method for third delta correction energy; if 'delta3_wfn' in kwargs:; do_delta3 = 1; cbs_delta3_wfn = kwargs['delta3_wfn'].lower(); if not (cbs_delta3_wfn in VARH.keys()):; raise ValidationError('Requested DELTA3 method \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta3_wfn)). if 'delta3_wfn_lesser' in kwargs:; cbs_delta3_wfn_lesser = kwargs['delta3_wfn_lesser'].lower(); else:; cbs_delta3_wfn_lesser = 'mp2'; if not (cbs_delta3_wfn_lesser in VARH.keys()):; raise ValidationError('Requested DELTA3 method lesser \'%s\' is not recognized. Add it to VARH in wrapper.py to pro,MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:72117,Integrability,wrap,wrapper,72117, not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta_wfn)). if 'delta_wfn_lesser' in kwargs:; cbs_delta_wfn_lesser = kwargs['delta_wfn_lesser'].lower(); else:; cbs_delta_wfn_lesser = 'mp2'; if not (cbs_delta_wfn_lesser in VARH.keys()):; raise ValidationError('Requested DELTA method lesser \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta_wfn_lesser)). # Establish method for second delta correction energy; if 'delta2_wfn' in kwargs:; do_delta2 = 1; cbs_delta2_wfn = kwargs['delta2_wfn'].lower(); if not (cbs_delta2_wfn in VARH.keys()):; raise ValidationError('Requested DELTA2 method \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta2_wfn)). if 'delta2_wfn_lesser' in kwargs:; cbs_delta2_wfn_lesser = kwargs['delta2_wfn_lesser'].lower(); else:; cbs_delta2_wfn_lesser = 'mp2'; if not (cbs_delta2_wfn_lesser in VARH.keys()):; raise ValidationError('Requested DELTA2 method lesser \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta2_wfn_lesser)). # Establish method for third delta correction energy; if 'delta3_wfn' in kwargs:; do_delta3 = 1; cbs_delta3_wfn = kwargs['delta3_wfn'].lower(); if not (cbs_delta3_wfn in VARH.keys()):; raise ValidationError('Requested DELTA3 method \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta3_wfn)). if 'delta3_wfn_lesser' in kwargs:; cbs_delta3_wfn_lesser = kwargs['delta3_wfn_lesser'].lower(); else:; cbs_delta3_wfn_lesser = 'mp2'; if not (cbs_delta3_wfn_lesser in VARH.keys()):; raise ValidationError('Requested DELTA3 method lesser \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta3_wfn_lesser)). # Establish method for fourth delta correction energy; if 'delta4_wfn' in kwargs:; do_delta4 = 1; cbs_delta4_wfn = kwargs['delta4_wfn'].lower(); if not (cbs_delta4_wfn in VARH.keys()):; raise ValidationError('Requested DELTA4 method \'%s\' is not recognized. Add it to VARH in wrapper.py to,MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:72445,Integrability,wrap,wrapper,72445,nized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta_wfn_lesser)). # Establish method for second delta correction energy; if 'delta2_wfn' in kwargs:; do_delta2 = 1; cbs_delta2_wfn = kwargs['delta2_wfn'].lower(); if not (cbs_delta2_wfn in VARH.keys()):; raise ValidationError('Requested DELTA2 method \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta2_wfn)). if 'delta2_wfn_lesser' in kwargs:; cbs_delta2_wfn_lesser = kwargs['delta2_wfn_lesser'].lower(); else:; cbs_delta2_wfn_lesser = 'mp2'; if not (cbs_delta2_wfn_lesser in VARH.keys()):; raise ValidationError('Requested DELTA2 method lesser \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta2_wfn_lesser)). # Establish method for third delta correction energy; if 'delta3_wfn' in kwargs:; do_delta3 = 1; cbs_delta3_wfn = kwargs['delta3_wfn'].lower(); if not (cbs_delta3_wfn in VARH.keys()):; raise ValidationError('Requested DELTA3 method \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta3_wfn)). if 'delta3_wfn_lesser' in kwargs:; cbs_delta3_wfn_lesser = kwargs['delta3_wfn_lesser'].lower(); else:; cbs_delta3_wfn_lesser = 'mp2'; if not (cbs_delta3_wfn_lesser in VARH.keys()):; raise ValidationError('Requested DELTA3 method lesser \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta3_wfn_lesser)). # Establish method for fourth delta correction energy; if 'delta4_wfn' in kwargs:; do_delta4 = 1; cbs_delta4_wfn = kwargs['delta4_wfn'].lower(); if not (cbs_delta4_wfn in VARH.keys()):; raise ValidationError('Requested DELTA4 method \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta4_wfn)). if 'delta4_wfn_lesser' in kwargs:; cbs_delta4_wfn_lesser = kwargs['delta4_wfn_lesser'].lower(); else:; cbs_delta4_wfn_lesser = 'mp2'; if not (cbs_delta4_wfn_lesser in VARH.keys()):; raise ValidationError('Requested DELTA4 method lesser \'%s\' is not recognized. Add it to VARH in wrapper.py to pr,MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:72770,Integrability,wrap,wrapper,72770,cognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta2_wfn)). if 'delta2_wfn_lesser' in kwargs:; cbs_delta2_wfn_lesser = kwargs['delta2_wfn_lesser'].lower(); else:; cbs_delta2_wfn_lesser = 'mp2'; if not (cbs_delta2_wfn_lesser in VARH.keys()):; raise ValidationError('Requested DELTA2 method lesser \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta2_wfn_lesser)). # Establish method for third delta correction energy; if 'delta3_wfn' in kwargs:; do_delta3 = 1; cbs_delta3_wfn = kwargs['delta3_wfn'].lower(); if not (cbs_delta3_wfn in VARH.keys()):; raise ValidationError('Requested DELTA3 method \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta3_wfn)). if 'delta3_wfn_lesser' in kwargs:; cbs_delta3_wfn_lesser = kwargs['delta3_wfn_lesser'].lower(); else:; cbs_delta3_wfn_lesser = 'mp2'; if not (cbs_delta3_wfn_lesser in VARH.keys()):; raise ValidationError('Requested DELTA3 method lesser \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta3_wfn_lesser)). # Establish method for fourth delta correction energy; if 'delta4_wfn' in kwargs:; do_delta4 = 1; cbs_delta4_wfn = kwargs['delta4_wfn'].lower(); if not (cbs_delta4_wfn in VARH.keys()):; raise ValidationError('Requested DELTA4 method \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta4_wfn)). if 'delta4_wfn_lesser' in kwargs:; cbs_delta4_wfn_lesser = kwargs['delta4_wfn_lesser'].lower(); else:; cbs_delta4_wfn_lesser = 'mp2'; if not (cbs_delta4_wfn_lesser in VARH.keys()):; raise ValidationError('Requested DELTA4 method lesser \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta4_wfn_lesser)). # Establish method for fifth delta correction energy; if 'delta5_wfn' in kwargs:; do_delta5 = 1; cbs_delta5_wfn = kwargs['delta5_wfn'].lower(); if not (cbs_delta5_wfn in VARH.keys()):; raise ValidationError('Requested DELTA5 method \'%s\' is not recognized. Add it to VARH in wrapper.py to,MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:73099,Integrability,wrap,wrapper,73099,ized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta2_wfn_lesser)). # Establish method for third delta correction energy; if 'delta3_wfn' in kwargs:; do_delta3 = 1; cbs_delta3_wfn = kwargs['delta3_wfn'].lower(); if not (cbs_delta3_wfn in VARH.keys()):; raise ValidationError('Requested DELTA3 method \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta3_wfn)). if 'delta3_wfn_lesser' in kwargs:; cbs_delta3_wfn_lesser = kwargs['delta3_wfn_lesser'].lower(); else:; cbs_delta3_wfn_lesser = 'mp2'; if not (cbs_delta3_wfn_lesser in VARH.keys()):; raise ValidationError('Requested DELTA3 method lesser \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta3_wfn_lesser)). # Establish method for fourth delta correction energy; if 'delta4_wfn' in kwargs:; do_delta4 = 1; cbs_delta4_wfn = kwargs['delta4_wfn'].lower(); if not (cbs_delta4_wfn in VARH.keys()):; raise ValidationError('Requested DELTA4 method \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta4_wfn)). if 'delta4_wfn_lesser' in kwargs:; cbs_delta4_wfn_lesser = kwargs['delta4_wfn_lesser'].lower(); else:; cbs_delta4_wfn_lesser = 'mp2'; if not (cbs_delta4_wfn_lesser in VARH.keys()):; raise ValidationError('Requested DELTA4 method lesser \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta4_wfn_lesser)). # Establish method for fifth delta correction energy; if 'delta5_wfn' in kwargs:; do_delta5 = 1; cbs_delta5_wfn = kwargs['delta5_wfn'].lower(); if not (cbs_delta5_wfn in VARH.keys()):; raise ValidationError('Requested DELTA5 method \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta5_wfn)). if 'delta5_wfn_lesser' in kwargs:; cbs_delta5_wfn_lesser = kwargs['delta5_wfn_lesser'].lower(); else:; cbs_delta5_wfn_lesser = 'mp2'; if not (cbs_delta5_wfn_lesser in VARH.keys()):; raise ValidationError('Requested DELTA5 method lesser \'%s\' is not recognized. Add it to VARH in wrapper.py to pro,MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:73424,Integrability,wrap,wrapper,73424,ognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta3_wfn)). if 'delta3_wfn_lesser' in kwargs:; cbs_delta3_wfn_lesser = kwargs['delta3_wfn_lesser'].lower(); else:; cbs_delta3_wfn_lesser = 'mp2'; if not (cbs_delta3_wfn_lesser in VARH.keys()):; raise ValidationError('Requested DELTA3 method lesser \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta3_wfn_lesser)). # Establish method for fourth delta correction energy; if 'delta4_wfn' in kwargs:; do_delta4 = 1; cbs_delta4_wfn = kwargs['delta4_wfn'].lower(); if not (cbs_delta4_wfn in VARH.keys()):; raise ValidationError('Requested DELTA4 method \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta4_wfn)). if 'delta4_wfn_lesser' in kwargs:; cbs_delta4_wfn_lesser = kwargs['delta4_wfn_lesser'].lower(); else:; cbs_delta4_wfn_lesser = 'mp2'; if not (cbs_delta4_wfn_lesser in VARH.keys()):; raise ValidationError('Requested DELTA4 method lesser \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta4_wfn_lesser)). # Establish method for fifth delta correction energy; if 'delta5_wfn' in kwargs:; do_delta5 = 1; cbs_delta5_wfn = kwargs['delta5_wfn'].lower(); if not (cbs_delta5_wfn in VARH.keys()):; raise ValidationError('Requested DELTA5 method \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta5_wfn)). if 'delta5_wfn_lesser' in kwargs:; cbs_delta5_wfn_lesser = kwargs['delta5_wfn_lesser'].lower(); else:; cbs_delta5_wfn_lesser = 'mp2'; if not (cbs_delta5_wfn_lesser in VARH.keys()):; raise ValidationError('Requested DELTA5 method lesser \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta5_wfn_lesser)). # Check that user isn't skipping steps in scf + corl + delta + delta2 sequence; if do_scf and not do_corl and not do_delta and not do_delta2 and not do_delta3 and not do_delta4 and not do_delta5:; pass; elif do_scf and do_corl and not do_delta and not do_delta2 and not do_delta3 and not do,MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:73752,Integrability,wrap,wrapper,73752,ized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta3_wfn_lesser)). # Establish method for fourth delta correction energy; if 'delta4_wfn' in kwargs:; do_delta4 = 1; cbs_delta4_wfn = kwargs['delta4_wfn'].lower(); if not (cbs_delta4_wfn in VARH.keys()):; raise ValidationError('Requested DELTA4 method \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta4_wfn)). if 'delta4_wfn_lesser' in kwargs:; cbs_delta4_wfn_lesser = kwargs['delta4_wfn_lesser'].lower(); else:; cbs_delta4_wfn_lesser = 'mp2'; if not (cbs_delta4_wfn_lesser in VARH.keys()):; raise ValidationError('Requested DELTA4 method lesser \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta4_wfn_lesser)). # Establish method for fifth delta correction energy; if 'delta5_wfn' in kwargs:; do_delta5 = 1; cbs_delta5_wfn = kwargs['delta5_wfn'].lower(); if not (cbs_delta5_wfn in VARH.keys()):; raise ValidationError('Requested DELTA5 method \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta5_wfn)). if 'delta5_wfn_lesser' in kwargs:; cbs_delta5_wfn_lesser = kwargs['delta5_wfn_lesser'].lower(); else:; cbs_delta5_wfn_lesser = 'mp2'; if not (cbs_delta5_wfn_lesser in VARH.keys()):; raise ValidationError('Requested DELTA5 method lesser \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta5_wfn_lesser)). # Check that user isn't skipping steps in scf + corl + delta + delta2 sequence; if do_scf and not do_corl and not do_delta and not do_delta2 and not do_delta3 and not do_delta4 and not do_delta5:; pass; elif do_scf and do_corl and not do_delta and not do_delta2 and not do_delta3 and not do_delta4 and not do_delta5:; pass; elif do_scf and do_corl and do_delta and not do_delta2 and not do_delta3 and not do_delta4 and not do_delta5:; pass; elif do_scf and do_corl and do_delta and do_delta2 and not do_delta3 and not do_delta4 and not do_delta5:; pass; elif do_scf and do_corl and do_delta and do_delta2 and do_delta3,MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:74077,Integrability,wrap,wrapper,74077,cognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta4_wfn)). if 'delta4_wfn_lesser' in kwargs:; cbs_delta4_wfn_lesser = kwargs['delta4_wfn_lesser'].lower(); else:; cbs_delta4_wfn_lesser = 'mp2'; if not (cbs_delta4_wfn_lesser in VARH.keys()):; raise ValidationError('Requested DELTA4 method lesser \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta4_wfn_lesser)). # Establish method for fifth delta correction energy; if 'delta5_wfn' in kwargs:; do_delta5 = 1; cbs_delta5_wfn = kwargs['delta5_wfn'].lower(); if not (cbs_delta5_wfn in VARH.keys()):; raise ValidationError('Requested DELTA5 method \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta5_wfn)). if 'delta5_wfn_lesser' in kwargs:; cbs_delta5_wfn_lesser = kwargs['delta5_wfn_lesser'].lower(); else:; cbs_delta5_wfn_lesser = 'mp2'; if not (cbs_delta5_wfn_lesser in VARH.keys()):; raise ValidationError('Requested DELTA5 method lesser \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta5_wfn_lesser)). # Check that user isn't skipping steps in scf + corl + delta + delta2 sequence; if do_scf and not do_corl and not do_delta and not do_delta2 and not do_delta3 and not do_delta4 and not do_delta5:; pass; elif do_scf and do_corl and not do_delta and not do_delta2 and not do_delta3 and not do_delta4 and not do_delta5:; pass; elif do_scf and do_corl and do_delta and not do_delta2 and not do_delta3 and not do_delta4 and not do_delta5:; pass; elif do_scf and do_corl and do_delta and do_delta2 and not do_delta3 and not do_delta4 and not do_delta5:; pass; elif do_scf and do_corl and do_delta and do_delta2 and do_delta3 and not do_delta4 and not do_delta5:; pass; elif do_scf and do_corl and do_delta and do_delta2 and do_delta3 and do_delta4 and not do_delta5:; pass; elif do_scf and do_corl and do_delta and do_delta2 and do_delta3 and do_delta4 and do_delta5:; pass; else:; raise ValidationError('Requested scf (%s) + corl (%s) + delta (%s) ,MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:84644,Integrability,depend,dependent,84644,"for indx_job, job in enumerate(JOBS):; for menial in VARH[job['f_wfn']]:; temp_wfn, temp_portion = split_menial(menial); JOBS_EXT.append(dict(zip(f_fields, [temp_wfn, temp_portion, job['f_basis'], job['f_zeta'], 0.0]))). #instructions += """"""\n Full listing of computations to be obtained (required and bonus).\n""""""; #for mc in JOBS_EXT:; # instructions += """""" %12s / %-24s for %s\n"""""" % (mc['f_wfn'], mc['f_basis'], VARH[mc['f_wfn']][mc['f_wfn']+mc['f_portion']]); psi4.print_out(instructions). psioh = psi4.IOManager.shared_object(); psioh.set_specific_retention(p4const.PSIF_SCF_MOS, True). # Run necessary computations; for mc in JOBS:; kwargs['name'] = mc['f_wfn']. # Build string of title banner; cbsbanners = ''; cbsbanners += """"""psi4.print_out('\\n')\n""""""; cbsbanners += """"""p4util.banner(' CBS Computation: %s / %s ')\n"""""" % (mc['f_wfn'].upper(), mc['f_basis'].upper()); cbsbanners += """"""psi4.print_out('\\n')\n\n""""""; exec(cbsbanners). # Build string of molecule and commands that are dependent on the database; commands = '\n'; commands += """"""\npsi4.set_global_option('BASIS', '%s')\n"""""" % (mc['f_basis']); commands += """"""psi4.set_global_option('WRITER_FILE_LABEL', '%s')\n"""""" % \; (user_writer_file_label + ('' if user_writer_file_label == '' else '-') + mc['f_wfn'].lower() + '-' + mc['f_basis'].lower()). exec(commands). # Make energy() call; mc['f_energy'] = call_function_in_1st_argument(func, **kwargs). # Fill in energies for subsumed methods; for menial in VARH[mc['f_wfn']]:; temp_wfn, temp_portion = split_menial(menial); for job in JOBS_EXT:; if (temp_wfn == job['f_wfn']) and (temp_portion == job['f_portion']) and (mc['f_basis'] == job['f_basis']):; job['f_energy'] = psi4.get_variable(VARH[temp_wfn][menial]). psi4.clean(). psioh.set_specific_retention(p4const.PSIF_SCF_MOS, False). # Build string of title banner; cbsbanners = ''; cbsbanners += """"""psi4.print_out('\\n')\n""""""; cbsbanners += """"""p4util.banner(' CBS Results ')\n""""""; cbsbanners += """"""psi4.print_out('\\n')\n\n""""""; ",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:90993,Integrability,wrap,wrappers,90993,"LATION ENERGY', finalenergy - GRAND_NEED[0]['d_energy']); psi4.set_variable('CBS TOTAL ENERGY', finalenergy); psi4.set_variable('CURRENT REFERENCE ENERGY', GRAND_NEED[0]['d_energy']); psi4.set_variable('CURRENT CORRELATION ENERGY', finalenergy - GRAND_NEED[0]['d_energy']); psi4.set_variable('CURRENT ENERGY', finalenergy); return finalenergy. # Transform and validate basis sets from 'cc-pV[Q5]Z' into [cc-pVQZ, cc-pV5Z] and [4, 5]; [docs]def validate_bracketed_basis(basisstring):; r""""""Function to transform and validate basis sets for cbs(). A basis set with no; paired square brackets is passed through with zeta level 0 (e.g., '6-31+G(d,p)'; is returned as [6-31+G(d,p)] and [0]). A basis set with square brackets is; checked for sensible sequence and Dunning-ness and returned as separate basis; sets (e.g., 'cc-pV[Q5]Z' is returned as [cc-pVQZ, cc-pV5Z] and [4, 5]). Note; that this function has no communication with the basis set library to check; if the basis actually exists. Used by :py:func:`~wrappers.complete_basis_set`. """"""; ZETA = ['d', 't', 'q', '5', '6']; BSET = []; ZSET = []; if re.match(r'.*cc-.*\[.*\].*z$', basisstring, flags=re.IGNORECASE):; basispattern = re.compile(r'^(.*)\[(.*)\](.*)$'); basisname = basispattern.match(basisstring); for b in basisname.group(2):; if b not in ZETA:; raise ValidationError('Basis set \'%s\' has invalid zeta level \'%s\'.' % (basisstring, b)); if len(ZSET) != 0:; if (int(ZSET[len(ZSET) - 1]) - ZETA.index(b)) != 1:; raise ValidationError('Basis set \'%s\' has out-of-order zeta level \'%s\'.' % (basisstring, b)); BSET.append(basisname.group(1) + b + basisname.group(3)); if b == 'd':; b = '2'; if b == 't':; b = '3'; if b == 'q':; b = '4'; ZSET.append(int(b)); elif re.match(r'.*\[.*\].*$', basisstring, flags=re.IGNORECASE):; raise ValidationError('Basis set surrounding series indicator [] in \'%s\' is invalid.' % (basisstring)); else:; BSET.append(basisstring); ZSET.append(0). return [BSET, ZSET]. # Reform string basis set descriptor",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:92348,Integrability,wrap,wrappers,92348," ValidationError('Basis set \'%s\' has invalid zeta level \'%s\'.' % (basisstring, b)); if len(ZSET) != 0:; if (int(ZSET[len(ZSET) - 1]) - ZETA.index(b)) != 1:; raise ValidationError('Basis set \'%s\' has out-of-order zeta level \'%s\'.' % (basisstring, b)); BSET.append(basisname.group(1) + b + basisname.group(3)); if b == 'd':; b = '2'; if b == 't':; b = '3'; if b == 'q':; b = '4'; ZSET.append(int(b)); elif re.match(r'.*\[.*\].*$', basisstring, flags=re.IGNORECASE):; raise ValidationError('Basis set surrounding series indicator [] in \'%s\' is invalid.' % (basisstring)); else:; BSET.append(basisstring); ZSET.append(0). return [BSET, ZSET]. # Reform string basis set descriptor from basis set strings, 'cc-pv[q5]z' from [cc-pvqz, cc-pv5z]; [docs]def reconstitute_bracketed_basis(needarray):; r""""""Function to reform a bracketed basis set string from a sequential series; of basis sets (e.g, form 'cc-pv[q5]z' from array [cc-pvqz, cc-pv5z]). The; basis set array is extracted from the *f_basis* field of a *NEED* dictionary in; :py:func:`~wrappers.complete_basis_set`. Result is used to print a nicely; formatted basis set string in the results table. """"""; ZETA = {'d': 2, 't': 3, 'q': 4, '5': 5, '6': 6}; ZSET = [''] * len(ZETA); BSET = []. for lvl in needarray.items():; BSET.append(lvl[1]['f_basis']). if (len(BSET) == 1):; basisstring = BSET[0]; else:; indx = 0; while indx < len(BSET[0]):; if (BSET[0][indx] != BSET[1][indx]):; zetaindx = indx; indx += 1; for basis in BSET:; ZSET[ZETA[basis[zetaindx]] - 2] = basis[zetaindx]. pre = BSET[0][:zetaindx]; post = BSET[0][zetaindx + 1:]; basisstring = pre + '[' + ''.join(ZSET) + ']' + post. return basisstring. [docs]def highest_1(**largs):; r""""""Scheme for total or correlation energies with a single basis or the highest; zeta-level among an array of bases. Used by :py:func:`~wrappers.complete_basis_set`. .. math:: E_{total}^X = E_{total}^X. """"""; energypiece = 0.0; functionname = sys._getframe().f_code.co_name; f_fields = ['f_wfn', 'f_por",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:93139,Integrability,wrap,wrappers,93139,"eted basis set string from a sequential series; of basis sets (e.g, form 'cc-pv[q5]z' from array [cc-pvqz, cc-pv5z]). The; basis set array is extracted from the *f_basis* field of a *NEED* dictionary in; :py:func:`~wrappers.complete_basis_set`. Result is used to print a nicely; formatted basis set string in the results table. """"""; ZETA = {'d': 2, 't': 3, 'q': 4, '5': 5, '6': 6}; ZSET = [''] * len(ZETA); BSET = []. for lvl in needarray.items():; BSET.append(lvl[1]['f_basis']). if (len(BSET) == 1):; basisstring = BSET[0]; else:; indx = 0; while indx < len(BSET[0]):; if (BSET[0][indx] != BSET[1][indx]):; zetaindx = indx; indx += 1; for basis in BSET:; ZSET[ZETA[basis[zetaindx]] - 2] = basis[zetaindx]. pre = BSET[0][:zetaindx]; post = BSET[0][zetaindx + 1:]; basisstring = pre + '[' + ''.join(ZSET) + ']' + post. return basisstring. [docs]def highest_1(**largs):; r""""""Scheme for total or correlation energies with a single basis or the highest; zeta-level among an array of bases. Used by :py:func:`~wrappers.complete_basis_set`. .. math:: E_{total}^X = E_{total}^X. """"""; energypiece = 0.0; functionname = sys._getframe().f_code.co_name; f_fields = ['f_wfn', 'f_portion', 'f_basis', 'f_zeta', 'f_energy']; [mode, NEED, wfnname, BSET, ZSET] = validate_scheme_args(functionname, **largs). if (mode == 'requisition'):. # Impose restrictions on zeta sequence; if (len(ZSET) == 0):; raise ValidationError('Call to \'%s\' not valid with \'%s\' basis sets.' % (functionname, len(ZSET))). # Return array that logs the requisite jobs; if (wfnname == 'scf'):; portion = 'tot'; else:; portion = 'corl'; NEED = {'HI': dict(zip(f_fields, [wfnname, portion, BSET[len(ZSET) - 1], ZSET[len(ZSET) - 1], 0.0]))}. return NEED. elif (mode == 'evaluate'):. # Extract required energies and zeta integers from array; # Compute extrapolated energy; energypiece = NEED['HI']['f_energy']. # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += """"""\n ==> %s <==\n\n"""""" % (functionname); if (NEED['HI']",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:94780,Integrability,wrap,wrappers,94780,"portion, BSET[len(ZSET) - 1], ZSET[len(ZSET) - 1], 0.0]))}. return NEED. elif (mode == 'evaluate'):. # Extract required energies and zeta integers from array; # Compute extrapolated energy; energypiece = NEED['HI']['f_energy']. # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += """"""\n ==> %s <==\n\n"""""" % (functionname); if (NEED['HI']['f_wfn'] == 'scf'):; cbsscheme += """""" HI-zeta (%s) Total Energy: %16.8f\n"""""" % (str(NEED['HI']['f_zeta']), energypiece); else:; cbsscheme += """""" HI-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(NEED['HI']['f_zeta']), energypiece); psi4.print_out(cbsscheme). return energypiece. # Solution equation in LaTeX: $E_{corl}^{\infty} = \frac{E_{corl}^{X} X^3 - E_{corl}^{X-1} (X-1)^3}{X^3 - (X-1)^3}$; # Solution equation in LaTeX: $\beta = \frac{E_{corl}^{X} - E_{corl}^{X-1}}{X^{-3} - (X-1)^{-3}}$; [docs]def corl_xtpl_helgaker_2(**largs):; r""""""Extrapolation scheme for correlation energies with two adjacent zeta-level bases.; Used by :py:func:`~wrappers.complete_basis_set`. .. math:: E_{corl}^X = E_{corl}^{\infty} + \beta X^{-3}. """"""; energypiece = 0.0; functionname = sys._getframe().f_code.co_name; f_fields = ['f_wfn', 'f_portion', 'f_basis', 'f_zeta', 'f_energy']; [mode, NEED, wfnname, BSET, ZSET] = validate_scheme_args(functionname, **largs). if (mode == 'requisition'):. # Impose restrictions on zeta sequence; if (len(ZSET) != 2):; raise ValidationError('Call to \'%s\' not valid with \'%s\' basis sets.' % (functionname, len(ZSET))). # Return array that logs the requisite jobs; NEED = {'HI': dict(zip(f_fields, [wfnname, 'corl', BSET[1], ZSET[1], 0.0])),; 'LO': dict(zip(f_fields, [wfnname, 'corl', BSET[0], ZSET[0], 0.0]))}. return NEED. elif (mode == 'evaluate'):. # Extract required energies and zeta integers from array; eHI = NEED['HI']['f_energy']; zHI = NEED['HI']['f_zeta']; eLO = NEED['LO']['f_energy']; zLO = NEED['LO']['f_zeta']. # Compute extrapolated energy; energypiece = (eHI * zHI ** 3 - eLO * zLO ** 3) / (zHI",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:96461,Integrability,wrap,wrappers,96461," ZSET[0], 0.0]))}. return NEED. elif (mode == 'evaluate'):. # Extract required energies and zeta integers from array; eHI = NEED['HI']['f_energy']; zHI = NEED['HI']['f_zeta']; eLO = NEED['LO']['f_energy']; zLO = NEED['LO']['f_zeta']. # Compute extrapolated energy; energypiece = (eHI * zHI ** 3 - eLO * zLO ** 3) / (zHI ** 3 - zLO ** 3); beta = (eHI - eLO) / (zHI ** (-3) - zLO ** (-3)). # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += """"""\n ==> %s <==\n\n"""""" % (functionname); cbsscheme += """""" LO-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zLO), eLO); cbsscheme += """""" HI-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zHI), eHI); cbsscheme += """""" Extrapolated Correlation Energy: %16.8f\n"""""" % (energypiece); cbsscheme += """""" Beta (coefficient) Value: %16.8f\n"""""" % (beta); psi4.print_out(cbsscheme). return energypiece. [docs]def scf_xtpl_helgaker_3(**largs):; r""""""Extrapolation scheme for reference energies with three adjacent zeta-level bases.; Used by :py:func:`~wrappers.complete_basis_set`. .. math:: E_{total}^X = E_{total}^{\infty} + \beta e^{-\alpha X}. """"""; energypiece = 0.0; functionname = sys._getframe().f_code.co_name; f_fields = ['f_wfn', 'f_portion', 'f_basis', 'f_zeta', 'f_energy']; [mode, NEED, wfnname, BSET, ZSET] = validate_scheme_args(functionname, **largs). if (mode == 'requisition'):. # Impose restrictions on zeta sequence; if (len(ZSET) != 3):; raise ValidationError('Call to \'%s\' not valid with \'%s\' basis sets.' % (functionname, len(ZSET))). # Return array that logs the requisite jobs; NEED = {'HI': dict(zip(f_fields, [wfnname, 'tot', BSET[2], ZSET[2], 0.0])),; 'MD': dict(zip(f_fields, [wfnname, 'tot', BSET[1], ZSET[1], 0.0])),; 'LO': dict(zip(f_fields, [wfnname, 'tot', BSET[0], ZSET[0], 0.0]))}. return NEED. elif (mode == 'evaluate'):. # Extract required energies and zeta integers from array; eHI = NEED['HI']['f_energy']; eMD = NEED['MD']['f_energy']; eLO = NEED['LO']['f_energy']; zHI = NEED['HI']['f_zeta']; zMD = N",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:98481,Integrability,wrap,wrappers,98481," zLO = NEED['LO']['f_zeta']. # Compute extrapolated energy; ratio = (eHI - eMD) / (eMD - eLO); alpha = -1 * math.log(ratio); beta = (eHI - eMD) / (math.exp(-1 * alpha * zMD) * (ratio - 1)); energypiece = eHI - beta * math.exp(-1 * alpha * zHI). # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += """"""\n ==> %s <==\n\n"""""" % (functionname); cbsscheme += """""" LO-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zLO), eLO); cbsscheme += """""" MD-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zMD), eMD); cbsscheme += """""" HI-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zHI), eHI); cbsscheme += """""" Extrapolated Correlation Energy: %16.8f\n"""""" % (energypiece); cbsscheme += """""" Alpha (exponent) Value: %16.8f\n"""""" % (alpha); cbsscheme += """""" Beta (coefficient) Value: %16.8f\n"""""" % (beta); psi4.print_out(cbsscheme). return energypiece. [docs]def scf_xtpl_helgaker_2(**largs):; r""""""Extrapolation scheme for reference energies with two adjacent zeta-level bases.; Used by :py:func:`~wrappers.complete_basis_set`. .. math:: E_{total}^X = E_{total}^{\infty} + \beta e^{-\alpha X}, \alpha = 1.63. """"""; energypiece = 0.0; functionname = sys._getframe().f_code.co_name; f_fields = ['f_wfn', 'f_portion', 'f_basis', 'f_zeta', 'f_energy']; [mode, NEED, wfnname, BSET, ZSET] = validate_scheme_args(functionname, **largs). if (mode == 'requisition'):. # Impose restrictions on zeta sequence; if (len(ZSET) != 2):; raise ValidationError('Call to \'%s\' not valid with \'%s\' basis sets.' % (functionname, len(ZSET))). # Return array that logs the requisite jobs; NEED = {'HI': dict(zip(f_fields, [wfnname, 'tot', BSET[1], ZSET[1], 0.0])),; 'LO': dict(zip(f_fields, [wfnname, 'tot', BSET[0], ZSET[0], 0.0]))}. return NEED. elif (mode == 'evaluate'):. # Extract required energies and zeta integers from array; eHI = NEED['HI']['f_energy']; eLO = NEED['LO']['f_energy']; zHI = NEED['HI']['f_zeta']; zLO = NEED['LO']['f_zeta']. # LAB TODO add ability to pass alternate parameter values in. #",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:100307,Integrability,wrap,wrappers,100307,"uired energies and zeta integers from array; eHI = NEED['HI']['f_energy']; eLO = NEED['LO']['f_energy']; zHI = NEED['HI']['f_zeta']; zLO = NEED['LO']['f_zeta']. # LAB TODO add ability to pass alternate parameter values in. # Return extrapolated energy; alpha = 1.63; beta = (eHI - eLO) / (math.exp(-1 * alpha * zLO) * (math.exp(-1 * alpha) - 1)); energypiece = eHI - beta * math.exp(-1 * alpha * zHI). # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += """"""\n ==> %s <==\n\n"""""" % (functionname); cbsscheme += """""" LO-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zLO), eLO); cbsscheme += """""" HI-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zHI), eHI); cbsscheme += """""" Extrapolated Correlation Energy: %16.8f\n"""""" % (energypiece); cbsscheme += """""" Alpha (exponent) Value: %16.8f\n"""""" % (alpha); cbsscheme += """""" Beta (coefficient) Value: %16.8f\n"""""" % (beta); psi4.print_out(cbsscheme). return energypiece. [docs]def validate_scheme_args(functionname, **largs):; r""""""Function called by each extrapolation scheme in :py:func:`~wrappers.complete_basis_set`.; Checks that all the input arguments are present and suitable so that; the scheme function can focus on defining the extrapolation. """"""; mode = ''; NEED = []; wfnname = ''; BSET = []; ZSET = []. # Mode where function fills out a form NEED with the computations needed to fulfill its call; if (largs['mode'].lower() == 'requisition'):; mode = largs['mode'].lower(). if 'wfnname' in largs:; wfnname = largs['wfnname']; else:; raise ValidationError('Call to \'%s\' has keyword \'wfnname\' missing.' % (functionname)). if re.match(r'scf_.*$', functionname) and (wfnname != 'scf'):; raise ValidationError('Call to \'%s\' is intended for scf portion of calculation.' % (functionname)); if re.match(r'corl_.*$', functionname) and (wfnname == 'scf'):; raise ValidationError('Call to \'%s\' is not intended for scf portion of calculation.' % (functionname)). if 'basisname' in largs:; BSET = largs['basisname']; else:; raise",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:102046,Integrability,wrap,wrappers,102046,"if re.match(r'corl_.*$', functionname) and (wfnname == 'scf'):; raise ValidationError('Call to \'%s\' is not intended for scf portion of calculation.' % (functionname)). if 'basisname' in largs:; BSET = largs['basisname']; else:; raise ValidationError('Call to \'%s\' has keyword \'basisname\' missing.' % (functionname)). if 'basiszeta' in largs:; ZSET = largs['basiszeta']; else:; raise ValidationError('Call to \'%s\' has keyword \'basiszeta\' missing.' % (functionname)). # Mode where function reads the now-filled-in energies from that same form and performs the sp, xtpl, delta, etc.; elif (largs['mode'].lower() == 'evaluate'):; mode = largs['mode'].lower(). if 'needname' in largs:; NEED = largs['needname']; else:; raise ValidationError('Call to \'%s\' has keyword \'needname\' missing.' % (functionname)). else:; raise ValidationError('Call to \'%s\' has keyword \'mode\' missing or invalid.' % (functionname)). return [mode, NEED, wfnname, BSET, ZSET]. [docs]def split_menial(menial):; r""""""Function used by :py:func:`~wrappers.complete_basis_set` to separate; *menial* 'scftot' into [scf, tot] and 'mp2corl' into [mp2, corl]. """"""; PTYP = ['tot', 'corl']; for temp in PTYP:; if menial.endswith(temp):; temp_wfn = menial[:-len(temp)]; temp_portion = temp. return [temp_wfn, temp_portion]. # Quickly normalize the types for both python 2 and 3; try:; unicode = unicode; except NameError:; # 'unicode' is undefined, must be Python 3; str = str; unicode = str; bytes = bytes; basestring = (str,bytes); else:; # 'unicode' exists, must be Python 2; str = str; unicode = unicode; bytes = str; basestring = basestring. ## Aliases ##; cbs = complete_basis_set. #################################; ## End of Complete Basis Set ##; #################################. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  ; PSI4 [beta5]  ; Module code .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:1716,Modifiability,variab,variable,1716,"icense for more details.; #; # You should have received a copy of the GNU General Public License along; # with this program; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; #@END LICENSE; #. """"""Module with functions that call the four main :py:mod:`driver`; functions: :py:mod:`driver.energy`, :py:mod:`driver.optimize`,; :py:mod:`driver.response`, and :py:mod:`driver.frequency`. """"""; import re; import os; import math; import warnings; import pickle; import copy; import collections; import psi4; import p4const; import p4util; from driver import *; #from extend_Molecule import *; from molutil import *; from p4regex import *; # never import aliases into this file. # Function to make calls among wrappers(), energy(), optimize(), etc.; [docs]def call_function_in_1st_argument(funcarg, **largs):; r""""""Function to make primary function call to energy(), opt(), etc.; with options dictionary *largs*.; Useful when *funcarg* to call is stored in variable. """"""; return funcarg(**largs). [docs]def convert(p, symbol):; if symbol[p] == 'H':; d = 1.001; if symbol[p] == 'He':; d = 1.012; if symbol[p] == 'Li':; d = 0.825; if symbol[p] == 'Be':; d = 1.408; if symbol[p] == 'B':; d = 1.485; if symbol[p] == 'C':; d = 1.452; if symbol[p] == 'N':; d = 1.397; if symbol[p] == 'O':; d = 1.342; if symbol[p] == 'F':; d = 1.287; if symbol[p] == 'Ne':; d = 1.243; if symbol[p] == 'Na':; d = 1.144; if symbol[p] == 'Mg':; d = 1.364; if symbol[p] == 'Al':; d = 1.639; if symbol[p] == 'Si':; d = 1.716; if symbol[p] == 'P':; d = 1.705; if symbol[p] == 'S':; d = 1.683; if symbol[p] == 'Cl':; d = 1.639; if symbol[p] == 'Ar':; d = 1.595. return d / 1.5. #Automatically detect fragments and build a new molecule for fragment; #needing methods (SAPT0, etc...); [docs]def auto_fragments(name, **kwargs):; r""""""; Detects fragments if the user does not supply them.; Currently only used for the WebMO implementation of SAPT. usage: auto_fragments('');",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:5630,Modifiability,config,configuration,5630,"name, **kwargs):; lowername = name.lower(); kwargs = p4util.kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name.lower(). # Establish function to call; if not('n_body_func' in kwargs):; if ('func' in kwargs):; kwargs['n_body_func'] = kwargs['func']; del kwargs['func']; else:; kwargs['n_body_func'] = energy; func = kwargs['n_body_func']; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper n_body.' % (func.__name__)); if (func is db):; raise ValidationError('Wrapper n_body is unhappy to be calling function \'%s\'.' % (func.__name__)). # Make sure the molecule the user provided is the active one; if 'molecule' in kwargs:; activate(kwargs['molecule']); del kwargs['molecule']; molecule = psi4.get_active_molecule(); molecule.update_geometry(); psi4.set_global_option(""BASIS"", psi4.get_global_option(""BASIS"")). # N-body run configuration; bsse = 'on'; if 'bsse' in kwargs:; bsse = kwargs['bsse']. max_n_body = molecule.nfragments(); if 'max_n_body' in kwargs:; max_n_body = kwargs['max_n_body']. do_total = False; if 'do_total' in kwargs:; do_total = kwargs['do_total']. external = None; external_indices = []; if 'external' in kwargs:; external = kwargs['external']; external_indices = [molecule.nfragments()]; if 'external_monomers' in kwargs:; external_indices = kwargs['external_monomers']. # Check input args; if not bsse == 'off' and not bsse == 'on' and not bsse == 'both':; raise ValidationError('n_body: bsse argument is one of on, off, or both'); if max_n_body < 1:; raise ValidationError('n_body: max_n_body must be at least 1'); if max_n_body > molecule.nfragments():; raise ValidationError('n_body: max_n_body must be <= to the number of fragments in the molecule'). # Set to save RI integrals for repeated full-basis computations; ri_ints_io = psi4.get_global_option('DF_INTS_IO'); # inquire if above at all applies to dfmp2 or just scf; p",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:17214,Modifiability,variab,variables,17214,"ta E [H]"", ""Delta E [kcal mol^-1]"")); for k in range(len(Ns)):; n = Ns[k]; if n == 1:; continue; E = energies_n_bsse[Ns[k]] - energies_n_bsse[Ns[k + 1]]; psi4.print_out(' %6s %24.16E %24.16E\n' % (n, E, p4const.psi_hartree2kcalmol * E)); psi4.print_out('\n'). # Put everything back the way it was; psi4.set_global_option('DF_INTS_IO', ri_ints_io); psioh.set_specific_retention(97, False); psi4.clean(); activate(molecule). if bsse == 'on' or bsse == 'both':; return energies_n_full[Ns[0]]; else:; return energies_n_mon[Ns[0]]. ## Aliases ##; nbody = n_body. #####################; ## End of n_body ##; #####################. ###################; ## Start of cp ##; ###################. [docs]def cp(name, **kwargs):; r""""""The cp function computes counterpoise-corrected two-body interaction energies; for complexes composed of arbitrary numbers of monomers. :aliases: counterpoise_correct(), counterpoise_correction(). :returns: (*float*) Counterpoise-corrected interaction energy in Hartrees. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CP-CORRECTED 2-BODY INTERACTION ENERGY <CP-CORRECTED2-BODYINTERACTIONENERGY>`; * :psivar:`UNCP-CORRECTED 2-BODY INTERACTION ENERGY <UNCP-CORRECTED2-BODYINTERACTIONENERGY>`. .. caution:: Some features are not yet implemented. Buy a developer a coffee. - No values of func besides energy have been tested. - Table print-out needs improving. Add some PSI variables. :type name: string; :param name: ``'scf'`` || ``'ccsd(t)'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the molecule. May be any valid argument to; :py:func:`~driver.energy`; however, SAPT is not appropriate. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``energy`` |dr| || ``optimize`` || ``cbs``. Indicates the type of calculation to be performed on the molecule; and each of its monomers. The default performs a single-point; ``energy('name')``, while ``optimize`` perfoms a geometry optimization; on each system, and `",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:17614,Modifiability,variab,variables,17614,"ean(); activate(molecule). if bsse == 'on' or bsse == 'both':; return energies_n_full[Ns[0]]; else:; return energies_n_mon[Ns[0]]. ## Aliases ##; nbody = n_body. #####################; ## End of n_body ##; #####################. ###################; ## Start of cp ##; ###################. [docs]def cp(name, **kwargs):; r""""""The cp function computes counterpoise-corrected two-body interaction energies; for complexes composed of arbitrary numbers of monomers. :aliases: counterpoise_correct(), counterpoise_correction(). :returns: (*float*) Counterpoise-corrected interaction energy in Hartrees. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CP-CORRECTED 2-BODY INTERACTION ENERGY <CP-CORRECTED2-BODYINTERACTIONENERGY>`; * :psivar:`UNCP-CORRECTED 2-BODY INTERACTION ENERGY <UNCP-CORRECTED2-BODYINTERACTIONENERGY>`. .. caution:: Some features are not yet implemented. Buy a developer a coffee. - No values of func besides energy have been tested. - Table print-out needs improving. Add some PSI variables. :type name: string; :param name: ``'scf'`` || ``'ccsd(t)'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the molecule. May be any valid argument to; :py:func:`~driver.energy`; however, SAPT is not appropriate. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``energy`` |dr| || ``optimize`` || ``cbs``. Indicates the type of calculation to be performed on the molecule; and each of its monomers. The default performs a single-point; ``energy('name')``, while ``optimize`` perfoms a geometry optimization; on each system, and ``cbs`` performs a compound single-point energy.; If a nested series of python functions is intended; (see :ref:`sec:intercalls`), use keyword ``cp_func`` instead of ``func``. :type check_bsse: :ref:`boolean <op_py_boolean>`; :param check_bsse: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether to additionally compute un-counterpoise corrected; monomers and thus obtain an estimate for the basi",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:23444,Modifiability,variab,variables,23444,"_full = e_full - e_monomer_full[cluster_n]; e_bsse = e_bsse - e_monomer_bsse[cluster_n]; cp_table[""Totals:""] = [e_full, e_bsse, e_full - e_bsse]. psi4.set_variable('UNCP-CORRECTED 2-BODY INTERACTION ENERGY', e_full). psi4.print_out(""\n""); p4util.banner(""CP Computation: Results.""); psi4.print_out(""\n""). p4util.banner(""Hartree"", 2); psi4.print_out(""\n""). psi4.print_out(str(cp_table)). psi4.print_out(""\n""); p4util.banner(""kcal*mol^-1"", 2); psi4.print_out(""\n""). cp_table.scale(). psi4.print_out(str(cp_table)); return e_full. ## Aliases ##; counterpoise_correct = cp; counterpoise_correction = cp. #################; ## End of cp ##; #################. #########################; ## Start of Database ##; #########################. DB_RGT = {}; DB_RXN = {}. [docs]def database(name, db_name, **kwargs):; r""""""Function to access the molecule objects and reference energies of; popular chemical databases. :aliases: db(). :returns: (*float*) Mean absolute deviation of the database in kcal/mol. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`db_name DATABASE MEAN SIGNED DEVIATION <db_nameDATABASEMEANSIGNEDDEVIATION>`; * :psivar:`db_name DATABASE MEAN ABSOLUTE DEVIATION <db_nameDATABASEMEANABSOLUTEDEVIATION>`; * :psivar:`db_name DATABASE ROOT-MEAN-SQUARE DEVIATION <db_nameDATABASEROOT-MEAN-SQUARESIGNEDDEVIATION>`; * Python dictionaries of results accessible as ``DB_RGT`` and ``DB_RXN``. .. note:: It is very easy to make a database from a collection of xyz files; using the script :source:`lib/scripts/ixyz2database.pl`.; See :ref:`sec:createDatabase` for details. .. caution:: Some features are not yet implemented. Buy a developer some coffee. - In sow/reap mode, use only global options (e.g., the local option set by ``set scf scf_type df`` will not be respected). .. note:: To access a database that is not embedded in a |PSIfour|; distribution, add the path to the directory containing the database; to the environment variable :envvar:`PYTHONPATH`. :type name: string; :param name: ``",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:24381,Modifiability,variab,variable,24381,"f; popular chemical databases. :aliases: db(). :returns: (*float*) Mean absolute deviation of the database in kcal/mol. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`db_name DATABASE MEAN SIGNED DEVIATION <db_nameDATABASEMEANSIGNEDDEVIATION>`; * :psivar:`db_name DATABASE MEAN ABSOLUTE DEVIATION <db_nameDATABASEMEANABSOLUTEDEVIATION>`; * :psivar:`db_name DATABASE ROOT-MEAN-SQUARE DEVIATION <db_nameDATABASEROOT-MEAN-SQUARESIGNEDDEVIATION>`; * Python dictionaries of results accessible as ``DB_RGT`` and ``DB_RXN``. .. note:: It is very easy to make a database from a collection of xyz files; using the script :source:`lib/scripts/ixyz2database.pl`.; See :ref:`sec:createDatabase` for details. .. caution:: Some features are not yet implemented. Buy a developer some coffee. - In sow/reap mode, use only global options (e.g., the local option set by ``set scf scf_type df`` will not be respected). .. note:: To access a database that is not embedded in a |PSIfour|; distribution, add the path to the directory containing the database; to the environment variable :envvar:`PYTHONPATH`. :type name: string; :param name: ``'scf'`` || ``'sapt0'`` || ``'ccsd(t)'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; :py:func:`~driver.energy`. :type db_name: string; :param db_name: ``'BASIC'`` || ``'S22'`` || ``'HTBH'`` || etc. Second argument, usually unlabeled. Indicates the requested database; name, matching (case insensitive) the name of a python file in; ``psi4/lib/databases`` or :envvar:`PYTHONPATH`. Consult that; directory for available databases and literature citations. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``energy`` |dr| || ``optimize`` || ``cbs``. Indicates the type of calculation to be performed on each database; member. The default performs a single-point ``energy('name')``, while; ``optimize`` perfoms a geometry optimization on each reagent, and; ``cbs`` p",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:27580,Modifiability,variab,variables,27580,":`boolean <op_py_boolean>`; :param symm: |dl| ``'on'`` |dr| || ``'off'``. Indicates whether the native symmetry of the database reagents is; employed (``'on'``) or whether it is forced to :math:`C_1` symmetry; (``'off'``). Some computational methods (e.g., SAPT) require no; symmetry, and this will be set by database(). :type zpe: :ref:`boolean <op_py_boolean>`; :param zpe: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether zero-point-energy corrections are appended to; single-point energy values. Option valid only for certain; thermochemical databases. Disabled until Hessians ready. :type benchmark: string; :param benchmark: |dl| ``'default'`` |dr| || ``'S22A'`` || etc. Indicates whether a non-default set of reference energies, if; available (See :ref:`sec:availableDatabases`), are employed for the; calculation of error statistics. :type tabulate: array of strings; :param tabulate: |dl| ``[]`` |dr| || ``['scf total energy', 'natom']`` || etc. Indicates whether to form tables of variables other than the; primary requested energy. Available for any PSI variable. :type subset: string or array of strings; :param subset:. Indicates a subset of the full database to run. This is a very; flexible option and can be used in three distinct ways, outlined; below. Note that two take a string and the last takes an array.; See `Available Databases`_ for available values. * ``'small'`` || ``'large'`` || ``'equilibrium'``; Calls predefined subsets of the requested database, either; ``'small'``, a few of the smallest database members,; ``'large'``, the largest of the database members, or; ``'equilibrium'``, the equilibrium geometries for a database; composed of dissociation curves.; * ``'BzBz_S'`` || ``'FaOOFaON'`` || ``'ArNe'`` || ``'HB'`` || etc.; For databases composed of dissociation curves, or otherwise; divided into subsets, individual curves and subsets can be; called by name. Consult the database python files for available; molecular systems (case insensitive).; * ``[1,2,5]``",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:27654,Modifiability,variab,variable,27654,"|| ``'off'``. Indicates whether the native symmetry of the database reagents is; employed (``'on'``) or whether it is forced to :math:`C_1` symmetry; (``'off'``). Some computational methods (e.g., SAPT) require no; symmetry, and this will be set by database(). :type zpe: :ref:`boolean <op_py_boolean>`; :param zpe: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether zero-point-energy corrections are appended to; single-point energy values. Option valid only for certain; thermochemical databases. Disabled until Hessians ready. :type benchmark: string; :param benchmark: |dl| ``'default'`` |dr| || ``'S22A'`` || etc. Indicates whether a non-default set of reference energies, if; available (See :ref:`sec:availableDatabases`), are employed for the; calculation of error statistics. :type tabulate: array of strings; :param tabulate: |dl| ``[]`` |dr| || ``['scf total energy', 'natom']`` || etc. Indicates whether to form tables of variables other than the; primary requested energy. Available for any PSI variable. :type subset: string or array of strings; :param subset:. Indicates a subset of the full database to run. This is a very; flexible option and can be used in three distinct ways, outlined; below. Note that two take a string and the last takes an array.; See `Available Databases`_ for available values. * ``'small'`` || ``'large'`` || ``'equilibrium'``; Calls predefined subsets of the requested database, either; ``'small'``, a few of the smallest database members,; ``'large'``, the largest of the database members, or; ``'equilibrium'``, the equilibrium geometries for a database; composed of dissociation curves.; * ``'BzBz_S'`` || ``'FaOOFaON'`` || ``'ArNe'`` || ``'HB'`` || etc.; For databases composed of dissociation curves, or otherwise; divided into subsets, individual curves and subsets can be; called by name. Consult the database python files for available; molecular systems (case insensitive).; * ``[1,2,5]`` || ``['1','2','5']`` || ``['BzMe-3.5', 'MeMe-5.0']`` || etc",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:27786,Modifiability,flexible,flexible,27786,"e computational methods (e.g., SAPT) require no; symmetry, and this will be set by database(). :type zpe: :ref:`boolean <op_py_boolean>`; :param zpe: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether zero-point-energy corrections are appended to; single-point energy values. Option valid only for certain; thermochemical databases. Disabled until Hessians ready. :type benchmark: string; :param benchmark: |dl| ``'default'`` |dr| || ``'S22A'`` || etc. Indicates whether a non-default set of reference energies, if; available (See :ref:`sec:availableDatabases`), are employed for the; calculation of error statistics. :type tabulate: array of strings; :param tabulate: |dl| ``[]`` |dr| || ``['scf total energy', 'natom']`` || etc. Indicates whether to form tables of variables other than the; primary requested energy. Available for any PSI variable. :type subset: string or array of strings; :param subset:. Indicates a subset of the full database to run. This is a very; flexible option and can be used in three distinct ways, outlined; below. Note that two take a string and the last takes an array.; See `Available Databases`_ for available values. * ``'small'`` || ``'large'`` || ``'equilibrium'``; Calls predefined subsets of the requested database, either; ``'small'``, a few of the smallest database members,; ``'large'``, the largest of the database members, or; ``'equilibrium'``, the equilibrium geometries for a database; composed of dissociation curves.; * ``'BzBz_S'`` || ``'FaOOFaON'`` || ``'ArNe'`` || ``'HB'`` || etc.; For databases composed of dissociation curves, or otherwise; divided into subsets, individual curves and subsets can be; called by name. Consult the database python files for available; molecular systems (case insensitive).; * ``[1,2,5]`` || ``['1','2','5']`` || ``['BzMe-3.5', 'MeMe-5.0']`` || etc.; Specify a list of database members to run. Consult the; database python files for available molecular systems. This; is the only portion of database input that is c",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:31951,Modifiability,Config,Configuration,31951,"; raise ValidationError(""Python module loading problem for database "" + str(db_name)); else:; dbse = database.dbse; HRXN = database.HRXN; ACTV = database.ACTV; RXNM = database.RXNM; BIND = database.BIND; TAGL = database.TAGL; GEOS = database.GEOS; try:; DATA = database.DATA; except AttributeError:; DATA = {}. # Must collect (here) and set (below) basis sets after every new molecule activation; user_basis = psi4.get_global_option('BASIS'); user_df_basis_scf = psi4.get_global_option('DF_BASIS_SCF'); user_df_basis_mp2 = psi4.get_global_option('DF_BASIS_MP2'); user_df_basis_sapt = psi4.get_global_option('DF_BASIS_SAPT'); user_df_basis_elst = psi4.get_global_option('DF_BASIS_ELST'). user_writer_file_label = psi4.get_global_option('WRITER_FILE_LABEL'). b_user_reference = psi4.has_global_option_changed('REFERENCE'); user_reference = psi4.get_global_option('REFERENCE'); user_memory = psi4.get_memory(). user_molecule = psi4.get_active_molecule(). # Configuration based upon e_name & db_name options; # Force non-supramolecular if needed; if re.match(r'^sapt', lowername) or re.match(r'^.*sapt', lowername):; try:; database.ACTV_SA; except AttributeError:; raise ValidationError('Database %s not suitable for non-supramolecular calculation.' % (db_name)); else:; ACTV = database.ACTV_SA; # Force open-shell if needed; openshell_override = 0; if (user_reference == 'RHF') or (user_reference == 'RKS'):; try:; database.isOS; except AttributeError:; pass; else:; if yes.match(str(database.isOS)):; openshell_override = 1; psi4.print_out('\nSome reagents in database %s require an open-shell reference; will be reset to UHF/UKS as needed.\n' % (db_name)). # Configuration based upon database keyword options; # Option symmetry- whether symmetry treated normally or turned off (currently req'd for dfmp2 & dft); db_symm = 'yes'; if 'symm' in kwargs:; db_symm = kwargs['symm']. symmetry_override = 0; if no.match(str(db_symm)):; symmetry_override = 1; elif yes.match(str(db_symm)):; pass; else:; raise ",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:32655,Modifiability,Config,Configuration,32655,"eference = psi4.has_global_option_changed('REFERENCE'); user_reference = psi4.get_global_option('REFERENCE'); user_memory = psi4.get_memory(). user_molecule = psi4.get_active_molecule(). # Configuration based upon e_name & db_name options; # Force non-supramolecular if needed; if re.match(r'^sapt', lowername) or re.match(r'^.*sapt', lowername):; try:; database.ACTV_SA; except AttributeError:; raise ValidationError('Database %s not suitable for non-supramolecular calculation.' % (db_name)); else:; ACTV = database.ACTV_SA; # Force open-shell if needed; openshell_override = 0; if (user_reference == 'RHF') or (user_reference == 'RKS'):; try:; database.isOS; except AttributeError:; pass; else:; if yes.match(str(database.isOS)):; openshell_override = 1; psi4.print_out('\nSome reagents in database %s require an open-shell reference; will be reset to UHF/UKS as needed.\n' % (db_name)). # Configuration based upon database keyword options; # Option symmetry- whether symmetry treated normally or turned off (currently req'd for dfmp2 & dft); db_symm = 'yes'; if 'symm' in kwargs:; db_symm = kwargs['symm']. symmetry_override = 0; if no.match(str(db_symm)):; symmetry_override = 1; elif yes.match(str(db_symm)):; pass; else:; raise ValidationError('Symmetry mode \'%s\' not valid.' % (db_symm)). # Option mode of operation- whether db run in one job or files farmed out; if not('db_mode' in kwargs):; if ('mode' in kwargs):; kwargs['db_mode'] = kwargs['mode']; del kwargs['mode']; else:; kwargs['db_mode'] = 'continuous'; db_mode = kwargs['db_mode']. if (db_mode.lower() == 'continuous'):; pass; elif (db_mode.lower() == 'sow'):; pass; elif (db_mode.lower() == 'reap'):; if 'linkage' in kwargs:; db_linkage = kwargs['linkage']; else:; raise ValidationError('Database execution mode \'reap\' requires a linkage option.'); else:; raise ValidationError('Database execution mode \'%s\' not valid.' % (db_mode)). # Option counterpoise- whether for interaction energy databases run in bsse-corrected or ",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:35827,Modifiability,variab,variables,35827,"lxd)):; pass; else:; raise ValidationError('Deformation correction mode \'%s\' not valid.' % (db_rlxd)). # Option zero-point-correction- whether for thermochem databases jobs are corrected by zpe; db_zpe = 'no'; if 'zpe' in kwargs:; db_zpe = kwargs['zpe']. if yes.match(str(db_zpe)):; raise ValidationError('Zero-point-correction mode \'yes\' not yet implemented.'); elif no.match(str(db_zpe)):; pass; else:; raise ValidationError('Zero-point-correction \'mode\' %s not valid.' % (db_zpe)). # Option benchmark- whether error statistics computed wrt alternate reference energies; db_benchmark = 'default'; if 'benchmark' in kwargs:; db_benchmark = kwargs['benchmark']. if (db_benchmark.lower() == 'default'):; pass; else:; BIND = p4util.getattr_ignorecase(database, 'BIND_' + db_benchmark); if BIND is None:; raise ValidationError('Special benchmark \'%s\' not available for database %s.' % (db_benchmark, db_name)). # Option tabulate- whether tables of variables other than primary energy method are formed; db_tabulate = []; if 'tabulate' in kwargs:; db_tabulate = kwargs['tabulate']. # Option subset- whether all of the database or just a portion is run; db_subset = HRXN; if 'subset' in kwargs:; db_subset = kwargs['subset']. if isinstance(db_subset, basestring):; if (db_subset.lower() == 'small'):; try:; database.HRXN_SM; except AttributeError:; raise ValidationError('Special subset \'small\' not available for database %s.' % (db_name)); else:; HRXN = database.HRXN_SM; elif (db_subset.lower() == 'large'):; try:; database.HRXN_LG; except AttributeError:; raise ValidationError('Special subset \'large\' not available for database %s.' % (db_name)); else:; HRXN = database.HRXN_LG; elif (db_subset.lower() == 'equilibrium'):; try:; database.HRXN_EQ; except AttributeError:; raise ValidationError('Special subset \'equilibrium\' not available for database %s.' % (db_name)); else:; HRXN = database.HRXN_EQ; else:; HRXN = p4util.getattr_ignorecase(database, db_subset); if HRXN is None:; HRXN =",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:45685,Modifiability,variab,variable,45685," elif (db_mode.lower() == 'sow'):; freagent = open('%s.in' % (rgt), 'w'); freagent.write('# This is a psi4 input file auto-generated from the database() wrapper.\n\n'); freagent.write(banners); freagent.write(p4util.format_molecule_for_input(GEOS[rgt])). freagent.write(commands); freagent.write('''\npickle_kw = (""""""'''); pickle.dump(kwargs, freagent); freagent.write('''"""""")\n'''); freagent.write(""""""\nkwargs = pickle.loads(pickle_kw)\n""""""); freagent.write(""""""electronic_energy = %s(**kwargs)\n\n"""""" % (func.__name__)); freagent.write(""""""psi4.print_variables()\n""""""); freagent.write(""""""psi4.print_out('\\nDATABASE RESULT: computation %d for reagent %s """"""; % (os.getpid(), rgt)); freagent.write(""""""yields electronic energy %20.12f\\n' % (electronic_energy))\n\n""""""); freagent.write(""""""psi4.set_variable('NATOM', molecule.natom())\n""""""); for envv in db_tabulate:; freagent.write(""""""psi4.print_out('DATABASE RESULT: computation %d for reagent %s """"""; % (os.getpid(), rgt)); freagent.write(""""""yields variable value %20.12f for variable %s\\n' % (psi4.get_variable(""""""); freagent.write(""""""'%s'), '%s'))\n"""""" % (envv.upper(), envv.upper())); freagent.close(). elif (db_mode.lower() == 'reap'):; ERGT[rgt] = 0.0; for envv in db_tabulate:; VRGT[rgt][envv.upper()] = 0.0; exec(banners); exec(actives); try:; freagent = open('%s.out' % (rgt), 'r'); except IOError:; psi4.print_out('Warning: Output file \'%s.out\' not found.\n' % (rgt)); psi4.print_out(' Database summary will have 0.0 and **** in its place.\n'); else:; while 1:; line = freagent.readline(); if not line:; if ERGT[rgt] == 0.0:; psi4.print_out('Warning: Output file \'%s.out\' has no DATABASE RESULT line.\n' % (rgt)); psi4.print_out(' Database summary will have 0.0 and **** in its place.\n'); break; s = line.split(); if (len(s) != 0) and (s[0:3] == ['DATABASE', 'RESULT:', 'computation']):; if int(s[3]) != db_linkage:; raise ValidationError('Output file \'%s.out\' has linkage %s incompatible with master.in linkage %s.'; % (rgt, str(s[3]",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:45712,Modifiability,variab,variable,45712," freagent = open('%s.in' % (rgt), 'w'); freagent.write('# This is a psi4 input file auto-generated from the database() wrapper.\n\n'); freagent.write(banners); freagent.write(p4util.format_molecule_for_input(GEOS[rgt])). freagent.write(commands); freagent.write('''\npickle_kw = (""""""'''); pickle.dump(kwargs, freagent); freagent.write('''"""""")\n'''); freagent.write(""""""\nkwargs = pickle.loads(pickle_kw)\n""""""); freagent.write(""""""electronic_energy = %s(**kwargs)\n\n"""""" % (func.__name__)); freagent.write(""""""psi4.print_variables()\n""""""); freagent.write(""""""psi4.print_out('\\nDATABASE RESULT: computation %d for reagent %s """"""; % (os.getpid(), rgt)); freagent.write(""""""yields electronic energy %20.12f\\n' % (electronic_energy))\n\n""""""); freagent.write(""""""psi4.set_variable('NATOM', molecule.natom())\n""""""); for envv in db_tabulate:; freagent.write(""""""psi4.print_out('DATABASE RESULT: computation %d for reagent %s """"""; % (os.getpid(), rgt)); freagent.write(""""""yields variable value %20.12f for variable %s\\n' % (psi4.get_variable(""""""); freagent.write(""""""'%s'), '%s'))\n"""""" % (envv.upper(), envv.upper())); freagent.close(). elif (db_mode.lower() == 'reap'):; ERGT[rgt] = 0.0; for envv in db_tabulate:; VRGT[rgt][envv.upper()] = 0.0; exec(banners); exec(actives); try:; freagent = open('%s.out' % (rgt), 'r'); except IOError:; psi4.print_out('Warning: Output file \'%s.out\' not found.\n' % (rgt)); psi4.print_out(' Database summary will have 0.0 and **** in its place.\n'); else:; while 1:; line = freagent.readline(); if not line:; if ERGT[rgt] == 0.0:; psi4.print_out('Warning: Output file \'%s.out\' has no DATABASE RESULT line.\n' % (rgt)); psi4.print_out(' Database summary will have 0.0 and **** in its place.\n'); break; s = line.split(); if (len(s) != 0) and (s[0:3] == ['DATABASE', 'RESULT:', 'computation']):; if int(s[3]) != db_linkage:; raise ValidationError('Output file \'%s.out\' has linkage %s incompatible with master.in linkage %s.'; % (rgt, str(s[3]), str(db_linkage))); if s[6] != ",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:47020,Modifiability,variab,variable,47020,"xcept IOError:; psi4.print_out('Warning: Output file \'%s.out\' not found.\n' % (rgt)); psi4.print_out(' Database summary will have 0.0 and **** in its place.\n'); else:; while 1:; line = freagent.readline(); if not line:; if ERGT[rgt] == 0.0:; psi4.print_out('Warning: Output file \'%s.out\' has no DATABASE RESULT line.\n' % (rgt)); psi4.print_out(' Database summary will have 0.0 and **** in its place.\n'); break; s = line.split(); if (len(s) != 0) and (s[0:3] == ['DATABASE', 'RESULT:', 'computation']):; if int(s[3]) != db_linkage:; raise ValidationError('Output file \'%s.out\' has linkage %s incompatible with master.in linkage %s.'; % (rgt, str(s[3]), str(db_linkage))); if s[6] != rgt:; raise ValidationError('Output file \'%s.out\' has nominal affiliation %s incompatible with reagent %s.'; % (rgt, s[6], rgt)); if (s[8:10] == ['electronic', 'energy']):; ERGT[rgt] = float(s[10]); psi4.print_out('DATABASE RESULT: electronic energy = %20.12f\n' % (ERGT[rgt])); elif (s[8:10] == ['variable', 'value']):; for envv in db_tabulate:; envv = envv.upper(); if (s[13:] == envv.split()):; VRGT[rgt][envv] = float(s[10]); psi4.print_out('DATABASE RESULT: variable %s value = %20.12f\n' % (envv, VRGT[rgt][envv])); freagent.close(). # end sow after writing files; if (db_mode.lower() == 'sow'):; return 0.0. # Reap all the necessary reaction computations; psi4.print_out(""\n""); p4util.banner((""Database %s Results"" % (db_name))); psi4.print_out(""\n""). maxactv = []; for rxn in HRXN:; maxactv.append(len(ACTV[dbse + '-' + str(rxn)])); maxrgt = max(maxactv); table_delimit = '-' * (54 + 20 * maxrgt); tables = ''. # find any reactions that are incomplete; FAIL = collections.defaultdict(int); for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn); for i in range(len(ACTV[db_rxn])):; if abs(ERGT[ACTV[db_rxn][i]]) < 1.0e-12:; FAIL[rxn] = 1. # tabulate requested process::environment variables; tables += """""" For each VARIABLE requested by tabulate, a 'Reaction Value' will be formed from\n""""""; tables += """""" ",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:47185,Modifiability,variab,variable,47185,"ace.\n'); else:; while 1:; line = freagent.readline(); if not line:; if ERGT[rgt] == 0.0:; psi4.print_out('Warning: Output file \'%s.out\' has no DATABASE RESULT line.\n' % (rgt)); psi4.print_out(' Database summary will have 0.0 and **** in its place.\n'); break; s = line.split(); if (len(s) != 0) and (s[0:3] == ['DATABASE', 'RESULT:', 'computation']):; if int(s[3]) != db_linkage:; raise ValidationError('Output file \'%s.out\' has linkage %s incompatible with master.in linkage %s.'; % (rgt, str(s[3]), str(db_linkage))); if s[6] != rgt:; raise ValidationError('Output file \'%s.out\' has nominal affiliation %s incompatible with reagent %s.'; % (rgt, s[6], rgt)); if (s[8:10] == ['electronic', 'energy']):; ERGT[rgt] = float(s[10]); psi4.print_out('DATABASE RESULT: electronic energy = %20.12f\n' % (ERGT[rgt])); elif (s[8:10] == ['variable', 'value']):; for envv in db_tabulate:; envv = envv.upper(); if (s[13:] == envv.split()):; VRGT[rgt][envv] = float(s[10]); psi4.print_out('DATABASE RESULT: variable %s value = %20.12f\n' % (envv, VRGT[rgt][envv])); freagent.close(). # end sow after writing files; if (db_mode.lower() == 'sow'):; return 0.0. # Reap all the necessary reaction computations; psi4.print_out(""\n""); p4util.banner((""Database %s Results"" % (db_name))); psi4.print_out(""\n""). maxactv = []; for rxn in HRXN:; maxactv.append(len(ACTV[dbse + '-' + str(rxn)])); maxrgt = max(maxactv); table_delimit = '-' * (54 + 20 * maxrgt); tables = ''. # find any reactions that are incomplete; FAIL = collections.defaultdict(int); for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn); for i in range(len(ACTV[db_rxn])):; if abs(ERGT[ACTV[db_rxn][i]]) < 1.0e-12:; FAIL[rxn] = 1. # tabulate requested process::environment variables; tables += """""" For each VARIABLE requested by tabulate, a 'Reaction Value' will be formed from\n""""""; tables += """""" 'Reagent' values according to weightings 'Wt', as for the REQUESTED ENERGY below.\n""""""; tables += """""" Depending on the nature of the variable, this may o",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:47905,Modifiability,variab,variables,47905," (ERGT[rgt])); elif (s[8:10] == ['variable', 'value']):; for envv in db_tabulate:; envv = envv.upper(); if (s[13:] == envv.split()):; VRGT[rgt][envv] = float(s[10]); psi4.print_out('DATABASE RESULT: variable %s value = %20.12f\n' % (envv, VRGT[rgt][envv])); freagent.close(). # end sow after writing files; if (db_mode.lower() == 'sow'):; return 0.0. # Reap all the necessary reaction computations; psi4.print_out(""\n""); p4util.banner((""Database %s Results"" % (db_name))); psi4.print_out(""\n""). maxactv = []; for rxn in HRXN:; maxactv.append(len(ACTV[dbse + '-' + str(rxn)])); maxrgt = max(maxactv); table_delimit = '-' * (54 + 20 * maxrgt); tables = ''. # find any reactions that are incomplete; FAIL = collections.defaultdict(int); for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn); for i in range(len(ACTV[db_rxn])):; if abs(ERGT[ACTV[db_rxn][i]]) < 1.0e-12:; FAIL[rxn] = 1. # tabulate requested process::environment variables; tables += """""" For each VARIABLE requested by tabulate, a 'Reaction Value' will be formed from\n""""""; tables += """""" 'Reagent' values according to weightings 'Wt', as for the REQUESTED ENERGY below.\n""""""; tables += """""" Depending on the nature of the variable, this may or may not make any physical sense.\n""""""; for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn); VRXN[db_rxn] = {}. for envv in db_tabulate:; envv = envv.upper(); tables += """"""\n ==> %s <==\n\n"""""" % (envv.title()); tables += tblhead(maxrgt, table_delimit, 2). for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn). if FAIL[rxn]:; tables += """"""\n%23s %8s %8s %8s"""""" % (db_rxn, '', '****', ''); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (VRGT[ACTV[db_rxn][i]][envv], RXNM[db_rxn][ACTV[db_rxn][i]]). else:; VRXN[db_rxn][envv] = 0.0; for i in range(len(ACTV[db_rxn])):; VRXN[db_rxn][envv] += VRGT[ACTV[db_rxn][i]][envv] * RXNM[db_rxn][ACTV[db_rxn][i]]. tables += """"""\n%23s %16.8f """""" % (db_rxn, VRXN[db_rxn][envv]); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (VRGT[ACT",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:47939,Modifiability,VARIAB,VARIABLE,47939," (ERGT[rgt])); elif (s[8:10] == ['variable', 'value']):; for envv in db_tabulate:; envv = envv.upper(); if (s[13:] == envv.split()):; VRGT[rgt][envv] = float(s[10]); psi4.print_out('DATABASE RESULT: variable %s value = %20.12f\n' % (envv, VRGT[rgt][envv])); freagent.close(). # end sow after writing files; if (db_mode.lower() == 'sow'):; return 0.0. # Reap all the necessary reaction computations; psi4.print_out(""\n""); p4util.banner((""Database %s Results"" % (db_name))); psi4.print_out(""\n""). maxactv = []; for rxn in HRXN:; maxactv.append(len(ACTV[dbse + '-' + str(rxn)])); maxrgt = max(maxactv); table_delimit = '-' * (54 + 20 * maxrgt); tables = ''. # find any reactions that are incomplete; FAIL = collections.defaultdict(int); for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn); for i in range(len(ACTV[db_rxn])):; if abs(ERGT[ACTV[db_rxn][i]]) < 1.0e-12:; FAIL[rxn] = 1. # tabulate requested process::environment variables; tables += """""" For each VARIABLE requested by tabulate, a 'Reaction Value' will be formed from\n""""""; tables += """""" 'Reagent' values according to weightings 'Wt', as for the REQUESTED ENERGY below.\n""""""; tables += """""" Depending on the nature of the variable, this may or may not make any physical sense.\n""""""; for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn); VRXN[db_rxn] = {}. for envv in db_tabulate:; envv = envv.upper(); tables += """"""\n ==> %s <==\n\n"""""" % (envv.title()); tables += tblhead(maxrgt, table_delimit, 2). for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn). if FAIL[rxn]:; tables += """"""\n%23s %8s %8s %8s"""""" % (db_rxn, '', '****', ''); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (VRGT[ACTV[db_rxn][i]][envv], RXNM[db_rxn][ACTV[db_rxn][i]]). else:; VRXN[db_rxn][envv] = 0.0; for i in range(len(ACTV[db_rxn])):; VRXN[db_rxn][envv] += VRGT[ACTV[db_rxn][i]][envv] * RXNM[db_rxn][ACTV[db_rxn][i]]. tables += """"""\n%23s %16.8f """""" % (db_rxn, VRXN[db_rxn][envv]); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (VRGT[ACT",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:48163,Modifiability,variab,variable,48163,"ut('DATABASE RESULT: variable %s value = %20.12f\n' % (envv, VRGT[rgt][envv])); freagent.close(). # end sow after writing files; if (db_mode.lower() == 'sow'):; return 0.0. # Reap all the necessary reaction computations; psi4.print_out(""\n""); p4util.banner((""Database %s Results"" % (db_name))); psi4.print_out(""\n""). maxactv = []; for rxn in HRXN:; maxactv.append(len(ACTV[dbse + '-' + str(rxn)])); maxrgt = max(maxactv); table_delimit = '-' * (54 + 20 * maxrgt); tables = ''. # find any reactions that are incomplete; FAIL = collections.defaultdict(int); for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn); for i in range(len(ACTV[db_rxn])):; if abs(ERGT[ACTV[db_rxn][i]]) < 1.0e-12:; FAIL[rxn] = 1. # tabulate requested process::environment variables; tables += """""" For each VARIABLE requested by tabulate, a 'Reaction Value' will be formed from\n""""""; tables += """""" 'Reagent' values according to weightings 'Wt', as for the REQUESTED ENERGY below.\n""""""; tables += """""" Depending on the nature of the variable, this may or may not make any physical sense.\n""""""; for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn); VRXN[db_rxn] = {}. for envv in db_tabulate:; envv = envv.upper(); tables += """"""\n ==> %s <==\n\n"""""" % (envv.title()); tables += tblhead(maxrgt, table_delimit, 2). for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn). if FAIL[rxn]:; tables += """"""\n%23s %8s %8s %8s"""""" % (db_rxn, '', '****', ''); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (VRGT[ACTV[db_rxn][i]][envv], RXNM[db_rxn][ACTV[db_rxn][i]]). else:; VRXN[db_rxn][envv] = 0.0; for i in range(len(ACTV[db_rxn])):; VRXN[db_rxn][envv] += VRGT[ACTV[db_rxn][i]][envv] * RXNM[db_rxn][ACTV[db_rxn][i]]. tables += """"""\n%23s %16.8f """""" % (db_rxn, VRXN[db_rxn][envv]); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (VRGT[ACTV[db_rxn][i]][envv], RXNM[db_rxn][ACTV[db_rxn][i]]); tables += """"""\n %s\n"""""" % (table_delimit). # tabulate primary requested energy variable with statistics; count_rxn = 0; minD",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:49119,Modifiability,variab,variable,49119,""" Depending on the nature of the variable, this may or may not make any physical sense.\n""""""; for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn); VRXN[db_rxn] = {}. for envv in db_tabulate:; envv = envv.upper(); tables += """"""\n ==> %s <==\n\n"""""" % (envv.title()); tables += tblhead(maxrgt, table_delimit, 2). for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn). if FAIL[rxn]:; tables += """"""\n%23s %8s %8s %8s"""""" % (db_rxn, '', '****', ''); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (VRGT[ACTV[db_rxn][i]][envv], RXNM[db_rxn][ACTV[db_rxn][i]]). else:; VRXN[db_rxn][envv] = 0.0; for i in range(len(ACTV[db_rxn])):; VRXN[db_rxn][envv] += VRGT[ACTV[db_rxn][i]][envv] * RXNM[db_rxn][ACTV[db_rxn][i]]. tables += """"""\n%23s %16.8f """""" % (db_rxn, VRXN[db_rxn][envv]); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (VRGT[ACTV[db_rxn][i]][envv], RXNM[db_rxn][ACTV[db_rxn][i]]); tables += """"""\n %s\n"""""" % (table_delimit). # tabulate primary requested energy variable with statistics; count_rxn = 0; minDerror = 100000.0; maxDerror = 0.0; MSDerror = 0.0; MADerror = 0.0; RMSDerror = 0.0. tables += """"""\n ==> %s <==\n\n"""""" % ('Requested Energy'); tables += tblhead(maxrgt, table_delimit, 1); for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn). if FAIL[rxn]:; tables += """"""\n%23s %8.4f %8s %8s"""""" % (db_rxn, BIND[db_rxn], '****', '****'); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (ERGT[ACTV[db_rxn][i]], RXNM[db_rxn][ACTV[db_rxn][i]]). else:; ERXN[db_rxn] = 0.0; for i in range(len(ACTV[db_rxn])):; ERXN[db_rxn] += ERGT[ACTV[db_rxn][i]] * RXNM[db_rxn][ACTV[db_rxn][i]]; error = p4const.psi_hartree2kcalmol * ERXN[db_rxn] - BIND[db_rxn]. tables += """"""\n%23s %8.4f %8.4f %8.4f"""""" % (db_rxn, BIND[db_rxn], p4const.psi_hartree2kcalmol * ERXN[db_rxn], error); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (ERGT[ACTV[db_rxn][i]], RXNM[db_rxn][ACTV[db_rxn][i]]). if abs(error) < abs(minDerror):; minDerror = error; if abs(error) > a",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:53165,Modifiability,variab,variables,53165,"""\n%23s %19s %6s"""""" % ('Reaction', 'Reaction Value', ''); for i in range(tbl_maxrgt):; tbl_str += """"""%20s"""""" % ('Reagent ' + str(i + 1)); if ttype == 1:; tbl_str += """"""\n%23s %8s %8s %8s"""""" % ('', 'Ref', 'Calc', '[kcal/mol]'); elif ttype == 2:; tbl_str += """"""\n%54s"""""" % (''); for i in range(tbl_maxrgt):; if ttype == 1:; tbl_str += """"""%20s"""""" % ('[H] Wt'); elif ttype == 2:; tbl_str += """"""%20s"""""" % ('Value Wt'); tbl_str += """"""\n %s"""""" % (tbl_delimit); return tbl_str. ## Aliases ##; db = database. #######################; ## End of Database ##; #######################. ###################################; ## Start of Complete Basis Set ##; ###################################. [docs]def complete_basis_set(name, **kwargs):; r""""""Function to define a multistage energy method from combinations of; basis set extrapolations and delta corrections and condense the; components into a minimum number of calculations. :aliases: cbs(). :returns: (*float*) -- Total electronic energy in Hartrees. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CBS TOTAL ENERGY <CBSTOTALENERGY>`; * :psivar:`CBS REFERENCE ENERGY <CBSREFERENCEENERGY>`; * :psivar:`CBS CORRELATION ENERGY <CBSCORRELATIONENERGY>`; * :psivar:`CURRENT ENERGY <CURRENTENERGY>`; * :psivar:`CURRENT REFERENCE ENERGY <CURRENTREFERENCEENERGY>`; * :psivar:`CURRENT CORRELATION ENERGY <CURRENTCORRELATIONENERGY>`. .. caution:: Some features are not yet implemented. Buy a developer a coffee. - Not all methods hooked in through PSI variables, configuration interaction and arbitrary order MP in particular. - No scheme defaults for given basis zeta number, so scheme must be specified explicitly. - No way to tell function to boost fitting basis size for all calculations. - No way to extrapolate def2 family basis sets. - Need to add more extrapolation schemes. As represented in the equation below, a CBS energy method is defined in several; sequential stages (scf, corl, delta, delta2, delta3, delta4, delta5) covering treatment; of the refer",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:53655,Modifiability,variab,variables,53655,"###################; ## End of Database ##; #######################. ###################################; ## Start of Complete Basis Set ##; ###################################. [docs]def complete_basis_set(name, **kwargs):; r""""""Function to define a multistage energy method from combinations of; basis set extrapolations and delta corrections and condense the; components into a minimum number of calculations. :aliases: cbs(). :returns: (*float*) -- Total electronic energy in Hartrees. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CBS TOTAL ENERGY <CBSTOTALENERGY>`; * :psivar:`CBS REFERENCE ENERGY <CBSREFERENCEENERGY>`; * :psivar:`CBS CORRELATION ENERGY <CBSCORRELATIONENERGY>`; * :psivar:`CURRENT ENERGY <CURRENTENERGY>`; * :psivar:`CURRENT REFERENCE ENERGY <CURRENTREFERENCEENERGY>`; * :psivar:`CURRENT CORRELATION ENERGY <CURRENTCORRELATIONENERGY>`. .. caution:: Some features are not yet implemented. Buy a developer a coffee. - Not all methods hooked in through PSI variables, configuration interaction and arbitrary order MP in particular. - No scheme defaults for given basis zeta number, so scheme must be specified explicitly. - No way to tell function to boost fitting basis size for all calculations. - No way to extrapolate def2 family basis sets. - Need to add more extrapolation schemes. As represented in the equation below, a CBS energy method is defined in several; sequential stages (scf, corl, delta, delta2, delta3, delta4, delta5) covering treatment; of the reference total energy, the correlation energy, a delta correction to the; correlation energy, and a second delta correction, etc.. Each is activated by its; stage_wfn keyword and is only allowed if all preceding stages are active. .. include:: cbs_eqn.rst. * Energy Methods; The presence of a stage_wfn keyword is the indicator to incorporate; (and check for stage_basis and stage_scheme keywords) and compute; that stage in defining the CBS energy. The cbs() function requires, at a minimum, ``name='scf'`` ",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:53666,Modifiability,config,configuration,53666,"###################; ## End of Database ##; #######################. ###################################; ## Start of Complete Basis Set ##; ###################################. [docs]def complete_basis_set(name, **kwargs):; r""""""Function to define a multistage energy method from combinations of; basis set extrapolations and delta corrections and condense the; components into a minimum number of calculations. :aliases: cbs(). :returns: (*float*) -- Total electronic energy in Hartrees. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CBS TOTAL ENERGY <CBSTOTALENERGY>`; * :psivar:`CBS REFERENCE ENERGY <CBSREFERENCEENERGY>`; * :psivar:`CBS CORRELATION ENERGY <CBSCORRELATIONENERGY>`; * :psivar:`CURRENT ENERGY <CURRENTENERGY>`; * :psivar:`CURRENT REFERENCE ENERGY <CURRENTREFERENCEENERGY>`; * :psivar:`CURRENT CORRELATION ENERGY <CURRENTCORRELATIONENERGY>`. .. caution:: Some features are not yet implemented. Buy a developer a coffee. - Not all methods hooked in through PSI variables, configuration interaction and arbitrary order MP in particular. - No scheme defaults for given basis zeta number, so scheme must be specified explicitly. - No way to tell function to boost fitting basis size for all calculations. - No way to extrapolate def2 family basis sets. - Need to add more extrapolation schemes. As represented in the equation below, a CBS energy method is defined in several; sequential stages (scf, corl, delta, delta2, delta3, delta4, delta5) covering treatment; of the reference total energy, the correlation energy, a delta correction to the; correlation energy, and a second delta correction, etc.. Each is activated by its; stage_wfn keyword and is only allowed if all preceding stages are active. .. include:: cbs_eqn.rst. * Energy Methods; The presence of a stage_wfn keyword is the indicator to incorporate; (and check for stage_basis and stage_scheme keywords) and compute; that stage in defining the CBS energy. The cbs() function requires, at a minimum, ``name='scf'`` ",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:86477,Modifiability,Variab,Variable,86477,"se). # Build string of title banner; cbsbanners = ''; cbsbanners += """"""psi4.print_out('\\n')\n""""""; cbsbanners += """"""p4util.banner(' CBS Results ')\n""""""; cbsbanners += """"""psi4.print_out('\\n')\n\n""""""; exec(cbsbanners). # Insert obtained energies into the array that stores the cbs stages; for stage in GRAND_NEED:; for lvl in stage['d_need'].items():; MODELCHEM.append(lvl[1]). for job in JOBS_EXT:; if ((lvl[1]['f_wfn'] == job['f_wfn']) and (lvl[1]['f_portion'] == job['f_portion']) and; (lvl[1]['f_basis'] == job['f_basis'])):; lvl[1]['f_energy'] = job['f_energy']. for stage in GRAND_NEED:; stage['d_energy'] = call_function_in_1st_argument(stage['d_scheme'], needname=stage['d_need'], mode='evaluate'); finalenergy += stage['d_energy'] * stage['d_coef']. # Build string of results table; table_delimit = ' ' + '-' * 105 + '\n'; tables = ''; tables += """"""\n ==> %s <==\n\n"""""" % ('Components'); tables += table_delimit; tables += """""" %6s %20s %1s %-26s %3s %16s %-s\n"""""" % ('', 'Method', '/', 'Basis', 'Rqd', 'Energy [H]', 'Variable'); tables += table_delimit; for job in JOBS_EXT:; star = ''; for mc in MODELCHEM:; if (job['f_wfn'] == mc['f_wfn']) and (job['f_basis'] == mc['f_basis']):; star = '*'; tables += """""" %6s %20s %1s %-27s %2s %16.8f %-s\n"""""" % ('', job['f_wfn'],; '/', job['f_basis'], star, job['f_energy'], VARH[job['f_wfn']][job['f_wfn'] + job['f_portion']]); tables += table_delimit. tables += """"""\n ==> %s <==\n\n"""""" % ('Stages'); tables += table_delimit; tables += """""" %6s %20s %1s %-27s %2s %16s %-s\n"""""" % ('Stage', 'Method', '/', 'Basis', 'Wt', 'Energy [H]', 'Scheme'); tables += table_delimit; for stage in GRAND_NEED:; tables += """""" %6s %20s %1s %-27s %2d %16.8f %-s\n"""""" % (stage['d_stage'], stage['d_wfn'],; '/', stage['d_basis'], stage['d_coef'], stage['d_energy'], stage['d_scheme'].__name__); tables += table_delimit. tables += """"""\n ==> %s <==\n\n"""""" % ('CBS'); tables += table_delimit; tables += """""" %6s %20s %1s %-27s %2s %16s %-s\n"""""" % ('Stage', 'Method', '/', 'Basis",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:1080,Performance,optimiz,optimize,1080,"]  ; Module code . Source code for wrappers; #; #@BEGIN LICENSE; #; # PSI4: an ab initio quantum chemistry software package; #; # This program is free software; you can redistribute it and/or modify; # it under the terms of the GNU General Public License as published by; # the Free Software Foundation; either version 2 of the License, or; # (at your option) any later version.; #; # This program is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU General Public License for more details.; #; # You should have received a copy of the GNU General Public License along; # with this program; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; #@END LICENSE; #. """"""Module with functions that call the four main :py:mod:`driver`; functions: :py:mod:`driver.energy`, :py:mod:`driver.optimize`,; :py:mod:`driver.response`, and :py:mod:`driver.frequency`. """"""; import re; import os; import math; import warnings; import pickle; import copy; import collections; import psi4; import p4const; import p4util; from driver import *; #from extend_Molecule import *; from molutil import *; from p4regex import *; # never import aliases into this file. # Function to make calls among wrappers(), energy(), optimize(), etc.; [docs]def call_function_in_1st_argument(funcarg, **largs):; r""""""Function to make primary function call to energy(), opt(), etc.; with options dictionary *largs*.; Useful when *funcarg* to call is stored in variable. """"""; return funcarg(**largs). [docs]def convert(p, symbol):; if symbol[p] == 'H':; d = 1.001; if symbol[p] == 'He':; d = 1.012; if symbol[p] == 'Li':; d = 0.825; if symbol[p] == 'Be':; d = 1.408; if symbol[p] == 'B':; d = 1.485; if symbol[p] == 'C':; d = 1.452; if symbol[p] == 'N':; d = 1.397; if symbol[p] == 'O':; d = 1.342; if symbol[p] == 'F':; d = 1.287; if symb",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:1492,Performance,optimiz,optimize,1492,".; #; # This program is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU General Public License for more details.; #; # You should have received a copy of the GNU General Public License along; # with this program; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; #@END LICENSE; #. """"""Module with functions that call the four main :py:mod:`driver`; functions: :py:mod:`driver.energy`, :py:mod:`driver.optimize`,; :py:mod:`driver.response`, and :py:mod:`driver.frequency`. """"""; import re; import os; import math; import warnings; import pickle; import copy; import collections; import psi4; import p4const; import p4util; from driver import *; #from extend_Molecule import *; from molutil import *; from p4regex import *; # never import aliases into this file. # Function to make calls among wrappers(), energy(), optimize(), etc.; [docs]def call_function_in_1st_argument(funcarg, **largs):; r""""""Function to make primary function call to energy(), opt(), etc.; with options dictionary *largs*.; Useful when *funcarg* to call is stored in variable. """"""; return funcarg(**largs). [docs]def convert(p, symbol):; if symbol[p] == 'H':; d = 1.001; if symbol[p] == 'He':; d = 1.012; if symbol[p] == 'Li':; d = 0.825; if symbol[p] == 'Be':; d = 1.408; if symbol[p] == 'B':; d = 1.485; if symbol[p] == 'C':; d = 1.452; if symbol[p] == 'N':; d = 1.397; if symbol[p] == 'O':; d = 1.342; if symbol[p] == 'F':; d = 1.287; if symbol[p] == 'Ne':; d = 1.243; if symbol[p] == 'Na':; d = 1.144; if symbol[p] == 'Mg':; d = 1.364; if symbol[p] == 'Al':; d = 1.639; if symbol[p] == 'Si':; d = 1.716; if symbol[p] == 'P':; d = 1.705; if symbol[p] == 'S':; d = 1.683; if symbol[p] == 'Cl':; d = 1.639; if symbol[p] == 'Ar':; d = 1.595. return d / 1.5. #Automatically detect fragments and build a new molecule for fragm",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:3058,Performance,Queue,Queue,3058,"1.287; if symbol[p] == 'Ne':; d = 1.243; if symbol[p] == 'Na':; d = 1.144; if symbol[p] == 'Mg':; d = 1.364; if symbol[p] == 'Al':; d = 1.639; if symbol[p] == 'Si':; d = 1.716; if symbol[p] == 'P':; d = 1.705; if symbol[p] == 'S':; d = 1.683; if symbol[p] == 'Cl':; d = 1.639; if symbol[p] == 'Ar':; d = 1.595. return d / 1.5. #Automatically detect fragments and build a new molecule for fragment; #needing methods (SAPT0, etc...); [docs]def auto_fragments(name, **kwargs):; r""""""; Detects fragments if the user does not supply them.; Currently only used for the WebMO implementation of SAPT. usage: auto_fragments(''); """"""; if 'molecule' in kwargs:; activate(kwargs['molecule']); del kwargs['molecule']; molecule = psi4.get_active_molecule(); molecule.update_geometry(). geom = molecule.save_string_xyz(). numatoms = molecule.natom(); VdW = [1.2, 1.7, 1.5, 1.55, 1.52, 1.9, 1.85, 1.8]. symbol = range(numatoms); X = [0.0] * numatoms; Y = [0.0] * numatoms; Z = [0.0] * numatoms. Queue = []; White = []; Black = []; F = geom.split('\n'); for f in range(0, numatoms):; A = F[f+1].split(); symbol[f] = A[0]; X[f] = float(A[1]); Y[f] = float(A[2]); Z[f] = float(A[3]); White.append(f); Fragment = [[] for i in range(numatoms)] # stores fragments. start = 0 # starts with the first atom in the list; Queue.append(start); White.remove(start). frag = 0. while((len(White) > 0) or (len(Queue) > 0)): # Iterates to the next fragment; while(len(Queue) > 0): # BFS within a fragment; for u in Queue: # find all nearest Neighbors; # (still coloured white) to vertex u; for i in White:; Distance = math.sqrt((X[i] - X[u]) * (X[i] - X[u]) +; (Y[i] - Y[u]) * (Y[i] - Y[u]) +; (Z[i] - Z[u]) * (Z[i] - Z[u])); if Distance < convert(u,symbol) + convert(i,symbol):; Queue.append(i) # if you find you, put it in the que; White.remove(i) # and remove it from the untouched list; Queue.remove(u) # remove focus from Queue; Black.append(u); Fragment[frag].append(int(u + 1)) # add to group (adding 1 to start; # list at one ",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:3374,Performance,Queue,Queue,3374,"1.639; if symbol[p] == 'Ar':; d = 1.595. return d / 1.5. #Automatically detect fragments and build a new molecule for fragment; #needing methods (SAPT0, etc...); [docs]def auto_fragments(name, **kwargs):; r""""""; Detects fragments if the user does not supply them.; Currently only used for the WebMO implementation of SAPT. usage: auto_fragments(''); """"""; if 'molecule' in kwargs:; activate(kwargs['molecule']); del kwargs['molecule']; molecule = psi4.get_active_molecule(); molecule.update_geometry(). geom = molecule.save_string_xyz(). numatoms = molecule.natom(); VdW = [1.2, 1.7, 1.5, 1.55, 1.52, 1.9, 1.85, 1.8]. symbol = range(numatoms); X = [0.0] * numatoms; Y = [0.0] * numatoms; Z = [0.0] * numatoms. Queue = []; White = []; Black = []; F = geom.split('\n'); for f in range(0, numatoms):; A = F[f+1].split(); symbol[f] = A[0]; X[f] = float(A[1]); Y[f] = float(A[2]); Z[f] = float(A[3]); White.append(f); Fragment = [[] for i in range(numatoms)] # stores fragments. start = 0 # starts with the first atom in the list; Queue.append(start); White.remove(start). frag = 0. while((len(White) > 0) or (len(Queue) > 0)): # Iterates to the next fragment; while(len(Queue) > 0): # BFS within a fragment; for u in Queue: # find all nearest Neighbors; # (still coloured white) to vertex u; for i in White:; Distance = math.sqrt((X[i] - X[u]) * (X[i] - X[u]) +; (Y[i] - Y[u]) * (Y[i] - Y[u]) +; (Z[i] - Z[u]) * (Z[i] - Z[u])); if Distance < convert(u,symbol) + convert(i,symbol):; Queue.append(i) # if you find you, put it in the que; White.remove(i) # and remove it from the untouched list; Queue.remove(u) # remove focus from Queue; Black.append(u); Fragment[frag].append(int(u + 1)) # add to group (adding 1 to start; # list at one instead of zero). if(len(White) != 0): # cant move White->Queue if no more exist; Queue.append(White[0]); White.remove(White[0]); frag += 1. new_geom = """"""\n0 1\n""""""; for i in Fragment[0]:; new_geom = new_geom + F[i].lstrip() + """"""\n""""""; new_geom = new_geom + """"""--\n0 1\",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:3457,Performance,Queue,Queue,3457,"args):; r""""""; Detects fragments if the user does not supply them.; Currently only used for the WebMO implementation of SAPT. usage: auto_fragments(''); """"""; if 'molecule' in kwargs:; activate(kwargs['molecule']); del kwargs['molecule']; molecule = psi4.get_active_molecule(); molecule.update_geometry(). geom = molecule.save_string_xyz(). numatoms = molecule.natom(); VdW = [1.2, 1.7, 1.5, 1.55, 1.52, 1.9, 1.85, 1.8]. symbol = range(numatoms); X = [0.0] * numatoms; Y = [0.0] * numatoms; Z = [0.0] * numatoms. Queue = []; White = []; Black = []; F = geom.split('\n'); for f in range(0, numatoms):; A = F[f+1].split(); symbol[f] = A[0]; X[f] = float(A[1]); Y[f] = float(A[2]); Z[f] = float(A[3]); White.append(f); Fragment = [[] for i in range(numatoms)] # stores fragments. start = 0 # starts with the first atom in the list; Queue.append(start); White.remove(start). frag = 0. while((len(White) > 0) or (len(Queue) > 0)): # Iterates to the next fragment; while(len(Queue) > 0): # BFS within a fragment; for u in Queue: # find all nearest Neighbors; # (still coloured white) to vertex u; for i in White:; Distance = math.sqrt((X[i] - X[u]) * (X[i] - X[u]) +; (Y[i] - Y[u]) * (Y[i] - Y[u]) +; (Z[i] - Z[u]) * (Z[i] - Z[u])); if Distance < convert(u,symbol) + convert(i,symbol):; Queue.append(i) # if you find you, put it in the que; White.remove(i) # and remove it from the untouched list; Queue.remove(u) # remove focus from Queue; Black.append(u); Fragment[frag].append(int(u + 1)) # add to group (adding 1 to start; # list at one instead of zero). if(len(White) != 0): # cant move White->Queue if no more exist; Queue.append(White[0]); White.remove(White[0]); frag += 1. new_geom = """"""\n0 1\n""""""; for i in Fragment[0]:; new_geom = new_geom + F[i].lstrip() + """"""\n""""""; new_geom = new_geom + """"""--\n0 1\n""""""; for j in Fragment[1]:; new_geom = new_geom + F[j].lstrip() + """"""\n""""""; new_geom = new_geom + """"""units angstrom\n"""""". new_mol = geometry(new_geom); new_mol.print_out(); psi4.print_out(""Exitin",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:3514,Performance,Queue,Queue,3514,"args):; r""""""; Detects fragments if the user does not supply them.; Currently only used for the WebMO implementation of SAPT. usage: auto_fragments(''); """"""; if 'molecule' in kwargs:; activate(kwargs['molecule']); del kwargs['molecule']; molecule = psi4.get_active_molecule(); molecule.update_geometry(). geom = molecule.save_string_xyz(). numatoms = molecule.natom(); VdW = [1.2, 1.7, 1.5, 1.55, 1.52, 1.9, 1.85, 1.8]. symbol = range(numatoms); X = [0.0] * numatoms; Y = [0.0] * numatoms; Z = [0.0] * numatoms. Queue = []; White = []; Black = []; F = geom.split('\n'); for f in range(0, numatoms):; A = F[f+1].split(); symbol[f] = A[0]; X[f] = float(A[1]); Y[f] = float(A[2]); Z[f] = float(A[3]); White.append(f); Fragment = [[] for i in range(numatoms)] # stores fragments. start = 0 # starts with the first atom in the list; Queue.append(start); White.remove(start). frag = 0. while((len(White) > 0) or (len(Queue) > 0)): # Iterates to the next fragment; while(len(Queue) > 0): # BFS within a fragment; for u in Queue: # find all nearest Neighbors; # (still coloured white) to vertex u; for i in White:; Distance = math.sqrt((X[i] - X[u]) * (X[i] - X[u]) +; (Y[i] - Y[u]) * (Y[i] - Y[u]) +; (Z[i] - Z[u]) * (Z[i] - Z[u])); if Distance < convert(u,symbol) + convert(i,symbol):; Queue.append(i) # if you find you, put it in the que; White.remove(i) # and remove it from the untouched list; Queue.remove(u) # remove focus from Queue; Black.append(u); Fragment[frag].append(int(u + 1)) # add to group (adding 1 to start; # list at one instead of zero). if(len(White) != 0): # cant move White->Queue if no more exist; Queue.append(White[0]); White.remove(White[0]); frag += 1. new_geom = """"""\n0 1\n""""""; for i in Fragment[0]:; new_geom = new_geom + F[i].lstrip() + """"""\n""""""; new_geom = new_geom + """"""--\n0 1\n""""""; for j in Fragment[1]:; new_geom = new_geom + F[j].lstrip() + """"""\n""""""; new_geom = new_geom + """"""units angstrom\n"""""". new_mol = geometry(new_geom); new_mol.print_out(); psi4.print_out(""Exitin",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:3561,Performance,Queue,Queue,3561,"args):; r""""""; Detects fragments if the user does not supply them.; Currently only used for the WebMO implementation of SAPT. usage: auto_fragments(''); """"""; if 'molecule' in kwargs:; activate(kwargs['molecule']); del kwargs['molecule']; molecule = psi4.get_active_molecule(); molecule.update_geometry(). geom = molecule.save_string_xyz(). numatoms = molecule.natom(); VdW = [1.2, 1.7, 1.5, 1.55, 1.52, 1.9, 1.85, 1.8]. symbol = range(numatoms); X = [0.0] * numatoms; Y = [0.0] * numatoms; Z = [0.0] * numatoms. Queue = []; White = []; Black = []; F = geom.split('\n'); for f in range(0, numatoms):; A = F[f+1].split(); symbol[f] = A[0]; X[f] = float(A[1]); Y[f] = float(A[2]); Z[f] = float(A[3]); White.append(f); Fragment = [[] for i in range(numatoms)] # stores fragments. start = 0 # starts with the first atom in the list; Queue.append(start); White.remove(start). frag = 0. while((len(White) > 0) or (len(Queue) > 0)): # Iterates to the next fragment; while(len(Queue) > 0): # BFS within a fragment; for u in Queue: # find all nearest Neighbors; # (still coloured white) to vertex u; for i in White:; Distance = math.sqrt((X[i] - X[u]) * (X[i] - X[u]) +; (Y[i] - Y[u]) * (Y[i] - Y[u]) +; (Z[i] - Z[u]) * (Z[i] - Z[u])); if Distance < convert(u,symbol) + convert(i,symbol):; Queue.append(i) # if you find you, put it in the que; White.remove(i) # and remove it from the untouched list; Queue.remove(u) # remove focus from Queue; Black.append(u); Fragment[frag].append(int(u + 1)) # add to group (adding 1 to start; # list at one instead of zero). if(len(White) != 0): # cant move White->Queue if no more exist; Queue.append(White[0]); White.remove(White[0]); frag += 1. new_geom = """"""\n0 1\n""""""; for i in Fragment[0]:; new_geom = new_geom + F[i].lstrip() + """"""\n""""""; new_geom = new_geom + """"""--\n0 1\n""""""; for j in Fragment[1]:; new_geom = new_geom + F[j].lstrip() + """"""\n""""""; new_geom = new_geom + """"""units angstrom\n"""""". new_mol = geometry(new_geom); new_mol.print_out(); psi4.print_out(""Exitin",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:3826,Performance,Queue,Queue,3826,"ecule']); del kwargs['molecule']; molecule = psi4.get_active_molecule(); molecule.update_geometry(). geom = molecule.save_string_xyz(). numatoms = molecule.natom(); VdW = [1.2, 1.7, 1.5, 1.55, 1.52, 1.9, 1.85, 1.8]. symbol = range(numatoms); X = [0.0] * numatoms; Y = [0.0] * numatoms; Z = [0.0] * numatoms. Queue = []; White = []; Black = []; F = geom.split('\n'); for f in range(0, numatoms):; A = F[f+1].split(); symbol[f] = A[0]; X[f] = float(A[1]); Y[f] = float(A[2]); Z[f] = float(A[3]); White.append(f); Fragment = [[] for i in range(numatoms)] # stores fragments. start = 0 # starts with the first atom in the list; Queue.append(start); White.remove(start). frag = 0. while((len(White) > 0) or (len(Queue) > 0)): # Iterates to the next fragment; while(len(Queue) > 0): # BFS within a fragment; for u in Queue: # find all nearest Neighbors; # (still coloured white) to vertex u; for i in White:; Distance = math.sqrt((X[i] - X[u]) * (X[i] - X[u]) +; (Y[i] - Y[u]) * (Y[i] - Y[u]) +; (Z[i] - Z[u]) * (Z[i] - Z[u])); if Distance < convert(u,symbol) + convert(i,symbol):; Queue.append(i) # if you find you, put it in the que; White.remove(i) # and remove it from the untouched list; Queue.remove(u) # remove focus from Queue; Black.append(u); Fragment[frag].append(int(u + 1)) # add to group (adding 1 to start; # list at one instead of zero). if(len(White) != 0): # cant move White->Queue if no more exist; Queue.append(White[0]); White.remove(White[0]); frag += 1. new_geom = """"""\n0 1\n""""""; for i in Fragment[0]:; new_geom = new_geom + F[i].lstrip() + """"""\n""""""; new_geom = new_geom + """"""--\n0 1\n""""""; for j in Fragment[1]:; new_geom = new_geom + F[j].lstrip() + """"""\n""""""; new_geom = new_geom + """"""units angstrom\n"""""". new_mol = geometry(new_geom); new_mol.print_out(); psi4.print_out(""Exiting auto_fragments\n""). #######################; ## Start of n_body ##; #######################. [docs]def n_body(name, **kwargs):; lowername = name.lower(); kwargs = p4util.kwargs_lower(kwargs). # Wrap any",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:3937,Performance,Queue,Queue,3937," VdW = [1.2, 1.7, 1.5, 1.55, 1.52, 1.9, 1.85, 1.8]. symbol = range(numatoms); X = [0.0] * numatoms; Y = [0.0] * numatoms; Z = [0.0] * numatoms. Queue = []; White = []; Black = []; F = geom.split('\n'); for f in range(0, numatoms):; A = F[f+1].split(); symbol[f] = A[0]; X[f] = float(A[1]); Y[f] = float(A[2]); Z[f] = float(A[3]); White.append(f); Fragment = [[] for i in range(numatoms)] # stores fragments. start = 0 # starts with the first atom in the list; Queue.append(start); White.remove(start). frag = 0. while((len(White) > 0) or (len(Queue) > 0)): # Iterates to the next fragment; while(len(Queue) > 0): # BFS within a fragment; for u in Queue: # find all nearest Neighbors; # (still coloured white) to vertex u; for i in White:; Distance = math.sqrt((X[i] - X[u]) * (X[i] - X[u]) +; (Y[i] - Y[u]) * (Y[i] - Y[u]) +; (Z[i] - Z[u]) * (Z[i] - Z[u])); if Distance < convert(u,symbol) + convert(i,symbol):; Queue.append(i) # if you find you, put it in the que; White.remove(i) # and remove it from the untouched list; Queue.remove(u) # remove focus from Queue; Black.append(u); Fragment[frag].append(int(u + 1)) # add to group (adding 1 to start; # list at one instead of zero). if(len(White) != 0): # cant move White->Queue if no more exist; Queue.append(White[0]); White.remove(White[0]); frag += 1. new_geom = """"""\n0 1\n""""""; for i in Fragment[0]:; new_geom = new_geom + F[i].lstrip() + """"""\n""""""; new_geom = new_geom + """"""--\n0 1\n""""""; for j in Fragment[1]:; new_geom = new_geom + F[j].lstrip() + """"""\n""""""; new_geom = new_geom + """"""units angstrom\n"""""". new_mol = geometry(new_geom); new_mol.print_out(); psi4.print_out(""Exiting auto_fragments\n""). #######################; ## Start of n_body ##; #######################. [docs]def n_body(name, **kwargs):; lowername = name.lower(); kwargs = p4util.kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name.lower(). # Establish function to call; ",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:3973,Performance,Queue,Queue,3973,". symbol = range(numatoms); X = [0.0] * numatoms; Y = [0.0] * numatoms; Z = [0.0] * numatoms. Queue = []; White = []; Black = []; F = geom.split('\n'); for f in range(0, numatoms):; A = F[f+1].split(); symbol[f] = A[0]; X[f] = float(A[1]); Y[f] = float(A[2]); Z[f] = float(A[3]); White.append(f); Fragment = [[] for i in range(numatoms)] # stores fragments. start = 0 # starts with the first atom in the list; Queue.append(start); White.remove(start). frag = 0. while((len(White) > 0) or (len(Queue) > 0)): # Iterates to the next fragment; while(len(Queue) > 0): # BFS within a fragment; for u in Queue: # find all nearest Neighbors; # (still coloured white) to vertex u; for i in White:; Distance = math.sqrt((X[i] - X[u]) * (X[i] - X[u]) +; (Y[i] - Y[u]) * (Y[i] - Y[u]) +; (Z[i] - Z[u]) * (Z[i] - Z[u])); if Distance < convert(u,symbol) + convert(i,symbol):; Queue.append(i) # if you find you, put it in the que; White.remove(i) # and remove it from the untouched list; Queue.remove(u) # remove focus from Queue; Black.append(u); Fragment[frag].append(int(u + 1)) # add to group (adding 1 to start; # list at one instead of zero). if(len(White) != 0): # cant move White->Queue if no more exist; Queue.append(White[0]); White.remove(White[0]); frag += 1. new_geom = """"""\n0 1\n""""""; for i in Fragment[0]:; new_geom = new_geom + F[i].lstrip() + """"""\n""""""; new_geom = new_geom + """"""--\n0 1\n""""""; for j in Fragment[1]:; new_geom = new_geom + F[j].lstrip() + """"""\n""""""; new_geom = new_geom + """"""units angstrom\n"""""". new_mol = geometry(new_geom); new_mol.print_out(); psi4.print_out(""Exiting auto_fragments\n""). #######################; ## Start of n_body ##; #######################. [docs]def n_body(name, **kwargs):; lowername = name.lower(); kwargs = p4util.kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name.lower(). # Establish function to call; if not('n_body_func' in kwargs):; if ('func' in kw",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:4138,Performance,Queue,Queue,4138,", numatoms):; A = F[f+1].split(); symbol[f] = A[0]; X[f] = float(A[1]); Y[f] = float(A[2]); Z[f] = float(A[3]); White.append(f); Fragment = [[] for i in range(numatoms)] # stores fragments. start = 0 # starts with the first atom in the list; Queue.append(start); White.remove(start). frag = 0. while((len(White) > 0) or (len(Queue) > 0)): # Iterates to the next fragment; while(len(Queue) > 0): # BFS within a fragment; for u in Queue: # find all nearest Neighbors; # (still coloured white) to vertex u; for i in White:; Distance = math.sqrt((X[i] - X[u]) * (X[i] - X[u]) +; (Y[i] - Y[u]) * (Y[i] - Y[u]) +; (Z[i] - Z[u]) * (Z[i] - Z[u])); if Distance < convert(u,symbol) + convert(i,symbol):; Queue.append(i) # if you find you, put it in the que; White.remove(i) # and remove it from the untouched list; Queue.remove(u) # remove focus from Queue; Black.append(u); Fragment[frag].append(int(u + 1)) # add to group (adding 1 to start; # list at one instead of zero). if(len(White) != 0): # cant move White->Queue if no more exist; Queue.append(White[0]); White.remove(White[0]); frag += 1. new_geom = """"""\n0 1\n""""""; for i in Fragment[0]:; new_geom = new_geom + F[i].lstrip() + """"""\n""""""; new_geom = new_geom + """"""--\n0 1\n""""""; for j in Fragment[1]:; new_geom = new_geom + F[j].lstrip() + """"""\n""""""; new_geom = new_geom + """"""units angstrom\n"""""". new_mol = geometry(new_geom); new_mol.print_out(); psi4.print_out(""Exiting auto_fragments\n""). #######################; ## Start of n_body ##; #######################. [docs]def n_body(name, **kwargs):; lowername = name.lower(); kwargs = p4util.kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name.lower(). # Establish function to call; if not('n_body_func' in kwargs):; if ('func' in kwargs):; kwargs['n_body_func'] = kwargs['func']; del kwargs['func']; else:; kwargs['n_body_func'] = energy; func = kwargs['n_body_func']; if not func:; raise ValidationE",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:4162,Performance,Queue,Queue,4162,", numatoms):; A = F[f+1].split(); symbol[f] = A[0]; X[f] = float(A[1]); Y[f] = float(A[2]); Z[f] = float(A[3]); White.append(f); Fragment = [[] for i in range(numatoms)] # stores fragments. start = 0 # starts with the first atom in the list; Queue.append(start); White.remove(start). frag = 0. while((len(White) > 0) or (len(Queue) > 0)): # Iterates to the next fragment; while(len(Queue) > 0): # BFS within a fragment; for u in Queue: # find all nearest Neighbors; # (still coloured white) to vertex u; for i in White:; Distance = math.sqrt((X[i] - X[u]) * (X[i] - X[u]) +; (Y[i] - Y[u]) * (Y[i] - Y[u]) +; (Z[i] - Z[u]) * (Z[i] - Z[u])); if Distance < convert(u,symbol) + convert(i,symbol):; Queue.append(i) # if you find you, put it in the que; White.remove(i) # and remove it from the untouched list; Queue.remove(u) # remove focus from Queue; Black.append(u); Fragment[frag].append(int(u + 1)) # add to group (adding 1 to start; # list at one instead of zero). if(len(White) != 0): # cant move White->Queue if no more exist; Queue.append(White[0]); White.remove(White[0]); frag += 1. new_geom = """"""\n0 1\n""""""; for i in Fragment[0]:; new_geom = new_geom + F[i].lstrip() + """"""\n""""""; new_geom = new_geom + """"""--\n0 1\n""""""; for j in Fragment[1]:; new_geom = new_geom + F[j].lstrip() + """"""\n""""""; new_geom = new_geom + """"""units angstrom\n"""""". new_mol = geometry(new_geom); new_mol.print_out(); psi4.print_out(""Exiting auto_fragments\n""). #######################; ## Start of n_body ##; #######################. [docs]def n_body(name, **kwargs):; lowername = name.lower(); kwargs = p4util.kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name.lower(). # Establish function to call; if not('n_body_func' in kwargs):; if ('func' in kwargs):; kwargs['n_body_func'] = kwargs['func']; del kwargs['func']; else:; kwargs['n_body_func'] = energy; func = kwargs['n_body_func']; if not func:; raise ValidationE",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:7975,Performance,LOAD,LOAD,7975,"\n'); psi4.print_out(' BSSE Treatment: %s\n' % (bsse)); psi4.print_out(' Maximum N-Body Interactions: %d\n' % (max_n_body)); psi4.print_out(' Compute Total Energy: %s\n' % (do_total)); psi4.print_out(' External Field: %s\n' % (has_external)); if (external):; psi4.print_out(' External Field Monomers: '); for k in external_indices:; psi4.print_out('%-3d ' % (k)); psi4.print_out('\n'); psi4.print_out('\n'). # Run the total molecule, if required; energies_full = {}; energies_mon = {}; N = molecule.nfragments(); Etotal = 0.0; if do_total or max_n_body == molecule.nfragments():; psi4.print_out(' => Total Cluster Energy <=\n'); # Full cluster always gets the external field; if (external):; psi4.set_global_option_python(""EXTERN"", external); Etotal = call_function_in_1st_argument(func, **kwargs); if (external):; psi4.set_global_option_python(""EXTERN"", None); energies_full[N] = []; energies_full[N].append(Etotal); energies_mon[N] = []; energies_mon[N].append(Etotal); psi4.set_global_option('DF_INTS_IO', 'LOAD'); psi4.clean(). max_effective = max_n_body; if (max_effective == N):; max_effective = N - 1. # Build the combos for indexing purposes; Ns = []; if (max_n_body == N or do_total):; Ns.append(N); for n in range(max_effective, 0, -1):; Ns.append(n). combos = {}; for n in Ns:. combos[n] = []. # Loop through combinations in lexical order #. # initialize the reals list; reals = []; #setup first combination [3,2,1] lexical ordering; #fragments indexing is 1's based, bloody hell; for index in range(n, 0, -1):; reals.append(index); #start loop through lexical promotion; counter = 0; while True:. counter = counter + 1. # Append the current combo; combos[n].append(copy.deepcopy(reals)). #reset rank; rank = 0. #look for lexical promotion opportunity; #i.e.: [4 2 1] has a promotion opportunity at; # index 1 to produce [4 3 1]; for k in range(n - 2, -1, -1):; if (reals[k] != reals[k + 1] + 1):; rank = k + 1; break. #do the promotion; reals[rank] = reals[rank] + 1. #demote the right po",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:9995,Performance,LOAD,LOAD,9995,"r; val = 1; for k in range(n - 1, rank, -1):; reals[k] = val; val = val + 1. #boundary condition is promotion into; #[nfrag+1 nfrag-1 ...]; if (reals[0] > N):; break. # Hack for external; externNone = psi4.ExternalPotential(). # Run the clusters in the full basis; if bsse == 'on' or bsse == 'both':; for n in range(max_effective, 0, -1):; energies_full[n] = []; clusters = extract_clusters(molecule, True, n); for k in range(len(clusters)):; activate(clusters[k]); # Do the external field for this cluster or not?; if (external):; do_extern = False; for mon in combos[n][k]:; if (mon in external_indices):; do_extern = True; break; if do_extern:; psi4.set_global_option_python(""EXTERN"", external); psi4.print_out('\n => Cluster (N-Body %4d, Combination %4d) Energy (Full Basis) <=\n' % (n, k + 1)); energies_full[n].append(call_function_in_1st_argument(func, **kwargs)); # Turn the external field off; if (external):; psi4.set_global_option_python(""EXTERN"", externNone); psi4.set_global_option('DF_INTS_IO', 'LOAD'); psi4.clean(). # Run the clusters in the minimal cluster bases; psi4.set_global_option('DF_INTS_IO', 'NONE'); if bsse == 'off' or bsse == 'both':; for n in range(max_effective, 0, -1):; energies_mon[n] = []; clusters = extract_clusters(molecule, False, n); for k in range(len(clusters)):; activate(clusters[k]); # Do the external field for this cluster or not?; if (external):; do_extern = False; for mon in combos[n][k]:; if (mon in external_indices):; do_extern = True; break; if do_extern:; psi4.set_global_option_python(""EXTERN"", external); psi4.print_out('\n => Cluster (N-Body %4d, Combination %4d) Energy (Cluster Basis) <=\n' % (n, k + 1)); energies_mon[n].append(call_function_in_1st_argument(func, **kwargs)); # Turn the external field off; if (external):; psi4.set_global_option_python(""EXTERN"", externNone); psi4.clean(). # Report the energies; psi4.print_out('\n ==> N-Body Interaction Energy Analysis: Combination Definitions <==\n\n'). psi4.print_out(' %6s %6s | %-24s",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:17971,Performance,optimiz,optimize,17971,"e cp function computes counterpoise-corrected two-body interaction energies; for complexes composed of arbitrary numbers of monomers. :aliases: counterpoise_correct(), counterpoise_correction(). :returns: (*float*) Counterpoise-corrected interaction energy in Hartrees. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CP-CORRECTED 2-BODY INTERACTION ENERGY <CP-CORRECTED2-BODYINTERACTIONENERGY>`; * :psivar:`UNCP-CORRECTED 2-BODY INTERACTION ENERGY <UNCP-CORRECTED2-BODYINTERACTIONENERGY>`. .. caution:: Some features are not yet implemented. Buy a developer a coffee. - No values of func besides energy have been tested. - Table print-out needs improving. Add some PSI variables. :type name: string; :param name: ``'scf'`` || ``'ccsd(t)'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the molecule. May be any valid argument to; :py:func:`~driver.energy`; however, SAPT is not appropriate. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``energy`` |dr| || ``optimize`` || ``cbs``. Indicates the type of calculation to be performed on the molecule; and each of its monomers. The default performs a single-point; ``energy('name')``, while ``optimize`` perfoms a geometry optimization; on each system, and ``cbs`` performs a compound single-point energy.; If a nested series of python functions is intended; (see :ref:`sec:intercalls`), use keyword ``cp_func`` instead of ``func``. :type check_bsse: :ref:`boolean <op_py_boolean>`; :param check_bsse: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether to additionally compute un-counterpoise corrected; monomers and thus obtain an estimate for the basis set superposition error. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :examples:. >>> # [1] counterpoise-corrected mp2 interaction energy; >>> cp('df-mp2'). """"""; lowername = name.lower(); kwargs = p4util.kwargs_lower(kwargs). # Wrap",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:18034,Performance,perform,performed,18034,"of arbitrary numbers of monomers. :aliases: counterpoise_correct(), counterpoise_correction(). :returns: (*float*) Counterpoise-corrected interaction energy in Hartrees. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CP-CORRECTED 2-BODY INTERACTION ENERGY <CP-CORRECTED2-BODYINTERACTIONENERGY>`; * :psivar:`UNCP-CORRECTED 2-BODY INTERACTION ENERGY <UNCP-CORRECTED2-BODYINTERACTIONENERGY>`. .. caution:: Some features are not yet implemented. Buy a developer a coffee. - No values of func besides energy have been tested. - Table print-out needs improving. Add some PSI variables. :type name: string; :param name: ``'scf'`` || ``'ccsd(t)'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the molecule. May be any valid argument to; :py:func:`~driver.energy`; however, SAPT is not appropriate. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``energy`` |dr| || ``optimize`` || ``cbs``. Indicates the type of calculation to be performed on the molecule; and each of its monomers. The default performs a single-point; ``energy('name')``, while ``optimize`` perfoms a geometry optimization; on each system, and ``cbs`` performs a compound single-point energy.; If a nested series of python functions is intended; (see :ref:`sec:intercalls`), use keyword ``cp_func`` instead of ``func``. :type check_bsse: :ref:`boolean <op_py_boolean>`; :param check_bsse: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether to additionally compute un-counterpoise corrected; monomers and thus obtain an estimate for the basis set superposition error. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :examples:. >>> # [1] counterpoise-corrected mp2 interaction energy; >>> cp('df-mp2'). """"""; lowername = name.lower(); kwargs = p4util.kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and n",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:18099,Performance,perform,performs,18099,"d interaction energy in Hartrees. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CP-CORRECTED 2-BODY INTERACTION ENERGY <CP-CORRECTED2-BODYINTERACTIONENERGY>`; * :psivar:`UNCP-CORRECTED 2-BODY INTERACTION ENERGY <UNCP-CORRECTED2-BODYINTERACTIONENERGY>`. .. caution:: Some features are not yet implemented. Buy a developer a coffee. - No values of func besides energy have been tested. - Table print-out needs improving. Add some PSI variables. :type name: string; :param name: ``'scf'`` || ``'ccsd(t)'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the molecule. May be any valid argument to; :py:func:`~driver.energy`; however, SAPT is not appropriate. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``energy`` |dr| || ``optimize`` || ``cbs``. Indicates the type of calculation to be performed on the molecule; and each of its monomers. The default performs a single-point; ``energy('name')``, while ``optimize`` perfoms a geometry optimization; on each system, and ``cbs`` performs a compound single-point energy.; If a nested series of python functions is intended; (see :ref:`sec:intercalls`), use keyword ``cp_func`` instead of ``func``. :type check_bsse: :ref:`boolean <op_py_boolean>`; :param check_bsse: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether to additionally compute un-counterpoise corrected; monomers and thus obtain an estimate for the basis set superposition error. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :examples:. >>> # [1] counterpoise-corrected mp2 interaction energy; >>> cp('df-mp2'). """"""; lowername = name.lower(); kwargs = p4util.kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name.lower(). # Establish function to call; if not('cp_func' in kwargs):; if ('func' in kwargs):; kwargs['cp_fun",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:18152,Performance,optimiz,optimize,18152,"d interaction energy in Hartrees. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CP-CORRECTED 2-BODY INTERACTION ENERGY <CP-CORRECTED2-BODYINTERACTIONENERGY>`; * :psivar:`UNCP-CORRECTED 2-BODY INTERACTION ENERGY <UNCP-CORRECTED2-BODYINTERACTIONENERGY>`. .. caution:: Some features are not yet implemented. Buy a developer a coffee. - No values of func besides energy have been tested. - Table print-out needs improving. Add some PSI variables. :type name: string; :param name: ``'scf'`` || ``'ccsd(t)'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the molecule. May be any valid argument to; :py:func:`~driver.energy`; however, SAPT is not appropriate. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``energy`` |dr| || ``optimize`` || ``cbs``. Indicates the type of calculation to be performed on the molecule; and each of its monomers. The default performs a single-point; ``energy('name')``, while ``optimize`` perfoms a geometry optimization; on each system, and ``cbs`` performs a compound single-point energy.; If a nested series of python functions is intended; (see :ref:`sec:intercalls`), use keyword ``cp_func`` instead of ``func``. :type check_bsse: :ref:`boolean <op_py_boolean>`; :param check_bsse: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether to additionally compute un-counterpoise corrected; monomers and thus obtain an estimate for the basis set superposition error. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :examples:. >>> # [1] counterpoise-corrected mp2 interaction energy; >>> cp('df-mp2'). """"""; lowername = name.lower(); kwargs = p4util.kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name.lower(). # Establish function to call; if not('cp_func' in kwargs):; if ('func' in kwargs):; kwargs['cp_fun",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:18182,Performance,optimiz,optimization,18182,"d interaction energy in Hartrees. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CP-CORRECTED 2-BODY INTERACTION ENERGY <CP-CORRECTED2-BODYINTERACTIONENERGY>`; * :psivar:`UNCP-CORRECTED 2-BODY INTERACTION ENERGY <UNCP-CORRECTED2-BODYINTERACTIONENERGY>`. .. caution:: Some features are not yet implemented. Buy a developer a coffee. - No values of func besides energy have been tested. - Table print-out needs improving. Add some PSI variables. :type name: string; :param name: ``'scf'`` || ``'ccsd(t)'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the molecule. May be any valid argument to; :py:func:`~driver.energy`; however, SAPT is not appropriate. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``energy`` |dr| || ``optimize`` || ``cbs``. Indicates the type of calculation to be performed on the molecule; and each of its monomers. The default performs a single-point; ``energy('name')``, while ``optimize`` perfoms a geometry optimization; on each system, and ``cbs`` performs a compound single-point energy.; If a nested series of python functions is intended; (see :ref:`sec:intercalls`), use keyword ``cp_func`` instead of ``func``. :type check_bsse: :ref:`boolean <op_py_boolean>`; :param check_bsse: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether to additionally compute un-counterpoise corrected; monomers and thus obtain an estimate for the basis set superposition error. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :examples:. >>> # [1] counterpoise-corrected mp2 interaction energy; >>> cp('df-mp2'). """"""; lowername = name.lower(); kwargs = p4util.kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name.lower(). # Establish function to call; if not('cp_func' in kwargs):; if ('func' in kwargs):; kwargs['cp_fun",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:18224,Performance,perform,performs,18224,"d interaction energy in Hartrees. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CP-CORRECTED 2-BODY INTERACTION ENERGY <CP-CORRECTED2-BODYINTERACTIONENERGY>`; * :psivar:`UNCP-CORRECTED 2-BODY INTERACTION ENERGY <UNCP-CORRECTED2-BODYINTERACTIONENERGY>`. .. caution:: Some features are not yet implemented. Buy a developer a coffee. - No values of func besides energy have been tested. - Table print-out needs improving. Add some PSI variables. :type name: string; :param name: ``'scf'`` || ``'ccsd(t)'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the molecule. May be any valid argument to; :py:func:`~driver.energy`; however, SAPT is not appropriate. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``energy`` |dr| || ``optimize`` || ``cbs``. Indicates the type of calculation to be performed on the molecule; and each of its monomers. The default performs a single-point; ``energy('name')``, while ``optimize`` perfoms a geometry optimization; on each system, and ``cbs`` performs a compound single-point energy.; If a nested series of python functions is intended; (see :ref:`sec:intercalls`), use keyword ``cp_func`` instead of ``func``. :type check_bsse: :ref:`boolean <op_py_boolean>`; :param check_bsse: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether to additionally compute un-counterpoise corrected; monomers and thus obtain an estimate for the basis set superposition error. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :examples:. >>> # [1] counterpoise-corrected mp2 interaction energy; >>> cp('df-mp2'). """"""; lowername = name.lower(); kwargs = p4util.kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name.lower(). # Establish function to call; if not('cp_func' in kwargs):; if ('func' in kwargs):; kwargs['cp_fun",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:20465,Performance,LOAD,LOAD,20465,"('Wrapper counterpoise_correct is unhappy to be calling function \'%s\'.' % (func.__name__)). if 'check_bsse' in kwargs and yes.match(str(kwargs['check_bsse'])):; check_bsse = True; else:; check_bsse = False. # Make sure the molecule the user provided is the active one; if 'molecule' in kwargs:; activate(kwargs['molecule']); del kwargs['molecule']; molecule = psi4.get_active_molecule(); molecule.update_geometry(); psi4.set_global_option(""BASIS"", psi4.get_global_option(""BASIS"")). df_ints_io = psi4.get_global_option('DF_INTS_IO'); # inquire if above at all applies to dfmp2 or just scf; psi4.set_global_option('DF_INTS_IO', 'SAVE'); psioh = psi4.IOManager.shared_object(); psioh.set_specific_retention(97, True). activate(molecule); molecule.update_geometry(). psi4.print_out(""\n""); p4util.banner(""CP Computation: Complex.\nFull Basis Set.""); psi4.print_out(""\n""); e_dimer = call_function_in_1st_argument(func, **kwargs); #e_dimer = energy(name, **kwargs). psi4.clean(); psi4.set_global_option('DF_INTS_IO', 'LOAD'). # All monomers with ghosts; monomers = extract_clusters(molecule, True, 1); e_monomer_full = []. cluster_n = 0; for cluster in monomers:; activate(cluster); psi4.print_out(""\n""); p4util.banner((""CP Computation: Monomer %d.\n Full Basis Set."" % (cluster_n + 1))); psi4.print_out(""\n""); e_monomer_full.append(call_function_in_1st_argument(func, **kwargs)); #e_monomer_full.append(energy(name,**kwargs)); cluster_n = cluster_n + 1; psi4.clean(). psi4.set_global_option('DF_INTS_IO', 'NONE'); if (check_bsse):; # All monomers without ghosts; monomers = extract_clusters(molecule, False, 1); e_monomer_bsse = []. cluster_n = 0; for cluster in monomers:; activate(cluster); psi4.print_out(""\n""); #cluster.print_to_output(); p4util.banner((""CP Computation: Monomer %d.\n Monomer Set."" % (cluster_n + 1))); psi4.print_out(""\n""); e_monomer_bsse.append(call_function_in_1st_argument(func, **kwargs)); #e_monomer_bsse.append(energy(name,**kwargs)); cluster_n = cluster_n + 1. psi4.set_globa",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:25081,Performance,optimiz,optimize,25081,"re not yet implemented. Buy a developer some coffee. - In sow/reap mode, use only global options (e.g., the local option set by ``set scf scf_type df`` will not be respected). .. note:: To access a database that is not embedded in a |PSIfour|; distribution, add the path to the directory containing the database; to the environment variable :envvar:`PYTHONPATH`. :type name: string; :param name: ``'scf'`` || ``'sapt0'`` || ``'ccsd(t)'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; :py:func:`~driver.energy`. :type db_name: string; :param db_name: ``'BASIC'`` || ``'S22'`` || ``'HTBH'`` || etc. Second argument, usually unlabeled. Indicates the requested database; name, matching (case insensitive) the name of a python file in; ``psi4/lib/databases`` or :envvar:`PYTHONPATH`. Consult that; directory for available databases and literature citations. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``energy`` |dr| || ``optimize`` || ``cbs``. Indicates the type of calculation to be performed on each database; member. The default performs a single-point ``energy('name')``, while; ``optimize`` perfoms a geometry optimization on each reagent, and; ``cbs`` performs a compound single-point energy. If a nested series; of python functions is intended (see :ref:`sec:intercalls`), use; keyword ``db_func`` instead of ``func``. :type mode: string; :param mode: |dl| ``'continuous'`` |dr| || ``'sow'`` || ``'reap'``. Indicates whether the calculations required to complete the; database are to be run in one file (``'continuous'``) or are to be; farmed out in an embarrassingly parallel fashion; (``'sow'``/``'reap'``). For the latter, run an initial job with; ``'sow'`` and follow instructions in its output file. :type cp: :ref:`boolean <op_py_boolean>`; :param cp: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether counterpoise correction is employed in computing; interaction energies. U",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:25144,Performance,perform,performed,25144,"ions (e.g., the local option set by ``set scf scf_type df`` will not be respected). .. note:: To access a database that is not embedded in a |PSIfour|; distribution, add the path to the directory containing the database; to the environment variable :envvar:`PYTHONPATH`. :type name: string; :param name: ``'scf'`` || ``'sapt0'`` || ``'ccsd(t)'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; :py:func:`~driver.energy`. :type db_name: string; :param db_name: ``'BASIC'`` || ``'S22'`` || ``'HTBH'`` || etc. Second argument, usually unlabeled. Indicates the requested database; name, matching (case insensitive) the name of a python file in; ``psi4/lib/databases`` or :envvar:`PYTHONPATH`. Consult that; directory for available databases and literature citations. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``energy`` |dr| || ``optimize`` || ``cbs``. Indicates the type of calculation to be performed on each database; member. The default performs a single-point ``energy('name')``, while; ``optimize`` perfoms a geometry optimization on each reagent, and; ``cbs`` performs a compound single-point energy. If a nested series; of python functions is intended (see :ref:`sec:intercalls`), use; keyword ``db_func`` instead of ``func``. :type mode: string; :param mode: |dl| ``'continuous'`` |dr| || ``'sow'`` || ``'reap'``. Indicates whether the calculations required to complete the; database are to be run in one file (``'continuous'``) or are to be; farmed out in an embarrassingly parallel fashion; (``'sow'``/``'reap'``). For the latter, run an initial job with; ``'sow'`` and follow instructions in its output file. :type cp: :ref:`boolean <op_py_boolean>`; :param cp: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether counterpoise correction is employed in computing; interaction energies. Use this option and NOT the :py:func:`~wrappers.cp`; function for BSSE correction in database",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:25192,Performance,perform,performs,25192,"embedded in a |PSIfour|; distribution, add the path to the directory containing the database; to the environment variable :envvar:`PYTHONPATH`. :type name: string; :param name: ``'scf'`` || ``'sapt0'`` || ``'ccsd(t)'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; :py:func:`~driver.energy`. :type db_name: string; :param db_name: ``'BASIC'`` || ``'S22'`` || ``'HTBH'`` || etc. Second argument, usually unlabeled. Indicates the requested database; name, matching (case insensitive) the name of a python file in; ``psi4/lib/databases`` or :envvar:`PYTHONPATH`. Consult that; directory for available databases and literature citations. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``energy`` |dr| || ``optimize`` || ``cbs``. Indicates the type of calculation to be performed on each database; member. The default performs a single-point ``energy('name')``, while; ``optimize`` perfoms a geometry optimization on each reagent, and; ``cbs`` performs a compound single-point energy. If a nested series; of python functions is intended (see :ref:`sec:intercalls`), use; keyword ``db_func`` instead of ``func``. :type mode: string; :param mode: |dl| ``'continuous'`` |dr| || ``'sow'`` || ``'reap'``. Indicates whether the calculations required to complete the; database are to be run in one file (``'continuous'``) or are to be; farmed out in an embarrassingly parallel fashion; (``'sow'``/``'reap'``). For the latter, run an initial job with; ``'sow'`` and follow instructions in its output file. :type cp: :ref:`boolean <op_py_boolean>`; :param cp: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether counterpoise correction is employed in computing; interaction energies. Use this option and NOT the :py:func:`~wrappers.cp`; function for BSSE correction in database(). Option available; (See :ref:`sec:availableDatabases`) only for databases of bimolecular complexes. :type rlxd: :ref:`boolean",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:25245,Performance,optimiz,optimize,25245,"embedded in a |PSIfour|; distribution, add the path to the directory containing the database; to the environment variable :envvar:`PYTHONPATH`. :type name: string; :param name: ``'scf'`` || ``'sapt0'`` || ``'ccsd(t)'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; :py:func:`~driver.energy`. :type db_name: string; :param db_name: ``'BASIC'`` || ``'S22'`` || ``'HTBH'`` || etc. Second argument, usually unlabeled. Indicates the requested database; name, matching (case insensitive) the name of a python file in; ``psi4/lib/databases`` or :envvar:`PYTHONPATH`. Consult that; directory for available databases and literature citations. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``energy`` |dr| || ``optimize`` || ``cbs``. Indicates the type of calculation to be performed on each database; member. The default performs a single-point ``energy('name')``, while; ``optimize`` perfoms a geometry optimization on each reagent, and; ``cbs`` performs a compound single-point energy. If a nested series; of python functions is intended (see :ref:`sec:intercalls`), use; keyword ``db_func`` instead of ``func``. :type mode: string; :param mode: |dl| ``'continuous'`` |dr| || ``'sow'`` || ``'reap'``. Indicates whether the calculations required to complete the; database are to be run in one file (``'continuous'``) or are to be; farmed out in an embarrassingly parallel fashion; (``'sow'``/``'reap'``). For the latter, run an initial job with; ``'sow'`` and follow instructions in its output file. :type cp: :ref:`boolean <op_py_boolean>`; :param cp: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether counterpoise correction is employed in computing; interaction energies. Use this option and NOT the :py:func:`~wrappers.cp`; function for BSSE correction in database(). Option available; (See :ref:`sec:availableDatabases`) only for databases of bimolecular complexes. :type rlxd: :ref:`boolean",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:25275,Performance,optimiz,optimization,25275,"embedded in a |PSIfour|; distribution, add the path to the directory containing the database; to the environment variable :envvar:`PYTHONPATH`. :type name: string; :param name: ``'scf'`` || ``'sapt0'`` || ``'ccsd(t)'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; :py:func:`~driver.energy`. :type db_name: string; :param db_name: ``'BASIC'`` || ``'S22'`` || ``'HTBH'`` || etc. Second argument, usually unlabeled. Indicates the requested database; name, matching (case insensitive) the name of a python file in; ``psi4/lib/databases`` or :envvar:`PYTHONPATH`. Consult that; directory for available databases and literature citations. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``energy`` |dr| || ``optimize`` || ``cbs``. Indicates the type of calculation to be performed on each database; member. The default performs a single-point ``energy('name')``, while; ``optimize`` perfoms a geometry optimization on each reagent, and; ``cbs`` performs a compound single-point energy. If a nested series; of python functions is intended (see :ref:`sec:intercalls`), use; keyword ``db_func`` instead of ``func``. :type mode: string; :param mode: |dl| ``'continuous'`` |dr| || ``'sow'`` || ``'reap'``. Indicates whether the calculations required to complete the; database are to be run in one file (``'continuous'``) or are to be; farmed out in an embarrassingly parallel fashion; (``'sow'``/``'reap'``). For the latter, run an initial job with; ``'sow'`` and follow instructions in its output file. :type cp: :ref:`boolean <op_py_boolean>`; :param cp: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether counterpoise correction is employed in computing; interaction energies. Use this option and NOT the :py:func:`~wrappers.cp`; function for BSSE correction in database(). Option available; (See :ref:`sec:availableDatabases`) only for databases of bimolecular complexes. :type rlxd: :ref:`boolean",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:25318,Performance,perform,performs,25318,"embedded in a |PSIfour|; distribution, add the path to the directory containing the database; to the environment variable :envvar:`PYTHONPATH`. :type name: string; :param name: ``'scf'`` || ``'sapt0'`` || ``'ccsd(t)'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; :py:func:`~driver.energy`. :type db_name: string; :param db_name: ``'BASIC'`` || ``'S22'`` || ``'HTBH'`` || etc. Second argument, usually unlabeled. Indicates the requested database; name, matching (case insensitive) the name of a python file in; ``psi4/lib/databases`` or :envvar:`PYTHONPATH`. Consult that; directory for available databases and literature citations. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``energy`` |dr| || ``optimize`` || ``cbs``. Indicates the type of calculation to be performed on each database; member. The default performs a single-point ``energy('name')``, while; ``optimize`` perfoms a geometry optimization on each reagent, and; ``cbs`` performs a compound single-point energy. If a nested series; of python functions is intended (see :ref:`sec:intercalls`), use; keyword ``db_func`` instead of ``func``. :type mode: string; :param mode: |dl| ``'continuous'`` |dr| || ``'sow'`` || ``'reap'``. Indicates whether the calculations required to complete the; database are to be run in one file (``'continuous'``) or are to be; farmed out in an embarrassingly parallel fashion; (``'sow'``/``'reap'``). For the latter, run an initial job with; ``'sow'`` and follow instructions in its output file. :type cp: :ref:`boolean <op_py_boolean>`; :param cp: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether counterpoise correction is employed in computing; interaction energies. Use this option and NOT the :py:func:`~wrappers.cp`; function for BSSE correction in database(). Option available; (See :ref:`sec:availableDatabases`) only for databases of bimolecular complexes. :type rlxd: :ref:`boolean",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:29442,Performance,Optimiz,Optimize,29442,"r available; molecular systems (case insensitive).; * ``[1,2,5]`` || ``['1','2','5']`` || ``['BzMe-3.5', 'MeMe-5.0']`` || etc.; Specify a list of database members to run. Consult the; database python files for available molecular systems. This; is the only portion of database input that is case sensitive;; choices for this keyword must match the database python file. :examples:. >>> # [1] Two-stage SCF calculation on short, equilibrium, and long helium dimer; >>> db('scf','RGC10',cast_up='sto-3g',subset=['HeHe-0.85','HeHe-1.0','HeHe-1.5'], tabulate=['scf total energy','natom']). >>> # [2] Counterpoise-corrected interaction energies for three complexes in S22; >>> # Error statistics computed wrt an old benchmark, S22A; >>> database('df-mp2','S22',cp=1,subset=[16,17,8],benchmark='S22A'). >>> # [3] SAPT0 on the neon dimer dissociation curve; >>> db('sapt0',subset='NeNe',cp=0,symm=0,db_name='RGC10'). >>> # [4] Optimize system 1 in database S22, producing tables of scf and mp2 energy; >>> db('mp2','S22',db_func=optimize,subset=[1], tabulate=['mp2 total energy','current energy']). >>> # [5] CCSD on the smallest systems of HTBH, a hydrogen-transfer database; >>> database('ccsd','HTBH',subset='small', tabulate=['ccsd total energy', 'mp2 total energy']). """"""; lowername = name.lower(); kwargs = p4util.kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name.lower(); if not('db_name' in kwargs) and db_name:; kwargs['db_name'] = db_name. # Establish function to call; if not('db_func' in kwargs):; if ('func' in kwargs):; kwargs['db_func'] = kwargs['func']; del kwargs['func']; else:; kwargs['db_func'] = energy; func = kwargs['db_func']; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper database.' % (func.__name__)); if (func is cp):; raise ValidationError('Wrapper database is unhappy to be calling function \'%s\'. Use the cp keyword within ",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:29544,Performance,optimiz,optimize,29544,"r available; molecular systems (case insensitive).; * ``[1,2,5]`` || ``['1','2','5']`` || ``['BzMe-3.5', 'MeMe-5.0']`` || etc.; Specify a list of database members to run. Consult the; database python files for available molecular systems. This; is the only portion of database input that is case sensitive;; choices for this keyword must match the database python file. :examples:. >>> # [1] Two-stage SCF calculation on short, equilibrium, and long helium dimer; >>> db('scf','RGC10',cast_up='sto-3g',subset=['HeHe-0.85','HeHe-1.0','HeHe-1.5'], tabulate=['scf total energy','natom']). >>> # [2] Counterpoise-corrected interaction energies for three complexes in S22; >>> # Error statistics computed wrt an old benchmark, S22A; >>> database('df-mp2','S22',cp=1,subset=[16,17,8],benchmark='S22A'). >>> # [3] SAPT0 on the neon dimer dissociation curve; >>> db('sapt0',subset='NeNe',cp=0,symm=0,db_name='RGC10'). >>> # [4] Optimize system 1 in database S22, producing tables of scf and mp2 energy; >>> db('mp2','S22',db_func=optimize,subset=[1], tabulate=['mp2 total energy','current energy']). >>> # [5] CCSD on the smallest systems of HTBH, a hydrogen-transfer database; >>> database('ccsd','HTBH',subset='small', tabulate=['ccsd total energy', 'mp2 total energy']). """"""; lowername = name.lower(); kwargs = p4util.kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name.lower(); if not('db_name' in kwargs) and db_name:; kwargs['db_name'] = db_name. # Establish function to call; if not('db_func' in kwargs):; if ('func' in kwargs):; kwargs['db_func'] = kwargs['func']; del kwargs['func']; else:; kwargs['db_func'] = energy; func = kwargs['db_func']; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper database.' % (func.__name__)); if (func is cp):; raise ValidationError('Wrapper database is unhappy to be calling function \'%s\'. Use the cp keyword within ",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:30579,Performance,load,load,30579,"rgy','current energy']). >>> # [5] CCSD on the smallest systems of HTBH, a hydrogen-transfer database; >>> database('ccsd','HTBH',subset='small', tabulate=['ccsd total energy', 'mp2 total energy']). """"""; lowername = name.lower(); kwargs = p4util.kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name.lower(); if not('db_name' in kwargs) and db_name:; kwargs['db_name'] = db_name. # Establish function to call; if not('db_func' in kwargs):; if ('func' in kwargs):; kwargs['db_func'] = kwargs['func']; del kwargs['func']; else:; kwargs['db_func'] = energy; func = kwargs['db_func']; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper database.' % (func.__name__)); if (func is cp):; raise ValidationError('Wrapper database is unhappy to be calling function \'%s\'. Use the cp keyword within database instead.' % (func.__name__)). # Define path and load module for requested database; sys.path.append('%sdatabases' % (psi4.Process.environment[""PSIDATADIR""])); sys.path.append('%s/lib/databases' % psi4.psi_top_srcdir()); database = p4util.import_ignorecase(db_name); if database is None:; psi4.print_out('\nPython module for database %s failed to load\n\n' % (db_name)); psi4.print_out('\nSearch path that was tried:\n'); psi4.print_out("", "".join(map(str, sys.path))); raise ValidationError(""Python module loading problem for database "" + str(db_name)); else:; dbse = database.dbse; HRXN = database.HRXN; ACTV = database.ACTV; RXNM = database.RXNM; BIND = database.BIND; TAGL = database.TAGL; GEOS = database.GEOS; try:; DATA = database.DATA; except AttributeError:; DATA = {}. # Must collect (here) and set (below) basis sets after every new molecule activation; user_basis = psi4.get_global_option('BASIS'); user_df_basis_scf = psi4.get_global_option('DF_BASIS_SCF'); user_df_basis_mp2 = psi4.get_global_option('DF_BASIS_MP2'); user_df_basis_sapt = psi4.get_",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:30877,Performance,load,load,30877,"ny positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name.lower(); if not('db_name' in kwargs) and db_name:; kwargs['db_name'] = db_name. # Establish function to call; if not('db_func' in kwargs):; if ('func' in kwargs):; kwargs['db_func'] = kwargs['func']; del kwargs['func']; else:; kwargs['db_func'] = energy; func = kwargs['db_func']; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper database.' % (func.__name__)); if (func is cp):; raise ValidationError('Wrapper database is unhappy to be calling function \'%s\'. Use the cp keyword within database instead.' % (func.__name__)). # Define path and load module for requested database; sys.path.append('%sdatabases' % (psi4.Process.environment[""PSIDATADIR""])); sys.path.append('%s/lib/databases' % psi4.psi_top_srcdir()); database = p4util.import_ignorecase(db_name); if database is None:; psi4.print_out('\nPython module for database %s failed to load\n\n' % (db_name)); psi4.print_out('\nSearch path that was tried:\n'); psi4.print_out("", "".join(map(str, sys.path))); raise ValidationError(""Python module loading problem for database "" + str(db_name)); else:; dbse = database.dbse; HRXN = database.HRXN; ACTV = database.ACTV; RXNM = database.RXNM; BIND = database.BIND; TAGL = database.TAGL; GEOS = database.GEOS; try:; DATA = database.DATA; except AttributeError:; DATA = {}. # Must collect (here) and set (below) basis sets after every new molecule activation; user_basis = psi4.get_global_option('BASIS'); user_df_basis_scf = psi4.get_global_option('DF_BASIS_SCF'); user_df_basis_mp2 = psi4.get_global_option('DF_BASIS_MP2'); user_df_basis_sapt = psi4.get_global_option('DF_BASIS_SAPT'); user_df_basis_elst = psi4.get_global_option('DF_BASIS_ELST'). user_writer_file_label = psi4.get_global_option('WRITER_FILE_LABEL'). b_user_reference = psi4.has_global_option_changed('REFERENCE'); user_reference = psi4.get_global_option('REFERE",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:31036,Performance,load,loading,31036,"s['db_name'] = db_name. # Establish function to call; if not('db_func' in kwargs):; if ('func' in kwargs):; kwargs['db_func'] = kwargs['func']; del kwargs['func']; else:; kwargs['db_func'] = energy; func = kwargs['db_func']; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper database.' % (func.__name__)); if (func is cp):; raise ValidationError('Wrapper database is unhappy to be calling function \'%s\'. Use the cp keyword within database instead.' % (func.__name__)). # Define path and load module for requested database; sys.path.append('%sdatabases' % (psi4.Process.environment[""PSIDATADIR""])); sys.path.append('%s/lib/databases' % psi4.psi_top_srcdir()); database = p4util.import_ignorecase(db_name); if database is None:; psi4.print_out('\nPython module for database %s failed to load\n\n' % (db_name)); psi4.print_out('\nSearch path that was tried:\n'); psi4.print_out("", "".join(map(str, sys.path))); raise ValidationError(""Python module loading problem for database "" + str(db_name)); else:; dbse = database.dbse; HRXN = database.HRXN; ACTV = database.ACTV; RXNM = database.RXNM; BIND = database.BIND; TAGL = database.TAGL; GEOS = database.GEOS; try:; DATA = database.DATA; except AttributeError:; DATA = {}. # Must collect (here) and set (below) basis sets after every new molecule activation; user_basis = psi4.get_global_option('BASIS'); user_df_basis_scf = psi4.get_global_option('DF_BASIS_SCF'); user_df_basis_mp2 = psi4.get_global_option('DF_BASIS_MP2'); user_df_basis_sapt = psi4.get_global_option('DF_BASIS_SAPT'); user_df_basis_elst = psi4.get_global_option('DF_BASIS_ELST'). user_writer_file_label = psi4.get_global_option('WRITER_FILE_LABEL'). b_user_reference = psi4.has_global_option_changed('REFERENCE'); user_reference = psi4.get_global_option('REFERENCE'); user_memory = psi4.get_memory(). user_molecule = psi4.get_active_molecule(). # Configuration based upon e_name & db_name options; # Force non-supramolecular if needed; if re.mat",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:45106,Performance,load,loads,45106,"iable('NUCLEAR REPULSION ENERGY', molecule.nuclear_repulsion_energy()); if re.match(r'^verify', lowername):; compare_values(DATA['NUCLEAR REPULSION ENERGY'][rgt], psi4.get_variable('NUCLEAR REPULSION ENERGY'),; 4, '%s %.4f' % (rgt, psi4.get_variable('NUCLEAR REPULSION ENERGY'))); ERGT[rgt] = 7.0; else:; ERGT[rgt] = call_function_in_1st_argument(func, **kwargs); #print ERGT[rgt]; psi4.print_variables(); exec(actives); for envv in db_tabulate:; VRGT[rgt][envv.upper()] = psi4.get_variable(envv); psi4.set_global_option(""REFERENCE"", user_reference); psi4.clean(). elif (db_mode.lower() == 'sow'):; freagent = open('%s.in' % (rgt), 'w'); freagent.write('# This is a psi4 input file auto-generated from the database() wrapper.\n\n'); freagent.write(banners); freagent.write(p4util.format_molecule_for_input(GEOS[rgt])). freagent.write(commands); freagent.write('''\npickle_kw = (""""""'''); pickle.dump(kwargs, freagent); freagent.write('''"""""")\n'''); freagent.write(""""""\nkwargs = pickle.loads(pickle_kw)\n""""""); freagent.write(""""""electronic_energy = %s(**kwargs)\n\n"""""" % (func.__name__)); freagent.write(""""""psi4.print_variables()\n""""""); freagent.write(""""""psi4.print_out('\\nDATABASE RESULT: computation %d for reagent %s """"""; % (os.getpid(), rgt)); freagent.write(""""""yields electronic energy %20.12f\\n' % (electronic_energy))\n\n""""""); freagent.write(""""""psi4.set_variable('NATOM', molecule.natom())\n""""""); for envv in db_tabulate:; freagent.write(""""""psi4.print_out('DATABASE RESULT: computation %d for reagent %s """"""; % (os.getpid(), rgt)); freagent.write(""""""yields variable value %20.12f for variable %s\\n' % (psi4.get_variable(""""""); freagent.write(""""""'%s'), '%s'))\n"""""" % (envv.upper(), envv.upper())); freagent.close(). elif (db_mode.lower() == 'reap'):; ERGT[rgt] = 0.0; for envv in db_tabulate:; VRGT[rgt][envv.upper()] = 0.0; exec(banners); exec(actives); try:; freagent = open('%s.out' % (rgt), 'r'); except IOError:; psi4.print_out('Warning: Output file \'%s.out\' not found.\n' % (rgt)); psi4.p",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:55418,Performance,perform,performed,55418,"e. .. include:: cbs_eqn.rst. * Energy Methods; The presence of a stage_wfn keyword is the indicator to incorporate; (and check for stage_basis and stage_scheme keywords) and compute; that stage in defining the CBS energy. The cbs() function requires, at a minimum, ``name='scf'`` and ``scf_basis``; keywords to be specified for reference-step only jobs and ``name`` and; ``corl_basis`` keywords for correlated jobs. The following energy methods have been set up for cbs(). .. hlist::; :columns: 5. * scf; * mp2; * mp2.5; * mp3; * mp4(sdq); * mp4; * omp2; * omp3; * ocepa; * cepa0; * cepa(0); * cepa(1); * cepa(3); * acpf; * aqcc; * qcisd; * cc2; * ccsd; * fno-df-ccsd; * bccd; * cc3; * qcisd(t); * ccsd(t); * fno-df-ccsd(t); * bccd(t); * cisd; * cisdt; * cisdtq; * ci\ *n*; * fci; * mrccsd; * mrccsd(t); * mrccsdt; * mrccsdt(q). :type name: string; :param name: ``'scf'`` || ``'ccsd'`` || etc. First argument, usually unlabeled. Indicates the computational method; for the correlation energy, unless only reference step to be performed,; in which case should be ``'scf'``. Overruled if stage_wfn keywords supplied. :type corl_wfn: string; :param corl_wfn: ``'mp2'`` || ``'ccsd(t)'`` || etc. Indicates the energy method for which the correlation energy is to be; obtained. Can also be specified with ``name`` or as the unlabeled; first argument to the function. :type delta_wfn: string; :param delta_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a delta correction; to the correlation energy is to be obtained. :type delta_wfn_lesser: string; :param delta_wfn_lesser: |dl| ``'mp2'`` |dr| || ``'ccsd'`` || etc. Indicates the inferior energy method for which a delta correction; to the correlation energy is to be obtained. :type delta2_wfn: string; :param delta2_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a second delta correction; to the correlation energy is to be obtained. :type delta2_wfn_lesser: string; ",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:63352,Performance,optimiz,optimize,63352,"l_helgaker_2). >>> # [5] a DT-zeta extrapolated coupled-cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >>> cbs('mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2). >>> # [6] a D-zeta ccsd(t) correction atop a DT-zeta extrapolated ccsd cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >>> cbs('mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2, delta2_wfn='ccsd(t)', delta2_wfn_lesser='ccsd', delta2_basis='aug-cc-pvdz'). >>> # [7] cbs() coupled with database(); >>> database('mp2', 'BASIC', subset=['h2o','nh3'], symm='on', func=cbs, corl_basis='cc-pV[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='sto-3g'). >>> # [8] cbs() coupled with optimize(); >>> optimize('mp2', corl_basis='cc-pV[DT]Z', corl_scheme=corl_xtpl_helgaker_2, func=cbs). """"""; lowername = name.lower(); kwargs = p4util.kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name.lower(). # Establish function to call (only energy makes sense for cbs); if not('cbs_func' in kwargs):; if ('func' in kwargs):; kwargs['cbs_func'] = kwargs['func']; del kwargs['func']; else:; kwargs['cbs_func'] = energy; func = kwargs['cbs_func']; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper complete_basis_set.' % (func.__name__)); if not(func is energy):; raise ValidationError('Wrapper complete_basis_set is unhappy to be calling function \'%s\' instead of \'energy\'.' % (func.__name__)). # Define some quantum chemical knowledge, namely what methods are subsumed in others; VARH = {}; VARH['scf'] = { 'scftot': 'SCF TOTAL ENERGY'}; VARH['oldmp2'] = { 'scftot': 'SCF TOTAL ENERG",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:63368,Performance,optimiz,optimize,63368,"l_helgaker_2). >>> # [5] a DT-zeta extrapolated coupled-cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >>> cbs('mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2). >>> # [6] a D-zeta ccsd(t) correction atop a DT-zeta extrapolated ccsd cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >>> cbs('mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2, delta2_wfn='ccsd(t)', delta2_wfn_lesser='ccsd', delta2_basis='aug-cc-pvdz'). >>> # [7] cbs() coupled with database(); >>> database('mp2', 'BASIC', subset=['h2o','nh3'], symm='on', func=cbs, corl_basis='cc-pV[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='sto-3g'). >>> # [8] cbs() coupled with optimize(); >>> optimize('mp2', corl_basis='cc-pV[DT]Z', corl_scheme=corl_xtpl_helgaker_2, func=cbs). """"""; lowername = name.lower(); kwargs = p4util.kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name.lower(). # Establish function to call (only energy makes sense for cbs); if not('cbs_func' in kwargs):; if ('func' in kwargs):; kwargs['cbs_func'] = kwargs['func']; del kwargs['func']; else:; kwargs['cbs_func'] = energy; func = kwargs['cbs_func']; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper complete_basis_set.' % (func.__name__)); if not(func is energy):; raise ValidationError('Wrapper complete_basis_set is unhappy to be calling function \'%s\' instead of \'energy\'.' % (func.__name__)). # Define some quantum chemical knowledge, namely what methods are subsumed in others; VARH = {}; VARH['scf'] = { 'scftot': 'SCF TOTAL ENERGY'}; VARH['oldmp2'] = { 'scftot': 'SCF TOTAL ENERG",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:101572,Performance,perform,performs,101572,"tion fills out a form NEED with the computations needed to fulfill its call; if (largs['mode'].lower() == 'requisition'):; mode = largs['mode'].lower(). if 'wfnname' in largs:; wfnname = largs['wfnname']; else:; raise ValidationError('Call to \'%s\' has keyword \'wfnname\' missing.' % (functionname)). if re.match(r'scf_.*$', functionname) and (wfnname != 'scf'):; raise ValidationError('Call to \'%s\' is intended for scf portion of calculation.' % (functionname)); if re.match(r'corl_.*$', functionname) and (wfnname == 'scf'):; raise ValidationError('Call to \'%s\' is not intended for scf portion of calculation.' % (functionname)). if 'basisname' in largs:; BSET = largs['basisname']; else:; raise ValidationError('Call to \'%s\' has keyword \'basisname\' missing.' % (functionname)). if 'basiszeta' in largs:; ZSET = largs['basiszeta']; else:; raise ValidationError('Call to \'%s\' has keyword \'basiszeta\' missing.' % (functionname)). # Mode where function reads the now-filled-in energies from that same form and performs the sp, xtpl, delta, etc.; elif (largs['mode'].lower() == 'evaluate'):; mode = largs['mode'].lower(). if 'needname' in largs:; NEED = largs['needname']; else:; raise ValidationError('Call to \'%s\' has keyword \'needname\' missing.' % (functionname)). else:; raise ValidationError('Call to \'%s\' has keyword \'mode\' missing or invalid.' % (functionname)). return [mode, NEED, wfnname, BSET, ZSET]. [docs]def split_menial(menial):; r""""""Function used by :py:func:`~wrappers.complete_basis_set` to separate; *menial* 'scftot' into [scf, tot] and 'mp2corl' into [mp2, corl]. """"""; PTYP = ['tot', 'corl']; for temp in PTYP:; if menial.endswith(temp):; temp_wfn = menial[:-len(temp)]; temp_portion = temp. return [temp_wfn, temp_portion]. # Quickly normalize the types for both python 2 and 3; try:; unicode = unicode; except NameError:; # 'unicode' is undefined, must be Python 3; str = str; unicode = str; bytes = bytes; basestring = (str,bytes); else:; # 'unicode' exist",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:2422,Safety,detect,detect,2422,"e calls among wrappers(), energy(), optimize(), etc.; [docs]def call_function_in_1st_argument(funcarg, **largs):; r""""""Function to make primary function call to energy(), opt(), etc.; with options dictionary *largs*.; Useful when *funcarg* to call is stored in variable. """"""; return funcarg(**largs). [docs]def convert(p, symbol):; if symbol[p] == 'H':; d = 1.001; if symbol[p] == 'He':; d = 1.012; if symbol[p] == 'Li':; d = 0.825; if symbol[p] == 'Be':; d = 1.408; if symbol[p] == 'B':; d = 1.485; if symbol[p] == 'C':; d = 1.452; if symbol[p] == 'N':; d = 1.397; if symbol[p] == 'O':; d = 1.342; if symbol[p] == 'F':; d = 1.287; if symbol[p] == 'Ne':; d = 1.243; if symbol[p] == 'Na':; d = 1.144; if symbol[p] == 'Mg':; d = 1.364; if symbol[p] == 'Al':; d = 1.639; if symbol[p] == 'Si':; d = 1.716; if symbol[p] == 'P':; d = 1.705; if symbol[p] == 'S':; d = 1.683; if symbol[p] == 'Cl':; d = 1.639; if symbol[p] == 'Ar':; d = 1.595. return d / 1.5. #Automatically detect fragments and build a new molecule for fragment; #needing methods (SAPT0, etc...); [docs]def auto_fragments(name, **kwargs):; r""""""; Detects fragments if the user does not supply them.; Currently only used for the WebMO implementation of SAPT. usage: auto_fragments(''); """"""; if 'molecule' in kwargs:; activate(kwargs['molecule']); del kwargs['molecule']; molecule = psi4.get_active_molecule(); molecule.update_geometry(). geom = molecule.save_string_xyz(). numatoms = molecule.natom(); VdW = [1.2, 1.7, 1.5, 1.55, 1.52, 1.9, 1.85, 1.8]. symbol = range(numatoms); X = [0.0] * numatoms; Y = [0.0] * numatoms; Z = [0.0] * numatoms. Queue = []; White = []; Black = []; F = geom.split('\n'); for f in range(0, numatoms):; A = F[f+1].split(); symbol[f] = A[0]; X[f] = float(A[1]); Y[f] = float(A[2]); Z[f] = float(A[3]); White.append(f); Fragment = [[] for i in range(numatoms)] # stores fragments. start = 0 # starts with the first atom in the list; Queue.append(start); White.remove(start). frag = 0. while((len(White) > 0) or (len(",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:2561,Safety,Detect,Detects,2561,"*largs):; r""""""Function to make primary function call to energy(), opt(), etc.; with options dictionary *largs*.; Useful when *funcarg* to call is stored in variable. """"""; return funcarg(**largs). [docs]def convert(p, symbol):; if symbol[p] == 'H':; d = 1.001; if symbol[p] == 'He':; d = 1.012; if symbol[p] == 'Li':; d = 0.825; if symbol[p] == 'Be':; d = 1.408; if symbol[p] == 'B':; d = 1.485; if symbol[p] == 'C':; d = 1.452; if symbol[p] == 'N':; d = 1.397; if symbol[p] == 'O':; d = 1.342; if symbol[p] == 'F':; d = 1.287; if symbol[p] == 'Ne':; d = 1.243; if symbol[p] == 'Na':; d = 1.144; if symbol[p] == 'Mg':; d = 1.364; if symbol[p] == 'Al':; d = 1.639; if symbol[p] == 'Si':; d = 1.716; if symbol[p] == 'P':; d = 1.705; if symbol[p] == 'S':; d = 1.683; if symbol[p] == 'Cl':; d = 1.639; if symbol[p] == 'Ar':; d = 1.595. return d / 1.5. #Automatically detect fragments and build a new molecule for fragment; #needing methods (SAPT0, etc...); [docs]def auto_fragments(name, **kwargs):; r""""""; Detects fragments if the user does not supply them.; Currently only used for the WebMO implementation of SAPT. usage: auto_fragments(''); """"""; if 'molecule' in kwargs:; activate(kwargs['molecule']); del kwargs['molecule']; molecule = psi4.get_active_molecule(); molecule.update_geometry(). geom = molecule.save_string_xyz(). numatoms = molecule.natom(); VdW = [1.2, 1.7, 1.5, 1.55, 1.52, 1.9, 1.85, 1.8]. symbol = range(numatoms); X = [0.0] * numatoms; Y = [0.0] * numatoms; Z = [0.0] * numatoms. Queue = []; White = []; Black = []; F = geom.split('\n'); for f in range(0, numatoms):; A = F[f+1].split(); symbol[f] = A[0]; X[f] = float(A[1]); Y[f] = float(A[2]); Z[f] = float(A[3]); White.append(f); Fragment = [[] for i in range(numatoms)] # stores fragments. start = 0 # starts with the first atom in the list; Queue.append(start); White.remove(start). frag = 0. while((len(White) > 0) or (len(Queue) > 0)): # Iterates to the next fragment; while(len(Queue) > 0): # BFS within a fragment; for u in ",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:5122,Security,Validat,ValidationError,5122,"oup (adding 1 to start; # list at one instead of zero). if(len(White) != 0): # cant move White->Queue if no more exist; Queue.append(White[0]); White.remove(White[0]); frag += 1. new_geom = """"""\n0 1\n""""""; for i in Fragment[0]:; new_geom = new_geom + F[i].lstrip() + """"""\n""""""; new_geom = new_geom + """"""--\n0 1\n""""""; for j in Fragment[1]:; new_geom = new_geom + F[j].lstrip() + """"""\n""""""; new_geom = new_geom + """"""units angstrom\n"""""". new_mol = geometry(new_geom); new_mol.print_out(); psi4.print_out(""Exiting auto_fragments\n""). #######################; ## Start of n_body ##; #######################. [docs]def n_body(name, **kwargs):; lowername = name.lower(); kwargs = p4util.kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name.lower(). # Establish function to call; if not('n_body_func' in kwargs):; if ('func' in kwargs):; kwargs['n_body_func'] = kwargs['func']; del kwargs['func']; else:; kwargs['n_body_func'] = energy; func = kwargs['n_body_func']; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper n_body.' % (func.__name__)); if (func is db):; raise ValidationError('Wrapper n_body is unhappy to be calling function \'%s\'.' % (func.__name__)). # Make sure the molecule the user provided is the active one; if 'molecule' in kwargs:; activate(kwargs['molecule']); del kwargs['molecule']; molecule = psi4.get_active_molecule(); molecule.update_geometry(); psi4.set_global_option(""BASIS"", psi4.get_global_option(""BASIS"")). # N-body run configuration; bsse = 'on'; if 'bsse' in kwargs:; bsse = kwargs['bsse']. max_n_body = molecule.nfragments(); if 'max_n_body' in kwargs:; max_n_body = kwargs['max_n_body']. do_total = False; if 'do_total' in kwargs:; do_total = kwargs['do_total']. external = None; external_indices = []; if 'external' in kwargs:; external = kwargs['external']; external_indices = [molecule.nfragments()]; if 'external_monomers' in",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:5247,Security,Validat,ValidationError,5247,"0]:; new_geom = new_geom + F[i].lstrip() + """"""\n""""""; new_geom = new_geom + """"""--\n0 1\n""""""; for j in Fragment[1]:; new_geom = new_geom + F[j].lstrip() + """"""\n""""""; new_geom = new_geom + """"""units angstrom\n"""""". new_mol = geometry(new_geom); new_mol.print_out(); psi4.print_out(""Exiting auto_fragments\n""). #######################; ## Start of n_body ##; #######################. [docs]def n_body(name, **kwargs):; lowername = name.lower(); kwargs = p4util.kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name.lower(). # Establish function to call; if not('n_body_func' in kwargs):; if ('func' in kwargs):; kwargs['n_body_func'] = kwargs['func']; del kwargs['func']; else:; kwargs['n_body_func'] = energy; func = kwargs['n_body_func']; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper n_body.' % (func.__name__)); if (func is db):; raise ValidationError('Wrapper n_body is unhappy to be calling function \'%s\'.' % (func.__name__)). # Make sure the molecule the user provided is the active one; if 'molecule' in kwargs:; activate(kwargs['molecule']); del kwargs['molecule']; molecule = psi4.get_active_molecule(); molecule.update_geometry(); psi4.set_global_option(""BASIS"", psi4.get_global_option(""BASIS"")). # N-body run configuration; bsse = 'on'; if 'bsse' in kwargs:; bsse = kwargs['bsse']. max_n_body = molecule.nfragments(); if 'max_n_body' in kwargs:; max_n_body = kwargs['max_n_body']. do_total = False; if 'do_total' in kwargs:; do_total = kwargs['do_total']. external = None; external_indices = []; if 'external' in kwargs:; external = kwargs['external']; external_indices = [molecule.nfragments()]; if 'external_monomers' in kwargs:; external_indices = kwargs['external_monomers']. # Check input args; if not bsse == 'off' and not bsse == 'on' and not bsse == 'both':; raise ValidationError('n_body: bsse argument is one of on, off, or both'); if ",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:6194,Security,Validat,ValidationError,6194,"b):; raise ValidationError('Wrapper n_body is unhappy to be calling function \'%s\'.' % (func.__name__)). # Make sure the molecule the user provided is the active one; if 'molecule' in kwargs:; activate(kwargs['molecule']); del kwargs['molecule']; molecule = psi4.get_active_molecule(); molecule.update_geometry(); psi4.set_global_option(""BASIS"", psi4.get_global_option(""BASIS"")). # N-body run configuration; bsse = 'on'; if 'bsse' in kwargs:; bsse = kwargs['bsse']. max_n_body = molecule.nfragments(); if 'max_n_body' in kwargs:; max_n_body = kwargs['max_n_body']. do_total = False; if 'do_total' in kwargs:; do_total = kwargs['do_total']. external = None; external_indices = []; if 'external' in kwargs:; external = kwargs['external']; external_indices = [molecule.nfragments()]; if 'external_monomers' in kwargs:; external_indices = kwargs['external_monomers']. # Check input args; if not bsse == 'off' and not bsse == 'on' and not bsse == 'both':; raise ValidationError('n_body: bsse argument is one of on, off, or both'); if max_n_body < 1:; raise ValidationError('n_body: max_n_body must be at least 1'); if max_n_body > molecule.nfragments():; raise ValidationError('n_body: max_n_body must be <= to the number of fragments in the molecule'). # Set to save RI integrals for repeated full-basis computations; ri_ints_io = psi4.get_global_option('DF_INTS_IO'); # inquire if above at all applies to dfmp2 or just scf; psi4.set_global_option('DF_INTS_IO', 'SAVE'); psioh = psi4.IOManager.shared_object(); psioh.set_specific_retention(97, True). # Tell 'em what you're gonna tell 'em; has_external = 'No'; if (external):; has_external = 'Yes'; psi4.print_out('\n'); psi4.print_out(' ==> N-Body Interaction Energy Analysis <==\n\n'); psi4.print_out(' BSSE Treatment: %s\n' % (bsse)); psi4.print_out(' Maximum N-Body Interactions: %d\n' % (max_n_body)); psi4.print_out(' Compute Total Energy: %s\n' % (do_total)); psi4.print_out(' External Field: %s\n' % (has_external)); if (external):; psi4.print_o",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:6289,Security,Validat,ValidationError,6289,"b):; raise ValidationError('Wrapper n_body is unhappy to be calling function \'%s\'.' % (func.__name__)). # Make sure the molecule the user provided is the active one; if 'molecule' in kwargs:; activate(kwargs['molecule']); del kwargs['molecule']; molecule = psi4.get_active_molecule(); molecule.update_geometry(); psi4.set_global_option(""BASIS"", psi4.get_global_option(""BASIS"")). # N-body run configuration; bsse = 'on'; if 'bsse' in kwargs:; bsse = kwargs['bsse']. max_n_body = molecule.nfragments(); if 'max_n_body' in kwargs:; max_n_body = kwargs['max_n_body']. do_total = False; if 'do_total' in kwargs:; do_total = kwargs['do_total']. external = None; external_indices = []; if 'external' in kwargs:; external = kwargs['external']; external_indices = [molecule.nfragments()]; if 'external_monomers' in kwargs:; external_indices = kwargs['external_monomers']. # Check input args; if not bsse == 'off' and not bsse == 'on' and not bsse == 'both':; raise ValidationError('n_body: bsse argument is one of on, off, or both'); if max_n_body < 1:; raise ValidationError('n_body: max_n_body must be at least 1'); if max_n_body > molecule.nfragments():; raise ValidationError('n_body: max_n_body must be <= to the number of fragments in the molecule'). # Set to save RI integrals for repeated full-basis computations; ri_ints_io = psi4.get_global_option('DF_INTS_IO'); # inquire if above at all applies to dfmp2 or just scf; psi4.set_global_option('DF_INTS_IO', 'SAVE'); psioh = psi4.IOManager.shared_object(); psioh.set_specific_retention(97, True). # Tell 'em what you're gonna tell 'em; has_external = 'No'; if (external):; has_external = 'Yes'; psi4.print_out('\n'); psi4.print_out(' ==> N-Body Interaction Energy Analysis <==\n\n'); psi4.print_out(' BSSE Treatment: %s\n' % (bsse)); psi4.print_out(' Maximum N-Body Interactions: %d\n' % (max_n_body)); psi4.print_out(' Compute Total Energy: %s\n' % (do_total)); psi4.print_out(' External Field: %s\n' % (has_external)); if (external):; psi4.print_o",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:6393,Security,Validat,ValidationError,6393,"; activate(kwargs['molecule']); del kwargs['molecule']; molecule = psi4.get_active_molecule(); molecule.update_geometry(); psi4.set_global_option(""BASIS"", psi4.get_global_option(""BASIS"")). # N-body run configuration; bsse = 'on'; if 'bsse' in kwargs:; bsse = kwargs['bsse']. max_n_body = molecule.nfragments(); if 'max_n_body' in kwargs:; max_n_body = kwargs['max_n_body']. do_total = False; if 'do_total' in kwargs:; do_total = kwargs['do_total']. external = None; external_indices = []; if 'external' in kwargs:; external = kwargs['external']; external_indices = [molecule.nfragments()]; if 'external_monomers' in kwargs:; external_indices = kwargs['external_monomers']. # Check input args; if not bsse == 'off' and not bsse == 'on' and not bsse == 'both':; raise ValidationError('n_body: bsse argument is one of on, off, or both'); if max_n_body < 1:; raise ValidationError('n_body: max_n_body must be at least 1'); if max_n_body > molecule.nfragments():; raise ValidationError('n_body: max_n_body must be <= to the number of fragments in the molecule'). # Set to save RI integrals for repeated full-basis computations; ri_ints_io = psi4.get_global_option('DF_INTS_IO'); # inquire if above at all applies to dfmp2 or just scf; psi4.set_global_option('DF_INTS_IO', 'SAVE'); psioh = psi4.IOManager.shared_object(); psioh.set_specific_retention(97, True). # Tell 'em what you're gonna tell 'em; has_external = 'No'; if (external):; has_external = 'Yes'; psi4.print_out('\n'); psi4.print_out(' ==> N-Body Interaction Energy Analysis <==\n\n'); psi4.print_out(' BSSE Treatment: %s\n' % (bsse)); psi4.print_out(' Maximum N-Body Interactions: %d\n' % (max_n_body)); psi4.print_out(' Compute Total Energy: %s\n' % (do_total)); psi4.print_out(' External Field: %s\n' % (has_external)); if (external):; psi4.print_out(' External Field Monomers: '); for k in external_indices:; psi4.print_out('%-3d ' % (k)); psi4.print_out('\n'); psi4.print_out('\n'). # Run the total molecule, if required; energies_full = {",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:19298,Security,Validat,ValidationError,19298,"a compound single-point energy.; If a nested series of python functions is intended; (see :ref:`sec:intercalls`), use keyword ``cp_func`` instead of ``func``. :type check_bsse: :ref:`boolean <op_py_boolean>`; :param check_bsse: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether to additionally compute un-counterpoise corrected; monomers and thus obtain an estimate for the basis set superposition error. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :examples:. >>> # [1] counterpoise-corrected mp2 interaction energy; >>> cp('df-mp2'). """"""; lowername = name.lower(); kwargs = p4util.kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name.lower(). # Establish function to call; if not('cp_func' in kwargs):; if ('func' in kwargs):; kwargs['cp_func'] = kwargs['func']; del kwargs['func']; else:; kwargs['cp_func'] = energy; func = kwargs['cp_func']; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper counterpoise_correct.' % (func.__name__)); if (func is db):; raise ValidationError('Wrapper counterpoise_correct is unhappy to be calling function \'%s\'.' % (func.__name__)). if 'check_bsse' in kwargs and yes.match(str(kwargs['check_bsse'])):; check_bsse = True; else:; check_bsse = False. # Make sure the molecule the user provided is the active one; if 'molecule' in kwargs:; activate(kwargs['molecule']); del kwargs['molecule']; molecule = psi4.get_active_molecule(); molecule.update_geometry(); psi4.set_global_option(""BASIS"", psi4.get_global_option(""BASIS"")). df_ints_io = psi4.get_global_option('DF_INTS_IO'); # inquire if above at all applies to dfmp2 or just scf; psi4.set_global_option('DF_INTS_IO', 'SAVE'); psioh = psi4.IOManager.shared_object(); psioh.set_specific_retention(97, True). activate(molecule); molecule.update_geometry(). psi4.print_out(""\",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:19437,Security,Validat,ValidationError,19437,"`'on'`` || |dl| ``'off'`` |dr|. Indicates whether to additionally compute un-counterpoise corrected; monomers and thus obtain an estimate for the basis set superposition error. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :examples:. >>> # [1] counterpoise-corrected mp2 interaction energy; >>> cp('df-mp2'). """"""; lowername = name.lower(); kwargs = p4util.kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name.lower(). # Establish function to call; if not('cp_func' in kwargs):; if ('func' in kwargs):; kwargs['cp_func'] = kwargs['func']; del kwargs['func']; else:; kwargs['cp_func'] = energy; func = kwargs['cp_func']; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper counterpoise_correct.' % (func.__name__)); if (func is db):; raise ValidationError('Wrapper counterpoise_correct is unhappy to be calling function \'%s\'.' % (func.__name__)). if 'check_bsse' in kwargs and yes.match(str(kwargs['check_bsse'])):; check_bsse = True; else:; check_bsse = False. # Make sure the molecule the user provided is the active one; if 'molecule' in kwargs:; activate(kwargs['molecule']); del kwargs['molecule']; molecule = psi4.get_active_molecule(); molecule.update_geometry(); psi4.set_global_option(""BASIS"", psi4.get_global_option(""BASIS"")). df_ints_io = psi4.get_global_option('DF_INTS_IO'); # inquire if above at all applies to dfmp2 or just scf; psi4.set_global_option('DF_INTS_IO', 'SAVE'); psioh = psi4.IOManager.shared_object(); psioh.set_specific_retention(97, True). activate(molecule); molecule.update_geometry(). psi4.print_out(""\n""); p4util.banner(""CP Computation: Complex.\nFull Basis Set.""); psi4.print_out(""\n""); e_dimer = call_function_in_1st_argument(func, **kwargs); #e_dimer = energy(name, **kwargs). psi4.clean(); psi4.set_global_option('DF_INTS_IO',",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:23267,Security,access,access,23267,"n], e_monomer_bsse[cluster_n], \; e_monomer_full[cluster_n] - e_monomer_bsse[cluster_n]]. e_full = e_dimer; e_bsse = e_dimer; for cluster_n in range(0, len(monomers)):; e_full = e_full - e_monomer_full[cluster_n]; e_bsse = e_bsse - e_monomer_bsse[cluster_n]; cp_table[""Totals:""] = [e_full, e_bsse, e_full - e_bsse]. psi4.set_variable('UNCP-CORRECTED 2-BODY INTERACTION ENERGY', e_full). psi4.print_out(""\n""); p4util.banner(""CP Computation: Results.""); psi4.print_out(""\n""). p4util.banner(""Hartree"", 2); psi4.print_out(""\n""). psi4.print_out(str(cp_table)). psi4.print_out(""\n""); p4util.banner(""kcal*mol^-1"", 2); psi4.print_out(""\n""). cp_table.scale(). psi4.print_out(str(cp_table)); return e_full. ## Aliases ##; counterpoise_correct = cp; counterpoise_correction = cp. #################; ## End of cp ##; #################. #########################; ## Start of Database ##; #########################. DB_RGT = {}; DB_RXN = {}. [docs]def database(name, db_name, **kwargs):; r""""""Function to access the molecule objects and reference energies of; popular chemical databases. :aliases: db(). :returns: (*float*) Mean absolute deviation of the database in kcal/mol. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`db_name DATABASE MEAN SIGNED DEVIATION <db_nameDATABASEMEANSIGNEDDEVIATION>`; * :psivar:`db_name DATABASE MEAN ABSOLUTE DEVIATION <db_nameDATABASEMEANABSOLUTEDEVIATION>`; * :psivar:`db_name DATABASE ROOT-MEAN-SQUARE DEVIATION <db_nameDATABASEROOT-MEAN-SQUARESIGNEDDEVIATION>`; * Python dictionaries of results accessible as ``DB_RGT`` and ``DB_RXN``. .. note:: It is very easy to make a database from a collection of xyz files; using the script :source:`lib/scripts/ixyz2database.pl`.; See :ref:`sec:createDatabase` for details. .. caution:: Some features are not yet implemented. Buy a developer some coffee. - In sow/reap mode, use only global options (e.g., the local option set by ``set scf scf_type df`` will not be respected). .. note:: To access a database that is not embedded ",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:23802,Security,access,accessible,23802,". psi4.print_out(""\n""); p4util.banner(""CP Computation: Results.""); psi4.print_out(""\n""). p4util.banner(""Hartree"", 2); psi4.print_out(""\n""). psi4.print_out(str(cp_table)). psi4.print_out(""\n""); p4util.banner(""kcal*mol^-1"", 2); psi4.print_out(""\n""). cp_table.scale(). psi4.print_out(str(cp_table)); return e_full. ## Aliases ##; counterpoise_correct = cp; counterpoise_correction = cp. #################; ## End of cp ##; #################. #########################; ## Start of Database ##; #########################. DB_RGT = {}; DB_RXN = {}. [docs]def database(name, db_name, **kwargs):; r""""""Function to access the molecule objects and reference energies of; popular chemical databases. :aliases: db(). :returns: (*float*) Mean absolute deviation of the database in kcal/mol. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`db_name DATABASE MEAN SIGNED DEVIATION <db_nameDATABASEMEANSIGNEDDEVIATION>`; * :psivar:`db_name DATABASE MEAN ABSOLUTE DEVIATION <db_nameDATABASEMEANABSOLUTEDEVIATION>`; * :psivar:`db_name DATABASE ROOT-MEAN-SQUARE DEVIATION <db_nameDATABASEROOT-MEAN-SQUARESIGNEDDEVIATION>`; * Python dictionaries of results accessible as ``DB_RGT`` and ``DB_RXN``. .. note:: It is very easy to make a database from a collection of xyz files; using the script :source:`lib/scripts/ixyz2database.pl`.; See :ref:`sec:createDatabase` for details. .. caution:: Some features are not yet implemented. Buy a developer some coffee. - In sow/reap mode, use only global options (e.g., the local option set by ``set scf scf_type df`` will not be respected). .. note:: To access a database that is not embedded in a |PSIfour|; distribution, add the path to the directory containing the database; to the environment variable :envvar:`PYTHONPATH`. :type name: string; :param name: ``'scf'`` || ``'sapt0'`` || ``'ccsd(t)'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; :py:func:`~driver.energy`. :type d",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:24238,Security,access,access,24238,"f; popular chemical databases. :aliases: db(). :returns: (*float*) Mean absolute deviation of the database in kcal/mol. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`db_name DATABASE MEAN SIGNED DEVIATION <db_nameDATABASEMEANSIGNEDDEVIATION>`; * :psivar:`db_name DATABASE MEAN ABSOLUTE DEVIATION <db_nameDATABASEMEANABSOLUTEDEVIATION>`; * :psivar:`db_name DATABASE ROOT-MEAN-SQUARE DEVIATION <db_nameDATABASEROOT-MEAN-SQUARESIGNEDDEVIATION>`; * Python dictionaries of results accessible as ``DB_RGT`` and ``DB_RXN``. .. note:: It is very easy to make a database from a collection of xyz files; using the script :source:`lib/scripts/ixyz2database.pl`.; See :ref:`sec:createDatabase` for details. .. caution:: Some features are not yet implemented. Buy a developer some coffee. - In sow/reap mode, use only global options (e.g., the local option set by ``set scf scf_type df`` will not be respected). .. note:: To access a database that is not embedded in a |PSIfour|; distribution, add the path to the directory containing the database; to the environment variable :envvar:`PYTHONPATH`. :type name: string; :param name: ``'scf'`` || ``'sapt0'`` || ``'ccsd(t)'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; :py:func:`~driver.energy`. :type db_name: string; :param db_name: ``'BASIC'`` || ``'S22'`` || ``'HTBH'`` || etc. Second argument, usually unlabeled. Indicates the requested database; name, matching (case insensitive) the name of a python file in; ``psi4/lib/databases`` or :envvar:`PYTHONPATH`. Consult that; directory for available databases and literature citations. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``energy`` |dr| || ``optimize`` || ``cbs``. Indicates the type of calculation to be performed on each database; member. The default performs a single-point ``energy('name')``, while; ``optimize`` perfoms a geometry optimization on each reagent, and; ``cbs`` p",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:30293,Security,Validat,ValidationError,30293,"wrt an old benchmark, S22A; >>> database('df-mp2','S22',cp=1,subset=[16,17,8],benchmark='S22A'). >>> # [3] SAPT0 on the neon dimer dissociation curve; >>> db('sapt0',subset='NeNe',cp=0,symm=0,db_name='RGC10'). >>> # [4] Optimize system 1 in database S22, producing tables of scf and mp2 energy; >>> db('mp2','S22',db_func=optimize,subset=[1], tabulate=['mp2 total energy','current energy']). >>> # [5] CCSD on the smallest systems of HTBH, a hydrogen-transfer database; >>> database('ccsd','HTBH',subset='small', tabulate=['ccsd total energy', 'mp2 total energy']). """"""; lowername = name.lower(); kwargs = p4util.kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name.lower(); if not('db_name' in kwargs) and db_name:; kwargs['db_name'] = db_name. # Establish function to call; if not('db_func' in kwargs):; if ('func' in kwargs):; kwargs['db_func'] = kwargs['func']; del kwargs['func']; else:; kwargs['db_func'] = energy; func = kwargs['db_func']; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper database.' % (func.__name__)); if (func is cp):; raise ValidationError('Wrapper database is unhappy to be calling function \'%s\'. Use the cp keyword within database instead.' % (func.__name__)). # Define path and load module for requested database; sys.path.append('%sdatabases' % (psi4.Process.environment[""PSIDATADIR""])); sys.path.append('%s/lib/databases' % psi4.psi_top_srcdir()); database = p4util.import_ignorecase(db_name); if database is None:; psi4.print_out('\nPython module for database %s failed to load\n\n' % (db_name)); psi4.print_out('\nSearch path that was tried:\n'); psi4.print_out("", "".join(map(str, sys.path))); raise ValidationError(""Python module loading problem for database "" + str(db_name)); else:; dbse = database.dbse; HRXN = database.HRXN; ACTV = database.ACTV; RXNM = database.RXNM; BIND = database.BIND; TAGL = database.TAGL; ",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:30420,Security,Validat,ValidationError,30420,"4] Optimize system 1 in database S22, producing tables of scf and mp2 energy; >>> db('mp2','S22',db_func=optimize,subset=[1], tabulate=['mp2 total energy','current energy']). >>> # [5] CCSD on the smallest systems of HTBH, a hydrogen-transfer database; >>> database('ccsd','HTBH',subset='small', tabulate=['ccsd total energy', 'mp2 total energy']). """"""; lowername = name.lower(); kwargs = p4util.kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name.lower(); if not('db_name' in kwargs) and db_name:; kwargs['db_name'] = db_name. # Establish function to call; if not('db_func' in kwargs):; if ('func' in kwargs):; kwargs['db_func'] = kwargs['func']; del kwargs['func']; else:; kwargs['db_func'] = energy; func = kwargs['db_func']; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper database.' % (func.__name__)); if (func is cp):; raise ValidationError('Wrapper database is unhappy to be calling function \'%s\'. Use the cp keyword within database instead.' % (func.__name__)). # Define path and load module for requested database; sys.path.append('%sdatabases' % (psi4.Process.environment[""PSIDATADIR""])); sys.path.append('%s/lib/databases' % psi4.psi_top_srcdir()); database = p4util.import_ignorecase(db_name); if database is None:; psi4.print_out('\nPython module for database %s failed to load\n\n' % (db_name)); psi4.print_out('\nSearch path that was tried:\n'); psi4.print_out("", "".join(map(str, sys.path))); raise ValidationError(""Python module loading problem for database "" + str(db_name)); else:; dbse = database.dbse; HRXN = database.HRXN; ACTV = database.ACTV; RXNM = database.RXNM; BIND = database.BIND; TAGL = database.TAGL; GEOS = database.GEOS; try:; DATA = database.DATA; except AttributeError:; DATA = {}. # Must collect (here) and set (below) basis sets after every new molecule activation; user_basis = psi4.get_global_option('BASIS'); ",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:31005,Security,Validat,ValidationError,31005,"s['db_name'] = db_name. # Establish function to call; if not('db_func' in kwargs):; if ('func' in kwargs):; kwargs['db_func'] = kwargs['func']; del kwargs['func']; else:; kwargs['db_func'] = energy; func = kwargs['db_func']; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper database.' % (func.__name__)); if (func is cp):; raise ValidationError('Wrapper database is unhappy to be calling function \'%s\'. Use the cp keyword within database instead.' % (func.__name__)). # Define path and load module for requested database; sys.path.append('%sdatabases' % (psi4.Process.environment[""PSIDATADIR""])); sys.path.append('%s/lib/databases' % psi4.psi_top_srcdir()); database = p4util.import_ignorecase(db_name); if database is None:; psi4.print_out('\nPython module for database %s failed to load\n\n' % (db_name)); psi4.print_out('\nSearch path that was tried:\n'); psi4.print_out("", "".join(map(str, sys.path))); raise ValidationError(""Python module loading problem for database "" + str(db_name)); else:; dbse = database.dbse; HRXN = database.HRXN; ACTV = database.ACTV; RXNM = database.RXNM; BIND = database.BIND; TAGL = database.TAGL; GEOS = database.GEOS; try:; DATA = database.DATA; except AttributeError:; DATA = {}. # Must collect (here) and set (below) basis sets after every new molecule activation; user_basis = psi4.get_global_option('BASIS'); user_df_basis_scf = psi4.get_global_option('DF_BASIS_SCF'); user_df_basis_mp2 = psi4.get_global_option('DF_BASIS_MP2'); user_df_basis_sapt = psi4.get_global_option('DF_BASIS_SAPT'); user_df_basis_elst = psi4.get_global_option('DF_BASIS_ELST'). user_writer_file_label = psi4.get_global_option('WRITER_FILE_LABEL'). b_user_reference = psi4.has_global_option_changed('REFERENCE'); user_reference = psi4.get_global_option('REFERENCE'); user_memory = psi4.get_memory(). user_molecule = psi4.get_active_molecule(). # Configuration based upon e_name & db_name options; # Force non-supramolecular if needed; if re.mat",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:32164,Security,Validat,ValidationError,32164," = database.BIND; TAGL = database.TAGL; GEOS = database.GEOS; try:; DATA = database.DATA; except AttributeError:; DATA = {}. # Must collect (here) and set (below) basis sets after every new molecule activation; user_basis = psi4.get_global_option('BASIS'); user_df_basis_scf = psi4.get_global_option('DF_BASIS_SCF'); user_df_basis_mp2 = psi4.get_global_option('DF_BASIS_MP2'); user_df_basis_sapt = psi4.get_global_option('DF_BASIS_SAPT'); user_df_basis_elst = psi4.get_global_option('DF_BASIS_ELST'). user_writer_file_label = psi4.get_global_option('WRITER_FILE_LABEL'). b_user_reference = psi4.has_global_option_changed('REFERENCE'); user_reference = psi4.get_global_option('REFERENCE'); user_memory = psi4.get_memory(). user_molecule = psi4.get_active_molecule(). # Configuration based upon e_name & db_name options; # Force non-supramolecular if needed; if re.match(r'^sapt', lowername) or re.match(r'^.*sapt', lowername):; try:; database.ACTV_SA; except AttributeError:; raise ValidationError('Database %s not suitable for non-supramolecular calculation.' % (db_name)); else:; ACTV = database.ACTV_SA; # Force open-shell if needed; openshell_override = 0; if (user_reference == 'RHF') or (user_reference == 'RKS'):; try:; database.isOS; except AttributeError:; pass; else:; if yes.match(str(database.isOS)):; openshell_override = 1; psi4.print_out('\nSome reagents in database %s require an open-shell reference; will be reset to UHF/UKS as needed.\n' % (db_name)). # Configuration based upon database keyword options; # Option symmetry- whether symmetry treated normally or turned off (currently req'd for dfmp2 & dft); db_symm = 'yes'; if 'symm' in kwargs:; db_symm = kwargs['symm']. symmetry_override = 0; if no.match(str(db_symm)):; symmetry_override = 1; elif yes.match(str(db_symm)):; pass; else:; raise ValidationError('Symmetry mode \'%s\' not valid.' % (db_symm)). # Option mode of operation- whether db run in one job or files farmed out; if not('db_mode' in kwargs):; if ('mode' in kwa",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:32997,Security,Validat,ValidationError,32997,"; # Force non-supramolecular if needed; if re.match(r'^sapt', lowername) or re.match(r'^.*sapt', lowername):; try:; database.ACTV_SA; except AttributeError:; raise ValidationError('Database %s not suitable for non-supramolecular calculation.' % (db_name)); else:; ACTV = database.ACTV_SA; # Force open-shell if needed; openshell_override = 0; if (user_reference == 'RHF') or (user_reference == 'RKS'):; try:; database.isOS; except AttributeError:; pass; else:; if yes.match(str(database.isOS)):; openshell_override = 1; psi4.print_out('\nSome reagents in database %s require an open-shell reference; will be reset to UHF/UKS as needed.\n' % (db_name)). # Configuration based upon database keyword options; # Option symmetry- whether symmetry treated normally or turned off (currently req'd for dfmp2 & dft); db_symm = 'yes'; if 'symm' in kwargs:; db_symm = kwargs['symm']. symmetry_override = 0; if no.match(str(db_symm)):; symmetry_override = 1; elif yes.match(str(db_symm)):; pass; else:; raise ValidationError('Symmetry mode \'%s\' not valid.' % (db_symm)). # Option mode of operation- whether db run in one job or files farmed out; if not('db_mode' in kwargs):; if ('mode' in kwargs):; kwargs['db_mode'] = kwargs['mode']; del kwargs['mode']; else:; kwargs['db_mode'] = 'continuous'; db_mode = kwargs['db_mode']. if (db_mode.lower() == 'continuous'):; pass; elif (db_mode.lower() == 'sow'):; pass; elif (db_mode.lower() == 'reap'):; if 'linkage' in kwargs:; db_linkage = kwargs['linkage']; else:; raise ValidationError('Database execution mode \'reap\' requires a linkage option.'); else:; raise ValidationError('Database execution mode \'%s\' not valid.' % (db_mode)). # Option counterpoise- whether for interaction energy databases run in bsse-corrected or not; db_cp = 'no'; if 'cp' in kwargs:; db_cp = kwargs['cp']. if yes.match(str(db_cp)):; try:; database.ACTV_CP; except AttributeError:; raise ValidationError('Counterpoise correction mode \'yes\' invalid for database %s.' % (db_name)); els",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:33506,Security,Validat,ValidationError,33506,enshell_override = 1; psi4.print_out('\nSome reagents in database %s require an open-shell reference; will be reset to UHF/UKS as needed.\n' % (db_name)). # Configuration based upon database keyword options; # Option symmetry- whether symmetry treated normally or turned off (currently req'd for dfmp2 & dft); db_symm = 'yes'; if 'symm' in kwargs:; db_symm = kwargs['symm']. symmetry_override = 0; if no.match(str(db_symm)):; symmetry_override = 1; elif yes.match(str(db_symm)):; pass; else:; raise ValidationError('Symmetry mode \'%s\' not valid.' % (db_symm)). # Option mode of operation- whether db run in one job or files farmed out; if not('db_mode' in kwargs):; if ('mode' in kwargs):; kwargs['db_mode'] = kwargs['mode']; del kwargs['mode']; else:; kwargs['db_mode'] = 'continuous'; db_mode = kwargs['db_mode']. if (db_mode.lower() == 'continuous'):; pass; elif (db_mode.lower() == 'sow'):; pass; elif (db_mode.lower() == 'reap'):; if 'linkage' in kwargs:; db_linkage = kwargs['linkage']; else:; raise ValidationError('Database execution mode \'reap\' requires a linkage option.'); else:; raise ValidationError('Database execution mode \'%s\' not valid.' % (db_mode)). # Option counterpoise- whether for interaction energy databases run in bsse-corrected or not; db_cp = 'no'; if 'cp' in kwargs:; db_cp = kwargs['cp']. if yes.match(str(db_cp)):; try:; database.ACTV_CP; except AttributeError:; raise ValidationError('Counterpoise correction mode \'yes\' invalid for database %s.' % (db_name)); else:; ACTV = database.ACTV_CP; elif no.match(str(db_cp)):; pass; else:; raise ValidationError('Counterpoise correction mode \'%s\' not valid.' % (db_cp)). # Option relaxed- whether for non-frozen-monomer interaction energy databases include deformation correction or not?; db_rlxd = 'no'; if 'rlxd' in kwargs:; db_rlxd = kwargs['rlxd']. if yes.match(str(db_rlxd)):; if yes.match(str(db_cp)):; try:; database.ACTV_CPRLX; database.RXNM_CPRLX; except AttributeError:; raise ValidationError('Deformation ,MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:33599,Security,Validat,ValidationError,33599,F/UKS as needed.\n' % (db_name)). # Configuration based upon database keyword options; # Option symmetry- whether symmetry treated normally or turned off (currently req'd for dfmp2 & dft); db_symm = 'yes'; if 'symm' in kwargs:; db_symm = kwargs['symm']. symmetry_override = 0; if no.match(str(db_symm)):; symmetry_override = 1; elif yes.match(str(db_symm)):; pass; else:; raise ValidationError('Symmetry mode \'%s\' not valid.' % (db_symm)). # Option mode of operation- whether db run in one job or files farmed out; if not('db_mode' in kwargs):; if ('mode' in kwargs):; kwargs['db_mode'] = kwargs['mode']; del kwargs['mode']; else:; kwargs['db_mode'] = 'continuous'; db_mode = kwargs['db_mode']. if (db_mode.lower() == 'continuous'):; pass; elif (db_mode.lower() == 'sow'):; pass; elif (db_mode.lower() == 'reap'):; if 'linkage' in kwargs:; db_linkage = kwargs['linkage']; else:; raise ValidationError('Database execution mode \'reap\' requires a linkage option.'); else:; raise ValidationError('Database execution mode \'%s\' not valid.' % (db_mode)). # Option counterpoise- whether for interaction energy databases run in bsse-corrected or not; db_cp = 'no'; if 'cp' in kwargs:; db_cp = kwargs['cp']. if yes.match(str(db_cp)):; try:; database.ACTV_CP; except AttributeError:; raise ValidationError('Counterpoise correction mode \'yes\' invalid for database %s.' % (db_name)); else:; ACTV = database.ACTV_CP; elif no.match(str(db_cp)):; pass; else:; raise ValidationError('Counterpoise correction mode \'%s\' not valid.' % (db_cp)). # Option relaxed- whether for non-frozen-monomer interaction energy databases include deformation correction or not?; db_rlxd = 'no'; if 'rlxd' in kwargs:; db_rlxd = kwargs['rlxd']. if yes.match(str(db_rlxd)):; if yes.match(str(db_cp)):; try:; database.ACTV_CPRLX; database.RXNM_CPRLX; except AttributeError:; raise ValidationError('Deformation and counterpoise correction mode \'yes\' invalid for database %s.' % (db_name)); else:; ACTV = database.ACTV_CPRLX; RXNM ,MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:33904,Security,Validat,ValidationError,33904, symmetry_override = 1; elif yes.match(str(db_symm)):; pass; else:; raise ValidationError('Symmetry mode \'%s\' not valid.' % (db_symm)). # Option mode of operation- whether db run in one job or files farmed out; if not('db_mode' in kwargs):; if ('mode' in kwargs):; kwargs['db_mode'] = kwargs['mode']; del kwargs['mode']; else:; kwargs['db_mode'] = 'continuous'; db_mode = kwargs['db_mode']. if (db_mode.lower() == 'continuous'):; pass; elif (db_mode.lower() == 'sow'):; pass; elif (db_mode.lower() == 'reap'):; if 'linkage' in kwargs:; db_linkage = kwargs['linkage']; else:; raise ValidationError('Database execution mode \'reap\' requires a linkage option.'); else:; raise ValidationError('Database execution mode \'%s\' not valid.' % (db_mode)). # Option counterpoise- whether for interaction energy databases run in bsse-corrected or not; db_cp = 'no'; if 'cp' in kwargs:; db_cp = kwargs['cp']. if yes.match(str(db_cp)):; try:; database.ACTV_CP; except AttributeError:; raise ValidationError('Counterpoise correction mode \'yes\' invalid for database %s.' % (db_name)); else:; ACTV = database.ACTV_CP; elif no.match(str(db_cp)):; pass; else:; raise ValidationError('Counterpoise correction mode \'%s\' not valid.' % (db_cp)). # Option relaxed- whether for non-frozen-monomer interaction energy databases include deformation correction or not?; db_rlxd = 'no'; if 'rlxd' in kwargs:; db_rlxd = kwargs['rlxd']. if yes.match(str(db_rlxd)):; if yes.match(str(db_cp)):; try:; database.ACTV_CPRLX; database.RXNM_CPRLX; except AttributeError:; raise ValidationError('Deformation and counterpoise correction mode \'yes\' invalid for database %s.' % (db_name)); else:; ACTV = database.ACTV_CPRLX; RXNM = database.RXNM_CPRLX; elif no.match(str(db_cp)):; try:; database.ACTV_RLX; except AttributeError:; raise ValidationError('Deformation correction mode \'yes\' invalid for database %s.' % (db_name)); else:; ACTV = database.ACTV_RLX; elif no.match(str(db_rlxd)):; pass; else:; raise ValidationError('Deform,MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:34077,Security,Validat,ValidationError,34077,whether db run in one job or files farmed out; if not('db_mode' in kwargs):; if ('mode' in kwargs):; kwargs['db_mode'] = kwargs['mode']; del kwargs['mode']; else:; kwargs['db_mode'] = 'continuous'; db_mode = kwargs['db_mode']. if (db_mode.lower() == 'continuous'):; pass; elif (db_mode.lower() == 'sow'):; pass; elif (db_mode.lower() == 'reap'):; if 'linkage' in kwargs:; db_linkage = kwargs['linkage']; else:; raise ValidationError('Database execution mode \'reap\' requires a linkage option.'); else:; raise ValidationError('Database execution mode \'%s\' not valid.' % (db_mode)). # Option counterpoise- whether for interaction energy databases run in bsse-corrected or not; db_cp = 'no'; if 'cp' in kwargs:; db_cp = kwargs['cp']. if yes.match(str(db_cp)):; try:; database.ACTV_CP; except AttributeError:; raise ValidationError('Counterpoise correction mode \'yes\' invalid for database %s.' % (db_name)); else:; ACTV = database.ACTV_CP; elif no.match(str(db_cp)):; pass; else:; raise ValidationError('Counterpoise correction mode \'%s\' not valid.' % (db_cp)). # Option relaxed- whether for non-frozen-monomer interaction energy databases include deformation correction or not?; db_rlxd = 'no'; if 'rlxd' in kwargs:; db_rlxd = kwargs['rlxd']. if yes.match(str(db_rlxd)):; if yes.match(str(db_cp)):; try:; database.ACTV_CPRLX; database.RXNM_CPRLX; except AttributeError:; raise ValidationError('Deformation and counterpoise correction mode \'yes\' invalid for database %s.' % (db_name)); else:; ACTV = database.ACTV_CPRLX; RXNM = database.RXNM_CPRLX; elif no.match(str(db_cp)):; try:; database.ACTV_RLX; except AttributeError:; raise ValidationError('Deformation correction mode \'yes\' invalid for database %s.' % (db_name)); else:; ACTV = database.ACTV_RLX; elif no.match(str(db_rlxd)):; pass; else:; raise ValidationError('Deformation correction mode \'%s\' not valid.' % (db_rlxd)). # Option zero-point-correction- whether for thermochem databases jobs are corrected by zpe; db_zpe = 'no'; if ,MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:34470,Security,Validat,ValidationError,34470,e:; raise ValidationError('Database execution mode \'reap\' requires a linkage option.'); else:; raise ValidationError('Database execution mode \'%s\' not valid.' % (db_mode)). # Option counterpoise- whether for interaction energy databases run in bsse-corrected or not; db_cp = 'no'; if 'cp' in kwargs:; db_cp = kwargs['cp']. if yes.match(str(db_cp)):; try:; database.ACTV_CP; except AttributeError:; raise ValidationError('Counterpoise correction mode \'yes\' invalid for database %s.' % (db_name)); else:; ACTV = database.ACTV_CP; elif no.match(str(db_cp)):; pass; else:; raise ValidationError('Counterpoise correction mode \'%s\' not valid.' % (db_cp)). # Option relaxed- whether for non-frozen-monomer interaction energy databases include deformation correction or not?; db_rlxd = 'no'; if 'rlxd' in kwargs:; db_rlxd = kwargs['rlxd']. if yes.match(str(db_rlxd)):; if yes.match(str(db_cp)):; try:; database.ACTV_CPRLX; database.RXNM_CPRLX; except AttributeError:; raise ValidationError('Deformation and counterpoise correction mode \'yes\' invalid for database %s.' % (db_name)); else:; ACTV = database.ACTV_CPRLX; RXNM = database.RXNM_CPRLX; elif no.match(str(db_cp)):; try:; database.ACTV_RLX; except AttributeError:; raise ValidationError('Deformation correction mode \'yes\' invalid for database %s.' % (db_name)); else:; ACTV = database.ACTV_RLX; elif no.match(str(db_rlxd)):; pass; else:; raise ValidationError('Deformation correction mode \'%s\' not valid.' % (db_rlxd)). # Option zero-point-correction- whether for thermochem databases jobs are corrected by zpe; db_zpe = 'no'; if 'zpe' in kwargs:; db_zpe = kwargs['zpe']. if yes.match(str(db_zpe)):; raise ValidationError('Zero-point-correction mode \'yes\' not yet implemented.'); elif no.match(str(db_zpe)):; pass; else:; raise ValidationError('Zero-point-correction \'mode\' %s not valid.' % (db_zpe)). # Option benchmark- whether error statistics computed wrt alternate reference energies; db_benchmark = 'default'; if 'benchmark' in,MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:34726,Security,Validat,ValidationError,34726,"bsse-corrected or not; db_cp = 'no'; if 'cp' in kwargs:; db_cp = kwargs['cp']. if yes.match(str(db_cp)):; try:; database.ACTV_CP; except AttributeError:; raise ValidationError('Counterpoise correction mode \'yes\' invalid for database %s.' % (db_name)); else:; ACTV = database.ACTV_CP; elif no.match(str(db_cp)):; pass; else:; raise ValidationError('Counterpoise correction mode \'%s\' not valid.' % (db_cp)). # Option relaxed- whether for non-frozen-monomer interaction energy databases include deformation correction or not?; db_rlxd = 'no'; if 'rlxd' in kwargs:; db_rlxd = kwargs['rlxd']. if yes.match(str(db_rlxd)):; if yes.match(str(db_cp)):; try:; database.ACTV_CPRLX; database.RXNM_CPRLX; except AttributeError:; raise ValidationError('Deformation and counterpoise correction mode \'yes\' invalid for database %s.' % (db_name)); else:; ACTV = database.ACTV_CPRLX; RXNM = database.RXNM_CPRLX; elif no.match(str(db_cp)):; try:; database.ACTV_RLX; except AttributeError:; raise ValidationError('Deformation correction mode \'yes\' invalid for database %s.' % (db_name)); else:; ACTV = database.ACTV_RLX; elif no.match(str(db_rlxd)):; pass; else:; raise ValidationError('Deformation correction mode \'%s\' not valid.' % (db_rlxd)). # Option zero-point-correction- whether for thermochem databases jobs are corrected by zpe; db_zpe = 'no'; if 'zpe' in kwargs:; db_zpe = kwargs['zpe']. if yes.match(str(db_zpe)):; raise ValidationError('Zero-point-correction mode \'yes\' not yet implemented.'); elif no.match(str(db_zpe)):; pass; else:; raise ValidationError('Zero-point-correction \'mode\' %s not valid.' % (db_zpe)). # Option benchmark- whether error statistics computed wrt alternate reference energies; db_benchmark = 'default'; if 'benchmark' in kwargs:; db_benchmark = kwargs['benchmark']. if (db_benchmark.lower() == 'default'):; pass; else:; BIND = p4util.getattr_ignorecase(database, 'BIND_' + db_benchmark); if BIND is None:; raise ValidationError('Special benchmark \'%s\' not available f",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:34901,Security,Validat,ValidationError,34901,"ionError('Counterpoise correction mode \'yes\' invalid for database %s.' % (db_name)); else:; ACTV = database.ACTV_CP; elif no.match(str(db_cp)):; pass; else:; raise ValidationError('Counterpoise correction mode \'%s\' not valid.' % (db_cp)). # Option relaxed- whether for non-frozen-monomer interaction energy databases include deformation correction or not?; db_rlxd = 'no'; if 'rlxd' in kwargs:; db_rlxd = kwargs['rlxd']. if yes.match(str(db_rlxd)):; if yes.match(str(db_cp)):; try:; database.ACTV_CPRLX; database.RXNM_CPRLX; except AttributeError:; raise ValidationError('Deformation and counterpoise correction mode \'yes\' invalid for database %s.' % (db_name)); else:; ACTV = database.ACTV_CPRLX; RXNM = database.RXNM_CPRLX; elif no.match(str(db_cp)):; try:; database.ACTV_RLX; except AttributeError:; raise ValidationError('Deformation correction mode \'yes\' invalid for database %s.' % (db_name)); else:; ACTV = database.ACTV_RLX; elif no.match(str(db_rlxd)):; pass; else:; raise ValidationError('Deformation correction mode \'%s\' not valid.' % (db_rlxd)). # Option zero-point-correction- whether for thermochem databases jobs are corrected by zpe; db_zpe = 'no'; if 'zpe' in kwargs:; db_zpe = kwargs['zpe']. if yes.match(str(db_zpe)):; raise ValidationError('Zero-point-correction mode \'yes\' not yet implemented.'); elif no.match(str(db_zpe)):; pass; else:; raise ValidationError('Zero-point-correction \'mode\' %s not valid.' % (db_zpe)). # Option benchmark- whether error statistics computed wrt alternate reference energies; db_benchmark = 'default'; if 'benchmark' in kwargs:; db_benchmark = kwargs['benchmark']. if (db_benchmark.lower() == 'default'):; pass; else:; BIND = p4util.getattr_ignorecase(database, 'BIND_' + db_benchmark); if BIND is None:; raise ValidationError('Special benchmark \'%s\' not available for database %s.' % (db_benchmark, db_name)). # Option tabulate- whether tables of variables other than primary energy method are formed; db_tabulate = []; if 'tabulate",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:35165,Security,Validat,ValidationError,35165,"-frozen-monomer interaction energy databases include deformation correction or not?; db_rlxd = 'no'; if 'rlxd' in kwargs:; db_rlxd = kwargs['rlxd']. if yes.match(str(db_rlxd)):; if yes.match(str(db_cp)):; try:; database.ACTV_CPRLX; database.RXNM_CPRLX; except AttributeError:; raise ValidationError('Deformation and counterpoise correction mode \'yes\' invalid for database %s.' % (db_name)); else:; ACTV = database.ACTV_CPRLX; RXNM = database.RXNM_CPRLX; elif no.match(str(db_cp)):; try:; database.ACTV_RLX; except AttributeError:; raise ValidationError('Deformation correction mode \'yes\' invalid for database %s.' % (db_name)); else:; ACTV = database.ACTV_RLX; elif no.match(str(db_rlxd)):; pass; else:; raise ValidationError('Deformation correction mode \'%s\' not valid.' % (db_rlxd)). # Option zero-point-correction- whether for thermochem databases jobs are corrected by zpe; db_zpe = 'no'; if 'zpe' in kwargs:; db_zpe = kwargs['zpe']. if yes.match(str(db_zpe)):; raise ValidationError('Zero-point-correction mode \'yes\' not yet implemented.'); elif no.match(str(db_zpe)):; pass; else:; raise ValidationError('Zero-point-correction \'mode\' %s not valid.' % (db_zpe)). # Option benchmark- whether error statistics computed wrt alternate reference energies; db_benchmark = 'default'; if 'benchmark' in kwargs:; db_benchmark = kwargs['benchmark']. if (db_benchmark.lower() == 'default'):; pass; else:; BIND = p4util.getattr_ignorecase(database, 'BIND_' + db_benchmark); if BIND is None:; raise ValidationError('Special benchmark \'%s\' not available for database %s.' % (db_benchmark, db_name)). # Option tabulate- whether tables of variables other than primary energy method are formed; db_tabulate = []; if 'tabulate' in kwargs:; db_tabulate = kwargs['tabulate']. # Option subset- whether all of the database or just a portion is run; db_subset = HRXN; if 'subset' in kwargs:; db_subset = kwargs['subset']. if isinstance(db_subset, basestring):; if (db_subset.lower() == 'small'):; try:; data",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:35289,Security,Validat,ValidationError,35289,"n kwargs:; db_rlxd = kwargs['rlxd']. if yes.match(str(db_rlxd)):; if yes.match(str(db_cp)):; try:; database.ACTV_CPRLX; database.RXNM_CPRLX; except AttributeError:; raise ValidationError('Deformation and counterpoise correction mode \'yes\' invalid for database %s.' % (db_name)); else:; ACTV = database.ACTV_CPRLX; RXNM = database.RXNM_CPRLX; elif no.match(str(db_cp)):; try:; database.ACTV_RLX; except AttributeError:; raise ValidationError('Deformation correction mode \'yes\' invalid for database %s.' % (db_name)); else:; ACTV = database.ACTV_RLX; elif no.match(str(db_rlxd)):; pass; else:; raise ValidationError('Deformation correction mode \'%s\' not valid.' % (db_rlxd)). # Option zero-point-correction- whether for thermochem databases jobs are corrected by zpe; db_zpe = 'no'; if 'zpe' in kwargs:; db_zpe = kwargs['zpe']. if yes.match(str(db_zpe)):; raise ValidationError('Zero-point-correction mode \'yes\' not yet implemented.'); elif no.match(str(db_zpe)):; pass; else:; raise ValidationError('Zero-point-correction \'mode\' %s not valid.' % (db_zpe)). # Option benchmark- whether error statistics computed wrt alternate reference energies; db_benchmark = 'default'; if 'benchmark' in kwargs:; db_benchmark = kwargs['benchmark']. if (db_benchmark.lower() == 'default'):; pass; else:; BIND = p4util.getattr_ignorecase(database, 'BIND_' + db_benchmark); if BIND is None:; raise ValidationError('Special benchmark \'%s\' not available for database %s.' % (db_benchmark, db_name)). # Option tabulate- whether tables of variables other than primary energy method are formed; db_tabulate = []; if 'tabulate' in kwargs:; db_tabulate = kwargs['tabulate']. # Option subset- whether all of the database or just a portion is run; db_subset = HRXN; if 'subset' in kwargs:; db_subset = kwargs['subset']. if isinstance(db_subset, basestring):; if (db_subset.lower() == 'small'):; try:; database.HRXN_SM; except AttributeError:; raise ValidationError('Special subset \'small\' not available for database",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:35688,Security,Validat,ValidationError,35688,".ACTV_RLX; except AttributeError:; raise ValidationError('Deformation correction mode \'yes\' invalid for database %s.' % (db_name)); else:; ACTV = database.ACTV_RLX; elif no.match(str(db_rlxd)):; pass; else:; raise ValidationError('Deformation correction mode \'%s\' not valid.' % (db_rlxd)). # Option zero-point-correction- whether for thermochem databases jobs are corrected by zpe; db_zpe = 'no'; if 'zpe' in kwargs:; db_zpe = kwargs['zpe']. if yes.match(str(db_zpe)):; raise ValidationError('Zero-point-correction mode \'yes\' not yet implemented.'); elif no.match(str(db_zpe)):; pass; else:; raise ValidationError('Zero-point-correction \'mode\' %s not valid.' % (db_zpe)). # Option benchmark- whether error statistics computed wrt alternate reference energies; db_benchmark = 'default'; if 'benchmark' in kwargs:; db_benchmark = kwargs['benchmark']. if (db_benchmark.lower() == 'default'):; pass; else:; BIND = p4util.getattr_ignorecase(database, 'BIND_' + db_benchmark); if BIND is None:; raise ValidationError('Special benchmark \'%s\' not available for database %s.' % (db_benchmark, db_name)). # Option tabulate- whether tables of variables other than primary energy method are formed; db_tabulate = []; if 'tabulate' in kwargs:; db_tabulate = kwargs['tabulate']. # Option subset- whether all of the database or just a portion is run; db_subset = HRXN; if 'subset' in kwargs:; db_subset = kwargs['subset']. if isinstance(db_subset, basestring):; if (db_subset.lower() == 'small'):; try:; database.HRXN_SM; except AttributeError:; raise ValidationError('Special subset \'small\' not available for database %s.' % (db_name)); else:; HRXN = database.HRXN_SM; elif (db_subset.lower() == 'large'):; try:; database.HRXN_LG; except AttributeError:; raise ValidationError('Special subset \'large\' not available for database %s.' % (db_name)); else:; HRXN = database.HRXN_LG; elif (db_subset.lower() == 'equilibrium'):; try:; database.HRXN_EQ; except AttributeError:; raise ValidationError('Specia",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:36232,Security,Validat,ValidationError,36232,".match(str(db_zpe)):; pass; else:; raise ValidationError('Zero-point-correction \'mode\' %s not valid.' % (db_zpe)). # Option benchmark- whether error statistics computed wrt alternate reference energies; db_benchmark = 'default'; if 'benchmark' in kwargs:; db_benchmark = kwargs['benchmark']. if (db_benchmark.lower() == 'default'):; pass; else:; BIND = p4util.getattr_ignorecase(database, 'BIND_' + db_benchmark); if BIND is None:; raise ValidationError('Special benchmark \'%s\' not available for database %s.' % (db_benchmark, db_name)). # Option tabulate- whether tables of variables other than primary energy method are formed; db_tabulate = []; if 'tabulate' in kwargs:; db_tabulate = kwargs['tabulate']. # Option subset- whether all of the database or just a portion is run; db_subset = HRXN; if 'subset' in kwargs:; db_subset = kwargs['subset']. if isinstance(db_subset, basestring):; if (db_subset.lower() == 'small'):; try:; database.HRXN_SM; except AttributeError:; raise ValidationError('Special subset \'small\' not available for database %s.' % (db_name)); else:; HRXN = database.HRXN_SM; elif (db_subset.lower() == 'large'):; try:; database.HRXN_LG; except AttributeError:; raise ValidationError('Special subset \'large\' not available for database %s.' % (db_name)); else:; HRXN = database.HRXN_LG; elif (db_subset.lower() == 'equilibrium'):; try:; database.HRXN_EQ; except AttributeError:; raise ValidationError('Special subset \'equilibrium\' not available for database %s.' % (db_name)); else:; HRXN = database.HRXN_EQ; else:; HRXN = p4util.getattr_ignorecase(database, db_subset); if HRXN is None:; HRXN = p4util.getattr_ignorecase(database, 'HRXN_' + db_subset); if HRXN is None:; raise ValidationError('Special subset \'%s\' not available for database %s.' % (db_subset, db_name)); else:; temp = []; for rxn in db_subset:; if rxn in HRXN:; temp.append(rxn); else:; raise ValidationError('Subset element \'%s\' not a member of database %s.' % (str(rxn), db_name)); HRXN = temp. t",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:36444,Security,Validat,ValidationError,36444,"hmark = 'default'; if 'benchmark' in kwargs:; db_benchmark = kwargs['benchmark']. if (db_benchmark.lower() == 'default'):; pass; else:; BIND = p4util.getattr_ignorecase(database, 'BIND_' + db_benchmark); if BIND is None:; raise ValidationError('Special benchmark \'%s\' not available for database %s.' % (db_benchmark, db_name)). # Option tabulate- whether tables of variables other than primary energy method are formed; db_tabulate = []; if 'tabulate' in kwargs:; db_tabulate = kwargs['tabulate']. # Option subset- whether all of the database or just a portion is run; db_subset = HRXN; if 'subset' in kwargs:; db_subset = kwargs['subset']. if isinstance(db_subset, basestring):; if (db_subset.lower() == 'small'):; try:; database.HRXN_SM; except AttributeError:; raise ValidationError('Special subset \'small\' not available for database %s.' % (db_name)); else:; HRXN = database.HRXN_SM; elif (db_subset.lower() == 'large'):; try:; database.HRXN_LG; except AttributeError:; raise ValidationError('Special subset \'large\' not available for database %s.' % (db_name)); else:; HRXN = database.HRXN_LG; elif (db_subset.lower() == 'equilibrium'):; try:; database.HRXN_EQ; except AttributeError:; raise ValidationError('Special subset \'equilibrium\' not available for database %s.' % (db_name)); else:; HRXN = database.HRXN_EQ; else:; HRXN = p4util.getattr_ignorecase(database, db_subset); if HRXN is None:; HRXN = p4util.getattr_ignorecase(database, 'HRXN_' + db_subset); if HRXN is None:; raise ValidationError('Special subset \'%s\' not available for database %s.' % (db_subset, db_name)); else:; temp = []; for rxn in db_subset:; if rxn in HRXN:; temp.append(rxn); else:; raise ValidationError('Subset element \'%s\' not a member of database %s.' % (str(rxn), db_name)); HRXN = temp. temp = []; for rxn in HRXN:; temp.append(ACTV['%s-%s' % (dbse, rxn)]); HSYS = p4util.drop_duplicates(sum(temp, [])). # Sow all the necessary reagent computations; psi4.print_out(""\n\n""); p4util.banner((""Database %",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:36662,Security,Validat,ValidationError,36662," raise ValidationError('Special benchmark \'%s\' not available for database %s.' % (db_benchmark, db_name)). # Option tabulate- whether tables of variables other than primary energy method are formed; db_tabulate = []; if 'tabulate' in kwargs:; db_tabulate = kwargs['tabulate']. # Option subset- whether all of the database or just a portion is run; db_subset = HRXN; if 'subset' in kwargs:; db_subset = kwargs['subset']. if isinstance(db_subset, basestring):; if (db_subset.lower() == 'small'):; try:; database.HRXN_SM; except AttributeError:; raise ValidationError('Special subset \'small\' not available for database %s.' % (db_name)); else:; HRXN = database.HRXN_SM; elif (db_subset.lower() == 'large'):; try:; database.HRXN_LG; except AttributeError:; raise ValidationError('Special subset \'large\' not available for database %s.' % (db_name)); else:; HRXN = database.HRXN_LG; elif (db_subset.lower() == 'equilibrium'):; try:; database.HRXN_EQ; except AttributeError:; raise ValidationError('Special subset \'equilibrium\' not available for database %s.' % (db_name)); else:; HRXN = database.HRXN_EQ; else:; HRXN = p4util.getattr_ignorecase(database, db_subset); if HRXN is None:; HRXN = p4util.getattr_ignorecase(database, 'HRXN_' + db_subset); if HRXN is None:; raise ValidationError('Special subset \'%s\' not available for database %s.' % (db_subset, db_name)); else:; temp = []; for rxn in db_subset:; if rxn in HRXN:; temp.append(rxn); else:; raise ValidationError('Subset element \'%s\' not a member of database %s.' % (str(rxn), db_name)); HRXN = temp. temp = []; for rxn in HRXN:; temp.append(ACTV['%s-%s' % (dbse, rxn)]); HSYS = p4util.drop_duplicates(sum(temp, [])). # Sow all the necessary reagent computations; psi4.print_out(""\n\n""); p4util.banner((""Database %s Computation"" % (db_name))); psi4.print_out(""\n""). # write index of calcs to output file; if (db_mode.lower() == 'continuous'):; instructions = """"""\n The database single-job procedure has been selected through mode='cont",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:36957,Security,Validat,ValidationError,36957,"te']. # Option subset- whether all of the database or just a portion is run; db_subset = HRXN; if 'subset' in kwargs:; db_subset = kwargs['subset']. if isinstance(db_subset, basestring):; if (db_subset.lower() == 'small'):; try:; database.HRXN_SM; except AttributeError:; raise ValidationError('Special subset \'small\' not available for database %s.' % (db_name)); else:; HRXN = database.HRXN_SM; elif (db_subset.lower() == 'large'):; try:; database.HRXN_LG; except AttributeError:; raise ValidationError('Special subset \'large\' not available for database %s.' % (db_name)); else:; HRXN = database.HRXN_LG; elif (db_subset.lower() == 'equilibrium'):; try:; database.HRXN_EQ; except AttributeError:; raise ValidationError('Special subset \'equilibrium\' not available for database %s.' % (db_name)); else:; HRXN = database.HRXN_EQ; else:; HRXN = p4util.getattr_ignorecase(database, db_subset); if HRXN is None:; HRXN = p4util.getattr_ignorecase(database, 'HRXN_' + db_subset); if HRXN is None:; raise ValidationError('Special subset \'%s\' not available for database %s.' % (db_subset, db_name)); else:; temp = []; for rxn in db_subset:; if rxn in HRXN:; temp.append(rxn); else:; raise ValidationError('Subset element \'%s\' not a member of database %s.' % (str(rxn), db_name)); HRXN = temp. temp = []; for rxn in HRXN:; temp.append(ACTV['%s-%s' % (dbse, rxn)]); HSYS = p4util.drop_duplicates(sum(temp, [])). # Sow all the necessary reagent computations; psi4.print_out(""\n\n""); p4util.banner((""Database %s Computation"" % (db_name))); psi4.print_out(""\n""). # write index of calcs to output file; if (db_mode.lower() == 'continuous'):; instructions = """"""\n The database single-job procedure has been selected through mode='continuous'.\n""""""; instructions += """""" Calculations for the reagents will proceed in the order below and will be followed\n""""""; instructions += """""" by summary results for the database.\n\n""""""; for rgt in HSYS:; instructions += """""" %-s\n"""""" % (rgt); instructions += """"""\n Alter",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:37142,Security,Validat,ValidationError,37142,") == 'small'):; try:; database.HRXN_SM; except AttributeError:; raise ValidationError('Special subset \'small\' not available for database %s.' % (db_name)); else:; HRXN = database.HRXN_SM; elif (db_subset.lower() == 'large'):; try:; database.HRXN_LG; except AttributeError:; raise ValidationError('Special subset \'large\' not available for database %s.' % (db_name)); else:; HRXN = database.HRXN_LG; elif (db_subset.lower() == 'equilibrium'):; try:; database.HRXN_EQ; except AttributeError:; raise ValidationError('Special subset \'equilibrium\' not available for database %s.' % (db_name)); else:; HRXN = database.HRXN_EQ; else:; HRXN = p4util.getattr_ignorecase(database, db_subset); if HRXN is None:; HRXN = p4util.getattr_ignorecase(database, 'HRXN_' + db_subset); if HRXN is None:; raise ValidationError('Special subset \'%s\' not available for database %s.' % (db_subset, db_name)); else:; temp = []; for rxn in db_subset:; if rxn in HRXN:; temp.append(rxn); else:; raise ValidationError('Subset element \'%s\' not a member of database %s.' % (str(rxn), db_name)); HRXN = temp. temp = []; for rxn in HRXN:; temp.append(ACTV['%s-%s' % (dbse, rxn)]); HSYS = p4util.drop_duplicates(sum(temp, [])). # Sow all the necessary reagent computations; psi4.print_out(""\n\n""); p4util.banner((""Database %s Computation"" % (db_name))); psi4.print_out(""\n""). # write index of calcs to output file; if (db_mode.lower() == 'continuous'):; instructions = """"""\n The database single-job procedure has been selected through mode='continuous'.\n""""""; instructions += """""" Calculations for the reagents will proceed in the order below and will be followed\n""""""; instructions += """""" by summary results for the database.\n\n""""""; for rgt in HSYS:; instructions += """""" %-s\n"""""" % (rgt); instructions += """"""\n Alternatively, a farming-out of the database calculations may be accessed through\n""""""; instructions += """""" the database wrapper option mode='sow'/'reap'.\n\n""""""; psi4.print_out(instructions). # write sow/reap inst",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:38014,Security,access,accessed,38014,"subset \'%s\' not available for database %s.' % (db_subset, db_name)); else:; temp = []; for rxn in db_subset:; if rxn in HRXN:; temp.append(rxn); else:; raise ValidationError('Subset element \'%s\' not a member of database %s.' % (str(rxn), db_name)); HRXN = temp. temp = []; for rxn in HRXN:; temp.append(ACTV['%s-%s' % (dbse, rxn)]); HSYS = p4util.drop_duplicates(sum(temp, [])). # Sow all the necessary reagent computations; psi4.print_out(""\n\n""); p4util.banner((""Database %s Computation"" % (db_name))); psi4.print_out(""\n""). # write index of calcs to output file; if (db_mode.lower() == 'continuous'):; instructions = """"""\n The database single-job procedure has been selected through mode='continuous'.\n""""""; instructions += """""" Calculations for the reagents will proceed in the order below and will be followed\n""""""; instructions += """""" by summary results for the database.\n\n""""""; for rgt in HSYS:; instructions += """""" %-s\n"""""" % (rgt); instructions += """"""\n Alternatively, a farming-out of the database calculations may be accessed through\n""""""; instructions += """""" the database wrapper option mode='sow'/'reap'.\n\n""""""; psi4.print_out(instructions). # write sow/reap instructions and index of calcs to output file and reap input file; if (db_mode.lower() == 'sow'):; instructions = """"""\n The database sow/reap procedure has been selected through mode='sow'. In addition\n""""""; instructions += """""" to this output file (which contains no quantum chemical calculations), this job\n""""""; instructions += """""" has produced a number of input files (%s-*.in) for individual database members\n"""""" % (dbse); instructions += """""" and a single input file (%s-master.in) with a database(mode='reap') command.\n"""""" % (dbse); instructions += """""" The former may look very peculiar since processed and pickled python rather than\n""""""; instructions += """""" raw input is written. Follow the instructions below to continue.\n\n""""""; instructions += """""" (1) Run all of the %s-*.in input files on any variety of comput",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:39671,Security,access,accessed,39671,"ap') command.\n"""""" % (dbse); instructions += """""" The former may look very peculiar since processed and pickled python rather than\n""""""; instructions += """""" raw input is written. Follow the instructions below to continue.\n\n""""""; instructions += """""" (1) Run all of the %s-*.in input files on any variety of computer architecture.\n"""""" % (dbse); instructions += """""" The output file names must be as given below.\n\n""""""; for rgt in HSYS:; instructions += """""" psi4 -i %-27s -o %-27s\n"""""" % (rgt + '.in', rgt + '.out'); instructions += """"""\n (2) Gather all the resulting output files in a directory. Place input file\n""""""; instructions += """""" %s-master.in into that directory and run it. The job will be trivial in\n"""""" % (dbse); instructions += """""" length and give summary results for the database in its output file.\n\n""""""; instructions += """""" psi4 -i %-27s -o %-27s\n\n"""""" % (dbse + '-master.in', dbse + '-master.out'); instructions += """""" Alternatively, a single-job execution of the database may be accessed through\n""""""; instructions += """""" the database wrapper option mode='continuous'.\n\n""""""; psi4.print_out(instructions). fmaster = open('%s-master.in' % (dbse), 'w'); fmaster.write('# This is a psi4 input file auto-generated from the database() wrapper.\n\n'); fmaster.write(""database('%s', '%s', mode='reap', cp='%s', rlxd='%s', zpe='%s', benchmark='%s', linkage=%d, subset=%s, tabulate=%s)\n\n"" %; (name, db_name, db_cp, db_rlxd, db_zpe, db_benchmark, os.getpid(), HRXN, db_tabulate)); fmaster.close(). # Loop through chemical systems; ERGT = {}; ERXN = {}; VRGT = {}; VRXN = {}; for rgt in HSYS:; VRGT[rgt] = {}. # extra definition of molecule so that logic in building commands string has something to act on; exec(p4util.format_molecule_for_input(GEOS[rgt])); molecule = psi4.get_active_molecule(). # build string of title banner; banners = ''; banners += """"""psi4.print_out('\\n')\n""""""; banners += """"""p4util.banner(' Database %s Computation: Reagent %s \\n %s')\n"""""" % (db_name, rgt, TAGL[",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:41765,Security,Validat,ValidationError,41765,"rxn; actives = ''; actives += """"""psi4.print_out(' Database Contributions Map:\\n %s\\n')\n"""""" % ('-' * 75); for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn); if rgt in ACTV[db_rxn]:; actives += """"""psi4.print_out(' reagent %s contributes by %.4f to reaction %s\\n')\n"""""" \; % (rgt, RXNM[db_rxn][rgt], db_rxn); actives += """"""psi4.print_out('\\n')\n\n"""""". # build string of commands for options from the input file TODO: handle local options too; commands = ''; commands += """"""\npsi4.set_memory(%s)\n\n"""""" % (user_memory); for chgdopt in psi4.get_global_option_list():; if psi4.has_global_option_changed(chgdopt):; chgdoptval = psi4.get_global_option(chgdopt); #chgdoptval = psi4.get_option(chgdopt); if isinstance(chgdoptval, basestring):; commands += """"""psi4.set_global_option('%s', '%s')\n"""""" % (chgdopt, chgdoptval); elif isinstance(chgdoptval, int) or isinstance(chgdoptval, float):; commands += """"""psi4.set_global_option('%s', %s)\n"""""" % (chgdopt, chgdoptval); else:; raise ValidationError('Option \'%s\' is not of a type (string, int, float, bool) that can be processed by database wrapper.' % (chgdopt)). # build string of molecule and commands that are dependent on the database; commands += '\n'; commands += """"""psi4.set_global_option('BASIS', '%s')\n"""""" % (user_basis); if not((user_df_basis_scf == """") or (user_df_basis_scf == 'NONE')):; commands += """"""psi4.set_global_option('DF_BASIS_SCF', '%s')\n"""""" % (user_df_basis_scf); if not((user_df_basis_mp2 == """") or (user_df_basis_mp2 == 'NONE')):; commands += """"""psi4.set_global_option('DF_BASIS_MP2', '%s')\n"""""" % (user_df_basis_mp2); if not((user_df_basis_sapt == """") or (user_df_basis_sapt == 'NONE')):; commands += """"""psi4.set_global_option('DF_BASIS_SAPT', '%s')\n"""""" % (user_df_basis_sapt); if not((user_df_basis_elst == """") or (user_df_basis_elst == 'NONE')):; commands += """"""psi4.set_global_option('DF_BASIS_ELST', '%s')\n"""""" % (user_df_basis_elst); commands += """"""molecule = psi4.get_active_molecule()\n""""""; commands += """"""molecule.upd",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:46574,Security,Validat,ValidationError,46574,"v in db_tabulate:; freagent.write(""""""psi4.print_out('DATABASE RESULT: computation %d for reagent %s """"""; % (os.getpid(), rgt)); freagent.write(""""""yields variable value %20.12f for variable %s\\n' % (psi4.get_variable(""""""); freagent.write(""""""'%s'), '%s'))\n"""""" % (envv.upper(), envv.upper())); freagent.close(). elif (db_mode.lower() == 'reap'):; ERGT[rgt] = 0.0; for envv in db_tabulate:; VRGT[rgt][envv.upper()] = 0.0; exec(banners); exec(actives); try:; freagent = open('%s.out' % (rgt), 'r'); except IOError:; psi4.print_out('Warning: Output file \'%s.out\' not found.\n' % (rgt)); psi4.print_out(' Database summary will have 0.0 and **** in its place.\n'); else:; while 1:; line = freagent.readline(); if not line:; if ERGT[rgt] == 0.0:; psi4.print_out('Warning: Output file \'%s.out\' has no DATABASE RESULT line.\n' % (rgt)); psi4.print_out(' Database summary will have 0.0 and **** in its place.\n'); break; s = line.split(); if (len(s) != 0) and (s[0:3] == ['DATABASE', 'RESULT:', 'computation']):; if int(s[3]) != db_linkage:; raise ValidationError('Output file \'%s.out\' has linkage %s incompatible with master.in linkage %s.'; % (rgt, str(s[3]), str(db_linkage))); if s[6] != rgt:; raise ValidationError('Output file \'%s.out\' has nominal affiliation %s incompatible with reagent %s.'; % (rgt, s[6], rgt)); if (s[8:10] == ['electronic', 'energy']):; ERGT[rgt] = float(s[10]); psi4.print_out('DATABASE RESULT: electronic energy = %20.12f\n' % (ERGT[rgt])); elif (s[8:10] == ['variable', 'value']):; for envv in db_tabulate:; envv = envv.upper(); if (s[13:] == envv.split()):; VRGT[rgt][envv] = float(s[10]); psi4.print_out('DATABASE RESULT: variable %s value = %20.12f\n' % (envv, VRGT[rgt][envv])); freagent.close(). # end sow after writing files; if (db_mode.lower() == 'sow'):; return 0.0. # Reap all the necessary reaction computations; psi4.print_out(""\n""); p4util.banner((""Database %s Results"" % (db_name))); psi4.print_out(""\n""). maxactv = []; for rxn in HRXN:; maxactv.append(len(",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:46732,Security,Validat,ValidationError,46732,"ble %s\\n' % (psi4.get_variable(""""""); freagent.write(""""""'%s'), '%s'))\n"""""" % (envv.upper(), envv.upper())); freagent.close(). elif (db_mode.lower() == 'reap'):; ERGT[rgt] = 0.0; for envv in db_tabulate:; VRGT[rgt][envv.upper()] = 0.0; exec(banners); exec(actives); try:; freagent = open('%s.out' % (rgt), 'r'); except IOError:; psi4.print_out('Warning: Output file \'%s.out\' not found.\n' % (rgt)); psi4.print_out(' Database summary will have 0.0 and **** in its place.\n'); else:; while 1:; line = freagent.readline(); if not line:; if ERGT[rgt] == 0.0:; psi4.print_out('Warning: Output file \'%s.out\' has no DATABASE RESULT line.\n' % (rgt)); psi4.print_out(' Database summary will have 0.0 and **** in its place.\n'); break; s = line.split(); if (len(s) != 0) and (s[0:3] == ['DATABASE', 'RESULT:', 'computation']):; if int(s[3]) != db_linkage:; raise ValidationError('Output file \'%s.out\' has linkage %s incompatible with master.in linkage %s.'; % (rgt, str(s[3]), str(db_linkage))); if s[6] != rgt:; raise ValidationError('Output file \'%s.out\' has nominal affiliation %s incompatible with reagent %s.'; % (rgt, s[6], rgt)); if (s[8:10] == ['electronic', 'energy']):; ERGT[rgt] = float(s[10]); psi4.print_out('DATABASE RESULT: electronic energy = %20.12f\n' % (ERGT[rgt])); elif (s[8:10] == ['variable', 'value']):; for envv in db_tabulate:; envv = envv.upper(); if (s[13:] == envv.split()):; VRGT[rgt][envv] = float(s[10]); psi4.print_out('DATABASE RESULT: variable %s value = %20.12f\n' % (envv, VRGT[rgt][envv])); freagent.close(). # end sow after writing files; if (db_mode.lower() == 'sow'):; return 0.0. # Reap all the necessary reaction computations; psi4.print_out(""\n""); p4util.banner((""Database %s Results"" % (db_name))); psi4.print_out(""\n""). maxactv = []; for rxn in HRXN:; maxactv.append(len(ACTV[dbse + '-' + str(rxn)])); maxrgt = max(maxactv); table_delimit = '-' * (54 + 20 * maxrgt); tables = ''. # find any reactions that are incomplete; FAIL = collections.defaultdict(int",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:63926,Security,Validat,ValidationError,63926,"gy atop a Q-zeta reference; >>> cbs('mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2, delta2_wfn='ccsd(t)', delta2_wfn_lesser='ccsd', delta2_basis='aug-cc-pvdz'). >>> # [7] cbs() coupled with database(); >>> database('mp2', 'BASIC', subset=['h2o','nh3'], symm='on', func=cbs, corl_basis='cc-pV[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='sto-3g'). >>> # [8] cbs() coupled with optimize(); >>> optimize('mp2', corl_basis='cc-pV[DT]Z', corl_scheme=corl_xtpl_helgaker_2, func=cbs). """"""; lowername = name.lower(); kwargs = p4util.kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name.lower(). # Establish function to call (only energy makes sense for cbs); if not('cbs_func' in kwargs):; if ('func' in kwargs):; kwargs['cbs_func'] = kwargs['func']; del kwargs['func']; else:; kwargs['cbs_func'] = energy; func = kwargs['cbs_func']; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper complete_basis_set.' % (func.__name__)); if not(func is energy):; raise ValidationError('Wrapper complete_basis_set is unhappy to be calling function \'%s\' instead of \'energy\'.' % (func.__name__)). # Define some quantum chemical knowledge, namely what methods are subsumed in others; VARH = {}; VARH['scf'] = { 'scftot': 'SCF TOTAL ENERGY'}; VARH['oldmp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'oldmp2corl': 'MP2 CORRELATION ENERGY'}; VARH['mp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY'}; VARH['mp2.5'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY'}; VARH['mp3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION E",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:64070,Security,Validat,ValidationError,64070,"z'). >>> # [7] cbs() coupled with database(); >>> database('mp2', 'BASIC', subset=['h2o','nh3'], symm='on', func=cbs, corl_basis='cc-pV[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='sto-3g'). >>> # [8] cbs() coupled with optimize(); >>> optimize('mp2', corl_basis='cc-pV[DT]Z', corl_scheme=corl_xtpl_helgaker_2, func=cbs). """"""; lowername = name.lower(); kwargs = p4util.kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name.lower(). # Establish function to call (only energy makes sense for cbs); if not('cbs_func' in kwargs):; if ('func' in kwargs):; kwargs['cbs_func'] = kwargs['func']; del kwargs['func']; else:; kwargs['cbs_func'] = energy; func = kwargs['cbs_func']; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper complete_basis_set.' % (func.__name__)); if not(func is energy):; raise ValidationError('Wrapper complete_basis_set is unhappy to be calling function \'%s\' instead of \'energy\'.' % (func.__name__)). # Define some quantum chemical knowledge, namely what methods are subsumed in others; VARH = {}; VARH['scf'] = { 'scftot': 'SCF TOTAL ENERGY'}; VARH['oldmp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'oldmp2corl': 'MP2 CORRELATION ENERGY'}; VARH['mp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY'}; VARH['mp2.5'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY'}; VARH['mp3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY'}; VARH['mp4(sdq)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY'}; VARH['mp4'] = { 'scftot': 'SCF TO",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:70756,Security,Validat,ValidationError,70756,"r_df_basis_mp2 = psi4.get_option('DF_BASIS_MP2'); #user_df_basis_cc = psi4.get_option('DF_BASIS_CC'); #user_df_basis_sapt = psi4.get_option('DF_BASIS_SAPT'); #user_df_basis_elst = psi4.get_option('DF_BASIS_ELST'); b_user_wfn = psi4.has_global_option_changed('WFN'); user_wfn = psi4.get_global_option('WFN'). user_writer_file_label = psi4.get_global_option('WRITER_FILE_LABEL'). # Make sure the molecule the user provided is the active one; if 'molecule' in kwargs:; activate(kwargs['molecule']); del kwargs['molecule']; molecule = psi4.get_active_molecule(); molecule.update_geometry(); psi4.set_global_option(""BASIS"", psi4.get_global_option(""BASIS"")). # Establish method for correlation energy; if 'name' in kwargs:; if (lowername == 'scf') or (lowername == 'df-scf'):; pass; else:; do_corl = 1; cbs_corl_wfn = kwargs['name'].lower(); if 'corl_wfn' in kwargs:; do_corl = 1; cbs_corl_wfn = kwargs['corl_wfn'].lower(); if do_corl:; if not (cbs_corl_wfn in VARH.keys()):; raise ValidationError('Requested CORL method \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_corl_wfn)). # Establish method for delta correction energy; if 'delta_wfn' in kwargs:; do_delta = 1; cbs_delta_wfn = kwargs['delta_wfn'].lower(); if not (cbs_delta_wfn in VARH.keys()):; raise ValidationError('Requested DELTA method \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta_wfn)). if 'delta_wfn_lesser' in kwargs:; cbs_delta_wfn_lesser = kwargs['delta_wfn_lesser'].lower(); else:; cbs_delta_wfn_lesser = 'mp2'; if not (cbs_delta_wfn_lesser in VARH.keys()):; raise ValidationError('Requested DELTA method lesser \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta_wfn_lesser)). # Establish method for second delta correction energy; if 'delta2_wfn' in kwargs:; do_delta2 = 1; cbs_delta2_wfn = kwargs['delta2_wfn'].lower(); if not (cbs_delta2_wfn in VARH.keys()):; raise ValidationError('Requested DELTA2 method \'%s\' is not recognized. Add it",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:71062,Security,Validat,ValidationError,71062,". user_writer_file_label = psi4.get_global_option('WRITER_FILE_LABEL'). # Make sure the molecule the user provided is the active one; if 'molecule' in kwargs:; activate(kwargs['molecule']); del kwargs['molecule']; molecule = psi4.get_active_molecule(); molecule.update_geometry(); psi4.set_global_option(""BASIS"", psi4.get_global_option(""BASIS"")). # Establish method for correlation energy; if 'name' in kwargs:; if (lowername == 'scf') or (lowername == 'df-scf'):; pass; else:; do_corl = 1; cbs_corl_wfn = kwargs['name'].lower(); if 'corl_wfn' in kwargs:; do_corl = 1; cbs_corl_wfn = kwargs['corl_wfn'].lower(); if do_corl:; if not (cbs_corl_wfn in VARH.keys()):; raise ValidationError('Requested CORL method \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_corl_wfn)). # Establish method for delta correction energy; if 'delta_wfn' in kwargs:; do_delta = 1; cbs_delta_wfn = kwargs['delta_wfn'].lower(); if not (cbs_delta_wfn in VARH.keys()):; raise ValidationError('Requested DELTA method \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta_wfn)). if 'delta_wfn_lesser' in kwargs:; cbs_delta_wfn_lesser = kwargs['delta_wfn_lesser'].lower(); else:; cbs_delta_wfn_lesser = 'mp2'; if not (cbs_delta_wfn_lesser in VARH.keys()):; raise ValidationError('Requested DELTA method lesser \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta_wfn_lesser)). # Establish method for second delta correction energy; if 'delta2_wfn' in kwargs:; do_delta2 = 1; cbs_delta2_wfn = kwargs['delta2_wfn'].lower(); if not (cbs_delta2_wfn in VARH.keys()):; raise ValidationError('Requested DELTA2 method \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta2_wfn)). if 'delta2_wfn_lesser' in kwargs:; cbs_delta2_wfn_lesser = kwargs['delta2_wfn_lesser'].lower(); else:; cbs_delta2_wfn_lesser = 'mp2'; if not (cbs_delta2_wfn_lesser in VARH.keys()):; raise ValidationError('Requested DELTA2 method lesser \'%s\' is not ",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:71373,Security,Validat,ValidationError,71373,"i4.get_global_option(""BASIS"")). # Establish method for correlation energy; if 'name' in kwargs:; if (lowername == 'scf') or (lowername == 'df-scf'):; pass; else:; do_corl = 1; cbs_corl_wfn = kwargs['name'].lower(); if 'corl_wfn' in kwargs:; do_corl = 1; cbs_corl_wfn = kwargs['corl_wfn'].lower(); if do_corl:; if not (cbs_corl_wfn in VARH.keys()):; raise ValidationError('Requested CORL method \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_corl_wfn)). # Establish method for delta correction energy; if 'delta_wfn' in kwargs:; do_delta = 1; cbs_delta_wfn = kwargs['delta_wfn'].lower(); if not (cbs_delta_wfn in VARH.keys()):; raise ValidationError('Requested DELTA method \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta_wfn)). if 'delta_wfn_lesser' in kwargs:; cbs_delta_wfn_lesser = kwargs['delta_wfn_lesser'].lower(); else:; cbs_delta_wfn_lesser = 'mp2'; if not (cbs_delta_wfn_lesser in VARH.keys()):; raise ValidationError('Requested DELTA method lesser \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta_wfn_lesser)). # Establish method for second delta correction energy; if 'delta2_wfn' in kwargs:; do_delta2 = 1; cbs_delta2_wfn = kwargs['delta2_wfn'].lower(); if not (cbs_delta2_wfn in VARH.keys()):; raise ValidationError('Requested DELTA2 method \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta2_wfn)). if 'delta2_wfn_lesser' in kwargs:; cbs_delta2_wfn_lesser = kwargs['delta2_wfn_lesser'].lower(); else:; cbs_delta2_wfn_lesser = 'mp2'; if not (cbs_delta2_wfn_lesser in VARH.keys()):; raise ValidationError('Requested DELTA2 method lesser \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta2_wfn_lesser)). # Establish method for third delta correction energy; if 'delta3_wfn' in kwargs:; do_delta3 = 1; cbs_delta3_wfn = kwargs['delta3_wfn'].lower(); if not (cbs_delta3_wfn in VARH.keys()):; raise ValidationError('Requested DELTA3 method ",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:71707,Security,Validat,ValidationError,71707,in VARH.keys()):; raise ValidationError('Requested CORL method \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_corl_wfn)). # Establish method for delta correction energy; if 'delta_wfn' in kwargs:; do_delta = 1; cbs_delta_wfn = kwargs['delta_wfn'].lower(); if not (cbs_delta_wfn in VARH.keys()):; raise ValidationError('Requested DELTA method \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta_wfn)). if 'delta_wfn_lesser' in kwargs:; cbs_delta_wfn_lesser = kwargs['delta_wfn_lesser'].lower(); else:; cbs_delta_wfn_lesser = 'mp2'; if not (cbs_delta_wfn_lesser in VARH.keys()):; raise ValidationError('Requested DELTA method lesser \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta_wfn_lesser)). # Establish method for second delta correction energy; if 'delta2_wfn' in kwargs:; do_delta2 = 1; cbs_delta2_wfn = kwargs['delta2_wfn'].lower(); if not (cbs_delta2_wfn in VARH.keys()):; raise ValidationError('Requested DELTA2 method \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta2_wfn)). if 'delta2_wfn_lesser' in kwargs:; cbs_delta2_wfn_lesser = kwargs['delta2_wfn_lesser'].lower(); else:; cbs_delta2_wfn_lesser = 'mp2'; if not (cbs_delta2_wfn_lesser in VARH.keys()):; raise ValidationError('Requested DELTA2 method lesser \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta2_wfn_lesser)). # Establish method for third delta correction energy; if 'delta3_wfn' in kwargs:; do_delta3 = 1; cbs_delta3_wfn = kwargs['delta3_wfn'].lower(); if not (cbs_delta3_wfn in VARH.keys()):; raise ValidationError('Requested DELTA3 method \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta3_wfn)). if 'delta3_wfn_lesser' in kwargs:; cbs_delta3_wfn_lesser = kwargs['delta3_wfn_lesser'].lower(); else:; cbs_delta3_wfn_lesser = 'mp2'; if not (cbs_delta3_wfn_lesser in VARH.keys()):; raise ValidationError('Requested DELTA3 method lesser \'%s\',MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:72025,Security,Validat,ValidationError,72025,:; raise ValidationError('Requested DELTA method \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta_wfn)). if 'delta_wfn_lesser' in kwargs:; cbs_delta_wfn_lesser = kwargs['delta_wfn_lesser'].lower(); else:; cbs_delta_wfn_lesser = 'mp2'; if not (cbs_delta_wfn_lesser in VARH.keys()):; raise ValidationError('Requested DELTA method lesser \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta_wfn_lesser)). # Establish method for second delta correction energy; if 'delta2_wfn' in kwargs:; do_delta2 = 1; cbs_delta2_wfn = kwargs['delta2_wfn'].lower(); if not (cbs_delta2_wfn in VARH.keys()):; raise ValidationError('Requested DELTA2 method \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta2_wfn)). if 'delta2_wfn_lesser' in kwargs:; cbs_delta2_wfn_lesser = kwargs['delta2_wfn_lesser'].lower(); else:; cbs_delta2_wfn_lesser = 'mp2'; if not (cbs_delta2_wfn_lesser in VARH.keys()):; raise ValidationError('Requested DELTA2 method lesser \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta2_wfn_lesser)). # Establish method for third delta correction energy; if 'delta3_wfn' in kwargs:; do_delta3 = 1; cbs_delta3_wfn = kwargs['delta3_wfn'].lower(); if not (cbs_delta3_wfn in VARH.keys()):; raise ValidationError('Requested DELTA3 method \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta3_wfn)). if 'delta3_wfn_lesser' in kwargs:; cbs_delta3_wfn_lesser = kwargs['delta3_wfn_lesser'].lower(); else:; cbs_delta3_wfn_lesser = 'mp2'; if not (cbs_delta3_wfn_lesser in VARH.keys()):; raise ValidationError('Requested DELTA3 method lesser \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta3_wfn_lesser)). # Establish method for fourth delta correction energy; if 'delta4_wfn' in kwargs:; do_delta4 = 1; cbs_delta4_wfn = kwargs['delta4_wfn'].lower(); if not (cbs_delta4_wfn in VARH.keys()):; raise ValidationError('Requested DELTA4 method,MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:72360,Security,Validat,ValidationError,72360,ror('Requested DELTA method lesser \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta_wfn_lesser)). # Establish method for second delta correction energy; if 'delta2_wfn' in kwargs:; do_delta2 = 1; cbs_delta2_wfn = kwargs['delta2_wfn'].lower(); if not (cbs_delta2_wfn in VARH.keys()):; raise ValidationError('Requested DELTA2 method \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta2_wfn)). if 'delta2_wfn_lesser' in kwargs:; cbs_delta2_wfn_lesser = kwargs['delta2_wfn_lesser'].lower(); else:; cbs_delta2_wfn_lesser = 'mp2'; if not (cbs_delta2_wfn_lesser in VARH.keys()):; raise ValidationError('Requested DELTA2 method lesser \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta2_wfn_lesser)). # Establish method for third delta correction energy; if 'delta3_wfn' in kwargs:; do_delta3 = 1; cbs_delta3_wfn = kwargs['delta3_wfn'].lower(); if not (cbs_delta3_wfn in VARH.keys()):; raise ValidationError('Requested DELTA3 method \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta3_wfn)). if 'delta3_wfn_lesser' in kwargs:; cbs_delta3_wfn_lesser = kwargs['delta3_wfn_lesser'].lower(); else:; cbs_delta3_wfn_lesser = 'mp2'; if not (cbs_delta3_wfn_lesser in VARH.keys()):; raise ValidationError('Requested DELTA3 method lesser \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta3_wfn_lesser)). # Establish method for fourth delta correction energy; if 'delta4_wfn' in kwargs:; do_delta4 = 1; cbs_delta4_wfn = kwargs['delta4_wfn'].lower(); if not (cbs_delta4_wfn in VARH.keys()):; raise ValidationError('Requested DELTA4 method \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta4_wfn)). if 'delta4_wfn_lesser' in kwargs:; cbs_delta4_wfn_lesser = kwargs['delta4_wfn_lesser'].lower(); else:; cbs_delta4_wfn_lesser = 'mp2'; if not (cbs_delta4_wfn_lesser in VARH.keys()):; raise ValidationError('Requested DELTA4 method lesser \'%s\,MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:72678,Security,Validat,ValidationError,72678, ValidationError('Requested DELTA2 method \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta2_wfn)). if 'delta2_wfn_lesser' in kwargs:; cbs_delta2_wfn_lesser = kwargs['delta2_wfn_lesser'].lower(); else:; cbs_delta2_wfn_lesser = 'mp2'; if not (cbs_delta2_wfn_lesser in VARH.keys()):; raise ValidationError('Requested DELTA2 method lesser \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta2_wfn_lesser)). # Establish method for third delta correction energy; if 'delta3_wfn' in kwargs:; do_delta3 = 1; cbs_delta3_wfn = kwargs['delta3_wfn'].lower(); if not (cbs_delta3_wfn in VARH.keys()):; raise ValidationError('Requested DELTA3 method \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta3_wfn)). if 'delta3_wfn_lesser' in kwargs:; cbs_delta3_wfn_lesser = kwargs['delta3_wfn_lesser'].lower(); else:; cbs_delta3_wfn_lesser = 'mp2'; if not (cbs_delta3_wfn_lesser in VARH.keys()):; raise ValidationError('Requested DELTA3 method lesser \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta3_wfn_lesser)). # Establish method for fourth delta correction energy; if 'delta4_wfn' in kwargs:; do_delta4 = 1; cbs_delta4_wfn = kwargs['delta4_wfn'].lower(); if not (cbs_delta4_wfn in VARH.keys()):; raise ValidationError('Requested DELTA4 method \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta4_wfn)). if 'delta4_wfn_lesser' in kwargs:; cbs_delta4_wfn_lesser = kwargs['delta4_wfn_lesser'].lower(); else:; cbs_delta4_wfn_lesser = 'mp2'; if not (cbs_delta4_wfn_lesser in VARH.keys()):; raise ValidationError('Requested DELTA4 method lesser \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta4_wfn_lesser)). # Establish method for fifth delta correction energy; if 'delta5_wfn' in kwargs:; do_delta5 = 1; cbs_delta5_wfn = kwargs['delta5_wfn'].lower(); if not (cbs_delta5_wfn in VARH.keys()):; raise ValidationError('Requested DELTA5 method,MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:73014,Security,Validat,ValidationError,73014,r('Requested DELTA2 method lesser \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta2_wfn_lesser)). # Establish method for third delta correction energy; if 'delta3_wfn' in kwargs:; do_delta3 = 1; cbs_delta3_wfn = kwargs['delta3_wfn'].lower(); if not (cbs_delta3_wfn in VARH.keys()):; raise ValidationError('Requested DELTA3 method \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta3_wfn)). if 'delta3_wfn_lesser' in kwargs:; cbs_delta3_wfn_lesser = kwargs['delta3_wfn_lesser'].lower(); else:; cbs_delta3_wfn_lesser = 'mp2'; if not (cbs_delta3_wfn_lesser in VARH.keys()):; raise ValidationError('Requested DELTA3 method lesser \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta3_wfn_lesser)). # Establish method for fourth delta correction energy; if 'delta4_wfn' in kwargs:; do_delta4 = 1; cbs_delta4_wfn = kwargs['delta4_wfn'].lower(); if not (cbs_delta4_wfn in VARH.keys()):; raise ValidationError('Requested DELTA4 method \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta4_wfn)). if 'delta4_wfn_lesser' in kwargs:; cbs_delta4_wfn_lesser = kwargs['delta4_wfn_lesser'].lower(); else:; cbs_delta4_wfn_lesser = 'mp2'; if not (cbs_delta4_wfn_lesser in VARH.keys()):; raise ValidationError('Requested DELTA4 method lesser \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta4_wfn_lesser)). # Establish method for fifth delta correction energy; if 'delta5_wfn' in kwargs:; do_delta5 = 1; cbs_delta5_wfn = kwargs['delta5_wfn'].lower(); if not (cbs_delta5_wfn in VARH.keys()):; raise ValidationError('Requested DELTA5 method \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta5_wfn)). if 'delta5_wfn_lesser' in kwargs:; cbs_delta5_wfn_lesser = kwargs['delta5_wfn_lesser'].lower(); else:; cbs_delta5_wfn_lesser = 'mp2'; if not (cbs_delta5_wfn_lesser in VARH.keys()):; raise ValidationError('Requested DELTA5 method lesser \'%s\',MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:73332,Security,Validat,ValidationError,73332,ValidationError('Requested DELTA3 method \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta3_wfn)). if 'delta3_wfn_lesser' in kwargs:; cbs_delta3_wfn_lesser = kwargs['delta3_wfn_lesser'].lower(); else:; cbs_delta3_wfn_lesser = 'mp2'; if not (cbs_delta3_wfn_lesser in VARH.keys()):; raise ValidationError('Requested DELTA3 method lesser \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta3_wfn_lesser)). # Establish method for fourth delta correction energy; if 'delta4_wfn' in kwargs:; do_delta4 = 1; cbs_delta4_wfn = kwargs['delta4_wfn'].lower(); if not (cbs_delta4_wfn in VARH.keys()):; raise ValidationError('Requested DELTA4 method \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta4_wfn)). if 'delta4_wfn_lesser' in kwargs:; cbs_delta4_wfn_lesser = kwargs['delta4_wfn_lesser'].lower(); else:; cbs_delta4_wfn_lesser = 'mp2'; if not (cbs_delta4_wfn_lesser in VARH.keys()):; raise ValidationError('Requested DELTA4 method lesser \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta4_wfn_lesser)). # Establish method for fifth delta correction energy; if 'delta5_wfn' in kwargs:; do_delta5 = 1; cbs_delta5_wfn = kwargs['delta5_wfn'].lower(); if not (cbs_delta5_wfn in VARH.keys()):; raise ValidationError('Requested DELTA5 method \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta5_wfn)). if 'delta5_wfn_lesser' in kwargs:; cbs_delta5_wfn_lesser = kwargs['delta5_wfn_lesser'].lower(); else:; cbs_delta5_wfn_lesser = 'mp2'; if not (cbs_delta5_wfn_lesser in VARH.keys()):; raise ValidationError('Requested DELTA5 method lesser \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta5_wfn_lesser)). # Check that user isn't skipping steps in scf + corl + delta + delta2 sequence; if do_scf and not do_corl and not do_delta and not do_delta2 and not do_delta3 and not do_delta4 and not do_delta5:; pass; elif do_scf and do_corl and n,MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:73667,Security,Validat,ValidationError,73667,r('Requested DELTA3 method lesser \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta3_wfn_lesser)). # Establish method for fourth delta correction energy; if 'delta4_wfn' in kwargs:; do_delta4 = 1; cbs_delta4_wfn = kwargs['delta4_wfn'].lower(); if not (cbs_delta4_wfn in VARH.keys()):; raise ValidationError('Requested DELTA4 method \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta4_wfn)). if 'delta4_wfn_lesser' in kwargs:; cbs_delta4_wfn_lesser = kwargs['delta4_wfn_lesser'].lower(); else:; cbs_delta4_wfn_lesser = 'mp2'; if not (cbs_delta4_wfn_lesser in VARH.keys()):; raise ValidationError('Requested DELTA4 method lesser \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta4_wfn_lesser)). # Establish method for fifth delta correction energy; if 'delta5_wfn' in kwargs:; do_delta5 = 1; cbs_delta5_wfn = kwargs['delta5_wfn'].lower(); if not (cbs_delta5_wfn in VARH.keys()):; raise ValidationError('Requested DELTA5 method \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta5_wfn)). if 'delta5_wfn_lesser' in kwargs:; cbs_delta5_wfn_lesser = kwargs['delta5_wfn_lesser'].lower(); else:; cbs_delta5_wfn_lesser = 'mp2'; if not (cbs_delta5_wfn_lesser in VARH.keys()):; raise ValidationError('Requested DELTA5 method lesser \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta5_wfn_lesser)). # Check that user isn't skipping steps in scf + corl + delta + delta2 sequence; if do_scf and not do_corl and not do_delta and not do_delta2 and not do_delta3 and not do_delta4 and not do_delta5:; pass; elif do_scf and do_corl and not do_delta and not do_delta2 and not do_delta3 and not do_delta4 and not do_delta5:; pass; elif do_scf and do_corl and do_delta and not do_delta2 and not do_delta3 and not do_delta4 and not do_delta5:; pass; elif do_scf and do_corl and do_delta and do_delta2 and not do_delta3 and not do_delta4 and not do_delta5:; pass; elif do_s,MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:73985,Security,Validat,ValidationError,73985, ValidationError('Requested DELTA4 method \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta4_wfn)). if 'delta4_wfn_lesser' in kwargs:; cbs_delta4_wfn_lesser = kwargs['delta4_wfn_lesser'].lower(); else:; cbs_delta4_wfn_lesser = 'mp2'; if not (cbs_delta4_wfn_lesser in VARH.keys()):; raise ValidationError('Requested DELTA4 method lesser \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta4_wfn_lesser)). # Establish method for fifth delta correction energy; if 'delta5_wfn' in kwargs:; do_delta5 = 1; cbs_delta5_wfn = kwargs['delta5_wfn'].lower(); if not (cbs_delta5_wfn in VARH.keys()):; raise ValidationError('Requested DELTA5 method \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta5_wfn)). if 'delta5_wfn_lesser' in kwargs:; cbs_delta5_wfn_lesser = kwargs['delta5_wfn_lesser'].lower(); else:; cbs_delta5_wfn_lesser = 'mp2'; if not (cbs_delta5_wfn_lesser in VARH.keys()):; raise ValidationError('Requested DELTA5 method lesser \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta5_wfn_lesser)). # Check that user isn't skipping steps in scf + corl + delta + delta2 sequence; if do_scf and not do_corl and not do_delta and not do_delta2 and not do_delta3 and not do_delta4 and not do_delta5:; pass; elif do_scf and do_corl and not do_delta and not do_delta2 and not do_delta3 and not do_delta4 and not do_delta5:; pass; elif do_scf and do_corl and do_delta and not do_delta2 and not do_delta3 and not do_delta4 and not do_delta5:; pass; elif do_scf and do_corl and do_delta and do_delta2 and not do_delta3 and not do_delta4 and not do_delta5:; pass; elif do_scf and do_corl and do_delta and do_delta2 and do_delta3 and not do_delta4 and not do_delta5:; pass; elif do_scf and do_corl and do_delta and do_delta2 and do_delta3 and do_delta4 and not do_delta5:; pass; elif do_scf and do_corl and do_delta and do_delta2 and do_delta3 and do_delta4 and do_delta5:; pass; else:; raise Val,MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:75011,Security,Validat,ValidationError,75011,"elta5_wfn in VARH.keys()):; raise ValidationError('Requested DELTA5 method \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta5_wfn)). if 'delta5_wfn_lesser' in kwargs:; cbs_delta5_wfn_lesser = kwargs['delta5_wfn_lesser'].lower(); else:; cbs_delta5_wfn_lesser = 'mp2'; if not (cbs_delta5_wfn_lesser in VARH.keys()):; raise ValidationError('Requested DELTA5 method lesser \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta5_wfn_lesser)). # Check that user isn't skipping steps in scf + corl + delta + delta2 sequence; if do_scf and not do_corl and not do_delta and not do_delta2 and not do_delta3 and not do_delta4 and not do_delta5:; pass; elif do_scf and do_corl and not do_delta and not do_delta2 and not do_delta3 and not do_delta4 and not do_delta5:; pass; elif do_scf and do_corl and do_delta and not do_delta2 and not do_delta3 and not do_delta4 and not do_delta5:; pass; elif do_scf and do_corl and do_delta and do_delta2 and not do_delta3 and not do_delta4 and not do_delta5:; pass; elif do_scf and do_corl and do_delta and do_delta2 and do_delta3 and not do_delta4 and not do_delta5:; pass; elif do_scf and do_corl and do_delta and do_delta2 and do_delta3 and do_delta4 and not do_delta5:; pass; elif do_scf and do_corl and do_delta and do_delta2 and do_delta3 and do_delta4 and do_delta5:; pass; else:; raise ValidationError('Requested scf (%s) + corl (%s) + delta (%s) + delta2 (%s) + delta3 (%s) + delta4 (%s) + delta5 (%s) not valid. These steps are cummulative.' %; (do_scf, do_corl, do_delta, do_delta2, do_delta3, do_delta4, do_delta5)). # Establish list of valid basis sets for correlation energy; if do_corl:; if 'corl_basis' in kwargs:; BSTC, ZETC = validate_bracketed_basis(kwargs['corl_basis'].lower()); else:; raise ValidationError('CORL basis sets through keyword \'%s\' are required.' % ('corl_basis')). # Establish list of valid basis sets for scf energy; if 'scf_basis' in kwargs:; BSTR, ZETR = validate_bracketed_b",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:75430,Security,Validat,ValidationError,75430,"elif do_scf and do_corl and do_delta and not do_delta2 and not do_delta3 and not do_delta4 and not do_delta5:; pass; elif do_scf and do_corl and do_delta and do_delta2 and not do_delta3 and not do_delta4 and not do_delta5:; pass; elif do_scf and do_corl and do_delta and do_delta2 and do_delta3 and not do_delta4 and not do_delta5:; pass; elif do_scf and do_corl and do_delta and do_delta2 and do_delta3 and do_delta4 and not do_delta5:; pass; elif do_scf and do_corl and do_delta and do_delta2 and do_delta3 and do_delta4 and do_delta5:; pass; else:; raise ValidationError('Requested scf (%s) + corl (%s) + delta (%s) + delta2 (%s) + delta3 (%s) + delta4 (%s) + delta5 (%s) not valid. These steps are cummulative.' %; (do_scf, do_corl, do_delta, do_delta2, do_delta3, do_delta4, do_delta5)). # Establish list of valid basis sets for correlation energy; if do_corl:; if 'corl_basis' in kwargs:; BSTC, ZETC = validate_bracketed_basis(kwargs['corl_basis'].lower()); else:; raise ValidationError('CORL basis sets through keyword \'%s\' are required.' % ('corl_basis')). # Establish list of valid basis sets for scf energy; if 'scf_basis' in kwargs:; BSTR, ZETR = validate_bracketed_basis(kwargs['scf_basis'].lower()); else:; if do_corl:; BSTR = BSTC[:]; ZETR = ZETC[:]; else:; raise ValidationError('SCF basis sets through keyword \'%s\' are required. Or perhaps you forgot the \'%s\'.' % ('scf_basis', 'corl_wfn')). # Establish list of valid basis sets for delta correction energy; if do_delta:; if 'delta_basis' in kwargs:; BSTD, ZETD = validate_bracketed_basis(kwargs['delta_basis'].lower()); else:; raise ValidationError('DELTA basis sets through keyword \'%s\' are required.' % ('delta_basis')). # Establish list of valid basis sets for second delta correction energy; if do_delta2:; if 'delta2_basis' in kwargs:; BSTD2, ZETD2 = validate_bracketed_basis(kwargs['delta2_basis'].lower()); else:; raise ValidationError('DELTA2 basis sets through keyword \'%s\' are required.' % ('delta2_basis')). # Es",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:75733,Security,Validat,ValidationError,75733,"lta2 and do_delta3 and not do_delta4 and not do_delta5:; pass; elif do_scf and do_corl and do_delta and do_delta2 and do_delta3 and do_delta4 and not do_delta5:; pass; elif do_scf and do_corl and do_delta and do_delta2 and do_delta3 and do_delta4 and do_delta5:; pass; else:; raise ValidationError('Requested scf (%s) + corl (%s) + delta (%s) + delta2 (%s) + delta3 (%s) + delta4 (%s) + delta5 (%s) not valid. These steps are cummulative.' %; (do_scf, do_corl, do_delta, do_delta2, do_delta3, do_delta4, do_delta5)). # Establish list of valid basis sets for correlation energy; if do_corl:; if 'corl_basis' in kwargs:; BSTC, ZETC = validate_bracketed_basis(kwargs['corl_basis'].lower()); else:; raise ValidationError('CORL basis sets through keyword \'%s\' are required.' % ('corl_basis')). # Establish list of valid basis sets for scf energy; if 'scf_basis' in kwargs:; BSTR, ZETR = validate_bracketed_basis(kwargs['scf_basis'].lower()); else:; if do_corl:; BSTR = BSTC[:]; ZETR = ZETC[:]; else:; raise ValidationError('SCF basis sets through keyword \'%s\' are required. Or perhaps you forgot the \'%s\'.' % ('scf_basis', 'corl_wfn')). # Establish list of valid basis sets for delta correction energy; if do_delta:; if 'delta_basis' in kwargs:; BSTD, ZETD = validate_bracketed_basis(kwargs['delta_basis'].lower()); else:; raise ValidationError('DELTA basis sets through keyword \'%s\' are required.' % ('delta_basis')). # Establish list of valid basis sets for second delta correction energy; if do_delta2:; if 'delta2_basis' in kwargs:; BSTD2, ZETD2 = validate_bracketed_basis(kwargs['delta2_basis'].lower()); else:; raise ValidationError('DELTA2 basis sets through keyword \'%s\' are required.' % ('delta2_basis')). # Establish list of valid basis sets for third delta correction energy; if do_delta3:; if 'delta3_basis' in kwargs:; BSTD3, ZETD3 = validate_bracketed_basis(kwargs['delta3_basis'].lower()); else:; raise ValidationError('DELTA3 basis sets through keyword \'%s\' are required.' % ('d",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:76059,Security,Validat,ValidationError,76059,"%s) + delta3 (%s) + delta4 (%s) + delta5 (%s) not valid. These steps are cummulative.' %; (do_scf, do_corl, do_delta, do_delta2, do_delta3, do_delta4, do_delta5)). # Establish list of valid basis sets for correlation energy; if do_corl:; if 'corl_basis' in kwargs:; BSTC, ZETC = validate_bracketed_basis(kwargs['corl_basis'].lower()); else:; raise ValidationError('CORL basis sets through keyword \'%s\' are required.' % ('corl_basis')). # Establish list of valid basis sets for scf energy; if 'scf_basis' in kwargs:; BSTR, ZETR = validate_bracketed_basis(kwargs['scf_basis'].lower()); else:; if do_corl:; BSTR = BSTC[:]; ZETR = ZETC[:]; else:; raise ValidationError('SCF basis sets through keyword \'%s\' are required. Or perhaps you forgot the \'%s\'.' % ('scf_basis', 'corl_wfn')). # Establish list of valid basis sets for delta correction energy; if do_delta:; if 'delta_basis' in kwargs:; BSTD, ZETD = validate_bracketed_basis(kwargs['delta_basis'].lower()); else:; raise ValidationError('DELTA basis sets through keyword \'%s\' are required.' % ('delta_basis')). # Establish list of valid basis sets for second delta correction energy; if do_delta2:; if 'delta2_basis' in kwargs:; BSTD2, ZETD2 = validate_bracketed_basis(kwargs['delta2_basis'].lower()); else:; raise ValidationError('DELTA2 basis sets through keyword \'%s\' are required.' % ('delta2_basis')). # Establish list of valid basis sets for third delta correction energy; if do_delta3:; if 'delta3_basis' in kwargs:; BSTD3, ZETD3 = validate_bracketed_basis(kwargs['delta3_basis'].lower()); else:; raise ValidationError('DELTA3 basis sets through keyword \'%s\' are required.' % ('delta3_basis')). # Establish list of valid basis sets for fourth delta correction energy; if do_delta4:; if 'delta4_basis' in kwargs:; BSTD4, ZETD4 = validate_bracketed_basis(kwargs['delta4_basis'].lower()); else:; raise ValidationError('DELTA4 basis sets through keyword \'%s\' are required.' % ('delta4_basis')). # Establish list of valid basis sets fo",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:76355,Security,Validat,ValidationError,76355,"_basis(kwargs['corl_basis'].lower()); else:; raise ValidationError('CORL basis sets through keyword \'%s\' are required.' % ('corl_basis')). # Establish list of valid basis sets for scf energy; if 'scf_basis' in kwargs:; BSTR, ZETR = validate_bracketed_basis(kwargs['scf_basis'].lower()); else:; if do_corl:; BSTR = BSTC[:]; ZETR = ZETC[:]; else:; raise ValidationError('SCF basis sets through keyword \'%s\' are required. Or perhaps you forgot the \'%s\'.' % ('scf_basis', 'corl_wfn')). # Establish list of valid basis sets for delta correction energy; if do_delta:; if 'delta_basis' in kwargs:; BSTD, ZETD = validate_bracketed_basis(kwargs['delta_basis'].lower()); else:; raise ValidationError('DELTA basis sets through keyword \'%s\' are required.' % ('delta_basis')). # Establish list of valid basis sets for second delta correction energy; if do_delta2:; if 'delta2_basis' in kwargs:; BSTD2, ZETD2 = validate_bracketed_basis(kwargs['delta2_basis'].lower()); else:; raise ValidationError('DELTA2 basis sets through keyword \'%s\' are required.' % ('delta2_basis')). # Establish list of valid basis sets for third delta correction energy; if do_delta3:; if 'delta3_basis' in kwargs:; BSTD3, ZETD3 = validate_bracketed_basis(kwargs['delta3_basis'].lower()); else:; raise ValidationError('DELTA3 basis sets through keyword \'%s\' are required.' % ('delta3_basis')). # Establish list of valid basis sets for fourth delta correction energy; if do_delta4:; if 'delta4_basis' in kwargs:; BSTD4, ZETD4 = validate_bracketed_basis(kwargs['delta4_basis'].lower()); else:; raise ValidationError('DELTA4 basis sets through keyword \'%s\' are required.' % ('delta4_basis')). # Establish list of valid basis sets for fifth delta correction energy; if do_delta5:; if 'delta5_basis' in kwargs:; BSTD5, ZETD5 = validate_bracketed_basis(kwargs['delta5_basis'].lower()); else:; raise ValidationError('DELTA5 basis sets through keyword \'%s\' are required.' % ('delta5_basis')). # Establish treatment for scf energy (",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:76652,Security,Validat,ValidationError,76652,"f do_corl:; BSTR = BSTC[:]; ZETR = ZETC[:]; else:; raise ValidationError('SCF basis sets through keyword \'%s\' are required. Or perhaps you forgot the \'%s\'.' % ('scf_basis', 'corl_wfn')). # Establish list of valid basis sets for delta correction energy; if do_delta:; if 'delta_basis' in kwargs:; BSTD, ZETD = validate_bracketed_basis(kwargs['delta_basis'].lower()); else:; raise ValidationError('DELTA basis sets through keyword \'%s\' are required.' % ('delta_basis')). # Establish list of valid basis sets for second delta correction energy; if do_delta2:; if 'delta2_basis' in kwargs:; BSTD2, ZETD2 = validate_bracketed_basis(kwargs['delta2_basis'].lower()); else:; raise ValidationError('DELTA2 basis sets through keyword \'%s\' are required.' % ('delta2_basis')). # Establish list of valid basis sets for third delta correction energy; if do_delta3:; if 'delta3_basis' in kwargs:; BSTD3, ZETD3 = validate_bracketed_basis(kwargs['delta3_basis'].lower()); else:; raise ValidationError('DELTA3 basis sets through keyword \'%s\' are required.' % ('delta3_basis')). # Establish list of valid basis sets for fourth delta correction energy; if do_delta4:; if 'delta4_basis' in kwargs:; BSTD4, ZETD4 = validate_bracketed_basis(kwargs['delta4_basis'].lower()); else:; raise ValidationError('DELTA4 basis sets through keyword \'%s\' are required.' % ('delta4_basis')). # Establish list of valid basis sets for fifth delta correction energy; if do_delta5:; if 'delta5_basis' in kwargs:; BSTD5, ZETD5 = validate_bracketed_basis(kwargs['delta5_basis'].lower()); else:; raise ValidationError('DELTA5 basis sets through keyword \'%s\' are required.' % ('delta5_basis')). # Establish treatment for scf energy (validity check useless since python will catch it long before here); cbs_scf_scheme = highest_1; if 'scf_scheme' in kwargs:; cbs_scf_scheme = kwargs['scf_scheme']. # Establish treatment for correlation energy; cbs_corl_scheme = highest_1; if 'corl_scheme' in kwargs:; cbs_corl_scheme = kwargs['cor",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:76950,Security,Validat,ValidationError,76950,"; BSTD, ZETD = validate_bracketed_basis(kwargs['delta_basis'].lower()); else:; raise ValidationError('DELTA basis sets through keyword \'%s\' are required.' % ('delta_basis')). # Establish list of valid basis sets for second delta correction energy; if do_delta2:; if 'delta2_basis' in kwargs:; BSTD2, ZETD2 = validate_bracketed_basis(kwargs['delta2_basis'].lower()); else:; raise ValidationError('DELTA2 basis sets through keyword \'%s\' are required.' % ('delta2_basis')). # Establish list of valid basis sets for third delta correction energy; if do_delta3:; if 'delta3_basis' in kwargs:; BSTD3, ZETD3 = validate_bracketed_basis(kwargs['delta3_basis'].lower()); else:; raise ValidationError('DELTA3 basis sets through keyword \'%s\' are required.' % ('delta3_basis')). # Establish list of valid basis sets for fourth delta correction energy; if do_delta4:; if 'delta4_basis' in kwargs:; BSTD4, ZETD4 = validate_bracketed_basis(kwargs['delta4_basis'].lower()); else:; raise ValidationError('DELTA4 basis sets through keyword \'%s\' are required.' % ('delta4_basis')). # Establish list of valid basis sets for fifth delta correction energy; if do_delta5:; if 'delta5_basis' in kwargs:; BSTD5, ZETD5 = validate_bracketed_basis(kwargs['delta5_basis'].lower()); else:; raise ValidationError('DELTA5 basis sets through keyword \'%s\' are required.' % ('delta5_basis')). # Establish treatment for scf energy (validity check useless since python will catch it long before here); cbs_scf_scheme = highest_1; if 'scf_scheme' in kwargs:; cbs_scf_scheme = kwargs['scf_scheme']. # Establish treatment for correlation energy; cbs_corl_scheme = highest_1; if 'corl_scheme' in kwargs:; cbs_corl_scheme = kwargs['corl_scheme']. # Establish treatment for delta correction energy; cbs_delta_scheme = highest_1; if 'delta_scheme' in kwargs:; cbs_delta_scheme = kwargs['delta_scheme']. # Establish treatment for delta2 correction energy; cbs_delta2_scheme = highest_1; if 'delta2_scheme' in kwargs:; cbs_delta2_scheme ",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:77247,Security,Validat,ValidationError,77247,"TD2, ZETD2 = validate_bracketed_basis(kwargs['delta2_basis'].lower()); else:; raise ValidationError('DELTA2 basis sets through keyword \'%s\' are required.' % ('delta2_basis')). # Establish list of valid basis sets for third delta correction energy; if do_delta3:; if 'delta3_basis' in kwargs:; BSTD3, ZETD3 = validate_bracketed_basis(kwargs['delta3_basis'].lower()); else:; raise ValidationError('DELTA3 basis sets through keyword \'%s\' are required.' % ('delta3_basis')). # Establish list of valid basis sets for fourth delta correction energy; if do_delta4:; if 'delta4_basis' in kwargs:; BSTD4, ZETD4 = validate_bracketed_basis(kwargs['delta4_basis'].lower()); else:; raise ValidationError('DELTA4 basis sets through keyword \'%s\' are required.' % ('delta4_basis')). # Establish list of valid basis sets for fifth delta correction energy; if do_delta5:; if 'delta5_basis' in kwargs:; BSTD5, ZETD5 = validate_bracketed_basis(kwargs['delta5_basis'].lower()); else:; raise ValidationError('DELTA5 basis sets through keyword \'%s\' are required.' % ('delta5_basis')). # Establish treatment for scf energy (validity check useless since python will catch it long before here); cbs_scf_scheme = highest_1; if 'scf_scheme' in kwargs:; cbs_scf_scheme = kwargs['scf_scheme']. # Establish treatment for correlation energy; cbs_corl_scheme = highest_1; if 'corl_scheme' in kwargs:; cbs_corl_scheme = kwargs['corl_scheme']. # Establish treatment for delta correction energy; cbs_delta_scheme = highest_1; if 'delta_scheme' in kwargs:; cbs_delta_scheme = kwargs['delta_scheme']. # Establish treatment for delta2 correction energy; cbs_delta2_scheme = highest_1; if 'delta2_scheme' in kwargs:; cbs_delta2_scheme = kwargs['delta2_scheme']. # Establish treatment for delta3 correction energy; cbs_delta3_scheme = highest_1; if 'delta3_scheme' in kwargs:; cbs_delta3_scheme = kwargs['delta3_scheme']. # Establish treatment for delta4 correction energy; cbs_delta4_scheme = highest_1; if 'delta4_scheme' in kwargs",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:90347,Security,validat,validate,90347,"S', '', '', '', finalenergy, ''); tables += table_delimit. #print tables; psi4.print_out(tables). # Restore molecule and options; #psi4.set_local_option('SCF', ""WFN"", user_wfn) # TODO refuses to set global option WFN - rejects SCF as option; psi4.set_global_option('BASIS', user_basis). psi4.set_global_option('WFN', user_wfn); if not b_user_wfn:; psi4.revoke_global_option_changed('WFN'). psi4.set_global_option('WRITER_FILE_LABEL', user_writer_file_label). psi4.set_variable('CBS REFERENCE ENERGY', GRAND_NEED[0]['d_energy']); psi4.set_variable('CBS CORRELATION ENERGY', finalenergy - GRAND_NEED[0]['d_energy']); psi4.set_variable('CBS TOTAL ENERGY', finalenergy); psi4.set_variable('CURRENT REFERENCE ENERGY', GRAND_NEED[0]['d_energy']); psi4.set_variable('CURRENT CORRELATION ENERGY', finalenergy - GRAND_NEED[0]['d_energy']); psi4.set_variable('CURRENT ENERGY', finalenergy); return finalenergy. # Transform and validate basis sets from 'cc-pV[Q5]Z' into [cc-pVQZ, cc-pV5Z] and [4, 5]; [docs]def validate_bracketed_basis(basisstring):; r""""""Function to transform and validate basis sets for cbs(). A basis set with no; paired square brackets is passed through with zeta level 0 (e.g., '6-31+G(d,p)'; is returned as [6-31+G(d,p)] and [0]). A basis set with square brackets is; checked for sensible sequence and Dunning-ness and returned as separate basis; sets (e.g., 'cc-pV[Q5]Z' is returned as [cc-pVQZ, cc-pV5Z] and [4, 5]). Note; that this function has no communication with the basis set library to check; if the basis actually exists. Used by :py:func:`~wrappers.complete_basis_set`. """"""; ZETA = ['d', 't', 'q', '5', '6']; BSET = []; ZSET = []; if re.match(r'.*cc-.*\[.*\].*z$', basisstring, flags=re.IGNORECASE):; basispattern = re.compile(r'^(.*)\[(.*)\](.*)$'); basisname = basispattern.match(basisstring); for b in basisname.group(2):; if b not in ZETA:; raise ValidationError('Basis set \'%s\' has invalid zeta level \'%s\'.' % (basisstring, b)); if len(ZSET) != 0:; if (int(ZSET[len(ZSE",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:90501,Security,validat,validate,90501,"S', '', '', '', finalenergy, ''); tables += table_delimit. #print tables; psi4.print_out(tables). # Restore molecule and options; #psi4.set_local_option('SCF', ""WFN"", user_wfn) # TODO refuses to set global option WFN - rejects SCF as option; psi4.set_global_option('BASIS', user_basis). psi4.set_global_option('WFN', user_wfn); if not b_user_wfn:; psi4.revoke_global_option_changed('WFN'). psi4.set_global_option('WRITER_FILE_LABEL', user_writer_file_label). psi4.set_variable('CBS REFERENCE ENERGY', GRAND_NEED[0]['d_energy']); psi4.set_variable('CBS CORRELATION ENERGY', finalenergy - GRAND_NEED[0]['d_energy']); psi4.set_variable('CBS TOTAL ENERGY', finalenergy); psi4.set_variable('CURRENT REFERENCE ENERGY', GRAND_NEED[0]['d_energy']); psi4.set_variable('CURRENT CORRELATION ENERGY', finalenergy - GRAND_NEED[0]['d_energy']); psi4.set_variable('CURRENT ENERGY', finalenergy); return finalenergy. # Transform and validate basis sets from 'cc-pV[Q5]Z' into [cc-pVQZ, cc-pV5Z] and [4, 5]; [docs]def validate_bracketed_basis(basisstring):; r""""""Function to transform and validate basis sets for cbs(). A basis set with no; paired square brackets is passed through with zeta level 0 (e.g., '6-31+G(d,p)'; is returned as [6-31+G(d,p)] and [0]). A basis set with square brackets is; checked for sensible sequence and Dunning-ness and returned as separate basis; sets (e.g., 'cc-pV[Q5]Z' is returned as [cc-pVQZ, cc-pV5Z] and [4, 5]). Note; that this function has no communication with the basis set library to check; if the basis actually exists. Used by :py:func:`~wrappers.complete_basis_set`. """"""; ZETA = ['d', 't', 'q', '5', '6']; BSET = []; ZSET = []; if re.match(r'.*cc-.*\[.*\].*z$', basisstring, flags=re.IGNORECASE):; basispattern = re.compile(r'^(.*)\[(.*)\](.*)$'); basisname = basispattern.match(basisstring); for b in basisname.group(2):; if b not in ZETA:; raise ValidationError('Basis set \'%s\' has invalid zeta level \'%s\'.' % (basisstring, b)); if len(ZSET) != 0:; if (int(ZSET[len(ZSE",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:91304,Security,Validat,ValidationError,91304,"finalenergy. # Transform and validate basis sets from 'cc-pV[Q5]Z' into [cc-pVQZ, cc-pV5Z] and [4, 5]; [docs]def validate_bracketed_basis(basisstring):; r""""""Function to transform and validate basis sets for cbs(). A basis set with no; paired square brackets is passed through with zeta level 0 (e.g., '6-31+G(d,p)'; is returned as [6-31+G(d,p)] and [0]). A basis set with square brackets is; checked for sensible sequence and Dunning-ness and returned as separate basis; sets (e.g., 'cc-pV[Q5]Z' is returned as [cc-pVQZ, cc-pV5Z] and [4, 5]). Note; that this function has no communication with the basis set library to check; if the basis actually exists. Used by :py:func:`~wrappers.complete_basis_set`. """"""; ZETA = ['d', 't', 'q', '5', '6']; BSET = []; ZSET = []; if re.match(r'.*cc-.*\[.*\].*z$', basisstring, flags=re.IGNORECASE):; basispattern = re.compile(r'^(.*)\[(.*)\](.*)$'); basisname = basispattern.match(basisstring); for b in basisname.group(2):; if b not in ZETA:; raise ValidationError('Basis set \'%s\' has invalid zeta level \'%s\'.' % (basisstring, b)); if len(ZSET) != 0:; if (int(ZSET[len(ZSET) - 1]) - ZETA.index(b)) != 1:; raise ValidationError('Basis set \'%s\' has out-of-order zeta level \'%s\'.' % (basisstring, b)); BSET.append(basisname.group(1) + b + basisname.group(3)); if b == 'd':; b = '2'; if b == 't':; b = '3'; if b == 'q':; b = '4'; ZSET.append(int(b)); elif re.match(r'.*\[.*\].*$', basisstring, flags=re.IGNORECASE):; raise ValidationError('Basis set surrounding series indicator [] in \'%s\' is invalid.' % (basisstring)); else:; BSET.append(basisstring); ZSET.append(0). return [BSET, ZSET]. # Reform string basis set descriptor from basis set strings, 'cc-pv[q5]z' from [cc-pvqz, cc-pv5z]; [docs]def reconstitute_bracketed_basis(needarray):; r""""""Function to reform a bracketed basis set string from a sequential series; of basis sets (e.g, form 'cc-pv[q5]z' from array [cc-pvqz, cc-pv5z]). The; basis set array is extracted from the *f_basis* field of a *NE",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:91470,Security,Validat,ValidationError,91470,"orm and validate basis sets for cbs(). A basis set with no; paired square brackets is passed through with zeta level 0 (e.g., '6-31+G(d,p)'; is returned as [6-31+G(d,p)] and [0]). A basis set with square brackets is; checked for sensible sequence and Dunning-ness and returned as separate basis; sets (e.g., 'cc-pV[Q5]Z' is returned as [cc-pVQZ, cc-pV5Z] and [4, 5]). Note; that this function has no communication with the basis set library to check; if the basis actually exists. Used by :py:func:`~wrappers.complete_basis_set`. """"""; ZETA = ['d', 't', 'q', '5', '6']; BSET = []; ZSET = []; if re.match(r'.*cc-.*\[.*\].*z$', basisstring, flags=re.IGNORECASE):; basispattern = re.compile(r'^(.*)\[(.*)\](.*)$'); basisname = basispattern.match(basisstring); for b in basisname.group(2):; if b not in ZETA:; raise ValidationError('Basis set \'%s\' has invalid zeta level \'%s\'.' % (basisstring, b)); if len(ZSET) != 0:; if (int(ZSET[len(ZSET) - 1]) - ZETA.index(b)) != 1:; raise ValidationError('Basis set \'%s\' has out-of-order zeta level \'%s\'.' % (basisstring, b)); BSET.append(basisname.group(1) + b + basisname.group(3)); if b == 'd':; b = '2'; if b == 't':; b = '3'; if b == 'q':; b = '4'; ZSET.append(int(b)); elif re.match(r'.*\[.*\].*$', basisstring, flags=re.IGNORECASE):; raise ValidationError('Basis set surrounding series indicator [] in \'%s\' is invalid.' % (basisstring)); else:; BSET.append(basisstring); ZSET.append(0). return [BSET, ZSET]. # Reform string basis set descriptor from basis set strings, 'cc-pv[q5]z' from [cc-pvqz, cc-pv5z]; [docs]def reconstitute_bracketed_basis(needarray):; r""""""Function to reform a bracketed basis set string from a sequential series; of basis sets (e.g, form 'cc-pv[q5]z' from array [cc-pvqz, cc-pv5z]). The; basis set array is extracted from the *f_basis* field of a *NEED* dictionary in; :py:func:`~wrappers.complete_basis_set`. Result is used to print a nicely; formatted basis set string in the results table. """"""; ZETA = {'d': 2, 't': 3, 'q'",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:91782,Security,Validat,ValidationError,91782,"' is returned as [cc-pVQZ, cc-pV5Z] and [4, 5]). Note; that this function has no communication with the basis set library to check; if the basis actually exists. Used by :py:func:`~wrappers.complete_basis_set`. """"""; ZETA = ['d', 't', 'q', '5', '6']; BSET = []; ZSET = []; if re.match(r'.*cc-.*\[.*\].*z$', basisstring, flags=re.IGNORECASE):; basispattern = re.compile(r'^(.*)\[(.*)\](.*)$'); basisname = basispattern.match(basisstring); for b in basisname.group(2):; if b not in ZETA:; raise ValidationError('Basis set \'%s\' has invalid zeta level \'%s\'.' % (basisstring, b)); if len(ZSET) != 0:; if (int(ZSET[len(ZSET) - 1]) - ZETA.index(b)) != 1:; raise ValidationError('Basis set \'%s\' has out-of-order zeta level \'%s\'.' % (basisstring, b)); BSET.append(basisname.group(1) + b + basisname.group(3)); if b == 'd':; b = '2'; if b == 't':; b = '3'; if b == 'q':; b = '4'; ZSET.append(int(b)); elif re.match(r'.*\[.*\].*$', basisstring, flags=re.IGNORECASE):; raise ValidationError('Basis set surrounding series indicator [] in \'%s\' is invalid.' % (basisstring)); else:; BSET.append(basisstring); ZSET.append(0). return [BSET, ZSET]. # Reform string basis set descriptor from basis set strings, 'cc-pv[q5]z' from [cc-pvqz, cc-pv5z]; [docs]def reconstitute_bracketed_basis(needarray):; r""""""Function to reform a bracketed basis set string from a sequential series; of basis sets (e.g, form 'cc-pv[q5]z' from array [cc-pvqz, cc-pv5z]). The; basis set array is extracted from the *f_basis* field of a *NEED* dictionary in; :py:func:`~wrappers.complete_basis_set`. Result is used to print a nicely; formatted basis set string in the results table. """"""; ZETA = {'d': 2, 't': 3, 'q': 4, '5': 5, '6': 6}; ZSET = [''] * len(ZETA); BSET = []. for lvl in needarray.items():; BSET.append(lvl[1]['f_basis']). if (len(BSET) == 1):; basisstring = BSET[0]; else:; indx = 0; while indx < len(BSET[0]):; if (BSET[0][indx] != BSET[1][indx]):; zetaindx = indx; indx += 1; for basis in BSET:; ZSET[ZETA[basis[zetain",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:93523,Security,Validat,ValidationError,93523," [''] * len(ZETA); BSET = []. for lvl in needarray.items():; BSET.append(lvl[1]['f_basis']). if (len(BSET) == 1):; basisstring = BSET[0]; else:; indx = 0; while indx < len(BSET[0]):; if (BSET[0][indx] != BSET[1][indx]):; zetaindx = indx; indx += 1; for basis in BSET:; ZSET[ZETA[basis[zetaindx]] - 2] = basis[zetaindx]. pre = BSET[0][:zetaindx]; post = BSET[0][zetaindx + 1:]; basisstring = pre + '[' + ''.join(ZSET) + ']' + post. return basisstring. [docs]def highest_1(**largs):; r""""""Scheme for total or correlation energies with a single basis or the highest; zeta-level among an array of bases. Used by :py:func:`~wrappers.complete_basis_set`. .. math:: E_{total}^X = E_{total}^X. """"""; energypiece = 0.0; functionname = sys._getframe().f_code.co_name; f_fields = ['f_wfn', 'f_portion', 'f_basis', 'f_zeta', 'f_energy']; [mode, NEED, wfnname, BSET, ZSET] = validate_scheme_args(functionname, **largs). if (mode == 'requisition'):. # Impose restrictions on zeta sequence; if (len(ZSET) == 0):; raise ValidationError('Call to \'%s\' not valid with \'%s\' basis sets.' % (functionname, len(ZSET))). # Return array that logs the requisite jobs; if (wfnname == 'scf'):; portion = 'tot'; else:; portion = 'corl'; NEED = {'HI': dict(zip(f_fields, [wfnname, portion, BSET[len(ZSET) - 1], ZSET[len(ZSET) - 1], 0.0]))}. return NEED. elif (mode == 'evaluate'):. # Extract required energies and zeta integers from array; # Compute extrapolated energy; energypiece = NEED['HI']['f_energy']. # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += """"""\n ==> %s <==\n\n"""""" % (functionname); if (NEED['HI']['f_wfn'] == 'scf'):; cbsscheme += """""" HI-zeta (%s) Total Energy: %16.8f\n"""""" % (str(NEED['HI']['f_zeta']), energypiece); else:; cbsscheme += """""" HI-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(NEED['HI']['f_zeta']), energypiece); psi4.print_out(cbsscheme). return energypiece. # Solution equation in LaTeX: $E_{corl}^{\infty} = \frac{E_{corl}^{X} X^3 - E_{corl}^{X-1} (X-1)^3}{X^3 -",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:95184,Security,Validat,ValidationError,95184,"%s) Total Energy: %16.8f\n"""""" % (str(NEED['HI']['f_zeta']), energypiece); else:; cbsscheme += """""" HI-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(NEED['HI']['f_zeta']), energypiece); psi4.print_out(cbsscheme). return energypiece. # Solution equation in LaTeX: $E_{corl}^{\infty} = \frac{E_{corl}^{X} X^3 - E_{corl}^{X-1} (X-1)^3}{X^3 - (X-1)^3}$; # Solution equation in LaTeX: $\beta = \frac{E_{corl}^{X} - E_{corl}^{X-1}}{X^{-3} - (X-1)^{-3}}$; [docs]def corl_xtpl_helgaker_2(**largs):; r""""""Extrapolation scheme for correlation energies with two adjacent zeta-level bases.; Used by :py:func:`~wrappers.complete_basis_set`. .. math:: E_{corl}^X = E_{corl}^{\infty} + \beta X^{-3}. """"""; energypiece = 0.0; functionname = sys._getframe().f_code.co_name; f_fields = ['f_wfn', 'f_portion', 'f_basis', 'f_zeta', 'f_energy']; [mode, NEED, wfnname, BSET, ZSET] = validate_scheme_args(functionname, **largs). if (mode == 'requisition'):. # Impose restrictions on zeta sequence; if (len(ZSET) != 2):; raise ValidationError('Call to \'%s\' not valid with \'%s\' basis sets.' % (functionname, len(ZSET))). # Return array that logs the requisite jobs; NEED = {'HI': dict(zip(f_fields, [wfnname, 'corl', BSET[1], ZSET[1], 0.0])),; 'LO': dict(zip(f_fields, [wfnname, 'corl', BSET[0], ZSET[0], 0.0]))}. return NEED. elif (mode == 'evaluate'):. # Extract required energies and zeta integers from array; eHI = NEED['HI']['f_energy']; zHI = NEED['HI']['f_zeta']; eLO = NEED['LO']['f_energy']; zLO = NEED['LO']['f_zeta']. # Compute extrapolated energy; energypiece = (eHI * zHI ** 3 - eLO * zLO ** 3) / (zHI ** 3 - zLO ** 3); beta = (eHI - eLO) / (zHI ** (-3) - zLO ** (-3)). # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += """"""\n ==> %s <==\n\n"""""" % (functionname); cbsscheme += """""" LO-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zLO), eLO); cbsscheme += """""" HI-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zHI), eHI); cbsscheme += """""" Extrapolated Correlation Energy: %16.8f\n""",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:96874,Security,Validat,ValidationError,96874,"ation parameters; cbsscheme = ''; cbsscheme += """"""\n ==> %s <==\n\n"""""" % (functionname); cbsscheme += """""" LO-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zLO), eLO); cbsscheme += """""" HI-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zHI), eHI); cbsscheme += """""" Extrapolated Correlation Energy: %16.8f\n"""""" % (energypiece); cbsscheme += """""" Beta (coefficient) Value: %16.8f\n"""""" % (beta); psi4.print_out(cbsscheme). return energypiece. [docs]def scf_xtpl_helgaker_3(**largs):; r""""""Extrapolation scheme for reference energies with three adjacent zeta-level bases.; Used by :py:func:`~wrappers.complete_basis_set`. .. math:: E_{total}^X = E_{total}^{\infty} + \beta e^{-\alpha X}. """"""; energypiece = 0.0; functionname = sys._getframe().f_code.co_name; f_fields = ['f_wfn', 'f_portion', 'f_basis', 'f_zeta', 'f_energy']; [mode, NEED, wfnname, BSET, ZSET] = validate_scheme_args(functionname, **largs). if (mode == 'requisition'):. # Impose restrictions on zeta sequence; if (len(ZSET) != 3):; raise ValidationError('Call to \'%s\' not valid with \'%s\' basis sets.' % (functionname, len(ZSET))). # Return array that logs the requisite jobs; NEED = {'HI': dict(zip(f_fields, [wfnname, 'tot', BSET[2], ZSET[2], 0.0])),; 'MD': dict(zip(f_fields, [wfnname, 'tot', BSET[1], ZSET[1], 0.0])),; 'LO': dict(zip(f_fields, [wfnname, 'tot', BSET[0], ZSET[0], 0.0]))}. return NEED. elif (mode == 'evaluate'):. # Extract required energies and zeta integers from array; eHI = NEED['HI']['f_energy']; eMD = NEED['MD']['f_energy']; eLO = NEED['LO']['f_energy']; zHI = NEED['HI']['f_zeta']; zMD = NEED['MD']['f_zeta']; zLO = NEED['LO']['f_zeta']. # Compute extrapolated energy; ratio = (eHI - eMD) / (eMD - eLO); alpha = -1 * math.log(ratio); beta = (eHI - eMD) / (math.exp(-1 * alpha * zMD) * (ratio - 1)); energypiece = eHI - beta * math.exp(-1 * alpha * zHI). # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += """"""\n ==> %s <==\n\n"""""" % (functionname); cbsscheme += """""" LO-zeta (%s) Corr",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:98909,Security,Validat,ValidationError,98909,"zLO), eLO); cbsscheme += """""" MD-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zMD), eMD); cbsscheme += """""" HI-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zHI), eHI); cbsscheme += """""" Extrapolated Correlation Energy: %16.8f\n"""""" % (energypiece); cbsscheme += """""" Alpha (exponent) Value: %16.8f\n"""""" % (alpha); cbsscheme += """""" Beta (coefficient) Value: %16.8f\n"""""" % (beta); psi4.print_out(cbsscheme). return energypiece. [docs]def scf_xtpl_helgaker_2(**largs):; r""""""Extrapolation scheme for reference energies with two adjacent zeta-level bases.; Used by :py:func:`~wrappers.complete_basis_set`. .. math:: E_{total}^X = E_{total}^{\infty} + \beta e^{-\alpha X}, \alpha = 1.63. """"""; energypiece = 0.0; functionname = sys._getframe().f_code.co_name; f_fields = ['f_wfn', 'f_portion', 'f_basis', 'f_zeta', 'f_energy']; [mode, NEED, wfnname, BSET, ZSET] = validate_scheme_args(functionname, **largs). if (mode == 'requisition'):. # Impose restrictions on zeta sequence; if (len(ZSET) != 2):; raise ValidationError('Call to \'%s\' not valid with \'%s\' basis sets.' % (functionname, len(ZSET))). # Return array that logs the requisite jobs; NEED = {'HI': dict(zip(f_fields, [wfnname, 'tot', BSET[1], ZSET[1], 0.0])),; 'LO': dict(zip(f_fields, [wfnname, 'tot', BSET[0], ZSET[0], 0.0]))}. return NEED. elif (mode == 'evaluate'):. # Extract required energies and zeta integers from array; eHI = NEED['HI']['f_energy']; eLO = NEED['LO']['f_energy']; zHI = NEED['HI']['f_zeta']; zLO = NEED['LO']['f_zeta']. # LAB TODO add ability to pass alternate parameter values in. # Return extrapolated energy; alpha = 1.63; beta = (eHI - eLO) / (math.exp(-1 * alpha * zLO) * (math.exp(-1 * alpha) - 1)); energypiece = eHI - beta * math.exp(-1 * alpha * zHI). # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += """"""\n ==> %s <==\n\n"""""" % (functionname); cbsscheme += """""" LO-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zLO), eLO); cbsscheme += """""" HI-zeta (%s) Correlation Energy: %16.8",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:100767,Security,Validat,ValidationError,100767,"me); cbsscheme += """""" LO-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zLO), eLO); cbsscheme += """""" HI-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zHI), eHI); cbsscheme += """""" Extrapolated Correlation Energy: %16.8f\n"""""" % (energypiece); cbsscheme += """""" Alpha (exponent) Value: %16.8f\n"""""" % (alpha); cbsscheme += """""" Beta (coefficient) Value: %16.8f\n"""""" % (beta); psi4.print_out(cbsscheme). return energypiece. [docs]def validate_scheme_args(functionname, **largs):; r""""""Function called by each extrapolation scheme in :py:func:`~wrappers.complete_basis_set`.; Checks that all the input arguments are present and suitable so that; the scheme function can focus on defining the extrapolation. """"""; mode = ''; NEED = []; wfnname = ''; BSET = []; ZSET = []. # Mode where function fills out a form NEED with the computations needed to fulfill its call; if (largs['mode'].lower() == 'requisition'):; mode = largs['mode'].lower(). if 'wfnname' in largs:; wfnname = largs['wfnname']; else:; raise ValidationError('Call to \'%s\' has keyword \'wfnname\' missing.' % (functionname)). if re.match(r'scf_.*$', functionname) and (wfnname != 'scf'):; raise ValidationError('Call to \'%s\' is intended for scf portion of calculation.' % (functionname)); if re.match(r'corl_.*$', functionname) and (wfnname == 'scf'):; raise ValidationError('Call to \'%s\' is not intended for scf portion of calculation.' % (functionname)). if 'basisname' in largs:; BSET = largs['basisname']; else:; raise ValidationError('Call to \'%s\' has keyword \'basisname\' missing.' % (functionname)). if 'basiszeta' in largs:; ZSET = largs['basiszeta']; else:; raise ValidationError('Call to \'%s\' has keyword \'basiszeta\' missing.' % (functionname)). # Mode where function reads the now-filled-in energies from that same form and performs the sp, xtpl, delta, etc.; elif (largs['mode'].lower() == 'evaluate'):; mode = largs['mode'].lower(). if 'needname' in largs:; NEED = largs['needname']; else:; raise ValidationError('Ca",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:100921,Security,Validat,ValidationError,100921,"cbsscheme += """""" Extrapolated Correlation Energy: %16.8f\n"""""" % (energypiece); cbsscheme += """""" Alpha (exponent) Value: %16.8f\n"""""" % (alpha); cbsscheme += """""" Beta (coefficient) Value: %16.8f\n"""""" % (beta); psi4.print_out(cbsscheme). return energypiece. [docs]def validate_scheme_args(functionname, **largs):; r""""""Function called by each extrapolation scheme in :py:func:`~wrappers.complete_basis_set`.; Checks that all the input arguments are present and suitable so that; the scheme function can focus on defining the extrapolation. """"""; mode = ''; NEED = []; wfnname = ''; BSET = []; ZSET = []. # Mode where function fills out a form NEED with the computations needed to fulfill its call; if (largs['mode'].lower() == 'requisition'):; mode = largs['mode'].lower(). if 'wfnname' in largs:; wfnname = largs['wfnname']; else:; raise ValidationError('Call to \'%s\' has keyword \'wfnname\' missing.' % (functionname)). if re.match(r'scf_.*$', functionname) and (wfnname != 'scf'):; raise ValidationError('Call to \'%s\' is intended for scf portion of calculation.' % (functionname)); if re.match(r'corl_.*$', functionname) and (wfnname == 'scf'):; raise ValidationError('Call to \'%s\' is not intended for scf portion of calculation.' % (functionname)). if 'basisname' in largs:; BSET = largs['basisname']; else:; raise ValidationError('Call to \'%s\' has keyword \'basisname\' missing.' % (functionname)). if 'basiszeta' in largs:; ZSET = largs['basiszeta']; else:; raise ValidationError('Call to \'%s\' has keyword \'basiszeta\' missing.' % (functionname)). # Mode where function reads the now-filled-in energies from that same form and performs the sp, xtpl, delta, etc.; elif (largs['mode'].lower() == 'evaluate'):; mode = largs['mode'].lower(). if 'needname' in largs:; NEED = largs['needname']; else:; raise ValidationError('Call to \'%s\' has keyword \'needname\' missing.' % (functionname)). else:; raise ValidationError('Call to \'%s\' has keyword \'mode\' missing or invalid.' % (functionnam",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:101087,Security,Validat,ValidationError,101087,"efficient) Value: %16.8f\n"""""" % (beta); psi4.print_out(cbsscheme). return energypiece. [docs]def validate_scheme_args(functionname, **largs):; r""""""Function called by each extrapolation scheme in :py:func:`~wrappers.complete_basis_set`.; Checks that all the input arguments are present and suitable so that; the scheme function can focus on defining the extrapolation. """"""; mode = ''; NEED = []; wfnname = ''; BSET = []; ZSET = []. # Mode where function fills out a form NEED with the computations needed to fulfill its call; if (largs['mode'].lower() == 'requisition'):; mode = largs['mode'].lower(). if 'wfnname' in largs:; wfnname = largs['wfnname']; else:; raise ValidationError('Call to \'%s\' has keyword \'wfnname\' missing.' % (functionname)). if re.match(r'scf_.*$', functionname) and (wfnname != 'scf'):; raise ValidationError('Call to \'%s\' is intended for scf portion of calculation.' % (functionname)); if re.match(r'corl_.*$', functionname) and (wfnname == 'scf'):; raise ValidationError('Call to \'%s\' is not intended for scf portion of calculation.' % (functionname)). if 'basisname' in largs:; BSET = largs['basisname']; else:; raise ValidationError('Call to \'%s\' has keyword \'basisname\' missing.' % (functionname)). if 'basiszeta' in largs:; ZSET = largs['basiszeta']; else:; raise ValidationError('Call to \'%s\' has keyword \'basiszeta\' missing.' % (functionname)). # Mode where function reads the now-filled-in energies from that same form and performs the sp, xtpl, delta, etc.; elif (largs['mode'].lower() == 'evaluate'):; mode = largs['mode'].lower(). if 'needname' in largs:; NEED = largs['needname']; else:; raise ValidationError('Call to \'%s\' has keyword \'needname\' missing.' % (functionname)). else:; raise ValidationError('Call to \'%s\' has keyword \'mode\' missing or invalid.' % (functionname)). return [mode, NEED, wfnname, BSET, ZSET]. [docs]def split_menial(menial):; r""""""Function used by :py:func:`~wrappers.complete_basis_set` to separate; *menial* 'scft",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:101253,Security,Validat,ValidationError,101253,"tion called by each extrapolation scheme in :py:func:`~wrappers.complete_basis_set`.; Checks that all the input arguments are present and suitable so that; the scheme function can focus on defining the extrapolation. """"""; mode = ''; NEED = []; wfnname = ''; BSET = []; ZSET = []. # Mode where function fills out a form NEED with the computations needed to fulfill its call; if (largs['mode'].lower() == 'requisition'):; mode = largs['mode'].lower(). if 'wfnname' in largs:; wfnname = largs['wfnname']; else:; raise ValidationError('Call to \'%s\' has keyword \'wfnname\' missing.' % (functionname)). if re.match(r'scf_.*$', functionname) and (wfnname != 'scf'):; raise ValidationError('Call to \'%s\' is intended for scf portion of calculation.' % (functionname)); if re.match(r'corl_.*$', functionname) and (wfnname == 'scf'):; raise ValidationError('Call to \'%s\' is not intended for scf portion of calculation.' % (functionname)). if 'basisname' in largs:; BSET = largs['basisname']; else:; raise ValidationError('Call to \'%s\' has keyword \'basisname\' missing.' % (functionname)). if 'basiszeta' in largs:; ZSET = largs['basiszeta']; else:; raise ValidationError('Call to \'%s\' has keyword \'basiszeta\' missing.' % (functionname)). # Mode where function reads the now-filled-in energies from that same form and performs the sp, xtpl, delta, etc.; elif (largs['mode'].lower() == 'evaluate'):; mode = largs['mode'].lower(). if 'needname' in largs:; NEED = largs['needname']; else:; raise ValidationError('Call to \'%s\' has keyword \'needname\' missing.' % (functionname)). else:; raise ValidationError('Call to \'%s\' has keyword \'mode\' missing or invalid.' % (functionname)). return [mode, NEED, wfnname, BSET, ZSET]. [docs]def split_menial(menial):; r""""""Function used by :py:func:`~wrappers.complete_basis_set` to separate; *menial* 'scftot' into [scf, tot] and 'mp2corl' into [mp2, corl]. """"""; PTYP = ['tot', 'corl']; for temp in PTYP:; if menial.endswith(temp):; temp_wfn = menial[:-len(",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:101406,Security,Validat,ValidationError,101406,"t; the scheme function can focus on defining the extrapolation. """"""; mode = ''; NEED = []; wfnname = ''; BSET = []; ZSET = []. # Mode where function fills out a form NEED with the computations needed to fulfill its call; if (largs['mode'].lower() == 'requisition'):; mode = largs['mode'].lower(). if 'wfnname' in largs:; wfnname = largs['wfnname']; else:; raise ValidationError('Call to \'%s\' has keyword \'wfnname\' missing.' % (functionname)). if re.match(r'scf_.*$', functionname) and (wfnname != 'scf'):; raise ValidationError('Call to \'%s\' is intended for scf portion of calculation.' % (functionname)); if re.match(r'corl_.*$', functionname) and (wfnname == 'scf'):; raise ValidationError('Call to \'%s\' is not intended for scf portion of calculation.' % (functionname)). if 'basisname' in largs:; BSET = largs['basisname']; else:; raise ValidationError('Call to \'%s\' has keyword \'basisname\' missing.' % (functionname)). if 'basiszeta' in largs:; ZSET = largs['basiszeta']; else:; raise ValidationError('Call to \'%s\' has keyword \'basiszeta\' missing.' % (functionname)). # Mode where function reads the now-filled-in energies from that same form and performs the sp, xtpl, delta, etc.; elif (largs['mode'].lower() == 'evaluate'):; mode = largs['mode'].lower(). if 'needname' in largs:; NEED = largs['needname']; else:; raise ValidationError('Call to \'%s\' has keyword \'needname\' missing.' % (functionname)). else:; raise ValidationError('Call to \'%s\' has keyword \'mode\' missing or invalid.' % (functionname)). return [mode, NEED, wfnname, BSET, ZSET]. [docs]def split_menial(menial):; r""""""Function used by :py:func:`~wrappers.complete_basis_set` to separate; *menial* 'scftot' into [scf, tot] and 'mp2corl' into [mp2, corl]. """"""; PTYP = ['tot', 'corl']; for temp in PTYP:; if menial.endswith(temp):; temp_wfn = menial[:-len(temp)]; temp_portion = temp. return [temp_wfn, temp_portion]. # Quickly normalize the types for both python 2 and 3; try:; unicode = unicode; except Name",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:101747,Security,Validat,ValidationError,101747,"ame']; else:; raise ValidationError('Call to \'%s\' has keyword \'wfnname\' missing.' % (functionname)). if re.match(r'scf_.*$', functionname) and (wfnname != 'scf'):; raise ValidationError('Call to \'%s\' is intended for scf portion of calculation.' % (functionname)); if re.match(r'corl_.*$', functionname) and (wfnname == 'scf'):; raise ValidationError('Call to \'%s\' is not intended for scf portion of calculation.' % (functionname)). if 'basisname' in largs:; BSET = largs['basisname']; else:; raise ValidationError('Call to \'%s\' has keyword \'basisname\' missing.' % (functionname)). if 'basiszeta' in largs:; ZSET = largs['basiszeta']; else:; raise ValidationError('Call to \'%s\' has keyword \'basiszeta\' missing.' % (functionname)). # Mode where function reads the now-filled-in energies from that same form and performs the sp, xtpl, delta, etc.; elif (largs['mode'].lower() == 'evaluate'):; mode = largs['mode'].lower(). if 'needname' in largs:; NEED = largs['needname']; else:; raise ValidationError('Call to \'%s\' has keyword \'needname\' missing.' % (functionname)). else:; raise ValidationError('Call to \'%s\' has keyword \'mode\' missing or invalid.' % (functionname)). return [mode, NEED, wfnname, BSET, ZSET]. [docs]def split_menial(menial):; r""""""Function used by :py:func:`~wrappers.complete_basis_set` to separate; *menial* 'scftot' into [scf, tot] and 'mp2corl' into [mp2, corl]. """"""; PTYP = ['tot', 'corl']; for temp in PTYP:; if menial.endswith(temp):; temp_wfn = menial[:-len(temp)]; temp_portion = temp. return [temp_wfn, temp_portion]. # Quickly normalize the types for both python 2 and 3; try:; unicode = unicode; except NameError:; # 'unicode' is undefined, must be Python 3; str = str; unicode = str; bytes = bytes; basestring = (str,bytes); else:; # 'unicode' exists, must be Python 2; str = str; unicode = unicode; bytes = str; basestring = basestring. ## Aliases ##; cbs = complete_basis_set. #################################; ## End of Complete Basis Set ##; ",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:101846,Security,Validat,ValidationError,101846," functionname) and (wfnname != 'scf'):; raise ValidationError('Call to \'%s\' is intended for scf portion of calculation.' % (functionname)); if re.match(r'corl_.*$', functionname) and (wfnname == 'scf'):; raise ValidationError('Call to \'%s\' is not intended for scf portion of calculation.' % (functionname)). if 'basisname' in largs:; BSET = largs['basisname']; else:; raise ValidationError('Call to \'%s\' has keyword \'basisname\' missing.' % (functionname)). if 'basiszeta' in largs:; ZSET = largs['basiszeta']; else:; raise ValidationError('Call to \'%s\' has keyword \'basiszeta\' missing.' % (functionname)). # Mode where function reads the now-filled-in energies from that same form and performs the sp, xtpl, delta, etc.; elif (largs['mode'].lower() == 'evaluate'):; mode = largs['mode'].lower(). if 'needname' in largs:; NEED = largs['needname']; else:; raise ValidationError('Call to \'%s\' has keyword \'needname\' missing.' % (functionname)). else:; raise ValidationError('Call to \'%s\' has keyword \'mode\' missing or invalid.' % (functionname)). return [mode, NEED, wfnname, BSET, ZSET]. [docs]def split_menial(menial):; r""""""Function used by :py:func:`~wrappers.complete_basis_set` to separate; *menial* 'scftot' into [scf, tot] and 'mp2corl' into [mp2, corl]. """"""; PTYP = ['tot', 'corl']; for temp in PTYP:; if menial.endswith(temp):; temp_wfn = menial[:-len(temp)]; temp_portion = temp. return [temp_wfn, temp_portion]. # Quickly normalize the types for both python 2 and 3; try:; unicode = unicode; except NameError:; # 'unicode' is undefined, must be Python 3; str = str; unicode = str; bytes = bytes; basestring = (str,bytes); else:; # 'unicode' exists, must be Python 2; str = str; unicode = unicode; bytes = str; basestring = basestring. ## Aliases ##; cbs = complete_basis_set. #################################; ## End of Complete Basis Set ##; #################################. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. m",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:17558,Testability,test,tested,17558,"DF_INTS_IO', ri_ints_io); psioh.set_specific_retention(97, False); psi4.clean(); activate(molecule). if bsse == 'on' or bsse == 'both':; return energies_n_full[Ns[0]]; else:; return energies_n_mon[Ns[0]]. ## Aliases ##; nbody = n_body. #####################; ## End of n_body ##; #####################. ###################; ## Start of cp ##; ###################. [docs]def cp(name, **kwargs):; r""""""The cp function computes counterpoise-corrected two-body interaction energies; for complexes composed of arbitrary numbers of monomers. :aliases: counterpoise_correct(), counterpoise_correction(). :returns: (*float*) Counterpoise-corrected interaction energy in Hartrees. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CP-CORRECTED 2-BODY INTERACTION ENERGY <CP-CORRECTED2-BODYINTERACTIONENERGY>`; * :psivar:`UNCP-CORRECTED 2-BODY INTERACTION ENERGY <UNCP-CORRECTED2-BODYINTERACTIONENERGY>`. .. caution:: Some features are not yet implemented. Buy a developer a coffee. - No values of func besides energy have been tested. - Table print-out needs improving. Add some PSI variables. :type name: string; :param name: ``'scf'`` || ``'ccsd(t)'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the molecule. May be any valid argument to; :py:func:`~driver.energy`; however, SAPT is not appropriate. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``energy`` |dr| || ``optimize`` || ``cbs``. Indicates the type of calculation to be performed on the molecule; and each of its monomers. The default performs a single-point; ``energy('name')``, while ``optimize`` perfoms a geometry optimization; on each system, and ``cbs`` performs a compound single-point energy.; If a nested series of python functions is intended; (see :ref:`sec:intercalls`), use keyword ``cp_func`` instead of ``func``. :type check_bsse: :ref:`boolean <op_py_boolean>`; :param check_bsse: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether to additionally compute un-",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:27183,Testability,benchmark,benchmark,27183," bimolecular complexes. :type rlxd: :ref:`boolean <op_py_boolean>`; :param rlxd: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether correction for deformation energy is; employed in computing interaction energies. Option available; (See :ref:`sec:availableDatabases`) only for databases of bimolecular complexes; with non-frozen monomers, e.g., HBC6. :type symm: :ref:`boolean <op_py_boolean>`; :param symm: |dl| ``'on'`` |dr| || ``'off'``. Indicates whether the native symmetry of the database reagents is; employed (``'on'``) or whether it is forced to :math:`C_1` symmetry; (``'off'``). Some computational methods (e.g., SAPT) require no; symmetry, and this will be set by database(). :type zpe: :ref:`boolean <op_py_boolean>`; :param zpe: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether zero-point-energy corrections are appended to; single-point energy values. Option valid only for certain; thermochemical databases. Disabled until Hessians ready. :type benchmark: string; :param benchmark: |dl| ``'default'`` |dr| || ``'S22A'`` || etc. Indicates whether a non-default set of reference energies, if; available (See :ref:`sec:availableDatabases`), are employed for the; calculation of error statistics. :type tabulate: array of strings; :param tabulate: |dl| ``[]`` |dr| || ``['scf total energy', 'natom']`` || etc. Indicates whether to form tables of variables other than the; primary requested energy. Available for any PSI variable. :type subset: string or array of strings; :param subset:. Indicates a subset of the full database to run. This is a very; flexible option and can be used in three distinct ways, outlined; below. Note that two take a string and the last takes an array.; See `Available Databases`_ for available values. * ``'small'`` || ``'large'`` || ``'equilibrium'``; Calls predefined subsets of the requested database, either; ``'small'``, a few of the smallest database members,; ``'large'``, the largest of the database members, or; ``'equilibrium'``, the equilibrium g",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:27209,Testability,benchmark,benchmark,27209," bimolecular complexes. :type rlxd: :ref:`boolean <op_py_boolean>`; :param rlxd: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether correction for deformation energy is; employed in computing interaction energies. Option available; (See :ref:`sec:availableDatabases`) only for databases of bimolecular complexes; with non-frozen monomers, e.g., HBC6. :type symm: :ref:`boolean <op_py_boolean>`; :param symm: |dl| ``'on'`` |dr| || ``'off'``. Indicates whether the native symmetry of the database reagents is; employed (``'on'``) or whether it is forced to :math:`C_1` symmetry; (``'off'``). Some computational methods (e.g., SAPT) require no; symmetry, and this will be set by database(). :type zpe: :ref:`boolean <op_py_boolean>`; :param zpe: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether zero-point-energy corrections are appended to; single-point energy values. Option valid only for certain; thermochemical databases. Disabled until Hessians ready. :type benchmark: string; :param benchmark: |dl| ``'default'`` |dr| || ``'S22A'`` || etc. Indicates whether a non-default set of reference energies, if; available (See :ref:`sec:availableDatabases`), are employed for the; calculation of error statistics. :type tabulate: array of strings; :param tabulate: |dl| ``[]`` |dr| || ``['scf total energy', 'natom']`` || etc. Indicates whether to form tables of variables other than the; primary requested energy. Available for any PSI variable. :type subset: string or array of strings; :param subset:. Indicates a subset of the full database to run. This is a very; flexible option and can be used in three distinct ways, outlined; below. Note that two take a string and the last takes an array.; See `Available Databases`_ for available values. * ``'small'`` || ``'large'`` || ``'equilibrium'``; Calls predefined subsets of the requested database, either; ``'small'``, a few of the smallest database members,; ``'large'``, the largest of the database members, or; ``'equilibrium'``, the equilibrium g",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:29233,Testability,benchmark,benchmark,29233,"librium geometries for a database; composed of dissociation curves.; * ``'BzBz_S'`` || ``'FaOOFaON'`` || ``'ArNe'`` || ``'HB'`` || etc.; For databases composed of dissociation curves, or otherwise; divided into subsets, individual curves and subsets can be; called by name. Consult the database python files for available; molecular systems (case insensitive).; * ``[1,2,5]`` || ``['1','2','5']`` || ``['BzMe-3.5', 'MeMe-5.0']`` || etc.; Specify a list of database members to run. Consult the; database python files for available molecular systems. This; is the only portion of database input that is case sensitive;; choices for this keyword must match the database python file. :examples:. >>> # [1] Two-stage SCF calculation on short, equilibrium, and long helium dimer; >>> db('scf','RGC10',cast_up='sto-3g',subset=['HeHe-0.85','HeHe-1.0','HeHe-1.5'], tabulate=['scf total energy','natom']). >>> # [2] Counterpoise-corrected interaction energies for three complexes in S22; >>> # Error statistics computed wrt an old benchmark, S22A; >>> database('df-mp2','S22',cp=1,subset=[16,17,8],benchmark='S22A'). >>> # [3] SAPT0 on the neon dimer dissociation curve; >>> db('sapt0',subset='NeNe',cp=0,symm=0,db_name='RGC10'). >>> # [4] Optimize system 1 in database S22, producing tables of scf and mp2 energy; >>> db('mp2','S22',db_func=optimize,subset=[1], tabulate=['mp2 total energy','current energy']). >>> # [5] CCSD on the smallest systems of HTBH, a hydrogen-transfer database; >>> database('ccsd','HTBH',subset='small', tabulate=['ccsd total energy', 'mp2 total energy']). """"""; lowername = name.lower(); kwargs = p4util.kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name.lower(); if not('db_name' in kwargs) and db_name:; kwargs['db_name'] = db_name. # Establish function to call; if not('db_func' in kwargs):; if ('func' in kwargs):; kwargs['db_func'] = kwargs['func']; del kwargs['func']; e",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:29300,Testability,benchmark,benchmark,29300,"librium geometries for a database; composed of dissociation curves.; * ``'BzBz_S'`` || ``'FaOOFaON'`` || ``'ArNe'`` || ``'HB'`` || etc.; For databases composed of dissociation curves, or otherwise; divided into subsets, individual curves and subsets can be; called by name. Consult the database python files for available; molecular systems (case insensitive).; * ``[1,2,5]`` || ``['1','2','5']`` || ``['BzMe-3.5', 'MeMe-5.0']`` || etc.; Specify a list of database members to run. Consult the; database python files for available molecular systems. This; is the only portion of database input that is case sensitive;; choices for this keyword must match the database python file. :examples:. >>> # [1] Two-stage SCF calculation on short, equilibrium, and long helium dimer; >>> db('scf','RGC10',cast_up='sto-3g',subset=['HeHe-0.85','HeHe-1.0','HeHe-1.5'], tabulate=['scf total energy','natom']). >>> # [2] Counterpoise-corrected interaction energies for three complexes in S22; >>> # Error statistics computed wrt an old benchmark, S22A; >>> database('df-mp2','S22',cp=1,subset=[16,17,8],benchmark='S22A'). >>> # [3] SAPT0 on the neon dimer dissociation curve; >>> db('sapt0',subset='NeNe',cp=0,symm=0,db_name='RGC10'). >>> # [4] Optimize system 1 in database S22, producing tables of scf and mp2 energy; >>> db('mp2','S22',db_func=optimize,subset=[1], tabulate=['mp2 total energy','current energy']). >>> # [5] CCSD on the smallest systems of HTBH, a hydrogen-transfer database; >>> database('ccsd','HTBH',subset='small', tabulate=['ccsd total energy', 'mp2 total energy']). """"""; lowername = name.lower(); kwargs = p4util.kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name.lower(); if not('db_name' in kwargs) and db_name:; kwargs['db_name'] = db_name. # Establish function to call; if not('db_func' in kwargs):; if ('func' in kwargs):; kwargs['db_func'] = kwargs['func']; del kwargs['func']; e",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:35374,Testability,benchmark,benchmark,35374,"buteError:; raise ValidationError('Deformation and counterpoise correction mode \'yes\' invalid for database %s.' % (db_name)); else:; ACTV = database.ACTV_CPRLX; RXNM = database.RXNM_CPRLX; elif no.match(str(db_cp)):; try:; database.ACTV_RLX; except AttributeError:; raise ValidationError('Deformation correction mode \'yes\' invalid for database %s.' % (db_name)); else:; ACTV = database.ACTV_RLX; elif no.match(str(db_rlxd)):; pass; else:; raise ValidationError('Deformation correction mode \'%s\' not valid.' % (db_rlxd)). # Option zero-point-correction- whether for thermochem databases jobs are corrected by zpe; db_zpe = 'no'; if 'zpe' in kwargs:; db_zpe = kwargs['zpe']. if yes.match(str(db_zpe)):; raise ValidationError('Zero-point-correction mode \'yes\' not yet implemented.'); elif no.match(str(db_zpe)):; pass; else:; raise ValidationError('Zero-point-correction \'mode\' %s not valid.' % (db_zpe)). # Option benchmark- whether error statistics computed wrt alternate reference energies; db_benchmark = 'default'; if 'benchmark' in kwargs:; db_benchmark = kwargs['benchmark']. if (db_benchmark.lower() == 'default'):; pass; else:; BIND = p4util.getattr_ignorecase(database, 'BIND_' + db_benchmark); if BIND is None:; raise ValidationError('Special benchmark \'%s\' not available for database %s.' % (db_benchmark, db_name)). # Option tabulate- whether tables of variables other than primary energy method are formed; db_tabulate = []; if 'tabulate' in kwargs:; db_tabulate = kwargs['tabulate']. # Option subset- whether all of the database or just a portion is run; db_subset = HRXN; if 'subset' in kwargs:; db_subset = kwargs['subset']. if isinstance(db_subset, basestring):; if (db_subset.lower() == 'small'):; try:; database.HRXN_SM; except AttributeError:; raise ValidationError('Special subset \'small\' not available for database %s.' % (db_name)); else:; HRXN = database.HRXN_SM; elif (db_subset.lower() == 'large'):; try:; database.HRXN_LG; except AttributeError:; raise Validatio",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:35483,Testability,benchmark,benchmark,35483,"buteError:; raise ValidationError('Deformation and counterpoise correction mode \'yes\' invalid for database %s.' % (db_name)); else:; ACTV = database.ACTV_CPRLX; RXNM = database.RXNM_CPRLX; elif no.match(str(db_cp)):; try:; database.ACTV_RLX; except AttributeError:; raise ValidationError('Deformation correction mode \'yes\' invalid for database %s.' % (db_name)); else:; ACTV = database.ACTV_RLX; elif no.match(str(db_rlxd)):; pass; else:; raise ValidationError('Deformation correction mode \'%s\' not valid.' % (db_rlxd)). # Option zero-point-correction- whether for thermochem databases jobs are corrected by zpe; db_zpe = 'no'; if 'zpe' in kwargs:; db_zpe = kwargs['zpe']. if yes.match(str(db_zpe)):; raise ValidationError('Zero-point-correction mode \'yes\' not yet implemented.'); elif no.match(str(db_zpe)):; pass; else:; raise ValidationError('Zero-point-correction \'mode\' %s not valid.' % (db_zpe)). # Option benchmark- whether error statistics computed wrt alternate reference energies; db_benchmark = 'default'; if 'benchmark' in kwargs:; db_benchmark = kwargs['benchmark']. if (db_benchmark.lower() == 'default'):; pass; else:; BIND = p4util.getattr_ignorecase(database, 'BIND_' + db_benchmark); if BIND is None:; raise ValidationError('Special benchmark \'%s\' not available for database %s.' % (db_benchmark, db_name)). # Option tabulate- whether tables of variables other than primary energy method are formed; db_tabulate = []; if 'tabulate' in kwargs:; db_tabulate = kwargs['tabulate']. # Option subset- whether all of the database or just a portion is run; db_subset = HRXN; if 'subset' in kwargs:; db_subset = kwargs['subset']. if isinstance(db_subset, basestring):; if (db_subset.lower() == 'small'):; try:; database.HRXN_SM; except AttributeError:; raise ValidationError('Special subset \'small\' not available for database %s.' % (db_name)); else:; HRXN = database.HRXN_SM; elif (db_subset.lower() == 'large'):; try:; database.HRXN_LG; except AttributeError:; raise Validatio",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:35529,Testability,benchmark,benchmark,35529,"buteError:; raise ValidationError('Deformation and counterpoise correction mode \'yes\' invalid for database %s.' % (db_name)); else:; ACTV = database.ACTV_CPRLX; RXNM = database.RXNM_CPRLX; elif no.match(str(db_cp)):; try:; database.ACTV_RLX; except AttributeError:; raise ValidationError('Deformation correction mode \'yes\' invalid for database %s.' % (db_name)); else:; ACTV = database.ACTV_RLX; elif no.match(str(db_rlxd)):; pass; else:; raise ValidationError('Deformation correction mode \'%s\' not valid.' % (db_rlxd)). # Option zero-point-correction- whether for thermochem databases jobs are corrected by zpe; db_zpe = 'no'; if 'zpe' in kwargs:; db_zpe = kwargs['zpe']. if yes.match(str(db_zpe)):; raise ValidationError('Zero-point-correction mode \'yes\' not yet implemented.'); elif no.match(str(db_zpe)):; pass; else:; raise ValidationError('Zero-point-correction \'mode\' %s not valid.' % (db_zpe)). # Option benchmark- whether error statistics computed wrt alternate reference energies; db_benchmark = 'default'; if 'benchmark' in kwargs:; db_benchmark = kwargs['benchmark']. if (db_benchmark.lower() == 'default'):; pass; else:; BIND = p4util.getattr_ignorecase(database, 'BIND_' + db_benchmark); if BIND is None:; raise ValidationError('Special benchmark \'%s\' not available for database %s.' % (db_benchmark, db_name)). # Option tabulate- whether tables of variables other than primary energy method are formed; db_tabulate = []; if 'tabulate' in kwargs:; db_tabulate = kwargs['tabulate']. # Option subset- whether all of the database or just a portion is run; db_subset = HRXN; if 'subset' in kwargs:; db_subset = kwargs['subset']. if isinstance(db_subset, basestring):; if (db_subset.lower() == 'small'):; try:; database.HRXN_SM; except AttributeError:; raise ValidationError('Special subset \'small\' not available for database %s.' % (db_name)); else:; HRXN = database.HRXN_SM; elif (db_subset.lower() == 'large'):; try:; database.HRXN_LG; except AttributeError:; raise Validatio",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:35713,Testability,benchmark,benchmark,35713,".ACTV_RLX; except AttributeError:; raise ValidationError('Deformation correction mode \'yes\' invalid for database %s.' % (db_name)); else:; ACTV = database.ACTV_RLX; elif no.match(str(db_rlxd)):; pass; else:; raise ValidationError('Deformation correction mode \'%s\' not valid.' % (db_rlxd)). # Option zero-point-correction- whether for thermochem databases jobs are corrected by zpe; db_zpe = 'no'; if 'zpe' in kwargs:; db_zpe = kwargs['zpe']. if yes.match(str(db_zpe)):; raise ValidationError('Zero-point-correction mode \'yes\' not yet implemented.'); elif no.match(str(db_zpe)):; pass; else:; raise ValidationError('Zero-point-correction \'mode\' %s not valid.' % (db_zpe)). # Option benchmark- whether error statistics computed wrt alternate reference energies; db_benchmark = 'default'; if 'benchmark' in kwargs:; db_benchmark = kwargs['benchmark']. if (db_benchmark.lower() == 'default'):; pass; else:; BIND = p4util.getattr_ignorecase(database, 'BIND_' + db_benchmark); if BIND is None:; raise ValidationError('Special benchmark \'%s\' not available for database %s.' % (db_benchmark, db_name)). # Option tabulate- whether tables of variables other than primary energy method are formed; db_tabulate = []; if 'tabulate' in kwargs:; db_tabulate = kwargs['tabulate']. # Option subset- whether all of the database or just a portion is run; db_subset = HRXN; if 'subset' in kwargs:; db_subset = kwargs['subset']. if isinstance(db_subset, basestring):; if (db_subset.lower() == 'small'):; try:; database.HRXN_SM; except AttributeError:; raise ValidationError('Special subset \'small\' not available for database %s.' % (db_name)); else:; HRXN = database.HRXN_SM; elif (db_subset.lower() == 'large'):; try:; database.HRXN_LG; except AttributeError:; raise ValidationError('Special subset \'large\' not available for database %s.' % (db_name)); else:; HRXN = database.HRXN_LG; elif (db_subset.lower() == 'equilibrium'):; try:; database.HRXN_EQ; except AttributeError:; raise ValidationError('Specia",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:40018,Testability,benchmark,benchmark,40018,"tput file names must be as given below.\n\n""""""; for rgt in HSYS:; instructions += """""" psi4 -i %-27s -o %-27s\n"""""" % (rgt + '.in', rgt + '.out'); instructions += """"""\n (2) Gather all the resulting output files in a directory. Place input file\n""""""; instructions += """""" %s-master.in into that directory and run it. The job will be trivial in\n"""""" % (dbse); instructions += """""" length and give summary results for the database in its output file.\n\n""""""; instructions += """""" psi4 -i %-27s -o %-27s\n\n"""""" % (dbse + '-master.in', dbse + '-master.out'); instructions += """""" Alternatively, a single-job execution of the database may be accessed through\n""""""; instructions += """""" the database wrapper option mode='continuous'.\n\n""""""; psi4.print_out(instructions). fmaster = open('%s-master.in' % (dbse), 'w'); fmaster.write('# This is a psi4 input file auto-generated from the database() wrapper.\n\n'); fmaster.write(""database('%s', '%s', mode='reap', cp='%s', rlxd='%s', zpe='%s', benchmark='%s', linkage=%d, subset=%s, tabulate=%s)\n\n"" %; (name, db_name, db_cp, db_rlxd, db_zpe, db_benchmark, os.getpid(), HRXN, db_tabulate)); fmaster.close(). # Loop through chemical systems; ERGT = {}; ERXN = {}; VRGT = {}; VRXN = {}; for rgt in HSYS:; VRGT[rgt] = {}. # extra definition of molecule so that logic in building commands string has something to act on; exec(p4util.format_molecule_for_input(GEOS[rgt])); molecule = psi4.get_active_molecule(). # build string of title banner; banners = ''; banners += """"""psi4.print_out('\\n')\n""""""; banners += """"""p4util.banner(' Database %s Computation: Reagent %s \\n %s')\n"""""" % (db_name, rgt, TAGL[rgt]); banners += """"""psi4.print_out('\\n')\n\n"""""". # build string of lines that defines contribution of rgt to each rxn; actives = ''; actives += """"""psi4.print_out(' Database Contributions Map:\\n %s\\n')\n"""""" % ('-' * 75); for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn); if rgt in ACTV[db_rxn]:; actives += """"""psi4.print_out(' reagent %s contributes by %.4f to react",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:40333,Testability,log,logic,40333,"n it. The job will be trivial in\n"""""" % (dbse); instructions += """""" length and give summary results for the database in its output file.\n\n""""""; instructions += """""" psi4 -i %-27s -o %-27s\n\n"""""" % (dbse + '-master.in', dbse + '-master.out'); instructions += """""" Alternatively, a single-job execution of the database may be accessed through\n""""""; instructions += """""" the database wrapper option mode='continuous'.\n\n""""""; psi4.print_out(instructions). fmaster = open('%s-master.in' % (dbse), 'w'); fmaster.write('# This is a psi4 input file auto-generated from the database() wrapper.\n\n'); fmaster.write(""database('%s', '%s', mode='reap', cp='%s', rlxd='%s', zpe='%s', benchmark='%s', linkage=%d, subset=%s, tabulate=%s)\n\n"" %; (name, db_name, db_cp, db_rlxd, db_zpe, db_benchmark, os.getpid(), HRXN, db_tabulate)); fmaster.close(). # Loop through chemical systems; ERGT = {}; ERXN = {}; VRGT = {}; VRXN = {}; for rgt in HSYS:; VRGT[rgt] = {}. # extra definition of molecule so that logic in building commands string has something to act on; exec(p4util.format_molecule_for_input(GEOS[rgt])); molecule = psi4.get_active_molecule(). # build string of title banner; banners = ''; banners += """"""psi4.print_out('\\n')\n""""""; banners += """"""p4util.banner(' Database %s Computation: Reagent %s \\n %s')\n"""""" % (db_name, rgt, TAGL[rgt]); banners += """"""psi4.print_out('\\n')\n\n"""""". # build string of lines that defines contribution of rgt to each rxn; actives = ''; actives += """"""psi4.print_out(' Database Contributions Map:\\n %s\\n')\n"""""" % ('-' * 75); for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn); if rgt in ACTV[db_rxn]:; actives += """"""psi4.print_out(' reagent %s contributes by %.4f to reaction %s\\n')\n"""""" \; % (rgt, RXNM[db_rxn][rgt], db_rxn); actives += """"""psi4.print_out('\\n')\n\n"""""". # build string of commands for options from the input file TODO: handle local options too; commands = ''; commands += """"""\npsi4.set_memory(%s)\n\n"""""" % (user_memory); for chgdopt in psi4.get_global_option_lis",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:93640,Testability,log,logs,93640,"= BSET[1][indx]):; zetaindx = indx; indx += 1; for basis in BSET:; ZSET[ZETA[basis[zetaindx]] - 2] = basis[zetaindx]. pre = BSET[0][:zetaindx]; post = BSET[0][zetaindx + 1:]; basisstring = pre + '[' + ''.join(ZSET) + ']' + post. return basisstring. [docs]def highest_1(**largs):; r""""""Scheme for total or correlation energies with a single basis or the highest; zeta-level among an array of bases. Used by :py:func:`~wrappers.complete_basis_set`. .. math:: E_{total}^X = E_{total}^X. """"""; energypiece = 0.0; functionname = sys._getframe().f_code.co_name; f_fields = ['f_wfn', 'f_portion', 'f_basis', 'f_zeta', 'f_energy']; [mode, NEED, wfnname, BSET, ZSET] = validate_scheme_args(functionname, **largs). if (mode == 'requisition'):. # Impose restrictions on zeta sequence; if (len(ZSET) == 0):; raise ValidationError('Call to \'%s\' not valid with \'%s\' basis sets.' % (functionname, len(ZSET))). # Return array that logs the requisite jobs; if (wfnname == 'scf'):; portion = 'tot'; else:; portion = 'corl'; NEED = {'HI': dict(zip(f_fields, [wfnname, portion, BSET[len(ZSET) - 1], ZSET[len(ZSET) - 1], 0.0]))}. return NEED. elif (mode == 'evaluate'):. # Extract required energies and zeta integers from array; # Compute extrapolated energy; energypiece = NEED['HI']['f_energy']. # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += """"""\n ==> %s <==\n\n"""""" % (functionname); if (NEED['HI']['f_wfn'] == 'scf'):; cbsscheme += """""" HI-zeta (%s) Total Energy: %16.8f\n"""""" % (str(NEED['HI']['f_zeta']), energypiece); else:; cbsscheme += """""" HI-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(NEED['HI']['f_zeta']), energypiece); psi4.print_out(cbsscheme). return energypiece. # Solution equation in LaTeX: $E_{corl}^{\infty} = \frac{E_{corl}^{X} X^3 - E_{corl}^{X-1} (X-1)^3}{X^3 - (X-1)^3}$; # Solution equation in LaTeX: $\beta = \frac{E_{corl}^{X} - E_{corl}^{X-1}}{X^{-3} - (X-1)^{-3}}$; [docs]def corl_xtpl_helgaker_2(**largs):; r""""""Extrapolation scheme for correlation energies",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:95301,Testability,log,logs,95301,"HI']['f_zeta']), energypiece); psi4.print_out(cbsscheme). return energypiece. # Solution equation in LaTeX: $E_{corl}^{\infty} = \frac{E_{corl}^{X} X^3 - E_{corl}^{X-1} (X-1)^3}{X^3 - (X-1)^3}$; # Solution equation in LaTeX: $\beta = \frac{E_{corl}^{X} - E_{corl}^{X-1}}{X^{-3} - (X-1)^{-3}}$; [docs]def corl_xtpl_helgaker_2(**largs):; r""""""Extrapolation scheme for correlation energies with two adjacent zeta-level bases.; Used by :py:func:`~wrappers.complete_basis_set`. .. math:: E_{corl}^X = E_{corl}^{\infty} + \beta X^{-3}. """"""; energypiece = 0.0; functionname = sys._getframe().f_code.co_name; f_fields = ['f_wfn', 'f_portion', 'f_basis', 'f_zeta', 'f_energy']; [mode, NEED, wfnname, BSET, ZSET] = validate_scheme_args(functionname, **largs). if (mode == 'requisition'):. # Impose restrictions on zeta sequence; if (len(ZSET) != 2):; raise ValidationError('Call to \'%s\' not valid with \'%s\' basis sets.' % (functionname, len(ZSET))). # Return array that logs the requisite jobs; NEED = {'HI': dict(zip(f_fields, [wfnname, 'corl', BSET[1], ZSET[1], 0.0])),; 'LO': dict(zip(f_fields, [wfnname, 'corl', BSET[0], ZSET[0], 0.0]))}. return NEED. elif (mode == 'evaluate'):. # Extract required energies and zeta integers from array; eHI = NEED['HI']['f_energy']; zHI = NEED['HI']['f_zeta']; eLO = NEED['LO']['f_energy']; zLO = NEED['LO']['f_zeta']. # Compute extrapolated energy; energypiece = (eHI * zHI ** 3 - eLO * zLO ** 3) / (zHI ** 3 - zLO ** 3); beta = (eHI - eLO) / (zHI ** (-3) - zLO ** (-3)). # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += """"""\n ==> %s <==\n\n"""""" % (functionname); cbsscheme += """""" LO-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zLO), eLO); cbsscheme += """""" HI-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zHI), eHI); cbsscheme += """""" Extrapolated Correlation Energy: %16.8f\n"""""" % (energypiece); cbsscheme += """""" Beta (coefficient) Value: %16.8f\n"""""" % (beta); psi4.print_out(cbsscheme). return energypiece. [docs]def scf_xtpl_helgak",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:96991,Testability,log,logs,96991,"r(zLO), eLO); cbsscheme += """""" HI-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zHI), eHI); cbsscheme += """""" Extrapolated Correlation Energy: %16.8f\n"""""" % (energypiece); cbsscheme += """""" Beta (coefficient) Value: %16.8f\n"""""" % (beta); psi4.print_out(cbsscheme). return energypiece. [docs]def scf_xtpl_helgaker_3(**largs):; r""""""Extrapolation scheme for reference energies with three adjacent zeta-level bases.; Used by :py:func:`~wrappers.complete_basis_set`. .. math:: E_{total}^X = E_{total}^{\infty} + \beta e^{-\alpha X}. """"""; energypiece = 0.0; functionname = sys._getframe().f_code.co_name; f_fields = ['f_wfn', 'f_portion', 'f_basis', 'f_zeta', 'f_energy']; [mode, NEED, wfnname, BSET, ZSET] = validate_scheme_args(functionname, **largs). if (mode == 'requisition'):. # Impose restrictions on zeta sequence; if (len(ZSET) != 3):; raise ValidationError('Call to \'%s\' not valid with \'%s\' basis sets.' % (functionname, len(ZSET))). # Return array that logs the requisite jobs; NEED = {'HI': dict(zip(f_fields, [wfnname, 'tot', BSET[2], ZSET[2], 0.0])),; 'MD': dict(zip(f_fields, [wfnname, 'tot', BSET[1], ZSET[1], 0.0])),; 'LO': dict(zip(f_fields, [wfnname, 'tot', BSET[0], ZSET[0], 0.0]))}. return NEED. elif (mode == 'evaluate'):. # Extract required energies and zeta integers from array; eHI = NEED['HI']['f_energy']; eMD = NEED['MD']['f_energy']; eLO = NEED['LO']['f_energy']; zHI = NEED['HI']['f_zeta']; zMD = NEED['MD']['f_zeta']; zLO = NEED['LO']['f_zeta']. # Compute extrapolated energy; ratio = (eHI - eMD) / (eMD - eLO); alpha = -1 * math.log(ratio); beta = (eHI - eMD) / (math.exp(-1 * alpha * zMD) * (ratio - 1)); energypiece = eHI - beta * math.exp(-1 * alpha * zHI). # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += """"""\n ==> %s <==\n\n"""""" % (functionname); cbsscheme += """""" LO-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zLO), eLO); cbsscheme += """""" MD-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zMD), eMD); cbsscheme += """""" HI-zeta (%s",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:97588,Testability,log,log,97588,"me().f_code.co_name; f_fields = ['f_wfn', 'f_portion', 'f_basis', 'f_zeta', 'f_energy']; [mode, NEED, wfnname, BSET, ZSET] = validate_scheme_args(functionname, **largs). if (mode == 'requisition'):. # Impose restrictions on zeta sequence; if (len(ZSET) != 3):; raise ValidationError('Call to \'%s\' not valid with \'%s\' basis sets.' % (functionname, len(ZSET))). # Return array that logs the requisite jobs; NEED = {'HI': dict(zip(f_fields, [wfnname, 'tot', BSET[2], ZSET[2], 0.0])),; 'MD': dict(zip(f_fields, [wfnname, 'tot', BSET[1], ZSET[1], 0.0])),; 'LO': dict(zip(f_fields, [wfnname, 'tot', BSET[0], ZSET[0], 0.0]))}. return NEED. elif (mode == 'evaluate'):. # Extract required energies and zeta integers from array; eHI = NEED['HI']['f_energy']; eMD = NEED['MD']['f_energy']; eLO = NEED['LO']['f_energy']; zHI = NEED['HI']['f_zeta']; zMD = NEED['MD']['f_zeta']; zLO = NEED['LO']['f_zeta']. # Compute extrapolated energy; ratio = (eHI - eMD) / (eMD - eLO); alpha = -1 * math.log(ratio); beta = (eHI - eMD) / (math.exp(-1 * alpha * zMD) * (ratio - 1)); energypiece = eHI - beta * math.exp(-1 * alpha * zHI). # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += """"""\n ==> %s <==\n\n"""""" % (functionname); cbsscheme += """""" LO-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zLO), eLO); cbsscheme += """""" MD-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zMD), eMD); cbsscheme += """""" HI-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zHI), eHI); cbsscheme += """""" Extrapolated Correlation Energy: %16.8f\n"""""" % (energypiece); cbsscheme += """""" Alpha (exponent) Value: %16.8f\n"""""" % (alpha); cbsscheme += """""" Beta (coefficient) Value: %16.8f\n"""""" % (beta); psi4.print_out(cbsscheme). return energypiece. [docs]def scf_xtpl_helgaker_2(**largs):; r""""""Extrapolation scheme for reference energies with two adjacent zeta-level bases.; Used by :py:func:`~wrappers.complete_basis_set`. .. math:: E_{total}^X = E_{total}^{\infty} + \beta e^{-\alpha X}, \alpha = 1.63. """"""; energypiece",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:99026,Testability,log,logs,99026," (str(zHI), eHI); cbsscheme += """""" Extrapolated Correlation Energy: %16.8f\n"""""" % (energypiece); cbsscheme += """""" Alpha (exponent) Value: %16.8f\n"""""" % (alpha); cbsscheme += """""" Beta (coefficient) Value: %16.8f\n"""""" % (beta); psi4.print_out(cbsscheme). return energypiece. [docs]def scf_xtpl_helgaker_2(**largs):; r""""""Extrapolation scheme for reference energies with two adjacent zeta-level bases.; Used by :py:func:`~wrappers.complete_basis_set`. .. math:: E_{total}^X = E_{total}^{\infty} + \beta e^{-\alpha X}, \alpha = 1.63. """"""; energypiece = 0.0; functionname = sys._getframe().f_code.co_name; f_fields = ['f_wfn', 'f_portion', 'f_basis', 'f_zeta', 'f_energy']; [mode, NEED, wfnname, BSET, ZSET] = validate_scheme_args(functionname, **largs). if (mode == 'requisition'):. # Impose restrictions on zeta sequence; if (len(ZSET) != 2):; raise ValidationError('Call to \'%s\' not valid with \'%s\' basis sets.' % (functionname, len(ZSET))). # Return array that logs the requisite jobs; NEED = {'HI': dict(zip(f_fields, [wfnname, 'tot', BSET[1], ZSET[1], 0.0])),; 'LO': dict(zip(f_fields, [wfnname, 'tot', BSET[0], ZSET[0], 0.0]))}. return NEED. elif (mode == 'evaluate'):. # Extract required energies and zeta integers from array; eHI = NEED['HI']['f_energy']; eLO = NEED['LO']['f_energy']; zHI = NEED['HI']['f_zeta']; zLO = NEED['LO']['f_zeta']. # LAB TODO add ability to pass alternate parameter values in. # Return extrapolated energy; alpha = 1.63; beta = (eHI - eLO) / (math.exp(-1 * alpha * zLO) * (math.exp(-1 * alpha) - 1)); energypiece = eHI - beta * math.exp(-1 * alpha * zHI). # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += """"""\n ==> %s <==\n\n"""""" % (functionname); cbsscheme += """""" LO-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zLO), eLO); cbsscheme += """""" HI-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zHI), eHI); cbsscheme += """""" Extrapolated Correlation Energy: %16.8f\n"""""" % (energypiece); cbsscheme += """""" Alpha (exponent) Value: %16.8f\n""""",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:51478,Usability,clear,clear,51478,"ror); tables += """"""%23s %19s %8.4f\n"""""" % ('Maximal Dev', '', maxDerror); tables += """"""%23s %19s %8.4f\n"""""" % ('Mean Signed Dev', '', MSDerror); tables += """"""%23s %19s %8.4f\n"""""" % ('Mean Absolute Dev', '', MADerror); tables += """"""%23s %19s %8.4f\n"""""" % ('RMS Dev', '', RMSDerror); tables += """""" %s\n"""""" % (table_delimit). psi4.set_variable('%s DATABASE MEAN SIGNED DEVIATION' % (db_name), MSDerror); psi4.set_variable('%s DATABASE MEAN ABSOLUTE DEVIATION' % (db_name), MADerror); psi4.set_variable('%s DATABASE ROOT-MEAN-SQUARE DEVIATION' % (db_name), RMSDerror). #print tables; psi4.print_out(tables); finalenergy = MADerror. else:; finalenergy = 0.0. # restore molecule and options; activate(user_molecule); user_molecule.update_geometry(); psi4.set_global_option(""BASIS"", user_basis); psi4.set_global_option(""REFERENCE"", user_reference); if not b_user_reference:; psi4.revoke_global_option_changed('REFERENCE'); psi4.set_global_option('WRITER_FILE_LABEL', user_writer_file_label). DB_RGT.clear(); DB_RGT.update(VRGT); DB_RXN.clear(); DB_RXN.update(VRXN); return finalenergy. [docs]def tblhead(tbl_maxrgt, tbl_delimit, ttype):; r""""""Function that prints the header for the changable-width results tables in db().; *tbl_maxrgt* is the number of reagent columns the table must plan for. *tbl_delimit*; is a string of dashes of the correct length to set off the table. *ttype* is 1 for; tables comparing the computed values to the reference or 2 for simple tabulation; and sum of the computed values. """"""; tbl_str = ''; tbl_str += """""" %s"""""" % (tbl_delimit); if ttype == 1:; tbl_str += """"""\n%23s %19s %8s"""""" % ('Reaction', 'Reaction Energy', 'Error'); elif ttype == 2:; tbl_str += """"""\n%23s %19s %6s"""""" % ('Reaction', 'Reaction Value', ''); for i in range(tbl_maxrgt):; tbl_str += """"""%20s"""""" % ('Reagent ' + str(i + 1)); if ttype == 1:; tbl_str += """"""\n%23s %8s %8s %8s"""""" % ('', 'Ref', 'Calc', '[kcal/mol]'); elif ttype == 2:; tbl_str += """"""\n%54s"""""" % (''); for i in range(tbl_maxrgt):; if ttype == 1",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:51515,Usability,clear,clear,51515,""""" % ('Maximal Dev', '', maxDerror); tables += """"""%23s %19s %8.4f\n"""""" % ('Mean Signed Dev', '', MSDerror); tables += """"""%23s %19s %8.4f\n"""""" % ('Mean Absolute Dev', '', MADerror); tables += """"""%23s %19s %8.4f\n"""""" % ('RMS Dev', '', RMSDerror); tables += """""" %s\n"""""" % (table_delimit). psi4.set_variable('%s DATABASE MEAN SIGNED DEVIATION' % (db_name), MSDerror); psi4.set_variable('%s DATABASE MEAN ABSOLUTE DEVIATION' % (db_name), MADerror); psi4.set_variable('%s DATABASE ROOT-MEAN-SQUARE DEVIATION' % (db_name), RMSDerror). #print tables; psi4.print_out(tables); finalenergy = MADerror. else:; finalenergy = 0.0. # restore molecule and options; activate(user_molecule); user_molecule.update_geometry(); psi4.set_global_option(""BASIS"", user_basis); psi4.set_global_option(""REFERENCE"", user_reference); if not b_user_reference:; psi4.revoke_global_option_changed('REFERENCE'); psi4.set_global_option('WRITER_FILE_LABEL', user_writer_file_label). DB_RGT.clear(); DB_RGT.update(VRGT); DB_RXN.clear(); DB_RXN.update(VRXN); return finalenergy. [docs]def tblhead(tbl_maxrgt, tbl_delimit, ttype):; r""""""Function that prints the header for the changable-width results tables in db().; *tbl_maxrgt* is the number of reagent columns the table must plan for. *tbl_delimit*; is a string of dashes of the correct length to set off the table. *ttype* is 1 for; tables comparing the computed values to the reference or 2 for simple tabulation; and sum of the computed values. """"""; tbl_str = ''; tbl_str += """""" %s"""""" % (tbl_delimit); if ttype == 1:; tbl_str += """"""\n%23s %19s %8s"""""" % ('Reaction', 'Reaction Energy', 'Error'); elif ttype == 2:; tbl_str += """"""\n%23s %19s %6s"""""" % ('Reaction', 'Reaction Value', ''); for i in range(tbl_maxrgt):; tbl_str += """"""%20s"""""" % ('Reagent ' + str(i + 1)); if ttype == 1:; tbl_str += """"""\n%23s %8s %8s %8s"""""" % ('', 'Ref', 'Calc', '[kcal/mol]'); elif ttype == 2:; tbl_str += """"""\n%54s"""""" % (''); for i in range(tbl_maxrgt):; if ttype == 1:; tbl_str += """"""%20s"""""" % ('[H] Wt')",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:51935,Usability,simpl,simple,51935,"EAN ABSOLUTE DEVIATION' % (db_name), MADerror); psi4.set_variable('%s DATABASE ROOT-MEAN-SQUARE DEVIATION' % (db_name), RMSDerror). #print tables; psi4.print_out(tables); finalenergy = MADerror. else:; finalenergy = 0.0. # restore molecule and options; activate(user_molecule); user_molecule.update_geometry(); psi4.set_global_option(""BASIS"", user_basis); psi4.set_global_option(""REFERENCE"", user_reference); if not b_user_reference:; psi4.revoke_global_option_changed('REFERENCE'); psi4.set_global_option('WRITER_FILE_LABEL', user_writer_file_label). DB_RGT.clear(); DB_RGT.update(VRGT); DB_RXN.clear(); DB_RXN.update(VRXN); return finalenergy. [docs]def tblhead(tbl_maxrgt, tbl_delimit, ttype):; r""""""Function that prints the header for the changable-width results tables in db().; *tbl_maxrgt* is the number of reagent columns the table must plan for. *tbl_delimit*; is a string of dashes of the correct length to set off the table. *ttype* is 1 for; tables comparing the computed values to the reference or 2 for simple tabulation; and sum of the computed values. """"""; tbl_str = ''; tbl_str += """""" %s"""""" % (tbl_delimit); if ttype == 1:; tbl_str += """"""\n%23s %19s %8s"""""" % ('Reaction', 'Reaction Energy', 'Error'); elif ttype == 2:; tbl_str += """"""\n%23s %19s %6s"""""" % ('Reaction', 'Reaction Value', ''); for i in range(tbl_maxrgt):; tbl_str += """"""%20s"""""" % ('Reagent ' + str(i + 1)); if ttype == 1:; tbl_str += """"""\n%23s %8s %8s %8s"""""" % ('', 'Ref', 'Calc', '[kcal/mol]'); elif ttype == 2:; tbl_str += """"""\n%54s"""""" % (''); for i in range(tbl_maxrgt):; if ttype == 1:; tbl_str += """"""%20s"""""" % ('[H] Wt'); elif ttype == 2:; tbl_str += """"""%20s"""""" % ('Value Wt'); tbl_str += """"""\n %s"""""" % (tbl_delimit); return tbl_str. ## Aliases ##; db = database. #######################; ## End of Database ##; #######################. ###################################; ## Start of Complete Basis Set ##; ###################################. [docs]def complete_basis_set(name, **kwargs):; r""""""Function to define ",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:61860,Usability,simpl,simple,61860,"polation scheme to be applied to the second delta correction; to the correlation energy. :type delta3_scheme: function; :param delta3_scheme: |dl| ``highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the third delta correction; to the correlation energy. :type delta4_scheme: function; :param delta4_scheme: |dl| ``highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the fourth delta correction; to the correlation energy. :type delta5_scheme: function; :param delta5_scheme: |dl| ``highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the fifth delta correction; to the correlation energy. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :examples:. >>> # [1] replicates with cbs() the simple model chemistry scf/cc-pVDZ: set basis cc-pVDZ energy('scf'); >>> cbs('scf', scf_basis='cc-pVDZ'). >>> # [2] replicates with cbs() the simple model chemistry mp2/jun-cc-pVDZ: set basis jun-cc-pVDZ energy('mp2'); >>> cbs('mp2', corl_basis='jun-cc-pVDZ'). >>> # [3] DTQ-zeta extrapolated scf reference energy; >>> cbs('scf', scf_basis='cc-pV[DTQ]Z', scf_scheme=scf_xtpl_helgaker_3). >>> # [4] DT-zeta extrapolated mp2 correlation energy atop a T-zeta reference; >>> cbs('mp2', corl_basis='cc-pv[dt]z', corl_scheme=corl_xtpl_helgaker_2). >>> # [5] a DT-zeta extrapolated coupled-cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >>> cbs('mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2). >>> # [6] a D-zeta ccsd(t) correction atop a DT-zeta extrapolated ccsd cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >>> cbs('mp2', corl_basis",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:62002,Usability,simpl,simple,62002,"`highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the third delta correction; to the correlation energy. :type delta4_scheme: function; :param delta4_scheme: |dl| ``highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the fourth delta correction; to the correlation energy. :type delta5_scheme: function; :param delta5_scheme: |dl| ``highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the fifth delta correction; to the correlation energy. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :examples:. >>> # [1] replicates with cbs() the simple model chemistry scf/cc-pVDZ: set basis cc-pVDZ energy('scf'); >>> cbs('scf', scf_basis='cc-pVDZ'). >>> # [2] replicates with cbs() the simple model chemistry mp2/jun-cc-pVDZ: set basis jun-cc-pVDZ energy('mp2'); >>> cbs('mp2', corl_basis='jun-cc-pVDZ'). >>> # [3] DTQ-zeta extrapolated scf reference energy; >>> cbs('scf', scf_basis='cc-pV[DTQ]Z', scf_scheme=scf_xtpl_helgaker_3). >>> # [4] DT-zeta extrapolated mp2 correlation energy atop a T-zeta reference; >>> cbs('mp2', corl_basis='cc-pv[dt]z', corl_scheme=corl_xtpl_helgaker_2). >>> # [5] a DT-zeta extrapolated coupled-cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >>> cbs('mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2). >>> # [6] a D-zeta ccsd(t) correction atop a DT-zeta extrapolated ccsd cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >>> cbs('mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2, delta2_wfn='c",MatchSource.WIKI,psi4manual/4.0b5/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b5/_modules/p4util/basislist.html:3343,Deployability,install,installed,3343,"tion to add basis *fit* as associated fitting basis; member *jkfit* to a BasisFamily object.; """"""; self.jkfit = sanitize_basisname(fit). [docs] def add_rifit(self, fit):; """"""Function to add basis *fit* as associated fitting basis; member *rifit* to a BasisFamily object.; """"""; self.rifit = sanitize_basisname(fit). [docs] def add_dualfit(self, fit):; """"""Function to add basis *fit* as associated helper basis; member *dualfit* to a BasisFamily object.; """"""; self.dualfit = sanitize_basisname(fit). [docs]def sanitize_basisname(name):; """"""Function to return *name* in coded form, stripped of; characters that confuse filenames, characters into lowercase,; ``+`` into ``p``, ``*`` into ``s``, and ``(``, ``)``, & ``,``; into ``_``.; """"""; temp = name.lower(); temp = temp.replace('+', 'p'); temp = temp.replace('*', 's'); temp = temp.replace('(', '_'); temp = temp.replace(')', '_'); temp = temp.replace(',', '_'); return temp. [docs]def load_basis_families():; """"""Function to load into the array ``basisfamily_list``; BasisFamily objects for all Psi4's standard installed bases.; """"""; from basislistdunning import load_basfam_dunning; from basislistother import load_basfam_other. if len(basisfamily_list) == 0:; load_basfam_dunning(); load_basfam_other(); return basisfamily_list. [docs]def print_basis_families():; """"""Function to print to the output file a formatted summary; of all the BasisFamily objects in ``basisfamily_list``, by; default all Psi4's standard installed bases.; """"""; basisfamily_list = load_basis_families(). text = ''; for fam in basisfamily_list:; text += '%s' % (fam); return text. [docs]def corresponding_orbital(name):; """"""Function to validate if the orbital basis *name* in coded or; ornate form is in Psi4's standard installed bases list. ``None``; is returned if the orbital basis is not found.; """"""; basisfamily_list = load_basis_families(). for fam in basisfamily_list:; if sanitize_basisname(fam.ornate) == sanitize_basisname(name):; return fam.ornate; return None. [do",MatchSource.WIKI,psi4manual/4.0b5/_modules/p4util/basislist.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/p4util/basislist.html
https://psicode.org/psi4manual/4.0b5/_modules/p4util/basislist.html:3747,Deployability,install,installed,3747,"t* as associated helper basis; member *dualfit* to a BasisFamily object.; """"""; self.dualfit = sanitize_basisname(fit). [docs]def sanitize_basisname(name):; """"""Function to return *name* in coded form, stripped of; characters that confuse filenames, characters into lowercase,; ``+`` into ``p``, ``*`` into ``s``, and ``(``, ``)``, & ``,``; into ``_``.; """"""; temp = name.lower(); temp = temp.replace('+', 'p'); temp = temp.replace('*', 's'); temp = temp.replace('(', '_'); temp = temp.replace(')', '_'); temp = temp.replace(',', '_'); return temp. [docs]def load_basis_families():; """"""Function to load into the array ``basisfamily_list``; BasisFamily objects for all Psi4's standard installed bases.; """"""; from basislistdunning import load_basfam_dunning; from basislistother import load_basfam_other. if len(basisfamily_list) == 0:; load_basfam_dunning(); load_basfam_other(); return basisfamily_list. [docs]def print_basis_families():; """"""Function to print to the output file a formatted summary; of all the BasisFamily objects in ``basisfamily_list``, by; default all Psi4's standard installed bases.; """"""; basisfamily_list = load_basis_families(). text = ''; for fam in basisfamily_list:; text += '%s' % (fam); return text. [docs]def corresponding_orbital(name):; """"""Function to validate if the orbital basis *name* in coded or; ornate form is in Psi4's standard installed bases list. ``None``; is returned if the orbital basis is not found.; """"""; basisfamily_list = load_basis_families(). for fam in basisfamily_list:; if sanitize_basisname(fam.ornate) == sanitize_basisname(name):; return fam.ornate; return None. [docs]def corresponding_jkfit(name):; """"""Function to return an appropriate JK fitting basis for; the orbital basis *name* in coded or ornate form. ``None``; is returned if no fitting basis is defined or if the; orbital basis is not found.; """"""; basisfamily_list = load_basis_families(). for fam in basisfamily_list:; if sanitize_basisname(fam.ornate) == sanitize_basisname(name):; re",MatchSource.WIKI,psi4manual/4.0b5/_modules/p4util/basislist.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/p4util/basislist.html
https://psicode.org/psi4manual/4.0b5/_modules/p4util/basislist.html:4027,Deployability,install,installed,4027,"``s``, and ``(``, ``)``, & ``,``; into ``_``.; """"""; temp = name.lower(); temp = temp.replace('+', 'p'); temp = temp.replace('*', 's'); temp = temp.replace('(', '_'); temp = temp.replace(')', '_'); temp = temp.replace(',', '_'); return temp. [docs]def load_basis_families():; """"""Function to load into the array ``basisfamily_list``; BasisFamily objects for all Psi4's standard installed bases.; """"""; from basislistdunning import load_basfam_dunning; from basislistother import load_basfam_other. if len(basisfamily_list) == 0:; load_basfam_dunning(); load_basfam_other(); return basisfamily_list. [docs]def print_basis_families():; """"""Function to print to the output file a formatted summary; of all the BasisFamily objects in ``basisfamily_list``, by; default all Psi4's standard installed bases.; """"""; basisfamily_list = load_basis_families(). text = ''; for fam in basisfamily_list:; text += '%s' % (fam); return text. [docs]def corresponding_orbital(name):; """"""Function to validate if the orbital basis *name* in coded or; ornate form is in Psi4's standard installed bases list. ``None``; is returned if the orbital basis is not found.; """"""; basisfamily_list = load_basis_families(). for fam in basisfamily_list:; if sanitize_basisname(fam.ornate) == sanitize_basisname(name):; return fam.ornate; return None. [docs]def corresponding_jkfit(name):; """"""Function to return an appropriate JK fitting basis for; the orbital basis *name* in coded or ornate form. ``None``; is returned if no fitting basis is defined or if the; orbital basis is not found.; """"""; basisfamily_list = load_basis_families(). for fam in basisfamily_list:; if sanitize_basisname(fam.ornate) == sanitize_basisname(name):; return fam.jkfit; return None. [docs]def corresponding_rifit(name):; """"""Function to return an appropriate RI fitting basis for; the orbital basis *name* in coded or ornate form. ``None``; is returned if no fitting basis is defined or if the; orbital basis is not found.; """"""; basisfamily_list = load_basis_f",MatchSource.WIKI,psi4manual/4.0b5/_modules/p4util/basislist.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/p4util/basislist.html
https://psicode.org/psi4manual/4.0b5/_modules/p4util/basislist.html:5709,Deployability,update,updated,5709,"""""; basisfamily_list = load_basis_families(). text = ''; for fam in basisfamily_list:; text += '%s' % (fam); return text. [docs]def corresponding_orbital(name):; """"""Function to validate if the orbital basis *name* in coded or; ornate form is in Psi4's standard installed bases list. ``None``; is returned if the orbital basis is not found.; """"""; basisfamily_list = load_basis_families(). for fam in basisfamily_list:; if sanitize_basisname(fam.ornate) == sanitize_basisname(name):; return fam.ornate; return None. [docs]def corresponding_jkfit(name):; """"""Function to return an appropriate JK fitting basis for; the orbital basis *name* in coded or ornate form. ``None``; is returned if no fitting basis is defined or if the; orbital basis is not found.; """"""; basisfamily_list = load_basis_families(). for fam in basisfamily_list:; if sanitize_basisname(fam.ornate) == sanitize_basisname(name):; return fam.jkfit; return None. [docs]def corresponding_rifit(name):; """"""Function to return an appropriate RI fitting basis for; the orbital basis *name* in coded or ornate form. ``None``; is returned if no fitting basis is defined or if the; orbital basis is not found.; """"""; basisfamily_list = load_basis_families(). for fam in basisfamily_list:; if sanitize_basisname(fam.ornate) == sanitize_basisname(name):; return fam.rifit; return None. [docs]def corresponding_dualfit(name):; """"""Function to return an appropriate DUAL helper basis for; the orbital basis *name* in coded or ornate form. ``None``; is returned if no fitting basis is defined or if the; orbital basis is not found.; """"""; basisfamily_list = load_basis_families(). for fam in basisfamily_list:; if sanitize_basisname(fam.ornate) == sanitize_basisname(name):; return fam.dualfit; return None. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  ; PSI4 [beta5]  ; Module code .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/_modules/p4util/basislist.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/p4util/basislist.html
https://psicode.org/psi4manual/4.0b5/_modules/p4util/basislist.html:3257,Performance,load,load,3257,"tion to add basis *fit* as associated fitting basis; member *jkfit* to a BasisFamily object.; """"""; self.jkfit = sanitize_basisname(fit). [docs] def add_rifit(self, fit):; """"""Function to add basis *fit* as associated fitting basis; member *rifit* to a BasisFamily object.; """"""; self.rifit = sanitize_basisname(fit). [docs] def add_dualfit(self, fit):; """"""Function to add basis *fit* as associated helper basis; member *dualfit* to a BasisFamily object.; """"""; self.dualfit = sanitize_basisname(fit). [docs]def sanitize_basisname(name):; """"""Function to return *name* in coded form, stripped of; characters that confuse filenames, characters into lowercase,; ``+`` into ``p``, ``*`` into ``s``, and ``(``, ``)``, & ``,``; into ``_``.; """"""; temp = name.lower(); temp = temp.replace('+', 'p'); temp = temp.replace('*', 's'); temp = temp.replace('(', '_'); temp = temp.replace(')', '_'); temp = temp.replace(',', '_'); return temp. [docs]def load_basis_families():; """"""Function to load into the array ``basisfamily_list``; BasisFamily objects for all Psi4's standard installed bases.; """"""; from basislistdunning import load_basfam_dunning; from basislistother import load_basfam_other. if len(basisfamily_list) == 0:; load_basfam_dunning(); load_basfam_other(); return basisfamily_list. [docs]def print_basis_families():; """"""Function to print to the output file a formatted summary; of all the BasisFamily objects in ``basisfamily_list``, by; default all Psi4's standard installed bases.; """"""; basisfamily_list = load_basis_families(). text = ''; for fam in basisfamily_list:; text += '%s' % (fam); return text. [docs]def corresponding_orbital(name):; """"""Function to validate if the orbital basis *name* in coded or; ornate form is in Psi4's standard installed bases list. ``None``; is returned if the orbital basis is not found.; """"""; basisfamily_list = load_basis_families(). for fam in basisfamily_list:; if sanitize_basisname(fam.ornate) == sanitize_basisname(name):; return fam.ornate; return None. [do",MatchSource.WIKI,psi4manual/4.0b5/_modules/p4util/basislist.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/p4util/basislist.html
https://psicode.org/psi4manual/4.0b5/_modules/p4util/basislist.html:3943,Security,validat,validate,3943,"``s``, and ``(``, ``)``, & ``,``; into ``_``.; """"""; temp = name.lower(); temp = temp.replace('+', 'p'); temp = temp.replace('*', 's'); temp = temp.replace('(', '_'); temp = temp.replace(')', '_'); temp = temp.replace(',', '_'); return temp. [docs]def load_basis_families():; """"""Function to load into the array ``basisfamily_list``; BasisFamily objects for all Psi4's standard installed bases.; """"""; from basislistdunning import load_basfam_dunning; from basislistother import load_basfam_other. if len(basisfamily_list) == 0:; load_basfam_dunning(); load_basfam_other(); return basisfamily_list. [docs]def print_basis_families():; """"""Function to print to the output file a formatted summary; of all the BasisFamily objects in ``basisfamily_list``, by; default all Psi4's standard installed bases.; """"""; basisfamily_list = load_basis_families(). text = ''; for fam in basisfamily_list:; text += '%s' % (fam); return text. [docs]def corresponding_orbital(name):; """"""Function to validate if the orbital basis *name* in coded or; ornate form is in Psi4's standard installed bases list. ``None``; is returned if the orbital basis is not found.; """"""; basisfamily_list = load_basis_families(). for fam in basisfamily_list:; if sanitize_basisname(fam.ornate) == sanitize_basisname(name):; return fam.ornate; return None. [docs]def corresponding_jkfit(name):; """"""Function to return an appropriate JK fitting basis for; the orbital basis *name* in coded or ornate form. ``None``; is returned if no fitting basis is defined or if the; orbital basis is not found.; """"""; basisfamily_list = load_basis_families(). for fam in basisfamily_list:; if sanitize_basisname(fam.ornate) == sanitize_basisname(name):; return fam.jkfit; return None. [docs]def corresponding_rifit(name):; """"""Function to return an appropriate RI fitting basis for; the orbital basis *name* in coded or ornate form. ``None``; is returned if no fitting basis is defined or if the; orbital basis is not found.; """"""; basisfamily_list = load_basis_f",MatchSource.WIKI,psi4manual/4.0b5/_modules/p4util/basislist.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/p4util/basislist.html
https://psicode.org/psi4manual/4.0b5/_modules/p4util/basislistdunning.html:29868,Deployability,update,updated,29868,"Family('mar-cc-pCV(6+d)Z'); basisfamily_list.append(basis_marccpcv_6pd_z); basis_febccpv6z = BasisFamily('feb-cc-pV6Z'); basisfamily_list.append(basis_febccpv6z); basis_febccpv_6pd_z = BasisFamily('feb-cc-pV(6+d)Z'); basisfamily_list.append(basis_febccpv_6pd_z); basis_febccpcv6z = BasisFamily('feb-cc-pCV6Z'); basisfamily_list.append(basis_febccpcv6z); basis_febccpcv_6pd_z = BasisFamily('feb-cc-pCV(6+d)Z'); basisfamily_list.append(basis_febccpcv_6pd_z); basis_daugccpv6z = BasisFamily('d-aug-cc-pV6Z'); basisfamily_list.append(basis_daugccpv6z); basis_daugccpcv6z = BasisFamily('d-aug-cc-pCV6Z'); basisfamily_list.append(basis_daugccpcv6z); basis_ccpv6z.add_rifit('cc-pV6Z-RI'); basis_ccpv_6pd_z.add_rifit('cc-pV6Z-RI'); basis_augccpv6z.add_rifit('aug-cc-pV6Z-RI'); basis_augccpv_6pd_z.add_rifit('aug-cc-pV6Z-RI'); basis_heavyaugccpv6z.add_rifit('heavy-aug-cc-pV6Z-RI'); basis_heavyaugccpv_6pd_z.add_rifit('heavy-aug-cc-pV6Z-RI'); basis_junccpv6z.add_rifit('jun-cc-pV6Z-RI'); basis_junccpv_6pd_z.add_rifit('jun-cc-pV6Z-RI'); basis_mayccpv6z.add_rifit('may-cc-pV6Z-RI'); basis_mayccpv_6pd_z.add_rifit('may-cc-pV6Z-RI'); basis_aprccpv6z.add_rifit('apr-cc-pV6Z-RI'); basis_aprccpv_6pd_z.add_rifit('apr-cc-pV6Z-RI'); basis_marccpv6z.add_rifit('mar-cc-pV6Z-RI'); basis_marccpv_6pd_z.add_rifit('mar-cc-pV6Z-RI'); basis_febccpv6z.add_rifit('feb-cc-pV6Z-RI'); basis_febccpv_6pd_z.add_rifit('feb-cc-pV6Z-RI'); basis_ccpvtz.add_dualfit('cc-pvtz-dual'); basis_ccpvqz.add_dualfit('cc-pvqz-dual'); basis_augccpvdz.add_dualfit('aug-cc-pvdz-dual'); basis_augccpvtz.add_dualfit('aug-cc-pvtz-dual'); basis_augccpvqz.add_dualfit('aug-cc-pvqz-dual'); basis_heavyaugccpvtz.add_dualfit('heavy-aug-cc-pvtz-dual'); basis_heavyaugccpvqz.add_dualfit('heavy-aug-cc-pvqz-dual'). Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  ; PSI4 [beta5]  ; Module code .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/_modules/p4util/basislistdunning.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/p4util/basislistdunning.html
https://psicode.org/psi4manual/4.0b5/_modules/p4util/basislistother.html:16294,Deployability,update,updated,16294,"_6311pg_3df_3pd_.add_rifit('heavy-aug-cc-pvtz-ri'). basis_6311ppg.add_jkfit('aug-cc-pvtz-jkfit'); basis_6311ppg_d_.add_jkfit('aug-cc-pvtz-jkfit'); basis_6311ppg_d_p_.add_jkfit('aug-cc-pvtz-jkfit'); basis_6311ppgs.add_jkfit('aug-cc-pvtz-jkfit'); basis_6311ppgss.add_jkfit('aug-cc-pvtz-jkfit'); basis_6311ppg_2d_.add_jkfit('aug-cc-pvtz-jkfit'); basis_6311ppg_2d_p_.add_jkfit('aug-cc-pvtz-jkfit'); basis_6311ppg_2d_2p_.add_jkfit('aug-cc-pvtz-jkfit'); basis_6311ppg_2df_.add_jkfit('aug-cc-pvtz-jkfit'); basis_6311ppg_2df_p_.add_jkfit('aug-cc-pvtz-jkfit'); basis_6311ppg_2df_2p_.add_jkfit('aug-cc-pvtz-jkfit'); basis_6311ppg_2df_2pd_.add_jkfit('aug-cc-pvtz-jkfit'); basis_6311ppg_3df_.add_jkfit('aug-cc-pvtz-jkfit'); basis_6311ppg_3df_p_.add_jkfit('aug-cc-pvtz-jkfit'); basis_6311ppg_3df_2p_.add_jkfit('aug-cc-pvtz-jkfit'); basis_6311ppg_3df_2pd_.add_jkfit('aug-cc-pvtz-jkfit'); basis_6311ppg_3df_3pd_.add_jkfit('aug-cc-pvtz-jkfit'). basis_6311ppg.add_rifit('aug-cc-pvtz-ri'); basis_6311ppg_d_.add_rifit('aug-cc-pvtz-ri'); basis_6311ppg_d_p_.add_rifit('aug-cc-pvtz-ri'); basis_6311ppgs.add_rifit('aug-cc-pvtz-ri'); basis_6311ppgss.add_rifit('aug-cc-pvtz-ri'); basis_6311ppg_2d_.add_rifit('aug-cc-pvtz-ri'); basis_6311ppg_2d_p_.add_rifit('aug-cc-pvtz-ri'); basis_6311ppg_2d_2p_.add_rifit('aug-cc-pvtz-ri'); basis_6311ppg_2df_.add_rifit('aug-cc-pvtz-ri'); basis_6311ppg_2df_p_.add_rifit('aug-cc-pvtz-ri'); basis_6311ppg_2df_2p_.add_rifit('aug-cc-pvtz-ri'); basis_6311ppg_2df_2pd_.add_rifit('aug-cc-pvtz-ri'); basis_6311ppg_3df_.add_rifit('aug-cc-pvtz-ri'); basis_6311ppg_3df_p_.add_rifit('aug-cc-pvtz-ri'); basis_6311ppg_3df_2p_.add_rifit('aug-cc-pvtz-ri'); basis_6311ppg_3df_2pd_.add_rifit('aug-cc-pvtz-ri'); basis_6311ppg_3df_3pd_.add_rifit('aug-cc-pvtz-ri'). Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  ; PSI4 [beta5]  ; Module code .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/_modules/p4util/basislistother.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/p4util/basislistother.html
https://psicode.org/psi4manual/4.0b5/_modules/p4util/basislistother.html:9466,Security,validat,validated,9466,d(basis_def2qzvpd); basisfamily_list.append(basis_def2qzvpp); basisfamily_list.append(basis_def2qzvppd). # Others; basis_dz = BasisFamily('DZ'); basis_dzp = BasisFamily('DZP'); basis_dzvp = BasisFamily('DZVP'); basis_psi3dzp = BasisFamily('psi3-DZP'); basis_psi3tz2p = BasisFamily('psi3-TZ2P'); basis_psi3tz2pf = BasisFamily('psi3-TZ2PF'); basis_sadlejlpoldl = BasisFamily('sadlej-lpol-dl'); basis_sadlejlpolds = BasisFamily('sadlej-lpol-ds'); basis_sadlejlpolfl = BasisFamily('sadlej-lpol-fl'); basis_sadlejlpolfs = BasisFamily('sadlej-lpol-fs'). basisfamily_list.append(basis_dz); basisfamily_list.append(basis_dzp); basisfamily_list.append(basis_dzvp); basisfamily_list.append(basis_psi3dzp); basisfamily_list.append(basis_psi3tz2p); basisfamily_list.append(basis_psi3tz2pf); basisfamily_list.append(basis_sadlejlpoldl); basisfamily_list.append(basis_sadlejlpolds); basisfamily_list.append(basis_sadlejlpolfl); basisfamily_list.append(basis_sadlejlpolfs). # Here lie practical (non-validated) fitting bases for; # Pople orbital basis sets. basis_sto3g.add_jkfit('cc-pvdz-ri'); basis_sto3g.add_rifit('cc-pvdz-ri'); basis_321g.add_jkfit('cc-pvdz-ri'); basis_321g.add_rifit('cc-pvdz-ri'). basis_631g.add_jkfit('cc-pvdz-jkfit'); basis_631g_d_.add_jkfit('cc-pvdz-jkfit'); basis_631g_d_p_.add_jkfit('cc-pvdz-jkfit'); basis_631gs.add_jkfit('cc-pvdz-jkfit'); basis_631gss.add_jkfit('cc-pvdz-jkfit'); basis_631g.add_rifit('cc-pvdz-ri'); basis_631g_d_.add_rifit('cc-pvdz-ri'); basis_631g_d_p_.add_rifit('cc-pvdz-ri'); basis_631gs.add_rifit('cc-pvdz-ri'); basis_631gss.add_rifit('cc-pvdz-ri'). basis_631pg.add_jkfit('heavy-aug-cc-pvdz-jkfit'); basis_631pg_d_.add_jkfit('heavy-aug-cc-pvdz-jkfit'); basis_631pg_d_p_.add_jkfit('heavy-aug-cc-pvdz-jkfit'); basis_631pgs.add_jkfit('heavy-aug-cc-pvdz-jkfit'); basis_631pgss.add_jkfit('heavy-aug-cc-pvdz-jkfit'); basis_631pg.add_rifit('heavy-aug-cc-pvdz-ri'); basis_631pg_d_.add_rifit('heavy-aug-cc-pvdz-ri'); basis_631pg_d_p_.add_rifit('heavy-aug-cc-pvdz-ri'); basi,MatchSource.WIKI,psi4manual/4.0b5/_modules/p4util/basislistother.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/p4util/basislistother.html
https://psicode.org/psi4manual/4.0b5/_modules/p4util/optproc.html:3801,Availability,ERROR,ERROR,3801,"as changed?) value: %7s %s\n"""""" % ('(' + str(self.haschanged_local) + ')', self.value_local); text += """""" Used (has changed?) value: %7s %s\n"""""" % ('(' + str(self.haschanged_used) + ')', self.value_used); else:; text += """""" ==> %s Option in Global Scope <==\n\n"""""" % (self.option); text += """""" Global (has changed?) value: %7s %s\n"""""" % ('(' + str(self.haschanged_global) + ')', self.value_global); text += """"""\n""""""; return text. [docs] def restore(self):; psi4.set_global_option(self.option, self.value_global); if not self.haschanged_global:; psi4.revoke_global_option_changed(self.option); if self.module:; psi4.set_local_option(self.module, self.option, self.value_local); if not self.haschanged_local:; psi4.revoke_local_option_changed(self.module, self.option). [docs]class OptionsState(object):; """"""Class to contain multiple :py:func:`~optproc.OptionsState` objects.; Used in python driver functions to collect several options before altering; them, then restoring before function return. ::. >>> optstash = OptionsState(; ['SCF', 'DFT_FUNCTIONAL'],; ['DF_BASIS_SCF'],; ['SCF', 'SCF_TYPE'],; ['SCF', 'REFERENCE']). >>> print(optstash). >>> optstash.restore(). """"""; def __init__(self, *largs):; self.data = []; for item in largs:; if len(item) == 2:; self.data.append(OptionState(item[1], item[0])); elif len(item) == 1:; self.data.append(OptionState(item[0])); else:; print('ERROR: Each argument to OptionsState should be an array, the first element'); print(' of which is the module scope and the second element of which is the'); print(' module name. Bad argument: %s' % (item)); sys.exit(). def __str__(self):; text = ''; for item in self.data:; text += str(item); return text. [docs] def restore(self):; for item in self.data:; item.restore(). Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  ; PSI4 [beta5]  ; Module code .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/_modules/p4util/optproc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/p4util/optproc.html
https://psicode.org/psi4manual/4.0b5/_modules/p4util/optproc.html:4362,Deployability,update,updated,4362,"as changed?) value: %7s %s\n"""""" % ('(' + str(self.haschanged_local) + ')', self.value_local); text += """""" Used (has changed?) value: %7s %s\n"""""" % ('(' + str(self.haschanged_used) + ')', self.value_used); else:; text += """""" ==> %s Option in Global Scope <==\n\n"""""" % (self.option); text += """""" Global (has changed?) value: %7s %s\n"""""" % ('(' + str(self.haschanged_global) + ')', self.value_global); text += """"""\n""""""; return text. [docs] def restore(self):; psi4.set_global_option(self.option, self.value_global); if not self.haschanged_global:; psi4.revoke_global_option_changed(self.option); if self.module:; psi4.set_local_option(self.module, self.option, self.value_local); if not self.haschanged_local:; psi4.revoke_local_option_changed(self.module, self.option). [docs]class OptionsState(object):; """"""Class to contain multiple :py:func:`~optproc.OptionsState` objects.; Used in python driver functions to collect several options before altering; them, then restoring before function return. ::. >>> optstash = OptionsState(; ['SCF', 'DFT_FUNCTIONAL'],; ['DF_BASIS_SCF'],; ['SCF', 'SCF_TYPE'],; ['SCF', 'REFERENCE']). >>> print(optstash). >>> optstash.restore(). """"""; def __init__(self, *largs):; self.data = []; for item in largs:; if len(item) == 2:; self.data.append(OptionState(item[1], item[0])); elif len(item) == 1:; self.data.append(OptionState(item[0])); else:; print('ERROR: Each argument to OptionsState should be an array, the first element'); print(' of which is the module scope and the second element of which is the'); print(' module name. Bad argument: %s' % (item)); sys.exit(). def __str__(self):; text = ''; for item in self.data:; text += str(item); return text. [docs] def restore(self):; for item in self.data:; item.restore(). Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  ; PSI4 [beta5]  ; Module code .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/_modules/p4util/optproc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/p4util/optproc.html
https://psicode.org/psi4manual/4.0b5/_modules/p4util/procutil.html:2817,Availability,avail,available,2817,"rent namespace *pidspace*. """"""; psioh = psi4.IOManager.shared_object(); psio = psi4.IO.shared_object(); filepath = psioh.get_file_path(fileno); namespace = psio.get_default_namespace(); targetfile = filepath + 'psi' + '.' + pidspace + '.' + namespace + '.' + str(fileno); return targetfile. [docs]def format_molecule_for_input(mol):; """"""Function to return a string of the output of; :py:func:`inputparser.process_input` applied to the XYZ; format of molecule, passed as either fragmented; geometry string *mol* or molecule instance *mol*.; Used to capture molecule information from database; modules and for distributed (sow/reap) input files.; For the reverse, see :py:func:`molutil.geometry`. """"""; # when mol is already a string; if isinstance(mol, basestring):; mol_string = mol; mol_name = ''; # when mol is psi4.Molecule or qcdb.Molecule object; else:; # save_string_for_psi4 is the more detailed choice as it includes fragment; # (and possibly no_com/no_reorient) info. but this is only available; # for qcdb Molecules. Since save_string_xyz was added to libmints just; # for the sow/reap purpose, may want to unify these fns sometime.; # the time for unification is nigh; mol_string = mol.create_psi4_string_from_molecule(); #try:; # mol_string = mol.save_string_for_psi4(); #except AttributeError:; # mol_string = mol.save_string_xyz(). mol_name = mol.name(). commands = 'inputparser.process_input(""""""\nmolecule %s {\n%s\n}\n"""""", 0)\n' % (mol_name, mol_string); return eval(commands). [docs]def format_options_for_input():; """"""Function to return a string of commands to replicate the; current state of user-modified options. Used to capture C++; options information for distributed (sow/reap) input files. .. caution:: Some features are not yet implemented. Buy a developer a coffee. - Does not cover local (as opposed to global) options. - Does not work with array-type options. """"""; commands = ''; commands += """"""\npsi4.set_memory(%s)\n\n"""""" % (psi4.get_memory()); for chgdopt in psi4.get_g",MatchSource.WIKI,psi4manual/4.0b5/_modules/p4util/procutil.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/p4util/procutil.html
https://psicode.org/psi4manual/4.0b5/_modules/p4util/procutil.html:5752,Availability,avail,available,5752,"write('''\npickle_kw = (""""""'''); pickle.dump(kwargs, filename); filename.write('''"""""")\n'''); filename.write(""""""\nkwargs = pickle.loads(pickle_kw)\n""""""); if lmode == 2:; kwargs['mode'] = 'sow'; del kwargs['linkage']. [docs]def drop_duplicates(seq):; """"""Function that given an array *seq*, returns an array without any duplicate; entries. There is no guarantee of which duplicate entry is dropped. """"""; noDupes = []; [noDupes.append(i) for i in seq if not noDupes.count(i)]; return noDupes. [docs]def all_casings(input_string):; """"""Function to return a generator of all lettercase permutations; of *input_string*. """"""; if not input_string:; yield """"; else:; first = input_string[:1]; if first.lower() == first.upper():; for sub_casing in all_casings(input_string[1:]):; yield first + sub_casing; else:; for sub_casing in all_casings(input_string[1:]):; yield first.lower() + sub_casing; yield first.upper() + sub_casing. [docs]def getattr_ignorecase(module, attr):; """"""Function to extract attribute *attr* from *module* if *attr*; is available in any possible lettercase permutation. Returns; attribute if available, None if not. """"""; array = None; for per in list(all_casings(attr)):; try:; getattr(module, per); except AttributeError:; pass; else:; array = getattr(module, per); break. return array. [docs]def import_ignorecase(module):; """"""Function to import *module* in any possible lettercase; permutation. Returns module object if available, None if not. """"""; modobj = None; for per in list(all_casings(module)):; try:; modobj = __import__(per); except ImportError:; pass; else:; break. return modobj. [docs]def extract_sowreap_from_output(sowout, quantity, sownum, linkage, allvital=False):; """"""Function to examine file *sowout* from a sow/reap distributed job; for formatted line with electronic energy information about index; *sownum* to be used for construction of *quantity* computations as; directed by master input file with *linkage* kwarg. When file *sowout*; is missing or incomplete f",MatchSource.WIKI,psi4manual/4.0b5/_modules/p4util/procutil.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/p4util/procutil.html
https://psicode.org/psi4manual/4.0b5/_modules/p4util/procutil.html:5824,Availability,avail,available,5824,"ite(""""""\nkwargs = pickle.loads(pickle_kw)\n""""""); if lmode == 2:; kwargs['mode'] = 'sow'; del kwargs['linkage']. [docs]def drop_duplicates(seq):; """"""Function that given an array *seq*, returns an array without any duplicate; entries. There is no guarantee of which duplicate entry is dropped. """"""; noDupes = []; [noDupes.append(i) for i in seq if not noDupes.count(i)]; return noDupes. [docs]def all_casings(input_string):; """"""Function to return a generator of all lettercase permutations; of *input_string*. """"""; if not input_string:; yield """"; else:; first = input_string[:1]; if first.lower() == first.upper():; for sub_casing in all_casings(input_string[1:]):; yield first + sub_casing; else:; for sub_casing in all_casings(input_string[1:]):; yield first.lower() + sub_casing; yield first.upper() + sub_casing. [docs]def getattr_ignorecase(module, attr):; """"""Function to extract attribute *attr* from *module* if *attr*; is available in any possible lettercase permutation. Returns; attribute if available, None if not. """"""; array = None; for per in list(all_casings(attr)):; try:; getattr(module, per); except AttributeError:; pass; else:; array = getattr(module, per); break. return array. [docs]def import_ignorecase(module):; """"""Function to import *module* in any possible lettercase; permutation. Returns module object if available, None if not. """"""; modobj = None; for per in list(all_casings(module)):; try:; modobj = __import__(per); except ImportError:; pass; else:; break. return modobj. [docs]def extract_sowreap_from_output(sowout, quantity, sownum, linkage, allvital=False):; """"""Function to examine file *sowout* from a sow/reap distributed job; for formatted line with electronic energy information about index; *sownum* to be used for construction of *quantity* computations as; directed by master input file with *linkage* kwarg. When file *sowout*; is missing or incomplete files, function will either return zero; (*allvital* is ``False``) or terminate (*allvital* is ``True``) ",MatchSource.WIKI,psi4manual/4.0b5/_modules/p4util/procutil.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/p4util/procutil.html
https://psicode.org/psi4manual/4.0b5/_modules/p4util/procutil.html:6155,Availability,avail,available,6155," for i in seq if not noDupes.count(i)]; return noDupes. [docs]def all_casings(input_string):; """"""Function to return a generator of all lettercase permutations; of *input_string*. """"""; if not input_string:; yield """"; else:; first = input_string[:1]; if first.lower() == first.upper():; for sub_casing in all_casings(input_string[1:]):; yield first + sub_casing; else:; for sub_casing in all_casings(input_string[1:]):; yield first.lower() + sub_casing; yield first.upper() + sub_casing. [docs]def getattr_ignorecase(module, attr):; """"""Function to extract attribute *attr* from *module* if *attr*; is available in any possible lettercase permutation. Returns; attribute if available, None if not. """"""; array = None; for per in list(all_casings(attr)):; try:; getattr(module, per); except AttributeError:; pass; else:; array = getattr(module, per); break. return array. [docs]def import_ignorecase(module):; """"""Function to import *module* in any possible lettercase; permutation. Returns module object if available, None if not. """"""; modobj = None; for per in list(all_casings(module)):; try:; modobj = __import__(per); except ImportError:; pass; else:; break. return modobj. [docs]def extract_sowreap_from_output(sowout, quantity, sownum, linkage, allvital=False):; """"""Function to examine file *sowout* from a sow/reap distributed job; for formatted line with electronic energy information about index; *sownum* to be used for construction of *quantity* computations as; directed by master input file with *linkage* kwarg. When file *sowout*; is missing or incomplete files, function will either return zero; (*allvital* is ``False``) or terminate (*allvital* is ``True``) since; some sow/reap procedures can produce meaningful results (database); from an incomplete set of sown files, while others cannot (gradient,; hessian). """"""; E = 0.0. try:; freagent = open('%s.out' % (sowout), 'r'); except IOError:; if allvital:; raise ValidationError('Aborting upon output file \'%s.out\' not found.\n' % (sowo",MatchSource.WIKI,psi4manual/4.0b5/_modules/p4util/procutil.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/p4util/procutil.html
https://psicode.org/psi4manual/4.0b5/_modules/p4util/procutil.html:8353,Deployability,update,updated,8353,"lse):; """"""Function to examine file *sowout* from a sow/reap distributed job; for formatted line with electronic energy information about index; *sownum* to be used for construction of *quantity* computations as; directed by master input file with *linkage* kwarg. When file *sowout*; is missing or incomplete files, function will either return zero; (*allvital* is ``False``) or terminate (*allvital* is ``True``) since; some sow/reap procedures can produce meaningful results (database); from an incomplete set of sown files, while others cannot (gradient,; hessian). """"""; E = 0.0. try:; freagent = open('%s.out' % (sowout), 'r'); except IOError:; if allvital:; raise ValidationError('Aborting upon output file \'%s.out\' not found.\n' % (sowout)); else:; ValidationError('Aborting upon output file \'%s.out\' not found.\n' % (sowout)); return 0.0; else:; while True:; line = freagent.readline(); if not line:; if E == 0.0:; if allvital:; raise ValidationError('Aborting upon output file \'%s.out\' has no %s RESULT line.\n' % (sowout, quantity)); else:; ValidationError('Aborting upon output file \'%s.out\' has no %s RESULT line.\n' % (sowout, quantity)); break; s = line.split(); if (len(s) != 0) and (s[0:3] == [quantity, 'RESULT:', 'computation']):; if int(s[3]) != linkage:; raise ValidationError('Output file \'%s.out\' has linkage %s incompatible with master.in linkage %s.'; % (sowout, str(s[3]), str(linkage))); if s[6] != str(sownum + 1):; raise ValidationError('Output file \'%s.out\' has nominal affiliation %s incompatible with item %s.'; % (sowout, s[6], str(sownum + 1))); if (s[8:10] == ['electronic', 'energy']):; E = float(s[10]); psi4.print_out('%s RESULT: electronic energy = %20.12f\n' % (quantity, E)); freagent.close(); return E. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  ; PSI4 [beta5]  ; Module code .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/_modules/p4util/procutil.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/p4util/procutil.html
https://psicode.org/psi4manual/4.0b5/_modules/p4util/procutil.html:6522,Energy Efficiency,energy,energy,6522," + sub_casing; else:; for sub_casing in all_casings(input_string[1:]):; yield first.lower() + sub_casing; yield first.upper() + sub_casing. [docs]def getattr_ignorecase(module, attr):; """"""Function to extract attribute *attr* from *module* if *attr*; is available in any possible lettercase permutation. Returns; attribute if available, None if not. """"""; array = None; for per in list(all_casings(attr)):; try:; getattr(module, per); except AttributeError:; pass; else:; array = getattr(module, per); break. return array. [docs]def import_ignorecase(module):; """"""Function to import *module* in any possible lettercase; permutation. Returns module object if available, None if not. """"""; modobj = None; for per in list(all_casings(module)):; try:; modobj = __import__(per); except ImportError:; pass; else:; break. return modobj. [docs]def extract_sowreap_from_output(sowout, quantity, sownum, linkage, allvital=False):; """"""Function to examine file *sowout* from a sow/reap distributed job; for formatted line with electronic energy information about index; *sownum* to be used for construction of *quantity* computations as; directed by master input file with *linkage* kwarg. When file *sowout*; is missing or incomplete files, function will either return zero; (*allvital* is ``False``) or terminate (*allvital* is ``True``) since; some sow/reap procedures can produce meaningful results (database); from an incomplete set of sown files, while others cannot (gradient,; hessian). """"""; E = 0.0. try:; freagent = open('%s.out' % (sowout), 'r'); except IOError:; if allvital:; raise ValidationError('Aborting upon output file \'%s.out\' not found.\n' % (sowout)); else:; ValidationError('Aborting upon output file \'%s.out\' not found.\n' % (sowout)); return 0.0; else:; while True:; line = freagent.readline(); if not line:; if E == 0.0:; if allvital:; raise ValidationError('Aborting upon output file \'%s.out\' has no %s RESULT line.\n' % (sowout, quantity)); else:; ValidationError('Aborting upon ou",MatchSource.WIKI,psi4manual/4.0b5/_modules/p4util/procutil.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/p4util/procutil.html
https://psicode.org/psi4manual/4.0b5/_modules/p4util/procutil.html:8031,Energy Efficiency,energy,energy,8031,"lse):; """"""Function to examine file *sowout* from a sow/reap distributed job; for formatted line with electronic energy information about index; *sownum* to be used for construction of *quantity* computations as; directed by master input file with *linkage* kwarg. When file *sowout*; is missing or incomplete files, function will either return zero; (*allvital* is ``False``) or terminate (*allvital* is ``True``) since; some sow/reap procedures can produce meaningful results (database); from an incomplete set of sown files, while others cannot (gradient,; hessian). """"""; E = 0.0. try:; freagent = open('%s.out' % (sowout), 'r'); except IOError:; if allvital:; raise ValidationError('Aborting upon output file \'%s.out\' not found.\n' % (sowout)); else:; ValidationError('Aborting upon output file \'%s.out\' not found.\n' % (sowout)); return 0.0; else:; while True:; line = freagent.readline(); if not line:; if E == 0.0:; if allvital:; raise ValidationError('Aborting upon output file \'%s.out\' has no %s RESULT line.\n' % (sowout, quantity)); else:; ValidationError('Aborting upon output file \'%s.out\' has no %s RESULT line.\n' % (sowout, quantity)); break; s = line.split(); if (len(s) != 0) and (s[0:3] == [quantity, 'RESULT:', 'computation']):; if int(s[3]) != linkage:; raise ValidationError('Output file \'%s.out\' has linkage %s incompatible with master.in linkage %s.'; % (sowout, str(s[3]), str(linkage))); if s[6] != str(sownum + 1):; raise ValidationError('Output file \'%s.out\' has nominal affiliation %s incompatible with item %s.'; % (sowout, s[6], str(sownum + 1))); if (s[8:10] == ['electronic', 'energy']):; E = float(s[10]); psi4.print_out('%s RESULT: electronic energy = %20.12f\n' % (quantity, E)); freagent.close(); return E. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  ; PSI4 [beta5]  ; Module code .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/_modules/p4util/procutil.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/p4util/procutil.html
https://psicode.org/psi4manual/4.0b5/_modules/p4util/procutil.html:8099,Energy Efficiency,energy,energy,8099,"lse):; """"""Function to examine file *sowout* from a sow/reap distributed job; for formatted line with electronic energy information about index; *sownum* to be used for construction of *quantity* computations as; directed by master input file with *linkage* kwarg. When file *sowout*; is missing or incomplete files, function will either return zero; (*allvital* is ``False``) or terminate (*allvital* is ``True``) since; some sow/reap procedures can produce meaningful results (database); from an incomplete set of sown files, while others cannot (gradient,; hessian). """"""; E = 0.0. try:; freagent = open('%s.out' % (sowout), 'r'); except IOError:; if allvital:; raise ValidationError('Aborting upon output file \'%s.out\' not found.\n' % (sowout)); else:; ValidationError('Aborting upon output file \'%s.out\' not found.\n' % (sowout)); return 0.0; else:; while True:; line = freagent.readline(); if not line:; if E == 0.0:; if allvital:; raise ValidationError('Aborting upon output file \'%s.out\' has no %s RESULT line.\n' % (sowout, quantity)); else:; ValidationError('Aborting upon output file \'%s.out\' has no %s RESULT line.\n' % (sowout, quantity)); break; s = line.split(); if (len(s) != 0) and (s[0:3] == [quantity, 'RESULT:', 'computation']):; if int(s[3]) != linkage:; raise ValidationError('Output file \'%s.out\' has linkage %s incompatible with master.in linkage %s.'; % (sowout, str(s[3]), str(linkage))); if s[6] != str(sownum + 1):; raise ValidationError('Output file \'%s.out\' has nominal affiliation %s incompatible with item %s.'; % (sowout, s[6], str(sownum + 1))); if (s[8:10] == ['electronic', 'energy']):; E = float(s[10]); psi4.print_out('%s RESULT: electronic energy = %20.12f\n' % (quantity, E)); freagent.close(); return E. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  ; PSI4 [beta5]  ; Module code .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/_modules/p4util/procutil.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/p4util/procutil.html
https://psicode.org/psi4manual/4.0b5/_modules/p4util/procutil.html:4849,Performance,load,loads,4849,"hgdoptval = psi4.get_global_option(chgdopt); if isinstance(chgdoptval, basestring):; commands += """"""psi4.set_global_option('%s', '%s')\n"""""" % (chgdopt, chgdoptval); elif isinstance(chgdoptval, int) or isinstance(chgdoptval, float):; commands += """"""psi4.set_global_option('%s', %s)\n"""""" % (chgdopt, chgdoptval); else:; raise ValidationError('Option \'%s\' is not of a type (string, int, float, bool) that can be processed.' % (chgdopt)); return commands. [docs]def format_kwargs_for_input(filename, lmode=1, **kwargs):; """"""Function to pickle to file *filename* the options dictionary; *kwargs*. Mode *lmode* =2 pickles appropriate settings for; reap mode. Used to capture Python options information for; distributed (sow/reap) input files. """"""; if lmode == 2:; kwargs['mode'] = 'reap'; kwargs['linkage'] = os.getpid(); filename.write('''\npickle_kw = (""""""'''); pickle.dump(kwargs, filename); filename.write('''"""""")\n'''); filename.write(""""""\nkwargs = pickle.loads(pickle_kw)\n""""""); if lmode == 2:; kwargs['mode'] = 'sow'; del kwargs['linkage']. [docs]def drop_duplicates(seq):; """"""Function that given an array *seq*, returns an array without any duplicate; entries. There is no guarantee of which duplicate entry is dropped. """"""; noDupes = []; [noDupes.append(i) for i in seq if not noDupes.count(i)]; return noDupes. [docs]def all_casings(input_string):; """"""Function to return a generator of all lettercase permutations; of *input_string*. """"""; if not input_string:; yield """"; else:; first = input_string[:1]; if first.lower() == first.upper():; for sub_casing in all_casings(input_string[1:]):; yield first + sub_casing; else:; for sub_casing in all_casings(input_string[1:]):; yield first.lower() + sub_casing; yield first.upper() + sub_casing. [docs]def getattr_ignorecase(module, attr):; """"""Function to extract attribute *attr* from *module* if *attr*; is available in any possible lettercase permutation. Returns; attribute if available, None if not. """"""; array = None; for per in list(all_casin",MatchSource.WIKI,psi4manual/4.0b5/_modules/p4util/procutil.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/p4util/procutil.html
https://psicode.org/psi4manual/4.0b5/_modules/p4util/procutil.html:7096,Safety,Abort,Aborting,7096,"import *module* in any possible lettercase; permutation. Returns module object if available, None if not. """"""; modobj = None; for per in list(all_casings(module)):; try:; modobj = __import__(per); except ImportError:; pass; else:; break. return modobj. [docs]def extract_sowreap_from_output(sowout, quantity, sownum, linkage, allvital=False):; """"""Function to examine file *sowout* from a sow/reap distributed job; for formatted line with electronic energy information about index; *sownum* to be used for construction of *quantity* computations as; directed by master input file with *linkage* kwarg. When file *sowout*; is missing or incomplete files, function will either return zero; (*allvital* is ``False``) or terminate (*allvital* is ``True``) since; some sow/reap procedures can produce meaningful results (database); from an incomplete set of sown files, while others cannot (gradient,; hessian). """"""; E = 0.0. try:; freagent = open('%s.out' % (sowout), 'r'); except IOError:; if allvital:; raise ValidationError('Aborting upon output file \'%s.out\' not found.\n' % (sowout)); else:; ValidationError('Aborting upon output file \'%s.out\' not found.\n' % (sowout)); return 0.0; else:; while True:; line = freagent.readline(); if not line:; if E == 0.0:; if allvital:; raise ValidationError('Aborting upon output file \'%s.out\' has no %s RESULT line.\n' % (sowout, quantity)); else:; ValidationError('Aborting upon output file \'%s.out\' has no %s RESULT line.\n' % (sowout, quantity)); break; s = line.split(); if (len(s) != 0) and (s[0:3] == [quantity, 'RESULT:', 'computation']):; if int(s[3]) != linkage:; raise ValidationError('Output file \'%s.out\' has linkage %s incompatible with master.in linkage %s.'; % (sowout, str(s[3]), str(linkage))); if s[6] != str(sownum + 1):; raise ValidationError('Output file \'%s.out\' has nominal affiliation %s incompatible with item %s.'; % (sowout, s[6], str(sownum + 1))); if (s[8:10] == ['electronic', 'energy']):; E = float(s[10]); psi4.print_o",MatchSource.WIKI,psi4manual/4.0b5/_modules/p4util/procutil.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/p4util/procutil.html
https://psicode.org/psi4manual/4.0b5/_modules/p4util/procutil.html:7184,Safety,Abort,Aborting,7184,"""""""; modobj = None; for per in list(all_casings(module)):; try:; modobj = __import__(per); except ImportError:; pass; else:; break. return modobj. [docs]def extract_sowreap_from_output(sowout, quantity, sownum, linkage, allvital=False):; """"""Function to examine file *sowout* from a sow/reap distributed job; for formatted line with electronic energy information about index; *sownum* to be used for construction of *quantity* computations as; directed by master input file with *linkage* kwarg. When file *sowout*; is missing or incomplete files, function will either return zero; (*allvital* is ``False``) or terminate (*allvital* is ``True``) since; some sow/reap procedures can produce meaningful results (database); from an incomplete set of sown files, while others cannot (gradient,; hessian). """"""; E = 0.0. try:; freagent = open('%s.out' % (sowout), 'r'); except IOError:; if allvital:; raise ValidationError('Aborting upon output file \'%s.out\' not found.\n' % (sowout)); else:; ValidationError('Aborting upon output file \'%s.out\' not found.\n' % (sowout)); return 0.0; else:; while True:; line = freagent.readline(); if not line:; if E == 0.0:; if allvital:; raise ValidationError('Aborting upon output file \'%s.out\' has no %s RESULT line.\n' % (sowout, quantity)); else:; ValidationError('Aborting upon output file \'%s.out\' has no %s RESULT line.\n' % (sowout, quantity)); break; s = line.split(); if (len(s) != 0) and (s[0:3] == [quantity, 'RESULT:', 'computation']):; if int(s[3]) != linkage:; raise ValidationError('Output file \'%s.out\' has linkage %s incompatible with master.in linkage %s.'; % (sowout, str(s[3]), str(linkage))); if s[6] != str(sownum + 1):; raise ValidationError('Output file \'%s.out\' has nominal affiliation %s incompatible with item %s.'; % (sowout, s[6], str(sownum + 1))); if (s[8:10] == ['electronic', 'energy']):; E = float(s[10]); psi4.print_out('%s RESULT: electronic energy = %20.12f\n' % (quantity, E)); freagent.close(); return E. Quick search. ",MatchSource.WIKI,psi4manual/4.0b5/_modules/p4util/procutil.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/p4util/procutil.html
https://psicode.org/psi4manual/4.0b5/_modules/p4util/procutil.html:7373,Safety,Abort,Aborting,7373,"ut, quantity, sownum, linkage, allvital=False):; """"""Function to examine file *sowout* from a sow/reap distributed job; for formatted line with electronic energy information about index; *sownum* to be used for construction of *quantity* computations as; directed by master input file with *linkage* kwarg. When file *sowout*; is missing or incomplete files, function will either return zero; (*allvital* is ``False``) or terminate (*allvital* is ``True``) since; some sow/reap procedures can produce meaningful results (database); from an incomplete set of sown files, while others cannot (gradient,; hessian). """"""; E = 0.0. try:; freagent = open('%s.out' % (sowout), 'r'); except IOError:; if allvital:; raise ValidationError('Aborting upon output file \'%s.out\' not found.\n' % (sowout)); else:; ValidationError('Aborting upon output file \'%s.out\' not found.\n' % (sowout)); return 0.0; else:; while True:; line = freagent.readline(); if not line:; if E == 0.0:; if allvital:; raise ValidationError('Aborting upon output file \'%s.out\' has no %s RESULT line.\n' % (sowout, quantity)); else:; ValidationError('Aborting upon output file \'%s.out\' has no %s RESULT line.\n' % (sowout, quantity)); break; s = line.split(); if (len(s) != 0) and (s[0:3] == [quantity, 'RESULT:', 'computation']):; if int(s[3]) != linkage:; raise ValidationError('Output file \'%s.out\' has linkage %s incompatible with master.in linkage %s.'; % (sowout, str(s[3]), str(linkage))); if s[6] != str(sownum + 1):; raise ValidationError('Output file \'%s.out\' has nominal affiliation %s incompatible with item %s.'; % (sowout, s[6], str(sownum + 1))); if (s[8:10] == ['electronic', 'energy']):; E = float(s[10]); psi4.print_out('%s RESULT: electronic energy = %20.12f\n' % (quantity, E)); freagent.close(); return E. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  ; PSI4 [beta5]  ; Module code .  Copyright 2013, The Psi4 Project.; Last updated on Jul ",MatchSource.WIKI,psi4manual/4.0b5/_modules/p4util/procutil.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/p4util/procutil.html
https://psicode.org/psi4manual/4.0b5/_modules/p4util/procutil.html:7483,Safety,Abort,Aborting,7483,"lse):; """"""Function to examine file *sowout* from a sow/reap distributed job; for formatted line with electronic energy information about index; *sownum* to be used for construction of *quantity* computations as; directed by master input file with *linkage* kwarg. When file *sowout*; is missing or incomplete files, function will either return zero; (*allvital* is ``False``) or terminate (*allvital* is ``True``) since; some sow/reap procedures can produce meaningful results (database); from an incomplete set of sown files, while others cannot (gradient,; hessian). """"""; E = 0.0. try:; freagent = open('%s.out' % (sowout), 'r'); except IOError:; if allvital:; raise ValidationError('Aborting upon output file \'%s.out\' not found.\n' % (sowout)); else:; ValidationError('Aborting upon output file \'%s.out\' not found.\n' % (sowout)); return 0.0; else:; while True:; line = freagent.readline(); if not line:; if E == 0.0:; if allvital:; raise ValidationError('Aborting upon output file \'%s.out\' has no %s RESULT line.\n' % (sowout, quantity)); else:; ValidationError('Aborting upon output file \'%s.out\' has no %s RESULT line.\n' % (sowout, quantity)); break; s = line.split(); if (len(s) != 0) and (s[0:3] == [quantity, 'RESULT:', 'computation']):; if int(s[3]) != linkage:; raise ValidationError('Output file \'%s.out\' has linkage %s incompatible with master.in linkage %s.'; % (sowout, str(s[3]), str(linkage))); if s[6] != str(sownum + 1):; raise ValidationError('Output file \'%s.out\' has nominal affiliation %s incompatible with item %s.'; % (sowout, s[6], str(sownum + 1))); if (s[8:10] == ['electronic', 'energy']):; E = float(s[10]); psi4.print_out('%s RESULT: electronic energy = %20.12f\n' % (quantity, E)); freagent.close(); return E. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  ; PSI4 [beta5]  ; Module code .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/_modules/p4util/procutil.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/p4util/procutil.html
https://psicode.org/psi4manual/4.0b5/_modules/p4util/procutil.html:4216,Security,Validat,ValidationError,4216,"(""""""\nmolecule %s {\n%s\n}\n"""""", 0)\n' % (mol_name, mol_string); return eval(commands). [docs]def format_options_for_input():; """"""Function to return a string of commands to replicate the; current state of user-modified options. Used to capture C++; options information for distributed (sow/reap) input files. .. caution:: Some features are not yet implemented. Buy a developer a coffee. - Does not cover local (as opposed to global) options. - Does not work with array-type options. """"""; commands = ''; commands += """"""\npsi4.set_memory(%s)\n\n"""""" % (psi4.get_memory()); for chgdopt in psi4.get_global_option_list():; if psi4.has_global_option_changed(chgdopt):; chgdoptval = psi4.get_global_option(chgdopt); if isinstance(chgdoptval, basestring):; commands += """"""psi4.set_global_option('%s', '%s')\n"""""" % (chgdopt, chgdoptval); elif isinstance(chgdoptval, int) or isinstance(chgdoptval, float):; commands += """"""psi4.set_global_option('%s', %s)\n"""""" % (chgdopt, chgdoptval); else:; raise ValidationError('Option \'%s\' is not of a type (string, int, float, bool) that can be processed.' % (chgdopt)); return commands. [docs]def format_kwargs_for_input(filename, lmode=1, **kwargs):; """"""Function to pickle to file *filename* the options dictionary; *kwargs*. Mode *lmode* =2 pickles appropriate settings for; reap mode. Used to capture Python options information for; distributed (sow/reap) input files. """"""; if lmode == 2:; kwargs['mode'] = 'reap'; kwargs['linkage'] = os.getpid(); filename.write('''\npickle_kw = (""""""'''); pickle.dump(kwargs, filename); filename.write('''"""""")\n'''); filename.write(""""""\nkwargs = pickle.loads(pickle_kw)\n""""""); if lmode == 2:; kwargs['mode'] = 'sow'; del kwargs['linkage']. [docs]def drop_duplicates(seq):; """"""Function that given an array *seq*, returns an array without any duplicate; entries. There is no guarantee of which duplicate entry is dropped. """"""; noDupes = []; [noDupes.append(i) for i in seq if not noDupes.count(i)]; return noDupes. [docs]def all_casing",MatchSource.WIKI,psi4manual/4.0b5/_modules/p4util/procutil.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/p4util/procutil.html
https://psicode.org/psi4manual/4.0b5/_modules/p4util/procutil.html:7079,Security,Validat,ValidationError,7079,"import *module* in any possible lettercase; permutation. Returns module object if available, None if not. """"""; modobj = None; for per in list(all_casings(module)):; try:; modobj = __import__(per); except ImportError:; pass; else:; break. return modobj. [docs]def extract_sowreap_from_output(sowout, quantity, sownum, linkage, allvital=False):; """"""Function to examine file *sowout* from a sow/reap distributed job; for formatted line with electronic energy information about index; *sownum* to be used for construction of *quantity* computations as; directed by master input file with *linkage* kwarg. When file *sowout*; is missing or incomplete files, function will either return zero; (*allvital* is ``False``) or terminate (*allvital* is ``True``) since; some sow/reap procedures can produce meaningful results (database); from an incomplete set of sown files, while others cannot (gradient,; hessian). """"""; E = 0.0. try:; freagent = open('%s.out' % (sowout), 'r'); except IOError:; if allvital:; raise ValidationError('Aborting upon output file \'%s.out\' not found.\n' % (sowout)); else:; ValidationError('Aborting upon output file \'%s.out\' not found.\n' % (sowout)); return 0.0; else:; while True:; line = freagent.readline(); if not line:; if E == 0.0:; if allvital:; raise ValidationError('Aborting upon output file \'%s.out\' has no %s RESULT line.\n' % (sowout, quantity)); else:; ValidationError('Aborting upon output file \'%s.out\' has no %s RESULT line.\n' % (sowout, quantity)); break; s = line.split(); if (len(s) != 0) and (s[0:3] == [quantity, 'RESULT:', 'computation']):; if int(s[3]) != linkage:; raise ValidationError('Output file \'%s.out\' has linkage %s incompatible with master.in linkage %s.'; % (sowout, str(s[3]), str(linkage))); if s[6] != str(sownum + 1):; raise ValidationError('Output file \'%s.out\' has nominal affiliation %s incompatible with item %s.'; % (sowout, s[6], str(sownum + 1))); if (s[8:10] == ['electronic', 'energy']):; E = float(s[10]); psi4.print_o",MatchSource.WIKI,psi4manual/4.0b5/_modules/p4util/procutil.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/p4util/procutil.html
https://psicode.org/psi4manual/4.0b5/_modules/p4util/procutil.html:7167,Security,Validat,ValidationError,7167,"""""""; modobj = None; for per in list(all_casings(module)):; try:; modobj = __import__(per); except ImportError:; pass; else:; break. return modobj. [docs]def extract_sowreap_from_output(sowout, quantity, sownum, linkage, allvital=False):; """"""Function to examine file *sowout* from a sow/reap distributed job; for formatted line with electronic energy information about index; *sownum* to be used for construction of *quantity* computations as; directed by master input file with *linkage* kwarg. When file *sowout*; is missing or incomplete files, function will either return zero; (*allvital* is ``False``) or terminate (*allvital* is ``True``) since; some sow/reap procedures can produce meaningful results (database); from an incomplete set of sown files, while others cannot (gradient,; hessian). """"""; E = 0.0. try:; freagent = open('%s.out' % (sowout), 'r'); except IOError:; if allvital:; raise ValidationError('Aborting upon output file \'%s.out\' not found.\n' % (sowout)); else:; ValidationError('Aborting upon output file \'%s.out\' not found.\n' % (sowout)); return 0.0; else:; while True:; line = freagent.readline(); if not line:; if E == 0.0:; if allvital:; raise ValidationError('Aborting upon output file \'%s.out\' has no %s RESULT line.\n' % (sowout, quantity)); else:; ValidationError('Aborting upon output file \'%s.out\' has no %s RESULT line.\n' % (sowout, quantity)); break; s = line.split(); if (len(s) != 0) and (s[0:3] == [quantity, 'RESULT:', 'computation']):; if int(s[3]) != linkage:; raise ValidationError('Output file \'%s.out\' has linkage %s incompatible with master.in linkage %s.'; % (sowout, str(s[3]), str(linkage))); if s[6] != str(sownum + 1):; raise ValidationError('Output file \'%s.out\' has nominal affiliation %s incompatible with item %s.'; % (sowout, s[6], str(sownum + 1))); if (s[8:10] == ['electronic', 'energy']):; E = float(s[10]); psi4.print_out('%s RESULT: electronic energy = %20.12f\n' % (quantity, E)); freagent.close(); return E. Quick search. ",MatchSource.WIKI,psi4manual/4.0b5/_modules/p4util/procutil.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/p4util/procutil.html
https://psicode.org/psi4manual/4.0b5/_modules/p4util/procutil.html:7356,Security,Validat,ValidationError,7356,"ut, quantity, sownum, linkage, allvital=False):; """"""Function to examine file *sowout* from a sow/reap distributed job; for formatted line with electronic energy information about index; *sownum* to be used for construction of *quantity* computations as; directed by master input file with *linkage* kwarg. When file *sowout*; is missing or incomplete files, function will either return zero; (*allvital* is ``False``) or terminate (*allvital* is ``True``) since; some sow/reap procedures can produce meaningful results (database); from an incomplete set of sown files, while others cannot (gradient,; hessian). """"""; E = 0.0. try:; freagent = open('%s.out' % (sowout), 'r'); except IOError:; if allvital:; raise ValidationError('Aborting upon output file \'%s.out\' not found.\n' % (sowout)); else:; ValidationError('Aborting upon output file \'%s.out\' not found.\n' % (sowout)); return 0.0; else:; while True:; line = freagent.readline(); if not line:; if E == 0.0:; if allvital:; raise ValidationError('Aborting upon output file \'%s.out\' has no %s RESULT line.\n' % (sowout, quantity)); else:; ValidationError('Aborting upon output file \'%s.out\' has no %s RESULT line.\n' % (sowout, quantity)); break; s = line.split(); if (len(s) != 0) and (s[0:3] == [quantity, 'RESULT:', 'computation']):; if int(s[3]) != linkage:; raise ValidationError('Output file \'%s.out\' has linkage %s incompatible with master.in linkage %s.'; % (sowout, str(s[3]), str(linkage))); if s[6] != str(sownum + 1):; raise ValidationError('Output file \'%s.out\' has nominal affiliation %s incompatible with item %s.'; % (sowout, s[6], str(sownum + 1))); if (s[8:10] == ['electronic', 'energy']):; E = float(s[10]); psi4.print_out('%s RESULT: electronic energy = %20.12f\n' % (quantity, E)); freagent.close(); return E. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  ; PSI4 [beta5]  ; Module code .  Copyright 2013, The Psi4 Project.; Last updated on Jul ",MatchSource.WIKI,psi4manual/4.0b5/_modules/p4util/procutil.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/p4util/procutil.html
https://psicode.org/psi4manual/4.0b5/_modules/p4util/procutil.html:7466,Security,Validat,ValidationError,7466,"lse):; """"""Function to examine file *sowout* from a sow/reap distributed job; for formatted line with electronic energy information about index; *sownum* to be used for construction of *quantity* computations as; directed by master input file with *linkage* kwarg. When file *sowout*; is missing or incomplete files, function will either return zero; (*allvital* is ``False``) or terminate (*allvital* is ``True``) since; some sow/reap procedures can produce meaningful results (database); from an incomplete set of sown files, while others cannot (gradient,; hessian). """"""; E = 0.0. try:; freagent = open('%s.out' % (sowout), 'r'); except IOError:; if allvital:; raise ValidationError('Aborting upon output file \'%s.out\' not found.\n' % (sowout)); else:; ValidationError('Aborting upon output file \'%s.out\' not found.\n' % (sowout)); return 0.0; else:; while True:; line = freagent.readline(); if not line:; if E == 0.0:; if allvital:; raise ValidationError('Aborting upon output file \'%s.out\' has no %s RESULT line.\n' % (sowout, quantity)); else:; ValidationError('Aborting upon output file \'%s.out\' has no %s RESULT line.\n' % (sowout, quantity)); break; s = line.split(); if (len(s) != 0) and (s[0:3] == [quantity, 'RESULT:', 'computation']):; if int(s[3]) != linkage:; raise ValidationError('Output file \'%s.out\' has linkage %s incompatible with master.in linkage %s.'; % (sowout, str(s[3]), str(linkage))); if s[6] != str(sownum + 1):; raise ValidationError('Output file \'%s.out\' has nominal affiliation %s incompatible with item %s.'; % (sowout, s[6], str(sownum + 1))); if (s[8:10] == ['electronic', 'energy']):; E = float(s[10]); psi4.print_out('%s RESULT: electronic energy = %20.12f\n' % (quantity, E)); freagent.close(); return E. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  ; PSI4 [beta5]  ; Module code .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/_modules/p4util/procutil.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/p4util/procutil.html
https://psicode.org/psi4manual/4.0b5/_modules/p4util/procutil.html:7698,Security,Validat,ValidationError,7698,"lse):; """"""Function to examine file *sowout* from a sow/reap distributed job; for formatted line with electronic energy information about index; *sownum* to be used for construction of *quantity* computations as; directed by master input file with *linkage* kwarg. When file *sowout*; is missing or incomplete files, function will either return zero; (*allvital* is ``False``) or terminate (*allvital* is ``True``) since; some sow/reap procedures can produce meaningful results (database); from an incomplete set of sown files, while others cannot (gradient,; hessian). """"""; E = 0.0. try:; freagent = open('%s.out' % (sowout), 'r'); except IOError:; if allvital:; raise ValidationError('Aborting upon output file \'%s.out\' not found.\n' % (sowout)); else:; ValidationError('Aborting upon output file \'%s.out\' not found.\n' % (sowout)); return 0.0; else:; while True:; line = freagent.readline(); if not line:; if E == 0.0:; if allvital:; raise ValidationError('Aborting upon output file \'%s.out\' has no %s RESULT line.\n' % (sowout, quantity)); else:; ValidationError('Aborting upon output file \'%s.out\' has no %s RESULT line.\n' % (sowout, quantity)); break; s = line.split(); if (len(s) != 0) and (s[0:3] == [quantity, 'RESULT:', 'computation']):; if int(s[3]) != linkage:; raise ValidationError('Output file \'%s.out\' has linkage %s incompatible with master.in linkage %s.'; % (sowout, str(s[3]), str(linkage))); if s[6] != str(sownum + 1):; raise ValidationError('Output file \'%s.out\' has nominal affiliation %s incompatible with item %s.'; % (sowout, s[6], str(sownum + 1))); if (s[8:10] == ['electronic', 'energy']):; E = float(s[10]); psi4.print_out('%s RESULT: electronic energy = %20.12f\n' % (quantity, E)); freagent.close(); return E. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  ; PSI4 [beta5]  ; Module code .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/_modules/p4util/procutil.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/p4util/procutil.html
https://psicode.org/psi4manual/4.0b5/_modules/p4util/procutil.html:7868,Security,Validat,ValidationError,7868,"lse):; """"""Function to examine file *sowout* from a sow/reap distributed job; for formatted line with electronic energy information about index; *sownum* to be used for construction of *quantity* computations as; directed by master input file with *linkage* kwarg. When file *sowout*; is missing or incomplete files, function will either return zero; (*allvital* is ``False``) or terminate (*allvital* is ``True``) since; some sow/reap procedures can produce meaningful results (database); from an incomplete set of sown files, while others cannot (gradient,; hessian). """"""; E = 0.0. try:; freagent = open('%s.out' % (sowout), 'r'); except IOError:; if allvital:; raise ValidationError('Aborting upon output file \'%s.out\' not found.\n' % (sowout)); else:; ValidationError('Aborting upon output file \'%s.out\' not found.\n' % (sowout)); return 0.0; else:; while True:; line = freagent.readline(); if not line:; if E == 0.0:; if allvital:; raise ValidationError('Aborting upon output file \'%s.out\' has no %s RESULT line.\n' % (sowout, quantity)); else:; ValidationError('Aborting upon output file \'%s.out\' has no %s RESULT line.\n' % (sowout, quantity)); break; s = line.split(); if (len(s) != 0) and (s[0:3] == [quantity, 'RESULT:', 'computation']):; if int(s[3]) != linkage:; raise ValidationError('Output file \'%s.out\' has linkage %s incompatible with master.in linkage %s.'; % (sowout, str(s[3]), str(linkage))); if s[6] != str(sownum + 1):; raise ValidationError('Output file \'%s.out\' has nominal affiliation %s incompatible with item %s.'; % (sowout, s[6], str(sownum + 1))); if (s[8:10] == ['electronic', 'energy']):; E = float(s[10]); psi4.print_out('%s RESULT: electronic energy = %20.12f\n' % (quantity, E)); freagent.close(); return E. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  ; PSI4 [beta5]  ; Module code .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/_modules/p4util/procutil.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/p4util/procutil.html
https://psicode.org/psi4manual/4.0b5/_modules/p4util/text.html:5104,Availability,error,error,5104,"he Table object; such that the lowest value is zero. A scaling factor of *Factor* is applied. """"""; import copy. if len(self.data) == 0:; return. current_min = list(copy.deepcopy(self.data[0][1])); for datarow in self.data:; for col in range(0, len(datarow[1])):; if current_min[col] > datarow[1][col]:; current_min[col] = datarow[1][col]. for datarow in self.data:; for col in range(0, len(datarow[1])):; #print datarow[1][col]; datarow[1][col] = (datarow[1][col] - current_min[col]) * Factor. [docs] def scale(self, Factor=p4const.psi_hartree2kcalmol):; """"""Function to apply a scaling factor *Factor* to the; data of the Table object. """"""; if len(self.data) == 0:; return. for datarow in self.data:; for col in range(0, len(datarow[1])):; #print datarow[1][col]; datarow[1][col] = datarow[1][col] * Factor. [docs]def banner(text, type=1, width=35):; """"""Function to print *text* to output file in a banner of; minimum width *width* and minimum three-line height for; *type* = 1 or one-line height for *type* = 2. """"""; lines = text.split('\n'); max_length = 0; for line in lines:; if (len(line) > max_length):; max_length = len(line). max_length = max([width, max_length]). null = ''; if type == 1:; banner = ' //' + null.center(max_length, '>') + '//\n'; for line in lines:; banner += ' //' + line.center(max_length) + '//\n'; banner += ' //' + null.center(max_length, '<') + '//\n'. if type == 2:; banner = ''; for line in lines:; banner += (' ' + line + ' ').center(max_length, '='). psi4.print_out(banner). [docs]def print_stdout(stuff):; """"""Function to print *stuff* to standard output stream.""""""; print(stuff, file=sys.stdout). [docs]def print_stderr(stuff):; """"""Function to print *stuff* to standard error stream.""""""; print(stuff, file=sys.stderr). Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  ; PSI4 [beta5]  ; Module code .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/_modules/p4util/text.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/p4util/text.html
https://psicode.org/psi4manual/4.0b5/_modules/p4util/text.html:5341,Deployability,update,updated,5341,"he Table object; such that the lowest value is zero. A scaling factor of *Factor* is applied. """"""; import copy. if len(self.data) == 0:; return. current_min = list(copy.deepcopy(self.data[0][1])); for datarow in self.data:; for col in range(0, len(datarow[1])):; if current_min[col] > datarow[1][col]:; current_min[col] = datarow[1][col]. for datarow in self.data:; for col in range(0, len(datarow[1])):; #print datarow[1][col]; datarow[1][col] = (datarow[1][col] - current_min[col]) * Factor. [docs] def scale(self, Factor=p4const.psi_hartree2kcalmol):; """"""Function to apply a scaling factor *Factor* to the; data of the Table object. """"""; if len(self.data) == 0:; return. for datarow in self.data:; for col in range(0, len(datarow[1])):; #print datarow[1][col]; datarow[1][col] = datarow[1][col] * Factor. [docs]def banner(text, type=1, width=35):; """"""Function to print *text* to output file in a banner of; minimum width *width* and minimum three-line height for; *type* = 1 or one-line height for *type* = 2. """"""; lines = text.split('\n'); max_length = 0; for line in lines:; if (len(line) > max_length):; max_length = len(line). max_length = max([width, max_length]). null = ''; if type == 1:; banner = ' //' + null.center(max_length, '>') + '//\n'; for line in lines:; banner += ' //' + line.center(max_length) + '//\n'; banner += ' //' + null.center(max_length, '<') + '//\n'. if type == 2:; banner = ''; for line in lines:; banner += (' ' + line + ' ').center(max_length, '='). psi4.print_out(banner). [docs]def print_stdout(stuff):; """"""Function to print *stuff* to standard output stream.""""""; print(stuff, file=sys.stdout). [docs]def print_stderr(stuff):; """"""Function to print *stuff* to standard error stream.""""""; print(stuff, file=sys.stderr). Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  ; PSI4 [beta5]  ; Module code .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/_modules/p4util/text.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/p4util/text.html
https://psicode.org/psi4manual/4.0b5/_modules/p4util/text.html:1219,Modifiability,flexible,flexible,1219,"are package; #; # This program is free software; you can redistribute it and/or modify; # it under the terms of the GNU General Public License as published by; # the Free Software Foundation; either version 2 of the License, or; # (at your option) any later version.; #; # This program is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU General Public License for more details.; #; # You should have received a copy of the GNU General Public License along; # with this program; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; #@END LICENSE; #. from __future__ import print_function; """"""Module with utility classes and functions related; to data tables and text. """"""; import psi4; import sys; import re; import p4const; from psiexceptions import *. [docs]class Table(object):; """"""Class defining a flexible Table object for storing data."""""". def __init__(self, rows=(),; row_label_width=10,; row_label_precision=4,; cols=(),; width=16, precision=10):; self.row_label_width = row_label_width; self.row_label_precision = row_label_precision; self.width = width; self.precision = precision; self.rows = rows. if isinstance(cols, str):; self.cols = (cols,); else:; self.cols = cols. self.labels = []; self.data = []. [docs] def format_label(self):; """"""Function to pad the width of Table object labels.""""""; #str = lambda x: (('%%%d.%df' % (self.row_label_width, self.row_label_precision)) % x); str = lambda x: (('%%%ds' % (self.row_label_width)) % x); return "" "".join(map(str, self.labels)). [docs] def format_values(self, values):; """"""Function to pad the width of Table object data cells.""""""; str = lambda x: (('%%%d.%df' % (self.width, self.precision)) % x); return "" "".join(map(str, values)). def __getitem__(self, value):; self.labels.append(value); return self. def __setitem__(self, name, va",MatchSource.WIKI,psi4manual/4.0b5/_modules/p4util/text.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/p4util/text.html
https://psicode.org/psi4manual/4.0b5/_modules/p4util/util.html:2198,Availability,failure,failure,2198,"set_title(kwargs['title']); for prop in args:; oe.add(prop); oe.compute(). [docs]def set_memory(bytes):; """"""Function to reset the total memory allocation.""""""; psi4.set_memory(bytes). [docs]def get_memory():; """"""Function to return the total memory allocation.""""""; return psi4.get_memory(). [docs]def set_num_threads(nthread):; """"""Function to reset the number of threads to parallelize across.""""""; psi4.set_nthread(nthread). [docs]def get_num_threads():; """"""Function to return the number of threads to parallelize across.""""""; return psi4.nthread(). [docs]def success(label):; """"""Function to print a '*label*...PASSED' line to screen.; Used by :py:func:`util.compare_values` family when functions pass. """"""; print('\t{0:.<66}PASSED'.format(label)); sys.stdout.flush(). # Test functions; [docs]def compare_values(expected, computed, digits, label):; """"""Function to compare two values. Prints :py:func:`util.success`; when value *computed* matches value *expected* to number of *digits*.; Performs a system exit on failure. Used in input files in the test suite. """"""; if (abs(expected - computed) > 10 ** (-digits)):; print((""\t%s: computed value (%."" + str(digits+1) + ""f) does not match (%."" + str(digits+1) + ""f) to %d decimal places."") % (label, computed, expected, digits)); sys.exit(1); if ( math.isnan(computed) ):; print(""\t%s: computed value (%f) does not match (%f) to %d decimal places.\n"" % (label, computed, expected, digits)); print(""\tprobably because the computed value is nan.""); sys.exit(1); success(label). [docs]def compare_integers(expected, computed, label):; """"""Function to compare two integers. Prints :py:func:`util.success`; when value *computed* matches value *expected*.; Performs a system exit on failure. Used in input files in the test suite. """"""; if (expected != computed):; print(""\t%s: computed value (%d) does not match (%d)."" % (label, computed, expected)); sys.exit(1); success(label). [docs]def compare_strings(expected, computed, label):; """"""Function to compare two ",MatchSource.WIKI,psi4manual/4.0b5/_modules/p4util/util.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/p4util/util.html
https://psicode.org/psi4manual/4.0b5/_modules/p4util/util.html:2909,Availability,failure,failure,2909,"'\t{0:.<66}PASSED'.format(label)); sys.stdout.flush(). # Test functions; [docs]def compare_values(expected, computed, digits, label):; """"""Function to compare two values. Prints :py:func:`util.success`; when value *computed* matches value *expected* to number of *digits*.; Performs a system exit on failure. Used in input files in the test suite. """"""; if (abs(expected - computed) > 10 ** (-digits)):; print((""\t%s: computed value (%."" + str(digits+1) + ""f) does not match (%."" + str(digits+1) + ""f) to %d decimal places."") % (label, computed, expected, digits)); sys.exit(1); if ( math.isnan(computed) ):; print(""\t%s: computed value (%f) does not match (%f) to %d decimal places.\n"" % (label, computed, expected, digits)); print(""\tprobably because the computed value is nan.""); sys.exit(1); success(label). [docs]def compare_integers(expected, computed, label):; """"""Function to compare two integers. Prints :py:func:`util.success`; when value *computed* matches value *expected*.; Performs a system exit on failure. Used in input files in the test suite. """"""; if (expected != computed):; print(""\t%s: computed value (%d) does not match (%d)."" % (label, computed, expected)); sys.exit(1); success(label). [docs]def compare_strings(expected, computed, label):; """"""Function to compare two strings. Prints :py:func:`util.success`; when string *computed* exactly matches string *expected*.; Performs a system exit on failure. Used in input files in the test suite. """"""; if(expected != computed):; print(""\t%s: computed value (%s) does not match (%s)."" % (label, computed, expected)); sys.exit(1); success(label). [docs]def compare_matrices(expected, computed, digits, label):; """"""Function to compare two matrices. Prints :py:func:`util.success`; when elements of matrix *computed* match elements of matrix *expected* to; number of *digits*. Performs a system exit on failure to match symmetry; structure, dimensions, or element values. Used in input files in the test suite. """"""; if (expected.nirrep() ",MatchSource.WIKI,psi4manual/4.0b5/_modules/p4util/util.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/p4util/util.html
https://psicode.org/psi4manual/4.0b5/_modules/p4util/util.html:3314,Availability,failure,failure,3314,"nt((""\t%s: computed value (%."" + str(digits+1) + ""f) does not match (%."" + str(digits+1) + ""f) to %d decimal places."") % (label, computed, expected, digits)); sys.exit(1); if ( math.isnan(computed) ):; print(""\t%s: computed value (%f) does not match (%f) to %d decimal places.\n"" % (label, computed, expected, digits)); print(""\tprobably because the computed value is nan.""); sys.exit(1); success(label). [docs]def compare_integers(expected, computed, label):; """"""Function to compare two integers. Prints :py:func:`util.success`; when value *computed* matches value *expected*.; Performs a system exit on failure. Used in input files in the test suite. """"""; if (expected != computed):; print(""\t%s: computed value (%d) does not match (%d)."" % (label, computed, expected)); sys.exit(1); success(label). [docs]def compare_strings(expected, computed, label):; """"""Function to compare two strings. Prints :py:func:`util.success`; when string *computed* exactly matches string *expected*.; Performs a system exit on failure. Used in input files in the test suite. """"""; if(expected != computed):; print(""\t%s: computed value (%s) does not match (%s)."" % (label, computed, expected)); sys.exit(1); success(label). [docs]def compare_matrices(expected, computed, digits, label):; """"""Function to compare two matrices. Prints :py:func:`util.success`; when elements of matrix *computed* match elements of matrix *expected* to; number of *digits*. Performs a system exit on failure to match symmetry; structure, dimensions, or element values. Used in input files in the test suite. """"""; if (expected.nirrep() != computed.nirrep()):; print(""\t%s has %d irreps, but %s has %d\n."" % (expected.name(), expected.nirrep(), computed.name(), computed.nirrep())); sys.exit(1); if (expected.symmetry() != computed.symmetry()):; print(""\t%s has %d symmetry, but %s has %d\n."" % (expected.name(), expected.symmetry(), computed.name(), computed.symmetry())); sys.exit(1); nirreps = expected.nirrep(); symmetry = expected.symmet",MatchSource.WIKI,psi4manual/4.0b5/_modules/p4util/util.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/p4util/util.html
https://psicode.org/psi4manual/4.0b5/_modules/p4util/util.html:3764,Availability,failure,failure,3764,"are two integers. Prints :py:func:`util.success`; when value *computed* matches value *expected*.; Performs a system exit on failure. Used in input files in the test suite. """"""; if (expected != computed):; print(""\t%s: computed value (%d) does not match (%d)."" % (label, computed, expected)); sys.exit(1); success(label). [docs]def compare_strings(expected, computed, label):; """"""Function to compare two strings. Prints :py:func:`util.success`; when string *computed* exactly matches string *expected*.; Performs a system exit on failure. Used in input files in the test suite. """"""; if(expected != computed):; print(""\t%s: computed value (%s) does not match (%s)."" % (label, computed, expected)); sys.exit(1); success(label). [docs]def compare_matrices(expected, computed, digits, label):; """"""Function to compare two matrices. Prints :py:func:`util.success`; when elements of matrix *computed* match elements of matrix *expected* to; number of *digits*. Performs a system exit on failure to match symmetry; structure, dimensions, or element values. Used in input files in the test suite. """"""; if (expected.nirrep() != computed.nirrep()):; print(""\t%s has %d irreps, but %s has %d\n."" % (expected.name(), expected.nirrep(), computed.name(), computed.nirrep())); sys.exit(1); if (expected.symmetry() != computed.symmetry()):; print(""\t%s has %d symmetry, but %s has %d\n."" % (expected.name(), expected.symmetry(), computed.name(), computed.symmetry())); sys.exit(1); nirreps = expected.nirrep(); symmetry = expected.symmetry(); for irrep in range(nirreps):; if(expected.rows(irrep) != computed.rows(irrep)):; print(""\t%s has %d rows in irrep %d, but %s has %d\n."" % (expected.name(), expected.rows(irrep), irrep, computed.name(), computed.rows(irrep))); sys.exit(1); if(expected.cols(irrep ^ symmetry) != computed.cols(irrep ^ symmetry)):; print(""\t%s has %d columns in irrep, but %s has %d\n."" % (expected.name(), expected.cols(irrep), irrep, computed.name(), computed.cols(irrep))); sys.exit(1); rows ",MatchSource.WIKI,psi4manual/4.0b5/_modules/p4util/util.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/p4util/util.html
https://psicode.org/psi4manual/4.0b5/_modules/p4util/util.html:5718,Availability,failure,failure,5718,"e(), computed.cols(irrep))); sys.exit(1); rows = expected.rows(irrep); cols = expected.cols(irrep ^ symmetry); failed = 0; for row in range(rows):; for col in range(cols):; if(abs(expected.get(irrep, row, col) - computed.get(irrep, row, col)) > 10 ** (-digits)):; print(""\t%s: computed value (%s) does not match (%s)."" % (label, expected.get(irrep, row, col), computed.get(irrep, row, col))); failed = 1; break. if(failed):; print(""Check your output file for reporting of the matrices.""); psi4.print_out(""The Failed Test Matrices\n""); psi4.print_out(""Computed Matrix (2nd matrix passed in)\n""); computed.print_out(); psi4.print_out(""Expected Matrix (1st matrix passed in)\n""); expected.print_out(); sys.exit(1); success(label). [docs]def compare_vectors(expected, computed, digits, label):; """"""Function to compare two vectors. Prints :py:func:`util.success`; when elements of vector *computed* match elements of vector *expected* to; number of *digits*. Performs a system exit on failure to match symmetry; structure, dimension, or element values. Used in input files in the test suite. """"""; if (expected.nirrep() != computed.nirrep()):; print(""\t%s has %d irreps, but %s has %d\n."" % (expected.name(), expected.nirrep(), computed.name(), computed.nirrep())); sys.exit(1); nirreps = expected.nirrep(); for irrep in range(nirreps):; if(expected.dim(irrep) != computed.dim(irrep)):; print(""\tThe reference has %d entries in irrep %d, but the computed vector has %d\n."" % (expected.dim(irrep), irrep, computed.dim(irrep))); sys.exit(1); dim = expected.dim(irrep); failed = 0; for entry in range(dim):; if(abs(expected.get(irrep, entry) - computed.get(irrep, entry)) > 10 ** (-digits)):; print(""\t%s: computed value (%s) does not match (%s)."" % (label, computed.get(irrep, entry), expected.get(irrep, entry))); failed = 1; break. if(failed):; psi4.print_out(""The computed vector\n""); computed.print_out(); psi4.print_out(""The reference vector\n""); expected.print_out(); sys.exit(1); success(label). [docs",MatchSource.WIKI,psi4manual/4.0b5/_modules/p4util/util.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/p4util/util.html
https://psicode.org/psi4manual/4.0b5/_modules/p4util/util.html:9405,Deployability,update,updated,9405,"2; copy_file_to_scratch('/tmp/temp', 'psi', '', 32, True):; -mv /tmp/temp /scratch/parrish/psi.12345.32. """""". pid = str(os.getpid()); scratch = psi4.IOManager.shared_object().get_file_path(int(unit)). cp = '/bin/cp';; if move:; cp = '/bin/mv';. unit = str(unit). target = ''; target += prefix; target += '.'; target += pid; if len(namespace):; target += '.'; target += namespace; target += '.'; target += unit. command = ('%s %s %s/%s' % (cp, filename, scratch, target)). os.system(command); #print command. [docs]def copy_file_from_scratch(filename, prefix, namespace, unit, move = False):. """"""Function to move file out of scratch with correct naming; convention. Arguments:. @arg filename full path to target file; @arg prefix computation prefix, usually 'psi'; @arg namespace context namespace, usually molecule name; @arg unit unit number, e.g. 32; @arg move copy or move? (default copy). Example:. Assume PID is 12345 and SCRATCH is /scratch/parrish/. copy_file_to_scratch('temp', 'psi', 'h2o', 32):; -cp /scratch/parrish/psi.12345.h2o.32 .temp; copy_file_to_scratch('/tmp/temp', 'psi', 'h2o', 32):; -cp /scratch/parrish/psi.12345.h2o.32 /tmp/temp; copy_file_to_scratch('/tmp/temp', 'psi', '', 32):; -cp /scratch/parrish/psi.12345.32 /tmp/temp; copy_file_to_scratch('/tmp/temp', 'psi', '', 32, True):; -mv /scratch/parrish/psi.12345.32 /tmp/temp. """""". pid = str(os.getpid()); scratch = psi4.IOManager.shared_object().get_file_path(int(unit)). cp = '/bin/cp';; if move:; cp = '/bin/mv';. unit = str(unit). target = ''; target += prefix; target += '.'; target += pid; if len(namespace):; target += '.'; target += namespace; target += '.'; target += unit. command = ('%s %s/%s %s' % (cp, scratch, target, filename)). os.system(command); #print command. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  ; PSI4 [beta5]  ; Module code .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/_modules/p4util/util.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/p4util/util.html
https://psicode.org/psi4manual/4.0b5/_modules/p4util/util.html:2172,Performance,Perform,Performs,2172,"set_title(kwargs['title']); for prop in args:; oe.add(prop); oe.compute(). [docs]def set_memory(bytes):; """"""Function to reset the total memory allocation.""""""; psi4.set_memory(bytes). [docs]def get_memory():; """"""Function to return the total memory allocation.""""""; return psi4.get_memory(). [docs]def set_num_threads(nthread):; """"""Function to reset the number of threads to parallelize across.""""""; psi4.set_nthread(nthread). [docs]def get_num_threads():; """"""Function to return the number of threads to parallelize across.""""""; return psi4.nthread(). [docs]def success(label):; """"""Function to print a '*label*...PASSED' line to screen.; Used by :py:func:`util.compare_values` family when functions pass. """"""; print('\t{0:.<66}PASSED'.format(label)); sys.stdout.flush(). # Test functions; [docs]def compare_values(expected, computed, digits, label):; """"""Function to compare two values. Prints :py:func:`util.success`; when value *computed* matches value *expected* to number of *digits*.; Performs a system exit on failure. Used in input files in the test suite. """"""; if (abs(expected - computed) > 10 ** (-digits)):; print((""\t%s: computed value (%."" + str(digits+1) + ""f) does not match (%."" + str(digits+1) + ""f) to %d decimal places."") % (label, computed, expected, digits)); sys.exit(1); if ( math.isnan(computed) ):; print(""\t%s: computed value (%f) does not match (%f) to %d decimal places.\n"" % (label, computed, expected, digits)); print(""\tprobably because the computed value is nan.""); sys.exit(1); success(label). [docs]def compare_integers(expected, computed, label):; """"""Function to compare two integers. Prints :py:func:`util.success`; when value *computed* matches value *expected*.; Performs a system exit on failure. Used in input files in the test suite. """"""; if (expected != computed):; print(""\t%s: computed value (%d) does not match (%d)."" % (label, computed, expected)); sys.exit(1); success(label). [docs]def compare_strings(expected, computed, label):; """"""Function to compare two ",MatchSource.WIKI,psi4manual/4.0b5/_modules/p4util/util.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/p4util/util.html
https://psicode.org/psi4manual/4.0b5/_modules/p4util/util.html:2883,Performance,Perform,Performs,2883,"'\t{0:.<66}PASSED'.format(label)); sys.stdout.flush(). # Test functions; [docs]def compare_values(expected, computed, digits, label):; """"""Function to compare two values. Prints :py:func:`util.success`; when value *computed* matches value *expected* to number of *digits*.; Performs a system exit on failure. Used in input files in the test suite. """"""; if (abs(expected - computed) > 10 ** (-digits)):; print((""\t%s: computed value (%."" + str(digits+1) + ""f) does not match (%."" + str(digits+1) + ""f) to %d decimal places."") % (label, computed, expected, digits)); sys.exit(1); if ( math.isnan(computed) ):; print(""\t%s: computed value (%f) does not match (%f) to %d decimal places.\n"" % (label, computed, expected, digits)); print(""\tprobably because the computed value is nan.""); sys.exit(1); success(label). [docs]def compare_integers(expected, computed, label):; """"""Function to compare two integers. Prints :py:func:`util.success`; when value *computed* matches value *expected*.; Performs a system exit on failure. Used in input files in the test suite. """"""; if (expected != computed):; print(""\t%s: computed value (%d) does not match (%d)."" % (label, computed, expected)); sys.exit(1); success(label). [docs]def compare_strings(expected, computed, label):; """"""Function to compare two strings. Prints :py:func:`util.success`; when string *computed* exactly matches string *expected*.; Performs a system exit on failure. Used in input files in the test suite. """"""; if(expected != computed):; print(""\t%s: computed value (%s) does not match (%s)."" % (label, computed, expected)); sys.exit(1); success(label). [docs]def compare_matrices(expected, computed, digits, label):; """"""Function to compare two matrices. Prints :py:func:`util.success`; when elements of matrix *computed* match elements of matrix *expected* to; number of *digits*. Performs a system exit on failure to match symmetry; structure, dimensions, or element values. Used in input files in the test suite. """"""; if (expected.nirrep() ",MatchSource.WIKI,psi4manual/4.0b5/_modules/p4util/util.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/p4util/util.html
https://psicode.org/psi4manual/4.0b5/_modules/p4util/util.html:3288,Performance,Perform,Performs,3288,"nt((""\t%s: computed value (%."" + str(digits+1) + ""f) does not match (%."" + str(digits+1) + ""f) to %d decimal places."") % (label, computed, expected, digits)); sys.exit(1); if ( math.isnan(computed) ):; print(""\t%s: computed value (%f) does not match (%f) to %d decimal places.\n"" % (label, computed, expected, digits)); print(""\tprobably because the computed value is nan.""); sys.exit(1); success(label). [docs]def compare_integers(expected, computed, label):; """"""Function to compare two integers. Prints :py:func:`util.success`; when value *computed* matches value *expected*.; Performs a system exit on failure. Used in input files in the test suite. """"""; if (expected != computed):; print(""\t%s: computed value (%d) does not match (%d)."" % (label, computed, expected)); sys.exit(1); success(label). [docs]def compare_strings(expected, computed, label):; """"""Function to compare two strings. Prints :py:func:`util.success`; when string *computed* exactly matches string *expected*.; Performs a system exit on failure. Used in input files in the test suite. """"""; if(expected != computed):; print(""\t%s: computed value (%s) does not match (%s)."" % (label, computed, expected)); sys.exit(1); success(label). [docs]def compare_matrices(expected, computed, digits, label):; """"""Function to compare two matrices. Prints :py:func:`util.success`; when elements of matrix *computed* match elements of matrix *expected* to; number of *digits*. Performs a system exit on failure to match symmetry; structure, dimensions, or element values. Used in input files in the test suite. """"""; if (expected.nirrep() != computed.nirrep()):; print(""\t%s has %d irreps, but %s has %d\n."" % (expected.name(), expected.nirrep(), computed.name(), computed.nirrep())); sys.exit(1); if (expected.symmetry() != computed.symmetry()):; print(""\t%s has %d symmetry, but %s has %d\n."" % (expected.name(), expected.symmetry(), computed.name(), computed.symmetry())); sys.exit(1); nirreps = expected.nirrep(); symmetry = expected.symmet",MatchSource.WIKI,psi4manual/4.0b5/_modules/p4util/util.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/p4util/util.html
https://psicode.org/psi4manual/4.0b5/_modules/p4util/util.html:3738,Performance,Perform,Performs,3738,"are two integers. Prints :py:func:`util.success`; when value *computed* matches value *expected*.; Performs a system exit on failure. Used in input files in the test suite. """"""; if (expected != computed):; print(""\t%s: computed value (%d) does not match (%d)."" % (label, computed, expected)); sys.exit(1); success(label). [docs]def compare_strings(expected, computed, label):; """"""Function to compare two strings. Prints :py:func:`util.success`; when string *computed* exactly matches string *expected*.; Performs a system exit on failure. Used in input files in the test suite. """"""; if(expected != computed):; print(""\t%s: computed value (%s) does not match (%s)."" % (label, computed, expected)); sys.exit(1); success(label). [docs]def compare_matrices(expected, computed, digits, label):; """"""Function to compare two matrices. Prints :py:func:`util.success`; when elements of matrix *computed* match elements of matrix *expected* to; number of *digits*. Performs a system exit on failure to match symmetry; structure, dimensions, or element values. Used in input files in the test suite. """"""; if (expected.nirrep() != computed.nirrep()):; print(""\t%s has %d irreps, but %s has %d\n."" % (expected.name(), expected.nirrep(), computed.name(), computed.nirrep())); sys.exit(1); if (expected.symmetry() != computed.symmetry()):; print(""\t%s has %d symmetry, but %s has %d\n."" % (expected.name(), expected.symmetry(), computed.name(), computed.symmetry())); sys.exit(1); nirreps = expected.nirrep(); symmetry = expected.symmetry(); for irrep in range(nirreps):; if(expected.rows(irrep) != computed.rows(irrep)):; print(""\t%s has %d rows in irrep %d, but %s has %d\n."" % (expected.name(), expected.rows(irrep), irrep, computed.name(), computed.rows(irrep))); sys.exit(1); if(expected.cols(irrep ^ symmetry) != computed.cols(irrep ^ symmetry)):; print(""\t%s has %d columns in irrep, but %s has %d\n."" % (expected.name(), expected.cols(irrep), irrep, computed.name(), computed.cols(irrep))); sys.exit(1); rows ",MatchSource.WIKI,psi4manual/4.0b5/_modules/p4util/util.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/p4util/util.html
https://psicode.org/psi4manual/4.0b5/_modules/p4util/util.html:5692,Performance,Perform,Performs,5692,"e(), computed.cols(irrep))); sys.exit(1); rows = expected.rows(irrep); cols = expected.cols(irrep ^ symmetry); failed = 0; for row in range(rows):; for col in range(cols):; if(abs(expected.get(irrep, row, col) - computed.get(irrep, row, col)) > 10 ** (-digits)):; print(""\t%s: computed value (%s) does not match (%s)."" % (label, expected.get(irrep, row, col), computed.get(irrep, row, col))); failed = 1; break. if(failed):; print(""Check your output file for reporting of the matrices.""); psi4.print_out(""The Failed Test Matrices\n""); psi4.print_out(""Computed Matrix (2nd matrix passed in)\n""); computed.print_out(); psi4.print_out(""Expected Matrix (1st matrix passed in)\n""); expected.print_out(); sys.exit(1); success(label). [docs]def compare_vectors(expected, computed, digits, label):; """"""Function to compare two vectors. Prints :py:func:`util.success`; when elements of vector *computed* match elements of vector *expected* to; number of *digits*. Performs a system exit on failure to match symmetry; structure, dimension, or element values. Used in input files in the test suite. """"""; if (expected.nirrep() != computed.nirrep()):; print(""\t%s has %d irreps, but %s has %d\n."" % (expected.name(), expected.nirrep(), computed.name(), computed.nirrep())); sys.exit(1); nirreps = expected.nirrep(); for irrep in range(nirreps):; if(expected.dim(irrep) != computed.dim(irrep)):; print(""\tThe reference has %d entries in irrep %d, but the computed vector has %d\n."" % (expected.dim(irrep), irrep, computed.dim(irrep))); sys.exit(1); dim = expected.dim(irrep); failed = 0; for entry in range(dim):; if(abs(expected.get(irrep, entry) - computed.get(irrep, entry)) > 10 ** (-digits)):; print(""\t%s: computed value (%s) does not match (%s)."" % (label, computed.get(irrep, entry), expected.get(irrep, entry))); failed = 1; break. if(failed):; psi4.print_out(""The computed vector\n""); computed.print_out(); psi4.print_out(""The reference vector\n""); expected.print_out(); sys.exit(1); success(label). [docs",MatchSource.WIKI,psi4manual/4.0b5/_modules/p4util/util.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/p4util/util.html
https://psicode.org/psi4manual/4.0b5/_modules/p4util/util.html:1956,Testability,Test,Test,1956," input files.""""""; import psi4; import sys; import os; import math; from psiexceptions import *. [docs]def oeprop(*args, **kwargs):; oe = psi4.OEProp(); if 'title' in kwargs:; oe.set_title(kwargs['title']); for prop in args:; oe.add(prop); oe.compute(). [docs]def set_memory(bytes):; """"""Function to reset the total memory allocation.""""""; psi4.set_memory(bytes). [docs]def get_memory():; """"""Function to return the total memory allocation.""""""; return psi4.get_memory(). [docs]def set_num_threads(nthread):; """"""Function to reset the number of threads to parallelize across.""""""; psi4.set_nthread(nthread). [docs]def get_num_threads():; """"""Function to return the number of threads to parallelize across.""""""; return psi4.nthread(). [docs]def success(label):; """"""Function to print a '*label*...PASSED' line to screen.; Used by :py:func:`util.compare_values` family when functions pass. """"""; print('\t{0:.<66}PASSED'.format(label)); sys.stdout.flush(). # Test functions; [docs]def compare_values(expected, computed, digits, label):; """"""Function to compare two values. Prints :py:func:`util.success`; when value *computed* matches value *expected* to number of *digits*.; Performs a system exit on failure. Used in input files in the test suite. """"""; if (abs(expected - computed) > 10 ** (-digits)):; print((""\t%s: computed value (%."" + str(digits+1) + ""f) does not match (%."" + str(digits+1) + ""f) to %d decimal places."") % (label, computed, expected, digits)); sys.exit(1); if ( math.isnan(computed) ):; print(""\t%s: computed value (%f) does not match (%f) to %d decimal places.\n"" % (label, computed, expected, digits)); print(""\tprobably because the computed value is nan.""); sys.exit(1); success(label). [docs]def compare_integers(expected, computed, label):; """"""Function to compare two integers. Prints :py:func:`util.success`; when value *computed* matches value *expected*.; Performs a system exit on failure. Used in input files in the test suite. """"""; if (expected != computed):; print(""\t%s: computed",MatchSource.WIKI,psi4manual/4.0b5/_modules/p4util/util.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/p4util/util.html
https://psicode.org/psi4manual/4.0b5/_modules/p4util/util.html:2234,Testability,test,test,2234,"in args:; oe.add(prop); oe.compute(). [docs]def set_memory(bytes):; """"""Function to reset the total memory allocation.""""""; psi4.set_memory(bytes). [docs]def get_memory():; """"""Function to return the total memory allocation.""""""; return psi4.get_memory(). [docs]def set_num_threads(nthread):; """"""Function to reset the number of threads to parallelize across.""""""; psi4.set_nthread(nthread). [docs]def get_num_threads():; """"""Function to return the number of threads to parallelize across.""""""; return psi4.nthread(). [docs]def success(label):; """"""Function to print a '*label*...PASSED' line to screen.; Used by :py:func:`util.compare_values` family when functions pass. """"""; print('\t{0:.<66}PASSED'.format(label)); sys.stdout.flush(). # Test functions; [docs]def compare_values(expected, computed, digits, label):; """"""Function to compare two values. Prints :py:func:`util.success`; when value *computed* matches value *expected* to number of *digits*.; Performs a system exit on failure. Used in input files in the test suite. """"""; if (abs(expected - computed) > 10 ** (-digits)):; print((""\t%s: computed value (%."" + str(digits+1) + ""f) does not match (%."" + str(digits+1) + ""f) to %d decimal places."") % (label, computed, expected, digits)); sys.exit(1); if ( math.isnan(computed) ):; print(""\t%s: computed value (%f) does not match (%f) to %d decimal places.\n"" % (label, computed, expected, digits)); print(""\tprobably because the computed value is nan.""); sys.exit(1); success(label). [docs]def compare_integers(expected, computed, label):; """"""Function to compare two integers. Prints :py:func:`util.success`; when value *computed* matches value *expected*.; Performs a system exit on failure. Used in input files in the test suite. """"""; if (expected != computed):; print(""\t%s: computed value (%d) does not match (%d)."" % (label, computed, expected)); sys.exit(1); success(label). [docs]def compare_strings(expected, computed, label):; """"""Function to compare two strings. Prints :py:func:`util.success",MatchSource.WIKI,psi4manual/4.0b5/_modules/p4util/util.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/p4util/util.html
https://psicode.org/psi4manual/4.0b5/_modules/p4util/util.html:2945,Testability,test,test,2945,"s.stdout.flush(). # Test functions; [docs]def compare_values(expected, computed, digits, label):; """"""Function to compare two values. Prints :py:func:`util.success`; when value *computed* matches value *expected* to number of *digits*.; Performs a system exit on failure. Used in input files in the test suite. """"""; if (abs(expected - computed) > 10 ** (-digits)):; print((""\t%s: computed value (%."" + str(digits+1) + ""f) does not match (%."" + str(digits+1) + ""f) to %d decimal places."") % (label, computed, expected, digits)); sys.exit(1); if ( math.isnan(computed) ):; print(""\t%s: computed value (%f) does not match (%f) to %d decimal places.\n"" % (label, computed, expected, digits)); print(""\tprobably because the computed value is nan.""); sys.exit(1); success(label). [docs]def compare_integers(expected, computed, label):; """"""Function to compare two integers. Prints :py:func:`util.success`; when value *computed* matches value *expected*.; Performs a system exit on failure. Used in input files in the test suite. """"""; if (expected != computed):; print(""\t%s: computed value (%d) does not match (%d)."" % (label, computed, expected)); sys.exit(1); success(label). [docs]def compare_strings(expected, computed, label):; """"""Function to compare two strings. Prints :py:func:`util.success`; when string *computed* exactly matches string *expected*.; Performs a system exit on failure. Used in input files in the test suite. """"""; if(expected != computed):; print(""\t%s: computed value (%s) does not match (%s)."" % (label, computed, expected)); sys.exit(1); success(label). [docs]def compare_matrices(expected, computed, digits, label):; """"""Function to compare two matrices. Prints :py:func:`util.success`; when elements of matrix *computed* match elements of matrix *expected* to; number of *digits*. Performs a system exit on failure to match symmetry; structure, dimensions, or element values. Used in input files in the test suite. """"""; if (expected.nirrep() != computed.nirrep()):; print(""\t%s ha",MatchSource.WIKI,psi4manual/4.0b5/_modules/p4util/util.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/p4util/util.html
https://psicode.org/psi4manual/4.0b5/_modules/p4util/util.html:3350,Testability,test,test,3350,"digits+1) + ""f) does not match (%."" + str(digits+1) + ""f) to %d decimal places."") % (label, computed, expected, digits)); sys.exit(1); if ( math.isnan(computed) ):; print(""\t%s: computed value (%f) does not match (%f) to %d decimal places.\n"" % (label, computed, expected, digits)); print(""\tprobably because the computed value is nan.""); sys.exit(1); success(label). [docs]def compare_integers(expected, computed, label):; """"""Function to compare two integers. Prints :py:func:`util.success`; when value *computed* matches value *expected*.; Performs a system exit on failure. Used in input files in the test suite. """"""; if (expected != computed):; print(""\t%s: computed value (%d) does not match (%d)."" % (label, computed, expected)); sys.exit(1); success(label). [docs]def compare_strings(expected, computed, label):; """"""Function to compare two strings. Prints :py:func:`util.success`; when string *computed* exactly matches string *expected*.; Performs a system exit on failure. Used in input files in the test suite. """"""; if(expected != computed):; print(""\t%s: computed value (%s) does not match (%s)."" % (label, computed, expected)); sys.exit(1); success(label). [docs]def compare_matrices(expected, computed, digits, label):; """"""Function to compare two matrices. Prints :py:func:`util.success`; when elements of matrix *computed* match elements of matrix *expected* to; number of *digits*. Performs a system exit on failure to match symmetry; structure, dimensions, or element values. Used in input files in the test suite. """"""; if (expected.nirrep() != computed.nirrep()):; print(""\t%s has %d irreps, but %s has %d\n."" % (expected.name(), expected.nirrep(), computed.name(), computed.nirrep())); sys.exit(1); if (expected.symmetry() != computed.symmetry()):; print(""\t%s has %d symmetry, but %s has %d\n."" % (expected.name(), expected.symmetry(), computed.name(), computed.symmetry())); sys.exit(1); nirreps = expected.nirrep(); symmetry = expected.symmetry(); for irrep in range(nirreps):; if",MatchSource.WIKI,psi4manual/4.0b5/_modules/p4util/util.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/p4util/util.html
https://psicode.org/psi4manual/4.0b5/_modules/p4util/util.html:3860,Testability,test,test,3860,"ted* matches value *expected*.; Performs a system exit on failure. Used in input files in the test suite. """"""; if (expected != computed):; print(""\t%s: computed value (%d) does not match (%d)."" % (label, computed, expected)); sys.exit(1); success(label). [docs]def compare_strings(expected, computed, label):; """"""Function to compare two strings. Prints :py:func:`util.success`; when string *computed* exactly matches string *expected*.; Performs a system exit on failure. Used in input files in the test suite. """"""; if(expected != computed):; print(""\t%s: computed value (%s) does not match (%s)."" % (label, computed, expected)); sys.exit(1); success(label). [docs]def compare_matrices(expected, computed, digits, label):; """"""Function to compare two matrices. Prints :py:func:`util.success`; when elements of matrix *computed* match elements of matrix *expected* to; number of *digits*. Performs a system exit on failure to match symmetry; structure, dimensions, or element values. Used in input files in the test suite. """"""; if (expected.nirrep() != computed.nirrep()):; print(""\t%s has %d irreps, but %s has %d\n."" % (expected.name(), expected.nirrep(), computed.name(), computed.nirrep())); sys.exit(1); if (expected.symmetry() != computed.symmetry()):; print(""\t%s has %d symmetry, but %s has %d\n."" % (expected.name(), expected.symmetry(), computed.name(), computed.symmetry())); sys.exit(1); nirreps = expected.nirrep(); symmetry = expected.symmetry(); for irrep in range(nirreps):; if(expected.rows(irrep) != computed.rows(irrep)):; print(""\t%s has %d rows in irrep %d, but %s has %d\n."" % (expected.name(), expected.rows(irrep), irrep, computed.name(), computed.rows(irrep))); sys.exit(1); if(expected.cols(irrep ^ symmetry) != computed.cols(irrep ^ symmetry)):; print(""\t%s has %d columns in irrep, but %s has %d\n."" % (expected.name(), expected.cols(irrep), irrep, computed.name(), computed.cols(irrep))); sys.exit(1); rows = expected.rows(irrep); cols = expected.cols(irrep ^ symmetry); fai",MatchSource.WIKI,psi4manual/4.0b5/_modules/p4util/util.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/p4util/util.html
https://psicode.org/psi4manual/4.0b5/_modules/p4util/util.html:5254,Testability,Test,Test,5254,"s = expected.nirrep(); symmetry = expected.symmetry(); for irrep in range(nirreps):; if(expected.rows(irrep) != computed.rows(irrep)):; print(""\t%s has %d rows in irrep %d, but %s has %d\n."" % (expected.name(), expected.rows(irrep), irrep, computed.name(), computed.rows(irrep))); sys.exit(1); if(expected.cols(irrep ^ symmetry) != computed.cols(irrep ^ symmetry)):; print(""\t%s has %d columns in irrep, but %s has %d\n."" % (expected.name(), expected.cols(irrep), irrep, computed.name(), computed.cols(irrep))); sys.exit(1); rows = expected.rows(irrep); cols = expected.cols(irrep ^ symmetry); failed = 0; for row in range(rows):; for col in range(cols):; if(abs(expected.get(irrep, row, col) - computed.get(irrep, row, col)) > 10 ** (-digits)):; print(""\t%s: computed value (%s) does not match (%s)."" % (label, expected.get(irrep, row, col), computed.get(irrep, row, col))); failed = 1; break. if(failed):; print(""Check your output file for reporting of the matrices.""); psi4.print_out(""The Failed Test Matrices\n""); psi4.print_out(""Computed Matrix (2nd matrix passed in)\n""); computed.print_out(); psi4.print_out(""Expected Matrix (1st matrix passed in)\n""); expected.print_out(); sys.exit(1); success(label). [docs]def compare_vectors(expected, computed, digits, label):; """"""Function to compare two vectors. Prints :py:func:`util.success`; when elements of vector *computed* match elements of vector *expected* to; number of *digits*. Performs a system exit on failure to match symmetry; structure, dimension, or element values. Used in input files in the test suite. """"""; if (expected.nirrep() != computed.nirrep()):; print(""\t%s has %d irreps, but %s has %d\n."" % (expected.name(), expected.nirrep(), computed.name(), computed.nirrep())); sys.exit(1); nirreps = expected.nirrep(); for irrep in range(nirreps):; if(expected.dim(irrep) != computed.dim(irrep)):; print(""\tThe reference has %d entries in irrep %d, but the computed vector has %d\n."" % (expected.dim(irrep), irrep, computed.dim(irrep)",MatchSource.WIKI,psi4manual/4.0b5/_modules/p4util/util.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/p4util/util.html
https://psicode.org/psi4manual/4.0b5/_modules/p4util/util.html:5813,Testability,test,test,5813,"ep); cols = expected.cols(irrep ^ symmetry); failed = 0; for row in range(rows):; for col in range(cols):; if(abs(expected.get(irrep, row, col) - computed.get(irrep, row, col)) > 10 ** (-digits)):; print(""\t%s: computed value (%s) does not match (%s)."" % (label, expected.get(irrep, row, col), computed.get(irrep, row, col))); failed = 1; break. if(failed):; print(""Check your output file for reporting of the matrices.""); psi4.print_out(""The Failed Test Matrices\n""); psi4.print_out(""Computed Matrix (2nd matrix passed in)\n""); computed.print_out(); psi4.print_out(""Expected Matrix (1st matrix passed in)\n""); expected.print_out(); sys.exit(1); success(label). [docs]def compare_vectors(expected, computed, digits, label):; """"""Function to compare two vectors. Prints :py:func:`util.success`; when elements of vector *computed* match elements of vector *expected* to; number of *digits*. Performs a system exit on failure to match symmetry; structure, dimension, or element values. Used in input files in the test suite. """"""; if (expected.nirrep() != computed.nirrep()):; print(""\t%s has %d irreps, but %s has %d\n."" % (expected.name(), expected.nirrep(), computed.name(), computed.nirrep())); sys.exit(1); nirreps = expected.nirrep(); for irrep in range(nirreps):; if(expected.dim(irrep) != computed.dim(irrep)):; print(""\tThe reference has %d entries in irrep %d, but the computed vector has %d\n."" % (expected.dim(irrep), irrep, computed.dim(irrep))); sys.exit(1); dim = expected.dim(irrep); failed = 0; for entry in range(dim):; if(abs(expected.get(irrep, entry) - computed.get(irrep, entry)) > 10 ** (-digits)):; print(""\t%s: computed value (%s) does not match (%s)."" % (label, computed.get(irrep, entry), expected.get(irrep, entry))); failed = 1; break. if(failed):; psi4.print_out(""The computed vector\n""); computed.print_out(); psi4.print_out(""The reference vector\n""); expected.print_out(); sys.exit(1); success(label). [docs]def copy_file_to_scratch(filename, prefix, namespace, unit, move =",MatchSource.WIKI,psi4manual/4.0b5/_modules/p4util/util.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/p4util/util.html
https://psicode.org/psi4manual/4.0b5/_modules/qcdb/dbproc.html:3052,Availability,avail,available,3052,"ule)[1]; basename = os.path.splitext(filename)[0]; div = '=' * len(basename). module_choices.append(basename); DSD[basename] = {}. M = ast.parse(''.join(open(module))); DS = ast.get_docstring(M); if not DS:; DS = """"; DS = str.replace(DS, '|dl|', '-->'); DS = str.replace(DS, '|dr|', '<--'); DS = str.replace(DS, ""``'"", ''); DS = str.replace(DS, ""'``"", ''). lst = DS.split(""\n- **""). #DSD[basename]['general'] = str.replace(lst[0], '|', ''); DSD[basename]['general'] = lst[0].split('\n'). try:; DSD[basename]['cp'] = [section for section in lst if section.startswith(""cp"")][0]; except IndexError:; DSD[basename]['cp'] = None. try:; DSD[basename]['rlxd'] = [section for section in lst if section.startswith(""rlxd"")][0]; except IndexError:; DSD[basename]['rlxd'] = None. try:; DSD[basename]['benchmark'] = [section for section in lst if section.startswith(""benchmark"")][0]; except IndexError:; DSD[basename]['benchmark'] = None. try:; #DSD[basename]['subset'] = [section for section in lst if section.startswith(""subset"")][0]; temp = [section for section in lst if section.startswith(""subset"")][0].splitlines(); temp = temp[2:]. result = {}; for item in temp:; item = item.lstrip("" -""); try:; key, val = item.split("" "", 1); result[key] = val; except ValueError:; result[item] = """". DSD[basename]['subset'] = result. except IndexError:; DSD[basename]['subset'] = {"""": 'No subsets available'}. return DSD. # print '\ngeneral\n\n', DSD[basename]['general']; # print '\ncp\n\n', DSD[basename]['cp']; # print '\nrlxd\n\n', DSD[basename]['rlxd']; # print '\nbenchmark\n\n', DSD[basename]['benchmark']; # print '\nsubset\n\n', DSD[basename]['subset']. #print ' %-12s %s' % ('[' + basename + ']', DSD[basename]['general'][0]). #print 'DSD2\n', DSD['S22']['subset']. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  ; PSI4 [beta5]  ; Module code .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/_modules/qcdb/dbproc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/dbproc.html
https://psicode.org/psi4manual/4.0b5/_modules/qcdb/dbproc.html:3619,Deployability,update,updated,3619,"ule)[1]; basename = os.path.splitext(filename)[0]; div = '=' * len(basename). module_choices.append(basename); DSD[basename] = {}. M = ast.parse(''.join(open(module))); DS = ast.get_docstring(M); if not DS:; DS = """"; DS = str.replace(DS, '|dl|', '-->'); DS = str.replace(DS, '|dr|', '<--'); DS = str.replace(DS, ""``'"", ''); DS = str.replace(DS, ""'``"", ''). lst = DS.split(""\n- **""). #DSD[basename]['general'] = str.replace(lst[0], '|', ''); DSD[basename]['general'] = lst[0].split('\n'). try:; DSD[basename]['cp'] = [section for section in lst if section.startswith(""cp"")][0]; except IndexError:; DSD[basename]['cp'] = None. try:; DSD[basename]['rlxd'] = [section for section in lst if section.startswith(""rlxd"")][0]; except IndexError:; DSD[basename]['rlxd'] = None. try:; DSD[basename]['benchmark'] = [section for section in lst if section.startswith(""benchmark"")][0]; except IndexError:; DSD[basename]['benchmark'] = None. try:; #DSD[basename]['subset'] = [section for section in lst if section.startswith(""subset"")][0]; temp = [section for section in lst if section.startswith(""subset"")][0].splitlines(); temp = temp[2:]. result = {}; for item in temp:; item = item.lstrip("" -""); try:; key, val = item.split("" "", 1); result[key] = val; except ValueError:; result[item] = """". DSD[basename]['subset'] = result. except IndexError:; DSD[basename]['subset'] = {"""": 'No subsets available'}. return DSD. # print '\ngeneral\n\n', DSD[basename]['general']; # print '\ncp\n\n', DSD[basename]['cp']; # print '\nrlxd\n\n', DSD[basename]['rlxd']; # print '\nbenchmark\n\n', DSD[basename]['benchmark']; # print '\nsubset\n\n', DSD[basename]['subset']. #print ' %-12s %s' % ('[' + basename + ']', DSD[basename]['general'][0]). #print 'DSD2\n', DSD['S22']['subset']. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  ; PSI4 [beta5]  ; Module code .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/_modules/qcdb/dbproc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/dbproc.html
https://psicode.org/psi4manual/4.0b5/_modules/qcdb/dbproc.html:1106,Security,access,accessed,1106,"beta5]  ; Module code . Source code for qcdb.dbproc; #; #@BEGIN LICENSE; #; # PSI4: an ab initio quantum chemistry software package; #; # This program is free software; you can redistribute it and/or modify; # it under the terms of the GNU General Public License as published by; # the Free Software Foundation; either version 2 of the License, or; # (at your option) any later version.; #; # This program is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU General Public License for more details.; #; # You should have received a copy of the GNU General Public License along; # with this program; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; #@END LICENSE; #. r""""""File to. """"""; import sys; import os; import glob; import ast. [docs]def useful():; print ""in qcdb.useful()""; return 'qcdb successfully accessed'. [docs]def drop_duplicates(seq):; """"""Function that given an array or array of arrays *seq*, returns an; array without any duplicate entries. There is no guarantee of which; duplicate entry is dropped. """"""; noDupes = []; seq2 = sum(seq, []); [noDupes.append(i) for i in seq2 if not noDupes.count(i)]; return noDupes. [docs]def dictify_database_docstrings():; """""". """"""; db_path = os.path.expanduser('~loriab/linux/qcdb/databases'); sys.path.append(db_path). DSD = {}; module_choices = []; for module in glob.glob(db_path + '/*.py'):; filename = os.path.split(module)[1]; basename = os.path.splitext(filename)[0]; div = '=' * len(basename). module_choices.append(basename); DSD[basename] = {}. M = ast.parse(''.join(open(module))); DS = ast.get_docstring(M); if not DS:; DS = """"; DS = str.replace(DS, '|dl|', '-->'); DS = str.replace(DS, '|dr|', '<--'); DS = str.replace(DS, ""``'"", ''); DS = str.replace(DS, ""'``"", ''). lst = DS.split(""\n- **""). #DSD[basename]['general'] = str.re",MatchSource.WIKI,psi4manual/4.0b5/_modules/qcdb/dbproc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/dbproc.html
https://psicode.org/psi4manual/4.0b5/_modules/qcdb/dbproc.html:2465,Testability,benchmark,benchmark,2465,"""""; db_path = os.path.expanduser('~loriab/linux/qcdb/databases'); sys.path.append(db_path). DSD = {}; module_choices = []; for module in glob.glob(db_path + '/*.py'):; filename = os.path.split(module)[1]; basename = os.path.splitext(filename)[0]; div = '=' * len(basename). module_choices.append(basename); DSD[basename] = {}. M = ast.parse(''.join(open(module))); DS = ast.get_docstring(M); if not DS:; DS = """"; DS = str.replace(DS, '|dl|', '-->'); DS = str.replace(DS, '|dr|', '<--'); DS = str.replace(DS, ""``'"", ''); DS = str.replace(DS, ""'``"", ''). lst = DS.split(""\n- **""). #DSD[basename]['general'] = str.replace(lst[0], '|', ''); DSD[basename]['general'] = lst[0].split('\n'). try:; DSD[basename]['cp'] = [section for section in lst if section.startswith(""cp"")][0]; except IndexError:; DSD[basename]['cp'] = None. try:; DSD[basename]['rlxd'] = [section for section in lst if section.startswith(""rlxd"")][0]; except IndexError:; DSD[basename]['rlxd'] = None. try:; DSD[basename]['benchmark'] = [section for section in lst if section.startswith(""benchmark"")][0]; except IndexError:; DSD[basename]['benchmark'] = None. try:; #DSD[basename]['subset'] = [section for section in lst if section.startswith(""subset"")][0]; temp = [section for section in lst if section.startswith(""subset"")][0].splitlines(); temp = temp[2:]. result = {}; for item in temp:; item = item.lstrip("" -""); try:; key, val = item.split("" "", 1); result[key] = val; except ValueError:; result[item] = """". DSD[basename]['subset'] = result. except IndexError:; DSD[basename]['subset'] = {"""": 'No subsets available'}. return DSD. # print '\ngeneral\n\n', DSD[basename]['general']; # print '\ncp\n\n', DSD[basename]['cp']; # print '\nrlxd\n\n', DSD[basename]['rlxd']; # print '\nbenchmark\n\n', DSD[basename]['benchmark']; # print '\nsubset\n\n', DSD[basename]['subset']. #print ' %-12s %s' % ('[' + basename + ']', DSD[basename]['general'][0]). #print 'DSD2\n', DSD['S22']['subset']. Quick search. Enter search terms or a module, clas",MatchSource.WIKI,psi4manual/4.0b5/_modules/qcdb/dbproc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/dbproc.html
https://psicode.org/psi4manual/4.0b5/_modules/qcdb/dbproc.html:2530,Testability,benchmark,benchmark,2530,"nd(db_path). DSD = {}; module_choices = []; for module in glob.glob(db_path + '/*.py'):; filename = os.path.split(module)[1]; basename = os.path.splitext(filename)[0]; div = '=' * len(basename). module_choices.append(basename); DSD[basename] = {}. M = ast.parse(''.join(open(module))); DS = ast.get_docstring(M); if not DS:; DS = """"; DS = str.replace(DS, '|dl|', '-->'); DS = str.replace(DS, '|dr|', '<--'); DS = str.replace(DS, ""``'"", ''); DS = str.replace(DS, ""'``"", ''). lst = DS.split(""\n- **""). #DSD[basename]['general'] = str.replace(lst[0], '|', ''); DSD[basename]['general'] = lst[0].split('\n'). try:; DSD[basename]['cp'] = [section for section in lst if section.startswith(""cp"")][0]; except IndexError:; DSD[basename]['cp'] = None. try:; DSD[basename]['rlxd'] = [section for section in lst if section.startswith(""rlxd"")][0]; except IndexError:; DSD[basename]['rlxd'] = None. try:; DSD[basename]['benchmark'] = [section for section in lst if section.startswith(""benchmark"")][0]; except IndexError:; DSD[basename]['benchmark'] = None. try:; #DSD[basename]['subset'] = [section for section in lst if section.startswith(""subset"")][0]; temp = [section for section in lst if section.startswith(""subset"")][0].splitlines(); temp = temp[2:]. result = {}; for item in temp:; item = item.lstrip("" -""); try:; key, val = item.split("" "", 1); result[key] = val; except ValueError:; result[item] = """". DSD[basename]['subset'] = result. except IndexError:; DSD[basename]['subset'] = {"""": 'No subsets available'}. return DSD. # print '\ngeneral\n\n', DSD[basename]['general']; # print '\ncp\n\n', DSD[basename]['cp']; # print '\nrlxd\n\n', DSD[basename]['rlxd']; # print '\nbenchmark\n\n', DSD[basename]['benchmark']; # print '\nsubset\n\n', DSD[basename]['subset']. #print ' %-12s %s' % ('[' + basename + ']', DSD[basename]['general'][0]). #print 'DSD2\n', DSD['S22']['subset']. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  ; PSI4 [beta5]  ",MatchSource.WIKI,psi4manual/4.0b5/_modules/qcdb/dbproc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/dbproc.html
https://psicode.org/psi4manual/4.0b5/_modules/qcdb/dbproc.html:2582,Testability,benchmark,benchmark,2582,"nd(db_path). DSD = {}; module_choices = []; for module in glob.glob(db_path + '/*.py'):; filename = os.path.split(module)[1]; basename = os.path.splitext(filename)[0]; div = '=' * len(basename). module_choices.append(basename); DSD[basename] = {}. M = ast.parse(''.join(open(module))); DS = ast.get_docstring(M); if not DS:; DS = """"; DS = str.replace(DS, '|dl|', '-->'); DS = str.replace(DS, '|dr|', '<--'); DS = str.replace(DS, ""``'"", ''); DS = str.replace(DS, ""'``"", ''). lst = DS.split(""\n- **""). #DSD[basename]['general'] = str.replace(lst[0], '|', ''); DSD[basename]['general'] = lst[0].split('\n'). try:; DSD[basename]['cp'] = [section for section in lst if section.startswith(""cp"")][0]; except IndexError:; DSD[basename]['cp'] = None. try:; DSD[basename]['rlxd'] = [section for section in lst if section.startswith(""rlxd"")][0]; except IndexError:; DSD[basename]['rlxd'] = None. try:; DSD[basename]['benchmark'] = [section for section in lst if section.startswith(""benchmark"")][0]; except IndexError:; DSD[basename]['benchmark'] = None. try:; #DSD[basename]['subset'] = [section for section in lst if section.startswith(""subset"")][0]; temp = [section for section in lst if section.startswith(""subset"")][0].splitlines(); temp = temp[2:]. result = {}; for item in temp:; item = item.lstrip("" -""); try:; key, val = item.split("" "", 1); result[key] = val; except ValueError:; result[item] = """". DSD[basename]['subset'] = result. except IndexError:; DSD[basename]['subset'] = {"""": 'No subsets available'}. return DSD. # print '\ngeneral\n\n', DSD[basename]['general']; # print '\ncp\n\n', DSD[basename]['cp']; # print '\nrlxd\n\n', DSD[basename]['rlxd']; # print '\nbenchmark\n\n', DSD[basename]['benchmark']; # print '\nsubset\n\n', DSD[basename]['subset']. #print ' %-12s %s' % ('[' + basename + ']', DSD[basename]['general'][0]). #print 'DSD2\n', DSD['S22']['subset']. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  ; PSI4 [beta5]  ",MatchSource.WIKI,psi4manual/4.0b5/_modules/qcdb/dbproc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/dbproc.html
https://psicode.org/psi4manual/4.0b5/_modules/qcdb/dbproc.html:3256,Testability,benchmark,benchmark,3256,"ule)[1]; basename = os.path.splitext(filename)[0]; div = '=' * len(basename). module_choices.append(basename); DSD[basename] = {}. M = ast.parse(''.join(open(module))); DS = ast.get_docstring(M); if not DS:; DS = """"; DS = str.replace(DS, '|dl|', '-->'); DS = str.replace(DS, '|dr|', '<--'); DS = str.replace(DS, ""``'"", ''); DS = str.replace(DS, ""'``"", ''). lst = DS.split(""\n- **""). #DSD[basename]['general'] = str.replace(lst[0], '|', ''); DSD[basename]['general'] = lst[0].split('\n'). try:; DSD[basename]['cp'] = [section for section in lst if section.startswith(""cp"")][0]; except IndexError:; DSD[basename]['cp'] = None. try:; DSD[basename]['rlxd'] = [section for section in lst if section.startswith(""rlxd"")][0]; except IndexError:; DSD[basename]['rlxd'] = None. try:; DSD[basename]['benchmark'] = [section for section in lst if section.startswith(""benchmark"")][0]; except IndexError:; DSD[basename]['benchmark'] = None. try:; #DSD[basename]['subset'] = [section for section in lst if section.startswith(""subset"")][0]; temp = [section for section in lst if section.startswith(""subset"")][0].splitlines(); temp = temp[2:]. result = {}; for item in temp:; item = item.lstrip("" -""); try:; key, val = item.split("" "", 1); result[key] = val; except ValueError:; result[item] = """". DSD[basename]['subset'] = result. except IndexError:; DSD[basename]['subset'] = {"""": 'No subsets available'}. return DSD. # print '\ngeneral\n\n', DSD[basename]['general']; # print '\ncp\n\n', DSD[basename]['cp']; # print '\nrlxd\n\n', DSD[basename]['rlxd']; # print '\nbenchmark\n\n', DSD[basename]['benchmark']; # print '\nsubset\n\n', DSD[basename]['subset']. #print ' %-12s %s' % ('[' + basename + ']', DSD[basename]['general'][0]). #print 'DSD2\n', DSD['S22']['subset']. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  ; PSI4 [beta5]  ; Module code .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/_modules/qcdb/dbproc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/dbproc.html
https://psicode.org/psi4manual/4.0b5/_modules/qcdb/exceptions.html:1068,Availability,Error,Error,1068,"on. index. modules  . toc  ; PSI4 [beta5]  ; Module code . Source code for qcdb.exceptions; #; #@BEGIN LICENSE; #; # PSI4: an ab initio quantum chemistry software package; #; # This program is free software; you can redistribute it and/or modify; # it under the terms of the GNU General Public License as published by; # the Free Software Foundation; either version 2 of the License, or; # (at your option) any later version.; #; # This program is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU General Public License for more details.; #; # You should have received a copy of the GNU General Public License along; # with this program; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; #@END LICENSE; #. """"""Module with non-generic exceptions classes."""""". [docs]class QcdbException(Exception):; """"""Error class for QCDB.""""""; pass. [docs]class FeatureNotImplemented(QcdbException):; """"""Error called for functions defined but not yet implemented.; Also for functions defined that will never be implemented. """"""; def __init__(self, msg):; QcdbException.__init__(self, msg); self.msg = msg; print('\nQcdbException: Feature %s is not yet implemented.\n\n' % (msg)). [docs]class ValidationError(QcdbException):; """"""Error called for problems with syntax input file. Prints; error message *msg* to standard output stream. """"""; def __init__(self, msg):; QcdbException.__init__(self, msg); self.msg = msg; print('\nQcdbException: %s\n\n' % (msg)). [docs]class IncompleteAtomError(QcdbException):; """"""Error raised when not all variables in an atom specification; have been defined at compute time. May be a temporary situation; so message not printed but appears as traceback when error persists. """"""; def __init__(self, msg):; QcdbException.__init__(self, msg); self.msg = msg. Quick search. Enter ",MatchSource.WIKI,psi4manual/4.0b5/_modules/qcdb/exceptions.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/exceptions.html
https://psicode.org/psi4manual/4.0b5/_modules/qcdb/exceptions.html:1154,Availability,Error,Error,1154,"; #@BEGIN LICENSE; #; # PSI4: an ab initio quantum chemistry software package; #; # This program is free software; you can redistribute it and/or modify; # it under the terms of the GNU General Public License as published by; # the Free Software Foundation; either version 2 of the License, or; # (at your option) any later version.; #; # This program is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU General Public License for more details.; #; # You should have received a copy of the GNU General Public License along; # with this program; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; #@END LICENSE; #. """"""Module with non-generic exceptions classes."""""". [docs]class QcdbException(Exception):; """"""Error class for QCDB.""""""; pass. [docs]class FeatureNotImplemented(QcdbException):; """"""Error called for functions defined but not yet implemented.; Also for functions defined that will never be implemented. """"""; def __init__(self, msg):; QcdbException.__init__(self, msg); self.msg = msg; print('\nQcdbException: Feature %s is not yet implemented.\n\n' % (msg)). [docs]class ValidationError(QcdbException):; """"""Error called for problems with syntax input file. Prints; error message *msg* to standard output stream. """"""; def __init__(self, msg):; QcdbException.__init__(self, msg); self.msg = msg; print('\nQcdbException: %s\n\n' % (msg)). [docs]class IncompleteAtomError(QcdbException):; """"""Error raised when not all variables in an atom specification; have been defined at compute time. May be a temporary situation; so message not printed but appears as traceback when error persists. """"""; def __init__(self, msg):; QcdbException.__init__(self, msg); self.msg = msg. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  ; PSI4 ",MatchSource.WIKI,psi4manual/4.0b5/_modules/qcdb/exceptions.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/exceptions.html
https://psicode.org/psi4manual/4.0b5/_modules/qcdb/exceptions.html:1478,Availability,Error,Error,1478,"istribute it and/or modify; # it under the terms of the GNU General Public License as published by; # the Free Software Foundation; either version 2 of the License, or; # (at your option) any later version.; #; # This program is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU General Public License for more details.; #; # You should have received a copy of the GNU General Public License along; # with this program; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; #@END LICENSE; #. """"""Module with non-generic exceptions classes."""""". [docs]class QcdbException(Exception):; """"""Error class for QCDB.""""""; pass. [docs]class FeatureNotImplemented(QcdbException):; """"""Error called for functions defined but not yet implemented.; Also for functions defined that will never be implemented. """"""; def __init__(self, msg):; QcdbException.__init__(self, msg); self.msg = msg; print('\nQcdbException: Feature %s is not yet implemented.\n\n' % (msg)). [docs]class ValidationError(QcdbException):; """"""Error called for problems with syntax input file. Prints; error message *msg* to standard output stream. """"""; def __init__(self, msg):; QcdbException.__init__(self, msg); self.msg = msg; print('\nQcdbException: %s\n\n' % (msg)). [docs]class IncompleteAtomError(QcdbException):; """"""Error raised when not all variables in an atom specification; have been defined at compute time. May be a temporary situation; so message not printed but appears as traceback when error persists. """"""; def __init__(self, msg):; QcdbException.__init__(self, msg); self.msg = msg. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  ; PSI4 [beta5]  ; Module code .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/_modules/qcdb/exceptions.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/exceptions.html
https://psicode.org/psi4manual/4.0b5/_modules/qcdb/exceptions.html:1536,Availability,error,error,1536,"istribute it and/or modify; # it under the terms of the GNU General Public License as published by; # the Free Software Foundation; either version 2 of the License, or; # (at your option) any later version.; #; # This program is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU General Public License for more details.; #; # You should have received a copy of the GNU General Public License along; # with this program; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; #@END LICENSE; #. """"""Module with non-generic exceptions classes."""""". [docs]class QcdbException(Exception):; """"""Error class for QCDB.""""""; pass. [docs]class FeatureNotImplemented(QcdbException):; """"""Error called for functions defined but not yet implemented.; Also for functions defined that will never be implemented. """"""; def __init__(self, msg):; QcdbException.__init__(self, msg); self.msg = msg; print('\nQcdbException: Feature %s is not yet implemented.\n\n' % (msg)). [docs]class ValidationError(QcdbException):; """"""Error called for problems with syntax input file. Prints; error message *msg* to standard output stream. """"""; def __init__(self, msg):; QcdbException.__init__(self, msg); self.msg = msg; print('\nQcdbException: %s\n\n' % (msg)). [docs]class IncompleteAtomError(QcdbException):; """"""Error raised when not all variables in an atom specification; have been defined at compute time. May be a temporary situation; so message not printed but appears as traceback when error persists. """"""; def __init__(self, msg):; QcdbException.__init__(self, msg); self.msg = msg. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  ; PSI4 [beta5]  ; Module code .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/_modules/qcdb/exceptions.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/exceptions.html
https://psicode.org/psi4manual/4.0b5/_modules/qcdb/exceptions.html:1759,Availability,Error,Error,1759,"istribute it and/or modify; # it under the terms of the GNU General Public License as published by; # the Free Software Foundation; either version 2 of the License, or; # (at your option) any later version.; #; # This program is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU General Public License for more details.; #; # You should have received a copy of the GNU General Public License along; # with this program; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; #@END LICENSE; #. """"""Module with non-generic exceptions classes."""""". [docs]class QcdbException(Exception):; """"""Error class for QCDB.""""""; pass. [docs]class FeatureNotImplemented(QcdbException):; """"""Error called for functions defined but not yet implemented.; Also for functions defined that will never be implemented. """"""; def __init__(self, msg):; QcdbException.__init__(self, msg); self.msg = msg; print('\nQcdbException: Feature %s is not yet implemented.\n\n' % (msg)). [docs]class ValidationError(QcdbException):; """"""Error called for problems with syntax input file. Prints; error message *msg* to standard output stream. """"""; def __init__(self, msg):; QcdbException.__init__(self, msg); self.msg = msg; print('\nQcdbException: %s\n\n' % (msg)). [docs]class IncompleteAtomError(QcdbException):; """"""Error raised when not all variables in an atom specification; have been defined at compute time. May be a temporary situation; so message not printed but appears as traceback when error persists. """"""; def __init__(self, msg):; QcdbException.__init__(self, msg); self.msg = msg. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  ; PSI4 [beta5]  ; Module code .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/_modules/qcdb/exceptions.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/exceptions.html
https://psicode.org/psi4manual/4.0b5/_modules/qcdb/exceptions.html:1939,Availability,error,error,1939,"istribute it and/or modify; # it under the terms of the GNU General Public License as published by; # the Free Software Foundation; either version 2 of the License, or; # (at your option) any later version.; #; # This program is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU General Public License for more details.; #; # You should have received a copy of the GNU General Public License along; # with this program; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; #@END LICENSE; #. """"""Module with non-generic exceptions classes."""""". [docs]class QcdbException(Exception):; """"""Error class for QCDB.""""""; pass. [docs]class FeatureNotImplemented(QcdbException):; """"""Error called for functions defined but not yet implemented.; Also for functions defined that will never be implemented. """"""; def __init__(self, msg):; QcdbException.__init__(self, msg); self.msg = msg; print('\nQcdbException: Feature %s is not yet implemented.\n\n' % (msg)). [docs]class ValidationError(QcdbException):; """"""Error called for problems with syntax input file. Prints; error message *msg* to standard output stream. """"""; def __init__(self, msg):; QcdbException.__init__(self, msg); self.msg = msg; print('\nQcdbException: %s\n\n' % (msg)). [docs]class IncompleteAtomError(QcdbException):; """"""Error raised when not all variables in an atom specification; have been defined at compute time. May be a temporary situation; so message not printed but appears as traceback when error persists. """"""; def __init__(self, msg):; QcdbException.__init__(self, msg); self.msg = msg. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  ; PSI4 [beta5]  ; Module code .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/_modules/qcdb/exceptions.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/exceptions.html
https://psicode.org/psi4manual/4.0b5/_modules/qcdb/exceptions.html:2225,Deployability,update,updated,2225,"istribute it and/or modify; # it under the terms of the GNU General Public License as published by; # the Free Software Foundation; either version 2 of the License, or; # (at your option) any later version.; #; # This program is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU General Public License for more details.; #; # You should have received a copy of the GNU General Public License along; # with this program; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; #@END LICENSE; #. """"""Module with non-generic exceptions classes."""""". [docs]class QcdbException(Exception):; """"""Error class for QCDB.""""""; pass. [docs]class FeatureNotImplemented(QcdbException):; """"""Error called for functions defined but not yet implemented.; Also for functions defined that will never be implemented. """"""; def __init__(self, msg):; QcdbException.__init__(self, msg); self.msg = msg; print('\nQcdbException: Feature %s is not yet implemented.\n\n' % (msg)). [docs]class ValidationError(QcdbException):; """"""Error called for problems with syntax input file. Prints; error message *msg* to standard output stream. """"""; def __init__(self, msg):; QcdbException.__init__(self, msg); self.msg = msg; print('\nQcdbException: %s\n\n' % (msg)). [docs]class IncompleteAtomError(QcdbException):; """"""Error raised when not all variables in an atom specification; have been defined at compute time. May be a temporary situation; so message not printed but appears as traceback when error persists. """"""; def __init__(self, msg):; QcdbException.__init__(self, msg); self.msg = msg. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  ; PSI4 [beta5]  ; Module code .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/_modules/qcdb/exceptions.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/exceptions.html
https://psicode.org/psi4manual/4.0b5/_modules/qcdb/exceptions.html:1542,Integrability,message,message,1542,"istribute it and/or modify; # it under the terms of the GNU General Public License as published by; # the Free Software Foundation; either version 2 of the License, or; # (at your option) any later version.; #; # This program is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU General Public License for more details.; #; # You should have received a copy of the GNU General Public License along; # with this program; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; #@END LICENSE; #. """"""Module with non-generic exceptions classes."""""". [docs]class QcdbException(Exception):; """"""Error class for QCDB.""""""; pass. [docs]class FeatureNotImplemented(QcdbException):; """"""Error called for functions defined but not yet implemented.; Also for functions defined that will never be implemented. """"""; def __init__(self, msg):; QcdbException.__init__(self, msg); self.msg = msg; print('\nQcdbException: Feature %s is not yet implemented.\n\n' % (msg)). [docs]class ValidationError(QcdbException):; """"""Error called for problems with syntax input file. Prints; error message *msg* to standard output stream. """"""; def __init__(self, msg):; QcdbException.__init__(self, msg); self.msg = msg; print('\nQcdbException: %s\n\n' % (msg)). [docs]class IncompleteAtomError(QcdbException):; """"""Error raised when not all variables in an atom specification; have been defined at compute time. May be a temporary situation; so message not printed but appears as traceback when error persists. """"""; def __init__(self, msg):; QcdbException.__init__(self, msg); self.msg = msg. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  ; PSI4 [beta5]  ; Module code .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/_modules/qcdb/exceptions.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/exceptions.html
https://psicode.org/psi4manual/4.0b5/_modules/qcdb/exceptions.html:1889,Integrability,message,message,1889,"istribute it and/or modify; # it under the terms of the GNU General Public License as published by; # the Free Software Foundation; either version 2 of the License, or; # (at your option) any later version.; #; # This program is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU General Public License for more details.; #; # You should have received a copy of the GNU General Public License along; # with this program; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; #@END LICENSE; #. """"""Module with non-generic exceptions classes."""""". [docs]class QcdbException(Exception):; """"""Error class for QCDB.""""""; pass. [docs]class FeatureNotImplemented(QcdbException):; """"""Error called for functions defined but not yet implemented.; Also for functions defined that will never be implemented. """"""; def __init__(self, msg):; QcdbException.__init__(self, msg); self.msg = msg; print('\nQcdbException: Feature %s is not yet implemented.\n\n' % (msg)). [docs]class ValidationError(QcdbException):; """"""Error called for problems with syntax input file. Prints; error message *msg* to standard output stream. """"""; def __init__(self, msg):; QcdbException.__init__(self, msg); self.msg = msg; print('\nQcdbException: %s\n\n' % (msg)). [docs]class IncompleteAtomError(QcdbException):; """"""Error raised when not all variables in an atom specification; have been defined at compute time. May be a temporary situation; so message not printed but appears as traceback when error persists. """"""; def __init__(self, msg):; QcdbException.__init__(self, msg); self.msg = msg. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  ; PSI4 [beta5]  ; Module code .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/_modules/qcdb/exceptions.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/exceptions.html
https://psicode.org/psi4manual/4.0b5/_modules/qcdb/exceptions.html:1785,Modifiability,variab,variables,1785,"istribute it and/or modify; # it under the terms of the GNU General Public License as published by; # the Free Software Foundation; either version 2 of the License, or; # (at your option) any later version.; #; # This program is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU General Public License for more details.; #; # You should have received a copy of the GNU General Public License along; # with this program; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; #@END LICENSE; #. """"""Module with non-generic exceptions classes."""""". [docs]class QcdbException(Exception):; """"""Error class for QCDB.""""""; pass. [docs]class FeatureNotImplemented(QcdbException):; """"""Error called for functions defined but not yet implemented.; Also for functions defined that will never be implemented. """"""; def __init__(self, msg):; QcdbException.__init__(self, msg); self.msg = msg; print('\nQcdbException: Feature %s is not yet implemented.\n\n' % (msg)). [docs]class ValidationError(QcdbException):; """"""Error called for problems with syntax input file. Prints; error message *msg* to standard output stream. """"""; def __init__(self, msg):; QcdbException.__init__(self, msg); self.msg = msg; print('\nQcdbException: %s\n\n' % (msg)). [docs]class IncompleteAtomError(QcdbException):; """"""Error raised when not all variables in an atom specification; have been defined at compute time. May be a temporary situation; so message not printed but appears as traceback when error persists. """"""; def __init__(self, msg):; QcdbException.__init__(self, msg); self.msg = msg. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  ; PSI4 [beta5]  ; Module code .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/_modules/qcdb/exceptions.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/exceptions.html
https://psicode.org/psi4manual/4.0b5/_modules/qcdb/exceptions.html:1442,Security,Validat,ValidationError,1442,"istribute it and/or modify; # it under the terms of the GNU General Public License as published by; # the Free Software Foundation; either version 2 of the License, or; # (at your option) any later version.; #; # This program is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU General Public License for more details.; #; # You should have received a copy of the GNU General Public License along; # with this program; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; #@END LICENSE; #. """"""Module with non-generic exceptions classes."""""". [docs]class QcdbException(Exception):; """"""Error class for QCDB.""""""; pass. [docs]class FeatureNotImplemented(QcdbException):; """"""Error called for functions defined but not yet implemented.; Also for functions defined that will never be implemented. """"""; def __init__(self, msg):; QcdbException.__init__(self, msg); self.msg = msg; print('\nQcdbException: Feature %s is not yet implemented.\n\n' % (msg)). [docs]class ValidationError(QcdbException):; """"""Error called for problems with syntax input file. Prints; error message *msg* to standard output stream. """"""; def __init__(self, msg):; QcdbException.__init__(self, msg); self.msg = msg; print('\nQcdbException: %s\n\n' % (msg)). [docs]class IncompleteAtomError(QcdbException):; """"""Error raised when not all variables in an atom specification; have been defined at compute time. May be a temporary situation; so message not printed but appears as traceback when error persists. """"""; def __init__(self, msg):; QcdbException.__init__(self, msg); self.msg = msg. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  ; PSI4 [beta5]  ; Module code .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/_modules/qcdb/exceptions.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/exceptions.html
https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintscoordentry.html:5995,Availability,ERROR,ERROR,5995,"n FValue = %s\n Name = %s\n Negated = %s\n Map = %s\n\n' % \; (self.PYfixed, self.computed, self.type(), self.compute(), self.variable_to_string(4), self.name(), self.negated(), self.geometryVariables). [docs]class CoordEntry(object):; """"""Class to. """"""; def __init__(self, entry_number, Z, charge, mass, symbol, label=""""):; # Order in full atomic list; self.PYentry_number = entry_number; # Whether the coordinates have been computed; self.computed = False; # Actual cartesian coordinates of the atom; self.coordinates = [None, None, None]. # Atomic number of the atom; self.PYZ = Z; # Charge of the atom (SAD-related); self.PYcharge = charge; # Mass of the atom; self.PYmass = mass; # Label of the atom minus any extra info (H1 => H); self.PYsymbol = symbol; # Original label from the molecule from the input file (H1); self.PYlabel = label; # Is this a ghost atom?; self.ghosted = False. @staticmethod; [docs] def r(a1, a2):; """"""Computes the distance between two sets of coordinates""""""; if len(a1) != 3 or len(a2) != 3:; raise ValidationError('ERROR: r() only defined for Vector3\n'); return distance(a1, a2). @staticmethod; [docs] def a(a1, a2, a3):; """"""Computes the angle (in rad.) between three sets of coordinates.""""""; if len(a1) != 3 or len(a2) != 3 or len(a3) != 3:; raise ValidationError('ERROR: a() only defined for Vector3\n'); eBA = sub(a2, a1); eBC = sub(a2, a3); eBA = normalize(eBA); eBC = normalize(eBC); costheta = dot(eBA, eBC). if costheta > 1.0 - 1.0E-14:; costheta = 1.0; if costheta < 1.0E-14 - 1.0:; costheta = -1.0; return math.acos(costheta). @staticmethod; [docs] def d(a1, a2, a3, a4):; """"""Computes the dihedral (in rad.) between four sets of coordinates.""""""; if len(a1) != 3 or len(a2) != 3 or len(a3) != 3 or len(a4) != 3:; raise ValidationError('ERROR: d() only defined for Vector3\n'); eBA = sub(a2, a1); eDC = sub(a4, a3); eCB = sub(a3, a2); CBNorm = norm(eCB); DCxCB = cross(eDC, eCB); CBxBA = cross(eCB, eBA); return -1.0 * math.atan2(CBNorm * dot(eDC, CBxBA), dot(D",MatchSource.WIKI,psi4manual/4.0b5/_modules/qcdb/libmintscoordentry.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintscoordentry.html
https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintscoordentry.html:6247,Availability,ERROR,ERROR,6247,"n full atomic list; self.PYentry_number = entry_number; # Whether the coordinates have been computed; self.computed = False; # Actual cartesian coordinates of the atom; self.coordinates = [None, None, None]. # Atomic number of the atom; self.PYZ = Z; # Charge of the atom (SAD-related); self.PYcharge = charge; # Mass of the atom; self.PYmass = mass; # Label of the atom minus any extra info (H1 => H); self.PYsymbol = symbol; # Original label from the molecule from the input file (H1); self.PYlabel = label; # Is this a ghost atom?; self.ghosted = False. @staticmethod; [docs] def r(a1, a2):; """"""Computes the distance between two sets of coordinates""""""; if len(a1) != 3 or len(a2) != 3:; raise ValidationError('ERROR: r() only defined for Vector3\n'); return distance(a1, a2). @staticmethod; [docs] def a(a1, a2, a3):; """"""Computes the angle (in rad.) between three sets of coordinates.""""""; if len(a1) != 3 or len(a2) != 3 or len(a3) != 3:; raise ValidationError('ERROR: a() only defined for Vector3\n'); eBA = sub(a2, a1); eBC = sub(a2, a3); eBA = normalize(eBA); eBC = normalize(eBC); costheta = dot(eBA, eBC). if costheta > 1.0 - 1.0E-14:; costheta = 1.0; if costheta < 1.0E-14 - 1.0:; costheta = -1.0; return math.acos(costheta). @staticmethod; [docs] def d(a1, a2, a3, a4):; """"""Computes the dihedral (in rad.) between four sets of coordinates.""""""; if len(a1) != 3 or len(a2) != 3 or len(a3) != 3 or len(a4) != 3:; raise ValidationError('ERROR: d() only defined for Vector3\n'); eBA = sub(a2, a1); eDC = sub(a4, a3); eCB = sub(a3, a2); CBNorm = norm(eCB); DCxCB = cross(eDC, eCB); CBxBA = cross(eCB, eBA); return -1.0 * math.atan2(CBNorm * dot(eDC, CBxBA), dot(DCxCB, CBxBA)). [docs] def is_computed(self):; """"""Whether the current atom's coordinates are up-to-date.""""""; return self.computed. [docs] def is_equivalent_to(self, other):; """"""Whether this atom has the same mass and ghost status as atom *other*.; Unlike the libmints version, this does not compare basisset assignment. """"""; if other.",MatchSource.WIKI,psi4manual/4.0b5/_modules/qcdb/libmintscoordentry.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintscoordentry.html
https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintscoordentry.html:6725,Availability,ERROR,ERROR,6725,"); self.PYlabel = label; # Is this a ghost atom?; self.ghosted = False. @staticmethod; [docs] def r(a1, a2):; """"""Computes the distance between two sets of coordinates""""""; if len(a1) != 3 or len(a2) != 3:; raise ValidationError('ERROR: r() only defined for Vector3\n'); return distance(a1, a2). @staticmethod; [docs] def a(a1, a2, a3):; """"""Computes the angle (in rad.) between three sets of coordinates.""""""; if len(a1) != 3 or len(a2) != 3 or len(a3) != 3:; raise ValidationError('ERROR: a() only defined for Vector3\n'); eBA = sub(a2, a1); eBC = sub(a2, a3); eBA = normalize(eBA); eBC = normalize(eBC); costheta = dot(eBA, eBC). if costheta > 1.0 - 1.0E-14:; costheta = 1.0; if costheta < 1.0E-14 - 1.0:; costheta = -1.0; return math.acos(costheta). @staticmethod; [docs] def d(a1, a2, a3, a4):; """"""Computes the dihedral (in rad.) between four sets of coordinates.""""""; if len(a1) != 3 or len(a2) != 3 or len(a3) != 3 or len(a4) != 3:; raise ValidationError('ERROR: d() only defined for Vector3\n'); eBA = sub(a2, a1); eDC = sub(a4, a3); eCB = sub(a3, a2); CBNorm = norm(eCB); DCxCB = cross(eDC, eCB); CBxBA = cross(eCB, eBA); return -1.0 * math.atan2(CBNorm * dot(eDC, CBxBA), dot(DCxCB, CBxBA)). [docs] def is_computed(self):; """"""Whether the current atom's coordinates are up-to-date.""""""; return self.computed. [docs] def is_equivalent_to(self, other):; """"""Whether this atom has the same mass and ghost status as atom *other*.; Unlike the libmints version, this does not compare basisset assignment. """"""; if other.PYZ != self.PYZ:; return False; if other.PYmass != self.PYmass:; return False; if other.ghosted != self.ghosted:; return False; return True. [docs] def is_ghosted(self):; """"""Whether the current atom is ghosted or not.""""""; return self.ghosted. [docs] def set_ghosted(self, gh):; """"""Flag the atom as either ghost or real.""""""; self.ghosted = gh. [docs] def Z(self):; """"""The nuclear charge of the current atom (0 if ghosted).""""""; if self.ghosted:; return 0.0; else:; return self.PYZ. [docs",MatchSource.WIKI,psi4manual/4.0b5/_modules/qcdb/libmintscoordentry.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintscoordentry.html
https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintscoordentry.html:9344,Deployability,update,updates,9344,"s = %f\n Symbol = %s\n Label = %s\n Ghosted = %s\n Coordinates = %s\n\n' % \; (self.entry_number(), self.is_computed(), self.Z(), self.charge(), self.mass(), self.symbol(), self.label(), self.is_ghosted(), self.coordinates). [docs]class CartesianEntry(CoordEntry):; """"""Class to hold all information about an atom, including its; coordinate specification as three Cartesians. """"""; def __init__(self, entry_number, Z, charge, mass, symbol, label, x, y, z):; CoordEntry.__init__(self, entry_number, Z, charge, mass, symbol, label); self.x = x; self.y = y; self.z = z. [docs] def compute(self):; """"""Computes the values of the coordinates (in whichever units; were inputted), returning them in a Vector. """"""; if self.computed:; return self.coordinates; self.coordinates[0] = self.x.compute(); self.coordinates[1] = self.y.compute(); self.coordinates[2] = self.z.compute(); self.computed = True; return self.coordinates. [docs] def set_coordinates(self, x, y, z):; """"""Given the current set of coordinates, updates the values of this; atom's coordinates and any variables that may depend on it. """"""; self.coordinates[0] = x; self.coordinates[1] = y; self.coordinates[2] = z. self.x.rset(x); self.y.rset(y); self.z.rset(z). self.computed = True. [docs] def type(self):; """"""The type of CoordEntry specialization.""""""; return 'CartesianCoord'. [docs] def print_in_input_format(self):; """"""Prints the updated geometry, in the format provided by the user.""""""; xstr = self.x.variable_to_string(12); ystr = self.y.variable_to_string(12); zstr = self.z.variable_to_string(12); return "" %17s %17s %17s\n"" % (xstr, ystr, zstr); # should go to outfile. [docs] def invalidate(self):; """"""Flags the current coordinates as being outdated.""""""; self.computed = False; self.x.invalidate(); self.y.invalidate(); self.z.invalidate(). [docs] def clone(self):; """"""Returns new, independent CartesianEntry object""""""; return copy.deepcopy(self). [docs] def everything(self):; CoordEntry.everything(self); print '\nCartesianEntry\n Type",MatchSource.WIKI,psi4manual/4.0b5/_modules/qcdb/libmintscoordentry.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintscoordentry.html
https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintscoordentry.html:9732,Deployability,update,updated,9732,"init__(self, entry_number, Z, charge, mass, symbol, label, x, y, z):; CoordEntry.__init__(self, entry_number, Z, charge, mass, symbol, label); self.x = x; self.y = y; self.z = z. [docs] def compute(self):; """"""Computes the values of the coordinates (in whichever units; were inputted), returning them in a Vector. """"""; if self.computed:; return self.coordinates; self.coordinates[0] = self.x.compute(); self.coordinates[1] = self.y.compute(); self.coordinates[2] = self.z.compute(); self.computed = True; return self.coordinates. [docs] def set_coordinates(self, x, y, z):; """"""Given the current set of coordinates, updates the values of this; atom's coordinates and any variables that may depend on it. """"""; self.coordinates[0] = x; self.coordinates[1] = y; self.coordinates[2] = z. self.x.rset(x); self.y.rset(y); self.z.rset(z). self.computed = True. [docs] def type(self):; """"""The type of CoordEntry specialization.""""""; return 'CartesianCoord'. [docs] def print_in_input_format(self):; """"""Prints the updated geometry, in the format provided by the user.""""""; xstr = self.x.variable_to_string(12); ystr = self.y.variable_to_string(12); zstr = self.z.variable_to_string(12); return "" %17s %17s %17s\n"" % (xstr, ystr, zstr); # should go to outfile. [docs] def invalidate(self):; """"""Flags the current coordinates as being outdated.""""""; self.computed = False; self.x.invalidate(); self.y.invalidate(); self.z.invalidate(). [docs] def clone(self):; """"""Returns new, independent CartesianEntry object""""""; return copy.deepcopy(self). [docs] def everything(self):; CoordEntry.everything(self); print '\nCartesianEntry\n Type = %s\n x = %s\n y = %s\n z = %s\n\n' % (self.type(), self.x.variable_to_string(8), self.y.variable_to_string(8), self.z.variable_to_string(8)). [docs]class ZMatrixEntry(CoordEntry):; """"""Class to hold all information about an atom, including its; coordinate specification as any position of ZMatrix. """"""; def __init__(self, entry_number, Z, charge, mass, symbol, label, \; rto=None, rva",MatchSource.WIKI,psi4manual/4.0b5/_modules/qcdb/libmintscoordentry.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintscoordentry.html
https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintscoordentry.html:11244,Deployability,update,updated,11244,". [docs] def everything(self):; CoordEntry.everything(self); print '\nCartesianEntry\n Type = %s\n x = %s\n y = %s\n z = %s\n\n' % (self.type(), self.x.variable_to_string(8), self.y.variable_to_string(8), self.z.variable_to_string(8)). [docs]class ZMatrixEntry(CoordEntry):; """"""Class to hold all information about an atom, including its; coordinate specification as any position of ZMatrix. """"""; def __init__(self, entry_number, Z, charge, mass, symbol, label, \; rto=None, rval=0, ato=None, aval=0, dto=None, dval=0):; CoordEntry.__init__(self, entry_number, Z, charge, mass, symbol, label); self.rto = rto; self.rval = rval; self.ato = ato; self.aval = aval; self.dto = dto; self.dval = dval. [docs] def invalidate(self):; """"""Flags the current coordinates as being outdated""""""; self.computed = False; if self.rval != 0:; self.rval.invalidate(); if self.aval != 0:; self.aval.invalidate(); if self.dval != 0:; self.dval.invalidate(). [docs] def print_in_input_format(self):; """"""Prints the updated geometry, in the format provided by the user""""""; text = """"; if self.rto == None and self.ato == None and self.dto == None:; # The first atom; text += ""\n""; elif self.ato == None and self.dto == None:; # The second atom; now_rto = self.rto.entry_number() + 1; now_rval = self.rval.variable_to_string(6); text += "" %5d %11s\n"" % (now_rto, now_rval); elif self.dto == None:; # The third atom; now_rto = self.rto.entry_number() + 1; now_rval = self.rval.variable_to_string(6); now_ato = self.ato.entry_number() + 1; now_aval = self.aval.variable_to_string(6); text += "" %5d %11s %5d %11s\n"" % (now_rto, now_rval, now_ato, now_aval); else:; # Remaining atoms; now_rto = self.rto.entry_number() + 1; now_rval = self.rval.variable_to_string(6); now_ato = self.ato.entry_number() + 1; now_aval = self.aval.variable_to_string(6); now_dto = self.dto.entry_number() + 1; now_dval = self.dval.variable_to_string(6); text += "" %5d %11s %5d %11s %5d %11s\n"" % \; (now_rto, now_rval, now_ato, now_aval, now_dto, now_d",MatchSource.WIKI,psi4manual/4.0b5/_modules/qcdb/libmintscoordentry.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintscoordentry.html
https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintscoordentry.html:12369,Deployability,update,updates,12369,"one:; # The first atom; text += ""\n""; elif self.ato == None and self.dto == None:; # The second atom; now_rto = self.rto.entry_number() + 1; now_rval = self.rval.variable_to_string(6); text += "" %5d %11s\n"" % (now_rto, now_rval); elif self.dto == None:; # The third atom; now_rto = self.rto.entry_number() + 1; now_rval = self.rval.variable_to_string(6); now_ato = self.ato.entry_number() + 1; now_aval = self.aval.variable_to_string(6); text += "" %5d %11s %5d %11s\n"" % (now_rto, now_rval, now_ato, now_aval); else:; # Remaining atoms; now_rto = self.rto.entry_number() + 1; now_rval = self.rval.variable_to_string(6); now_ato = self.ato.entry_number() + 1; now_aval = self.aval.variable_to_string(6); now_dto = self.dto.entry_number() + 1; now_dval = self.dval.variable_to_string(6); text += "" %5d %11s %5d %11s %5d %11s\n"" % \; (now_rto, now_rval, now_ato, now_aval, now_dto, now_dval); return text; # outfile. [docs] def set_coordinates(self, x, y, z):; """"""Given the current set of coordinates, updates the values of this; atom's coordinates, and any variables that may depend on it. """"""; self.coordinates[0] = 0.0 if math.fabs(x) < 1.0E-14 else x; self.coordinates[1] = 0.0 if math.fabs(y) < 1.0E-14 else y; self.coordinates[2] = 0.0 if math.fabs(z) < 1.0E-14 else z. if self.rto != None:; if not self.rto.is_computed():; raise ValidationError(""Coordinates have been set in the wrong order""); self.rval.rset(self.r(self.coordinates, self.rto.compute())). if self.ato != None:; if not self.ato.is_computed():; raise ValidationError(""Coordinates have been set in the wrong order""); aval = self.a(self.coordinates, self.rto.compute(), self.ato.compute()); # Noise creeps in for linear molecules. Force linearity, if it is close enough.; val = aval * 180.0 / math.pi; self.aval.rset(val). if self.dto != None:; if not self.dto.is_computed():; raise ValidationError(""Coordinates have been set in the wrong order""); val = self.d(self.coordinates, self.rto.compute(), self.ato.compute(), self.dto.compu",MatchSource.WIKI,psi4manual/4.0b5/_modules/qcdb/libmintscoordentry.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintscoordentry.html
https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintscoordentry.html:13404,Deployability,update,update,13404,"ariables that may depend on it. """"""; self.coordinates[0] = 0.0 if math.fabs(x) < 1.0E-14 else x; self.coordinates[1] = 0.0 if math.fabs(y) < 1.0E-14 else y; self.coordinates[2] = 0.0 if math.fabs(z) < 1.0E-14 else z. if self.rto != None:; if not self.rto.is_computed():; raise ValidationError(""Coordinates have been set in the wrong order""); self.rval.rset(self.r(self.coordinates, self.rto.compute())). if self.ato != None:; if not self.ato.is_computed():; raise ValidationError(""Coordinates have been set in the wrong order""); aval = self.a(self.coordinates, self.rto.compute(), self.ato.compute()); # Noise creeps in for linear molecules. Force linearity, if it is close enough.; val = aval * 180.0 / math.pi; self.aval.rset(val). if self.dto != None:; if not self.dto.is_computed():; raise ValidationError(""Coordinates have been set in the wrong order""); val = self.d(self.coordinates, self.rto.compute(), self.ato.compute(), self.dto.compute()); # Check for NaN, and don't update if we find one; # what is this? proper py traslation?; if val == val:; self.dval.rset(val * 180.0 / math.pi). self.computed = True. [docs] def type(self):; """"""The type of CoordEntry specialization.""""""; return 'ZMatrixCoord'. [docs] def clone(self):; """"""Returns new, independent ZMatrixEntry object.""""""; return copy.deepcopy(self). [docs] def compute(self):; """"""Compute the Cartesian coordinates in Bohr of current atom's entry."""""". if self.computed:; return self.coordinates. # place first atom at the origin; if self.rto == None and self.ato == None and self.dto == None:; self.coordinates[0] = 0.0; self.coordinates[1] = 0.0; self.coordinates[2] = 0.0. # place second atom directly above the first; elif self.ato == None and self.dto == None:; self.coordinates[0] = 0.0; self.coordinates[1] = 0.0; self.coordinates[2] = self.rval.compute(). # place third atom pointing upwards; # this rTo rVal aTo aVal; # A B C; elif self.dto == None:; r = self.rval.compute(); a = self.aval.compute() * math.pi / 180.0; cosABC =",MatchSource.WIKI,psi4manual/4.0b5/_modules/qcdb/libmintscoordentry.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintscoordentry.html
https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintscoordentry.html:16349,Deployability,update,updated,16349,"pi / 180.0; cosABC = math.cos(a); sinABC = math.sin(a); B = self.rto.compute(); C = self.ato.compute(). eCB = sub(B, C); eCB = normalize(eCB); eX = [0.0, 0.0, 0.0]; eY = [0.0, 0.0, 0.0]; if (math.fabs(1.0 - math.fabs(eCB[0])) < 1.0E-5):; # CB is collinear with X, start by finding Y; eY[1] = 1.0; eX = perp_unit(eY, eCB); eY = perp_unit(eX, eCB); else:; # CB is not collinear with X, we can safely find X first; eX[0] = 1.0; eY = perp_unit(eX, eCB); eX = perp_unit(eY, eCB); for xyz in range(3):; self.coordinates[xyz] = B[xyz] + r * (eY[xyz] * sinABC - eCB[xyz] * cosABC); if math.fabs(self.coordinates[xyz]) < 1.E-14:; self.coordinates[xyz] = 0.0. # The fourth, or subsequent, atom; #; # The atom specification is; # this rTo rVal aTo aVal dTo dVal; # A B C D; # which allows us to define the vector from C->B (eCB) as the +z axis, and eDC; # lies in the xz plane. Then eX, eY and eZ (=eBC) are the x, y, and z axes, respecively.; else:; r = self.rval.compute(); a = self.aval.compute() * math.pi / 180.0; d = self.dval.compute() * math.pi / 180.0; B = self.rto.compute(); C = self.ato.compute(); D = self.dto.compute(). eDC = sub(C, D); eCB = sub(B, C); eDC = normalize(eDC); eCB = normalize(eCB); cosABC = math.cos(a); sinABC = math.sin(a); cosABCD = math.cos(d); sinABCD = math.sin(d); eY = perp_unit(eDC, eCB); eX = perp_unit(eY, eCB); for xyz in range(3):; self.coordinates[xyz] = B[xyz] + r * (eX[xyz] * sinABC * cosABCD +; eY[xyz] * sinABC * sinABCD - eCB[xyz] * cosABC); if math.fabs(self.coordinates[xyz]) < 1.E-14:; self.coordinates[xyz] = 0.0. self.computed = True; return self.coordinates. [docs] def everything(self):; CoordEntry.everything(self); print '\nZMatrixEntry\n Type = %s\n\n' % (self.type()); print self.print_in_input_format(). Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  ; PSI4 [beta5]  ; Module code .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/_modules/qcdb/libmintscoordentry.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintscoordentry.html
https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintscoordentry.html:5239,Energy Efficiency,charge,charge,5239,"set(self, val):; """"""Resets value of coordinate if not fixed""""""; if not self.PYfixed:; if self.negate:; self.geometryVariables[self.PYname] = val * -1.0; else:; self.geometryVariables[self.PYname] = val. [docs] def type(self):; """"""Gets specialization type of CoordValue""""""; return 'VariableType'. [docs] def clone(self):; """"""Returns new, independent VariableValue object""""""; return copy.deepcopy(self). [docs] def variable_to_string(self, precision):; """"""Takes a CoordValue object, and returns a string for printing.""""""; if self.negate:; return '-' + self.PYname; else:; return self.PYname. [docs] def everything(self):; print '\nVariableValue\n Fixed = %s\n Computed = %s\n Type = %s\n Value = %f\n FValue = %s\n Name = %s\n Negated = %s\n Map = %s\n\n' % \; (self.PYfixed, self.computed, self.type(), self.compute(), self.variable_to_string(4), self.name(), self.negated(), self.geometryVariables). [docs]class CoordEntry(object):; """"""Class to. """"""; def __init__(self, entry_number, Z, charge, mass, symbol, label=""""):; # Order in full atomic list; self.PYentry_number = entry_number; # Whether the coordinates have been computed; self.computed = False; # Actual cartesian coordinates of the atom; self.coordinates = [None, None, None]. # Atomic number of the atom; self.PYZ = Z; # Charge of the atom (SAD-related); self.PYcharge = charge; # Mass of the atom; self.PYmass = mass; # Label of the atom minus any extra info (H1 => H); self.PYsymbol = symbol; # Original label from the molecule from the input file (H1); self.PYlabel = label; # Is this a ghost atom?; self.ghosted = False. @staticmethod; [docs] def r(a1, a2):; """"""Computes the distance between two sets of coordinates""""""; if len(a1) != 3 or len(a2) != 3:; raise ValidationError('ERROR: r() only defined for Vector3\n'); return distance(a1, a2). @staticmethod; [docs] def a(a1, a2, a3):; """"""Computes the angle (in rad.) between three sets of coordinates.""""""; if len(a1) != 3 or len(a2) != 3 or len(a3) != 3:; raise ValidationError('ERROR",MatchSource.WIKI,psi4manual/4.0b5/_modules/qcdb/libmintscoordentry.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintscoordentry.html
https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintscoordentry.html:5535,Energy Efficiency,Charge,Charge,5535,"docs] def clone(self):; """"""Returns new, independent VariableValue object""""""; return copy.deepcopy(self). [docs] def variable_to_string(self, precision):; """"""Takes a CoordValue object, and returns a string for printing.""""""; if self.negate:; return '-' + self.PYname; else:; return self.PYname. [docs] def everything(self):; print '\nVariableValue\n Fixed = %s\n Computed = %s\n Type = %s\n Value = %f\n FValue = %s\n Name = %s\n Negated = %s\n Map = %s\n\n' % \; (self.PYfixed, self.computed, self.type(), self.compute(), self.variable_to_string(4), self.name(), self.negated(), self.geometryVariables). [docs]class CoordEntry(object):; """"""Class to. """"""; def __init__(self, entry_number, Z, charge, mass, symbol, label=""""):; # Order in full atomic list; self.PYentry_number = entry_number; # Whether the coordinates have been computed; self.computed = False; # Actual cartesian coordinates of the atom; self.coordinates = [None, None, None]. # Atomic number of the atom; self.PYZ = Z; # Charge of the atom (SAD-related); self.PYcharge = charge; # Mass of the atom; self.PYmass = mass; # Label of the atom minus any extra info (H1 => H); self.PYsymbol = symbol; # Original label from the molecule from the input file (H1); self.PYlabel = label; # Is this a ghost atom?; self.ghosted = False. @staticmethod; [docs] def r(a1, a2):; """"""Computes the distance between two sets of coordinates""""""; if len(a1) != 3 or len(a2) != 3:; raise ValidationError('ERROR: r() only defined for Vector3\n'); return distance(a1, a2). @staticmethod; [docs] def a(a1, a2, a3):; """"""Computes the angle (in rad.) between three sets of coordinates.""""""; if len(a1) != 3 or len(a2) != 3 or len(a3) != 3:; raise ValidationError('ERROR: a() only defined for Vector3\n'); eBA = sub(a2, a1); eBC = sub(a2, a3); eBA = normalize(eBA); eBC = normalize(eBC); costheta = dot(eBA, eBC). if costheta > 1.0 - 1.0E-14:; costheta = 1.0; if costheta < 1.0E-14 - 1.0:; costheta = -1.0; return math.acos(costheta). @staticmethod; [docs] def d(a1, ",MatchSource.WIKI,psi4manual/4.0b5/_modules/qcdb/libmintscoordentry.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintscoordentry.html
https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintscoordentry.html:5585,Energy Efficiency,charge,charge,5585,"dent VariableValue object""""""; return copy.deepcopy(self). [docs] def variable_to_string(self, precision):; """"""Takes a CoordValue object, and returns a string for printing.""""""; if self.negate:; return '-' + self.PYname; else:; return self.PYname. [docs] def everything(self):; print '\nVariableValue\n Fixed = %s\n Computed = %s\n Type = %s\n Value = %f\n FValue = %s\n Name = %s\n Negated = %s\n Map = %s\n\n' % \; (self.PYfixed, self.computed, self.type(), self.compute(), self.variable_to_string(4), self.name(), self.negated(), self.geometryVariables). [docs]class CoordEntry(object):; """"""Class to. """"""; def __init__(self, entry_number, Z, charge, mass, symbol, label=""""):; # Order in full atomic list; self.PYentry_number = entry_number; # Whether the coordinates have been computed; self.computed = False; # Actual cartesian coordinates of the atom; self.coordinates = [None, None, None]. # Atomic number of the atom; self.PYZ = Z; # Charge of the atom (SAD-related); self.PYcharge = charge; # Mass of the atom; self.PYmass = mass; # Label of the atom minus any extra info (H1 => H); self.PYsymbol = symbol; # Original label from the molecule from the input file (H1); self.PYlabel = label; # Is this a ghost atom?; self.ghosted = False. @staticmethod; [docs] def r(a1, a2):; """"""Computes the distance between two sets of coordinates""""""; if len(a1) != 3 or len(a2) != 3:; raise ValidationError('ERROR: r() only defined for Vector3\n'); return distance(a1, a2). @staticmethod; [docs] def a(a1, a2, a3):; """"""Computes the angle (in rad.) between three sets of coordinates.""""""; if len(a1) != 3 or len(a2) != 3 or len(a3) != 3:; raise ValidationError('ERROR: a() only defined for Vector3\n'); eBA = sub(a2, a1); eBC = sub(a2, a3); eBA = normalize(eBA); eBC = normalize(eBC); costheta = dot(eBA, eBC). if costheta > 1.0 - 1.0E-14:; costheta = 1.0; if costheta < 1.0E-14 - 1.0:; costheta = -1.0; return math.acos(costheta). @staticmethod; [docs] def d(a1, a2, a3, a4):; """"""Computes the dihedral (in rad.",MatchSource.WIKI,psi4manual/4.0b5/_modules/qcdb/libmintscoordentry.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintscoordentry.html
https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintscoordentry.html:7661,Energy Efficiency,charge,charge,7661,"!= 3 or len(a3) != 3 or len(a4) != 3:; raise ValidationError('ERROR: d() only defined for Vector3\n'); eBA = sub(a2, a1); eDC = sub(a4, a3); eCB = sub(a3, a2); CBNorm = norm(eCB); DCxCB = cross(eDC, eCB); CBxBA = cross(eCB, eBA); return -1.0 * math.atan2(CBNorm * dot(eDC, CBxBA), dot(DCxCB, CBxBA)). [docs] def is_computed(self):; """"""Whether the current atom's coordinates are up-to-date.""""""; return self.computed. [docs] def is_equivalent_to(self, other):; """"""Whether this atom has the same mass and ghost status as atom *other*.; Unlike the libmints version, this does not compare basisset assignment. """"""; if other.PYZ != self.PYZ:; return False; if other.PYmass != self.PYmass:; return False; if other.ghosted != self.ghosted:; return False; return True. [docs] def is_ghosted(self):; """"""Whether the current atom is ghosted or not.""""""; return self.ghosted. [docs] def set_ghosted(self, gh):; """"""Flag the atom as either ghost or real.""""""; self.ghosted = gh. [docs] def Z(self):; """"""The nuclear charge of the current atom (0 if ghosted).""""""; if self.ghosted:; return 0.0; else:; return self.PYZ. [docs] def charge(self):; """"""The ""atomic charge"" of the current atom (for SAD purposes).""""""; return self.PYcharge. [docs] def mass(self):; """"""The atomic mass of the current atom.""""""; return self.PYmass. [docs] def symbol(self):; """"""The atomic symbol.""""""; return self.PYsymbol. [docs] def label(self):; """"""The atom label.""""""; return self.PYlabel. [docs] def entry_number(self):; """"""The order in which this appears in the full atom list.""""""; return self.PYentry_number. [docs] def everything(self):; print '\nCoordEntry\n Entry Number = %d\n Computed = %s\n Z = %d\n Charge = %f\n Mass = %f\n Symbol = %s\n Label = %s\n Ghosted = %s\n Coordinates = %s\n\n' % \; (self.entry_number(), self.is_computed(), self.Z(), self.charge(), self.mass(), self.symbol(), self.label(), self.is_ghosted(), self.coordinates). [docs]class CartesianEntry(CoordEntry):; """"""Class to hold all information about an atom, includ",MatchSource.WIKI,psi4manual/4.0b5/_modules/qcdb/libmintscoordentry.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintscoordentry.html
https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintscoordentry.html:7773,Energy Efficiency,charge,charge,7773,"CB = sub(a3, a2); CBNorm = norm(eCB); DCxCB = cross(eDC, eCB); CBxBA = cross(eCB, eBA); return -1.0 * math.atan2(CBNorm * dot(eDC, CBxBA), dot(DCxCB, CBxBA)). [docs] def is_computed(self):; """"""Whether the current atom's coordinates are up-to-date.""""""; return self.computed. [docs] def is_equivalent_to(self, other):; """"""Whether this atom has the same mass and ghost status as atom *other*.; Unlike the libmints version, this does not compare basisset assignment. """"""; if other.PYZ != self.PYZ:; return False; if other.PYmass != self.PYmass:; return False; if other.ghosted != self.ghosted:; return False; return True. [docs] def is_ghosted(self):; """"""Whether the current atom is ghosted or not.""""""; return self.ghosted. [docs] def set_ghosted(self, gh):; """"""Flag the atom as either ghost or real.""""""; self.ghosted = gh. [docs] def Z(self):; """"""The nuclear charge of the current atom (0 if ghosted).""""""; if self.ghosted:; return 0.0; else:; return self.PYZ. [docs] def charge(self):; """"""The ""atomic charge"" of the current atom (for SAD purposes).""""""; return self.PYcharge. [docs] def mass(self):; """"""The atomic mass of the current atom.""""""; return self.PYmass. [docs] def symbol(self):; """"""The atomic symbol.""""""; return self.PYsymbol. [docs] def label(self):; """"""The atom label.""""""; return self.PYlabel. [docs] def entry_number(self):; """"""The order in which this appears in the full atom list.""""""; return self.PYentry_number. [docs] def everything(self):; print '\nCoordEntry\n Entry Number = %d\n Computed = %s\n Z = %d\n Charge = %f\n Mass = %f\n Symbol = %s\n Label = %s\n Ghosted = %s\n Coordinates = %s\n\n' % \; (self.entry_number(), self.is_computed(), self.Z(), self.charge(), self.mass(), self.symbol(), self.label(), self.is_ghosted(), self.coordinates). [docs]class CartesianEntry(CoordEntry):; """"""Class to hold all information about an atom, including its; coordinate specification as three Cartesians. """"""; def __init__(self, entry_number, Z, charge, mass, symbol, label, x, y, z):; CoordE",MatchSource.WIKI,psi4manual/4.0b5/_modules/qcdb/libmintscoordentry.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintscoordentry.html
https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintscoordentry.html:7803,Energy Efficiency,charge,charge,7803,"CB = sub(a3, a2); CBNorm = norm(eCB); DCxCB = cross(eDC, eCB); CBxBA = cross(eCB, eBA); return -1.0 * math.atan2(CBNorm * dot(eDC, CBxBA), dot(DCxCB, CBxBA)). [docs] def is_computed(self):; """"""Whether the current atom's coordinates are up-to-date.""""""; return self.computed. [docs] def is_equivalent_to(self, other):; """"""Whether this atom has the same mass and ghost status as atom *other*.; Unlike the libmints version, this does not compare basisset assignment. """"""; if other.PYZ != self.PYZ:; return False; if other.PYmass != self.PYmass:; return False; if other.ghosted != self.ghosted:; return False; return True. [docs] def is_ghosted(self):; """"""Whether the current atom is ghosted or not.""""""; return self.ghosted. [docs] def set_ghosted(self, gh):; """"""Flag the atom as either ghost or real.""""""; self.ghosted = gh. [docs] def Z(self):; """"""The nuclear charge of the current atom (0 if ghosted).""""""; if self.ghosted:; return 0.0; else:; return self.PYZ. [docs] def charge(self):; """"""The ""atomic charge"" of the current atom (for SAD purposes).""""""; return self.PYcharge. [docs] def mass(self):; """"""The atomic mass of the current atom.""""""; return self.PYmass. [docs] def symbol(self):; """"""The atomic symbol.""""""; return self.PYsymbol. [docs] def label(self):; """"""The atom label.""""""; return self.PYlabel. [docs] def entry_number(self):; """"""The order in which this appears in the full atom list.""""""; return self.PYentry_number. [docs] def everything(self):; print '\nCoordEntry\n Entry Number = %d\n Computed = %s\n Z = %d\n Charge = %f\n Mass = %f\n Symbol = %s\n Label = %s\n Ghosted = %s\n Coordinates = %s\n\n' % \; (self.entry_number(), self.is_computed(), self.Z(), self.charge(), self.mass(), self.symbol(), self.label(), self.is_ghosted(), self.coordinates). [docs]class CartesianEntry(CoordEntry):; """"""Class to hold all information about an atom, including its; coordinate specification as three Cartesians. """"""; def __init__(self, entry_number, Z, charge, mass, symbol, label, x, y, z):; CoordE",MatchSource.WIKI,psi4manual/4.0b5/_modules/qcdb/libmintscoordentry.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintscoordentry.html
https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintscoordentry.html:8327,Energy Efficiency,Charge,Charge,8327,"s != self.PYmass:; return False; if other.ghosted != self.ghosted:; return False; return True. [docs] def is_ghosted(self):; """"""Whether the current atom is ghosted or not.""""""; return self.ghosted. [docs] def set_ghosted(self, gh):; """"""Flag the atom as either ghost or real.""""""; self.ghosted = gh. [docs] def Z(self):; """"""The nuclear charge of the current atom (0 if ghosted).""""""; if self.ghosted:; return 0.0; else:; return self.PYZ. [docs] def charge(self):; """"""The ""atomic charge"" of the current atom (for SAD purposes).""""""; return self.PYcharge. [docs] def mass(self):; """"""The atomic mass of the current atom.""""""; return self.PYmass. [docs] def symbol(self):; """"""The atomic symbol.""""""; return self.PYsymbol. [docs] def label(self):; """"""The atom label.""""""; return self.PYlabel. [docs] def entry_number(self):; """"""The order in which this appears in the full atom list.""""""; return self.PYentry_number. [docs] def everything(self):; print '\nCoordEntry\n Entry Number = %d\n Computed = %s\n Z = %d\n Charge = %f\n Mass = %f\n Symbol = %s\n Label = %s\n Ghosted = %s\n Coordinates = %s\n\n' % \; (self.entry_number(), self.is_computed(), self.Z(), self.charge(), self.mass(), self.symbol(), self.label(), self.is_ghosted(), self.coordinates). [docs]class CartesianEntry(CoordEntry):; """"""Class to hold all information about an atom, including its; coordinate specification as three Cartesians. """"""; def __init__(self, entry_number, Z, charge, mass, symbol, label, x, y, z):; CoordEntry.__init__(self, entry_number, Z, charge, mass, symbol, label); self.x = x; self.y = y; self.z = z. [docs] def compute(self):; """"""Computes the values of the coordinates (in whichever units; were inputted), returning them in a Vector. """"""; if self.computed:; return self.coordinates; self.coordinates[0] = self.x.compute(); self.coordinates[1] = self.y.compute(); self.coordinates[2] = self.z.compute(); self.computed = True; return self.coordinates. [docs] def set_coordinates(self, x, y, z):; """"""Given the current set o",MatchSource.WIKI,psi4manual/4.0b5/_modules/qcdb/libmintscoordentry.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintscoordentry.html
https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintscoordentry.html:8479,Energy Efficiency,charge,charge,8479,"osted or not.""""""; return self.ghosted. [docs] def set_ghosted(self, gh):; """"""Flag the atom as either ghost or real.""""""; self.ghosted = gh. [docs] def Z(self):; """"""The nuclear charge of the current atom (0 if ghosted).""""""; if self.ghosted:; return 0.0; else:; return self.PYZ. [docs] def charge(self):; """"""The ""atomic charge"" of the current atom (for SAD purposes).""""""; return self.PYcharge. [docs] def mass(self):; """"""The atomic mass of the current atom.""""""; return self.PYmass. [docs] def symbol(self):; """"""The atomic symbol.""""""; return self.PYsymbol. [docs] def label(self):; """"""The atom label.""""""; return self.PYlabel. [docs] def entry_number(self):; """"""The order in which this appears in the full atom list.""""""; return self.PYentry_number. [docs] def everything(self):; print '\nCoordEntry\n Entry Number = %d\n Computed = %s\n Z = %d\n Charge = %f\n Mass = %f\n Symbol = %s\n Label = %s\n Ghosted = %s\n Coordinates = %s\n\n' % \; (self.entry_number(), self.is_computed(), self.Z(), self.charge(), self.mass(), self.symbol(), self.label(), self.is_ghosted(), self.coordinates). [docs]class CartesianEntry(CoordEntry):; """"""Class to hold all information about an atom, including its; coordinate specification as three Cartesians. """"""; def __init__(self, entry_number, Z, charge, mass, symbol, label, x, y, z):; CoordEntry.__init__(self, entry_number, Z, charge, mass, symbol, label); self.x = x; self.y = y; self.z = z. [docs] def compute(self):; """"""Computes the values of the coordinates (in whichever units; were inputted), returning them in a Vector. """"""; if self.computed:; return self.coordinates; self.coordinates[0] = self.x.compute(); self.coordinates[1] = self.y.compute(); self.coordinates[2] = self.z.compute(); self.computed = True; return self.coordinates. [docs] def set_coordinates(self, x, y, z):; """"""Given the current set of coordinates, updates the values of this; atom's coordinates and any variables that may depend on it. """"""; self.coordinates[0] = x; self.coordinates[1] = y; ",MatchSource.WIKI,psi4manual/4.0b5/_modules/qcdb/libmintscoordentry.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintscoordentry.html
https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintscoordentry.html:8760,Energy Efficiency,charge,charge,8760,"ocs] def charge(self):; """"""The ""atomic charge"" of the current atom (for SAD purposes).""""""; return self.PYcharge. [docs] def mass(self):; """"""The atomic mass of the current atom.""""""; return self.PYmass. [docs] def symbol(self):; """"""The atomic symbol.""""""; return self.PYsymbol. [docs] def label(self):; """"""The atom label.""""""; return self.PYlabel. [docs] def entry_number(self):; """"""The order in which this appears in the full atom list.""""""; return self.PYentry_number. [docs] def everything(self):; print '\nCoordEntry\n Entry Number = %d\n Computed = %s\n Z = %d\n Charge = %f\n Mass = %f\n Symbol = %s\n Label = %s\n Ghosted = %s\n Coordinates = %s\n\n' % \; (self.entry_number(), self.is_computed(), self.Z(), self.charge(), self.mass(), self.symbol(), self.label(), self.is_ghosted(), self.coordinates). [docs]class CartesianEntry(CoordEntry):; """"""Class to hold all information about an atom, including its; coordinate specification as three Cartesians. """"""; def __init__(self, entry_number, Z, charge, mass, symbol, label, x, y, z):; CoordEntry.__init__(self, entry_number, Z, charge, mass, symbol, label); self.x = x; self.y = y; self.z = z. [docs] def compute(self):; """"""Computes the values of the coordinates (in whichever units; were inputted), returning them in a Vector. """"""; if self.computed:; return self.coordinates; self.coordinates[0] = self.x.compute(); self.coordinates[1] = self.y.compute(); self.coordinates[2] = self.z.compute(); self.computed = True; return self.coordinates. [docs] def set_coordinates(self, x, y, z):; """"""Given the current set of coordinates, updates the values of this; atom's coordinates and any variables that may depend on it. """"""; self.coordinates[0] = x; self.coordinates[1] = y; self.coordinates[2] = z. self.x.rset(x); self.y.rset(y); self.z.rset(z). self.computed = True. [docs] def type(self):; """"""The type of CoordEntry specialization.""""""; return 'CartesianCoord'. [docs] def print_in_input_format(self):; """"""Prints the updated geometry, in the format p",MatchSource.WIKI,psi4manual/4.0b5/_modules/qcdb/libmintscoordentry.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintscoordentry.html
https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintscoordentry.html:8843,Energy Efficiency,charge,charge,8843,"oses).""""""; return self.PYcharge. [docs] def mass(self):; """"""The atomic mass of the current atom.""""""; return self.PYmass. [docs] def symbol(self):; """"""The atomic symbol.""""""; return self.PYsymbol. [docs] def label(self):; """"""The atom label.""""""; return self.PYlabel. [docs] def entry_number(self):; """"""The order in which this appears in the full atom list.""""""; return self.PYentry_number. [docs] def everything(self):; print '\nCoordEntry\n Entry Number = %d\n Computed = %s\n Z = %d\n Charge = %f\n Mass = %f\n Symbol = %s\n Label = %s\n Ghosted = %s\n Coordinates = %s\n\n' % \; (self.entry_number(), self.is_computed(), self.Z(), self.charge(), self.mass(), self.symbol(), self.label(), self.is_ghosted(), self.coordinates). [docs]class CartesianEntry(CoordEntry):; """"""Class to hold all information about an atom, including its; coordinate specification as three Cartesians. """"""; def __init__(self, entry_number, Z, charge, mass, symbol, label, x, y, z):; CoordEntry.__init__(self, entry_number, Z, charge, mass, symbol, label); self.x = x; self.y = y; self.z = z. [docs] def compute(self):; """"""Computes the values of the coordinates (in whichever units; were inputted), returning them in a Vector. """"""; if self.computed:; return self.coordinates; self.coordinates[0] = self.x.compute(); self.coordinates[1] = self.y.compute(); self.coordinates[2] = self.z.compute(); self.computed = True; return self.coordinates. [docs] def set_coordinates(self, x, y, z):; """"""Given the current set of coordinates, updates the values of this; atom's coordinates and any variables that may depend on it. """"""; self.coordinates[0] = x; self.coordinates[1] = y; self.coordinates[2] = z. self.x.rset(x); self.y.rset(y); self.z.rset(z). self.computed = True. [docs] def type(self):; """"""The type of CoordEntry specialization.""""""; return 'CartesianCoord'. [docs] def print_in_input_format(self):; """"""Prints the updated geometry, in the format provided by the user.""""""; xstr = self.x.variable_to_string(12); ystr = self.y.var",MatchSource.WIKI,psi4manual/4.0b5/_modules/qcdb/libmintscoordentry.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintscoordentry.html
https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintscoordentry.html:10686,Energy Efficiency,charge,charge,10686,"):; """"""Prints the updated geometry, in the format provided by the user.""""""; xstr = self.x.variable_to_string(12); ystr = self.y.variable_to_string(12); zstr = self.z.variable_to_string(12); return "" %17s %17s %17s\n"" % (xstr, ystr, zstr); # should go to outfile. [docs] def invalidate(self):; """"""Flags the current coordinates as being outdated.""""""; self.computed = False; self.x.invalidate(); self.y.invalidate(); self.z.invalidate(). [docs] def clone(self):; """"""Returns new, independent CartesianEntry object""""""; return copy.deepcopy(self). [docs] def everything(self):; CoordEntry.everything(self); print '\nCartesianEntry\n Type = %s\n x = %s\n y = %s\n z = %s\n\n' % (self.type(), self.x.variable_to_string(8), self.y.variable_to_string(8), self.z.variable_to_string(8)). [docs]class ZMatrixEntry(CoordEntry):; """"""Class to hold all information about an atom, including its; coordinate specification as any position of ZMatrix. """"""; def __init__(self, entry_number, Z, charge, mass, symbol, label, \; rto=None, rval=0, ato=None, aval=0, dto=None, dval=0):; CoordEntry.__init__(self, entry_number, Z, charge, mass, symbol, label); self.rto = rto; self.rval = rval; self.ato = ato; self.aval = aval; self.dto = dto; self.dval = dval. [docs] def invalidate(self):; """"""Flags the current coordinates as being outdated""""""; self.computed = False; if self.rval != 0:; self.rval.invalidate(); if self.aval != 0:; self.aval.invalidate(); if self.dval != 0:; self.dval.invalidate(). [docs] def print_in_input_format(self):; """"""Prints the updated geometry, in the format provided by the user""""""; text = """"; if self.rto == None and self.ato == None and self.dto == None:; # The first atom; text += ""\n""; elif self.ato == None and self.dto == None:; # The second atom; now_rto = self.rto.entry_number() + 1; now_rval = self.rval.variable_to_string(6); text += "" %5d %11s\n"" % (now_rto, now_rval); elif self.dto == None:; # The third atom; now_rto = self.rto.entry_number() + 1; now_rval = self.rval.variable_to_s",MatchSource.WIKI,psi4manual/4.0b5/_modules/qcdb/libmintscoordentry.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintscoordentry.html
https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintscoordentry.html:10817,Energy Efficiency,charge,charge,10817,"ring(12); ystr = self.y.variable_to_string(12); zstr = self.z.variable_to_string(12); return "" %17s %17s %17s\n"" % (xstr, ystr, zstr); # should go to outfile. [docs] def invalidate(self):; """"""Flags the current coordinates as being outdated.""""""; self.computed = False; self.x.invalidate(); self.y.invalidate(); self.z.invalidate(). [docs] def clone(self):; """"""Returns new, independent CartesianEntry object""""""; return copy.deepcopy(self). [docs] def everything(self):; CoordEntry.everything(self); print '\nCartesianEntry\n Type = %s\n x = %s\n y = %s\n z = %s\n\n' % (self.type(), self.x.variable_to_string(8), self.y.variable_to_string(8), self.z.variable_to_string(8)). [docs]class ZMatrixEntry(CoordEntry):; """"""Class to hold all information about an atom, including its; coordinate specification as any position of ZMatrix. """"""; def __init__(self, entry_number, Z, charge, mass, symbol, label, \; rto=None, rval=0, ato=None, aval=0, dto=None, dval=0):; CoordEntry.__init__(self, entry_number, Z, charge, mass, symbol, label); self.rto = rto; self.rval = rval; self.ato = ato; self.aval = aval; self.dto = dto; self.dval = dval. [docs] def invalidate(self):; """"""Flags the current coordinates as being outdated""""""; self.computed = False; if self.rval != 0:; self.rval.invalidate(); if self.aval != 0:; self.aval.invalidate(); if self.dval != 0:; self.dval.invalidate(). [docs] def print_in_input_format(self):; """"""Prints the updated geometry, in the format provided by the user""""""; text = """"; if self.rto == None and self.ato == None and self.dto == None:; # The first atom; text += ""\n""; elif self.ato == None and self.dto == None:; # The second atom; now_rto = self.rto.entry_number() + 1; now_rval = self.rval.variable_to_string(6); text += "" %5d %11s\n"" % (now_rto, now_rval); elif self.dto == None:; # The third atom; now_rto = self.rto.entry_number() + 1; now_rval = self.rval.variable_to_string(6); now_ato = self.ato.entry_number() + 1; now_aval = self.aval.variable_to_string(6); text += "" %",MatchSource.WIKI,psi4manual/4.0b5/_modules/qcdb/libmintscoordentry.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintscoordentry.html
https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintscoordentry.html:3244,Integrability,depend,depends,3244,"t__(self, value, fixed=False):; CoordValue.__init__(self, fixed, True); # coordinate number value; self.value = value. [docs] def compute(self):; """"""Computes value of coordinate from member data""""""; return self.value. [docs] def rset(self, val):; """"""Resets value of coordinate if not fixed""""""; if not self.PYfixed:; self.value = val. [docs] def type(self):; """"""Gets specialization type of CoordValue""""""; return 'NumberType'. [docs] def clone(self):; """"""Returns new, independent NumberValue object""""""; return copy.deepcopy(self). [docs] def variable_to_string(self, precision):; """"""Takes a CoordValue object, and returns a string for printing.""""""; return ""%*.*f"" % (precision + 5, precision, self.compute()). [docs] def everything(self):; print '\nNumberValue\n Fixed = %s\n Computed = %s\n Type = %s\n Value = %f\n FValue = %s\n\n' % \; (self.PYfixed, self.computed, self.type(), self.value, self.variable_to_string(4)). [docs]class VariableValue(CoordValue):; """"""Specialization of CoordValue, where the current value depends; on the list of geometry values stored by the molecule. """"""; def __init__(self, name, geometryVariables, negate=False, fixed=False):; CoordValue.__init__(self, fixed, True); # Name of variable; self.PYname = name; # Dictionary from molecule of variable names and values; self.geometryVariables = geometryVariables; # Whether the coordinate value is actually the negative of the variable value; self.negate = negate. [docs] def compute(self):; """"""Computes value of coordinate from member data""""""; vstr = self.PYname.upper(); if vstr not in self.geometryVariables:; raise IncompleteAtomError('Variable %s used in geometry specification has not been defined' % (vstr)); if self.negate:; return self.geometryVariables[vstr] * -1.0; else:; return self.geometryVariables[vstr]. [docs] def negated(self):; """"""Gets whether the coordinate value is actually the negative of the variable value""""""; return self.negate. [docs] def name(self):; """"""Gets the name of the variable""""""; return ",MatchSource.WIKI,psi4manual/4.0b5/_modules/qcdb/libmintscoordentry.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintscoordentry.html
https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintscoordentry.html:9418,Integrability,depend,depend,9418,"s = %f\n Symbol = %s\n Label = %s\n Ghosted = %s\n Coordinates = %s\n\n' % \; (self.entry_number(), self.is_computed(), self.Z(), self.charge(), self.mass(), self.symbol(), self.label(), self.is_ghosted(), self.coordinates). [docs]class CartesianEntry(CoordEntry):; """"""Class to hold all information about an atom, including its; coordinate specification as three Cartesians. """"""; def __init__(self, entry_number, Z, charge, mass, symbol, label, x, y, z):; CoordEntry.__init__(self, entry_number, Z, charge, mass, symbol, label); self.x = x; self.y = y; self.z = z. [docs] def compute(self):; """"""Computes the values of the coordinates (in whichever units; were inputted), returning them in a Vector. """"""; if self.computed:; return self.coordinates; self.coordinates[0] = self.x.compute(); self.coordinates[1] = self.y.compute(); self.coordinates[2] = self.z.compute(); self.computed = True; return self.coordinates. [docs] def set_coordinates(self, x, y, z):; """"""Given the current set of coordinates, updates the values of this; atom's coordinates and any variables that may depend on it. """"""; self.coordinates[0] = x; self.coordinates[1] = y; self.coordinates[2] = z. self.x.rset(x); self.y.rset(y); self.z.rset(z). self.computed = True. [docs] def type(self):; """"""The type of CoordEntry specialization.""""""; return 'CartesianCoord'. [docs] def print_in_input_format(self):; """"""Prints the updated geometry, in the format provided by the user.""""""; xstr = self.x.variable_to_string(12); ystr = self.y.variable_to_string(12); zstr = self.z.variable_to_string(12); return "" %17s %17s %17s\n"" % (xstr, ystr, zstr); # should go to outfile. [docs] def invalidate(self):; """"""Flags the current coordinates as being outdated.""""""; self.computed = False; self.x.invalidate(); self.y.invalidate(); self.z.invalidate(). [docs] def clone(self):; """"""Returns new, independent CartesianEntry object""""""; return copy.deepcopy(self). [docs] def everything(self):; CoordEntry.everything(self); print '\nCartesianEntry\n Type",MatchSource.WIKI,psi4manual/4.0b5/_modules/qcdb/libmintscoordentry.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintscoordentry.html
https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintscoordentry.html:12444,Integrability,depend,depend,12444,"one:; # The first atom; text += ""\n""; elif self.ato == None and self.dto == None:; # The second atom; now_rto = self.rto.entry_number() + 1; now_rval = self.rval.variable_to_string(6); text += "" %5d %11s\n"" % (now_rto, now_rval); elif self.dto == None:; # The third atom; now_rto = self.rto.entry_number() + 1; now_rval = self.rval.variable_to_string(6); now_ato = self.ato.entry_number() + 1; now_aval = self.aval.variable_to_string(6); text += "" %5d %11s %5d %11s\n"" % (now_rto, now_rval, now_ato, now_aval); else:; # Remaining atoms; now_rto = self.rto.entry_number() + 1; now_rval = self.rval.variable_to_string(6); now_ato = self.ato.entry_number() + 1; now_aval = self.aval.variable_to_string(6); now_dto = self.dto.entry_number() + 1; now_dval = self.dval.variable_to_string(6); text += "" %5d %11s %5d %11s %5d %11s\n"" % \; (now_rto, now_rval, now_ato, now_aval, now_dto, now_dval); return text; # outfile. [docs] def set_coordinates(self, x, y, z):; """"""Given the current set of coordinates, updates the values of this; atom's coordinates, and any variables that may depend on it. """"""; self.coordinates[0] = 0.0 if math.fabs(x) < 1.0E-14 else x; self.coordinates[1] = 0.0 if math.fabs(y) < 1.0E-14 else y; self.coordinates[2] = 0.0 if math.fabs(z) < 1.0E-14 else z. if self.rto != None:; if not self.rto.is_computed():; raise ValidationError(""Coordinates have been set in the wrong order""); self.rval.rset(self.r(self.coordinates, self.rto.compute())). if self.ato != None:; if not self.ato.is_computed():; raise ValidationError(""Coordinates have been set in the wrong order""); aval = self.a(self.coordinates, self.rto.compute(), self.ato.compute()); # Noise creeps in for linear molecules. Force linearity, if it is close enough.; val = aval * 180.0 / math.pi; self.aval.rset(val). if self.dto != None:; if not self.dto.is_computed():; raise ValidationError(""Coordinates have been set in the wrong order""); val = self.d(self.coordinates, self.rto.compute(), self.ato.compute(), self.dto.compu",MatchSource.WIKI,psi4manual/4.0b5/_modules/qcdb/libmintscoordentry.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintscoordentry.html
https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintscoordentry.html:1411,Modifiability,variab,variables,1411,"published by; # the Free Software Foundation; either version 2 of the License, or; # (at your option) any later version.; #; # This program is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU General Public License for more details.; #; # You should have received a copy of the GNU General Public License along; # with this program; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; #@END LICENSE; #. r""""""Module to largely replicate in python the psi4 libmints; CoordValue and CoordEntry classes, which were developed by; Justin M. Turney, with incremental improvements by other; psi4 developers. """"""; import math; import copy; from vecutil import *; from exceptions import *. [docs]class CoordValue(object):; """"""An abstract class to handle storage of Cartesian coordinate values, which; may be defined in terms of other variables through this mechanism, greatly; simplifying Z-matrix specification, for example. """""". def __init__(self, fixed=False, computed=False):; # Fixed coordinate?; self.PYfixed = fixed; # Whether the current value is up to date or not; self.computed = computed. [docs] def set_fixed(self, fixed):; """"""Set whether the coordinate value is fixed or not""""""; self.PYfixed = fixed. [docs] def fixed(self):; """"""Get whether the coordinate value is fixed or not""""""; return self.PYfixed. [docs] def invalidate(self):; """"""Flag the current value as outdated""""""; self.computed = False. [docs] def everything(self):; print '\nCoordValue\n Fixed = %s\n Computed = %s\n\n' % (self.PYfixed, self.computed). [docs]class NumberValue(CoordValue):; """"""Specialization of CoordValue that is simply a number to be stored."""""". def __init__(self, value, fixed=False):; CoordValue.__init__(self, fixed, True); # coordinate number value; self.value = value. [docs] def compute(self):; """"""Computes ",MatchSource.WIKI,psi4manual/4.0b5/_modules/qcdb/libmintscoordentry.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintscoordentry.html
https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintscoordentry.html:3159,Modifiability,Variab,VariableValue,3159,"t__(self, value, fixed=False):; CoordValue.__init__(self, fixed, True); # coordinate number value; self.value = value. [docs] def compute(self):; """"""Computes value of coordinate from member data""""""; return self.value. [docs] def rset(self, val):; """"""Resets value of coordinate if not fixed""""""; if not self.PYfixed:; self.value = val. [docs] def type(self):; """"""Gets specialization type of CoordValue""""""; return 'NumberType'. [docs] def clone(self):; """"""Returns new, independent NumberValue object""""""; return copy.deepcopy(self). [docs] def variable_to_string(self, precision):; """"""Takes a CoordValue object, and returns a string for printing.""""""; return ""%*.*f"" % (precision + 5, precision, self.compute()). [docs] def everything(self):; print '\nNumberValue\n Fixed = %s\n Computed = %s\n Type = %s\n Value = %f\n FValue = %s\n\n' % \; (self.PYfixed, self.computed, self.type(), self.value, self.variable_to_string(4)). [docs]class VariableValue(CoordValue):; """"""Specialization of CoordValue, where the current value depends; on the list of geometry values stored by the molecule. """"""; def __init__(self, name, geometryVariables, negate=False, fixed=False):; CoordValue.__init__(self, fixed, True); # Name of variable; self.PYname = name; # Dictionary from molecule of variable names and values; self.geometryVariables = geometryVariables; # Whether the coordinate value is actually the negative of the variable value; self.negate = negate. [docs] def compute(self):; """"""Computes value of coordinate from member data""""""; vstr = self.PYname.upper(); if vstr not in self.geometryVariables:; raise IncompleteAtomError('Variable %s used in geometry specification has not been defined' % (vstr)); if self.negate:; return self.geometryVariables[vstr] * -1.0; else:; return self.geometryVariables[vstr]. [docs] def negated(self):; """"""Gets whether the coordinate value is actually the negative of the variable value""""""; return self.negate. [docs] def name(self):; """"""Gets the name of the variable""""""; return ",MatchSource.WIKI,psi4manual/4.0b5/_modules/qcdb/libmintscoordentry.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintscoordentry.html
https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintscoordentry.html:3436,Modifiability,variab,variable,3436," return self.value. [docs] def rset(self, val):; """"""Resets value of coordinate if not fixed""""""; if not self.PYfixed:; self.value = val. [docs] def type(self):; """"""Gets specialization type of CoordValue""""""; return 'NumberType'. [docs] def clone(self):; """"""Returns new, independent NumberValue object""""""; return copy.deepcopy(self). [docs] def variable_to_string(self, precision):; """"""Takes a CoordValue object, and returns a string for printing.""""""; return ""%*.*f"" % (precision + 5, precision, self.compute()). [docs] def everything(self):; print '\nNumberValue\n Fixed = %s\n Computed = %s\n Type = %s\n Value = %f\n FValue = %s\n\n' % \; (self.PYfixed, self.computed, self.type(), self.value, self.variable_to_string(4)). [docs]class VariableValue(CoordValue):; """"""Specialization of CoordValue, where the current value depends; on the list of geometry values stored by the molecule. """"""; def __init__(self, name, geometryVariables, negate=False, fixed=False):; CoordValue.__init__(self, fixed, True); # Name of variable; self.PYname = name; # Dictionary from molecule of variable names and values; self.geometryVariables = geometryVariables; # Whether the coordinate value is actually the negative of the variable value; self.negate = negate. [docs] def compute(self):; """"""Computes value of coordinate from member data""""""; vstr = self.PYname.upper(); if vstr not in self.geometryVariables:; raise IncompleteAtomError('Variable %s used in geometry specification has not been defined' % (vstr)); if self.negate:; return self.geometryVariables[vstr] * -1.0; else:; return self.geometryVariables[vstr]. [docs] def negated(self):; """"""Gets whether the coordinate value is actually the negative of the variable value""""""; return self.negate. [docs] def name(self):; """"""Gets the name of the variable""""""; return self.PYname. [docs] def rset(self, val):; """"""Resets value of coordinate if not fixed""""""; if not self.PYfixed:; if self.negate:; self.geometryVariables[self.PYname] = val * -1.0; else:; self.geometr",MatchSource.WIKI,psi4manual/4.0b5/_modules/qcdb/libmintscoordentry.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintscoordentry.html
https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintscoordentry.html:3496,Modifiability,variab,variable,3496,"of coordinate if not fixed""""""; if not self.PYfixed:; self.value = val. [docs] def type(self):; """"""Gets specialization type of CoordValue""""""; return 'NumberType'. [docs] def clone(self):; """"""Returns new, independent NumberValue object""""""; return copy.deepcopy(self). [docs] def variable_to_string(self, precision):; """"""Takes a CoordValue object, and returns a string for printing.""""""; return ""%*.*f"" % (precision + 5, precision, self.compute()). [docs] def everything(self):; print '\nNumberValue\n Fixed = %s\n Computed = %s\n Type = %s\n Value = %f\n FValue = %s\n\n' % \; (self.PYfixed, self.computed, self.type(), self.value, self.variable_to_string(4)). [docs]class VariableValue(CoordValue):; """"""Specialization of CoordValue, where the current value depends; on the list of geometry values stored by the molecule. """"""; def __init__(self, name, geometryVariables, negate=False, fixed=False):; CoordValue.__init__(self, fixed, True); # Name of variable; self.PYname = name; # Dictionary from molecule of variable names and values; self.geometryVariables = geometryVariables; # Whether the coordinate value is actually the negative of the variable value; self.negate = negate. [docs] def compute(self):; """"""Computes value of coordinate from member data""""""; vstr = self.PYname.upper(); if vstr not in self.geometryVariables:; raise IncompleteAtomError('Variable %s used in geometry specification has not been defined' % (vstr)); if self.negate:; return self.geometryVariables[vstr] * -1.0; else:; return self.geometryVariables[vstr]. [docs] def negated(self):; """"""Gets whether the coordinate value is actually the negative of the variable value""""""; return self.negate. [docs] def name(self):; """"""Gets the name of the variable""""""; return self.PYname. [docs] def rset(self, val):; """"""Resets value of coordinate if not fixed""""""; if not self.PYfixed:; if self.negate:; self.geometryVariables[self.PYname] = val * -1.0; else:; self.geometryVariables[self.PYname] = val. [docs] def type(self):; """"""Gets spe",MatchSource.WIKI,psi4manual/4.0b5/_modules/qcdb/libmintscoordentry.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintscoordentry.html
https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintscoordentry.html:3630,Modifiability,variab,variable,3630,"ts specialization type of CoordValue""""""; return 'NumberType'. [docs] def clone(self):; """"""Returns new, independent NumberValue object""""""; return copy.deepcopy(self). [docs] def variable_to_string(self, precision):; """"""Takes a CoordValue object, and returns a string for printing.""""""; return ""%*.*f"" % (precision + 5, precision, self.compute()). [docs] def everything(self):; print '\nNumberValue\n Fixed = %s\n Computed = %s\n Type = %s\n Value = %f\n FValue = %s\n\n' % \; (self.PYfixed, self.computed, self.type(), self.value, self.variable_to_string(4)). [docs]class VariableValue(CoordValue):; """"""Specialization of CoordValue, where the current value depends; on the list of geometry values stored by the molecule. """"""; def __init__(self, name, geometryVariables, negate=False, fixed=False):; CoordValue.__init__(self, fixed, True); # Name of variable; self.PYname = name; # Dictionary from molecule of variable names and values; self.geometryVariables = geometryVariables; # Whether the coordinate value is actually the negative of the variable value; self.negate = negate. [docs] def compute(self):; """"""Computes value of coordinate from member data""""""; vstr = self.PYname.upper(); if vstr not in self.geometryVariables:; raise IncompleteAtomError('Variable %s used in geometry specification has not been defined' % (vstr)); if self.negate:; return self.geometryVariables[vstr] * -1.0; else:; return self.geometryVariables[vstr]. [docs] def negated(self):; """"""Gets whether the coordinate value is actually the negative of the variable value""""""; return self.negate. [docs] def name(self):; """"""Gets the name of the variable""""""; return self.PYname. [docs] def rset(self, val):; """"""Resets value of coordinate if not fixed""""""; if not self.PYfixed:; if self.negate:; self.geometryVariables[self.PYname] = val * -1.0; else:; self.geometryVariables[self.PYname] = val. [docs] def type(self):; """"""Gets specialization type of CoordValue""""""; return 'VariableType'. [docs] def clone(self):; """"""Returns new, i",MatchSource.WIKI,psi4manual/4.0b5/_modules/qcdb/libmintscoordentry.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintscoordentry.html
https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintscoordentry.html:3843,Modifiability,Variab,Variable,3843,"inting.""""""; return ""%*.*f"" % (precision + 5, precision, self.compute()). [docs] def everything(self):; print '\nNumberValue\n Fixed = %s\n Computed = %s\n Type = %s\n Value = %f\n FValue = %s\n\n' % \; (self.PYfixed, self.computed, self.type(), self.value, self.variable_to_string(4)). [docs]class VariableValue(CoordValue):; """"""Specialization of CoordValue, where the current value depends; on the list of geometry values stored by the molecule. """"""; def __init__(self, name, geometryVariables, negate=False, fixed=False):; CoordValue.__init__(self, fixed, True); # Name of variable; self.PYname = name; # Dictionary from molecule of variable names and values; self.geometryVariables = geometryVariables; # Whether the coordinate value is actually the negative of the variable value; self.negate = negate. [docs] def compute(self):; """"""Computes value of coordinate from member data""""""; vstr = self.PYname.upper(); if vstr not in self.geometryVariables:; raise IncompleteAtomError('Variable %s used in geometry specification has not been defined' % (vstr)); if self.negate:; return self.geometryVariables[vstr] * -1.0; else:; return self.geometryVariables[vstr]. [docs] def negated(self):; """"""Gets whether the coordinate value is actually the negative of the variable value""""""; return self.negate. [docs] def name(self):; """"""Gets the name of the variable""""""; return self.PYname. [docs] def rset(self, val):; """"""Resets value of coordinate if not fixed""""""; if not self.PYfixed:; if self.negate:; self.geometryVariables[self.PYname] = val * -1.0; else:; self.geometryVariables[self.PYname] = val. [docs] def type(self):; """"""Gets specialization type of CoordValue""""""; return 'VariableType'. [docs] def clone(self):; """"""Returns new, independent VariableValue object""""""; return copy.deepcopy(self). [docs] def variable_to_string(self, precision):; """"""Takes a CoordValue object, and returns a string for printing.""""""; if self.negate:; return '-' + self.PYname; else:; return self.PYname. [docs] def everythin",MatchSource.WIKI,psi4manual/4.0b5/_modules/qcdb/libmintscoordentry.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintscoordentry.html
https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintscoordentry.html:4120,Modifiability,variab,variable,4120,"uted, self.type(), self.value, self.variable_to_string(4)). [docs]class VariableValue(CoordValue):; """"""Specialization of CoordValue, where the current value depends; on the list of geometry values stored by the molecule. """"""; def __init__(self, name, geometryVariables, negate=False, fixed=False):; CoordValue.__init__(self, fixed, True); # Name of variable; self.PYname = name; # Dictionary from molecule of variable names and values; self.geometryVariables = geometryVariables; # Whether the coordinate value is actually the negative of the variable value; self.negate = negate. [docs] def compute(self):; """"""Computes value of coordinate from member data""""""; vstr = self.PYname.upper(); if vstr not in self.geometryVariables:; raise IncompleteAtomError('Variable %s used in geometry specification has not been defined' % (vstr)); if self.negate:; return self.geometryVariables[vstr] * -1.0; else:; return self.geometryVariables[vstr]. [docs] def negated(self):; """"""Gets whether the coordinate value is actually the negative of the variable value""""""; return self.negate. [docs] def name(self):; """"""Gets the name of the variable""""""; return self.PYname. [docs] def rset(self, val):; """"""Resets value of coordinate if not fixed""""""; if not self.PYfixed:; if self.negate:; self.geometryVariables[self.PYname] = val * -1.0; else:; self.geometryVariables[self.PYname] = val. [docs] def type(self):; """"""Gets specialization type of CoordValue""""""; return 'VariableType'. [docs] def clone(self):; """"""Returns new, independent VariableValue object""""""; return copy.deepcopy(self). [docs] def variable_to_string(self, precision):; """"""Takes a CoordValue object, and returns a string for printing.""""""; if self.negate:; return '-' + self.PYname; else:; return self.PYname. [docs] def everything(self):; print '\nVariableValue\n Fixed = %s\n Computed = %s\n Type = %s\n Value = %f\n FValue = %s\n Name = %s\n Negated = %s\n Map = %s\n\n' % \; (self.PYfixed, self.computed, self.type(), self.compute(), self.variable_to_",MatchSource.WIKI,psi4manual/4.0b5/_modules/qcdb/libmintscoordentry.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintscoordentry.html
https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintscoordentry.html:4207,Modifiability,variab,variable,4207,"alization of CoordValue, where the current value depends; on the list of geometry values stored by the molecule. """"""; def __init__(self, name, geometryVariables, negate=False, fixed=False):; CoordValue.__init__(self, fixed, True); # Name of variable; self.PYname = name; # Dictionary from molecule of variable names and values; self.geometryVariables = geometryVariables; # Whether the coordinate value is actually the negative of the variable value; self.negate = negate. [docs] def compute(self):; """"""Computes value of coordinate from member data""""""; vstr = self.PYname.upper(); if vstr not in self.geometryVariables:; raise IncompleteAtomError('Variable %s used in geometry specification has not been defined' % (vstr)); if self.negate:; return self.geometryVariables[vstr] * -1.0; else:; return self.geometryVariables[vstr]. [docs] def negated(self):; """"""Gets whether the coordinate value is actually the negative of the variable value""""""; return self.negate. [docs] def name(self):; """"""Gets the name of the variable""""""; return self.PYname. [docs] def rset(self, val):; """"""Resets value of coordinate if not fixed""""""; if not self.PYfixed:; if self.negate:; self.geometryVariables[self.PYname] = val * -1.0; else:; self.geometryVariables[self.PYname] = val. [docs] def type(self):; """"""Gets specialization type of CoordValue""""""; return 'VariableType'. [docs] def clone(self):; """"""Returns new, independent VariableValue object""""""; return copy.deepcopy(self). [docs] def variable_to_string(self, precision):; """"""Takes a CoordValue object, and returns a string for printing.""""""; if self.negate:; return '-' + self.PYname; else:; return self.PYname. [docs] def everything(self):; print '\nVariableValue\n Fixed = %s\n Computed = %s\n Type = %s\n Value = %f\n FValue = %s\n Name = %s\n Negated = %s\n Map = %s\n\n' % \; (self.PYfixed, self.computed, self.type(), self.compute(), self.variable_to_string(4), self.name(), self.negated(), self.geometryVariables). [docs]class CoordEntry(object):; """"""Class t",MatchSource.WIKI,psi4manual/4.0b5/_modules/qcdb/libmintscoordentry.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintscoordentry.html
https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintscoordentry.html:4533,Modifiability,Variab,VariableType,4533,"able names and values; self.geometryVariables = geometryVariables; # Whether the coordinate value is actually the negative of the variable value; self.negate = negate. [docs] def compute(self):; """"""Computes value of coordinate from member data""""""; vstr = self.PYname.upper(); if vstr not in self.geometryVariables:; raise IncompleteAtomError('Variable %s used in geometry specification has not been defined' % (vstr)); if self.negate:; return self.geometryVariables[vstr] * -1.0; else:; return self.geometryVariables[vstr]. [docs] def negated(self):; """"""Gets whether the coordinate value is actually the negative of the variable value""""""; return self.negate. [docs] def name(self):; """"""Gets the name of the variable""""""; return self.PYname. [docs] def rset(self, val):; """"""Resets value of coordinate if not fixed""""""; if not self.PYfixed:; if self.negate:; self.geometryVariables[self.PYname] = val * -1.0; else:; self.geometryVariables[self.PYname] = val. [docs] def type(self):; """"""Gets specialization type of CoordValue""""""; return 'VariableType'. [docs] def clone(self):; """"""Returns new, independent VariableValue object""""""; return copy.deepcopy(self). [docs] def variable_to_string(self, precision):; """"""Takes a CoordValue object, and returns a string for printing.""""""; if self.negate:; return '-' + self.PYname; else:; return self.PYname. [docs] def everything(self):; print '\nVariableValue\n Fixed = %s\n Computed = %s\n Type = %s\n Value = %f\n FValue = %s\n Name = %s\n Negated = %s\n Map = %s\n\n' % \; (self.PYfixed, self.computed, self.type(), self.compute(), self.variable_to_string(4), self.name(), self.negated(), self.geometryVariables). [docs]class CoordEntry(object):; """"""Class to. """"""; def __init__(self, entry_number, Z, charge, mass, symbol, label=""""):; # Order in full atomic list; self.PYentry_number = entry_number; # Whether the coordinates have been computed; self.computed = False; # Actual cartesian coordinates of the atom; self.coordinates = [None, None, None]. # Atomic nu",MatchSource.WIKI,psi4manual/4.0b5/_modules/qcdb/libmintscoordentry.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintscoordentry.html
https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintscoordentry.html:4601,Modifiability,Variab,VariableValue,4601,"value is actually the negative of the variable value; self.negate = negate. [docs] def compute(self):; """"""Computes value of coordinate from member data""""""; vstr = self.PYname.upper(); if vstr not in self.geometryVariables:; raise IncompleteAtomError('Variable %s used in geometry specification has not been defined' % (vstr)); if self.negate:; return self.geometryVariables[vstr] * -1.0; else:; return self.geometryVariables[vstr]. [docs] def negated(self):; """"""Gets whether the coordinate value is actually the negative of the variable value""""""; return self.negate. [docs] def name(self):; """"""Gets the name of the variable""""""; return self.PYname. [docs] def rset(self, val):; """"""Resets value of coordinate if not fixed""""""; if not self.PYfixed:; if self.negate:; self.geometryVariables[self.PYname] = val * -1.0; else:; self.geometryVariables[self.PYname] = val. [docs] def type(self):; """"""Gets specialization type of CoordValue""""""; return 'VariableType'. [docs] def clone(self):; """"""Returns new, independent VariableValue object""""""; return copy.deepcopy(self). [docs] def variable_to_string(self, precision):; """"""Takes a CoordValue object, and returns a string for printing.""""""; if self.negate:; return '-' + self.PYname; else:; return self.PYname. [docs] def everything(self):; print '\nVariableValue\n Fixed = %s\n Computed = %s\n Type = %s\n Value = %f\n FValue = %s\n Name = %s\n Negated = %s\n Map = %s\n\n' % \; (self.PYfixed, self.computed, self.type(), self.compute(), self.variable_to_string(4), self.name(), self.negated(), self.geometryVariables). [docs]class CoordEntry(object):; """"""Class to. """"""; def __init__(self, entry_number, Z, charge, mass, symbol, label=""""):; # Order in full atomic list; self.PYentry_number = entry_number; # Whether the coordinates have been computed; self.computed = False; # Actual cartesian coordinates of the atom; self.coordinates = [None, None, None]. # Atomic number of the atom; self.PYZ = Z; # Charge of the atom (SAD-related); self.PYcharge = charge; ",MatchSource.WIKI,psi4manual/4.0b5/_modules/qcdb/libmintscoordentry.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintscoordentry.html
https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintscoordentry.html:9399,Modifiability,variab,variables,9399,"s = %f\n Symbol = %s\n Label = %s\n Ghosted = %s\n Coordinates = %s\n\n' % \; (self.entry_number(), self.is_computed(), self.Z(), self.charge(), self.mass(), self.symbol(), self.label(), self.is_ghosted(), self.coordinates). [docs]class CartesianEntry(CoordEntry):; """"""Class to hold all information about an atom, including its; coordinate specification as three Cartesians. """"""; def __init__(self, entry_number, Z, charge, mass, symbol, label, x, y, z):; CoordEntry.__init__(self, entry_number, Z, charge, mass, symbol, label); self.x = x; self.y = y; self.z = z. [docs] def compute(self):; """"""Computes the values of the coordinates (in whichever units; were inputted), returning them in a Vector. """"""; if self.computed:; return self.coordinates; self.coordinates[0] = self.x.compute(); self.coordinates[1] = self.y.compute(); self.coordinates[2] = self.z.compute(); self.computed = True; return self.coordinates. [docs] def set_coordinates(self, x, y, z):; """"""Given the current set of coordinates, updates the values of this; atom's coordinates and any variables that may depend on it. """"""; self.coordinates[0] = x; self.coordinates[1] = y; self.coordinates[2] = z. self.x.rset(x); self.y.rset(y); self.z.rset(z). self.computed = True. [docs] def type(self):; """"""The type of CoordEntry specialization.""""""; return 'CartesianCoord'. [docs] def print_in_input_format(self):; """"""Prints the updated geometry, in the format provided by the user.""""""; xstr = self.x.variable_to_string(12); ystr = self.y.variable_to_string(12); zstr = self.z.variable_to_string(12); return "" %17s %17s %17s\n"" % (xstr, ystr, zstr); # should go to outfile. [docs] def invalidate(self):; """"""Flags the current coordinates as being outdated.""""""; self.computed = False; self.x.invalidate(); self.y.invalidate(); self.z.invalidate(). [docs] def clone(self):; """"""Returns new, independent CartesianEntry object""""""; return copy.deepcopy(self). [docs] def everything(self):; CoordEntry.everything(self); print '\nCartesianEntry\n Type",MatchSource.WIKI,psi4manual/4.0b5/_modules/qcdb/libmintscoordentry.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintscoordentry.html
https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintscoordentry.html:12425,Modifiability,variab,variables,12425,"one:; # The first atom; text += ""\n""; elif self.ato == None and self.dto == None:; # The second atom; now_rto = self.rto.entry_number() + 1; now_rval = self.rval.variable_to_string(6); text += "" %5d %11s\n"" % (now_rto, now_rval); elif self.dto == None:; # The third atom; now_rto = self.rto.entry_number() + 1; now_rval = self.rval.variable_to_string(6); now_ato = self.ato.entry_number() + 1; now_aval = self.aval.variable_to_string(6); text += "" %5d %11s %5d %11s\n"" % (now_rto, now_rval, now_ato, now_aval); else:; # Remaining atoms; now_rto = self.rto.entry_number() + 1; now_rval = self.rval.variable_to_string(6); now_ato = self.ato.entry_number() + 1; now_aval = self.aval.variable_to_string(6); now_dto = self.dto.entry_number() + 1; now_dval = self.dval.variable_to_string(6); text += "" %5d %11s %5d %11s %5d %11s\n"" % \; (now_rto, now_rval, now_ato, now_aval, now_dto, now_dval); return text; # outfile. [docs] def set_coordinates(self, x, y, z):; """"""Given the current set of coordinates, updates the values of this; atom's coordinates, and any variables that may depend on it. """"""; self.coordinates[0] = 0.0 if math.fabs(x) < 1.0E-14 else x; self.coordinates[1] = 0.0 if math.fabs(y) < 1.0E-14 else y; self.coordinates[2] = 0.0 if math.fabs(z) < 1.0E-14 else z. if self.rto != None:; if not self.rto.is_computed():; raise ValidationError(""Coordinates have been set in the wrong order""); self.rval.rset(self.r(self.coordinates, self.rto.compute())). if self.ato != None:; if not self.ato.is_computed():; raise ValidationError(""Coordinates have been set in the wrong order""); aval = self.a(self.coordinates, self.rto.compute(), self.ato.compute()); # Noise creeps in for linear molecules. Force linearity, if it is close enough.; val = aval * 180.0 / math.pi; self.aval.rset(val). if self.dto != None:; if not self.dto.is_computed():; raise ValidationError(""Coordinates have been set in the wrong order""); val = self.d(self.coordinates, self.rto.compute(), self.ato.compute(), self.dto.compu",MatchSource.WIKI,psi4manual/4.0b5/_modules/qcdb/libmintscoordentry.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintscoordentry.html
https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintscoordentry.html:14797,Safety,safe,safely,14797,"f):; """"""Compute the Cartesian coordinates in Bohr of current atom's entry."""""". if self.computed:; return self.coordinates. # place first atom at the origin; if self.rto == None and self.ato == None and self.dto == None:; self.coordinates[0] = 0.0; self.coordinates[1] = 0.0; self.coordinates[2] = 0.0. # place second atom directly above the first; elif self.ato == None and self.dto == None:; self.coordinates[0] = 0.0; self.coordinates[1] = 0.0; self.coordinates[2] = self.rval.compute(). # place third atom pointing upwards; # this rTo rVal aTo aVal; # A B C; elif self.dto == None:; r = self.rval.compute(); a = self.aval.compute() * math.pi / 180.0; cosABC = math.cos(a); sinABC = math.sin(a); B = self.rto.compute(); C = self.ato.compute(). eCB = sub(B, C); eCB = normalize(eCB); eX = [0.0, 0.0, 0.0]; eY = [0.0, 0.0, 0.0]; if (math.fabs(1.0 - math.fabs(eCB[0])) < 1.0E-5):; # CB is collinear with X, start by finding Y; eY[1] = 1.0; eX = perp_unit(eY, eCB); eY = perp_unit(eX, eCB); else:; # CB is not collinear with X, we can safely find X first; eX[0] = 1.0; eY = perp_unit(eX, eCB); eX = perp_unit(eY, eCB); for xyz in range(3):; self.coordinates[xyz] = B[xyz] + r * (eY[xyz] * sinABC - eCB[xyz] * cosABC); if math.fabs(self.coordinates[xyz]) < 1.E-14:; self.coordinates[xyz] = 0.0. # The fourth, or subsequent, atom; #; # The atom specification is; # this rTo rVal aTo aVal dTo dVal; # A B C D; # which allows us to define the vector from C->B (eCB) as the +z axis, and eDC; # lies in the xz plane. Then eX, eY and eZ (=eBC) are the x, y, and z axes, respecively.; else:; r = self.rval.compute(); a = self.aval.compute() * math.pi / 180.0; d = self.dval.compute() * math.pi / 180.0; B = self.rto.compute(); C = self.ato.compute(); D = self.dto.compute(). eDC = sub(C, D); eCB = sub(B, C); eDC = normalize(eDC); eCB = normalize(eCB); cosABC = math.cos(a); sinABC = math.sin(a); cosABCD = math.cos(d); sinABCD = math.sin(d); eY = perp_unit(eDC, eCB); eX = perp_unit(eY, eCB); for xyz in range",MatchSource.WIKI,psi4manual/4.0b5/_modules/qcdb/libmintscoordentry.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintscoordentry.html
https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintscoordentry.html:5978,Security,Validat,ValidationError,5978,"n FValue = %s\n Name = %s\n Negated = %s\n Map = %s\n\n' % \; (self.PYfixed, self.computed, self.type(), self.compute(), self.variable_to_string(4), self.name(), self.negated(), self.geometryVariables). [docs]class CoordEntry(object):; """"""Class to. """"""; def __init__(self, entry_number, Z, charge, mass, symbol, label=""""):; # Order in full atomic list; self.PYentry_number = entry_number; # Whether the coordinates have been computed; self.computed = False; # Actual cartesian coordinates of the atom; self.coordinates = [None, None, None]. # Atomic number of the atom; self.PYZ = Z; # Charge of the atom (SAD-related); self.PYcharge = charge; # Mass of the atom; self.PYmass = mass; # Label of the atom minus any extra info (H1 => H); self.PYsymbol = symbol; # Original label from the molecule from the input file (H1); self.PYlabel = label; # Is this a ghost atom?; self.ghosted = False. @staticmethod; [docs] def r(a1, a2):; """"""Computes the distance between two sets of coordinates""""""; if len(a1) != 3 or len(a2) != 3:; raise ValidationError('ERROR: r() only defined for Vector3\n'); return distance(a1, a2). @staticmethod; [docs] def a(a1, a2, a3):; """"""Computes the angle (in rad.) between three sets of coordinates.""""""; if len(a1) != 3 or len(a2) != 3 or len(a3) != 3:; raise ValidationError('ERROR: a() only defined for Vector3\n'); eBA = sub(a2, a1); eBC = sub(a2, a3); eBA = normalize(eBA); eBC = normalize(eBC); costheta = dot(eBA, eBC). if costheta > 1.0 - 1.0E-14:; costheta = 1.0; if costheta < 1.0E-14 - 1.0:; costheta = -1.0; return math.acos(costheta). @staticmethod; [docs] def d(a1, a2, a3, a4):; """"""Computes the dihedral (in rad.) between four sets of coordinates.""""""; if len(a1) != 3 or len(a2) != 3 or len(a3) != 3 or len(a4) != 3:; raise ValidationError('ERROR: d() only defined for Vector3\n'); eBA = sub(a2, a1); eDC = sub(a4, a3); eCB = sub(a3, a2); CBNorm = norm(eCB); DCxCB = cross(eDC, eCB); CBxBA = cross(eCB, eBA); return -1.0 * math.atan2(CBNorm * dot(eDC, CBxBA), dot(D",MatchSource.WIKI,psi4manual/4.0b5/_modules/qcdb/libmintscoordentry.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintscoordentry.html
https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintscoordentry.html:6230,Security,Validat,ValidationError,6230,"n full atomic list; self.PYentry_number = entry_number; # Whether the coordinates have been computed; self.computed = False; # Actual cartesian coordinates of the atom; self.coordinates = [None, None, None]. # Atomic number of the atom; self.PYZ = Z; # Charge of the atom (SAD-related); self.PYcharge = charge; # Mass of the atom; self.PYmass = mass; # Label of the atom minus any extra info (H1 => H); self.PYsymbol = symbol; # Original label from the molecule from the input file (H1); self.PYlabel = label; # Is this a ghost atom?; self.ghosted = False. @staticmethod; [docs] def r(a1, a2):; """"""Computes the distance between two sets of coordinates""""""; if len(a1) != 3 or len(a2) != 3:; raise ValidationError('ERROR: r() only defined for Vector3\n'); return distance(a1, a2). @staticmethod; [docs] def a(a1, a2, a3):; """"""Computes the angle (in rad.) between three sets of coordinates.""""""; if len(a1) != 3 or len(a2) != 3 or len(a3) != 3:; raise ValidationError('ERROR: a() only defined for Vector3\n'); eBA = sub(a2, a1); eBC = sub(a2, a3); eBA = normalize(eBA); eBC = normalize(eBC); costheta = dot(eBA, eBC). if costheta > 1.0 - 1.0E-14:; costheta = 1.0; if costheta < 1.0E-14 - 1.0:; costheta = -1.0; return math.acos(costheta). @staticmethod; [docs] def d(a1, a2, a3, a4):; """"""Computes the dihedral (in rad.) between four sets of coordinates.""""""; if len(a1) != 3 or len(a2) != 3 or len(a3) != 3 or len(a4) != 3:; raise ValidationError('ERROR: d() only defined for Vector3\n'); eBA = sub(a2, a1); eDC = sub(a4, a3); eCB = sub(a3, a2); CBNorm = norm(eCB); DCxCB = cross(eDC, eCB); CBxBA = cross(eCB, eBA); return -1.0 * math.atan2(CBNorm * dot(eDC, CBxBA), dot(DCxCB, CBxBA)). [docs] def is_computed(self):; """"""Whether the current atom's coordinates are up-to-date.""""""; return self.computed. [docs] def is_equivalent_to(self, other):; """"""Whether this atom has the same mass and ghost status as atom *other*.; Unlike the libmints version, this does not compare basisset assignment. """"""; if other.",MatchSource.WIKI,psi4manual/4.0b5/_modules/qcdb/libmintscoordentry.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintscoordentry.html
https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintscoordentry.html:6708,Security,Validat,ValidationError,6708,"); self.PYlabel = label; # Is this a ghost atom?; self.ghosted = False. @staticmethod; [docs] def r(a1, a2):; """"""Computes the distance between two sets of coordinates""""""; if len(a1) != 3 or len(a2) != 3:; raise ValidationError('ERROR: r() only defined for Vector3\n'); return distance(a1, a2). @staticmethod; [docs] def a(a1, a2, a3):; """"""Computes the angle (in rad.) between three sets of coordinates.""""""; if len(a1) != 3 or len(a2) != 3 or len(a3) != 3:; raise ValidationError('ERROR: a() only defined for Vector3\n'); eBA = sub(a2, a1); eBC = sub(a2, a3); eBA = normalize(eBA); eBC = normalize(eBC); costheta = dot(eBA, eBC). if costheta > 1.0 - 1.0E-14:; costheta = 1.0; if costheta < 1.0E-14 - 1.0:; costheta = -1.0; return math.acos(costheta). @staticmethod; [docs] def d(a1, a2, a3, a4):; """"""Computes the dihedral (in rad.) between four sets of coordinates.""""""; if len(a1) != 3 or len(a2) != 3 or len(a3) != 3 or len(a4) != 3:; raise ValidationError('ERROR: d() only defined for Vector3\n'); eBA = sub(a2, a1); eDC = sub(a4, a3); eCB = sub(a3, a2); CBNorm = norm(eCB); DCxCB = cross(eDC, eCB); CBxBA = cross(eCB, eBA); return -1.0 * math.atan2(CBNorm * dot(eDC, CBxBA), dot(DCxCB, CBxBA)). [docs] def is_computed(self):; """"""Whether the current atom's coordinates are up-to-date.""""""; return self.computed. [docs] def is_equivalent_to(self, other):; """"""Whether this atom has the same mass and ghost status as atom *other*.; Unlike the libmints version, this does not compare basisset assignment. """"""; if other.PYZ != self.PYZ:; return False; if other.PYmass != self.PYmass:; return False; if other.ghosted != self.ghosted:; return False; return True. [docs] def is_ghosted(self):; """"""Whether the current atom is ghosted or not.""""""; return self.ghosted. [docs] def set_ghosted(self, gh):; """"""Flag the atom as either ghost or real.""""""; self.ghosted = gh. [docs] def Z(self):; """"""The nuclear charge of the current atom (0 if ghosted).""""""; if self.ghosted:; return 0.0; else:; return self.PYZ. [docs",MatchSource.WIKI,psi4manual/4.0b5/_modules/qcdb/libmintscoordentry.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintscoordentry.html
https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintscoordentry.html:12703,Security,Validat,ValidationError,12703,"w_ato = self.ato.entry_number() + 1; now_aval = self.aval.variable_to_string(6); text += "" %5d %11s %5d %11s\n"" % (now_rto, now_rval, now_ato, now_aval); else:; # Remaining atoms; now_rto = self.rto.entry_number() + 1; now_rval = self.rval.variable_to_string(6); now_ato = self.ato.entry_number() + 1; now_aval = self.aval.variable_to_string(6); now_dto = self.dto.entry_number() + 1; now_dval = self.dval.variable_to_string(6); text += "" %5d %11s %5d %11s %5d %11s\n"" % \; (now_rto, now_rval, now_ato, now_aval, now_dto, now_dval); return text; # outfile. [docs] def set_coordinates(self, x, y, z):; """"""Given the current set of coordinates, updates the values of this; atom's coordinates, and any variables that may depend on it. """"""; self.coordinates[0] = 0.0 if math.fabs(x) < 1.0E-14 else x; self.coordinates[1] = 0.0 if math.fabs(y) < 1.0E-14 else y; self.coordinates[2] = 0.0 if math.fabs(z) < 1.0E-14 else z. if self.rto != None:; if not self.rto.is_computed():; raise ValidationError(""Coordinates have been set in the wrong order""); self.rval.rset(self.r(self.coordinates, self.rto.compute())). if self.ato != None:; if not self.ato.is_computed():; raise ValidationError(""Coordinates have been set in the wrong order""); aval = self.a(self.coordinates, self.rto.compute(), self.ato.compute()); # Noise creeps in for linear molecules. Force linearity, if it is close enough.; val = aval * 180.0 / math.pi; self.aval.rset(val). if self.dto != None:; if not self.dto.is_computed():; raise ValidationError(""Coordinates have been set in the wrong order""); val = self.d(self.coordinates, self.rto.compute(), self.ato.compute(), self.dto.compute()); # Check for NaN, and don't update if we find one; # what is this? proper py traslation?; if val == val:; self.dval.rset(val * 180.0 / math.pi). self.computed = True. [docs] def type(self):; """"""The type of CoordEntry specialization.""""""; return 'ZMatrixCoord'. [docs] def clone(self):; """"""Returns new, independent ZMatrixEntry object.""""""; return copy.d",MatchSource.WIKI,psi4manual/4.0b5/_modules/qcdb/libmintscoordentry.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintscoordentry.html
https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintscoordentry.html:12890,Security,Validat,ValidationError,12890,"self.rto.entry_number() + 1; now_rval = self.rval.variable_to_string(6); now_ato = self.ato.entry_number() + 1; now_aval = self.aval.variable_to_string(6); now_dto = self.dto.entry_number() + 1; now_dval = self.dval.variable_to_string(6); text += "" %5d %11s %5d %11s %5d %11s\n"" % \; (now_rto, now_rval, now_ato, now_aval, now_dto, now_dval); return text; # outfile. [docs] def set_coordinates(self, x, y, z):; """"""Given the current set of coordinates, updates the values of this; atom's coordinates, and any variables that may depend on it. """"""; self.coordinates[0] = 0.0 if math.fabs(x) < 1.0E-14 else x; self.coordinates[1] = 0.0 if math.fabs(y) < 1.0E-14 else y; self.coordinates[2] = 0.0 if math.fabs(z) < 1.0E-14 else z. if self.rto != None:; if not self.rto.is_computed():; raise ValidationError(""Coordinates have been set in the wrong order""); self.rval.rset(self.r(self.coordinates, self.rto.compute())). if self.ato != None:; if not self.ato.is_computed():; raise ValidationError(""Coordinates have been set in the wrong order""); aval = self.a(self.coordinates, self.rto.compute(), self.ato.compute()); # Noise creeps in for linear molecules. Force linearity, if it is close enough.; val = aval * 180.0 / math.pi; self.aval.rset(val). if self.dto != None:; if not self.dto.is_computed():; raise ValidationError(""Coordinates have been set in the wrong order""); val = self.d(self.coordinates, self.rto.compute(), self.ato.compute(), self.dto.compute()); # Check for NaN, and don't update if we find one; # what is this? proper py traslation?; if val == val:; self.dval.rset(val * 180.0 / math.pi). self.computed = True. [docs] def type(self):; """"""The type of CoordEntry specialization.""""""; return 'ZMatrixCoord'. [docs] def clone(self):; """"""Returns new, independent ZMatrixEntry object.""""""; return copy.deepcopy(self). [docs] def compute(self):; """"""Compute the Cartesian coordinates in Bohr of current atom's entry."""""". if self.computed:; return self.coordinates. # place first atom at the origi",MatchSource.WIKI,psi4manual/4.0b5/_modules/qcdb/libmintscoordentry.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintscoordentry.html
https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintscoordentry.html:13220,Security,Validat,ValidationError,13220,", now_dval); return text; # outfile. [docs] def set_coordinates(self, x, y, z):; """"""Given the current set of coordinates, updates the values of this; atom's coordinates, and any variables that may depend on it. """"""; self.coordinates[0] = 0.0 if math.fabs(x) < 1.0E-14 else x; self.coordinates[1] = 0.0 if math.fabs(y) < 1.0E-14 else y; self.coordinates[2] = 0.0 if math.fabs(z) < 1.0E-14 else z. if self.rto != None:; if not self.rto.is_computed():; raise ValidationError(""Coordinates have been set in the wrong order""); self.rval.rset(self.r(self.coordinates, self.rto.compute())). if self.ato != None:; if not self.ato.is_computed():; raise ValidationError(""Coordinates have been set in the wrong order""); aval = self.a(self.coordinates, self.rto.compute(), self.ato.compute()); # Noise creeps in for linear molecules. Force linearity, if it is close enough.; val = aval * 180.0 / math.pi; self.aval.rset(val). if self.dto != None:; if not self.dto.is_computed():; raise ValidationError(""Coordinates have been set in the wrong order""); val = self.d(self.coordinates, self.rto.compute(), self.ato.compute(), self.dto.compute()); # Check for NaN, and don't update if we find one; # what is this? proper py traslation?; if val == val:; self.dval.rset(val * 180.0 / math.pi). self.computed = True. [docs] def type(self):; """"""The type of CoordEntry specialization.""""""; return 'ZMatrixCoord'. [docs] def clone(self):; """"""Returns new, independent ZMatrixEntry object.""""""; return copy.deepcopy(self). [docs] def compute(self):; """"""Compute the Cartesian coordinates in Bohr of current atom's entry."""""". if self.computed:; return self.coordinates. # place first atom at the origin; if self.rto == None and self.ato == None and self.dto == None:; self.coordinates[0] = 0.0; self.coordinates[1] = 0.0; self.coordinates[2] = 0.0. # place second atom directly above the first; elif self.ato == None and self.dto == None:; self.coordinates[0] = 0.0; self.coordinates[1] = 0.0; self.coordinates[2] = self.rval.comp",MatchSource.WIKI,psi4manual/4.0b5/_modules/qcdb/libmintscoordentry.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintscoordentry.html
https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintscoordentry.html:1454,Usability,simpl,simplifying,1454,"published by; # the Free Software Foundation; either version 2 of the License, or; # (at your option) any later version.; #; # This program is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU General Public License for more details.; #; # You should have received a copy of the GNU General Public License along; # with this program; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; #@END LICENSE; #. r""""""Module to largely replicate in python the psi4 libmints; CoordValue and CoordEntry classes, which were developed by; Justin M. Turney, with incremental improvements by other; psi4 developers. """"""; import math; import copy; from vecutil import *; from exceptions import *. [docs]class CoordValue(object):; """"""An abstract class to handle storage of Cartesian coordinate values, which; may be defined in terms of other variables through this mechanism, greatly; simplifying Z-matrix specification, for example. """""". def __init__(self, fixed=False, computed=False):; # Fixed coordinate?; self.PYfixed = fixed; # Whether the current value is up to date or not; self.computed = computed. [docs] def set_fixed(self, fixed):; """"""Set whether the coordinate value is fixed or not""""""; self.PYfixed = fixed. [docs] def fixed(self):; """"""Get whether the coordinate value is fixed or not""""""; return self.PYfixed. [docs] def invalidate(self):; """"""Flag the current value as outdated""""""; self.computed = False. [docs] def everything(self):; print '\nCoordValue\n Fixed = %s\n Computed = %s\n\n' % (self.PYfixed, self.computed). [docs]class NumberValue(CoordValue):; """"""Specialization of CoordValue that is simply a number to be stored."""""". def __init__(self, value, fixed=False):; CoordValue.__init__(self, fixed, True); # coordinate number value; self.value = value. [docs] def compute(self):; """"""Computes ",MatchSource.WIKI,psi4manual/4.0b5/_modules/qcdb/libmintscoordentry.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintscoordentry.html
https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintscoordentry.html:2183,Usability,simpl,simply,2183,"s by other; psi4 developers. """"""; import math; import copy; from vecutil import *; from exceptions import *. [docs]class CoordValue(object):; """"""An abstract class to handle storage of Cartesian coordinate values, which; may be defined in terms of other variables through this mechanism, greatly; simplifying Z-matrix specification, for example. """""". def __init__(self, fixed=False, computed=False):; # Fixed coordinate?; self.PYfixed = fixed; # Whether the current value is up to date or not; self.computed = computed. [docs] def set_fixed(self, fixed):; """"""Set whether the coordinate value is fixed or not""""""; self.PYfixed = fixed. [docs] def fixed(self):; """"""Get whether the coordinate value is fixed or not""""""; return self.PYfixed. [docs] def invalidate(self):; """"""Flag the current value as outdated""""""; self.computed = False. [docs] def everything(self):; print '\nCoordValue\n Fixed = %s\n Computed = %s\n\n' % (self.PYfixed, self.computed). [docs]class NumberValue(CoordValue):; """"""Specialization of CoordValue that is simply a number to be stored."""""". def __init__(self, value, fixed=False):; CoordValue.__init__(self, fixed, True); # coordinate number value; self.value = value. [docs] def compute(self):; """"""Computes value of coordinate from member data""""""; return self.value. [docs] def rset(self, val):; """"""Resets value of coordinate if not fixed""""""; if not self.PYfixed:; self.value = val. [docs] def type(self):; """"""Gets specialization type of CoordValue""""""; return 'NumberType'. [docs] def clone(self):; """"""Returns new, independent NumberValue object""""""; return copy.deepcopy(self). [docs] def variable_to_string(self, precision):; """"""Takes a CoordValue object, and returns a string for printing.""""""; return ""%*.*f"" % (precision + 5, precision, self.compute()). [docs] def everything(self):; print '\nNumberValue\n Fixed = %s\n Computed = %s\n Type = %s\n Value = %f\n FValue = %s\n\n' % \; (self.PYfixed, self.computed, self.type(), self.value, self.variable_to_string(4)). [docs]class",MatchSource.WIKI,psi4manual/4.0b5/_modules/qcdb/libmintscoordentry.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintscoordentry.html
https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html:18760,Availability,Error,Error,18760," # Save the actual atom symbol (H1 => H); atomSym = re.split('(\d+)', atomLabel)[0].upper(). # Check that the atom symbol is valid; if not atomSym in el2z:; raise ValidationError('Illegal atom symbol in geometry specification: %s' % (atomSym)). zVal = el2z[atomSym]; charge = float(zVal); if ghostAtom:; zVal = 0; charge = 0.0. # handle cartesians; if len(entries) == 4:; tempfrag.append(iatom); xval = self.get_coord_value(entries[1]); yval = self.get_coord_value(entries[2]); zval = self.get_coord_value(entries[3]); self.full_atoms.append(CartesianEntry(iatom, zVal, charge, \; el2masses[atomSym], atomSym, atomLabel, \; xval, yval, zval)). # handle first line of Zmat; elif len(entries) == 1:; zmatrix = True; tempfrag.append(iatom); self.full_atoms.append(ZMatrixEntry(iatom, zVal, charge, \; el2masses[atomSym], atomSym, atomLabel)). # handle second line of Zmat; elif len(entries) == 3:; zmatrix = True; tempfrag.append(iatom). rTo = self.get_anchor_atom(entries[1], line); if rTo >= iatom:; raise ValidationError(""Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[1])); rval = self.get_coord_value(entries[2]). if self.full_atoms[rTo].symbol() == 'X':; rval.set_fixed(True). self.full_atoms.append(ZMatrixEntry(iatom, zVal, charge, \; el2masses[atomSym], atomSym, atomLabel, \; self.full_atoms[rTo], rval)). # handle third line of Zmat; elif len(entries) == 5:; zmatrix = True; tempfrag.append(iatom). rTo = self.get_anchor_atom(entries[1], line); if rTo >= iatom:; raise ValidationError(""Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[1])); aTo = self.get_anchor_atom(entries[3], line); if aTo >= iatom:; raise ValidationError(""Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[3])); if aTo == rTo:; raise ValidationError(""Atom used multiple times on line %s."" % (line)); rval = self.get_coord_value(entries[2]); aval = self.get_coord_value(entries[4]). if self.full_atoms[rTo]",MatchSource.WIKI,psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html:19272,Availability,Error,Error,19272,"s[3]); self.full_atoms.append(CartesianEntry(iatom, zVal, charge, \; el2masses[atomSym], atomSym, atomLabel, \; xval, yval, zval)). # handle first line of Zmat; elif len(entries) == 1:; zmatrix = True; tempfrag.append(iatom); self.full_atoms.append(ZMatrixEntry(iatom, zVal, charge, \; el2masses[atomSym], atomSym, atomLabel)). # handle second line of Zmat; elif len(entries) == 3:; zmatrix = True; tempfrag.append(iatom). rTo = self.get_anchor_atom(entries[1], line); if rTo >= iatom:; raise ValidationError(""Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[1])); rval = self.get_coord_value(entries[2]). if self.full_atoms[rTo].symbol() == 'X':; rval.set_fixed(True). self.full_atoms.append(ZMatrixEntry(iatom, zVal, charge, \; el2masses[atomSym], atomSym, atomLabel, \; self.full_atoms[rTo], rval)). # handle third line of Zmat; elif len(entries) == 5:; zmatrix = True; tempfrag.append(iatom). rTo = self.get_anchor_atom(entries[1], line); if rTo >= iatom:; raise ValidationError(""Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[1])); aTo = self.get_anchor_atom(entries[3], line); if aTo >= iatom:; raise ValidationError(""Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[3])); if aTo == rTo:; raise ValidationError(""Atom used multiple times on line %s."" % (line)); rval = self.get_coord_value(entries[2]); aval = self.get_coord_value(entries[4]). if self.full_atoms[rTo].symbol() == 'X':; rval.set_fixed(True); if self.full_atoms[aTo].symbol() == 'X':; aval.set_fixed(True). self.full_atoms.append(ZMatrixEntry(iatom, zVal, charge, \; el2masses[atomSym], atomSym, atomLabel, \; self.full_atoms[rTo], rval, \; self.full_atoms[aTo], aval)). # handle fourth line of Zmat; elif len(entries) == 7:; zmatrix = True; tempfrag.append(iatom). rTo = self.get_anchor_atom(entries[1], line); if rTo >= iatom:; raise ValidationError(""Error on geometry input line %s. Atom %s has not been defined",MatchSource.WIKI,psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html:19452,Availability,Error,Error,19452,"= 1:; zmatrix = True; tempfrag.append(iatom); self.full_atoms.append(ZMatrixEntry(iatom, zVal, charge, \; el2masses[atomSym], atomSym, atomLabel)). # handle second line of Zmat; elif len(entries) == 3:; zmatrix = True; tempfrag.append(iatom). rTo = self.get_anchor_atom(entries[1], line); if rTo >= iatom:; raise ValidationError(""Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[1])); rval = self.get_coord_value(entries[2]). if self.full_atoms[rTo].symbol() == 'X':; rval.set_fixed(True). self.full_atoms.append(ZMatrixEntry(iatom, zVal, charge, \; el2masses[atomSym], atomSym, atomLabel, \; self.full_atoms[rTo], rval)). # handle third line of Zmat; elif len(entries) == 5:; zmatrix = True; tempfrag.append(iatom). rTo = self.get_anchor_atom(entries[1], line); if rTo >= iatom:; raise ValidationError(""Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[1])); aTo = self.get_anchor_atom(entries[3], line); if aTo >= iatom:; raise ValidationError(""Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[3])); if aTo == rTo:; raise ValidationError(""Atom used multiple times on line %s."" % (line)); rval = self.get_coord_value(entries[2]); aval = self.get_coord_value(entries[4]). if self.full_atoms[rTo].symbol() == 'X':; rval.set_fixed(True); if self.full_atoms[aTo].symbol() == 'X':; aval.set_fixed(True). self.full_atoms.append(ZMatrixEntry(iatom, zVal, charge, \; el2masses[atomSym], atomSym, atomLabel, \; self.full_atoms[rTo], rval, \; self.full_atoms[aTo], aval)). # handle fourth line of Zmat; elif len(entries) == 7:; zmatrix = True; tempfrag.append(iatom). rTo = self.get_anchor_atom(entries[1], line); if rTo >= iatom:; raise ValidationError(""Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[1])); aTo = self.get_anchor_atom(entries[3], line); if aTo >= iatom:; raise ValidationError(""Error on geometry input line %s. Atom %s has not been defined",MatchSource.WIKI,psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html:20189,Availability,Error,Error,20189,"ag.append(iatom). rTo = self.get_anchor_atom(entries[1], line); if rTo >= iatom:; raise ValidationError(""Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[1])); aTo = self.get_anchor_atom(entries[3], line); if aTo >= iatom:; raise ValidationError(""Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[3])); if aTo == rTo:; raise ValidationError(""Atom used multiple times on line %s."" % (line)); rval = self.get_coord_value(entries[2]); aval = self.get_coord_value(entries[4]). if self.full_atoms[rTo].symbol() == 'X':; rval.set_fixed(True); if self.full_atoms[aTo].symbol() == 'X':; aval.set_fixed(True). self.full_atoms.append(ZMatrixEntry(iatom, zVal, charge, \; el2masses[atomSym], atomSym, atomLabel, \; self.full_atoms[rTo], rval, \; self.full_atoms[aTo], aval)). # handle fourth line of Zmat; elif len(entries) == 7:; zmatrix = True; tempfrag.append(iatom). rTo = self.get_anchor_atom(entries[1], line); if rTo >= iatom:; raise ValidationError(""Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[1])); aTo = self.get_anchor_atom(entries[3], line); if aTo >= iatom:; raise ValidationError(""Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[3])); dTo = self.get_anchor_atom(entries[5], line); if dTo >= iatom:; raise ValidationError(""Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[5])); if aTo == rTo or rTo == dTo or aTo == dTo: # for you star wars fans; raise ValidationError(""Atom used multiple times on line %s"" % (line)). rval = self.get_coord_value(entries[2]); aval = self.get_coord_value(entries[4]); dval = self.get_coord_value(entries[6]). if self.full_atoms[rTo].symbol() == 'X':; rval.set_fixed(True); if self.full_atoms[aTo].symbol() == 'X':; aval.set_fixed(True); if self.full_atoms[dTo].symbol() == 'X':; dval.set_fixed(True). self.full_atoms.append(ZMatrixEntry(iatom, zVal, charge, \; el2masses[",MatchSource.WIKI,psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html:20369,Availability,Error,Error,20369,"ne, entries[1])); aTo = self.get_anchor_atom(entries[3], line); if aTo >= iatom:; raise ValidationError(""Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[3])); if aTo == rTo:; raise ValidationError(""Atom used multiple times on line %s."" % (line)); rval = self.get_coord_value(entries[2]); aval = self.get_coord_value(entries[4]). if self.full_atoms[rTo].symbol() == 'X':; rval.set_fixed(True); if self.full_atoms[aTo].symbol() == 'X':; aval.set_fixed(True). self.full_atoms.append(ZMatrixEntry(iatom, zVal, charge, \; el2masses[atomSym], atomSym, atomLabel, \; self.full_atoms[rTo], rval, \; self.full_atoms[aTo], aval)). # handle fourth line of Zmat; elif len(entries) == 7:; zmatrix = True; tempfrag.append(iatom). rTo = self.get_anchor_atom(entries[1], line); if rTo >= iatom:; raise ValidationError(""Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[1])); aTo = self.get_anchor_atom(entries[3], line); if aTo >= iatom:; raise ValidationError(""Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[3])); dTo = self.get_anchor_atom(entries[5], line); if dTo >= iatom:; raise ValidationError(""Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[5])); if aTo == rTo or rTo == dTo or aTo == dTo: # for you star wars fans; raise ValidationError(""Atom used multiple times on line %s"" % (line)). rval = self.get_coord_value(entries[2]); aval = self.get_coord_value(entries[4]); dval = self.get_coord_value(entries[6]). if self.full_atoms[rTo].symbol() == 'X':; rval.set_fixed(True); if self.full_atoms[aTo].symbol() == 'X':; aval.set_fixed(True); if self.full_atoms[dTo].symbol() == 'X':; dval.set_fixed(True). self.full_atoms.append(ZMatrixEntry(iatom, zVal, charge, \; el2masses[atomSym], atomSym, atomLabel, \; self.full_atoms[rTo], rval, \; self.full_atoms[aTo], aval, \; self.full_atoms[dTo], dval)). else:; raise ValidationError('Illegal geometry specific",MatchSource.WIKI,psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html:20549,Availability,Error,Error,20549,"ne, entries[3])); if aTo == rTo:; raise ValidationError(""Atom used multiple times on line %s."" % (line)); rval = self.get_coord_value(entries[2]); aval = self.get_coord_value(entries[4]). if self.full_atoms[rTo].symbol() == 'X':; rval.set_fixed(True); if self.full_atoms[aTo].symbol() == 'X':; aval.set_fixed(True). self.full_atoms.append(ZMatrixEntry(iatom, zVal, charge, \; el2masses[atomSym], atomSym, atomLabel, \; self.full_atoms[rTo], rval, \; self.full_atoms[aTo], aval)). # handle fourth line of Zmat; elif len(entries) == 7:; zmatrix = True; tempfrag.append(iatom). rTo = self.get_anchor_atom(entries[1], line); if rTo >= iatom:; raise ValidationError(""Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[1])); aTo = self.get_anchor_atom(entries[3], line); if aTo >= iatom:; raise ValidationError(""Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[3])); dTo = self.get_anchor_atom(entries[5], line); if dTo >= iatom:; raise ValidationError(""Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[5])); if aTo == rTo or rTo == dTo or aTo == dTo: # for you star wars fans; raise ValidationError(""Atom used multiple times on line %s"" % (line)). rval = self.get_coord_value(entries[2]); aval = self.get_coord_value(entries[4]); dval = self.get_coord_value(entries[6]). if self.full_atoms[rTo].symbol() == 'X':; rval.set_fixed(True); if self.full_atoms[aTo].symbol() == 'X':; aval.set_fixed(True); if self.full_atoms[dTo].symbol() == 'X':; dval.set_fixed(True). self.full_atoms.append(ZMatrixEntry(iatom, zVal, charge, \; el2masses[atomSym], atomSym, atomLabel, \; self.full_atoms[rTo], rval, \; self.full_atoms[aTo], aval, \; self.full_atoms[dTo], dval)). else:; raise ValidationError('Illegal geometry specification line : %s. \; You should provide either Z-Matrix or Cartesian input' % (line)). iatom += 1. self.fragments.append([tempfrag[0], tempfrag[-1]]); self.fragment_types.append('Re",MatchSource.WIKI,psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html:33734,Availability,toler,tolerance,33734,"y_variables). [docs] def add_atom(self, Z, x, y, z, label="""", mass=0.0, charge=0.0, lineno=-1):; """"""Add an atom to the molecule; *Z* atomic number; *x* cartesian coordinate; *y* cartesian coordinate; *z* cartesian coordinate; *symb* atomic symbol to use; *mass* mass to use if non standard; *charge* charge to use if non standard; *lineno* line number when taken from a string. """"""; self.lock_frame = False. if self.atom_at_position([x, y, z]) == -1:; # Dummies go to full_atoms, ghosts need to go to both.; self.full_atoms.append(CartesianEntry(self.nallatom(), Z, charge, mass, label, label, \; NumberValue(x), NumberValue(y), NumberValue(z))); if label.upper() != 'X':; self.atoms.append(self.full_atoms[-1]); else:; raise ValidationError(""Molecule::add_atom: Adding atom on top of an existing atom.""). [docs] def atom_entry(self, atom):; """"""Returns the CoordEntry for an atom.""""""; return self.atoms[atom]. [docs] def atom_at_position(self, b, tol=0.05):; """"""Tests to see of an atom is at the passed position *b* in Bohr with a tolerance *tol*. >>> print H2OH2O.atom_at_position([1.35*(1.0/psi_bohr2angstroms), 0.10*(1.0/psi_bohr2angstroms), 0.0*(1.0/psi_bohr2angstroms)]); 3. """"""; if len(b) != 3:; raise ValidationError('ERROR: atom_at_position() requires as argument a vector of length 3\n'). for at in range(self.natom()):; a = self.xyz(at); if distance(b, a) < tol:; return at; return -1. [docs] def is_variable(self, vstr):; """"""Checks to see if the variable str is in the list, returns; true if it is, and returns false if not. >>> H2OH2O.is_variable('R'); False. """"""; return True if vstr.upper() in self.all_variables else False. [docs] def get_variable(self, vstr):; """"""Checks to see if the variable str is in the list, sets it to; val and returns true if it is, and returns false if not. """"""; vstr = vstr.upper(); try:; return self.geometry_variables[vstr]; except KeyError:; raise ValidationError('ERROR: Geometry variable %s not known.\n' % (vstr)). [docs] def set_variable(self, vstr, v",MatchSource.WIKI,psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html:33928,Availability,ERROR,ERROR,33928,"c symbol to use; *mass* mass to use if non standard; *charge* charge to use if non standard; *lineno* line number when taken from a string. """"""; self.lock_frame = False. if self.atom_at_position([x, y, z]) == -1:; # Dummies go to full_atoms, ghosts need to go to both.; self.full_atoms.append(CartesianEntry(self.nallatom(), Z, charge, mass, label, label, \; NumberValue(x), NumberValue(y), NumberValue(z))); if label.upper() != 'X':; self.atoms.append(self.full_atoms[-1]); else:; raise ValidationError(""Molecule::add_atom: Adding atom on top of an existing atom.""). [docs] def atom_entry(self, atom):; """"""Returns the CoordEntry for an atom.""""""; return self.atoms[atom]. [docs] def atom_at_position(self, b, tol=0.05):; """"""Tests to see of an atom is at the passed position *b* in Bohr with a tolerance *tol*. >>> print H2OH2O.atom_at_position([1.35*(1.0/psi_bohr2angstroms), 0.10*(1.0/psi_bohr2angstroms), 0.0*(1.0/psi_bohr2angstroms)]); 3. """"""; if len(b) != 3:; raise ValidationError('ERROR: atom_at_position() requires as argument a vector of length 3\n'). for at in range(self.natom()):; a = self.xyz(at); if distance(b, a) < tol:; return at; return -1. [docs] def is_variable(self, vstr):; """"""Checks to see if the variable str is in the list, returns; true if it is, and returns false if not. >>> H2OH2O.is_variable('R'); False. """"""; return True if vstr.upper() in self.all_variables else False. [docs] def get_variable(self, vstr):; """"""Checks to see if the variable str is in the list, sets it to; val and returns true if it is, and returns false if not. """"""; vstr = vstr.upper(); try:; return self.geometry_variables[vstr]; except KeyError:; raise ValidationError('ERROR: Geometry variable %s not known.\n' % (vstr)). [docs] def set_variable(self, vstr, val):; """"""Assigns the value val to the variable labelled string in the; list of geometry variables. Also calls update_geometry(). """"""; self.__dict__['lock_frame'] = False; self.__dict__['geometry_variables'][vstr.upper()] = val; print ""Set",MatchSource.WIKI,psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html:34613,Availability,ERROR,ERROR,34613,"f.atoms[atom]. [docs] def atom_at_position(self, b, tol=0.05):; """"""Tests to see of an atom is at the passed position *b* in Bohr with a tolerance *tol*. >>> print H2OH2O.atom_at_position([1.35*(1.0/psi_bohr2angstroms), 0.10*(1.0/psi_bohr2angstroms), 0.0*(1.0/psi_bohr2angstroms)]); 3. """"""; if len(b) != 3:; raise ValidationError('ERROR: atom_at_position() requires as argument a vector of length 3\n'). for at in range(self.natom()):; a = self.xyz(at); if distance(b, a) < tol:; return at; return -1. [docs] def is_variable(self, vstr):; """"""Checks to see if the variable str is in the list, returns; true if it is, and returns false if not. >>> H2OH2O.is_variable('R'); False. """"""; return True if vstr.upper() in self.all_variables else False. [docs] def get_variable(self, vstr):; """"""Checks to see if the variable str is in the list, sets it to; val and returns true if it is, and returns false if not. """"""; vstr = vstr.upper(); try:; return self.geometry_variables[vstr]; except KeyError:; raise ValidationError('ERROR: Geometry variable %s not known.\n' % (vstr)). [docs] def set_variable(self, vstr, val):; """"""Assigns the value val to the variable labelled string in the; list of geometry variables. Also calls update_geometry(). """"""; self.__dict__['lock_frame'] = False; self.__dict__['geometry_variables'][vstr.upper()] = val; print ""Setting geometry variable %s to %f"" % (vstr.upper(), val); try:; self.update_geometry(); except IncompleteAtomError:; # Update geometry might have added some atoms, delete them to be safe.; self.atoms = []; # TODO outfile. def __setattr__(self, name, value):; """"""Function to overload setting attributes to allow geometry; variable assigment as if member data. """"""; try:; if name.upper() in self.__dict__['all_variables']:; self.set_variable(name, value); else:; self.__dict__[name] = value; except KeyError:; self.__dict__[name] = value. def __getattr__(self, name):; """"""Function to overload accessing attribute contents to allow; retrivial geometry variable va",MatchSource.WIKI,psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html:35992,Availability,error,error,35992,"), val); try:; self.update_geometry(); except IncompleteAtomError:; # Update geometry might have added some atoms, delete them to be safe.; self.atoms = []; # TODO outfile. def __setattr__(self, name, value):; """"""Function to overload setting attributes to allow geometry; variable assigment as if member data. """"""; try:; if name.upper() in self.__dict__['all_variables']:; self.set_variable(name, value); else:; self.__dict__[name] = value; except KeyError:; self.__dict__[name] = value. def __getattr__(self, name):; """"""Function to overload accessing attribute contents to allow; retrivial geometry variable values as if member data. """"""; if not name in self.__dict__:; if object.__getattribute__(self, 'is_variable')(name):; return object.__getattribute__(self, 'get_variable')(name); else:; raise AttributeError; else:; return self.__dict__[name]. [docs] def get_anchor_atom(self, vstr, line):; """"""Attempts to interpret a string *vstr* as an atom specifier in; a zmatrix. Takes the current *line* for error message printing.; Returns the atom number (adjusted to zero-based counting). """"""; integerNumber = re.compile(r""(-?\d+)"", re.IGNORECASE); if integerNumber.match(vstr):; # This is just a number, return it; return int(vstr) - 1; else:; # Look to see if this string is known; for i in range(self.nallatom()):; if self.full_atoms[i].label() == vstr:; return i; raise ValidationError(""Illegal value %s in atom specification on line %s.\n"" % (vstr, line)). [docs] def geometry(self):; """"""Returns the geometry in Bohr as a N X 3 array. >>> print H2OH2O.geometry(); [[-2.930978460188563, -0.21641143673806384, 0.0], [-3.655219780069251, 1.4409218455037016, 0.0], [-1.1332252981904638, 0.0769345303220403, 0.0], [2.5523113582286716, 0.21064588230662976, 0.0], [3.175492014248769, -0.7062681346308132, -1.4334725450878665], [3.175492014248769, -0.7062681346308132, 1.4334725450878665]]. """"""; geom = []; for at in range(self.natom()):; geom.append([self.x(at), self.y(at), self.z(at)]); return geom. [d",MatchSource.WIKI,psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html:57461,Availability,checkpoint,checkpoint,57461,"000000 -0.114520000000 0.000000000000; H -1.934259000000 0.762503000000 0.000000000000; H -0.599677000000 0.040712000000 0.000000000000; O 1.350625000000 0.111469000000 0.000000000000; H 1.680398000000 -0.373741000000 -0.758561000000; H 1.680398000000 -0.373741000000 0.758561000000. """"""; factor = 1.0 if self.PYunits == 'Angstrom' else psi_bohr2angstroms. N = self.natom(); if not save_ghosts:; N = 0; for i in range(self.natom()):; if self.Z(i):; N += 1; text = ""%d\n\n"" % (N). for i in range(self.natom()):; [x, y, z] = self.atoms[i].compute(); if save_ghosts or self.Z(i):; text += '%2s %17.12f %17.12f %17.12f\n' % ((self.symbol(i) if self.Z(i) else ""Gh""), \; x * factor, y * factor, z * factor); return text. [docs] def save_xyz(self, filename, save_ghosts=True):; """"""Save an XYZ file. >>> H2OH2O.save_xyz('h2o.xyz'). """"""; outfile = open(filename, 'w'); outfile.write(self.save_string_xyz(save_ghosts)); outfile.close(). [docs] def save_to_checkpoint(self, chkpt, prefix=""""):; """""" **NYI** Save information to checkpoint file; (method name in libmints is save_to_chkpt). """"""; raise FeatureNotImplemented('Molecule::save_to_checkpoint') # FINAL. # <<< Methods for Symmetry >>>. [docs] def has_symmetry_element(self, op, tol=DEFAULT_SYM_TOL):; """""" **NYI** Whether molecule satisfies the vector symmetry operation *op* """"""; raise FeatureNotImplemented('Molecule::has_symmetry_element') # FINAL SYMM. [docs] def point_group(self):; """""" **NYI** Returns the point group (object) if set""""""; raise FeatureNotImplemented('Molecule::point_group') # FINAL SYMM. [docs] def set_point_group(self, pg):; """""" **NYI** Set the point group to object *pg* """"""; raise FeatureNotImplemented('Molecule::set_point_group') # FINAL SYMM. [docs] def set_full_point_group(self, tol=FULL_PG_TOL):; """""" **NYI** Determine and set FULL point group""""""; raise FeatureNotImplemented('Molecule::set_full_point_group') # FINAL SYMM. [docs] def has_inversion(self, origin, tol=DEFAULT_SYM_TOL):; """"""Does the molecule have an inversio",MatchSource.WIKI,psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html:35058,Deployability,Update,Update,35058,") < tol:; return at; return -1. [docs] def is_variable(self, vstr):; """"""Checks to see if the variable str is in the list, returns; true if it is, and returns false if not. >>> H2OH2O.is_variable('R'); False. """"""; return True if vstr.upper() in self.all_variables else False. [docs] def get_variable(self, vstr):; """"""Checks to see if the variable str is in the list, sets it to; val and returns true if it is, and returns false if not. """"""; vstr = vstr.upper(); try:; return self.geometry_variables[vstr]; except KeyError:; raise ValidationError('ERROR: Geometry variable %s not known.\n' % (vstr)). [docs] def set_variable(self, vstr, val):; """"""Assigns the value val to the variable labelled string in the; list of geometry variables. Also calls update_geometry(). """"""; self.__dict__['lock_frame'] = False; self.__dict__['geometry_variables'][vstr.upper()] = val; print ""Setting geometry variable %s to %f"" % (vstr.upper(), val); try:; self.update_geometry(); except IncompleteAtomError:; # Update geometry might have added some atoms, delete them to be safe.; self.atoms = []; # TODO outfile. def __setattr__(self, name, value):; """"""Function to overload setting attributes to allow geometry; variable assigment as if member data. """"""; try:; if name.upper() in self.__dict__['all_variables']:; self.set_variable(name, value); else:; self.__dict__[name] = value; except KeyError:; self.__dict__[name] = value. def __getattr__(self, name):; """"""Function to overload accessing attribute contents to allow; retrivial geometry variable values as if member data. """"""; if not name in self.__dict__:; if object.__getattribute__(self, 'is_variable')(name):; return object.__getattribute__(self, 'get_variable')(name); else:; raise AttributeError; else:; return self.__dict__[name]. [docs] def get_anchor_atom(self, vstr, line):; """"""Attempts to interpret a string *vstr* as an atom specifier in; a zmatrix. Takes the current *line* for error message printing.; Returns the atom number (adjusted to zero-based co",MatchSource.WIKI,psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html:44733,Deployability,Update,Updates,44733,"; self.atoms = []; for item in self.full_atoms:; item.invalidate(). temp_charge = self.PYmolecular_charge; temp_multiplicity = self.PYmultiplicity; self.PYmolecular_charge = 0; self.PYmultiplicity = 1. for fr in range(self.nfragments()):; if self.fragment_types[fr] == 'Absent':; continue. if self.fragment_types[fr] == 'Real':; self.PYmolecular_charge += self.fragment_charges[fr]; self.PYmultiplicity += self.fragment_multiplicities[fr] - 1. for at in range(self.fragments[fr][0], self.fragments[fr][1] + 1):; self.full_atoms[at].compute(); self.full_atoms[at].set_ghosted(self.fragment_types[fr] == 'Ghost'); if self.full_atoms[at].symbol() != 'X':; self.atoms.append(self.full_atoms[at]). # TODO: This is a hack to ensure that set_multiplicity and set_molecular_charge; # work for single-fragment molecules.; if self.nfragments() < 2:; self.PYmolecular_charge = temp_charge; self.PYmultiplicity = temp_multiplicity. [docs] def update_geometry(self):; """"""Updates the geometry, by (re)interpreting the string used to; create the molecule, and the current values of the variables.; The atoms list is cleared, and then rebuilt by this routine.; This function must be called after first instantiation of Molecule. >>> H2 = qcdb.Molecule(""H\\nH 1 0.74\\n""); >>> print H2.natom(); 0; >>> H2.update_geometry(); >>> print H2.natom(); 2. """"""; if self.nfragments() == 0:; raise ValidationError(""Molecule::update_geometry: There are no fragments in this molecule.""). # Idempotence condition; if self.lock_frame:; return. #print ""beginning update_geometry:""; #self.print_full(); if self.PYreinterpret_coordentries:; self.reinterpret_coordentries(); #print ""after reinterpret_coordentries:""; #self.print_full(). if self.PYmove_to_com:; self.move_to_com(); #print ""after com:""; #self.print_full(). # If the no_reorient command was given, don't reorient; if not self.PYfix_orientation:; # Now we need to rotate the geometry to its symmetry frame; # to align the axes correctly for the point group; # symmetry_fra",MatchSource.WIKI,psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html:46111,Deployability,update,updated,46111,"tom(); 2. """"""; if self.nfragments() == 0:; raise ValidationError(""Molecule::update_geometry: There are no fragments in this molecule.""). # Idempotence condition; if self.lock_frame:; return. #print ""beginning update_geometry:""; #self.print_full(); if self.PYreinterpret_coordentries:; self.reinterpret_coordentries(); #print ""after reinterpret_coordentries:""; #self.print_full(). if self.PYmove_to_com:; self.move_to_com(); #print ""after com:""; #self.print_full(). # If the no_reorient command was given, don't reorient; if not self.PYfix_orientation:; # Now we need to rotate the geometry to its symmetry frame; # to align the axes correctly for the point group; # symmetry_frame looks for the highest point group so that we can align; # the molecule according to its actual symmetry, rather than the symmetry; # the the user might have provided.; frame = self.symmetry_frame(); self.rotate_full(frame); #print ""after rotate:""; #self.print_full(). # Recompute point group of the molecule, so the symmetry info is updated to the new frame; # TODO self.set_point_group(self.find_point_group()); # TODO self.set_full_point_group(). # Disabling symmetrize for now if orientation is fixed, as it is not; # correct. We may want to fix this in the future, but in some cases of; # finite-differences the set geometry is not totally symmetric anyway.; # Symmetrize the molecule to remove any noise; # TODO self.symmetrize(); #print ""after symmetry:""; #self.print_full(). self.lock_frame = True. # <<< Methods for Miscellaneous >>>. [docs] def clear(self):; """"""Zero it out.""""""; self.lock_frame = False; self.atoms = []; self.full_atoms = []. [docs] def nuclear_repulsion_energy(self):; """"""Computes nuclear repulsion energy. >>> print H2OH2O.nuclear_repulsion_energy(); 36.6628478528. """"""; e = 0.0; for at1 in range(self.natom()):; for at2 in range(self.natom()):; if at2 < at1:; Zi = self.Z(at1); Zj = self.Z(at2); dist = distance(self.xyz(at1), self.xyz(at2)); e += Zi * Zj / dist; return e. [docs] def nucle",MatchSource.WIKI,psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html:56213,Deployability,release,release,56213,"[0,-1,0],[-1,0,0],[0,0,1]]). """"""; new_geom = zero(3, self.nallatom()); geom = self.full_geometry(); new_geom = mult(geom, R); self.set_full_geometry(new_geom). [docs] def orientation_fixed(self):; """"""Get whether or not orientation is fixed. >>> H2OH2O.orientation_fixed(); True. """"""; return self.PYfix_orientation. [docs] def fix_orientation(self, _fix=True):; """"""Fix the orientation at its current frame; (method name in libmints is set_orientation_fixed). """"""; if _fix:; self.PYfix_orientation = True # tells update_geometry() not to change orientation; # Compute original cartesian coordinates - code coped from update_geometry(); self.atoms = []; for item in self.full_atoms:; item.invalidate(). for fr in range(self.nfragments()):; for at in range(self.fragments[fr][0], self.fragments[fr][1] + 1):; self.full_atoms[at].compute(); self.full_atoms[at].set_ghosted(self.fragment_types[fr] == 'Ghost'); if self.full_atoms[at].symbol() != 'X':; self.atoms.append(self.full_atoms[at]); else: # release orientation to be free; self.PYfix_orientation = False. # <<< Methods for Saving >>>. [docs] def save_string_xyz(self, save_ghosts=True):; """"""Save a string for a XYZ-style file. >>> H2OH2O.save_string_xyz(); 6; _; O -1.551007000000 -0.114520000000 0.000000000000; H -1.934259000000 0.762503000000 0.000000000000; H -0.599677000000 0.040712000000 0.000000000000; O 1.350625000000 0.111469000000 0.000000000000; H 1.680398000000 -0.373741000000 -0.758561000000; H 1.680398000000 -0.373741000000 0.758561000000. """"""; factor = 1.0 if self.PYunits == 'Angstrom' else psi_bohr2angstroms. N = self.natom(); if not save_ghosts:; N = 0; for i in range(self.natom()):; if self.Z(i):; N += 1; text = ""%d\n\n"" % (N). for i in range(self.natom()):; [x, y, z] = self.atoms[i].compute(); if save_ghosts or self.Z(i):; text += '%2s %17.12f %17.12f %17.12f\n' % ((self.symbol(i) if self.Z(i) else ""Gh""), \; x * factor, y * factor, z * factor); return text. [docs] def save_xyz(self, filename, save_ghosts=True):; """"",MatchSource.WIKI,psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html:70302,Deployability,Release,Release,70302," do; xaxis = perp_unit(zaxis, zaxis); elif have_sigma:; zaxis = copy.deepcopy(sigma); xaxis = perp_unit(zaxis, zaxis). # Clean up our z axis; if math.fabs(zaxis[0]) < NOISY_ZERO:; zaxis[0] = 0.0; if math.fabs(zaxis[1]) < NOISY_ZERO:; zaxis[1] = 0.0; if math.fabs(zaxis[2]) < NOISY_ZERO:; zaxis[2] = 0.0. # Clean up our x axis; if math.fabs(xaxis[0]) < NOISY_ZERO:; xaxis[0] = 0.0; if math.fabs(xaxis[1]) < NOISY_ZERO:; xaxis[1] = 0.0; if math.fabs(xaxis[2]) < NOISY_ZERO:; xaxis[2] = 0.0. # the y is then -x cross z; yaxis = scale(cross(xaxis, zaxis), -1.0). #print ""xaxis %20.14lf %20.14lf %20.14lf"" % (xaxis[0], xaxis[1], xaxis[2]); #print ""yaxis %20.14lf %20.14lf %20.14lf"" % (yaxis[0], yaxis[1], yaxis[2]); #print ""zaxis %20.14lf %20.14lf %20.14lf"" % (zaxis[0], zaxis[1], zaxis[2]). frame = zero(3, 3); for i in range(3):; frame[i][0] = xaxis[i]; frame[i][1] = yaxis[i]; frame[i][2] = zaxis[i]; return frame. [docs] def release_symmetry_information(self):; """""" **NYI** Release symmetry information""""""; raise FeatureNotImplemented('Molecule::release_symmetry_information') # FINAL SYMM. [docs] def form_symmetry_information(self, tol=DEFAULT_SYM_TOL):; """""" **NYI** Initialize molecular specific symmetry information.; Uses the point group object obtain by calling point_group(). """"""; raise FeatureNotImplemented('Molecule::form_symmetry_information') # FINAL SYMM. [docs] def sym_label(self):; """""" **NYI** Returns the symmetry label""""""; raise FeatureNotImplemented('Molecule::sym_label') # FINAL SYMM. [docs] def irrep_labels(self):; """""" **NYI** Returns the irrep labels""""""; raise FeatureNotImplemented('Molecule::irrep_labels') # FINAL SYMM. [docs] def symmetry_from_input(self):; """"""Returns the symmetry specified in the input. >>> print H2OH2O.symmetry_from_input(); C1. """"""; return self.PYsymmetry_from_input. [docs] def symmetrize(self):; """""" **NYI** Force the molecule to have the symmetry specified in pg.; This is to handle noise coming in from optking. """"""; raise FeatureNotImplemented('Mo",MatchSource.WIKI,psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html:74291,Deployability,update,updated,74291,"_group') # FINAL SYMM. # <<< Methods for Uniqueness >>> (assume molecular point group has been determined). [docs] def nunique(self):; """""" **NYI** Return the number of unique atoms.""""""; #w#return PYnunique; raise FeatureNotImplemented('Molecule::nunique') # FINAL SYMM. [docs] def unique(self, iuniq):; """""" **NYI** Returns the overall number of the iuniq'th unique atom.""""""; #w#return self.equiv[iuniq][0]; raise FeatureNotImplemented('Molecule::unique') # FINAL SYMM. [docs] def nequivalent(self, iuniq):; """""" **NYI** Returns the number of atoms equivalent to iuniq.""""""; #w#return self.nequiv[iuniq]; raise FeatureNotImplemented('Molecule::nequivalent') # FINAL SYMM. [docs] def equivalent(self, iuniq, j):; """""" **NYI** Returns the j'th atom equivalent to iuniq.""""""; #w#return self.equiv[iuniq][j]; raise FeatureNotImplemented('Molecule::equivalent') # FINAL SYMM. [docs] def atom_to_unique(self, iatom):; """""" **NYI** Converts an atom number to the number of its generating unique atom.; The return value is in [0, nunique). """"""; #w#return PYatom_to_unique[iatom]; raise FeatureNotImplemented('Molecule::atom_to_unique') # FINAL SYMM. [docs] def atom_to_unique_offset(self, iatom):; """""" **NYI** Converts an atom number to the offset of this atom; in the list of generated atoms. The unique atom itself is allowed offset 0. """"""; raise FeatureNotImplemented('Molecule::atom_to_unique_offset') # FINAL SYMM. [docs] def max_nequivalent(self):; """""" **NYI** Returns the maximum number of equivalent atoms.""""""; raise FeatureNotImplemented('Molecule::max_nequivalent') # FINAL SYMM. # TODO outfile; # ignored =, +, 0, += assignment operators; # no pubchem; # no symmetry; # TODO rename save_string_for_psi4; # TODO add no_com no_reorint in save string for psi4. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  ; PSI4 [beta5]  ; Module code .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html:1452,Energy Efficiency,charge,charge,1452,"oundation; either version 2 of the License, or; # (at your option) any later version.; #; # This program is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU General Public License for more details.; #; # You should have received a copy of the GNU General Public License along; # with this program; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; #@END LICENSE; #. import os; import re; import math; import copy; from periodictable import *; from physconst import *; from vecutil import *; from exceptions import *; from libmintscoordentry import *. LINEAR_A_TOL = 1.0E-2 # When sin(a) is below this, we consider the angle to be linear; DEFAULT_SYM_TOL = 1.0E-8; FULL_PG_TOL = 1.0e-8; ZERO = 1.0E-14; NOISY_ZERO = 1.0E-8. [docs]class LibmintsMolecule(object):; """"""Class to store the elements, coordinates, fragmentation pattern,; charge, multiplicity of a molecule. Largely replicates psi4's libmints; Molecule class, developed by Justin M. Turney and Andy M. Simmonett; with incremental improvements by other psi4 developers. Major; differences from the C++ class are: no basisset handling, no symmetry,; no pubchem, no efp, no discarding dummies. This class translated so; that databases can function independently of psi4. >>> H2OH2O = qcdb.Molecule(\""\""\""; 0 1; O1 -1.551007 -0.114520 0.000000; H1 -1.934259 0.762503 0.000000; H2 -0.599677 0.040712 0.000000; --; 0 1; X 0.000000 0.000000 0.000000; O2 1.350625 0.111469 0.000000; H3 1.680398 -0.373741 -0.758561; H4 1.680398 -0.373741 0.758561; no_com; no_reorient; units angstrom; \""\""\""). >>> H2O = qcdb.Molecule.init_with_xyz('h2o.xyz'); """"""; FullPointGroupList = [""ATOM"", ""C_inf_v"", ""D_inf_h"", ""C1"", ""Cs"", ""Ci"", \; ""Cn"", ""Cnv"", ""Cnh"", ""Sn"", ""Dn"", ""Dnd"", ""Dnh"", ""Td"", ""Oh"", ""Ih""]. def __init__(self, psi4molstr=None):; """"""Initialize Mole",MatchSource.WIKI,psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html:2568,Energy Efficiency,charge,charge,2568,"tin M. Turney and Andy M. Simmonett; with incremental improvements by other psi4 developers. Major; differences from the C++ class are: no basisset handling, no symmetry,; no pubchem, no efp, no discarding dummies. This class translated so; that databases can function independently of psi4. >>> H2OH2O = qcdb.Molecule(\""\""\""; 0 1; O1 -1.551007 -0.114520 0.000000; H1 -1.934259 0.762503 0.000000; H2 -0.599677 0.040712 0.000000; --; 0 1; X 0.000000 0.000000 0.000000; O2 1.350625 0.111469 0.000000; H3 1.680398 -0.373741 -0.758561; H4 1.680398 -0.373741 0.758561; no_com; no_reorient; units angstrom; \""\""\""). >>> H2O = qcdb.Molecule.init_with_xyz('h2o.xyz'); """"""; FullPointGroupList = [""ATOM"", ""C_inf_v"", ""D_inf_h"", ""C1"", ""Cs"", ""Ci"", \; ""Cn"", ""Cnv"", ""Cnh"", ""Sn"", ""Dn"", ""Dnd"", ""Dnh"", ""Td"", ""Oh"", ""Ih""]. def __init__(self, psi4molstr=None):; """"""Initialize Molecule object from string in psi4 format"""""". # <<< Basic Molecule Information >>>. # Molecule (or fragment) name; self.PYname = 'default'; # The molecular charge; self.PYmolecular_charge = 0; # Whether the charge was given by the user UNUSED; self.PYcharge_specified = False; # The multiplicity (defined as 2Ms + 1); self.PYmultiplicity = 1; # Whether the multiplicity was specified by the user UNUSED; self.PYmultiplicity_specified = False; # The units used to define the geometry; self.PYunits = 'Angstrom'; # The conversion factor to take input units to Bohr; self.input_units_to_au = 1.0 / psi_bohr2angstroms; # Whether this molecule has at least one zmatrix entry; self.zmat = False. # <<< Coordinates >>>. # Atom info vector (no knowledge of dummy atoms); self.atoms = []; # Atom info vector (includes dummy atoms); self.full_atoms = []; # A list of all variables known, whether they have been set or not.; self.all_variables = []; # A listing of the variables used to define the geometries; self.geometry_variables = {}. # <<< Fragmentation >>>. # The list of atom ranges defining each fragment from parent molecule; self.fragments = [];",MatchSource.WIKI,psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html:2619,Energy Efficiency,charge,charge,2619,"s by other psi4 developers. Major; differences from the C++ class are: no basisset handling, no symmetry,; no pubchem, no efp, no discarding dummies. This class translated so; that databases can function independently of psi4. >>> H2OH2O = qcdb.Molecule(\""\""\""; 0 1; O1 -1.551007 -0.114520 0.000000; H1 -1.934259 0.762503 0.000000; H2 -0.599677 0.040712 0.000000; --; 0 1; X 0.000000 0.000000 0.000000; O2 1.350625 0.111469 0.000000; H3 1.680398 -0.373741 -0.758561; H4 1.680398 -0.373741 0.758561; no_com; no_reorient; units angstrom; \""\""\""). >>> H2O = qcdb.Molecule.init_with_xyz('h2o.xyz'); """"""; FullPointGroupList = [""ATOM"", ""C_inf_v"", ""D_inf_h"", ""C1"", ""Cs"", ""Ci"", \; ""Cn"", ""Cnv"", ""Cnh"", ""Sn"", ""Dn"", ""Dnd"", ""Dnh"", ""Td"", ""Oh"", ""Ih""]. def __init__(self, psi4molstr=None):; """"""Initialize Molecule object from string in psi4 format"""""". # <<< Basic Molecule Information >>>. # Molecule (or fragment) name; self.PYname = 'default'; # The molecular charge; self.PYmolecular_charge = 0; # Whether the charge was given by the user UNUSED; self.PYcharge_specified = False; # The multiplicity (defined as 2Ms + 1); self.PYmultiplicity = 1; # Whether the multiplicity was specified by the user UNUSED; self.PYmultiplicity_specified = False; # The units used to define the geometry; self.PYunits = 'Angstrom'; # The conversion factor to take input units to Bohr; self.input_units_to_au = 1.0 / psi_bohr2angstroms; # Whether this molecule has at least one zmatrix entry; self.zmat = False. # <<< Coordinates >>>. # Atom info vector (no knowledge of dummy atoms); self.atoms = []; # Atom info vector (includes dummy atoms); self.full_atoms = []; # A list of all variables known, whether they have been set or not.; self.all_variables = []; # A listing of the variables used to define the geometries; self.geometry_variables = {}. # <<< Fragmentation >>>. # The list of atom ranges defining each fragment from parent molecule; self.fragments = []; # A list describing how to handle each fragment; self.fragment_",MatchSource.WIKI,psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html:3639,Energy Efficiency,charge,charge,3639,"he user UNUSED; self.PYcharge_specified = False; # The multiplicity (defined as 2Ms + 1); self.PYmultiplicity = 1; # Whether the multiplicity was specified by the user UNUSED; self.PYmultiplicity_specified = False; # The units used to define the geometry; self.PYunits = 'Angstrom'; # The conversion factor to take input units to Bohr; self.input_units_to_au = 1.0 / psi_bohr2angstroms; # Whether this molecule has at least one zmatrix entry; self.zmat = False. # <<< Coordinates >>>. # Atom info vector (no knowledge of dummy atoms); self.atoms = []; # Atom info vector (includes dummy atoms); self.full_atoms = []; # A list of all variables known, whether they have been set or not.; self.all_variables = []; # A listing of the variables used to define the geometries; self.geometry_variables = {}. # <<< Fragmentation >>>. # The list of atom ranges defining each fragment from parent molecule; self.fragments = []; # A list describing how to handle each fragment; self.fragment_types = []; # The charge of each fragment; self.fragment_charges = []; # The multiplicity of each fragment; self.fragment_multiplicities = []. # <<< Frame >>>. # Move to center of mass or not?; self.PYmove_to_com = True; # Reorient or not? UNUSED; self.PYfix_orientation = False; # Reinterpret the coord entries or not (Default is true, except for findif); self.PYreinterpret_coordentries = True; # Nilpotence boolean (flagged upon first determination of symmetry frame,; # reset each time a substantiative change is made); self.lock_frame = False. # <<< Symmetry >>>. # Point group to use with this molecule UNUSED; self.pg = None; # Full point group UNUSED; self.full_pg = 'PG_C1'; # n of the highest rotational axis Cn UNUSED; self.full_pg_n = 1; # Symmetry string from geometry specification; self.PYsymmetry_from_input = 'C1'; # Number of unique atoms; self.PYnunique = 0; # Number of equivalent atoms per unique atom (length nunique); self.nequiv = 0; # Equivalent atom mapping array; self.equiv = 0; # Atom to uni",MatchSource.WIKI,psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html:5350,Energy Efficiency,charge,charge,5350,"rotational axis Cn UNUSED; self.full_pg_n = 1; # Symmetry string from geometry specification; self.PYsymmetry_from_input = 'C1'; # Number of unique atoms; self.PYnunique = 0; # Number of equivalent atoms per unique atom (length nunique); self.nequiv = 0; # Equivalent atom mapping array; self.equiv = 0; # Atom to unique atom mapping array (length natom); self.PYatom_to_unique = 0. if psi4molstr:; self.create_molecule_from_string(psi4molstr). # <<< Simple Methods for Basic Molecule Information >>>. [docs] def name(self):; """"""Get molecule name. >>> print H2OH2O.name(); water_dimer. """"""; return self.PYname. [docs] def set_name(self, name):; """"""Set molecule name. >>> H2OH2O.set_name('water_dimer'). """"""; self.PYname = name. [docs] def natom(self):; """"""Number of atoms. >>> print H2OH2O.natom(); 6. """"""; return len(self.atoms). [docs] def nallatom(self):; """"""Number of all atoms (includes dummies). >>> print H2OH2O.nallatom(); 7. """"""; return len(self.full_atoms). [docs] def molecular_charge(self):; """"""Gets the molecular charge. >>> print H2OH2O.molecular_charge(); -2. """"""; return self.PYmolecular_charge. [docs] def set_molecular_charge(self, charge):; """"""Sets the molecular charge. >>> H2OH2O.set_molecular_charge(-2). """"""; self.PYcharge_specified = True; self.PYmolecular_charge = charge. [docs] def charge_specified(self):; """"""Whether the charge was given by the user. >>> print H2OH2O.charge_specified(); True. """"""; return self.PYcharge_specified. [docs] def multiplicity(self):; """"""Get the multiplicity (defined as 2Ms + 1). >>> print H2OH2O.multiplicity(). """"""; return self.PYmultiplicity. [docs] def set_multiplicity(self, mult):; """"""Sets the multiplicity (defined as 2Ms + 1). >>> H2OH2O.set_multiplicity(3). """"""; self.PYmultiplicity_specified = True; self.PYmultiplicity = mult. [docs] def multiplicity_specified(self):; """"""Whether the multiplicity was given by the user. >>> print H2OH2O.multiplicity_specified(); True. """"""; return self.PYmultiplicity_specified. [docs] def units(sel",MatchSource.WIKI,psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html:5474,Energy Efficiency,charge,charge,5474,"oms; self.PYnunique = 0; # Number of equivalent atoms per unique atom (length nunique); self.nequiv = 0; # Equivalent atom mapping array; self.equiv = 0; # Atom to unique atom mapping array (length natom); self.PYatom_to_unique = 0. if psi4molstr:; self.create_molecule_from_string(psi4molstr). # <<< Simple Methods for Basic Molecule Information >>>. [docs] def name(self):; """"""Get molecule name. >>> print H2OH2O.name(); water_dimer. """"""; return self.PYname. [docs] def set_name(self, name):; """"""Set molecule name. >>> H2OH2O.set_name('water_dimer'). """"""; self.PYname = name. [docs] def natom(self):; """"""Number of atoms. >>> print H2OH2O.natom(); 6. """"""; return len(self.atoms). [docs] def nallatom(self):; """"""Number of all atoms (includes dummies). >>> print H2OH2O.nallatom(); 7. """"""; return len(self.full_atoms). [docs] def molecular_charge(self):; """"""Gets the molecular charge. >>> print H2OH2O.molecular_charge(); -2. """"""; return self.PYmolecular_charge. [docs] def set_molecular_charge(self, charge):; """"""Sets the molecular charge. >>> H2OH2O.set_molecular_charge(-2). """"""; self.PYcharge_specified = True; self.PYmolecular_charge = charge. [docs] def charge_specified(self):; """"""Whether the charge was given by the user. >>> print H2OH2O.charge_specified(); True. """"""; return self.PYcharge_specified. [docs] def multiplicity(self):; """"""Get the multiplicity (defined as 2Ms + 1). >>> print H2OH2O.multiplicity(). """"""; return self.PYmultiplicity. [docs] def set_multiplicity(self, mult):; """"""Sets the multiplicity (defined as 2Ms + 1). >>> H2OH2O.set_multiplicity(3). """"""; self.PYmultiplicity_specified = True; self.PYmultiplicity = mult. [docs] def multiplicity_specified(self):; """"""Whether the multiplicity was given by the user. >>> print H2OH2O.multiplicity_specified(); True. """"""; return self.PYmultiplicity_specified. [docs] def units(self):; """"""Gets the geometry units. >>> print H2OH2O.units(); Angstrom. """"""; return self.PYunits. [docs] def set_units(self, units):; """"""Sets the geometr",MatchSource.WIKI,psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html:5506,Energy Efficiency,charge,charge,5506,"oms; self.PYnunique = 0; # Number of equivalent atoms per unique atom (length nunique); self.nequiv = 0; # Equivalent atom mapping array; self.equiv = 0; # Atom to unique atom mapping array (length natom); self.PYatom_to_unique = 0. if psi4molstr:; self.create_molecule_from_string(psi4molstr). # <<< Simple Methods for Basic Molecule Information >>>. [docs] def name(self):; """"""Get molecule name. >>> print H2OH2O.name(); water_dimer. """"""; return self.PYname. [docs] def set_name(self, name):; """"""Set molecule name. >>> H2OH2O.set_name('water_dimer'). """"""; self.PYname = name. [docs] def natom(self):; """"""Number of atoms. >>> print H2OH2O.natom(); 6. """"""; return len(self.atoms). [docs] def nallatom(self):; """"""Number of all atoms (includes dummies). >>> print H2OH2O.nallatom(); 7. """"""; return len(self.full_atoms). [docs] def molecular_charge(self):; """"""Gets the molecular charge. >>> print H2OH2O.molecular_charge(); -2. """"""; return self.PYmolecular_charge. [docs] def set_molecular_charge(self, charge):; """"""Sets the molecular charge. >>> H2OH2O.set_molecular_charge(-2). """"""; self.PYcharge_specified = True; self.PYmolecular_charge = charge. [docs] def charge_specified(self):; """"""Whether the charge was given by the user. >>> print H2OH2O.charge_specified(); True. """"""; return self.PYcharge_specified. [docs] def multiplicity(self):; """"""Get the multiplicity (defined as 2Ms + 1). >>> print H2OH2O.multiplicity(). """"""; return self.PYmultiplicity. [docs] def set_multiplicity(self, mult):; """"""Sets the multiplicity (defined as 2Ms + 1). >>> H2OH2O.set_multiplicity(3). """"""; self.PYmultiplicity_specified = True; self.PYmultiplicity = mult. [docs] def multiplicity_specified(self):; """"""Whether the multiplicity was given by the user. >>> print H2OH2O.multiplicity_specified(); True. """"""; return self.PYmultiplicity_specified. [docs] def units(self):; """"""Gets the geometry units. >>> print H2OH2O.units(); Angstrom. """"""; return self.PYunits. [docs] def set_units(self, units):; """"""Sets the geometr",MatchSource.WIKI,psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html:5614,Energy Efficiency,charge,charge,5614,"ray; self.equiv = 0; # Atom to unique atom mapping array (length natom); self.PYatom_to_unique = 0. if psi4molstr:; self.create_molecule_from_string(psi4molstr). # <<< Simple Methods for Basic Molecule Information >>>. [docs] def name(self):; """"""Get molecule name. >>> print H2OH2O.name(); water_dimer. """"""; return self.PYname. [docs] def set_name(self, name):; """"""Set molecule name. >>> H2OH2O.set_name('water_dimer'). """"""; self.PYname = name. [docs] def natom(self):; """"""Number of atoms. >>> print H2OH2O.natom(); 6. """"""; return len(self.atoms). [docs] def nallatom(self):; """"""Number of all atoms (includes dummies). >>> print H2OH2O.nallatom(); 7. """"""; return len(self.full_atoms). [docs] def molecular_charge(self):; """"""Gets the molecular charge. >>> print H2OH2O.molecular_charge(); -2. """"""; return self.PYmolecular_charge. [docs] def set_molecular_charge(self, charge):; """"""Sets the molecular charge. >>> H2OH2O.set_molecular_charge(-2). """"""; self.PYcharge_specified = True; self.PYmolecular_charge = charge. [docs] def charge_specified(self):; """"""Whether the charge was given by the user. >>> print H2OH2O.charge_specified(); True. """"""; return self.PYcharge_specified. [docs] def multiplicity(self):; """"""Get the multiplicity (defined as 2Ms + 1). >>> print H2OH2O.multiplicity(). """"""; return self.PYmultiplicity. [docs] def set_multiplicity(self, mult):; """"""Sets the multiplicity (defined as 2Ms + 1). >>> H2OH2O.set_multiplicity(3). """"""; self.PYmultiplicity_specified = True; self.PYmultiplicity = mult. [docs] def multiplicity_specified(self):; """"""Whether the multiplicity was given by the user. >>> print H2OH2O.multiplicity_specified(); True. """"""; return self.PYmultiplicity_specified. [docs] def units(self):; """"""Gets the geometry units. >>> print H2OH2O.units(); Angstrom. """"""; return self.PYunits. [docs] def set_units(self, units):; """"""Sets the geometry units. >>> H2OH2O.set_units('Angstom'). """"""; if units == 'Angstrom' or units == 'Bohr':; self.PYunits = units; else:; raise Validat",MatchSource.WIKI,psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html:5673,Energy Efficiency,charge,charge,5673,"ay (length natom); self.PYatom_to_unique = 0. if psi4molstr:; self.create_molecule_from_string(psi4molstr). # <<< Simple Methods for Basic Molecule Information >>>. [docs] def name(self):; """"""Get molecule name. >>> print H2OH2O.name(); water_dimer. """"""; return self.PYname. [docs] def set_name(self, name):; """"""Set molecule name. >>> H2OH2O.set_name('water_dimer'). """"""; self.PYname = name. [docs] def natom(self):; """"""Number of atoms. >>> print H2OH2O.natom(); 6. """"""; return len(self.atoms). [docs] def nallatom(self):; """"""Number of all atoms (includes dummies). >>> print H2OH2O.nallatom(); 7. """"""; return len(self.full_atoms). [docs] def molecular_charge(self):; """"""Gets the molecular charge. >>> print H2OH2O.molecular_charge(); -2. """"""; return self.PYmolecular_charge. [docs] def set_molecular_charge(self, charge):; """"""Sets the molecular charge. >>> H2OH2O.set_molecular_charge(-2). """"""; self.PYcharge_specified = True; self.PYmolecular_charge = charge. [docs] def charge_specified(self):; """"""Whether the charge was given by the user. >>> print H2OH2O.charge_specified(); True. """"""; return self.PYcharge_specified. [docs] def multiplicity(self):; """"""Get the multiplicity (defined as 2Ms + 1). >>> print H2OH2O.multiplicity(). """"""; return self.PYmultiplicity. [docs] def set_multiplicity(self, mult):; """"""Sets the multiplicity (defined as 2Ms + 1). >>> H2OH2O.set_multiplicity(3). """"""; self.PYmultiplicity_specified = True; self.PYmultiplicity = mult. [docs] def multiplicity_specified(self):; """"""Whether the multiplicity was given by the user. >>> print H2OH2O.multiplicity_specified(); True. """"""; return self.PYmultiplicity_specified. [docs] def units(self):; """"""Gets the geometry units. >>> print H2OH2O.units(); Angstrom. """"""; return self.PYunits. [docs] def set_units(self, units):; """"""Sets the geometry units. >>> H2OH2O.set_units('Angstom'). """"""; if units == 'Angstrom' or units == 'Bohr':; self.PYunits = units; else:; raise ValidationError(""""""Argument to Molecule::set_units must be 'An",MatchSource.WIKI,psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html:7039,Energy Efficiency,charge,charge,7039,"ltiplicity(3). """"""; self.PYmultiplicity_specified = True; self.PYmultiplicity = mult. [docs] def multiplicity_specified(self):; """"""Whether the multiplicity was given by the user. >>> print H2OH2O.multiplicity_specified(); True. """"""; return self.PYmultiplicity_specified. [docs] def units(self):; """"""Gets the geometry units. >>> print H2OH2O.units(); Angstrom. """"""; return self.PYunits. [docs] def set_units(self, units):; """"""Sets the geometry units. >>> H2OH2O.set_units('Angstom'). """"""; if units == 'Angstrom' or units == 'Bohr':; self.PYunits = units; else:; raise ValidationError(""""""Argument to Molecule::set_units must be 'Angstrom' or 'Bohr'.""""""). [docs] def has_zmatrix(self):; """"""Gets the presence of any zmatrix entry. >>> print H2OH2O.has_zmatrix(); False. """"""; return self.zmat. [docs] def set_has_zmatrix(self, tf):; """"""Sets the presence of any zmatrix entry. >>> H2OH2O.set_has_zmatrix(True). """"""; self.zmat = tf. # <<< Simple Methods for Coordinates >>>. [docs] def Z(self, atom):; """"""Nuclear charge of atom (0-indexed). >>> print H2OH2O.Z(4); 1. """"""; return self.atoms[atom].Z(). [docs] def x(self, atom):; """"""x position of atom (0-indexed) in Bohr. >>> print H2OH2O.x(4); 3.17549201425. """"""; return self.input_units_to_au * self.atoms[atom].compute()[0]. [docs] def y(self, atom):; """"""y position of atom (0-indexed) in Bohr. >>> print H2OH2O.y(4); -0.706268134631. """"""; return self.input_units_to_au * self.atoms[atom].compute()[1]. [docs] def z(self, atom):; """"""z position of atom (0-indexed) in Bohr. >>> print H2OH2O.z(4); -1.43347254509. """"""; return self.input_units_to_au * self.atoms[atom].compute()[2]. [docs] def xyz(self, atom, posn=None):; """"""Returns a Vector3 with x, y, z position of atom (0-indexed); in Bohr or coordinate at *posn*. >>> print H2OH2O.xyz(4); [3.175492014248769, -0.7062681346308132, -1.4334725450878665]. """"""; temp = scale(self.atoms[atom].compute(), self.input_units_to_au); if posn >= 0:; return temp[posn]; else:; return temp. [docs] def mass(self, ato",MatchSource.WIKI,psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html:8319,Energy Efficiency,charge,charge,8319,"mpute()[0]. [docs] def y(self, atom):; """"""y position of atom (0-indexed) in Bohr. >>> print H2OH2O.y(4); -0.706268134631. """"""; return self.input_units_to_au * self.atoms[atom].compute()[1]. [docs] def z(self, atom):; """"""z position of atom (0-indexed) in Bohr. >>> print H2OH2O.z(4); -1.43347254509. """"""; return self.input_units_to_au * self.atoms[atom].compute()[2]. [docs] def xyz(self, atom, posn=None):; """"""Returns a Vector3 with x, y, z position of atom (0-indexed); in Bohr or coordinate at *posn*. >>> print H2OH2O.xyz(4); [3.175492014248769, -0.7062681346308132, -1.4334725450878665]. """"""; temp = scale(self.atoms[atom].compute(), self.input_units_to_au); if posn >= 0:; return temp[posn]; else:; return temp. [docs] def mass(self, atom):; """"""Returns mass of atom (0-indexed). >>> print H2OH2O.mass(4); 1.00782503207. """"""; if self.atoms[atom].mass() != 0.0:; return self.atoms[atom].mass(). if math.fabs(self.atoms[atom].Z() - int(self.atoms[atom].Z())) > 0.0:; print ""WARNING: Obtaining masses from atom with fractional charge...may be incorrect!!!\n""; # TODO outfile; return an2masses[int(self.atoms[atom].Z())]. [docs] def symbol(self, atom):; """"""Returns the cleaned up label of the atom (C2 => C, H4 = H) (0-indexed). >>> print H2OH2O.symbol(4); H. """"""; return self.atoms[atom].symbol(). [docs] def label(self, atom):; """"""Returns the original label of the atom (0-indexed) as given in the input file (C2, H4). >>> print H2OH2O.label(4); H3. """"""; return self.atoms[atom].label(). [docs] def charge(self, atom):; """"""Returns charge of atom (0-indexed).; Related to SAD guess in libmints version. >>> print H2OH2O.charge(4); 1.0. """"""; return self.atoms[atom].charge(). [docs] def fZ(self, atom):; """"""Nuclear charge of atom (includes dummies). >>> print H2OH2O.fZ(4); 8. """"""; return self.full_atoms[atom].Z(). [docs] def fx(self, atom):; """"""x position of atom (0-indexed, includes dummies) in Bohr. >>> print H2OH2O.fx(4); 2.55231135823. """"""; return self.input_units_to_au * self.full_atoms[ato",MatchSource.WIKI,psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html:8792,Energy Efficiency,charge,charge,8792,"(4); [3.175492014248769, -0.7062681346308132, -1.4334725450878665]. """"""; temp = scale(self.atoms[atom].compute(), self.input_units_to_au); if posn >= 0:; return temp[posn]; else:; return temp. [docs] def mass(self, atom):; """"""Returns mass of atom (0-indexed). >>> print H2OH2O.mass(4); 1.00782503207. """"""; if self.atoms[atom].mass() != 0.0:; return self.atoms[atom].mass(). if math.fabs(self.atoms[atom].Z() - int(self.atoms[atom].Z())) > 0.0:; print ""WARNING: Obtaining masses from atom with fractional charge...may be incorrect!!!\n""; # TODO outfile; return an2masses[int(self.atoms[atom].Z())]. [docs] def symbol(self, atom):; """"""Returns the cleaned up label of the atom (C2 => C, H4 = H) (0-indexed). >>> print H2OH2O.symbol(4); H. """"""; return self.atoms[atom].symbol(). [docs] def label(self, atom):; """"""Returns the original label of the atom (0-indexed) as given in the input file (C2, H4). >>> print H2OH2O.label(4); H3. """"""; return self.atoms[atom].label(). [docs] def charge(self, atom):; """"""Returns charge of atom (0-indexed).; Related to SAD guess in libmints version. >>> print H2OH2O.charge(4); 1.0. """"""; return self.atoms[atom].charge(). [docs] def fZ(self, atom):; """"""Nuclear charge of atom (includes dummies). >>> print H2OH2O.fZ(4); 8. """"""; return self.full_atoms[atom].Z(). [docs] def fx(self, atom):; """"""x position of atom (0-indexed, includes dummies) in Bohr. >>> print H2OH2O.fx(4); 2.55231135823. """"""; return self.input_units_to_au * self.full_atoms[atom].compute()[0]. [docs] def fy(self, atom):; """"""y position of atom (0-indexed, includes dummies) in Bohr. >>> print H2OH2O.fy(4); 0.210645882307. """"""; return self.input_units_to_au * self.full_atoms[atom].compute()[1]. [docs] def fz(self, atom):; """"""z position of atom (0-indexed, includes dummies) in Bohr. >>> print H2OH2O.fz(4); 0.0. """"""; return self.input_units_to_au * self.full_atoms[atom].compute()[2]. [docs] def fxyz(self, atom):; """"""Returns a Vector3 with x, y, z position of atom; (0-indexed) in Bohr (includes dum",MatchSource.WIKI,psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html:8824,Energy Efficiency,charge,charge,8824,"(4); [3.175492014248769, -0.7062681346308132, -1.4334725450878665]. """"""; temp = scale(self.atoms[atom].compute(), self.input_units_to_au); if posn >= 0:; return temp[posn]; else:; return temp. [docs] def mass(self, atom):; """"""Returns mass of atom (0-indexed). >>> print H2OH2O.mass(4); 1.00782503207. """"""; if self.atoms[atom].mass() != 0.0:; return self.atoms[atom].mass(). if math.fabs(self.atoms[atom].Z() - int(self.atoms[atom].Z())) > 0.0:; print ""WARNING: Obtaining masses from atom with fractional charge...may be incorrect!!!\n""; # TODO outfile; return an2masses[int(self.atoms[atom].Z())]. [docs] def symbol(self, atom):; """"""Returns the cleaned up label of the atom (C2 => C, H4 = H) (0-indexed). >>> print H2OH2O.symbol(4); H. """"""; return self.atoms[atom].symbol(). [docs] def label(self, atom):; """"""Returns the original label of the atom (0-indexed) as given in the input file (C2, H4). >>> print H2OH2O.label(4); H3. """"""; return self.atoms[atom].label(). [docs] def charge(self, atom):; """"""Returns charge of atom (0-indexed).; Related to SAD guess in libmints version. >>> print H2OH2O.charge(4); 1.0. """"""; return self.atoms[atom].charge(). [docs] def fZ(self, atom):; """"""Nuclear charge of atom (includes dummies). >>> print H2OH2O.fZ(4); 8. """"""; return self.full_atoms[atom].Z(). [docs] def fx(self, atom):; """"""x position of atom (0-indexed, includes dummies) in Bohr. >>> print H2OH2O.fx(4); 2.55231135823. """"""; return self.input_units_to_au * self.full_atoms[atom].compute()[0]. [docs] def fy(self, atom):; """"""y position of atom (0-indexed, includes dummies) in Bohr. >>> print H2OH2O.fy(4); 0.210645882307. """"""; return self.input_units_to_au * self.full_atoms[atom].compute()[1]. [docs] def fz(self, atom):; """"""z position of atom (0-indexed, includes dummies) in Bohr. >>> print H2OH2O.fz(4); 0.0. """"""; return self.input_units_to_au * self.full_atoms[atom].compute()[2]. [docs] def fxyz(self, atom):; """"""Returns a Vector3 with x, y, z position of atom; (0-indexed) in Bohr (includes dum",MatchSource.WIKI,psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html:8912,Energy Efficiency,charge,charge,8912,"compute(), self.input_units_to_au); if posn >= 0:; return temp[posn]; else:; return temp. [docs] def mass(self, atom):; """"""Returns mass of atom (0-indexed). >>> print H2OH2O.mass(4); 1.00782503207. """"""; if self.atoms[atom].mass() != 0.0:; return self.atoms[atom].mass(). if math.fabs(self.atoms[atom].Z() - int(self.atoms[atom].Z())) > 0.0:; print ""WARNING: Obtaining masses from atom with fractional charge...may be incorrect!!!\n""; # TODO outfile; return an2masses[int(self.atoms[atom].Z())]. [docs] def symbol(self, atom):; """"""Returns the cleaned up label of the atom (C2 => C, H4 = H) (0-indexed). >>> print H2OH2O.symbol(4); H. """"""; return self.atoms[atom].symbol(). [docs] def label(self, atom):; """"""Returns the original label of the atom (0-indexed) as given in the input file (C2, H4). >>> print H2OH2O.label(4); H3. """"""; return self.atoms[atom].label(). [docs] def charge(self, atom):; """"""Returns charge of atom (0-indexed).; Related to SAD guess in libmints version. >>> print H2OH2O.charge(4); 1.0. """"""; return self.atoms[atom].charge(). [docs] def fZ(self, atom):; """"""Nuclear charge of atom (includes dummies). >>> print H2OH2O.fZ(4); 8. """"""; return self.full_atoms[atom].Z(). [docs] def fx(self, atom):; """"""x position of atom (0-indexed, includes dummies) in Bohr. >>> print H2OH2O.fx(4); 2.55231135823. """"""; return self.input_units_to_au * self.full_atoms[atom].compute()[0]. [docs] def fy(self, atom):; """"""y position of atom (0-indexed, includes dummies) in Bohr. >>> print H2OH2O.fy(4); 0.210645882307. """"""; return self.input_units_to_au * self.full_atoms[atom].compute()[1]. [docs] def fz(self, atom):; """"""z position of atom (0-indexed, includes dummies) in Bohr. >>> print H2OH2O.fz(4); 0.0. """"""; return self.input_units_to_au * self.full_atoms[atom].compute()[2]. [docs] def fxyz(self, atom):; """"""Returns a Vector3 with x, y, z position of atom; (0-indexed) in Bohr (includes dummies). >>> print H2OH2O.fxyz(4); [2.5523113582286716, 0.21064588230662976, 0.0]. """"""; return scale(self",MatchSource.WIKI,psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html:8957,Energy Efficiency,charge,charge,8957," >= 0:; return temp[posn]; else:; return temp. [docs] def mass(self, atom):; """"""Returns mass of atom (0-indexed). >>> print H2OH2O.mass(4); 1.00782503207. """"""; if self.atoms[atom].mass() != 0.0:; return self.atoms[atom].mass(). if math.fabs(self.atoms[atom].Z() - int(self.atoms[atom].Z())) > 0.0:; print ""WARNING: Obtaining masses from atom with fractional charge...may be incorrect!!!\n""; # TODO outfile; return an2masses[int(self.atoms[atom].Z())]. [docs] def symbol(self, atom):; """"""Returns the cleaned up label of the atom (C2 => C, H4 = H) (0-indexed). >>> print H2OH2O.symbol(4); H. """"""; return self.atoms[atom].symbol(). [docs] def label(self, atom):; """"""Returns the original label of the atom (0-indexed) as given in the input file (C2, H4). >>> print H2OH2O.label(4); H3. """"""; return self.atoms[atom].label(). [docs] def charge(self, atom):; """"""Returns charge of atom (0-indexed).; Related to SAD guess in libmints version. >>> print H2OH2O.charge(4); 1.0. """"""; return self.atoms[atom].charge(). [docs] def fZ(self, atom):; """"""Nuclear charge of atom (includes dummies). >>> print H2OH2O.fZ(4); 8. """"""; return self.full_atoms[atom].Z(). [docs] def fx(self, atom):; """"""x position of atom (0-indexed, includes dummies) in Bohr. >>> print H2OH2O.fx(4); 2.55231135823. """"""; return self.input_units_to_au * self.full_atoms[atom].compute()[0]. [docs] def fy(self, atom):; """"""y position of atom (0-indexed, includes dummies) in Bohr. >>> print H2OH2O.fy(4); 0.210645882307. """"""; return self.input_units_to_au * self.full_atoms[atom].compute()[1]. [docs] def fz(self, atom):; """"""z position of atom (0-indexed, includes dummies) in Bohr. >>> print H2OH2O.fz(4); 0.0. """"""; return self.input_units_to_au * self.full_atoms[atom].compute()[2]. [docs] def fxyz(self, atom):; """"""Returns a Vector3 with x, y, z position of atom; (0-indexed) in Bohr (includes dummies). >>> print H2OH2O.fxyz(4); [2.5523113582286716, 0.21064588230662976, 0.0]. """"""; return scale(self.full_atoms[atom].compute(), self.input_uni",MatchSource.WIKI,psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html:9006,Energy Efficiency,charge,charge,9006,"emp. [docs] def mass(self, atom):; """"""Returns mass of atom (0-indexed). >>> print H2OH2O.mass(4); 1.00782503207. """"""; if self.atoms[atom].mass() != 0.0:; return self.atoms[atom].mass(). if math.fabs(self.atoms[atom].Z() - int(self.atoms[atom].Z())) > 0.0:; print ""WARNING: Obtaining masses from atom with fractional charge...may be incorrect!!!\n""; # TODO outfile; return an2masses[int(self.atoms[atom].Z())]. [docs] def symbol(self, atom):; """"""Returns the cleaned up label of the atom (C2 => C, H4 = H) (0-indexed). >>> print H2OH2O.symbol(4); H. """"""; return self.atoms[atom].symbol(). [docs] def label(self, atom):; """"""Returns the original label of the atom (0-indexed) as given in the input file (C2, H4). >>> print H2OH2O.label(4); H3. """"""; return self.atoms[atom].label(). [docs] def charge(self, atom):; """"""Returns charge of atom (0-indexed).; Related to SAD guess in libmints version. >>> print H2OH2O.charge(4); 1.0. """"""; return self.atoms[atom].charge(). [docs] def fZ(self, atom):; """"""Nuclear charge of atom (includes dummies). >>> print H2OH2O.fZ(4); 8. """"""; return self.full_atoms[atom].Z(). [docs] def fx(self, atom):; """"""x position of atom (0-indexed, includes dummies) in Bohr. >>> print H2OH2O.fx(4); 2.55231135823. """"""; return self.input_units_to_au * self.full_atoms[atom].compute()[0]. [docs] def fy(self, atom):; """"""y position of atom (0-indexed, includes dummies) in Bohr. >>> print H2OH2O.fy(4); 0.210645882307. """"""; return self.input_units_to_au * self.full_atoms[atom].compute()[1]. [docs] def fz(self, atom):; """"""z position of atom (0-indexed, includes dummies) in Bohr. >>> print H2OH2O.fz(4); 0.0. """"""; return self.input_units_to_au * self.full_atoms[atom].compute()[2]. [docs] def fxyz(self, atom):; """"""Returns a Vector3 with x, y, z position of atom; (0-indexed) in Bohr (includes dummies). >>> print H2OH2O.fxyz(4); [2.5523113582286716, 0.21064588230662976, 0.0]. """"""; return scale(self.full_atoms[atom].compute(), self.input_units_to_au). [docs] def fmass(self, atom):;",MatchSource.WIKI,psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html:10596,Energy Efficiency,charge,charge,10596,"r. >>> print H2OH2O.fz(4); 0.0. """"""; return self.input_units_to_au * self.full_atoms[atom].compute()[2]. [docs] def fxyz(self, atom):; """"""Returns a Vector3 with x, y, z position of atom; (0-indexed) in Bohr (includes dummies). >>> print H2OH2O.fxyz(4); [2.5523113582286716, 0.21064588230662976, 0.0]. """"""; return scale(self.full_atoms[atom].compute(), self.input_units_to_au). [docs] def fmass(self, atom):; """"""Returns mass of atom (0-indexed, includes dummies). >>> print H2OH2O.fmass(4); 15.9949146196. """"""; return self.full_atoms[atom].mass(). [docs] def fsymbol(self, atom):; """"""Returns the cleaned up label of the atom (C2 => C, H4 = H) (includes dummies). >>> print H2OH2O.fsymbol(4); O. """"""; return self.full_atoms[atom].symbol(). [docs] def flabel(self, atom):; """"""Returns the original label of the atom (0-indexed) as given in; the input file (C2, H4) (includes dummies). >>> print H2OH2O.flabel(4); O2. """"""; return self.full_atoms[atom].label(). [docs] def fcharge(self, atom):; """"""Returns charge of atom (0-indexed, includes dummies).; Related to SAD guess in libmints version. >>> print H2OH2O.fcharge(4); 8.0. """"""; return self.full_atoms[atom].charge(). # <<< Simple Methods for Fragmentation >>>. [docs] def nfragments(self):; """"""The number of fragments in the molecule. >>> print H2OH2O.nfragments(); 2. """"""; return len(self.fragments). [docs] def nactive_fragments(self):; """"""The number of active fragments in the molecule. >>> print H2OH2O.nactive_fragments(); 2. """"""; n = 0; for fr in range(self.nfragments()):; if self.fragment_types[fr] == 'Real':; n += 1; return n. [docs] def activate_all_fragments(self):; """"""Sets all fragments in the molecule to be active.""""""; self.lock_frame = False; print 'it lives', 'activate all'; for fr in range(self.nfragments()):; print 'reviving', fr; self.fragment_types[fr] = 'Real'. [docs] def set_active_fragment(self, fr):; """"""Tags fragment index *fr* as composed of real atoms.""""""; self.lock_frame = False; self.fragment_types[fr - 1] = 'Real'",MatchSource.WIKI,psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html:10753,Energy Efficiency,charge,charge,10753,"x, y, z position of atom; (0-indexed) in Bohr (includes dummies). >>> print H2OH2O.fxyz(4); [2.5523113582286716, 0.21064588230662976, 0.0]. """"""; return scale(self.full_atoms[atom].compute(), self.input_units_to_au). [docs] def fmass(self, atom):; """"""Returns mass of atom (0-indexed, includes dummies). >>> print H2OH2O.fmass(4); 15.9949146196. """"""; return self.full_atoms[atom].mass(). [docs] def fsymbol(self, atom):; """"""Returns the cleaned up label of the atom (C2 => C, H4 = H) (includes dummies). >>> print H2OH2O.fsymbol(4); O. """"""; return self.full_atoms[atom].symbol(). [docs] def flabel(self, atom):; """"""Returns the original label of the atom (0-indexed) as given in; the input file (C2, H4) (includes dummies). >>> print H2OH2O.flabel(4); O2. """"""; return self.full_atoms[atom].label(). [docs] def fcharge(self, atom):; """"""Returns charge of atom (0-indexed, includes dummies).; Related to SAD guess in libmints version. >>> print H2OH2O.fcharge(4); 8.0. """"""; return self.full_atoms[atom].charge(). # <<< Simple Methods for Fragmentation >>>. [docs] def nfragments(self):; """"""The number of fragments in the molecule. >>> print H2OH2O.nfragments(); 2. """"""; return len(self.fragments). [docs] def nactive_fragments(self):; """"""The number of active fragments in the molecule. >>> print H2OH2O.nactive_fragments(); 2. """"""; n = 0; for fr in range(self.nfragments()):; if self.fragment_types[fr] == 'Real':; n += 1; return n. [docs] def activate_all_fragments(self):; """"""Sets all fragments in the molecule to be active.""""""; self.lock_frame = False; print 'it lives', 'activate all'; for fr in range(self.nfragments()):; print 'reviving', fr; self.fragment_types[fr] = 'Real'. [docs] def set_active_fragment(self, fr):; """"""Tags fragment index *fr* as composed of real atoms.""""""; self.lock_frame = False; self.fragment_types[fr - 1] = 'Real'. [docs] def set_active_fragments(self, reals):; """"""Tags the fragments in array *reals* as composed of real atoms.""""""; self.lock_frame = False; for fr in reals:; ",MatchSource.WIKI,psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html:16159,Energy Efficiency,charge,charge,16159,"it('\n', text); glines = []; ifrag = 0. for line in lines:. # handle comments; if comment.match(line) or blank.match(line):; pass. # handle units; elif ang.match(line):; self.set_units('Angstrom'); self.input_units_to_au = 1.0 / psi_bohr2angstroms; elif bohr.match(line):; self.set_units('Bohr'); self.input_units_to_au = 1.0. # handle no_reorient; elif orient.match(line):; self.fix_orientation(True). # handle no_com; elif com.match(line):; self.PYmove_to_com = False. # handle symmetry; elif symmetry.match(line):; tempSymm = symmetry.match(line).group(1); temp2 = re.sub('[23456789]', 'n', tempSymm).upper(); if temp2 in (item.upper() for item in self.FullPointGroupList):; self.PYsymmetry_from_input = tempSymm. # handle variables; elif variable.match(line):; vname = variable.match(line).group(1).upper(); vval = float(variable.match(line).group(2)); tda = 360.0 * math.atan(math.sqrt(2)) / math.pi; self.geometry_variables['%s' % vname] = tda if vname == 'TDA' else vval. # handle charge and multiplicity; elif cgmp.match(line):; tempCharge = int(cgmp.match(line).group(1)); tempMultiplicity = int(cgmp.match(line).group(2)). if ifrag == 0:; self.PYcharge_specified = True; self.PYmultiplicity_specified = True; self.PYmolecular_charge = tempCharge; self.PYmultiplicity = tempMultiplicity; self.fragment_charges.append(tempCharge); self.fragment_multiplicities.append(tempMultiplicity). # handle fragment markers and default fragment cgmp; elif frag.match(line):; try:; self.fragment_charges[ifrag]; except:; self.fragment_charges.append(0); self.fragment_multiplicities.append(1); ifrag += 1; glines.append(line). elif atom.match(line):; glines.append(line). # catch last default fragment cgmp; try:; self.fragment_charges[ifrag]; except:; self.fragment_charges.append(0); self.fragment_multiplicities.append(1). # Now go through the rest of the lines looking for fragment markers; ifrag = 0; iatom = 0; tempfrag = []; atomSym = """"; atomLabel = """"; zmatrix = False; for line in glines:. # hand",MatchSource.WIKI,psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html:18005,Energy Efficiency,charge,charge,18005,"he lines looking for fragment markers; ifrag = 0; iatom = 0; tempfrag = []; atomSym = """"; atomLabel = """"; zmatrix = False; for line in glines:. # handle fragment markers; if frag.match(line):; ifrag += 1; self.fragments.append([tempfrag[0], tempfrag[-1]]); self.fragment_types.append('Real'); tempfrag = []. # handle atom markers; elif atom.match(line):; entries = re.split(r'\s+|\s*,\s*', line.strip()); atomLabel = entries[0]. # handle ghost atoms; ghostAtom = False; if ghost.match(atomLabel):; # We don't know whether the @C or Gh(C) notation matched. Do a quick check.; atomLabel = ghost.match(atomLabel).group(2) if not ghost.match(atomLabel).group(1) \; else ghost.match(atomLabel).group(1); ghostAtom = True. # Save the actual atom symbol (H1 => H); atomSym = re.split('(\d+)', atomLabel)[0].upper(). # Check that the atom symbol is valid; if not atomSym in el2z:; raise ValidationError('Illegal atom symbol in geometry specification: %s' % (atomSym)). zVal = el2z[atomSym]; charge = float(zVal); if ghostAtom:; zVal = 0; charge = 0.0. # handle cartesians; if len(entries) == 4:; tempfrag.append(iatom); xval = self.get_coord_value(entries[1]); yval = self.get_coord_value(entries[2]); zval = self.get_coord_value(entries[3]); self.full_atoms.append(CartesianEntry(iatom, zVal, charge, \; el2masses[atomSym], atomSym, atomLabel, \; xval, yval, zval)). # handle first line of Zmat; elif len(entries) == 1:; zmatrix = True; tempfrag.append(iatom); self.full_atoms.append(ZMatrixEntry(iatom, zVal, charge, \; el2masses[atomSym], atomSym, atomLabel)). # handle second line of Zmat; elif len(entries) == 3:; zmatrix = True; tempfrag.append(iatom). rTo = self.get_anchor_atom(entries[1], line); if rTo >= iatom:; raise ValidationError(""Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[1])); rval = self.get_coord_value(entries[2]). if self.full_atoms[rTo].symbol() == 'X':; rval.set_fixed(True). self.full_atoms.append(ZMatrixEntry(iatom, zVal, charge, \; el2ma",MatchSource.WIKI,psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html:18052,Energy Efficiency,charge,charge,18052,"he lines looking for fragment markers; ifrag = 0; iatom = 0; tempfrag = []; atomSym = """"; atomLabel = """"; zmatrix = False; for line in glines:. # handle fragment markers; if frag.match(line):; ifrag += 1; self.fragments.append([tempfrag[0], tempfrag[-1]]); self.fragment_types.append('Real'); tempfrag = []. # handle atom markers; elif atom.match(line):; entries = re.split(r'\s+|\s*,\s*', line.strip()); atomLabel = entries[0]. # handle ghost atoms; ghostAtom = False; if ghost.match(atomLabel):; # We don't know whether the @C or Gh(C) notation matched. Do a quick check.; atomLabel = ghost.match(atomLabel).group(2) if not ghost.match(atomLabel).group(1) \; else ghost.match(atomLabel).group(1); ghostAtom = True. # Save the actual atom symbol (H1 => H); atomSym = re.split('(\d+)', atomLabel)[0].upper(). # Check that the atom symbol is valid; if not atomSym in el2z:; raise ValidationError('Illegal atom symbol in geometry specification: %s' % (atomSym)). zVal = el2z[atomSym]; charge = float(zVal); if ghostAtom:; zVal = 0; charge = 0.0. # handle cartesians; if len(entries) == 4:; tempfrag.append(iatom); xval = self.get_coord_value(entries[1]); yval = self.get_coord_value(entries[2]); zval = self.get_coord_value(entries[3]); self.full_atoms.append(CartesianEntry(iatom, zVal, charge, \; el2masses[atomSym], atomSym, atomLabel, \; xval, yval, zval)). # handle first line of Zmat; elif len(entries) == 1:; zmatrix = True; tempfrag.append(iatom); self.full_atoms.append(ZMatrixEntry(iatom, zVal, charge, \; el2masses[atomSym], atomSym, atomLabel)). # handle second line of Zmat; elif len(entries) == 3:; zmatrix = True; tempfrag.append(iatom). rTo = self.get_anchor_atom(entries[1], line); if rTo >= iatom:; raise ValidationError(""Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[1])); rval = self.get_coord_value(entries[2]). if self.full_atoms[rTo].symbol() == 'X':; rval.set_fixed(True). self.full_atoms.append(ZMatrixEntry(iatom, zVal, charge, \; el2ma",MatchSource.WIKI,psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html:18308,Energy Efficiency,charge,charge,18308,"]. # handle atom markers; elif atom.match(line):; entries = re.split(r'\s+|\s*,\s*', line.strip()); atomLabel = entries[0]. # handle ghost atoms; ghostAtom = False; if ghost.match(atomLabel):; # We don't know whether the @C or Gh(C) notation matched. Do a quick check.; atomLabel = ghost.match(atomLabel).group(2) if not ghost.match(atomLabel).group(1) \; else ghost.match(atomLabel).group(1); ghostAtom = True. # Save the actual atom symbol (H1 => H); atomSym = re.split('(\d+)', atomLabel)[0].upper(). # Check that the atom symbol is valid; if not atomSym in el2z:; raise ValidationError('Illegal atom symbol in geometry specification: %s' % (atomSym)). zVal = el2z[atomSym]; charge = float(zVal); if ghostAtom:; zVal = 0; charge = 0.0. # handle cartesians; if len(entries) == 4:; tempfrag.append(iatom); xval = self.get_coord_value(entries[1]); yval = self.get_coord_value(entries[2]); zval = self.get_coord_value(entries[3]); self.full_atoms.append(CartesianEntry(iatom, zVal, charge, \; el2masses[atomSym], atomSym, atomLabel, \; xval, yval, zval)). # handle first line of Zmat; elif len(entries) == 1:; zmatrix = True; tempfrag.append(iatom); self.full_atoms.append(ZMatrixEntry(iatom, zVal, charge, \; el2masses[atomSym], atomSym, atomLabel)). # handle second line of Zmat; elif len(entries) == 3:; zmatrix = True; tempfrag.append(iatom). rTo = self.get_anchor_atom(entries[1], line); if rTo >= iatom:; raise ValidationError(""Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[1])); rval = self.get_coord_value(entries[2]). if self.full_atoms[rTo].symbol() == 'X':; rval.set_fixed(True). self.full_atoms.append(ZMatrixEntry(iatom, zVal, charge, \; el2masses[atomSym], atomSym, atomLabel, \; self.full_atoms[rTo], rval)). # handle third line of Zmat; elif len(entries) == 5:; zmatrix = True; tempfrag.append(iatom). rTo = self.get_anchor_atom(entries[1], line); if rTo >= iatom:; raise ValidationError(""Error on geometry input line %s. Atom %s has not been d",MatchSource.WIKI,psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html:18525,Energy Efficiency,charge,charge,18525,"w whether the @C or Gh(C) notation matched. Do a quick check.; atomLabel = ghost.match(atomLabel).group(2) if not ghost.match(atomLabel).group(1) \; else ghost.match(atomLabel).group(1); ghostAtom = True. # Save the actual atom symbol (H1 => H); atomSym = re.split('(\d+)', atomLabel)[0].upper(). # Check that the atom symbol is valid; if not atomSym in el2z:; raise ValidationError('Illegal atom symbol in geometry specification: %s' % (atomSym)). zVal = el2z[atomSym]; charge = float(zVal); if ghostAtom:; zVal = 0; charge = 0.0. # handle cartesians; if len(entries) == 4:; tempfrag.append(iatom); xval = self.get_coord_value(entries[1]); yval = self.get_coord_value(entries[2]); zval = self.get_coord_value(entries[3]); self.full_atoms.append(CartesianEntry(iatom, zVal, charge, \; el2masses[atomSym], atomSym, atomLabel, \; xval, yval, zval)). # handle first line of Zmat; elif len(entries) == 1:; zmatrix = True; tempfrag.append(iatom); self.full_atoms.append(ZMatrixEntry(iatom, zVal, charge, \; el2masses[atomSym], atomSym, atomLabel)). # handle second line of Zmat; elif len(entries) == 3:; zmatrix = True; tempfrag.append(iatom). rTo = self.get_anchor_atom(entries[1], line); if rTo >= iatom:; raise ValidationError(""Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[1])); rval = self.get_coord_value(entries[2]). if self.full_atoms[rTo].symbol() == 'X':; rval.set_fixed(True). self.full_atoms.append(ZMatrixEntry(iatom, zVal, charge, \; el2masses[atomSym], atomSym, atomLabel, \; self.full_atoms[rTo], rval)). # handle third line of Zmat; elif len(entries) == 5:; zmatrix = True; tempfrag.append(iatom). rTo = self.get_anchor_atom(entries[1], line); if rTo >= iatom:; raise ValidationError(""Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[1])); aTo = self.get_anchor_atom(entries[3], line); if aTo >= iatom:; raise ValidationError(""Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entr",MatchSource.WIKI,psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html:19007,Energy Efficiency,charge,charge,19007,"zVal); if ghostAtom:; zVal = 0; charge = 0.0. # handle cartesians; if len(entries) == 4:; tempfrag.append(iatom); xval = self.get_coord_value(entries[1]); yval = self.get_coord_value(entries[2]); zval = self.get_coord_value(entries[3]); self.full_atoms.append(CartesianEntry(iatom, zVal, charge, \; el2masses[atomSym], atomSym, atomLabel, \; xval, yval, zval)). # handle first line of Zmat; elif len(entries) == 1:; zmatrix = True; tempfrag.append(iatom); self.full_atoms.append(ZMatrixEntry(iatom, zVal, charge, \; el2masses[atomSym], atomSym, atomLabel)). # handle second line of Zmat; elif len(entries) == 3:; zmatrix = True; tempfrag.append(iatom). rTo = self.get_anchor_atom(entries[1], line); if rTo >= iatom:; raise ValidationError(""Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[1])); rval = self.get_coord_value(entries[2]). if self.full_atoms[rTo].symbol() == 'X':; rval.set_fixed(True). self.full_atoms.append(ZMatrixEntry(iatom, zVal, charge, \; el2masses[atomSym], atomSym, atomLabel, \; self.full_atoms[rTo], rval)). # handle third line of Zmat; elif len(entries) == 5:; zmatrix = True; tempfrag.append(iatom). rTo = self.get_anchor_atom(entries[1], line); if rTo >= iatom:; raise ValidationError(""Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[1])); aTo = self.get_anchor_atom(entries[3], line); if aTo >= iatom:; raise ValidationError(""Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[3])); if aTo == rTo:; raise ValidationError(""Atom used multiple times on line %s."" % (line)); rval = self.get_coord_value(entries[2]); aval = self.get_coord_value(entries[4]). if self.full_atoms[rTo].symbol() == 'X':; rval.set_fixed(True); if self.full_atoms[aTo].symbol() == 'X':; aval.set_fixed(True). self.full_atoms.append(ZMatrixEntry(iatom, zVal, charge, \; el2masses[atomSym], atomSym, atomLabel, \; self.full_atoms[rTo], rval, \; self.full_atoms[aTo], aval)). # handle four",MatchSource.WIKI,psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html:19892,Energy Efficiency,charge,charge,19892,"l_atoms[rTo].symbol() == 'X':; rval.set_fixed(True). self.full_atoms.append(ZMatrixEntry(iatom, zVal, charge, \; el2masses[atomSym], atomSym, atomLabel, \; self.full_atoms[rTo], rval)). # handle third line of Zmat; elif len(entries) == 5:; zmatrix = True; tempfrag.append(iatom). rTo = self.get_anchor_atom(entries[1], line); if rTo >= iatom:; raise ValidationError(""Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[1])); aTo = self.get_anchor_atom(entries[3], line); if aTo >= iatom:; raise ValidationError(""Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[3])); if aTo == rTo:; raise ValidationError(""Atom used multiple times on line %s."" % (line)); rval = self.get_coord_value(entries[2]); aval = self.get_coord_value(entries[4]). if self.full_atoms[rTo].symbol() == 'X':; rval.set_fixed(True); if self.full_atoms[aTo].symbol() == 'X':; aval.set_fixed(True). self.full_atoms.append(ZMatrixEntry(iatom, zVal, charge, \; el2masses[atomSym], atomSym, atomLabel, \; self.full_atoms[rTo], rval, \; self.full_atoms[aTo], aval)). # handle fourth line of Zmat; elif len(entries) == 7:; zmatrix = True; tempfrag.append(iatom). rTo = self.get_anchor_atom(entries[1], line); if rTo >= iatom:; raise ValidationError(""Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[1])); aTo = self.get_anchor_atom(entries[3], line); if aTo >= iatom:; raise ValidationError(""Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[3])); dTo = self.get_anchor_atom(entries[5], line); if dTo >= iatom:; raise ValidationError(""Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[5])); if aTo == rTo or rTo == dTo or aTo == dTo: # for you star wars fans; raise ValidationError(""Atom used multiple times on line %s"" % (line)). rval = self.get_coord_value(entries[2]); aval = self.get_coord_value(entries[4]); dval = self.get_coord_value(entries[6]). ",MatchSource.WIKI,psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html:21146,Energy Efficiency,charge,charge,21146,"atom:; raise ValidationError(""Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[1])); aTo = self.get_anchor_atom(entries[3], line); if aTo >= iatom:; raise ValidationError(""Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[3])); dTo = self.get_anchor_atom(entries[5], line); if dTo >= iatom:; raise ValidationError(""Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[5])); if aTo == rTo or rTo == dTo or aTo == dTo: # for you star wars fans; raise ValidationError(""Atom used multiple times on line %s"" % (line)). rval = self.get_coord_value(entries[2]); aval = self.get_coord_value(entries[4]); dval = self.get_coord_value(entries[6]). if self.full_atoms[rTo].symbol() == 'X':; rval.set_fixed(True); if self.full_atoms[aTo].symbol() == 'X':; aval.set_fixed(True); if self.full_atoms[dTo].symbol() == 'X':; dval.set_fixed(True). self.full_atoms.append(ZMatrixEntry(iatom, zVal, charge, \; el2masses[atomSym], atomSym, atomLabel, \; self.full_atoms[rTo], rval, \; self.full_atoms[aTo], aval, \; self.full_atoms[dTo], dval)). else:; raise ValidationError('Illegal geometry specification line : %s. \; You should provide either Z-Matrix or Cartesian input' % (line)). iatom += 1. self.fragments.append([tempfrag[0], tempfrag[-1]]); self.fragment_types.append('Real'); self.set_has_zmatrix(zmatrix). [docs] def init_with_checkpoint(self, chkpt):; """""" **NYI** Pull information from the *chkpt* object passed; (method name in libmints is init_with_chkpt). """"""; raise FeatureNotImplemented('Molecule::init_with_checkpoint') # FINAL. [docs] def init_with_io(self, psio):; """""" **NYI** Pull information from a chkpt object created from psio; (method name in libmints is init_with_psio). """"""; raise FeatureNotImplemented('Molecule::init_with_io') # FINAL. @classmethod; [docs] def init_with_xyz(cls, xyzfilename):; """"""Pull information from an XYZ file. No fragment or chg/mult info detected. >>> H2O = ",MatchSource.WIKI,psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html:24745,Energy Efficiency,charge,charge,24745," fileAtom, el2masses[fileAtom]). else:; raise ValidationError(""Molecule::init_with_xyz: Malformed atom information line %d."" % (i + 3)); except IndexError:; raise ValidationError(""Molecule::init_with_xyz: Expected atom in file at line %d.\n%s"" % (i + 3, text[i + 2])). # We need to make 1 fragment with all atoms; instance.fragments.append([0, fileNatom - 1]); instance.fragment_types.append('Real'); instance.fragment_charges.append(0); instance.fragment_multiplicities.append(1); # Set the units to bohr since we did the conversion above, if needed.; instance.PYunits = 'Bohr'; instance.input_units_to_au = 1.0. instance.update_geometry(); return instance. [docs] def clone(self):; """"""Returns new, independent Molecule object. >>> dimer = H2OH2O.clone(). """"""; return copy.deepcopy(self). # <<< Methods for Printing >>>. [docs] def print_out(self):; """"""Print the molecule.; (method name in libmints is print). >>> H2OH2O.print_out(); Geometry (in Angstrom), charge = -2, multiplicity = 3:; Center X Y Z; ------------ ----------------- ----------------- -----------------; O -1.551007000000 -0.114520000000 0.000000000000; H -1.934259000000 0.762503000000 0.000000000000; H -0.599677000000 0.040712000000 0.000000000000; O 1.350625000000 0.111469000000 0.000000000000; H 1.680398000000 -0.373741000000 -0.758561000000; H 1.680398000000 -0.373741000000 0.758561000000. """"""; text = """"; if self.natom():; if self.pg:; text += """""" Molecular point group: %s\n"""""" % (self.pg.symbol()); # if self.full_pg: TODO symmetry; # text += """""" Full point group: %s\n\n"""""" % (self.full_point_group()) TODO symmetry; text += """""" Geometry (in %s), charge = %d, multiplicity = %d:\n\n"""""" % \; ('Angstrom' if self.units() == 'Angstrom' else 'Bohr', self.molecular_charge(), self.multiplicity()); text += """""" Center X Y Z \n""""""; text += """""" ------------ ----------------- ----------------- -----------------\n"""""". for i in range(self.natom()):; geom = self.atoms[i].compute(); text += """""" %8s%4s """""" % (self.symbol(i), """" ",MatchSource.WIKI,psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html:25415,Energy Efficiency,charge,charge,25415,"e_geometry(); return instance. [docs] def clone(self):; """"""Returns new, independent Molecule object. >>> dimer = H2OH2O.clone(). """"""; return copy.deepcopy(self). # <<< Methods for Printing >>>. [docs] def print_out(self):; """"""Print the molecule.; (method name in libmints is print). >>> H2OH2O.print_out(); Geometry (in Angstrom), charge = -2, multiplicity = 3:; Center X Y Z; ------------ ----------------- ----------------- -----------------; O -1.551007000000 -0.114520000000 0.000000000000; H -1.934259000000 0.762503000000 0.000000000000; H -0.599677000000 0.040712000000 0.000000000000; O 1.350625000000 0.111469000000 0.000000000000; H 1.680398000000 -0.373741000000 -0.758561000000; H 1.680398000000 -0.373741000000 0.758561000000. """"""; text = """"; if self.natom():; if self.pg:; text += """""" Molecular point group: %s\n"""""" % (self.pg.symbol()); # if self.full_pg: TODO symmetry; # text += """""" Full point group: %s\n\n"""""" % (self.full_point_group()) TODO symmetry; text += """""" Geometry (in %s), charge = %d, multiplicity = %d:\n\n"""""" % \; ('Angstrom' if self.units() == 'Angstrom' else 'Bohr', self.molecular_charge(), self.multiplicity()); text += """""" Center X Y Z \n""""""; text += """""" ------------ ----------------- ----------------- -----------------\n"""""". for i in range(self.natom()):; geom = self.atoms[i].compute(); text += """""" %8s%4s """""" % (self.symbol(i), """" if self.Z(i) else ""(Gh)""); for j in range(3):; text += """""" %17.12f"""""" % (geom[j]); text += ""\n""; text += ""\n""; else:; text += "" No atoms in this molecule.\n""; print text; # TODO outfile. [docs] def print_out_in_bohr(self):; """"""Print the molecule in Bohr. Same as :py:func:`print_out` only in Bohr.; (method name in libmints is print_in_bohr). """"""; text = """"; if self.natom():; if self.pg:; text += """""" Molecular point group: %s\n"""""" % (self.pg.symbol()); # if self.full_pg: TODO symmetry; # text += """""" Full point group: %s\n\n"""""" % (self.full_point_group()) TODO symmetry; text += """""" Geometry (in %s), charge = %d, multiplicity",MatchSource.WIKI,psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html:26390,Energy Efficiency,charge,charge,26390,"ext += """""" Geometry (in %s), charge = %d, multiplicity = %d:\n\n"""""" % \; ('Angstrom' if self.units() == 'Angstrom' else 'Bohr', self.molecular_charge(), self.multiplicity()); text += """""" Center X Y Z \n""""""; text += """""" ------------ ----------------- ----------------- -----------------\n"""""". for i in range(self.natom()):; geom = self.atoms[i].compute(); text += """""" %8s%4s """""" % (self.symbol(i), """" if self.Z(i) else ""(Gh)""); for j in range(3):; text += """""" %17.12f"""""" % (geom[j]); text += ""\n""; text += ""\n""; else:; text += "" No atoms in this molecule.\n""; print text; # TODO outfile. [docs] def print_out_in_bohr(self):; """"""Print the molecule in Bohr. Same as :py:func:`print_out` only in Bohr.; (method name in libmints is print_in_bohr). """"""; text = """"; if self.natom():; if self.pg:; text += """""" Molecular point group: %s\n"""""" % (self.pg.symbol()); # if self.full_pg: TODO symmetry; # text += """""" Full point group: %s\n\n"""""" % (self.full_point_group()) TODO symmetry; text += """""" Geometry (in %s), charge = %d, multiplicity = %d:\n\n"""""" % \; ('Bohr', self.molecular_charge(), self.multiplicity()); text += """""" Center X Y Z \n""""""; text += """""" ------------ ----------------- ----------------- -----------------\n"""""". for i in range(self.natom()):; text += """""" %8s%4s """""" % (self.symbol(i), """" if self.Z(i) else ""(Gh)""); for j in range(3):; text += """""" %17.12f"""""" % (self.xyz(i, j)); text += ""\n""; text += ""\n""; else:; text += "" No atoms in this molecule.\n""; print text; # TODO outfile. [docs] def print_out_in_angstrom(self):; """"""Print the molecule in Angstroms. Same as :py:func:`print_out` only always in Angstroms.; (method name in libmints is print_in_angstrom). """"""; text = """"; if self.natom():; if self.pg:; text += """""" Molecular point group: %s\n"""""" % (self.pg.symbol()); # if self.full_pg: TODO symmetry; # text += """""" Full point group: %s\n\n"""""" % (self.full_point_group()) TODO symmetry; text += """""" Geometry (in %s), charge = %d, multiplicity = %d:\n\n"""""" % \; ('Angstrom', self.molecu",MatchSource.WIKI,psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html:27319,Energy Efficiency,charge,charge,27319,"% (self.full_point_group()) TODO symmetry; text += """""" Geometry (in %s), charge = %d, multiplicity = %d:\n\n"""""" % \; ('Bohr', self.molecular_charge(), self.multiplicity()); text += """""" Center X Y Z \n""""""; text += """""" ------------ ----------------- ----------------- -----------------\n"""""". for i in range(self.natom()):; text += """""" %8s%4s """""" % (self.symbol(i), """" if self.Z(i) else ""(Gh)""); for j in range(3):; text += """""" %17.12f"""""" % (self.xyz(i, j)); text += ""\n""; text += ""\n""; else:; text += "" No atoms in this molecule.\n""; print text; # TODO outfile. [docs] def print_out_in_angstrom(self):; """"""Print the molecule in Angstroms. Same as :py:func:`print_out` only always in Angstroms.; (method name in libmints is print_in_angstrom). """"""; text = """"; if self.natom():; if self.pg:; text += """""" Molecular point group: %s\n"""""" % (self.pg.symbol()); # if self.full_pg: TODO symmetry; # text += """""" Full point group: %s\n\n"""""" % (self.full_point_group()) TODO symmetry; text += """""" Geometry (in %s), charge = %d, multiplicity = %d:\n\n"""""" % \; ('Angstrom', self.molecular_charge(), self.multiplicity()); text += """""" Center X Y Z \n""""""; text += """""" ------------ ----------------- ----------------- -----------------\n"""""". for i in range(self.natom()):; text += """""" %8s%4s """""" % (self.symbol(i), """" if self.Z(i) else ""(Gh)""); for j in range(3):; text += """""" %17.12f"""""" % (self.xyz(i, j) * psi_bohr2angstroms); text += ""\n""; text += ""\n""; else:; text += "" No atoms in this molecule.\n""; print text; # TODO outfile. [docs] def print_full(self):; """"""Print full atom list. Same as :py:func:`print_out` only displays dummy atoms. """"""; text = """"; if self.natom():; if self.pg:; text += """""" Molecular point group: %s\n"""""" % (self.pg.symbol()); # if self.full_pg: TODO symmetry; # text += """""" Full point group: %s\n\n"""""" % (self.full_point_group()) TODO symmetry; text += """""" Geometry (in %s), charge = %d, multiplicity = %d:\n\n"""""" % \; (self.units(), self.molecular_charge(), self.multiplicity()); text += """,MatchSource.WIKI,psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html:28203,Energy Efficiency,charge,charge,28203,"ymmetry; # text += """""" Full point group: %s\n\n"""""" % (self.full_point_group()) TODO symmetry; text += """""" Geometry (in %s), charge = %d, multiplicity = %d:\n\n"""""" % \; ('Angstrom', self.molecular_charge(), self.multiplicity()); text += """""" Center X Y Z \n""""""; text += """""" ------------ ----------------- ----------------- -----------------\n"""""". for i in range(self.natom()):; text += """""" %8s%4s """""" % (self.symbol(i), """" if self.Z(i) else ""(Gh)""); for j in range(3):; text += """""" %17.12f"""""" % (self.xyz(i, j) * psi_bohr2angstroms); text += ""\n""; text += ""\n""; else:; text += "" No atoms in this molecule.\n""; print text; # TODO outfile. [docs] def print_full(self):; """"""Print full atom list. Same as :py:func:`print_out` only displays dummy atoms. """"""; text = """"; if self.natom():; if self.pg:; text += """""" Molecular point group: %s\n"""""" % (self.pg.symbol()); # if self.full_pg: TODO symmetry; # text += """""" Full point group: %s\n\n"""""" % (self.full_point_group()) TODO symmetry; text += """""" Geometry (in %s), charge = %d, multiplicity = %d:\n\n"""""" % \; (self.units(), self.molecular_charge(), self.multiplicity()); text += """""" Center X Y Z \n""""""; text += """""" ------------ ----------------- ----------------- -----------------\n"""""". for i in range(self.nallatom()):; geom = self.full_atoms[i].compute(); text += """""" %8s%4s """""" % (self.fsymbol(i), """" if self.fZ(i) else ""(Gh)""); for j in range(3):; text += """""" %17.12f"""""" % (geom[j]); text += ""\n""; text += ""\n""; else:; text += "" No atoms in this molecule.\n""; print text; # TODO outfile. [docs] def print_in_input_format(self):; """"""Print the molecule in the same format that the user provided.; """"""; text = """"; if self.nallatom():; text += "" Geometry (in %s), charge = %d, multiplicity = %d:\n\n"" % \; (""Angstrom"" if self.units() == 'Angstrom' else ""Bohr"",; self.molecular_charge(), self.multiplicity()); for i in range(self.nallatom()):; if self.fZ(i) or self.fsymbol(i) == ""X"":; text += "" %-8s"" % (self.fsymbol(i)); else:; text += "" %-8s"" % (""Gh("" + s",MatchSource.WIKI,psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html:28903,Energy Efficiency,charge,charge,28903,"` only displays dummy atoms. """"""; text = """"; if self.natom():; if self.pg:; text += """""" Molecular point group: %s\n"""""" % (self.pg.symbol()); # if self.full_pg: TODO symmetry; # text += """""" Full point group: %s\n\n"""""" % (self.full_point_group()) TODO symmetry; text += """""" Geometry (in %s), charge = %d, multiplicity = %d:\n\n"""""" % \; (self.units(), self.molecular_charge(), self.multiplicity()); text += """""" Center X Y Z \n""""""; text += """""" ------------ ----------------- ----------------- -----------------\n"""""". for i in range(self.nallatom()):; geom = self.full_atoms[i].compute(); text += """""" %8s%4s """""" % (self.fsymbol(i), """" if self.fZ(i) else ""(Gh)""); for j in range(3):; text += """""" %17.12f"""""" % (geom[j]); text += ""\n""; text += ""\n""; else:; text += "" No atoms in this molecule.\n""; print text; # TODO outfile. [docs] def print_in_input_format(self):; """"""Print the molecule in the same format that the user provided.; """"""; text = """"; if self.nallatom():; text += "" Geometry (in %s), charge = %d, multiplicity = %d:\n\n"" % \; (""Angstrom"" if self.units() == 'Angstrom' else ""Bohr"",; self.molecular_charge(), self.multiplicity()); for i in range(self.nallatom()):; if self.fZ(i) or self.fsymbol(i) == ""X"":; text += "" %-8s"" % (self.fsymbol(i)); else:; text += "" %-8s"" % (""Gh("" + self.fsymbol(i) + "")""); text += self.full_atoms[i].print_in_input_format(); text += ""\n""; if len(self.geometry_variables):; for vb, val in self.geometry_variables.items():; text += """""" %-10s=%16.10f\n"""""" % (vb, val); text += ""\n"". print text; # TODO outfile. [docs] def everything(self):; """"""Quick print of class data""""""; text = """""" ==> qcdb Molecule %s <==\n\n"""""" % (self.name()); text += """""" Natom %d\t\tNallatom %d\n"""""" % (self.natom(), self.nallatom()); text += """""" charge %d\t\tspecified? %s\n"""""" % (self.molecular_charge(), self.charge_specified()); text += """""" multiplicity %d\t\tspecified? %s\n"""""" % (self.multiplicity(), self.multiplicity_specified()); text += """""" units %s\tconversion %f\n"""""" % (self.units(),",MatchSource.WIKI,psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html:29665,Energy Efficiency,charge,charge,29665,"No atoms in this molecule.\n""; print text; # TODO outfile. [docs] def print_in_input_format(self):; """"""Print the molecule in the same format that the user provided.; """"""; text = """"; if self.nallatom():; text += "" Geometry (in %s), charge = %d, multiplicity = %d:\n\n"" % \; (""Angstrom"" if self.units() == 'Angstrom' else ""Bohr"",; self.molecular_charge(), self.multiplicity()); for i in range(self.nallatom()):; if self.fZ(i) or self.fsymbol(i) == ""X"":; text += "" %-8s"" % (self.fsymbol(i)); else:; text += "" %-8s"" % (""Gh("" + self.fsymbol(i) + "")""); text += self.full_atoms[i].print_in_input_format(); text += ""\n""; if len(self.geometry_variables):; for vb, val in self.geometry_variables.items():; text += """""" %-10s=%16.10f\n"""""" % (vb, val); text += ""\n"". print text; # TODO outfile. [docs] def everything(self):; """"""Quick print of class data""""""; text = """""" ==> qcdb Molecule %s <==\n\n"""""" % (self.name()); text += """""" Natom %d\t\tNallatom %d\n"""""" % (self.natom(), self.nallatom()); text += """""" charge %d\t\tspecified? %s\n"""""" % (self.molecular_charge(), self.charge_specified()); text += """""" multiplicity %d\t\tspecified? %s\n"""""" % (self.multiplicity(), self.multiplicity_specified()); text += """""" units %s\tconversion %f\n"""""" % (self.units(), self.input_units_to_au); text += """""" DOcom? %s\t\tDONTreorient? %s\n"""""" % (self.PYmove_to_com, self.orientation_fixed()); text += """""" reinterpret? %s\t\tlock_frame? %s\n"""""" % (self.PYreinterpret_coordentries, self.lock_frame); text += """""" input symm %s\n"""""" % (self.symmetry_from_input()); text += """""" Nfragments %d\t\tNactive %d\n"""""" % (self.nfragments(), self.nactive_fragments()); text += """""" zmat? %s\n"""""" % (self.has_zmatrix()); print text. [docs] def create_psi4_string_from_molecule(self):; """"""Regenerates a input file molecule specification string from the; current state of the Molecule. Contains geometry info,; fragmentation, charges and multiplicities, and any frame; restriction.; """"""; text = """"; if self.nallatom():. # append units and any othe",MatchSource.WIKI,psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html:30552,Energy Efficiency,charge,charges,30552," % (self.name()); text += """""" Natom %d\t\tNallatom %d\n"""""" % (self.natom(), self.nallatom()); text += """""" charge %d\t\tspecified? %s\n"""""" % (self.molecular_charge(), self.charge_specified()); text += """""" multiplicity %d\t\tspecified? %s\n"""""" % (self.multiplicity(), self.multiplicity_specified()); text += """""" units %s\tconversion %f\n"""""" % (self.units(), self.input_units_to_au); text += """""" DOcom? %s\t\tDONTreorient? %s\n"""""" % (self.PYmove_to_com, self.orientation_fixed()); text += """""" reinterpret? %s\t\tlock_frame? %s\n"""""" % (self.PYreinterpret_coordentries, self.lock_frame); text += """""" input symm %s\n"""""" % (self.symmetry_from_input()); text += """""" Nfragments %d\t\tNactive %d\n"""""" % (self.nfragments(), self.nactive_fragments()); text += """""" zmat? %s\n"""""" % (self.has_zmatrix()); print text. [docs] def create_psi4_string_from_molecule(self):; """"""Regenerates a input file molecule specification string from the; current state of the Molecule. Contains geometry info,; fragmentation, charges and multiplicities, and any frame; restriction.; """"""; text = """"; if self.nallatom():. # append units and any other non-default molecule keywords; text += "" units %-s\n"" % (""Angstrom"" if self.units() == 'Angstrom' else ""Bohr""); if not self.PYmove_to_com:; text += "" no_com\n""; if self.PYfix_orientation:; text += "" no_reorient\n"". # append atoms and coordentries and fragment separators with charge and multiplicity; Pfr = 0; for fr in range(self.nfragments()):; if self.fragment_types[fr] == 'Absent' and not self.has_zmatrix():; continue; text += ""%s %s%d %d\n"" % (; """" if Pfr == 0 else "" --\n"",; ""#"" if self.fragment_types[fr] == 'Ghost' or self.fragment_types[fr] == 'Absent' else """",; self.fragment_charges[fr], self.fragment_multiplicities[fr]); Pfr += 1; for at in range(self.fragments[fr][0], self.fragments[fr][1] + 1):; if self.fragment_types[fr] == 'Absent':; text += "" %-8s"" % (""X""); elif self.fZ(at) or self.fsymbol(at) == ""X"":; text += "" %-8s"" % (self.fsymbol(at)); else:; text += "" %-8",MatchSource.WIKI,psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html:30951,Energy Efficiency,charge,charge,30951," """""" DOcom? %s\t\tDONTreorient? %s\n"""""" % (self.PYmove_to_com, self.orientation_fixed()); text += """""" reinterpret? %s\t\tlock_frame? %s\n"""""" % (self.PYreinterpret_coordentries, self.lock_frame); text += """""" input symm %s\n"""""" % (self.symmetry_from_input()); text += """""" Nfragments %d\t\tNactive %d\n"""""" % (self.nfragments(), self.nactive_fragments()); text += """""" zmat? %s\n"""""" % (self.has_zmatrix()); print text. [docs] def create_psi4_string_from_molecule(self):; """"""Regenerates a input file molecule specification string from the; current state of the Molecule. Contains geometry info,; fragmentation, charges and multiplicities, and any frame; restriction.; """"""; text = """"; if self.nallatom():. # append units and any other non-default molecule keywords; text += "" units %-s\n"" % (""Angstrom"" if self.units() == 'Angstrom' else ""Bohr""); if not self.PYmove_to_com:; text += "" no_com\n""; if self.PYfix_orientation:; text += "" no_reorient\n"". # append atoms and coordentries and fragment separators with charge and multiplicity; Pfr = 0; for fr in range(self.nfragments()):; if self.fragment_types[fr] == 'Absent' and not self.has_zmatrix():; continue; text += ""%s %s%d %d\n"" % (; """" if Pfr == 0 else "" --\n"",; ""#"" if self.fragment_types[fr] == 'Ghost' or self.fragment_types[fr] == 'Absent' else """",; self.fragment_charges[fr], self.fragment_multiplicities[fr]); Pfr += 1; for at in range(self.fragments[fr][0], self.fragments[fr][1] + 1):; if self.fragment_types[fr] == 'Absent':; text += "" %-8s"" % (""X""); elif self.fZ(at) or self.fsymbol(at) == ""X"":; text += "" %-8s"" % (self.fsymbol(at)); else:; text += "" %-8s"" % (""Gh("" + self.fsymbol(at) + "")""); text += "" %s"" % (self.full_atoms[at].print_in_input_format()); text += ""\n"". # append any coordinate variables; if len(self.geometry_variables):; for vb, val in self.geometry_variables.items():; text += """""" %-10s=%16.10f\n"""""" % (vb, val); text += ""\n"". return text. # <<< Involved Methods for Coordinates >>>. [docs] def get_coord_value(self, vstr):;",MatchSource.WIKI,psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html:32775,Energy Efficiency,charge,charge,32775,"bles.items():; text += """""" %-10s=%16.10f\n"""""" % (vb, val); text += ""\n"". return text. # <<< Involved Methods for Coordinates >>>. [docs] def get_coord_value(self, vstr):; """"""Attempts to interpret a string as a double, if not it assumes it's a variable. """"""; vstr = vstr.upper(); realNumber = re.compile(r""""""[-+]?(?:(?:\d*\.\d+)|(?:\d+\.?))(?:[Ee][+-]?\d+)?"""""", re.VERBOSE). # handle number values; if realNumber.match(vstr):; return NumberValue(float(vstr)). # handle variable values, whether defined or not; else:; if vstr == 'TDA':; self.geometry_variables[vstr] = 360.0 * math.atan(math.sqrt(2)) / math.pi. # handle negative variable values (ignore leading '-' and return minus the value); if vstr[0] == '-':; self.all_variables.append(vstr[1:]); return VariableValue(vstr[1:], self.geometry_variables, True). # handle normal variable values; else:; self.all_variables.append(vstr); return VariableValue(vstr, self.geometry_variables). [docs] def add_atom(self, Z, x, y, z, label="""", mass=0.0, charge=0.0, lineno=-1):; """"""Add an atom to the molecule; *Z* atomic number; *x* cartesian coordinate; *y* cartesian coordinate; *z* cartesian coordinate; *symb* atomic symbol to use; *mass* mass to use if non standard; *charge* charge to use if non standard; *lineno* line number when taken from a string. """"""; self.lock_frame = False. if self.atom_at_position([x, y, z]) == -1:; # Dummies go to full_atoms, ghosts need to go to both.; self.full_atoms.append(CartesianEntry(self.nallatom(), Z, charge, mass, label, label, \; NumberValue(x), NumberValue(y), NumberValue(z))); if label.upper() != 'X':; self.atoms.append(self.full_atoms[-1]); else:; raise ValidationError(""Molecule::add_atom: Adding atom on top of an existing atom.""). [docs] def atom_entry(self, atom):; """"""Returns the CoordEntry for an atom.""""""; return self.atoms[atom]. [docs] def atom_at_position(self, b, tol=0.05):; """"""Tests to see of an atom is at the passed position *b* in Bohr with a tolerance *tol*. >>> print H2OH2O.atom_at_po",MatchSource.WIKI,psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html:32995,Energy Efficiency,charge,charge,32995,"ue(self, vstr):; """"""Attempts to interpret a string as a double, if not it assumes it's a variable. """"""; vstr = vstr.upper(); realNumber = re.compile(r""""""[-+]?(?:(?:\d*\.\d+)|(?:\d+\.?))(?:[Ee][+-]?\d+)?"""""", re.VERBOSE). # handle number values; if realNumber.match(vstr):; return NumberValue(float(vstr)). # handle variable values, whether defined or not; else:; if vstr == 'TDA':; self.geometry_variables[vstr] = 360.0 * math.atan(math.sqrt(2)) / math.pi. # handle negative variable values (ignore leading '-' and return minus the value); if vstr[0] == '-':; self.all_variables.append(vstr[1:]); return VariableValue(vstr[1:], self.geometry_variables, True). # handle normal variable values; else:; self.all_variables.append(vstr); return VariableValue(vstr, self.geometry_variables). [docs] def add_atom(self, Z, x, y, z, label="""", mass=0.0, charge=0.0, lineno=-1):; """"""Add an atom to the molecule; *Z* atomic number; *x* cartesian coordinate; *y* cartesian coordinate; *z* cartesian coordinate; *symb* atomic symbol to use; *mass* mass to use if non standard; *charge* charge to use if non standard; *lineno* line number when taken from a string. """"""; self.lock_frame = False. if self.atom_at_position([x, y, z]) == -1:; # Dummies go to full_atoms, ghosts need to go to both.; self.full_atoms.append(CartesianEntry(self.nallatom(), Z, charge, mass, label, label, \; NumberValue(x), NumberValue(y), NumberValue(z))); if label.upper() != 'X':; self.atoms.append(self.full_atoms[-1]); else:; raise ValidationError(""Molecule::add_atom: Adding atom on top of an existing atom.""). [docs] def atom_entry(self, atom):; """"""Returns the CoordEntry for an atom.""""""; return self.atoms[atom]. [docs] def atom_at_position(self, b, tol=0.05):; """"""Tests to see of an atom is at the passed position *b* in Bohr with a tolerance *tol*. >>> print H2OH2O.atom_at_position([1.35*(1.0/psi_bohr2angstroms), 0.10*(1.0/psi_bohr2angstroms), 0.0*(1.0/psi_bohr2angstroms)]); 3. """"""; if len(b) != 3:; raise ValidationError('ERRO",MatchSource.WIKI,psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html:33003,Energy Efficiency,charge,charge,33003,"ue(self, vstr):; """"""Attempts to interpret a string as a double, if not it assumes it's a variable. """"""; vstr = vstr.upper(); realNumber = re.compile(r""""""[-+]?(?:(?:\d*\.\d+)|(?:\d+\.?))(?:[Ee][+-]?\d+)?"""""", re.VERBOSE). # handle number values; if realNumber.match(vstr):; return NumberValue(float(vstr)). # handle variable values, whether defined or not; else:; if vstr == 'TDA':; self.geometry_variables[vstr] = 360.0 * math.atan(math.sqrt(2)) / math.pi. # handle negative variable values (ignore leading '-' and return minus the value); if vstr[0] == '-':; self.all_variables.append(vstr[1:]); return VariableValue(vstr[1:], self.geometry_variables, True). # handle normal variable values; else:; self.all_variables.append(vstr); return VariableValue(vstr, self.geometry_variables). [docs] def add_atom(self, Z, x, y, z, label="""", mass=0.0, charge=0.0, lineno=-1):; """"""Add an atom to the molecule; *Z* atomic number; *x* cartesian coordinate; *y* cartesian coordinate; *z* cartesian coordinate; *symb* atomic symbol to use; *mass* mass to use if non standard; *charge* charge to use if non standard; *lineno* line number when taken from a string. """"""; self.lock_frame = False. if self.atom_at_position([x, y, z]) == -1:; # Dummies go to full_atoms, ghosts need to go to both.; self.full_atoms.append(CartesianEntry(self.nallatom(), Z, charge, mass, label, label, \; NumberValue(x), NumberValue(y), NumberValue(z))); if label.upper() != 'X':; self.atoms.append(self.full_atoms[-1]); else:; raise ValidationError(""Molecule::add_atom: Adding atom on top of an existing atom.""). [docs] def atom_entry(self, atom):; """"""Returns the CoordEntry for an atom.""""""; return self.atoms[atom]. [docs] def atom_at_position(self, b, tol=0.05):; """"""Tests to see of an atom is at the passed position *b* in Bohr with a tolerance *tol*. >>> print H2OH2O.atom_at_position([1.35*(1.0/psi_bohr2angstroms), 0.10*(1.0/psi_bohr2angstroms), 0.0*(1.0/psi_bohr2angstroms)]); 3. """"""; if len(b) != 3:; raise ValidationError('ERRO",MatchSource.WIKI,psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html:33269,Energy Efficiency,charge,charge,33269,"TDA':; self.geometry_variables[vstr] = 360.0 * math.atan(math.sqrt(2)) / math.pi. # handle negative variable values (ignore leading '-' and return minus the value); if vstr[0] == '-':; self.all_variables.append(vstr[1:]); return VariableValue(vstr[1:], self.geometry_variables, True). # handle normal variable values; else:; self.all_variables.append(vstr); return VariableValue(vstr, self.geometry_variables). [docs] def add_atom(self, Z, x, y, z, label="""", mass=0.0, charge=0.0, lineno=-1):; """"""Add an atom to the molecule; *Z* atomic number; *x* cartesian coordinate; *y* cartesian coordinate; *z* cartesian coordinate; *symb* atomic symbol to use; *mass* mass to use if non standard; *charge* charge to use if non standard; *lineno* line number when taken from a string. """"""; self.lock_frame = False. if self.atom_at_position([x, y, z]) == -1:; # Dummies go to full_atoms, ghosts need to go to both.; self.full_atoms.append(CartesianEntry(self.nallatom(), Z, charge, mass, label, label, \; NumberValue(x), NumberValue(y), NumberValue(z))); if label.upper() != 'X':; self.atoms.append(self.full_atoms[-1]); else:; raise ValidationError(""Molecule::add_atom: Adding atom on top of an existing atom.""). [docs] def atom_entry(self, atom):; """"""Returns the CoordEntry for an atom.""""""; return self.atoms[atom]. [docs] def atom_at_position(self, b, tol=0.05):; """"""Tests to see of an atom is at the passed position *b* in Bohr with a tolerance *tol*. >>> print H2OH2O.atom_at_position([1.35*(1.0/psi_bohr2angstroms), 0.10*(1.0/psi_bohr2angstroms), 0.0*(1.0/psi_bohr2angstroms)]); 3. """"""; if len(b) != 3:; raise ValidationError('ERROR: atom_at_position() requires as argument a vector of length 3\n'). for at in range(self.natom()):; a = self.xyz(at); if distance(b, a) < tol:; return at; return -1. [docs] def is_variable(self, vstr):; """"""Checks to see if the variable str is in the list, returns; true if it is, and returns false if not. >>> H2OH2O.is_variable('R'); False. """"""; return True if vstr.upper()",MatchSource.WIKI,psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html:46804,Energy Efficiency,energy,energy,46804,"y_frame looks for the highest point group so that we can align; # the molecule according to its actual symmetry, rather than the symmetry; # the the user might have provided.; frame = self.symmetry_frame(); self.rotate_full(frame); #print ""after rotate:""; #self.print_full(). # Recompute point group of the molecule, so the symmetry info is updated to the new frame; # TODO self.set_point_group(self.find_point_group()); # TODO self.set_full_point_group(). # Disabling symmetrize for now if orientation is fixed, as it is not; # correct. We may want to fix this in the future, but in some cases of; # finite-differences the set geometry is not totally symmetric anyway.; # Symmetrize the molecule to remove any noise; # TODO self.symmetrize(); #print ""after symmetry:""; #self.print_full(). self.lock_frame = True. # <<< Methods for Miscellaneous >>>. [docs] def clear(self):; """"""Zero it out.""""""; self.lock_frame = False; self.atoms = []; self.full_atoms = []. [docs] def nuclear_repulsion_energy(self):; """"""Computes nuclear repulsion energy. >>> print H2OH2O.nuclear_repulsion_energy(); 36.6628478528. """"""; e = 0.0; for at1 in range(self.natom()):; for at2 in range(self.natom()):; if at2 < at1:; Zi = self.Z(at1); Zj = self.Z(at2); dist = distance(self.xyz(at1), self.xyz(at2)); e += Zi * Zj / dist; return e. [docs] def nuclear_repulsion_energy_deriv1(self):; """"""Computes nuclear repulsion energy derivatives. >>> print H2OH2O.nuclear_repulsion_energy_deriv1(); [[3.9020946901323774, 2.76201566471991, 0.0], [1.3172905807089021, -2.3486366050337293, 0.0], [-1.8107598525022435, -0.32511212499256564, 0.0], [-1.217656141385739, -2.6120090867576717, 0.0], [-1.0954846384766488, 1.2618710760320282, 2.1130743287465603], [-1.0954846384766488, 1.2618710760320282, -2.1130743287465603]]. """"""; de = []; for i in range(self.natom()):; entry = [0.0, 0.0, 0.0]; for j in range(self.natom()):; if i != j:; temp = distance(self.xyz(i), self.xyz(j)) ** 3.0; Zi = self.Z(i); Zj = self.Z(j); entry[0] -= (self.x(i",MatchSource.WIKI,psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html:47162,Energy Efficiency,energy,energy,47162,"frame; # TODO self.set_point_group(self.find_point_group()); # TODO self.set_full_point_group(). # Disabling symmetrize for now if orientation is fixed, as it is not; # correct. We may want to fix this in the future, but in some cases of; # finite-differences the set geometry is not totally symmetric anyway.; # Symmetrize the molecule to remove any noise; # TODO self.symmetrize(); #print ""after symmetry:""; #self.print_full(). self.lock_frame = True. # <<< Methods for Miscellaneous >>>. [docs] def clear(self):; """"""Zero it out.""""""; self.lock_frame = False; self.atoms = []; self.full_atoms = []. [docs] def nuclear_repulsion_energy(self):; """"""Computes nuclear repulsion energy. >>> print H2OH2O.nuclear_repulsion_energy(); 36.6628478528. """"""; e = 0.0; for at1 in range(self.natom()):; for at2 in range(self.natom()):; if at2 < at1:; Zi = self.Z(at1); Zj = self.Z(at2); dist = distance(self.xyz(at1), self.xyz(at2)); e += Zi * Zj / dist; return e. [docs] def nuclear_repulsion_energy_deriv1(self):; """"""Computes nuclear repulsion energy derivatives. >>> print H2OH2O.nuclear_repulsion_energy_deriv1(); [[3.9020946901323774, 2.76201566471991, 0.0], [1.3172905807089021, -2.3486366050337293, 0.0], [-1.8107598525022435, -0.32511212499256564, 0.0], [-1.217656141385739, -2.6120090867576717, 0.0], [-1.0954846384766488, 1.2618710760320282, 2.1130743287465603], [-1.0954846384766488, 1.2618710760320282, -2.1130743287465603]]. """"""; de = []; for i in range(self.natom()):; entry = [0.0, 0.0, 0.0]; for j in range(self.natom()):; if i != j:; temp = distance(self.xyz(i), self.xyz(j)) ** 3.0; Zi = self.Z(i); Zj = self.Z(j); entry[0] -= (self.x(i) - self.x(j)) * Zi * Zj / temp; entry[1] -= (self.y(i) - self.y(j)) * Zi * Zj / temp; entry[2] -= (self.z(i) - self.z(j)) * Zi * Zj / temp; de.append(entry); return de. [docs] def nuclear_repulsion_energy_deriv2(self):; """""" **NYI** Computes nuclear repulsion energy second derivatives""""""; raise FeatureNotImplemented('Molecule::nuclear_repulsion_energy_deriv2'",MatchSource.WIKI,psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html:48030,Energy Efficiency,energy,energy,48030,"yz(at2)); e += Zi * Zj / dist; return e. [docs] def nuclear_repulsion_energy_deriv1(self):; """"""Computes nuclear repulsion energy derivatives. >>> print H2OH2O.nuclear_repulsion_energy_deriv1(); [[3.9020946901323774, 2.76201566471991, 0.0], [1.3172905807089021, -2.3486366050337293, 0.0], [-1.8107598525022435, -0.32511212499256564, 0.0], [-1.217656141385739, -2.6120090867576717, 0.0], [-1.0954846384766488, 1.2618710760320282, 2.1130743287465603], [-1.0954846384766488, 1.2618710760320282, -2.1130743287465603]]. """"""; de = []; for i in range(self.natom()):; entry = [0.0, 0.0, 0.0]; for j in range(self.natom()):; if i != j:; temp = distance(self.xyz(i), self.xyz(j)) ** 3.0; Zi = self.Z(i); Zj = self.Z(j); entry[0] -= (self.x(i) - self.x(j)) * Zi * Zj / temp; entry[1] -= (self.y(i) - self.y(j)) * Zi * Zj / temp; entry[2] -= (self.z(i) - self.z(j)) * Zi * Zj / temp; de.append(entry); return de. [docs] def nuclear_repulsion_energy_deriv2(self):; """""" **NYI** Computes nuclear repulsion energy second derivatives""""""; raise FeatureNotImplemented('Molecule::nuclear_repulsion_energy_deriv2') # FINAL. [docs] def set_basis_all_atoms(self, name, type=""BASIS""):; """""" **NYI** Assigns basis *name* to all atoms.""""""; raise FeatureNotImplemented('Molecule::set_basis_all_atoms') # FINAL. [docs] def set_basis_by_symbol(self, symbol, name, type=""BASIS""):; """""" **NYI** Assigns basis *name* to all *symbol* atoms.""""""; raise FeatureNotImplemented('Molecule::set_basis_by_symbol') # FINAL. [docs] def set_basis_by_number(self, number, name, type=""BASIS""):; """""" **NYI** Assigns basis *name* to atom number *number* (1-indexed, includes dummies).""""""; raise FeatureNotImplemented('Molecule::set_basis_by_number') # FINAL. [docs] def set_basis_by_label(self, label, name, type=""BASIS""):; """""" **NYI** Assigns basis *name* to all atoms with *label*.""""""; raise FeatureNotImplemented('Molecule::set_basis_by_label') # FINAL. [docs] def nfrozen_core(self, depth=False):; """"""Number of frozen core for molecule given freez",MatchSource.WIKI,psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html:12469,Integrability,Wrap,Wrapper,12469,"_fragment(self, fr):; """"""Tags fragment index *fr* as composed of real atoms.""""""; self.lock_frame = False; self.fragment_types[fr - 1] = 'Real'. [docs] def set_active_fragments(self, reals):; """"""Tags the fragments in array *reals* as composed of real atoms.""""""; self.lock_frame = False; for fr in reals:; self.fragment_types[fr - 1] = 'Real'. [docs] def set_ghost_fragment(self, fr):; """"""Tags fragment index *fr* as composed of ghost atoms.""""""; self.lock_frame = False; self.fragment_types[fr - 1] = 'Ghost'. [docs] def set_ghost_fragments(self, ghosts):; """"""Tags the fragments in array *ghosts* as composed of ghost atoms.""""""; self.lock_frame = False; print 'doomed', ghosts; for fr in ghosts:; print 'killing', fr - 1; self.fragment_types[fr - 1] = 'Ghost'. [docs] def deactivate_all_fragments(self):; """"""Sets all fragments in the molecule to be inactive.""""""; self.lock_frame = False; for fr in range(self.nfragments()):; self.fragment_types[fr] = 'Absent'. [docs] def extract_subsets(self, reals, ghosts=[]):; """"""Wrapper for :py:func:`~qcdb.molecule.extract_fragments`.; See note there. This function can be used as long as not; in psi4 input file. Use extract_fragments directly, then. >>> H2OH2O.extract_subsets(2) # monomer B, unCP-corrected; >>> H2OH2O.extract_subsets(2,1) # monomer B, CP-corrected; >>> obj.extract_subsets(1,[2,3]) # monomer A, CP-corrected if obj is tri-molecular complex. """"""; return self.extract_fragments(reals, ghosts=[]). [docs] def extract_fragments(self, reals, ghosts=[]):; """"""Makes a copy of the molecule, returning a new molecule with; only certain fragment atoms present as either ghost or real atoms; *reals*: The list or int of fragments (1-indexed) that should be present in the molecule as real atoms.; *ghosts*: The list or int of fragments (1-indexed) that should be present in the molecule as ghosts.; (method name in libmints is extract_subsets. This is different; in qcdb because the psi4 input parser tries to process lines with; that term, giving rise t",MatchSource.WIKI,psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html:35998,Integrability,message,message,35998,"), val); try:; self.update_geometry(); except IncompleteAtomError:; # Update geometry might have added some atoms, delete them to be safe.; self.atoms = []; # TODO outfile. def __setattr__(self, name, value):; """"""Function to overload setting attributes to allow geometry; variable assigment as if member data. """"""; try:; if name.upper() in self.__dict__['all_variables']:; self.set_variable(name, value); else:; self.__dict__[name] = value; except KeyError:; self.__dict__[name] = value. def __getattr__(self, name):; """"""Function to overload accessing attribute contents to allow; retrivial geometry variable values as if member data. """"""; if not name in self.__dict__:; if object.__getattribute__(self, 'is_variable')(name):; return object.__getattribute__(self, 'get_variable')(name); else:; raise AttributeError; else:; return self.__dict__[name]. [docs] def get_anchor_atom(self, vstr, line):; """"""Attempts to interpret a string *vstr* as an atom specifier in; a zmatrix. Takes the current *line* for error message printing.; Returns the atom number (adjusted to zero-based counting). """"""; integerNumber = re.compile(r""(-?\d+)"", re.IGNORECASE); if integerNumber.match(vstr):; # This is just a number, return it; return int(vstr) - 1; else:; # Look to see if this string is known; for i in range(self.nallatom()):; if self.full_atoms[i].label() == vstr:; return i; raise ValidationError(""Illegal value %s in atom specification on line %s.\n"" % (vstr, line)). [docs] def geometry(self):; """"""Returns the geometry in Bohr as a N X 3 array. >>> print H2OH2O.geometry(); [[-2.930978460188563, -0.21641143673806384, 0.0], [-3.655219780069251, 1.4409218455037016, 0.0], [-1.1332252981904638, 0.0769345303220403, 0.0], [2.5523113582286716, 0.21064588230662976, 0.0], [3.175492014248769, -0.7062681346308132, -1.4334725450878665], [3.175492014248769, -0.7062681346308132, 1.4334725450878665]]. """"""; geom = []; for at in range(self.natom()):; geom.append([self.x(at), self.y(at), self.z(at)]); return geom. [d",MatchSource.WIKI,psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html:44910,Integrability,rout,routine,44910,"multiplicity = self.PYmultiplicity; self.PYmolecular_charge = 0; self.PYmultiplicity = 1. for fr in range(self.nfragments()):; if self.fragment_types[fr] == 'Absent':; continue. if self.fragment_types[fr] == 'Real':; self.PYmolecular_charge += self.fragment_charges[fr]; self.PYmultiplicity += self.fragment_multiplicities[fr] - 1. for at in range(self.fragments[fr][0], self.fragments[fr][1] + 1):; self.full_atoms[at].compute(); self.full_atoms[at].set_ghosted(self.fragment_types[fr] == 'Ghost'); if self.full_atoms[at].symbol() != 'X':; self.atoms.append(self.full_atoms[at]). # TODO: This is a hack to ensure that set_multiplicity and set_molecular_charge; # work for single-fragment molecules.; if self.nfragments() < 2:; self.PYmolecular_charge = temp_charge; self.PYmultiplicity = temp_multiplicity. [docs] def update_geometry(self):; """"""Updates the geometry, by (re)interpreting the string used to; create the molecule, and the current values of the variables.; The atoms list is cleared, and then rebuilt by this routine.; This function must be called after first instantiation of Molecule. >>> H2 = qcdb.Molecule(""H\\nH 1 0.74\\n""); >>> print H2.natom(); 0; >>> H2.update_geometry(); >>> print H2.natom(); 2. """"""; if self.nfragments() == 0:; raise ValidationError(""Molecule::update_geometry: There are no fragments in this molecule.""). # Idempotence condition; if self.lock_frame:; return. #print ""beginning update_geometry:""; #self.print_full(); if self.PYreinterpret_coordentries:; self.reinterpret_coordentries(); #print ""after reinterpret_coordentries:""; #self.print_full(). if self.PYmove_to_com:; self.move_to_com(); #print ""after com:""; #self.print_full(). # If the no_reorient command was given, don't reorient; if not self.PYfix_orientation:; # Now we need to rotate the geometry to its symmetry frame; # to align the axes correctly for the point group; # symmetry_frame looks for the highest point group so that we can align; # the molecule according to its actual symmetry, rath",MatchSource.WIKI,psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html:3273,Modifiability,variab,variables,3273,""", ""Ci"", \; ""Cn"", ""Cnv"", ""Cnh"", ""Sn"", ""Dn"", ""Dnd"", ""Dnh"", ""Td"", ""Oh"", ""Ih""]. def __init__(self, psi4molstr=None):; """"""Initialize Molecule object from string in psi4 format"""""". # <<< Basic Molecule Information >>>. # Molecule (or fragment) name; self.PYname = 'default'; # The molecular charge; self.PYmolecular_charge = 0; # Whether the charge was given by the user UNUSED; self.PYcharge_specified = False; # The multiplicity (defined as 2Ms + 1); self.PYmultiplicity = 1; # Whether the multiplicity was specified by the user UNUSED; self.PYmultiplicity_specified = False; # The units used to define the geometry; self.PYunits = 'Angstrom'; # The conversion factor to take input units to Bohr; self.input_units_to_au = 1.0 / psi_bohr2angstroms; # Whether this molecule has at least one zmatrix entry; self.zmat = False. # <<< Coordinates >>>. # Atom info vector (no knowledge of dummy atoms); self.atoms = []; # Atom info vector (includes dummy atoms); self.full_atoms = []; # A list of all variables known, whether they have been set or not.; self.all_variables = []; # A listing of the variables used to define the geometries; self.geometry_variables = {}. # <<< Fragmentation >>>. # The list of atom ranges defining each fragment from parent molecule; self.fragments = []; # A list describing how to handle each fragment; self.fragment_types = []; # The charge of each fragment; self.fragment_charges = []; # The multiplicity of each fragment; self.fragment_multiplicities = []. # <<< Frame >>>. # Move to center of mass or not?; self.PYmove_to_com = True; # Reorient or not? UNUSED; self.PYfix_orientation = False; # Reinterpret the coord entries or not (Default is true, except for findif); self.PYreinterpret_coordentries = True; # Nilpotence boolean (flagged upon first determination of symmetry frame,; # reset each time a substantiative change is made); self.lock_frame = False. # <<< Symmetry >>>. # Point group to use with this molecule UNUSED; self.pg = None; # Full point group UNUSED; s",MatchSource.WIKI,psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html:3370,Modifiability,variab,variables,3370,"elf, psi4molstr=None):; """"""Initialize Molecule object from string in psi4 format"""""". # <<< Basic Molecule Information >>>. # Molecule (or fragment) name; self.PYname = 'default'; # The molecular charge; self.PYmolecular_charge = 0; # Whether the charge was given by the user UNUSED; self.PYcharge_specified = False; # The multiplicity (defined as 2Ms + 1); self.PYmultiplicity = 1; # Whether the multiplicity was specified by the user UNUSED; self.PYmultiplicity_specified = False; # The units used to define the geometry; self.PYunits = 'Angstrom'; # The conversion factor to take input units to Bohr; self.input_units_to_au = 1.0 / psi_bohr2angstroms; # Whether this molecule has at least one zmatrix entry; self.zmat = False. # <<< Coordinates >>>. # Atom info vector (no knowledge of dummy atoms); self.atoms = []; # Atom info vector (includes dummy atoms); self.full_atoms = []; # A list of all variables known, whether they have been set or not.; self.all_variables = []; # A listing of the variables used to define the geometries; self.geometry_variables = {}. # <<< Fragmentation >>>. # The list of atom ranges defining each fragment from parent molecule; self.fragments = []; # A list describing how to handle each fragment; self.fragment_types = []; # The charge of each fragment; self.fragment_charges = []; # The multiplicity of each fragment; self.fragment_multiplicities = []. # <<< Frame >>>. # Move to center of mass or not?; self.PYmove_to_com = True; # Reorient or not? UNUSED; self.PYfix_orientation = False; # Reinterpret the coord entries or not (Default is true, except for findif); self.PYreinterpret_coordentries = True; # Nilpotence boolean (flagged upon first determination of symmetry frame,; # reset each time a substantiative change is made); self.lock_frame = False. # <<< Symmetry >>>. # Point group to use with this molecule UNUSED; self.pg = None; # Full point group UNUSED; self.full_pg = 'PG_C1'; # n of the highest rotational axis Cn UNUSED; self.full_pg_n = 1; # S",MatchSource.WIKI,psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html:15000,Modifiability,variab,variable,15000,"ubset.set_active_fragment(fr + 1) # the active fragment code subtracts 1; for fr in lghosts:; subset.set_ghost_fragment(fr + 1) # the ghost fragment code subtracts 1. subset.update_geometry(); return subset. # <<< Methods for Construction >>>. [docs] def create_molecule_from_string(self, text):; """"""Given a string *geom* of psi4-style geometry specification; (including newlines to separate lines), builds a new molecule.; Called from constructor. """"""; comment = re.compile(r'^\s*#'); blank = re.compile(r'^\s*$'); bohr = re.compile(r'^\s*units?[\s=]+(bohr|au|a.u.)\s*$', re.IGNORECASE); ang = re.compile(r'^\s*units?[\s=]+(ang|angstrom)\s*$', re.IGNORECASE); orient = re.compile(r'^\s*(no_reorient|noreorient)\s*$', re.IGNORECASE); com = re.compile(r'^\s*(no_com|nocom)\s*$', re.IGNORECASE); symmetry = re.compile(r'^\s*symmetry[\s=]+(\w+)\s*$', re.IGNORECASE); atom = re.compile(r'^\s*(@?[A-Z]{1,2})\s*', re.IGNORECASE); cgmp = re.compile(r'^\s*(-?\d+)\s+(\d+)\s*$'); frag = re.compile(r'^\s*--\s*$'); variable = re.compile(r'^\s*(\w+)\s*=\s*(-?\d+\.\d+|-?\d+\.|-?\.\d+|-?\d+|tda)\s*$', re.IGNORECASE); ghost = re.compile(r'@(.*)|Gh\((.*)\)', re.IGNORECASE). lines = re.split('\n', text); glines = []; ifrag = 0. for line in lines:. # handle comments; if comment.match(line) or blank.match(line):; pass. # handle units; elif ang.match(line):; self.set_units('Angstrom'); self.input_units_to_au = 1.0 / psi_bohr2angstroms; elif bohr.match(line):; self.set_units('Bohr'); self.input_units_to_au = 1.0. # handle no_reorient; elif orient.match(line):; self.fix_orientation(True). # handle no_com; elif com.match(line):; self.PYmove_to_com = False. # handle symmetry; elif symmetry.match(line):; tempSymm = symmetry.match(line).group(1); temp2 = re.sub('[23456789]', 'n', tempSymm).upper(); if temp2 in (item.upper() for item in self.FullPointGroupList):; self.PYsymmetry_from_input = tempSymm. # handle variables; elif variable.match(line):; vname = variable.match(line).group(1).upper(); vval = float",MatchSource.WIKI,psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html:15897,Modifiability,variab,variables,15897,"e.IGNORECASE); cgmp = re.compile(r'^\s*(-?\d+)\s+(\d+)\s*$'); frag = re.compile(r'^\s*--\s*$'); variable = re.compile(r'^\s*(\w+)\s*=\s*(-?\d+\.\d+|-?\d+\.|-?\.\d+|-?\d+|tda)\s*$', re.IGNORECASE); ghost = re.compile(r'@(.*)|Gh\((.*)\)', re.IGNORECASE). lines = re.split('\n', text); glines = []; ifrag = 0. for line in lines:. # handle comments; if comment.match(line) or blank.match(line):; pass. # handle units; elif ang.match(line):; self.set_units('Angstrom'); self.input_units_to_au = 1.0 / psi_bohr2angstroms; elif bohr.match(line):; self.set_units('Bohr'); self.input_units_to_au = 1.0. # handle no_reorient; elif orient.match(line):; self.fix_orientation(True). # handle no_com; elif com.match(line):; self.PYmove_to_com = False. # handle symmetry; elif symmetry.match(line):; tempSymm = symmetry.match(line).group(1); temp2 = re.sub('[23456789]', 'n', tempSymm).upper(); if temp2 in (item.upper() for item in self.FullPointGroupList):; self.PYsymmetry_from_input = tempSymm. # handle variables; elif variable.match(line):; vname = variable.match(line).group(1).upper(); vval = float(variable.match(line).group(2)); tda = 360.0 * math.atan(math.sqrt(2)) / math.pi; self.geometry_variables['%s' % vname] = tda if vname == 'TDA' else vval. # handle charge and multiplicity; elif cgmp.match(line):; tempCharge = int(cgmp.match(line).group(1)); tempMultiplicity = int(cgmp.match(line).group(2)). if ifrag == 0:; self.PYcharge_specified = True; self.PYmultiplicity_specified = True; self.PYmolecular_charge = tempCharge; self.PYmultiplicity = tempMultiplicity; self.fragment_charges.append(tempCharge); self.fragment_multiplicities.append(tempMultiplicity). # handle fragment markers and default fragment cgmp; elif frag.match(line):; try:; self.fragment_charges[ifrag]; except:; self.fragment_charges.append(0); self.fragment_multiplicities.append(1); ifrag += 1; glines.append(line). elif atom.match(line):; glines.append(line). # catch last default fragment cgmp; try:; self.fragment_charges[ifr",MatchSource.WIKI,psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html:15913,Modifiability,variab,variable,15913,"e.IGNORECASE); cgmp = re.compile(r'^\s*(-?\d+)\s+(\d+)\s*$'); frag = re.compile(r'^\s*--\s*$'); variable = re.compile(r'^\s*(\w+)\s*=\s*(-?\d+\.\d+|-?\d+\.|-?\.\d+|-?\d+|tda)\s*$', re.IGNORECASE); ghost = re.compile(r'@(.*)|Gh\((.*)\)', re.IGNORECASE). lines = re.split('\n', text); glines = []; ifrag = 0. for line in lines:. # handle comments; if comment.match(line) or blank.match(line):; pass. # handle units; elif ang.match(line):; self.set_units('Angstrom'); self.input_units_to_au = 1.0 / psi_bohr2angstroms; elif bohr.match(line):; self.set_units('Bohr'); self.input_units_to_au = 1.0. # handle no_reorient; elif orient.match(line):; self.fix_orientation(True). # handle no_com; elif com.match(line):; self.PYmove_to_com = False. # handle symmetry; elif symmetry.match(line):; tempSymm = symmetry.match(line).group(1); temp2 = re.sub('[23456789]', 'n', tempSymm).upper(); if temp2 in (item.upper() for item in self.FullPointGroupList):; self.PYsymmetry_from_input = tempSymm. # handle variables; elif variable.match(line):; vname = variable.match(line).group(1).upper(); vval = float(variable.match(line).group(2)); tda = 360.0 * math.atan(math.sqrt(2)) / math.pi; self.geometry_variables['%s' % vname] = tda if vname == 'TDA' else vval. # handle charge and multiplicity; elif cgmp.match(line):; tempCharge = int(cgmp.match(line).group(1)); tempMultiplicity = int(cgmp.match(line).group(2)). if ifrag == 0:; self.PYcharge_specified = True; self.PYmultiplicity_specified = True; self.PYmolecular_charge = tempCharge; self.PYmultiplicity = tempMultiplicity; self.fragment_charges.append(tempCharge); self.fragment_multiplicities.append(tempMultiplicity). # handle fragment markers and default fragment cgmp; elif frag.match(line):; try:; self.fragment_charges[ifrag]; except:; self.fragment_charges.append(0); self.fragment_multiplicities.append(1); ifrag += 1; glines.append(line). elif atom.match(line):; glines.append(line). # catch last default fragment cgmp; try:; self.fragment_charges[ifr",MatchSource.WIKI,psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html:15944,Modifiability,variab,variable,15944,"r'^\s*(-?\d+)\s+(\d+)\s*$'); frag = re.compile(r'^\s*--\s*$'); variable = re.compile(r'^\s*(\w+)\s*=\s*(-?\d+\.\d+|-?\d+\.|-?\.\d+|-?\d+|tda)\s*$', re.IGNORECASE); ghost = re.compile(r'@(.*)|Gh\((.*)\)', re.IGNORECASE). lines = re.split('\n', text); glines = []; ifrag = 0. for line in lines:. # handle comments; if comment.match(line) or blank.match(line):; pass. # handle units; elif ang.match(line):; self.set_units('Angstrom'); self.input_units_to_au = 1.0 / psi_bohr2angstroms; elif bohr.match(line):; self.set_units('Bohr'); self.input_units_to_au = 1.0. # handle no_reorient; elif orient.match(line):; self.fix_orientation(True). # handle no_com; elif com.match(line):; self.PYmove_to_com = False. # handle symmetry; elif symmetry.match(line):; tempSymm = symmetry.match(line).group(1); temp2 = re.sub('[23456789]', 'n', tempSymm).upper(); if temp2 in (item.upper() for item in self.FullPointGroupList):; self.PYsymmetry_from_input = tempSymm. # handle variables; elif variable.match(line):; vname = variable.match(line).group(1).upper(); vval = float(variable.match(line).group(2)); tda = 360.0 * math.atan(math.sqrt(2)) / math.pi; self.geometry_variables['%s' % vname] = tda if vname == 'TDA' else vval. # handle charge and multiplicity; elif cgmp.match(line):; tempCharge = int(cgmp.match(line).group(1)); tempMultiplicity = int(cgmp.match(line).group(2)). if ifrag == 0:; self.PYcharge_specified = True; self.PYmultiplicity_specified = True; self.PYmolecular_charge = tempCharge; self.PYmultiplicity = tempMultiplicity; self.fragment_charges.append(tempCharge); self.fragment_multiplicities.append(tempMultiplicity). # handle fragment markers and default fragment cgmp; elif frag.match(line):; try:; self.fragment_charges[ifrag]; except:; self.fragment_charges.append(0); self.fragment_multiplicities.append(1); ifrag += 1; glines.append(line). elif atom.match(line):; glines.append(line). # catch last default fragment cgmp; try:; self.fragment_charges[ifrag]; except:; self.fragment_charg",MatchSource.WIKI,psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html:15996,Modifiability,variab,variable,15996,"*--\s*$'); variable = re.compile(r'^\s*(\w+)\s*=\s*(-?\d+\.\d+|-?\d+\.|-?\.\d+|-?\d+|tda)\s*$', re.IGNORECASE); ghost = re.compile(r'@(.*)|Gh\((.*)\)', re.IGNORECASE). lines = re.split('\n', text); glines = []; ifrag = 0. for line in lines:. # handle comments; if comment.match(line) or blank.match(line):; pass. # handle units; elif ang.match(line):; self.set_units('Angstrom'); self.input_units_to_au = 1.0 / psi_bohr2angstroms; elif bohr.match(line):; self.set_units('Bohr'); self.input_units_to_au = 1.0. # handle no_reorient; elif orient.match(line):; self.fix_orientation(True). # handle no_com; elif com.match(line):; self.PYmove_to_com = False. # handle symmetry; elif symmetry.match(line):; tempSymm = symmetry.match(line).group(1); temp2 = re.sub('[23456789]', 'n', tempSymm).upper(); if temp2 in (item.upper() for item in self.FullPointGroupList):; self.PYsymmetry_from_input = tempSymm. # handle variables; elif variable.match(line):; vname = variable.match(line).group(1).upper(); vval = float(variable.match(line).group(2)); tda = 360.0 * math.atan(math.sqrt(2)) / math.pi; self.geometry_variables['%s' % vname] = tda if vname == 'TDA' else vval. # handle charge and multiplicity; elif cgmp.match(line):; tempCharge = int(cgmp.match(line).group(1)); tempMultiplicity = int(cgmp.match(line).group(2)). if ifrag == 0:; self.PYcharge_specified = True; self.PYmultiplicity_specified = True; self.PYmolecular_charge = tempCharge; self.PYmultiplicity = tempMultiplicity; self.fragment_charges.append(tempCharge); self.fragment_multiplicities.append(tempMultiplicity). # handle fragment markers and default fragment cgmp; elif frag.match(line):; try:; self.fragment_charges[ifrag]; except:; self.fragment_charges.append(0); self.fragment_multiplicities.append(1); ifrag += 1; glines.append(line). elif atom.match(line):; glines.append(line). # catch last default fragment cgmp; try:; self.fragment_charges[ifrag]; except:; self.fragment_charges.append(0); self.fragment_multiplicities.append(1)",MatchSource.WIKI,psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html:31699,Modifiability,variab,variables,31699,"ywords; text += "" units %-s\n"" % (""Angstrom"" if self.units() == 'Angstrom' else ""Bohr""); if not self.PYmove_to_com:; text += "" no_com\n""; if self.PYfix_orientation:; text += "" no_reorient\n"". # append atoms and coordentries and fragment separators with charge and multiplicity; Pfr = 0; for fr in range(self.nfragments()):; if self.fragment_types[fr] == 'Absent' and not self.has_zmatrix():; continue; text += ""%s %s%d %d\n"" % (; """" if Pfr == 0 else "" --\n"",; ""#"" if self.fragment_types[fr] == 'Ghost' or self.fragment_types[fr] == 'Absent' else """",; self.fragment_charges[fr], self.fragment_multiplicities[fr]); Pfr += 1; for at in range(self.fragments[fr][0], self.fragments[fr][1] + 1):; if self.fragment_types[fr] == 'Absent':; text += "" %-8s"" % (""X""); elif self.fZ(at) or self.fsymbol(at) == ""X"":; text += "" %-8s"" % (self.fsymbol(at)); else:; text += "" %-8s"" % (""Gh("" + self.fsymbol(at) + "")""); text += "" %s"" % (self.full_atoms[at].print_in_input_format()); text += ""\n"". # append any coordinate variables; if len(self.geometry_variables):; for vb, val in self.geometry_variables.items():; text += """""" %-10s=%16.10f\n"""""" % (vb, val); text += ""\n"". return text. # <<< Involved Methods for Coordinates >>>. [docs] def get_coord_value(self, vstr):; """"""Attempts to interpret a string as a double, if not it assumes it's a variable. """"""; vstr = vstr.upper(); realNumber = re.compile(r""""""[-+]?(?:(?:\d*\.\d+)|(?:\d+\.?))(?:[Ee][+-]?\d+)?"""""", re.VERBOSE). # handle number values; if realNumber.match(vstr):; return NumberValue(float(vstr)). # handle variable values, whether defined or not; else:; if vstr == 'TDA':; self.geometry_variables[vstr] = 360.0 * math.atan(math.sqrt(2)) / math.pi. # handle negative variable values (ignore leading '-' and return minus the value); if vstr[0] == '-':; self.all_variables.append(vstr[1:]); return VariableValue(vstr[1:], self.geometry_variables, True). # handle normal variable values; else:; self.all_variables.append(vstr); return VariableValue(vstr, self.ge",MatchSource.WIKI,psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html:32021,Modifiability,variab,variable,32021,"licity; Pfr = 0; for fr in range(self.nfragments()):; if self.fragment_types[fr] == 'Absent' and not self.has_zmatrix():; continue; text += ""%s %s%d %d\n"" % (; """" if Pfr == 0 else "" --\n"",; ""#"" if self.fragment_types[fr] == 'Ghost' or self.fragment_types[fr] == 'Absent' else """",; self.fragment_charges[fr], self.fragment_multiplicities[fr]); Pfr += 1; for at in range(self.fragments[fr][0], self.fragments[fr][1] + 1):; if self.fragment_types[fr] == 'Absent':; text += "" %-8s"" % (""X""); elif self.fZ(at) or self.fsymbol(at) == ""X"":; text += "" %-8s"" % (self.fsymbol(at)); else:; text += "" %-8s"" % (""Gh("" + self.fsymbol(at) + "")""); text += "" %s"" % (self.full_atoms[at].print_in_input_format()); text += ""\n"". # append any coordinate variables; if len(self.geometry_variables):; for vb, val in self.geometry_variables.items():; text += """""" %-10s=%16.10f\n"""""" % (vb, val); text += ""\n"". return text. # <<< Involved Methods for Coordinates >>>. [docs] def get_coord_value(self, vstr):; """"""Attempts to interpret a string as a double, if not it assumes it's a variable. """"""; vstr = vstr.upper(); realNumber = re.compile(r""""""[-+]?(?:(?:\d*\.\d+)|(?:\d+\.?))(?:[Ee][+-]?\d+)?"""""", re.VERBOSE). # handle number values; if realNumber.match(vstr):; return NumberValue(float(vstr)). # handle variable values, whether defined or not; else:; if vstr == 'TDA':; self.geometry_variables[vstr] = 360.0 * math.atan(math.sqrt(2)) / math.pi. # handle negative variable values (ignore leading '-' and return minus the value); if vstr[0] == '-':; self.all_variables.append(vstr[1:]); return VariableValue(vstr[1:], self.geometry_variables, True). # handle normal variable values; else:; self.all_variables.append(vstr); return VariableValue(vstr, self.geometry_variables). [docs] def add_atom(self, Z, x, y, z, label="""", mass=0.0, charge=0.0, lineno=-1):; """"""Add an atom to the molecule; *Z* atomic number; *x* cartesian coordinate; *y* cartesian coordinate; *z* cartesian coordinate; *symb* atomic symbol to use; *mass* mass",MatchSource.WIKI,psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html:32246,Modifiability,variab,variable,32246,"elf.fragment_multiplicities[fr]); Pfr += 1; for at in range(self.fragments[fr][0], self.fragments[fr][1] + 1):; if self.fragment_types[fr] == 'Absent':; text += "" %-8s"" % (""X""); elif self.fZ(at) or self.fsymbol(at) == ""X"":; text += "" %-8s"" % (self.fsymbol(at)); else:; text += "" %-8s"" % (""Gh("" + self.fsymbol(at) + "")""); text += "" %s"" % (self.full_atoms[at].print_in_input_format()); text += ""\n"". # append any coordinate variables; if len(self.geometry_variables):; for vb, val in self.geometry_variables.items():; text += """""" %-10s=%16.10f\n"""""" % (vb, val); text += ""\n"". return text. # <<< Involved Methods for Coordinates >>>. [docs] def get_coord_value(self, vstr):; """"""Attempts to interpret a string as a double, if not it assumes it's a variable. """"""; vstr = vstr.upper(); realNumber = re.compile(r""""""[-+]?(?:(?:\d*\.\d+)|(?:\d+\.?))(?:[Ee][+-]?\d+)?"""""", re.VERBOSE). # handle number values; if realNumber.match(vstr):; return NumberValue(float(vstr)). # handle variable values, whether defined or not; else:; if vstr == 'TDA':; self.geometry_variables[vstr] = 360.0 * math.atan(math.sqrt(2)) / math.pi. # handle negative variable values (ignore leading '-' and return minus the value); if vstr[0] == '-':; self.all_variables.append(vstr[1:]); return VariableValue(vstr[1:], self.geometry_variables, True). # handle normal variable values; else:; self.all_variables.append(vstr); return VariableValue(vstr, self.geometry_variables). [docs] def add_atom(self, Z, x, y, z, label="""", mass=0.0, charge=0.0, lineno=-1):; """"""Add an atom to the molecule; *Z* atomic number; *x* cartesian coordinate; *y* cartesian coordinate; *z* cartesian coordinate; *symb* atomic symbol to use; *mass* mass to use if non standard; *charge* charge to use if non standard; *lineno* line number when taken from a string. """"""; self.lock_frame = False. if self.atom_at_position([x, y, z]) == -1:; # Dummies go to full_atoms, ghosts need to go to both.; self.full_atoms.append(CartesianEntry(self.nallatom(), Z, charge, ",MatchSource.WIKI,psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html:32406,Modifiability,variab,variable,32406,"-8s"" % (""X""); elif self.fZ(at) or self.fsymbol(at) == ""X"":; text += "" %-8s"" % (self.fsymbol(at)); else:; text += "" %-8s"" % (""Gh("" + self.fsymbol(at) + "")""); text += "" %s"" % (self.full_atoms[at].print_in_input_format()); text += ""\n"". # append any coordinate variables; if len(self.geometry_variables):; for vb, val in self.geometry_variables.items():; text += """""" %-10s=%16.10f\n"""""" % (vb, val); text += ""\n"". return text. # <<< Involved Methods for Coordinates >>>. [docs] def get_coord_value(self, vstr):; """"""Attempts to interpret a string as a double, if not it assumes it's a variable. """"""; vstr = vstr.upper(); realNumber = re.compile(r""""""[-+]?(?:(?:\d*\.\d+)|(?:\d+\.?))(?:[Ee][+-]?\d+)?"""""", re.VERBOSE). # handle number values; if realNumber.match(vstr):; return NumberValue(float(vstr)). # handle variable values, whether defined or not; else:; if vstr == 'TDA':; self.geometry_variables[vstr] = 360.0 * math.atan(math.sqrt(2)) / math.pi. # handle negative variable values (ignore leading '-' and return minus the value); if vstr[0] == '-':; self.all_variables.append(vstr[1:]); return VariableValue(vstr[1:], self.geometry_variables, True). # handle normal variable values; else:; self.all_variables.append(vstr); return VariableValue(vstr, self.geometry_variables). [docs] def add_atom(self, Z, x, y, z, label="""", mass=0.0, charge=0.0, lineno=-1):; """"""Add an atom to the molecule; *Z* atomic number; *x* cartesian coordinate; *y* cartesian coordinate; *z* cartesian coordinate; *symb* atomic symbol to use; *mass* mass to use if non standard; *charge* charge to use if non standard; *lineno* line number when taken from a string. """"""; self.lock_frame = False. if self.atom_at_position([x, y, z]) == -1:; # Dummies go to full_atoms, ghosts need to go to both.; self.full_atoms.append(CartesianEntry(self.nallatom(), Z, charge, mass, label, label, \; NumberValue(x), NumberValue(y), NumberValue(z))); if label.upper() != 'X':; self.atoms.append(self.full_atoms[-1]); else:; raise ValidationErr",MatchSource.WIKI,psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html:32535,Modifiability,Variab,VariableValue,32535,"; else:; text += "" %-8s"" % (""Gh("" + self.fsymbol(at) + "")""); text += "" %s"" % (self.full_atoms[at].print_in_input_format()); text += ""\n"". # append any coordinate variables; if len(self.geometry_variables):; for vb, val in self.geometry_variables.items():; text += """""" %-10s=%16.10f\n"""""" % (vb, val); text += ""\n"". return text. # <<< Involved Methods for Coordinates >>>. [docs] def get_coord_value(self, vstr):; """"""Attempts to interpret a string as a double, if not it assumes it's a variable. """"""; vstr = vstr.upper(); realNumber = re.compile(r""""""[-+]?(?:(?:\d*\.\d+)|(?:\d+\.?))(?:[Ee][+-]?\d+)?"""""", re.VERBOSE). # handle number values; if realNumber.match(vstr):; return NumberValue(float(vstr)). # handle variable values, whether defined or not; else:; if vstr == 'TDA':; self.geometry_variables[vstr] = 360.0 * math.atan(math.sqrt(2)) / math.pi. # handle negative variable values (ignore leading '-' and return minus the value); if vstr[0] == '-':; self.all_variables.append(vstr[1:]); return VariableValue(vstr[1:], self.geometry_variables, True). # handle normal variable values; else:; self.all_variables.append(vstr); return VariableValue(vstr, self.geometry_variables). [docs] def add_atom(self, Z, x, y, z, label="""", mass=0.0, charge=0.0, lineno=-1):; """"""Add an atom to the molecule; *Z* atomic number; *x* cartesian coordinate; *y* cartesian coordinate; *z* cartesian coordinate; *symb* atomic symbol to use; *mass* mass to use if non standard; *charge* charge to use if non standard; *lineno* line number when taken from a string. """"""; self.lock_frame = False. if self.atom_at_position([x, y, z]) == -1:; # Dummies go to full_atoms, ghosts need to go to both.; self.full_atoms.append(CartesianEntry(self.nallatom(), Z, charge, mass, label, label, \; NumberValue(x), NumberValue(y), NumberValue(z))); if label.upper() != 'X':; self.atoms.append(self.full_atoms[-1]); else:; raise ValidationError(""Molecule::add_atom: Adding atom on top of an existing atom.""). [docs] def atom_entry(self, ",MatchSource.WIKI,psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html:32607,Modifiability,variab,variable,32607," (self.full_atoms[at].print_in_input_format()); text += ""\n"". # append any coordinate variables; if len(self.geometry_variables):; for vb, val in self.geometry_variables.items():; text += """""" %-10s=%16.10f\n"""""" % (vb, val); text += ""\n"". return text. # <<< Involved Methods for Coordinates >>>. [docs] def get_coord_value(self, vstr):; """"""Attempts to interpret a string as a double, if not it assumes it's a variable. """"""; vstr = vstr.upper(); realNumber = re.compile(r""""""[-+]?(?:(?:\d*\.\d+)|(?:\d+\.?))(?:[Ee][+-]?\d+)?"""""", re.VERBOSE). # handle number values; if realNumber.match(vstr):; return NumberValue(float(vstr)). # handle variable values, whether defined or not; else:; if vstr == 'TDA':; self.geometry_variables[vstr] = 360.0 * math.atan(math.sqrt(2)) / math.pi. # handle negative variable values (ignore leading '-' and return minus the value); if vstr[0] == '-':; self.all_variables.append(vstr[1:]); return VariableValue(vstr[1:], self.geometry_variables, True). # handle normal variable values; else:; self.all_variables.append(vstr); return VariableValue(vstr, self.geometry_variables). [docs] def add_atom(self, Z, x, y, z, label="""", mass=0.0, charge=0.0, lineno=-1):; """"""Add an atom to the molecule; *Z* atomic number; *x* cartesian coordinate; *y* cartesian coordinate; *z* cartesian coordinate; *symb* atomic symbol to use; *mass* mass to use if non standard; *charge* charge to use if non standard; *lineno* line number when taken from a string. """"""; self.lock_frame = False. if self.atom_at_position([x, y, z]) == -1:; # Dummies go to full_atoms, ghosts need to go to both.; self.full_atoms.append(CartesianEntry(self.nallatom(), Z, charge, mass, label, label, \; NumberValue(x), NumberValue(y), NumberValue(z))); if label.upper() != 'X':; self.atoms.append(self.full_atoms[-1]); else:; raise ValidationError(""Molecule::add_atom: Adding atom on top of an existing atom.""). [docs] def atom_entry(self, atom):; """"""Returns the CoordEntry for an atom.""""""; return self.atoms[atom]. ",MatchSource.WIKI,psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html:32671,Modifiability,Variab,VariableValue,32671,". # append any coordinate variables; if len(self.geometry_variables):; for vb, val in self.geometry_variables.items():; text += """""" %-10s=%16.10f\n"""""" % (vb, val); text += ""\n"". return text. # <<< Involved Methods for Coordinates >>>. [docs] def get_coord_value(self, vstr):; """"""Attempts to interpret a string as a double, if not it assumes it's a variable. """"""; vstr = vstr.upper(); realNumber = re.compile(r""""""[-+]?(?:(?:\d*\.\d+)|(?:\d+\.?))(?:[Ee][+-]?\d+)?"""""", re.VERBOSE). # handle number values; if realNumber.match(vstr):; return NumberValue(float(vstr)). # handle variable values, whether defined or not; else:; if vstr == 'TDA':; self.geometry_variables[vstr] = 360.0 * math.atan(math.sqrt(2)) / math.pi. # handle negative variable values (ignore leading '-' and return minus the value); if vstr[0] == '-':; self.all_variables.append(vstr[1:]); return VariableValue(vstr[1:], self.geometry_variables, True). # handle normal variable values; else:; self.all_variables.append(vstr); return VariableValue(vstr, self.geometry_variables). [docs] def add_atom(self, Z, x, y, z, label="""", mass=0.0, charge=0.0, lineno=-1):; """"""Add an atom to the molecule; *Z* atomic number; *x* cartesian coordinate; *y* cartesian coordinate; *z* cartesian coordinate; *symb* atomic symbol to use; *mass* mass to use if non standard; *charge* charge to use if non standard; *lineno* line number when taken from a string. """"""; self.lock_frame = False. if self.atom_at_position([x, y, z]) == -1:; # Dummies go to full_atoms, ghosts need to go to both.; self.full_atoms.append(CartesianEntry(self.nallatom(), Z, charge, mass, label, label, \; NumberValue(x), NumberValue(y), NumberValue(z))); if label.upper() != 'X':; self.atoms.append(self.full_atoms[-1]); else:; raise ValidationError(""Molecule::add_atom: Adding atom on top of an existing atom.""). [docs] def atom_entry(self, atom):; """"""Returns the CoordEntry for an atom.""""""; return self.atoms[atom]. [docs] def atom_at_position(self, b, tol=0.05):; """"""Tests to",MatchSource.WIKI,psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html:34160,Modifiability,variab,variable,34160,"to full_atoms, ghosts need to go to both.; self.full_atoms.append(CartesianEntry(self.nallatom(), Z, charge, mass, label, label, \; NumberValue(x), NumberValue(y), NumberValue(z))); if label.upper() != 'X':; self.atoms.append(self.full_atoms[-1]); else:; raise ValidationError(""Molecule::add_atom: Adding atom on top of an existing atom.""). [docs] def atom_entry(self, atom):; """"""Returns the CoordEntry for an atom.""""""; return self.atoms[atom]. [docs] def atom_at_position(self, b, tol=0.05):; """"""Tests to see of an atom is at the passed position *b* in Bohr with a tolerance *tol*. >>> print H2OH2O.atom_at_position([1.35*(1.0/psi_bohr2angstroms), 0.10*(1.0/psi_bohr2angstroms), 0.0*(1.0/psi_bohr2angstroms)]); 3. """"""; if len(b) != 3:; raise ValidationError('ERROR: atom_at_position() requires as argument a vector of length 3\n'). for at in range(self.natom()):; a = self.xyz(at); if distance(b, a) < tol:; return at; return -1. [docs] def is_variable(self, vstr):; """"""Checks to see if the variable str is in the list, returns; true if it is, and returns false if not. >>> H2OH2O.is_variable('R'); False. """"""; return True if vstr.upper() in self.all_variables else False. [docs] def get_variable(self, vstr):; """"""Checks to see if the variable str is in the list, sets it to; val and returns true if it is, and returns false if not. """"""; vstr = vstr.upper(); try:; return self.geometry_variables[vstr]; except KeyError:; raise ValidationError('ERROR: Geometry variable %s not known.\n' % (vstr)). [docs] def set_variable(self, vstr, val):; """"""Assigns the value val to the variable labelled string in the; list of geometry variables. Also calls update_geometry(). """"""; self.__dict__['lock_frame'] = False; self.__dict__['geometry_variables'][vstr.upper()] = val; print ""Setting geometry variable %s to %f"" % (vstr.upper(), val); try:; self.update_geometry(); except IncompleteAtomError:; # Update geometry might have added some atoms, delete them to be safe.; self.atoms = []; # TODO outfile. def __s",MatchSource.WIKI,psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html:34404,Modifiability,variab,variable,34404,"; raise ValidationError(""Molecule::add_atom: Adding atom on top of an existing atom.""). [docs] def atom_entry(self, atom):; """"""Returns the CoordEntry for an atom.""""""; return self.atoms[atom]. [docs] def atom_at_position(self, b, tol=0.05):; """"""Tests to see of an atom is at the passed position *b* in Bohr with a tolerance *tol*. >>> print H2OH2O.atom_at_position([1.35*(1.0/psi_bohr2angstroms), 0.10*(1.0/psi_bohr2angstroms), 0.0*(1.0/psi_bohr2angstroms)]); 3. """"""; if len(b) != 3:; raise ValidationError('ERROR: atom_at_position() requires as argument a vector of length 3\n'). for at in range(self.natom()):; a = self.xyz(at); if distance(b, a) < tol:; return at; return -1. [docs] def is_variable(self, vstr):; """"""Checks to see if the variable str is in the list, returns; true if it is, and returns false if not. >>> H2OH2O.is_variable('R'); False. """"""; return True if vstr.upper() in self.all_variables else False. [docs] def get_variable(self, vstr):; """"""Checks to see if the variable str is in the list, sets it to; val and returns true if it is, and returns false if not. """"""; vstr = vstr.upper(); try:; return self.geometry_variables[vstr]; except KeyError:; raise ValidationError('ERROR: Geometry variable %s not known.\n' % (vstr)). [docs] def set_variable(self, vstr, val):; """"""Assigns the value val to the variable labelled string in the; list of geometry variables. Also calls update_geometry(). """"""; self.__dict__['lock_frame'] = False; self.__dict__['geometry_variables'][vstr.upper()] = val; print ""Setting geometry variable %s to %f"" % (vstr.upper(), val); try:; self.update_geometry(); except IncompleteAtomError:; # Update geometry might have added some atoms, delete them to be safe.; self.atoms = []; # TODO outfile. def __setattr__(self, name, value):; """"""Function to overload setting attributes to allow geometry; variable assigment as if member data. """"""; try:; if name.upper() in self.__dict__['all_variables']:; self.set_variable(name, value); else:; self.__dict__[name] =",MatchSource.WIKI,psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html:34629,Modifiability,variab,variable,34629,"f.atoms[atom]. [docs] def atom_at_position(self, b, tol=0.05):; """"""Tests to see of an atom is at the passed position *b* in Bohr with a tolerance *tol*. >>> print H2OH2O.atom_at_position([1.35*(1.0/psi_bohr2angstroms), 0.10*(1.0/psi_bohr2angstroms), 0.0*(1.0/psi_bohr2angstroms)]); 3. """"""; if len(b) != 3:; raise ValidationError('ERROR: atom_at_position() requires as argument a vector of length 3\n'). for at in range(self.natom()):; a = self.xyz(at); if distance(b, a) < tol:; return at; return -1. [docs] def is_variable(self, vstr):; """"""Checks to see if the variable str is in the list, returns; true if it is, and returns false if not. >>> H2OH2O.is_variable('R'); False. """"""; return True if vstr.upper() in self.all_variables else False. [docs] def get_variable(self, vstr):; """"""Checks to see if the variable str is in the list, sets it to; val and returns true if it is, and returns false if not. """"""; vstr = vstr.upper(); try:; return self.geometry_variables[vstr]; except KeyError:; raise ValidationError('ERROR: Geometry variable %s not known.\n' % (vstr)). [docs] def set_variable(self, vstr, val):; """"""Assigns the value val to the variable labelled string in the; list of geometry variables. Also calls update_geometry(). """"""; self.__dict__['lock_frame'] = False; self.__dict__['geometry_variables'][vstr.upper()] = val; print ""Setting geometry variable %s to %f"" % (vstr.upper(), val); try:; self.update_geometry(); except IncompleteAtomError:; # Update geometry might have added some atoms, delete them to be safe.; self.atoms = []; # TODO outfile. def __setattr__(self, name, value):; """"""Function to overload setting attributes to allow geometry; variable assigment as if member data. """"""; try:; if name.upper() in self.__dict__['all_variables']:; self.set_variable(name, value); else:; self.__dict__[name] = value; except KeyError:; self.__dict__[name] = value. def __getattr__(self, name):; """"""Function to overload accessing attribute contents to allow; retrivial geometry variable va",MatchSource.WIKI,psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html:34741,Modifiability,variab,variable,34741," tolerance *tol*. >>> print H2OH2O.atom_at_position([1.35*(1.0/psi_bohr2angstroms), 0.10*(1.0/psi_bohr2angstroms), 0.0*(1.0/psi_bohr2angstroms)]); 3. """"""; if len(b) != 3:; raise ValidationError('ERROR: atom_at_position() requires as argument a vector of length 3\n'). for at in range(self.natom()):; a = self.xyz(at); if distance(b, a) < tol:; return at; return -1. [docs] def is_variable(self, vstr):; """"""Checks to see if the variable str is in the list, returns; true if it is, and returns false if not. >>> H2OH2O.is_variable('R'); False. """"""; return True if vstr.upper() in self.all_variables else False. [docs] def get_variable(self, vstr):; """"""Checks to see if the variable str is in the list, sets it to; val and returns true if it is, and returns false if not. """"""; vstr = vstr.upper(); try:; return self.geometry_variables[vstr]; except KeyError:; raise ValidationError('ERROR: Geometry variable %s not known.\n' % (vstr)). [docs] def set_variable(self, vstr, val):; """"""Assigns the value val to the variable labelled string in the; list of geometry variables. Also calls update_geometry(). """"""; self.__dict__['lock_frame'] = False; self.__dict__['geometry_variables'][vstr.upper()] = val; print ""Setting geometry variable %s to %f"" % (vstr.upper(), val); try:; self.update_geometry(); except IncompleteAtomError:; # Update geometry might have added some atoms, delete them to be safe.; self.atoms = []; # TODO outfile. def __setattr__(self, name, value):; """"""Function to overload setting attributes to allow geometry; variable assigment as if member data. """"""; try:; if name.upper() in self.__dict__['all_variables']:; self.set_variable(name, value); else:; self.__dict__[name] = value; except KeyError:; self.__dict__[name] = value. def __getattr__(self, name):; """"""Function to overload accessing attribute contents to allow; retrivial geometry variable values as if member data. """"""; if not name in self.__dict__:; if object.__getattribute__(self, 'is_variable')(name):; return object.__ge",MatchSource.WIKI,psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html:34791,Modifiability,variab,variables,34791," tolerance *tol*. >>> print H2OH2O.atom_at_position([1.35*(1.0/psi_bohr2angstroms), 0.10*(1.0/psi_bohr2angstroms), 0.0*(1.0/psi_bohr2angstroms)]); 3. """"""; if len(b) != 3:; raise ValidationError('ERROR: atom_at_position() requires as argument a vector of length 3\n'). for at in range(self.natom()):; a = self.xyz(at); if distance(b, a) < tol:; return at; return -1. [docs] def is_variable(self, vstr):; """"""Checks to see if the variable str is in the list, returns; true if it is, and returns false if not. >>> H2OH2O.is_variable('R'); False. """"""; return True if vstr.upper() in self.all_variables else False. [docs] def get_variable(self, vstr):; """"""Checks to see if the variable str is in the list, sets it to; val and returns true if it is, and returns false if not. """"""; vstr = vstr.upper(); try:; return self.geometry_variables[vstr]; except KeyError:; raise ValidationError('ERROR: Geometry variable %s not known.\n' % (vstr)). [docs] def set_variable(self, vstr, val):; """"""Assigns the value val to the variable labelled string in the; list of geometry variables. Also calls update_geometry(). """"""; self.__dict__['lock_frame'] = False; self.__dict__['geometry_variables'][vstr.upper()] = val; print ""Setting geometry variable %s to %f"" % (vstr.upper(), val); try:; self.update_geometry(); except IncompleteAtomError:; # Update geometry might have added some atoms, delete them to be safe.; self.atoms = []; # TODO outfile. def __setattr__(self, name, value):; """"""Function to overload setting attributes to allow geometry; variable assigment as if member data. """"""; try:; if name.upper() in self.__dict__['all_variables']:; self.set_variable(name, value); else:; self.__dict__[name] = value; except KeyError:; self.__dict__[name] = value. def __getattr__(self, name):; """"""Function to overload accessing attribute contents to allow; retrivial geometry variable values as if member data. """"""; if not name in self.__dict__:; if object.__getattribute__(self, 'is_variable')(name):; return object.__ge",MatchSource.WIKI,psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html:34955,Modifiability,variab,variable,34955,"ion() requires as argument a vector of length 3\n'). for at in range(self.natom()):; a = self.xyz(at); if distance(b, a) < tol:; return at; return -1. [docs] def is_variable(self, vstr):; """"""Checks to see if the variable str is in the list, returns; true if it is, and returns false if not. >>> H2OH2O.is_variable('R'); False. """"""; return True if vstr.upper() in self.all_variables else False. [docs] def get_variable(self, vstr):; """"""Checks to see if the variable str is in the list, sets it to; val and returns true if it is, and returns false if not. """"""; vstr = vstr.upper(); try:; return self.geometry_variables[vstr]; except KeyError:; raise ValidationError('ERROR: Geometry variable %s not known.\n' % (vstr)). [docs] def set_variable(self, vstr, val):; """"""Assigns the value val to the variable labelled string in the; list of geometry variables. Also calls update_geometry(). """"""; self.__dict__['lock_frame'] = False; self.__dict__['geometry_variables'][vstr.upper()] = val; print ""Setting geometry variable %s to %f"" % (vstr.upper(), val); try:; self.update_geometry(); except IncompleteAtomError:; # Update geometry might have added some atoms, delete them to be safe.; self.atoms = []; # TODO outfile. def __setattr__(self, name, value):; """"""Function to overload setting attributes to allow geometry; variable assigment as if member data. """"""; try:; if name.upper() in self.__dict__['all_variables']:; self.set_variable(name, value); else:; self.__dict__[name] = value; except KeyError:; self.__dict__[name] = value. def __getattr__(self, name):; """"""Function to overload accessing attribute contents to allow; retrivial geometry variable values as if member data. """"""; if not name in self.__dict__:; if object.__getattribute__(self, 'is_variable')(name):; return object.__getattribute__(self, 'get_variable')(name); else:; raise AttributeError; else:; return self.__dict__[name]. [docs] def get_anchor_atom(self, vstr, line):; """"""Attempts to interpret a string *vstr* as an atom specifier i",MatchSource.WIKI,psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html:35260,Modifiability,variab,variable,35260,"se if not. >>> H2OH2O.is_variable('R'); False. """"""; return True if vstr.upper() in self.all_variables else False. [docs] def get_variable(self, vstr):; """"""Checks to see if the variable str is in the list, sets it to; val and returns true if it is, and returns false if not. """"""; vstr = vstr.upper(); try:; return self.geometry_variables[vstr]; except KeyError:; raise ValidationError('ERROR: Geometry variable %s not known.\n' % (vstr)). [docs] def set_variable(self, vstr, val):; """"""Assigns the value val to the variable labelled string in the; list of geometry variables. Also calls update_geometry(). """"""; self.__dict__['lock_frame'] = False; self.__dict__['geometry_variables'][vstr.upper()] = val; print ""Setting geometry variable %s to %f"" % (vstr.upper(), val); try:; self.update_geometry(); except IncompleteAtomError:; # Update geometry might have added some atoms, delete them to be safe.; self.atoms = []; # TODO outfile. def __setattr__(self, name, value):; """"""Function to overload setting attributes to allow geometry; variable assigment as if member data. """"""; try:; if name.upper() in self.__dict__['all_variables']:; self.set_variable(name, value); else:; self.__dict__[name] = value; except KeyError:; self.__dict__[name] = value. def __getattr__(self, name):; """"""Function to overload accessing attribute contents to allow; retrivial geometry variable values as if member data. """"""; if not name in self.__dict__:; if object.__getattribute__(self, 'is_variable')(name):; return object.__getattribute__(self, 'get_variable')(name); else:; raise AttributeError; else:; return self.__dict__[name]. [docs] def get_anchor_atom(self, vstr, line):; """"""Attempts to interpret a string *vstr* as an atom specifier in; a zmatrix. Takes the current *line* for error message printing.; Returns the atom number (adjusted to zero-based counting). """"""; integerNumber = re.compile(r""(-?\d+)"", re.IGNORECASE); if integerNumber.match(vstr):; # This is just a number, return it; return int(vstr) - 1; else",MatchSource.WIKI,psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html:35588,Modifiability,variab,variable,35588,"ometry_variables[vstr]; except KeyError:; raise ValidationError('ERROR: Geometry variable %s not known.\n' % (vstr)). [docs] def set_variable(self, vstr, val):; """"""Assigns the value val to the variable labelled string in the; list of geometry variables. Also calls update_geometry(). """"""; self.__dict__['lock_frame'] = False; self.__dict__['geometry_variables'][vstr.upper()] = val; print ""Setting geometry variable %s to %f"" % (vstr.upper(), val); try:; self.update_geometry(); except IncompleteAtomError:; # Update geometry might have added some atoms, delete them to be safe.; self.atoms = []; # TODO outfile. def __setattr__(self, name, value):; """"""Function to overload setting attributes to allow geometry; variable assigment as if member data. """"""; try:; if name.upper() in self.__dict__['all_variables']:; self.set_variable(name, value); else:; self.__dict__[name] = value; except KeyError:; self.__dict__[name] = value. def __getattr__(self, name):; """"""Function to overload accessing attribute contents to allow; retrivial geometry variable values as if member data. """"""; if not name in self.__dict__:; if object.__getattribute__(self, 'is_variable')(name):; return object.__getattribute__(self, 'get_variable')(name); else:; raise AttributeError; else:; return self.__dict__[name]. [docs] def get_anchor_atom(self, vstr, line):; """"""Attempts to interpret a string *vstr* as an atom specifier in; a zmatrix. Takes the current *line* for error message printing.; Returns the atom number (adjusted to zero-based counting). """"""; integerNumber = re.compile(r""(-?\d+)"", re.IGNORECASE); if integerNumber.match(vstr):; # This is just a number, return it; return int(vstr) - 1; else:; # Look to see if this string is known; for i in range(self.nallatom()):; if self.full_atoms[i].label() == vstr:; return i; raise ValidationError(""Illegal value %s in atom specification on line %s.\n"" % (vstr, line)). [docs] def geometry(self):; """"""Returns the geometry in Bohr as a N X 3 array. >>> print H2OH2O.geome",MatchSource.WIKI,psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html:44846,Modifiability,variab,variables,44846,"; self.atoms = []; for item in self.full_atoms:; item.invalidate(). temp_charge = self.PYmolecular_charge; temp_multiplicity = self.PYmultiplicity; self.PYmolecular_charge = 0; self.PYmultiplicity = 1. for fr in range(self.nfragments()):; if self.fragment_types[fr] == 'Absent':; continue. if self.fragment_types[fr] == 'Real':; self.PYmolecular_charge += self.fragment_charges[fr]; self.PYmultiplicity += self.fragment_multiplicities[fr] - 1. for at in range(self.fragments[fr][0], self.fragments[fr][1] + 1):; self.full_atoms[at].compute(); self.full_atoms[at].set_ghosted(self.fragment_types[fr] == 'Ghost'); if self.full_atoms[at].symbol() != 'X':; self.atoms.append(self.full_atoms[at]). # TODO: This is a hack to ensure that set_multiplicity and set_molecular_charge; # work for single-fragment molecules.; if self.nfragments() < 2:; self.PYmolecular_charge = temp_charge; self.PYmultiplicity = temp_multiplicity. [docs] def update_geometry(self):; """"""Updates the geometry, by (re)interpreting the string used to; create the molecule, and the current values of the variables.; The atoms list is cleared, and then rebuilt by this routine.; This function must be called after first instantiation of Molecule. >>> H2 = qcdb.Molecule(""H\\nH 1 0.74\\n""); >>> print H2.natom(); 0; >>> H2.update_geometry(); >>> print H2.natom(); 2. """"""; if self.nfragments() == 0:; raise ValidationError(""Molecule::update_geometry: There are no fragments in this molecule.""). # Idempotence condition; if self.lock_frame:; return. #print ""beginning update_geometry:""; #self.print_full(); if self.PYreinterpret_coordentries:; self.reinterpret_coordentries(); #print ""after reinterpret_coordentries:""; #self.print_full(). if self.PYmove_to_com:; self.move_to_com(); #print ""after com:""; #self.print_full(). # If the no_reorient command was given, don't reorient; if not self.PYfix_orientation:; # Now we need to rotate the geometry to its symmetry frame; # to align the axes correctly for the point group; # symmetry_fra",MatchSource.WIKI,psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html:22139,Safety,detect,detected,22139,"ntry(iatom, zVal, charge, \; el2masses[atomSym], atomSym, atomLabel, \; self.full_atoms[rTo], rval, \; self.full_atoms[aTo], aval, \; self.full_atoms[dTo], dval)). else:; raise ValidationError('Illegal geometry specification line : %s. \; You should provide either Z-Matrix or Cartesian input' % (line)). iatom += 1. self.fragments.append([tempfrag[0], tempfrag[-1]]); self.fragment_types.append('Real'); self.set_has_zmatrix(zmatrix). [docs] def init_with_checkpoint(self, chkpt):; """""" **NYI** Pull information from the *chkpt* object passed; (method name in libmints is init_with_chkpt). """"""; raise FeatureNotImplemented('Molecule::init_with_checkpoint') # FINAL. [docs] def init_with_io(self, psio):; """""" **NYI** Pull information from a chkpt object created from psio; (method name in libmints is init_with_psio). """"""; raise FeatureNotImplemented('Molecule::init_with_io') # FINAL. @classmethod; [docs] def init_with_xyz(cls, xyzfilename):; """"""Pull information from an XYZ file. No fragment or chg/mult info detected. >>> H2O = qcdb.Molecule.init_with_xyz('h2o.xyz'). """"""; instance = cls(); instance.lock_frame = False. try:; infile = open(xyzfilename, 'r'); except IOError:; raise ValidationError(""""""Molecule::init_with_xyz: given filename '%s' does not exist."""""" % (xyzfilename)); if os.stat(xyzfilename).st_size == 0:; raise ValidationError(""""""Molecule::init_with_xyz: given filename '%s' is blank."""""" % (xyzfilename)); text = infile.readlines(). xyz1 = re.compile(r""^\s*(\d+)\s*(bohr|au)?\s*$"", re.IGNORECASE); xyzN = re.compile(r""(?:\s*)([A-Z](?:[a-z])?)(?:\s+)(-?\d+\.\d+)(?:\s+)(-?\d+\.\d+)(?:\s+)(-?\d+\.\d+)(?:\s*)"", re.IGNORECASE). # Try to match the first line; if xyz1.match(text[0]):; fileNatom = int(xyz1.match(text[0]).group(1)); if xyz1.match(text[0]).group(2) == None:; fileUnits = 'Angstrom'; else:; fileUnits = 'Bohr'; else:; raise ValidationError(""Molecule::init_with_xyz: Malformed first line\n%s"" % (text[0])). # Skip the second line. # Next line begins the useful information",MatchSource.WIKI,psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html:35121,Safety,safe,safe,35121,") < tol:; return at; return -1. [docs] def is_variable(self, vstr):; """"""Checks to see if the variable str is in the list, returns; true if it is, and returns false if not. >>> H2OH2O.is_variable('R'); False. """"""; return True if vstr.upper() in self.all_variables else False. [docs] def get_variable(self, vstr):; """"""Checks to see if the variable str is in the list, sets it to; val and returns true if it is, and returns false if not. """"""; vstr = vstr.upper(); try:; return self.geometry_variables[vstr]; except KeyError:; raise ValidationError('ERROR: Geometry variable %s not known.\n' % (vstr)). [docs] def set_variable(self, vstr, val):; """"""Assigns the value val to the variable labelled string in the; list of geometry variables. Also calls update_geometry(). """"""; self.__dict__['lock_frame'] = False; self.__dict__['geometry_variables'][vstr.upper()] = val; print ""Setting geometry variable %s to %f"" % (vstr.upper(), val); try:; self.update_geometry(); except IncompleteAtomError:; # Update geometry might have added some atoms, delete them to be safe.; self.atoms = []; # TODO outfile. def __setattr__(self, name, value):; """"""Function to overload setting attributes to allow geometry; variable assigment as if member data. """"""; try:; if name.upper() in self.__dict__['all_variables']:; self.set_variable(name, value); else:; self.__dict__[name] = value; except KeyError:; self.__dict__[name] = value. def __getattr__(self, name):; """"""Function to overload accessing attribute contents to allow; retrivial geometry variable values as if member data. """"""; if not name in self.__dict__:; if object.__getattribute__(self, 'is_variable')(name):; return object.__getattribute__(self, 'get_variable')(name); else:; raise AttributeError; else:; return self.__dict__[name]. [docs] def get_anchor_atom(self, vstr, line):; """"""Attempts to interpret a string *vstr* as an atom specifier in; a zmatrix. Takes the current *line* for error message printing.; Returns the atom number (adjusted to zero-based co",MatchSource.WIKI,psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html:6600,Security,Validat,ValidationError,6600,"cs] def charge_specified(self):; """"""Whether the charge was given by the user. >>> print H2OH2O.charge_specified(); True. """"""; return self.PYcharge_specified. [docs] def multiplicity(self):; """"""Get the multiplicity (defined as 2Ms + 1). >>> print H2OH2O.multiplicity(). """"""; return self.PYmultiplicity. [docs] def set_multiplicity(self, mult):; """"""Sets the multiplicity (defined as 2Ms + 1). >>> H2OH2O.set_multiplicity(3). """"""; self.PYmultiplicity_specified = True; self.PYmultiplicity = mult. [docs] def multiplicity_specified(self):; """"""Whether the multiplicity was given by the user. >>> print H2OH2O.multiplicity_specified(); True. """"""; return self.PYmultiplicity_specified. [docs] def units(self):; """"""Gets the geometry units. >>> print H2OH2O.units(); Angstrom. """"""; return self.PYunits. [docs] def set_units(self, units):; """"""Sets the geometry units. >>> H2OH2O.set_units('Angstom'). """"""; if units == 'Angstrom' or units == 'Bohr':; self.PYunits = units; else:; raise ValidationError(""""""Argument to Molecule::set_units must be 'Angstrom' or 'Bohr'.""""""). [docs] def has_zmatrix(self):; """"""Gets the presence of any zmatrix entry. >>> print H2OH2O.has_zmatrix(); False. """"""; return self.zmat. [docs] def set_has_zmatrix(self, tf):; """"""Sets the presence of any zmatrix entry. >>> H2OH2O.set_has_zmatrix(True). """"""; self.zmat = tf. # <<< Simple Methods for Coordinates >>>. [docs] def Z(self, atom):; """"""Nuclear charge of atom (0-indexed). >>> print H2OH2O.Z(4); 1. """"""; return self.atoms[atom].Z(). [docs] def x(self, atom):; """"""x position of atom (0-indexed) in Bohr. >>> print H2OH2O.x(4); 3.17549201425. """"""; return self.input_units_to_au * self.atoms[atom].compute()[0]. [docs] def y(self, atom):; """"""y position of atom (0-indexed) in Bohr. >>> print H2OH2O.y(4); -0.706268134631. """"""; return self.input_units_to_au * self.atoms[atom].compute()[1]. [docs] def z(self, atom):; """"""z position of atom (0-indexed) in Bohr. >>> print H2OH2O.z(4); -1.43347254509. """"""; return self.input_units_to_au ",MatchSource.WIKI,psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html:13819,Security,Validat,ValidationError,13819," return self.extract_fragments(reals, ghosts=[]). [docs] def extract_fragments(self, reals, ghosts=[]):; """"""Makes a copy of the molecule, returning a new molecule with; only certain fragment atoms present as either ghost or real atoms; *reals*: The list or int of fragments (1-indexed) that should be present in the molecule as real atoms.; *ghosts*: The list or int of fragments (1-indexed) that should be present in the molecule as ghosts.; (method name in libmints is extract_subsets. This is different; in qcdb because the psi4 input parser tries to process lines with; that term, giving rise to Boost:Python type conlicts.) See usage; at :py:func:`~qcdb.molecule.extract_fragments`. """"""; lreals = []; try:; for idx in reals:; lreals.append(idx - 1); except TypeError:; lreals = [reals - 1]; lghosts = []; try:; for idx in ghosts:; lghosts.append(idx - 1); except TypeError:; lghosts = [ghosts - 1]; if len(lreals) + len(lghosts) > self.nfragments():; raise ValidationError('The sum of real- and ghost-atom subsets is greater than the number of subsets'). subset = self.clone(); subset.deactivate_all_fragments(); for fr in lreals:; subset.set_active_fragment(fr + 1) # the active fragment code subtracts 1; for fr in lghosts:; subset.set_ghost_fragment(fr + 1) # the ghost fragment code subtracts 1. subset.update_geometry(); return subset. # <<< Methods for Construction >>>. [docs] def create_molecule_from_string(self, text):; """"""Given a string *geom* of psi4-style geometry specification; (including newlines to separate lines), builds a new molecule.; Called from constructor. """"""; comment = re.compile(r'^\s*#'); blank = re.compile(r'^\s*$'); bohr = re.compile(r'^\s*units?[\s=]+(bohr|au|a.u.)\s*$', re.IGNORECASE); ang = re.compile(r'^\s*units?[\s=]+(ang|angstrom)\s*$', re.IGNORECASE); orient = re.compile(r'^\s*(no_reorient|noreorient)\s*$', re.IGNORECASE); com = re.compile(r'^\s*(no_com|nocom)\s*$', re.IGNORECASE); symmetry = re.compile(r'^\s*symmetry[\s=]+(\w+)\s*$', re.IGNORECASE)",MatchSource.WIKI,psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html:17901,Security,Validat,ValidationError,17901,"g]; except:; self.fragment_charges.append(0); self.fragment_multiplicities.append(1). # Now go through the rest of the lines looking for fragment markers; ifrag = 0; iatom = 0; tempfrag = []; atomSym = """"; atomLabel = """"; zmatrix = False; for line in glines:. # handle fragment markers; if frag.match(line):; ifrag += 1; self.fragments.append([tempfrag[0], tempfrag[-1]]); self.fragment_types.append('Real'); tempfrag = []. # handle atom markers; elif atom.match(line):; entries = re.split(r'\s+|\s*,\s*', line.strip()); atomLabel = entries[0]. # handle ghost atoms; ghostAtom = False; if ghost.match(atomLabel):; # We don't know whether the @C or Gh(C) notation matched. Do a quick check.; atomLabel = ghost.match(atomLabel).group(2) if not ghost.match(atomLabel).group(1) \; else ghost.match(atomLabel).group(1); ghostAtom = True. # Save the actual atom symbol (H1 => H); atomSym = re.split('(\d+)', atomLabel)[0].upper(). # Check that the atom symbol is valid; if not atomSym in el2z:; raise ValidationError('Illegal atom symbol in geometry specification: %s' % (atomSym)). zVal = el2z[atomSym]; charge = float(zVal); if ghostAtom:; zVal = 0; charge = 0.0. # handle cartesians; if len(entries) == 4:; tempfrag.append(iatom); xval = self.get_coord_value(entries[1]); yval = self.get_coord_value(entries[2]); zval = self.get_coord_value(entries[3]); self.full_atoms.append(CartesianEntry(iatom, zVal, charge, \; el2masses[atomSym], atomSym, atomLabel, \; xval, yval, zval)). # handle first line of Zmat; elif len(entries) == 1:; zmatrix = True; tempfrag.append(iatom); self.full_atoms.append(ZMatrixEntry(iatom, zVal, charge, \; el2masses[atomSym], atomSym, atomLabel)). # handle second line of Zmat; elif len(entries) == 3:; zmatrix = True; tempfrag.append(iatom). rTo = self.get_anchor_atom(entries[1], line); if rTo >= iatom:; raise ValidationError(""Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[1])); rval = self.get_coord_value(entries[2]). if self.full",MatchSource.WIKI,psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html:18743,Security,Validat,ValidationError,18743," # Save the actual atom symbol (H1 => H); atomSym = re.split('(\d+)', atomLabel)[0].upper(). # Check that the atom symbol is valid; if not atomSym in el2z:; raise ValidationError('Illegal atom symbol in geometry specification: %s' % (atomSym)). zVal = el2z[atomSym]; charge = float(zVal); if ghostAtom:; zVal = 0; charge = 0.0. # handle cartesians; if len(entries) == 4:; tempfrag.append(iatom); xval = self.get_coord_value(entries[1]); yval = self.get_coord_value(entries[2]); zval = self.get_coord_value(entries[3]); self.full_atoms.append(CartesianEntry(iatom, zVal, charge, \; el2masses[atomSym], atomSym, atomLabel, \; xval, yval, zval)). # handle first line of Zmat; elif len(entries) == 1:; zmatrix = True; tempfrag.append(iatom); self.full_atoms.append(ZMatrixEntry(iatom, zVal, charge, \; el2masses[atomSym], atomSym, atomLabel)). # handle second line of Zmat; elif len(entries) == 3:; zmatrix = True; tempfrag.append(iatom). rTo = self.get_anchor_atom(entries[1], line); if rTo >= iatom:; raise ValidationError(""Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[1])); rval = self.get_coord_value(entries[2]). if self.full_atoms[rTo].symbol() == 'X':; rval.set_fixed(True). self.full_atoms.append(ZMatrixEntry(iatom, zVal, charge, \; el2masses[atomSym], atomSym, atomLabel, \; self.full_atoms[rTo], rval)). # handle third line of Zmat; elif len(entries) == 5:; zmatrix = True; tempfrag.append(iatom). rTo = self.get_anchor_atom(entries[1], line); if rTo >= iatom:; raise ValidationError(""Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[1])); aTo = self.get_anchor_atom(entries[3], line); if aTo >= iatom:; raise ValidationError(""Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[3])); if aTo == rTo:; raise ValidationError(""Atom used multiple times on line %s."" % (line)); rval = self.get_coord_value(entries[2]); aval = self.get_coord_value(entries[4]). if self.full_atoms[rTo]",MatchSource.WIKI,psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html:19255,Security,Validat,ValidationError,19255,"s[3]); self.full_atoms.append(CartesianEntry(iatom, zVal, charge, \; el2masses[atomSym], atomSym, atomLabel, \; xval, yval, zval)). # handle first line of Zmat; elif len(entries) == 1:; zmatrix = True; tempfrag.append(iatom); self.full_atoms.append(ZMatrixEntry(iatom, zVal, charge, \; el2masses[atomSym], atomSym, atomLabel)). # handle second line of Zmat; elif len(entries) == 3:; zmatrix = True; tempfrag.append(iatom). rTo = self.get_anchor_atom(entries[1], line); if rTo >= iatom:; raise ValidationError(""Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[1])); rval = self.get_coord_value(entries[2]). if self.full_atoms[rTo].symbol() == 'X':; rval.set_fixed(True). self.full_atoms.append(ZMatrixEntry(iatom, zVal, charge, \; el2masses[atomSym], atomSym, atomLabel, \; self.full_atoms[rTo], rval)). # handle third line of Zmat; elif len(entries) == 5:; zmatrix = True; tempfrag.append(iatom). rTo = self.get_anchor_atom(entries[1], line); if rTo >= iatom:; raise ValidationError(""Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[1])); aTo = self.get_anchor_atom(entries[3], line); if aTo >= iatom:; raise ValidationError(""Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[3])); if aTo == rTo:; raise ValidationError(""Atom used multiple times on line %s."" % (line)); rval = self.get_coord_value(entries[2]); aval = self.get_coord_value(entries[4]). if self.full_atoms[rTo].symbol() == 'X':; rval.set_fixed(True); if self.full_atoms[aTo].symbol() == 'X':; aval.set_fixed(True). self.full_atoms.append(ZMatrixEntry(iatom, zVal, charge, \; el2masses[atomSym], atomSym, atomLabel, \; self.full_atoms[rTo], rval, \; self.full_atoms[aTo], aval)). # handle fourth line of Zmat; elif len(entries) == 7:; zmatrix = True; tempfrag.append(iatom). rTo = self.get_anchor_atom(entries[1], line); if rTo >= iatom:; raise ValidationError(""Error on geometry input line %s. Atom %s has not been defined",MatchSource.WIKI,psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html:19435,Security,Validat,ValidationError,19435,"= 1:; zmatrix = True; tempfrag.append(iatom); self.full_atoms.append(ZMatrixEntry(iatom, zVal, charge, \; el2masses[atomSym], atomSym, atomLabel)). # handle second line of Zmat; elif len(entries) == 3:; zmatrix = True; tempfrag.append(iatom). rTo = self.get_anchor_atom(entries[1], line); if rTo >= iatom:; raise ValidationError(""Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[1])); rval = self.get_coord_value(entries[2]). if self.full_atoms[rTo].symbol() == 'X':; rval.set_fixed(True). self.full_atoms.append(ZMatrixEntry(iatom, zVal, charge, \; el2masses[atomSym], atomSym, atomLabel, \; self.full_atoms[rTo], rval)). # handle third line of Zmat; elif len(entries) == 5:; zmatrix = True; tempfrag.append(iatom). rTo = self.get_anchor_atom(entries[1], line); if rTo >= iatom:; raise ValidationError(""Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[1])); aTo = self.get_anchor_atom(entries[3], line); if aTo >= iatom:; raise ValidationError(""Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[3])); if aTo == rTo:; raise ValidationError(""Atom used multiple times on line %s."" % (line)); rval = self.get_coord_value(entries[2]); aval = self.get_coord_value(entries[4]). if self.full_atoms[rTo].symbol() == 'X':; rval.set_fixed(True); if self.full_atoms[aTo].symbol() == 'X':; aval.set_fixed(True). self.full_atoms.append(ZMatrixEntry(iatom, zVal, charge, \; el2masses[atomSym], atomSym, atomLabel, \; self.full_atoms[rTo], rval, \; self.full_atoms[aTo], aval)). # handle fourth line of Zmat; elif len(entries) == 7:; zmatrix = True; tempfrag.append(iatom). rTo = self.get_anchor_atom(entries[1], line); if rTo >= iatom:; raise ValidationError(""Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[1])); aTo = self.get_anchor_atom(entries[3], line); if aTo >= iatom:; raise ValidationError(""Error on geometry input line %s. Atom %s has not been defined",MatchSource.WIKI,psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html:19567,Security,Validat,ValidationError,19567,"Label)). # handle second line of Zmat; elif len(entries) == 3:; zmatrix = True; tempfrag.append(iatom). rTo = self.get_anchor_atom(entries[1], line); if rTo >= iatom:; raise ValidationError(""Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[1])); rval = self.get_coord_value(entries[2]). if self.full_atoms[rTo].symbol() == 'X':; rval.set_fixed(True). self.full_atoms.append(ZMatrixEntry(iatom, zVal, charge, \; el2masses[atomSym], atomSym, atomLabel, \; self.full_atoms[rTo], rval)). # handle third line of Zmat; elif len(entries) == 5:; zmatrix = True; tempfrag.append(iatom). rTo = self.get_anchor_atom(entries[1], line); if rTo >= iatom:; raise ValidationError(""Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[1])); aTo = self.get_anchor_atom(entries[3], line); if aTo >= iatom:; raise ValidationError(""Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[3])); if aTo == rTo:; raise ValidationError(""Atom used multiple times on line %s."" % (line)); rval = self.get_coord_value(entries[2]); aval = self.get_coord_value(entries[4]). if self.full_atoms[rTo].symbol() == 'X':; rval.set_fixed(True); if self.full_atoms[aTo].symbol() == 'X':; aval.set_fixed(True). self.full_atoms.append(ZMatrixEntry(iatom, zVal, charge, \; el2masses[atomSym], atomSym, atomLabel, \; self.full_atoms[rTo], rval, \; self.full_atoms[aTo], aval)). # handle fourth line of Zmat; elif len(entries) == 7:; zmatrix = True; tempfrag.append(iatom). rTo = self.get_anchor_atom(entries[1], line); if rTo >= iatom:; raise ValidationError(""Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[1])); aTo = self.get_anchor_atom(entries[3], line); if aTo >= iatom:; raise ValidationError(""Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[3])); dTo = self.get_anchor_atom(entries[5], line); if dTo >= iatom:; raise ValidationError(""Error on geometry in",MatchSource.WIKI,psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html:20172,Security,Validat,ValidationError,20172,"ag.append(iatom). rTo = self.get_anchor_atom(entries[1], line); if rTo >= iatom:; raise ValidationError(""Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[1])); aTo = self.get_anchor_atom(entries[3], line); if aTo >= iatom:; raise ValidationError(""Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[3])); if aTo == rTo:; raise ValidationError(""Atom used multiple times on line %s."" % (line)); rval = self.get_coord_value(entries[2]); aval = self.get_coord_value(entries[4]). if self.full_atoms[rTo].symbol() == 'X':; rval.set_fixed(True); if self.full_atoms[aTo].symbol() == 'X':; aval.set_fixed(True). self.full_atoms.append(ZMatrixEntry(iatom, zVal, charge, \; el2masses[atomSym], atomSym, atomLabel, \; self.full_atoms[rTo], rval, \; self.full_atoms[aTo], aval)). # handle fourth line of Zmat; elif len(entries) == 7:; zmatrix = True; tempfrag.append(iatom). rTo = self.get_anchor_atom(entries[1], line); if rTo >= iatom:; raise ValidationError(""Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[1])); aTo = self.get_anchor_atom(entries[3], line); if aTo >= iatom:; raise ValidationError(""Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[3])); dTo = self.get_anchor_atom(entries[5], line); if dTo >= iatom:; raise ValidationError(""Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[5])); if aTo == rTo or rTo == dTo or aTo == dTo: # for you star wars fans; raise ValidationError(""Atom used multiple times on line %s"" % (line)). rval = self.get_coord_value(entries[2]); aval = self.get_coord_value(entries[4]); dval = self.get_coord_value(entries[6]). if self.full_atoms[rTo].symbol() == 'X':; rval.set_fixed(True); if self.full_atoms[aTo].symbol() == 'X':; aval.set_fixed(True); if self.full_atoms[dTo].symbol() == 'X':; dval.set_fixed(True). self.full_atoms.append(ZMatrixEntry(iatom, zVal, charge, \; el2masses[",MatchSource.WIKI,psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html:20352,Security,Validat,ValidationError,20352,"ne, entries[1])); aTo = self.get_anchor_atom(entries[3], line); if aTo >= iatom:; raise ValidationError(""Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[3])); if aTo == rTo:; raise ValidationError(""Atom used multiple times on line %s."" % (line)); rval = self.get_coord_value(entries[2]); aval = self.get_coord_value(entries[4]). if self.full_atoms[rTo].symbol() == 'X':; rval.set_fixed(True); if self.full_atoms[aTo].symbol() == 'X':; aval.set_fixed(True). self.full_atoms.append(ZMatrixEntry(iatom, zVal, charge, \; el2masses[atomSym], atomSym, atomLabel, \; self.full_atoms[rTo], rval, \; self.full_atoms[aTo], aval)). # handle fourth line of Zmat; elif len(entries) == 7:; zmatrix = True; tempfrag.append(iatom). rTo = self.get_anchor_atom(entries[1], line); if rTo >= iatom:; raise ValidationError(""Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[1])); aTo = self.get_anchor_atom(entries[3], line); if aTo >= iatom:; raise ValidationError(""Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[3])); dTo = self.get_anchor_atom(entries[5], line); if dTo >= iatom:; raise ValidationError(""Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[5])); if aTo == rTo or rTo == dTo or aTo == dTo: # for you star wars fans; raise ValidationError(""Atom used multiple times on line %s"" % (line)). rval = self.get_coord_value(entries[2]); aval = self.get_coord_value(entries[4]); dval = self.get_coord_value(entries[6]). if self.full_atoms[rTo].symbol() == 'X':; rval.set_fixed(True); if self.full_atoms[aTo].symbol() == 'X':; aval.set_fixed(True); if self.full_atoms[dTo].symbol() == 'X':; dval.set_fixed(True). self.full_atoms.append(ZMatrixEntry(iatom, zVal, charge, \; el2masses[atomSym], atomSym, atomLabel, \; self.full_atoms[rTo], rval, \; self.full_atoms[aTo], aval, \; self.full_atoms[dTo], dval)). else:; raise ValidationError('Illegal geometry specific",MatchSource.WIKI,psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html:20532,Security,Validat,ValidationError,20532,"ne, entries[3])); if aTo == rTo:; raise ValidationError(""Atom used multiple times on line %s."" % (line)); rval = self.get_coord_value(entries[2]); aval = self.get_coord_value(entries[4]). if self.full_atoms[rTo].symbol() == 'X':; rval.set_fixed(True); if self.full_atoms[aTo].symbol() == 'X':; aval.set_fixed(True). self.full_atoms.append(ZMatrixEntry(iatom, zVal, charge, \; el2masses[atomSym], atomSym, atomLabel, \; self.full_atoms[rTo], rval, \; self.full_atoms[aTo], aval)). # handle fourth line of Zmat; elif len(entries) == 7:; zmatrix = True; tempfrag.append(iatom). rTo = self.get_anchor_atom(entries[1], line); if rTo >= iatom:; raise ValidationError(""Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[1])); aTo = self.get_anchor_atom(entries[3], line); if aTo >= iatom:; raise ValidationError(""Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[3])); dTo = self.get_anchor_atom(entries[5], line); if dTo >= iatom:; raise ValidationError(""Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[5])); if aTo == rTo or rTo == dTo or aTo == dTo: # for you star wars fans; raise ValidationError(""Atom used multiple times on line %s"" % (line)). rval = self.get_coord_value(entries[2]); aval = self.get_coord_value(entries[4]); dval = self.get_coord_value(entries[6]). if self.full_atoms[rTo].symbol() == 'X':; rval.set_fixed(True); if self.full_atoms[aTo].symbol() == 'X':; aval.set_fixed(True); if self.full_atoms[dTo].symbol() == 'X':; dval.set_fixed(True). self.full_atoms.append(ZMatrixEntry(iatom, zVal, charge, \; el2masses[atomSym], atomSym, atomLabel, \; self.full_atoms[rTo], rval, \; self.full_atoms[aTo], aval, \; self.full_atoms[dTo], dval)). else:; raise ValidationError('Illegal geometry specification line : %s. \; You should provide either Z-Matrix or Cartesian input' % (line)). iatom += 1. self.fragments.append([tempfrag[0], tempfrag[-1]]); self.fragment_types.append('Re",MatchSource.WIKI,psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html:20717,Security,Validat,ValidationError,20717,"lue(entries[4]). if self.full_atoms[rTo].symbol() == 'X':; rval.set_fixed(True); if self.full_atoms[aTo].symbol() == 'X':; aval.set_fixed(True). self.full_atoms.append(ZMatrixEntry(iatom, zVal, charge, \; el2masses[atomSym], atomSym, atomLabel, \; self.full_atoms[rTo], rval, \; self.full_atoms[aTo], aval)). # handle fourth line of Zmat; elif len(entries) == 7:; zmatrix = True; tempfrag.append(iatom). rTo = self.get_anchor_atom(entries[1], line); if rTo >= iatom:; raise ValidationError(""Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[1])); aTo = self.get_anchor_atom(entries[3], line); if aTo >= iatom:; raise ValidationError(""Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[3])); dTo = self.get_anchor_atom(entries[5], line); if dTo >= iatom:; raise ValidationError(""Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[5])); if aTo == rTo or rTo == dTo or aTo == dTo: # for you star wars fans; raise ValidationError(""Atom used multiple times on line %s"" % (line)). rval = self.get_coord_value(entries[2]); aval = self.get_coord_value(entries[4]); dval = self.get_coord_value(entries[6]). if self.full_atoms[rTo].symbol() == 'X':; rval.set_fixed(True); if self.full_atoms[aTo].symbol() == 'X':; aval.set_fixed(True); if self.full_atoms[dTo].symbol() == 'X':; dval.set_fixed(True). self.full_atoms.append(ZMatrixEntry(iatom, zVal, charge, \; el2masses[atomSym], atomSym, atomLabel, \; self.full_atoms[rTo], rval, \; self.full_atoms[aTo], aval, \; self.full_atoms[dTo], dval)). else:; raise ValidationError('Illegal geometry specification line : %s. \; You should provide either Z-Matrix or Cartesian input' % (line)). iatom += 1. self.fragments.append([tempfrag[0], tempfrag[-1]]); self.fragment_types.append('Real'); self.set_has_zmatrix(zmatrix). [docs] def init_with_checkpoint(self, chkpt):; """""" **NYI** Pull information from the *chkpt* object passed; (method name in libmints i",MatchSource.WIKI,psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html:21305,Security,Validat,ValidationError,21305," if aTo >= iatom:; raise ValidationError(""Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[3])); dTo = self.get_anchor_atom(entries[5], line); if dTo >= iatom:; raise ValidationError(""Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[5])); if aTo == rTo or rTo == dTo or aTo == dTo: # for you star wars fans; raise ValidationError(""Atom used multiple times on line %s"" % (line)). rval = self.get_coord_value(entries[2]); aval = self.get_coord_value(entries[4]); dval = self.get_coord_value(entries[6]). if self.full_atoms[rTo].symbol() == 'X':; rval.set_fixed(True); if self.full_atoms[aTo].symbol() == 'X':; aval.set_fixed(True); if self.full_atoms[dTo].symbol() == 'X':; dval.set_fixed(True). self.full_atoms.append(ZMatrixEntry(iatom, zVal, charge, \; el2masses[atomSym], atomSym, atomLabel, \; self.full_atoms[rTo], rval, \; self.full_atoms[aTo], aval, \; self.full_atoms[dTo], dval)). else:; raise ValidationError('Illegal geometry specification line : %s. \; You should provide either Z-Matrix or Cartesian input' % (line)). iatom += 1. self.fragments.append([tempfrag[0], tempfrag[-1]]); self.fragment_types.append('Real'); self.set_has_zmatrix(zmatrix). [docs] def init_with_checkpoint(self, chkpt):; """""" **NYI** Pull information from the *chkpt* object passed; (method name in libmints is init_with_chkpt). """"""; raise FeatureNotImplemented('Molecule::init_with_checkpoint') # FINAL. [docs] def init_with_io(self, psio):; """""" **NYI** Pull information from a chkpt object created from psio; (method name in libmints is init_with_psio). """"""; raise FeatureNotImplemented('Molecule::init_with_io') # FINAL. @classmethod; [docs] def init_with_xyz(cls, xyzfilename):; """"""Pull information from an XYZ file. No fragment or chg/mult info detected. >>> H2O = qcdb.Molecule.init_with_xyz('h2o.xyz'). """"""; instance = cls(); instance.lock_frame = False. try:; infile = open(xyzfilename, 'r'); except IOError:; raise ValidationErro",MatchSource.WIKI,psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html:22313,Security,Validat,ValidationError,22313,"'Illegal geometry specification line : %s. \; You should provide either Z-Matrix or Cartesian input' % (line)). iatom += 1. self.fragments.append([tempfrag[0], tempfrag[-1]]); self.fragment_types.append('Real'); self.set_has_zmatrix(zmatrix). [docs] def init_with_checkpoint(self, chkpt):; """""" **NYI** Pull information from the *chkpt* object passed; (method name in libmints is init_with_chkpt). """"""; raise FeatureNotImplemented('Molecule::init_with_checkpoint') # FINAL. [docs] def init_with_io(self, psio):; """""" **NYI** Pull information from a chkpt object created from psio; (method name in libmints is init_with_psio). """"""; raise FeatureNotImplemented('Molecule::init_with_io') # FINAL. @classmethod; [docs] def init_with_xyz(cls, xyzfilename):; """"""Pull information from an XYZ file. No fragment or chg/mult info detected. >>> H2O = qcdb.Molecule.init_with_xyz('h2o.xyz'). """"""; instance = cls(); instance.lock_frame = False. try:; infile = open(xyzfilename, 'r'); except IOError:; raise ValidationError(""""""Molecule::init_with_xyz: given filename '%s' does not exist."""""" % (xyzfilename)); if os.stat(xyzfilename).st_size == 0:; raise ValidationError(""""""Molecule::init_with_xyz: given filename '%s' is blank."""""" % (xyzfilename)); text = infile.readlines(). xyz1 = re.compile(r""^\s*(\d+)\s*(bohr|au)?\s*$"", re.IGNORECASE); xyzN = re.compile(r""(?:\s*)([A-Z](?:[a-z])?)(?:\s+)(-?\d+\.\d+)(?:\s+)(-?\d+\.\d+)(?:\s+)(-?\d+\.\d+)(?:\s*)"", re.IGNORECASE). # Try to match the first line; if xyz1.match(text[0]):; fileNatom = int(xyz1.match(text[0]).group(1)); if xyz1.match(text[0]).group(2) == None:; fileUnits = 'Angstrom'; else:; fileUnits = 'Bohr'; else:; raise ValidationError(""Molecule::init_with_xyz: Malformed first line\n%s"" % (text[0])). # Skip the second line. # Next line begins the useful information.; for i in range(fileNatom):; try:; if xyzN.match(text[2 + i]):. fileAtom = xyzN.match(text[2 + i]).group(1).upper(); fileX = float(xyzN.match(text[2 + i]).group(2)); fileY = float(xyzN.match",MatchSource.WIKI,psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html:22459,Security,Validat,ValidationError,22459,"frag[-1]]); self.fragment_types.append('Real'); self.set_has_zmatrix(zmatrix). [docs] def init_with_checkpoint(self, chkpt):; """""" **NYI** Pull information from the *chkpt* object passed; (method name in libmints is init_with_chkpt). """"""; raise FeatureNotImplemented('Molecule::init_with_checkpoint') # FINAL. [docs] def init_with_io(self, psio):; """""" **NYI** Pull information from a chkpt object created from psio; (method name in libmints is init_with_psio). """"""; raise FeatureNotImplemented('Molecule::init_with_io') # FINAL. @classmethod; [docs] def init_with_xyz(cls, xyzfilename):; """"""Pull information from an XYZ file. No fragment or chg/mult info detected. >>> H2O = qcdb.Molecule.init_with_xyz('h2o.xyz'). """"""; instance = cls(); instance.lock_frame = False. try:; infile = open(xyzfilename, 'r'); except IOError:; raise ValidationError(""""""Molecule::init_with_xyz: given filename '%s' does not exist."""""" % (xyzfilename)); if os.stat(xyzfilename).st_size == 0:; raise ValidationError(""""""Molecule::init_with_xyz: given filename '%s' is blank."""""" % (xyzfilename)); text = infile.readlines(). xyz1 = re.compile(r""^\s*(\d+)\s*(bohr|au)?\s*$"", re.IGNORECASE); xyzN = re.compile(r""(?:\s*)([A-Z](?:[a-z])?)(?:\s+)(-?\d+\.\d+)(?:\s+)(-?\d+\.\d+)(?:\s+)(-?\d+\.\d+)(?:\s*)"", re.IGNORECASE). # Try to match the first line; if xyz1.match(text[0]):; fileNatom = int(xyz1.match(text[0]).group(1)); if xyz1.match(text[0]).group(2) == None:; fileUnits = 'Angstrom'; else:; fileUnits = 'Bohr'; else:; raise ValidationError(""Molecule::init_with_xyz: Malformed first line\n%s"" % (text[0])). # Skip the second line. # Next line begins the useful information.; for i in range(fileNatom):; try:; if xyzN.match(text[2 + i]):. fileAtom = xyzN.match(text[2 + i]).group(1).upper(); fileX = float(xyzN.match(text[2 + i]).group(2)); fileY = float(xyzN.match(text[2 + i]).group(3)); fileZ = float(xyzN.match(text[2 + i]).group(4)). # Coordinates in Molecule must be bohr.; if fileUnits == 'Angstrom':; fileX /= psi_bohr2an",MatchSource.WIKI,psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html:22982,Security,Validat,ValidationError,22982,"lecule::init_with_io') # FINAL. @classmethod; [docs] def init_with_xyz(cls, xyzfilename):; """"""Pull information from an XYZ file. No fragment or chg/mult info detected. >>> H2O = qcdb.Molecule.init_with_xyz('h2o.xyz'). """"""; instance = cls(); instance.lock_frame = False. try:; infile = open(xyzfilename, 'r'); except IOError:; raise ValidationError(""""""Molecule::init_with_xyz: given filename '%s' does not exist."""""" % (xyzfilename)); if os.stat(xyzfilename).st_size == 0:; raise ValidationError(""""""Molecule::init_with_xyz: given filename '%s' is blank."""""" % (xyzfilename)); text = infile.readlines(). xyz1 = re.compile(r""^\s*(\d+)\s*(bohr|au)?\s*$"", re.IGNORECASE); xyzN = re.compile(r""(?:\s*)([A-Z](?:[a-z])?)(?:\s+)(-?\d+\.\d+)(?:\s+)(-?\d+\.\d+)(?:\s+)(-?\d+\.\d+)(?:\s*)"", re.IGNORECASE). # Try to match the first line; if xyz1.match(text[0]):; fileNatom = int(xyz1.match(text[0]).group(1)); if xyz1.match(text[0]).group(2) == None:; fileUnits = 'Angstrom'; else:; fileUnits = 'Bohr'; else:; raise ValidationError(""Molecule::init_with_xyz: Malformed first line\n%s"" % (text[0])). # Skip the second line. # Next line begins the useful information.; for i in range(fileNatom):; try:; if xyzN.match(text[2 + i]):. fileAtom = xyzN.match(text[2 + i]).group(1).upper(); fileX = float(xyzN.match(text[2 + i]).group(2)); fileY = float(xyzN.match(text[2 + i]).group(3)); fileZ = float(xyzN.match(text[2 + i]).group(4)). # Coordinates in Molecule must be bohr.; if fileUnits == 'Angstrom':; fileX /= psi_bohr2angstroms; fileY /= psi_bohr2angstroms; fileZ /= psi_bohr2angstroms. # Check that the atom symbol is valid; if not fileAtom in el2z:; raise ValidationError('Illegal atom symbol in geometry specification: %s' % (atomSym)). # Add it to the molecule.; instance.add_atom(el2z[fileAtom], fileX, fileY, fileZ, fileAtom, el2masses[fileAtom]). else:; raise ValidationError(""Molecule::init_with_xyz: Malformed atom information line %d."" % (i + 3)); except IndexError:; raise ValidationError(""Molecule::init_",MatchSource.WIKI,psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html:23623,Security,Validat,ValidationError,23623,""", re.IGNORECASE); xyzN = re.compile(r""(?:\s*)([A-Z](?:[a-z])?)(?:\s+)(-?\d+\.\d+)(?:\s+)(-?\d+\.\d+)(?:\s+)(-?\d+\.\d+)(?:\s*)"", re.IGNORECASE). # Try to match the first line; if xyz1.match(text[0]):; fileNatom = int(xyz1.match(text[0]).group(1)); if xyz1.match(text[0]).group(2) == None:; fileUnits = 'Angstrom'; else:; fileUnits = 'Bohr'; else:; raise ValidationError(""Molecule::init_with_xyz: Malformed first line\n%s"" % (text[0])). # Skip the second line. # Next line begins the useful information.; for i in range(fileNatom):; try:; if xyzN.match(text[2 + i]):. fileAtom = xyzN.match(text[2 + i]).group(1).upper(); fileX = float(xyzN.match(text[2 + i]).group(2)); fileY = float(xyzN.match(text[2 + i]).group(3)); fileZ = float(xyzN.match(text[2 + i]).group(4)). # Coordinates in Molecule must be bohr.; if fileUnits == 'Angstrom':; fileX /= psi_bohr2angstroms; fileY /= psi_bohr2angstroms; fileZ /= psi_bohr2angstroms. # Check that the atom symbol is valid; if not fileAtom in el2z:; raise ValidationError('Illegal atom symbol in geometry specification: %s' % (atomSym)). # Add it to the molecule.; instance.add_atom(el2z[fileAtom], fileX, fileY, fileZ, fileAtom, el2masses[fileAtom]). else:; raise ValidationError(""Molecule::init_with_xyz: Malformed atom information line %d."" % (i + 3)); except IndexError:; raise ValidationError(""Molecule::init_with_xyz: Expected atom in file at line %d.\n%s"" % (i + 3, text[i + 2])). # We need to make 1 fragment with all atoms; instance.fragments.append([0, fileNatom - 1]); instance.fragment_types.append('Real'); instance.fragment_charges.append(0); instance.fragment_multiplicities.append(1); # Set the units to bohr since we did the conversion above, if needed.; instance.PYunits = 'Bohr'; instance.input_units_to_au = 1.0. instance.update_geometry(); return instance. [docs] def clone(self):; """"""Returns new, independent Molecule object. >>> dimer = H2OH2O.clone(). """"""; return copy.deepcopy(self). # <<< Methods for Printing >>>. [docs] def print_out",MatchSource.WIKI,psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html:23832,Security,Validat,ValidationError,23832,").group(1)); if xyz1.match(text[0]).group(2) == None:; fileUnits = 'Angstrom'; else:; fileUnits = 'Bohr'; else:; raise ValidationError(""Molecule::init_with_xyz: Malformed first line\n%s"" % (text[0])). # Skip the second line. # Next line begins the useful information.; for i in range(fileNatom):; try:; if xyzN.match(text[2 + i]):. fileAtom = xyzN.match(text[2 + i]).group(1).upper(); fileX = float(xyzN.match(text[2 + i]).group(2)); fileY = float(xyzN.match(text[2 + i]).group(3)); fileZ = float(xyzN.match(text[2 + i]).group(4)). # Coordinates in Molecule must be bohr.; if fileUnits == 'Angstrom':; fileX /= psi_bohr2angstroms; fileY /= psi_bohr2angstroms; fileZ /= psi_bohr2angstroms. # Check that the atom symbol is valid; if not fileAtom in el2z:; raise ValidationError('Illegal atom symbol in geometry specification: %s' % (atomSym)). # Add it to the molecule.; instance.add_atom(el2z[fileAtom], fileX, fileY, fileZ, fileAtom, el2masses[fileAtom]). else:; raise ValidationError(""Molecule::init_with_xyz: Malformed atom information line %d."" % (i + 3)); except IndexError:; raise ValidationError(""Molecule::init_with_xyz: Expected atom in file at line %d.\n%s"" % (i + 3, text[i + 2])). # We need to make 1 fragment with all atoms; instance.fragments.append([0, fileNatom - 1]); instance.fragment_types.append('Real'); instance.fragment_charges.append(0); instance.fragment_multiplicities.append(1); # Set the units to bohr since we did the conversion above, if needed.; instance.PYunits = 'Bohr'; instance.input_units_to_au = 1.0. instance.update_geometry(); return instance. [docs] def clone(self):; """"""Returns new, independent Molecule object. >>> dimer = H2OH2O.clone(). """"""; return copy.deepcopy(self). # <<< Methods for Printing >>>. [docs] def print_out(self):; """"""Print the molecule.; (method name in libmints is print). >>> H2OH2O.print_out(); Geometry (in Angstrom), charge = -2, multiplicity = 3:; Center X Y Z; ------------ ----------------- ----------------- -----------------; O -1.",MatchSource.WIKI,psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html:23949,Security,Validat,ValidationError,23949,"'; else:; raise ValidationError(""Molecule::init_with_xyz: Malformed first line\n%s"" % (text[0])). # Skip the second line. # Next line begins the useful information.; for i in range(fileNatom):; try:; if xyzN.match(text[2 + i]):. fileAtom = xyzN.match(text[2 + i]).group(1).upper(); fileX = float(xyzN.match(text[2 + i]).group(2)); fileY = float(xyzN.match(text[2 + i]).group(3)); fileZ = float(xyzN.match(text[2 + i]).group(4)). # Coordinates in Molecule must be bohr.; if fileUnits == 'Angstrom':; fileX /= psi_bohr2angstroms; fileY /= psi_bohr2angstroms; fileZ /= psi_bohr2angstroms. # Check that the atom symbol is valid; if not fileAtom in el2z:; raise ValidationError('Illegal atom symbol in geometry specification: %s' % (atomSym)). # Add it to the molecule.; instance.add_atom(el2z[fileAtom], fileX, fileY, fileZ, fileAtom, el2masses[fileAtom]). else:; raise ValidationError(""Molecule::init_with_xyz: Malformed atom information line %d."" % (i + 3)); except IndexError:; raise ValidationError(""Molecule::init_with_xyz: Expected atom in file at line %d.\n%s"" % (i + 3, text[i + 2])). # We need to make 1 fragment with all atoms; instance.fragments.append([0, fileNatom - 1]); instance.fragment_types.append('Real'); instance.fragment_charges.append(0); instance.fragment_multiplicities.append(1); # Set the units to bohr since we did the conversion above, if needed.; instance.PYunits = 'Bohr'; instance.input_units_to_au = 1.0. instance.update_geometry(); return instance. [docs] def clone(self):; """"""Returns new, independent Molecule object. >>> dimer = H2OH2O.clone(). """"""; return copy.deepcopy(self). # <<< Methods for Printing >>>. [docs] def print_out(self):; """"""Print the molecule.; (method name in libmints is print). >>> H2OH2O.print_out(); Geometry (in Angstrom), charge = -2, multiplicity = 3:; Center X Y Z; ------------ ----------------- ----------------- -----------------; O -1.551007000000 -0.114520000000 0.000000000000; H -1.934259000000 0.762503000000 0.000000000000; H -0.5996",MatchSource.WIKI,psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html:33429,Security,Validat,ValidationError,33429," minus the value); if vstr[0] == '-':; self.all_variables.append(vstr[1:]); return VariableValue(vstr[1:], self.geometry_variables, True). # handle normal variable values; else:; self.all_variables.append(vstr); return VariableValue(vstr, self.geometry_variables). [docs] def add_atom(self, Z, x, y, z, label="""", mass=0.0, charge=0.0, lineno=-1):; """"""Add an atom to the molecule; *Z* atomic number; *x* cartesian coordinate; *y* cartesian coordinate; *z* cartesian coordinate; *symb* atomic symbol to use; *mass* mass to use if non standard; *charge* charge to use if non standard; *lineno* line number when taken from a string. """"""; self.lock_frame = False. if self.atom_at_position([x, y, z]) == -1:; # Dummies go to full_atoms, ghosts need to go to both.; self.full_atoms.append(CartesianEntry(self.nallatom(), Z, charge, mass, label, label, \; NumberValue(x), NumberValue(y), NumberValue(z))); if label.upper() != 'X':; self.atoms.append(self.full_atoms[-1]); else:; raise ValidationError(""Molecule::add_atom: Adding atom on top of an existing atom.""). [docs] def atom_entry(self, atom):; """"""Returns the CoordEntry for an atom.""""""; return self.atoms[atom]. [docs] def atom_at_position(self, b, tol=0.05):; """"""Tests to see of an atom is at the passed position *b* in Bohr with a tolerance *tol*. >>> print H2OH2O.atom_at_position([1.35*(1.0/psi_bohr2angstroms), 0.10*(1.0/psi_bohr2angstroms), 0.0*(1.0/psi_bohr2angstroms)]); 3. """"""; if len(b) != 3:; raise ValidationError('ERROR: atom_at_position() requires as argument a vector of length 3\n'). for at in range(self.natom()):; a = self.xyz(at); if distance(b, a) < tol:; return at; return -1. [docs] def is_variable(self, vstr):; """"""Checks to see if the variable str is in the list, returns; true if it is, and returns false if not. >>> H2OH2O.is_variable('R'); False. """"""; return True if vstr.upper() in self.all_variables else False. [docs] def get_variable(self, vstr):; """"""Checks to see if the variable str is in the list, sets it to; val and",MatchSource.WIKI,psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html:33911,Security,Validat,ValidationError,33911,"c symbol to use; *mass* mass to use if non standard; *charge* charge to use if non standard; *lineno* line number when taken from a string. """"""; self.lock_frame = False. if self.atom_at_position([x, y, z]) == -1:; # Dummies go to full_atoms, ghosts need to go to both.; self.full_atoms.append(CartesianEntry(self.nallatom(), Z, charge, mass, label, label, \; NumberValue(x), NumberValue(y), NumberValue(z))); if label.upper() != 'X':; self.atoms.append(self.full_atoms[-1]); else:; raise ValidationError(""Molecule::add_atom: Adding atom on top of an existing atom.""). [docs] def atom_entry(self, atom):; """"""Returns the CoordEntry for an atom.""""""; return self.atoms[atom]. [docs] def atom_at_position(self, b, tol=0.05):; """"""Tests to see of an atom is at the passed position *b* in Bohr with a tolerance *tol*. >>> print H2OH2O.atom_at_position([1.35*(1.0/psi_bohr2angstroms), 0.10*(1.0/psi_bohr2angstroms), 0.0*(1.0/psi_bohr2angstroms)]); 3. """"""; if len(b) != 3:; raise ValidationError('ERROR: atom_at_position() requires as argument a vector of length 3\n'). for at in range(self.natom()):; a = self.xyz(at); if distance(b, a) < tol:; return at; return -1. [docs] def is_variable(self, vstr):; """"""Checks to see if the variable str is in the list, returns; true if it is, and returns false if not. >>> H2OH2O.is_variable('R'); False. """"""; return True if vstr.upper() in self.all_variables else False. [docs] def get_variable(self, vstr):; """"""Checks to see if the variable str is in the list, sets it to; val and returns true if it is, and returns false if not. """"""; vstr = vstr.upper(); try:; return self.geometry_variables[vstr]; except KeyError:; raise ValidationError('ERROR: Geometry variable %s not known.\n' % (vstr)). [docs] def set_variable(self, vstr, val):; """"""Assigns the value val to the variable labelled string in the; list of geometry variables. Also calls update_geometry(). """"""; self.__dict__['lock_frame'] = False; self.__dict__['geometry_variables'][vstr.upper()] = val; print ""Set",MatchSource.WIKI,psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html:34596,Security,Validat,ValidationError,34596,"f.atoms[atom]. [docs] def atom_at_position(self, b, tol=0.05):; """"""Tests to see of an atom is at the passed position *b* in Bohr with a tolerance *tol*. >>> print H2OH2O.atom_at_position([1.35*(1.0/psi_bohr2angstroms), 0.10*(1.0/psi_bohr2angstroms), 0.0*(1.0/psi_bohr2angstroms)]); 3. """"""; if len(b) != 3:; raise ValidationError('ERROR: atom_at_position() requires as argument a vector of length 3\n'). for at in range(self.natom()):; a = self.xyz(at); if distance(b, a) < tol:; return at; return -1. [docs] def is_variable(self, vstr):; """"""Checks to see if the variable str is in the list, returns; true if it is, and returns false if not. >>> H2OH2O.is_variable('R'); False. """"""; return True if vstr.upper() in self.all_variables else False. [docs] def get_variable(self, vstr):; """"""Checks to see if the variable str is in the list, sets it to; val and returns true if it is, and returns false if not. """"""; vstr = vstr.upper(); try:; return self.geometry_variables[vstr]; except KeyError:; raise ValidationError('ERROR: Geometry variable %s not known.\n' % (vstr)). [docs] def set_variable(self, vstr, val):; """"""Assigns the value val to the variable labelled string in the; list of geometry variables. Also calls update_geometry(). """"""; self.__dict__['lock_frame'] = False; self.__dict__['geometry_variables'][vstr.upper()] = val; print ""Setting geometry variable %s to %f"" % (vstr.upper(), val); try:; self.update_geometry(); except IncompleteAtomError:; # Update geometry might have added some atoms, delete them to be safe.; self.atoms = []; # TODO outfile. def __setattr__(self, name, value):; """"""Function to overload setting attributes to allow geometry; variable assigment as if member data. """"""; try:; if name.upper() in self.__dict__['all_variables']:; self.set_variable(name, value); else:; self.__dict__[name] = value; except KeyError:; self.__dict__[name] = value. def __getattr__(self, name):; """"""Function to overload accessing attribute contents to allow; retrivial geometry variable va",MatchSource.WIKI,psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html:35530,Security,access,accessing,35530,"ometry_variables[vstr]; except KeyError:; raise ValidationError('ERROR: Geometry variable %s not known.\n' % (vstr)). [docs] def set_variable(self, vstr, val):; """"""Assigns the value val to the variable labelled string in the; list of geometry variables. Also calls update_geometry(). """"""; self.__dict__['lock_frame'] = False; self.__dict__['geometry_variables'][vstr.upper()] = val; print ""Setting geometry variable %s to %f"" % (vstr.upper(), val); try:; self.update_geometry(); except IncompleteAtomError:; # Update geometry might have added some atoms, delete them to be safe.; self.atoms = []; # TODO outfile. def __setattr__(self, name, value):; """"""Function to overload setting attributes to allow geometry; variable assigment as if member data. """"""; try:; if name.upper() in self.__dict__['all_variables']:; self.set_variable(name, value); else:; self.__dict__[name] = value; except KeyError:; self.__dict__[name] = value. def __getattr__(self, name):; """"""Function to overload accessing attribute contents to allow; retrivial geometry variable values as if member data. """"""; if not name in self.__dict__:; if object.__getattribute__(self, 'is_variable')(name):; return object.__getattribute__(self, 'get_variable')(name); else:; raise AttributeError; else:; return self.__dict__[name]. [docs] def get_anchor_atom(self, vstr, line):; """"""Attempts to interpret a string *vstr* as an atom specifier in; a zmatrix. Takes the current *line* for error message printing.; Returns the atom number (adjusted to zero-based counting). """"""; integerNumber = re.compile(r""(-?\d+)"", re.IGNORECASE); if integerNumber.match(vstr):; # This is just a number, return it; return int(vstr) - 1; else:; # Look to see if this string is known; for i in range(self.nallatom()):; if self.full_atoms[i].label() == vstr:; return i; raise ValidationError(""Illegal value %s in atom specification on line %s.\n"" % (vstr, line)). [docs] def geometry(self):; """"""Returns the geometry in Bohr as a N X 3 array. >>> print H2OH2O.geome",MatchSource.WIKI,psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html:36361,Security,Validat,ValidationError,36361,"e(name, value); else:; self.__dict__[name] = value; except KeyError:; self.__dict__[name] = value. def __getattr__(self, name):; """"""Function to overload accessing attribute contents to allow; retrivial geometry variable values as if member data. """"""; if not name in self.__dict__:; if object.__getattribute__(self, 'is_variable')(name):; return object.__getattribute__(self, 'get_variable')(name); else:; raise AttributeError; else:; return self.__dict__[name]. [docs] def get_anchor_atom(self, vstr, line):; """"""Attempts to interpret a string *vstr* as an atom specifier in; a zmatrix. Takes the current *line* for error message printing.; Returns the atom number (adjusted to zero-based counting). """"""; integerNumber = re.compile(r""(-?\d+)"", re.IGNORECASE); if integerNumber.match(vstr):; # This is just a number, return it; return int(vstr) - 1; else:; # Look to see if this string is known; for i in range(self.nallatom()):; if self.full_atoms[i].label() == vstr:; return i; raise ValidationError(""Illegal value %s in atom specification on line %s.\n"" % (vstr, line)). [docs] def geometry(self):; """"""Returns the geometry in Bohr as a N X 3 array. >>> print H2OH2O.geometry(); [[-2.930978460188563, -0.21641143673806384, 0.0], [-3.655219780069251, 1.4409218455037016, 0.0], [-1.1332252981904638, 0.0769345303220403, 0.0], [2.5523113582286716, 0.21064588230662976, 0.0], [3.175492014248769, -0.7062681346308132, -1.4334725450878665], [3.175492014248769, -0.7062681346308132, 1.4334725450878665]]. """"""; geom = []; for at in range(self.natom()):; geom.append([self.x(at), self.y(at), self.z(at)]); return geom. [docs] def full_geometry(self):; """"""Returns the full (dummies included) geometry in Bohr as a N X 3 array. >>> print H2OH2O.full_geometry(); [[-2.930978460188563, -0.21641143673806384, 0.0], [-3.655219780069251, 1.4409218455037016, 0.0], [-1.1332252981904638, 0.0769345303220403, 0.0], [0.0, 0.0, 0.0], [2.5523113582286716, 0.21064588230662976, 0.0], [3.175492014248769, -0.7062681346308132,",MatchSource.WIKI,psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html:45146,Security,Validat,ValidationError,45146,"ty += self.fragment_multiplicities[fr] - 1. for at in range(self.fragments[fr][0], self.fragments[fr][1] + 1):; self.full_atoms[at].compute(); self.full_atoms[at].set_ghosted(self.fragment_types[fr] == 'Ghost'); if self.full_atoms[at].symbol() != 'X':; self.atoms.append(self.full_atoms[at]). # TODO: This is a hack to ensure that set_multiplicity and set_molecular_charge; # work for single-fragment molecules.; if self.nfragments() < 2:; self.PYmolecular_charge = temp_charge; self.PYmultiplicity = temp_multiplicity. [docs] def update_geometry(self):; """"""Updates the geometry, by (re)interpreting the string used to; create the molecule, and the current values of the variables.; The atoms list is cleared, and then rebuilt by this routine.; This function must be called after first instantiation of Molecule. >>> H2 = qcdb.Molecule(""H\\nH 1 0.74\\n""); >>> print H2.natom(); 0; >>> H2.update_geometry(); >>> print H2.natom(); 2. """"""; if self.nfragments() == 0:; raise ValidationError(""Molecule::update_geometry: There are no fragments in this molecule.""). # Idempotence condition; if self.lock_frame:; return. #print ""beginning update_geometry:""; #self.print_full(); if self.PYreinterpret_coordentries:; self.reinterpret_coordentries(); #print ""after reinterpret_coordentries:""; #self.print_full(). if self.PYmove_to_com:; self.move_to_com(); #print ""after com:""; #self.print_full(). # If the no_reorient command was given, don't reorient; if not self.PYfix_orientation:; # Now we need to rotate the geometry to its symmetry frame; # to align the axes correctly for the point group; # symmetry_frame looks for the highest point group so that we can align; # the molecule according to its actual symmetry, rather than the symmetry; # the the user might have provided.; frame = self.symmetry_frame(); self.rotate_full(frame); #print ""after rotate:""; #self.print_full(). # Recompute point group of the molecule, so the symmetry info is updated to the new frame; # TODO self.set_point_group(self.find_",MatchSource.WIKI,psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html:49686,Security,Validat,ValidationError,49686,"ed('Molecule::set_basis_by_number') # FINAL. [docs] def set_basis_by_label(self, label, name, type=""BASIS""):; """""" **NYI** Assigns basis *name* to all atoms with *label*.""""""; raise FeatureNotImplemented('Molecule::set_basis_by_label') # FINAL. [docs] def nfrozen_core(self, depth=False):; """"""Number of frozen core for molecule given freezing state. >>> print H2OH2O.nfrozen_core(); 2. """"""; if depth == False or depth.upper() == 'FALSE':; return 0. elif depth == True or depth.upper() == 'TRUE':; # Freeze the number of core electrons corresponding to the; # nearest previous noble gas atom. This means that the 4p block; # will still have 3d electrons active. Alkali earth atoms will; # have one valence electron in this scheme.; nfzc = 0; for A in range(self.natom()):; if self.Z(A) > 2:; nfzc += 1; if self.Z(A) > 10:; nfzc += 4; if self.Z(A) > 18:; nfzc += 4; if self.Z(A) > 36:; nfzc += 9; if self.Z(A) > 54:; nfzc += 9; if self.Z(A) > 86:; nfzc += 16; if self.Z(A) > 108:; raise ValidationError(""Invalid atomic number""); return nfzc. else:; raise ValidationError(""Frozen core '%s' is not supported, options are {true, false}."" % (depth)). # <<< Involved Methods for Frame >>>. [docs] def translate(self, r):; """"""Translates molecule by r. >>> H2OH2O.translate([1.0, 1.0, 0.0]). """"""; temp = [None, None, None]; for at in range(self.nallatom()):; temp = scale(self.full_atoms[at].compute(), self.input_units_to_au); temp = add(temp, r); temp = scale(temp, 1.0 / self.input_units_to_au); self.full_atoms[at].set_coordinates(temp[0], temp[1], temp[2]). [docs] def center_of_mass(self):; """"""Computes center of mass of molecule (does not translate molecule). >>> H2OH2O.center_of_mass(); [-0.12442647346606871, 0.00038657002584110707, 0.0]. """"""; ret = [0.0, 0.0, 0.0]; total_m = 0.0. for at in range(self.natom()):; m = self.mass(at); ret = add(ret, scale(self.xyz(at), m)); total_m += m. ret = scale(ret, 1.0 / total_m); return ret. [docs] def move_to_com(self):; """"""Moves molecule to center of mass. """"",MatchSource.WIKI,psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html:49754,Security,Validat,ValidationError,49754,"bel, name, type=""BASIS""):; """""" **NYI** Assigns basis *name* to all atoms with *label*.""""""; raise FeatureNotImplemented('Molecule::set_basis_by_label') # FINAL. [docs] def nfrozen_core(self, depth=False):; """"""Number of frozen core for molecule given freezing state. >>> print H2OH2O.nfrozen_core(); 2. """"""; if depth == False or depth.upper() == 'FALSE':; return 0. elif depth == True or depth.upper() == 'TRUE':; # Freeze the number of core electrons corresponding to the; # nearest previous noble gas atom. This means that the 4p block; # will still have 3d electrons active. Alkali earth atoms will; # have one valence electron in this scheme.; nfzc = 0; for A in range(self.natom()):; if self.Z(A) > 2:; nfzc += 1; if self.Z(A) > 10:; nfzc += 4; if self.Z(A) > 18:; nfzc += 4; if self.Z(A) > 36:; nfzc += 9; if self.Z(A) > 54:; nfzc += 9; if self.Z(A) > 86:; nfzc += 16; if self.Z(A) > 108:; raise ValidationError(""Invalid atomic number""); return nfzc. else:; raise ValidationError(""Frozen core '%s' is not supported, options are {true, false}."" % (depth)). # <<< Involved Methods for Frame >>>. [docs] def translate(self, r):; """"""Translates molecule by r. >>> H2OH2O.translate([1.0, 1.0, 0.0]). """"""; temp = [None, None, None]; for at in range(self.nallatom()):; temp = scale(self.full_atoms[at].compute(), self.input_units_to_au); temp = add(temp, r); temp = scale(temp, 1.0 / self.input_units_to_au); self.full_atoms[at].set_coordinates(temp[0], temp[1], temp[2]). [docs] def center_of_mass(self):; """"""Computes center of mass of molecule (does not translate molecule). >>> H2OH2O.center_of_mass(); [-0.12442647346606871, 0.00038657002584110707, 0.0]. """"""; ret = [0.0, 0.0, 0.0]; total_m = 0.0. for at in range(self.natom()):; m = self.mass(at); ret = add(ret, scale(self.xyz(at), m)); total_m += m. ret = scale(ret, 1.0 / total_m); return ret. [docs] def move_to_com(self):; """"""Moves molecule to center of mass. """"""; com = scale(self.center_of_mass(), -1.0); self.translate(com). [docs] def set_c",MatchSource.WIKI,psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html:33665,Testability,Test,Tests,33665,"y_variables). [docs] def add_atom(self, Z, x, y, z, label="""", mass=0.0, charge=0.0, lineno=-1):; """"""Add an atom to the molecule; *Z* atomic number; *x* cartesian coordinate; *y* cartesian coordinate; *z* cartesian coordinate; *symb* atomic symbol to use; *mass* mass to use if non standard; *charge* charge to use if non standard; *lineno* line number when taken from a string. """"""; self.lock_frame = False. if self.atom_at_position([x, y, z]) == -1:; # Dummies go to full_atoms, ghosts need to go to both.; self.full_atoms.append(CartesianEntry(self.nallatom(), Z, charge, mass, label, label, \; NumberValue(x), NumberValue(y), NumberValue(z))); if label.upper() != 'X':; self.atoms.append(self.full_atoms[-1]); else:; raise ValidationError(""Molecule::add_atom: Adding atom on top of an existing atom.""). [docs] def atom_entry(self, atom):; """"""Returns the CoordEntry for an atom.""""""; return self.atoms[atom]. [docs] def atom_at_position(self, b, tol=0.05):; """"""Tests to see of an atom is at the passed position *b* in Bohr with a tolerance *tol*. >>> print H2OH2O.atom_at_position([1.35*(1.0/psi_bohr2angstroms), 0.10*(1.0/psi_bohr2angstroms), 0.0*(1.0/psi_bohr2angstroms)]); 3. """"""; if len(b) != 3:; raise ValidationError('ERROR: atom_at_position() requires as argument a vector of length 3\n'). for at in range(self.natom()):; a = self.xyz(at); if distance(b, a) < tol:; return at; return -1. [docs] def is_variable(self, vstr):; """"""Checks to see if the variable str is in the list, returns; true if it is, and returns false if not. >>> H2OH2O.is_variable('R'); False. """"""; return True if vstr.upper() in self.all_variables else False. [docs] def get_variable(self, vstr):; """"""Checks to see if the variable str is in the list, sets it to; val and returns true if it is, and returns false if not. """"""; vstr = vstr.upper(); try:; return self.geometry_variables[vstr]; except KeyError:; raise ValidationError('ERROR: Geometry variable %s not known.\n' % (vstr)). [docs] def set_variable(self, vstr, v",MatchSource.WIKI,psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html:4775,Usability,Simpl,Simple,4775,"r of mass or not?; self.PYmove_to_com = True; # Reorient or not? UNUSED; self.PYfix_orientation = False; # Reinterpret the coord entries or not (Default is true, except for findif); self.PYreinterpret_coordentries = True; # Nilpotence boolean (flagged upon first determination of symmetry frame,; # reset each time a substantiative change is made); self.lock_frame = False. # <<< Symmetry >>>. # Point group to use with this molecule UNUSED; self.pg = None; # Full point group UNUSED; self.full_pg = 'PG_C1'; # n of the highest rotational axis Cn UNUSED; self.full_pg_n = 1; # Symmetry string from geometry specification; self.PYsymmetry_from_input = 'C1'; # Number of unique atoms; self.PYnunique = 0; # Number of equivalent atoms per unique atom (length nunique); self.nequiv = 0; # Equivalent atom mapping array; self.equiv = 0; # Atom to unique atom mapping array (length natom); self.PYatom_to_unique = 0. if psi4molstr:; self.create_molecule_from_string(psi4molstr). # <<< Simple Methods for Basic Molecule Information >>>. [docs] def name(self):; """"""Get molecule name. >>> print H2OH2O.name(); water_dimer. """"""; return self.PYname. [docs] def set_name(self, name):; """"""Set molecule name. >>> H2OH2O.set_name('water_dimer'). """"""; self.PYname = name. [docs] def natom(self):; """"""Number of atoms. >>> print H2OH2O.natom(); 6. """"""; return len(self.atoms). [docs] def nallatom(self):; """"""Number of all atoms (includes dummies). >>> print H2OH2O.nallatom(); 7. """"""; return len(self.full_atoms). [docs] def molecular_charge(self):; """"""Gets the molecular charge. >>> print H2OH2O.molecular_charge(); -2. """"""; return self.PYmolecular_charge. [docs] def set_molecular_charge(self, charge):; """"""Sets the molecular charge. >>> H2OH2O.set_molecular_charge(-2). """"""; self.PYcharge_specified = True; self.PYmolecular_charge = charge. [docs] def charge_specified(self):; """"""Whether the charge was given by the user. >>> print H2OH2O.charge_specified(); True. """"""; return self.PYcharge_specified. [docs] def mul",MatchSource.WIKI,psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html:6965,Usability,Simpl,Simple,6965,"e multiplicity (defined as 2Ms + 1). >>> H2OH2O.set_multiplicity(3). """"""; self.PYmultiplicity_specified = True; self.PYmultiplicity = mult. [docs] def multiplicity_specified(self):; """"""Whether the multiplicity was given by the user. >>> print H2OH2O.multiplicity_specified(); True. """"""; return self.PYmultiplicity_specified. [docs] def units(self):; """"""Gets the geometry units. >>> print H2OH2O.units(); Angstrom. """"""; return self.PYunits. [docs] def set_units(self, units):; """"""Sets the geometry units. >>> H2OH2O.set_units('Angstom'). """"""; if units == 'Angstrom' or units == 'Bohr':; self.PYunits = units; else:; raise ValidationError(""""""Argument to Molecule::set_units must be 'Angstrom' or 'Bohr'.""""""). [docs] def has_zmatrix(self):; """"""Gets the presence of any zmatrix entry. >>> print H2OH2O.has_zmatrix(); False. """"""; return self.zmat. [docs] def set_has_zmatrix(self, tf):; """"""Sets the presence of any zmatrix entry. >>> H2OH2O.set_has_zmatrix(True). """"""; self.zmat = tf. # <<< Simple Methods for Coordinates >>>. [docs] def Z(self, atom):; """"""Nuclear charge of atom (0-indexed). >>> print H2OH2O.Z(4); 1. """"""; return self.atoms[atom].Z(). [docs] def x(self, atom):; """"""x position of atom (0-indexed) in Bohr. >>> print H2OH2O.x(4); 3.17549201425. """"""; return self.input_units_to_au * self.atoms[atom].compute()[0]. [docs] def y(self, atom):; """"""y position of atom (0-indexed) in Bohr. >>> print H2OH2O.y(4); -0.706268134631. """"""; return self.input_units_to_au * self.atoms[atom].compute()[1]. [docs] def z(self, atom):; """"""z position of atom (0-indexed) in Bohr. >>> print H2OH2O.z(4); -1.43347254509. """"""; return self.input_units_to_au * self.atoms[atom].compute()[2]. [docs] def xyz(self, atom, posn=None):; """"""Returns a Vector3 with x, y, z position of atom (0-indexed); in Bohr or coordinate at *posn*. >>> print H2OH2O.xyz(4); [3.175492014248769, -0.7062681346308132, -1.4334725450878665]. """"""; temp = scale(self.atoms[atom].compute(), self.input_units_to_au); if posn >= 0:; return tem",MatchSource.WIKI,psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html:10769,Usability,Simpl,Simple,10769,"0-indexed) in Bohr (includes dummies). >>> print H2OH2O.fxyz(4); [2.5523113582286716, 0.21064588230662976, 0.0]. """"""; return scale(self.full_atoms[atom].compute(), self.input_units_to_au). [docs] def fmass(self, atom):; """"""Returns mass of atom (0-indexed, includes dummies). >>> print H2OH2O.fmass(4); 15.9949146196. """"""; return self.full_atoms[atom].mass(). [docs] def fsymbol(self, atom):; """"""Returns the cleaned up label of the atom (C2 => C, H4 = H) (includes dummies). >>> print H2OH2O.fsymbol(4); O. """"""; return self.full_atoms[atom].symbol(). [docs] def flabel(self, atom):; """"""Returns the original label of the atom (0-indexed) as given in; the input file (C2, H4) (includes dummies). >>> print H2OH2O.flabel(4); O2. """"""; return self.full_atoms[atom].label(). [docs] def fcharge(self, atom):; """"""Returns charge of atom (0-indexed, includes dummies).; Related to SAD guess in libmints version. >>> print H2OH2O.fcharge(4); 8.0. """"""; return self.full_atoms[atom].charge(). # <<< Simple Methods for Fragmentation >>>. [docs] def nfragments(self):; """"""The number of fragments in the molecule. >>> print H2OH2O.nfragments(); 2. """"""; return len(self.fragments). [docs] def nactive_fragments(self):; """"""The number of active fragments in the molecule. >>> print H2OH2O.nactive_fragments(); 2. """"""; n = 0; for fr in range(self.nfragments()):; if self.fragment_types[fr] == 'Real':; n += 1; return n. [docs] def activate_all_fragments(self):; """"""Sets all fragments in the molecule to be active.""""""; self.lock_frame = False; print 'it lives', 'activate all'; for fr in range(self.nfragments()):; print 'reviving', fr; self.fragment_types[fr] = 'Real'. [docs] def set_active_fragment(self, fr):; """"""Tags fragment index *fr* as composed of real atoms.""""""; self.lock_frame = False; self.fragment_types[fr - 1] = 'Real'. [docs] def set_active_fragments(self, reals):; """"""Tags the fragments in array *reals* as composed of real atoms.""""""; self.lock_frame = False; for fr in reals:; self.fragment_types[fr - 1",MatchSource.WIKI,psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html:44876,Usability,clear,cleared,44876,"multiplicity = self.PYmultiplicity; self.PYmolecular_charge = 0; self.PYmultiplicity = 1. for fr in range(self.nfragments()):; if self.fragment_types[fr] == 'Absent':; continue. if self.fragment_types[fr] == 'Real':; self.PYmolecular_charge += self.fragment_charges[fr]; self.PYmultiplicity += self.fragment_multiplicities[fr] - 1. for at in range(self.fragments[fr][0], self.fragments[fr][1] + 1):; self.full_atoms[at].compute(); self.full_atoms[at].set_ghosted(self.fragment_types[fr] == 'Ghost'); if self.full_atoms[at].symbol() != 'X':; self.atoms.append(self.full_atoms[at]). # TODO: This is a hack to ensure that set_multiplicity and set_molecular_charge; # work for single-fragment molecules.; if self.nfragments() < 2:; self.PYmolecular_charge = temp_charge; self.PYmultiplicity = temp_multiplicity. [docs] def update_geometry(self):; """"""Updates the geometry, by (re)interpreting the string used to; create the molecule, and the current values of the variables.; The atoms list is cleared, and then rebuilt by this routine.; This function must be called after first instantiation of Molecule. >>> H2 = qcdb.Molecule(""H\\nH 1 0.74\\n""); >>> print H2.natom(); 0; >>> H2.update_geometry(); >>> print H2.natom(); 2. """"""; if self.nfragments() == 0:; raise ValidationError(""Molecule::update_geometry: There are no fragments in this molecule.""). # Idempotence condition; if self.lock_frame:; return. #print ""beginning update_geometry:""; #self.print_full(); if self.PYreinterpret_coordentries:; self.reinterpret_coordentries(); #print ""after reinterpret_coordentries:""; #self.print_full(). if self.PYmove_to_com:; self.move_to_com(); #print ""after com:""; #self.print_full(). # If the no_reorient command was given, don't reorient; if not self.PYfix_orientation:; # Now we need to rotate the geometry to its symmetry frame; # to align the axes correctly for the point group; # symmetry_frame looks for the highest point group so that we can align; # the molecule according to its actual symmetry, rath",MatchSource.WIKI,psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html:46632,Usability,clear,clear,46632,"ntation:; # Now we need to rotate the geometry to its symmetry frame; # to align the axes correctly for the point group; # symmetry_frame looks for the highest point group so that we can align; # the molecule according to its actual symmetry, rather than the symmetry; # the the user might have provided.; frame = self.symmetry_frame(); self.rotate_full(frame); #print ""after rotate:""; #self.print_full(). # Recompute point group of the molecule, so the symmetry info is updated to the new frame; # TODO self.set_point_group(self.find_point_group()); # TODO self.set_full_point_group(). # Disabling symmetrize for now if orientation is fixed, as it is not; # correct. We may want to fix this in the future, but in some cases of; # finite-differences the set geometry is not totally symmetric anyway.; # Symmetrize the molecule to remove any noise; # TODO self.symmetrize(); #print ""after symmetry:""; #self.print_full(). self.lock_frame = True. # <<< Methods for Miscellaneous >>>. [docs] def clear(self):; """"""Zero it out.""""""; self.lock_frame = False; self.atoms = []; self.full_atoms = []. [docs] def nuclear_repulsion_energy(self):; """"""Computes nuclear repulsion energy. >>> print H2OH2O.nuclear_repulsion_energy(); 36.6628478528. """"""; e = 0.0; for at1 in range(self.natom()):; for at2 in range(self.natom()):; if at2 < at1:; Zi = self.Z(at1); Zj = self.Z(at2); dist = distance(self.xyz(at1), self.xyz(at2)); e += Zi * Zj / dist; return e. [docs] def nuclear_repulsion_energy_deriv1(self):; """"""Computes nuclear repulsion energy derivatives. >>> print H2OH2O.nuclear_repulsion_energy_deriv1(); [[3.9020946901323774, 2.76201566471991, 0.0], [1.3172905807089021, -2.3486366050337293, 0.0], [-1.8107598525022435, -0.32511212499256564, 0.0], [-1.217656141385739, -2.6120090867576717, 0.0], [-1.0954846384766488, 1.2618710760320282, 2.1130743287465603], [-1.0954846384766488, 1.2618710760320282, -2.1130743287465603]]. """"""; de = []; for i in range(self.natom()):; entry = [0.0, 0.0, 0.0]; for j in range(se",MatchSource.WIKI,psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/4.0b5/_modules/qcdb/molecule.html:2005,Availability,avail,available,2005,"; #import re; #import math; #import copy; #from periodictable import *; #from physconst import *; #from vecutil import *; #from exceptions import *; #from coordentry import *; import subprocess; import socket; import shutil; import random; from libmintsmolecule import *. [docs]class Molecule(LibmintsMolecule):; """"""Class to store python extensions to the MoleculeLibmints class.; Multiple classes allows separation of libmints and extension methods. """""". def __init__(self, psi4molstr=None):; """"""Initialize Molecule object from LibmintsMolecule""""""; LibmintsMolecule.__init__(self, psi4molstr). # The comment line; self.tagline = """". def __str__(self):; text = """""" ==> qcdb Molecule %s <==\n\n"""""" % (self.name()); text += """""" => %s <=\n\n"""""" % (self.tagline); text += self.save_string_for_psi4(); return text. @classmethod; [docs] def init_with_xyz(cls, xyzfilename, no_com=False, no_reorient=False):; """"""Pull information from an XYZ file. No fragment info detected.; Charge, multiplicity, tagline pulled from second line if available. >>> H2O = qcdb.Molecule.init_with_xyz('h2o.xyz'). """"""; instance = cls(); instance.lock_frame = False; instance.PYmove_to_com = not no_com; instance.PYfix_orientation = no_reorient. try:; infile = open(xyzfilename, 'r'); except IOError:; raise ValidationError(""""""Molecule::init_with_xyz: given filename '%s' does not exist."""""" % (xyzfilename)); if os.stat(xyzfilename).st_size == 0:; raise ValidationError(""""""Molecule::init_with_xyz: given filename '%s' is blank."""""" % (xyzfilename)); text = infile.readlines(). xyz1 = re.compile(r""^\s*(\d+)\s*(bohr|au)?\s*$"", re.IGNORECASE); xyz2 = re.compile(r'^\s*(-?\d+)\s+(\d+)\s+(.*)\s*$'); xyzN = re.compile(r""(?:\s*)([A-Z](?:[a-z])?)(?:\s+)(-?\d+\.\d+)(?:\s+)(-?\d+\.\d+)(?:\s+)(-?\d+\.\d+)(?:\s*)"", re.IGNORECASE). # Try to match the first line; if xyz1.match(text[0]):; fileNatom = int(xyz1.match(text[0]).group(1)); if xyz1.match(text[0]).group(2) == None:; fileUnits = 'Angstrom'; else:; fileUnits = 'Bohr'; else:; raise",MatchSource.WIKI,psi4manual/4.0b5/_modules/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/molecule.html
https://psicode.org/psi4manual/4.0b5/_modules/qcdb/molecule.html:10210,Availability,fault,faulty,10210,"return self. flist = self.BFS(). # form new molecule through a string since self may contain; # dummies or zmatrix specs that mayn't be valid with atom shuffling; new_geom = '\n'. if self.PYcharge_specified or self.PYmultiplicity_specified:; new_geom = """"""\n %d %d\n"""""" % (self.molecular_charge(), self.multiplicity()). for fr in range(len(flist)):; new_geom += """" if fr == 0 else "" --\n""; for at in flist[fr]:; geom = self.atoms[at].compute(); new_geom += """"""%-4s """""" % (("""" if self.Z(at) else ""@"") + self.symbol(at)); for j in range(3):; new_geom += """""" %17.12f"""""" % (geom[j]); new_geom += ""\n""; new_geom += "" units %s\n"" % (self.units()); if not self.PYmove_to_com:; new_geom += "" no_com\n""; if self.orientation_fixed():; new_geom += "" no_reorient\n"". subset = Molecule(new_geom); subset.update_geometry(); return subset. [docs] def BFS(self):; """"""Perform a breadth-first search (BFS) on the real atoms; in molecule, returning an array of atom indices of fragments.; Relies upon van der Waals radii and so faulty for close; (esp. hydrogen-bonded) fragments. Original code from; Michael S. Marshall. """"""; vdW_diameter = {; #'H': 1.001 / 1.5, # JMol; 'HE': 1.012 / 1.5, # JMol; 'LI': 0.825 / 1.5, # JMol; 'BE': 1.408 / 1.5, # JMol; #'B': 1.485 / 1.5, # JMol; #'C': 1.452 / 1.5, # JMol; #'N': 1.397 / 1.5, # JMol; #'O': 1.342 / 1.5, # JMol; #'F': 1.287 / 1.5, # JMol; 'NE': 1.243 / 1.5, # JMol; 'NA': 1.144 / 1.5, # JMol; 'MG': 1.364 / 1.5, # JMol; 'AL': 1.639 / 1.5, # JMol; #'SI': 1.716 / 1.5, # JMol; #'P': 1.705 / 1.5, # JMol; #'S': 1.683 / 1.5, # JMol; #'CL': 1.639 / 1.5, # JMol; 'AR': 1.595 / 1.5, # JMol. 'H': 1.06 / 1.5, # Bondi JPC 68 441 (1964); 'B': 1.65 / 1.5, # Bondi JPC 68 441 (1964); 'C': 1.53 / 1.5, # Bondi JPC 68 441 (1964); 'N': 1.46 / 1.5, # Bondi JPC 68 441 (1964); 'O': 1.42 / 1.5, # Bondi JPC 68 441 (1964); 'F': 1.40 / 1.5, # Bondi JPC 68 441 (1964); 'SI': 1.93 / 1.5, # Bondi JPC 68 441 (1964); 'P': 1.86 / 1.5, # Bondi JPC 68 441 (1964); 'S': 1.80 / 1.5, # Bondi JPC 68 44",MatchSource.WIKI,psi4manual/4.0b5/_modules/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/molecule.html
https://psicode.org/psi4manual/4.0b5/_modules/qcdb/molecule.html:26540,Availability,avail,available,26540,"59}, # in psi4; 'bp86' : {'s6': 1.000, 'a1': 0.3946, 's8': 3.2822, 'a2': 4.8516}, # in psi4; 'dsd-blyp' : {'s6': 0.500, 'a1': 0.000, 's8': 0.2130, 'a2': 6.0519}, # in psi4; 'pbe0' : {'s6': 1.000, 'a1': 0.4145, 's8': 1.2177, 'a2': 4.8593}, # in psi4; 'pbe' : {'s6': 1.000, 'a1': 0.4289, 's8': 0.7875, 'a2': 4.4407}, # in psi4; 'pw6b95' : {'s6': 1.000, 'a1': 0.2076, 's8': 0.7257, 'a2': 6.3750},; 'pwpb95' : {'s6': 0.820, 'a1': 0.0000, 's8': 0.2904, 'a2': 7.3141},; 'revpbe0' : {'s6': 1.000, 'a1': 0.4679, 's8': 1.7588, 'a2': 3.7619},; 'revpbe38' : {'s6': 1.000, 'a1': 0.4309, 's8': 1.4760, 'a2': 3.9446},; 'revpbe' : {'s6': 1.000, 'a1': 0.5238, 's8': 2.3550, 'a2': 3.5016},; 'rpw86pbe' : {'s6': 1.000, 'a1': 0.4613, 's8': 1.3845, 'a2': 4.5062},; 'tpss0' : {'s6': 1.000, 'a1': 0.3768, 's8': 1.2576, 'a2': 4.5865},; 'tpss' : {'s6': 1.000, 'a1': 0.4535, 's8': 1.9435, 'a2': 4.4752},; }; }. # Validate arguments; dashlvl = dashlvl.lower(); if dashlvl not in dashcoeff.keys():; raise ValidationError(""""""-D correction level %s is not available. Choose among %s."""""" % (dashlvl, dashcoeff.keys())). if func is None:; if dashparam is None:; # defunct case; raise ValidationError(""""""Parameters for -D correction missing. Provide a func or a dashparam kwarg.""""""); else:; # case where all param read from dashparam dict (which must have all correct keys); func = 'custom'; dashcoeff[dashlvl][func] = {}; dashparam = dict((k.lower(), v) for k, v in dashparam.iteritems()); for key in dashcoeff[dashlvl]['b3lyp'].keys():; if key in dashparam.keys():; dashcoeff[dashlvl][func][key] = dashparam[key]; else:; raise ValidationError(""""""Parameter %s is missing from dashparam dict %s."""""" % (key, dashparam)); else:; func = func.lower(); if func not in dashcoeff[dashlvl].keys():; raise ValidationError(""""""Functional %s is not available for -D level %s."""""" % (func, dashlvl)); if dashparam is None:; # (normal) case where all param taken from dashcoeff above; pass; else:; # case where items in dashparam dict can override",MatchSource.WIKI,psi4manual/4.0b5/_modules/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/molecule.html
https://psicode.org/psi4manual/4.0b5/_modules/qcdb/molecule.html:27318,Availability,avail,available,27318,".2576, 'a2': 4.5865},; 'tpss' : {'s6': 1.000, 'a1': 0.4535, 's8': 1.9435, 'a2': 4.4752},; }; }. # Validate arguments; dashlvl = dashlvl.lower(); if dashlvl not in dashcoeff.keys():; raise ValidationError(""""""-D correction level %s is not available. Choose among %s."""""" % (dashlvl, dashcoeff.keys())). if func is None:; if dashparam is None:; # defunct case; raise ValidationError(""""""Parameters for -D correction missing. Provide a func or a dashparam kwarg.""""""); else:; # case where all param read from dashparam dict (which must have all correct keys); func = 'custom'; dashcoeff[dashlvl][func] = {}; dashparam = dict((k.lower(), v) for k, v in dashparam.iteritems()); for key in dashcoeff[dashlvl]['b3lyp'].keys():; if key in dashparam.keys():; dashcoeff[dashlvl][func][key] = dashparam[key]; else:; raise ValidationError(""""""Parameter %s is missing from dashparam dict %s."""""" % (key, dashparam)); else:; func = func.lower(); if func not in dashcoeff[dashlvl].keys():; raise ValidationError(""""""Functional %s is not available for -D level %s."""""" % (func, dashlvl)); if dashparam is None:; # (normal) case where all param taken from dashcoeff above; pass; else:; # case where items in dashparam dict can override param taken from dashcoeff above; dashparam = dict((k.lower(), v) for k, v in dashparam.iteritems()); for key in dashcoeff[dashlvl]['b3lyp'].keys():; if key in dashparam.keys():; dashcoeff[dashlvl][func][key] = dashparam[key]. # Move ~/.dftd3par.<hostname> out of the way so it won't interfere; defaultfile = os.path.expanduser('~') + '/.dftd3par.' + socket.gethostname(); defmoved = False; if os.path.isfile(defaultfile):; os.rename(defaultfile, defaultfile + '_hide'); defmoved = True. # Setup unique scratch directory and move in; current_directory = os.getcwd(); dftd3_tmpdir = 'dftd3_' + str(random.randint(0, 99999)); if os.path.exists(dftd3_tmpdir) is False:; os.mkdir(dftd3_tmpdir); os.chdir(dftd3_tmpdir). # Write dftd3_parameters file that governs dispersion calc; paramfile = './",MatchSource.WIKI,psi4manual/4.0b5/_modules/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/molecule.html
https://psicode.org/psi4manual/4.0b5/_modules/qcdb/molecule.html:30970,Deployability,update,updated,30970,"oeff[dashlvl][func]['s6'], dashcoeff[dashlvl][func]['a1'], dashcoeff[dashlvl][func]['s8'],; dashcoeff[dashlvl][func]['a2'], 0.0, 4)); pfile.close(). # Write dftd3_geometry file that supplies geometry to dispersion calc; geomfile = './dftd3_geometry.xyz'; gfile = open(geomfile, 'w'); gfile.write(self.save_string_xyz()); gfile.close(). # Call dftd3 program; try:; dashout = subprocess.Popen(['dftd3', geomfile, '-grad'], stdout=subprocess.PIPE); except OSError:; raise ValidationError('Program dftd3 not found in path.'); out, err = dashout.communicate(); if verbosity >= 3:; print out. # Parse output (could go further and break into E6, E8, E10 and Cn coeff); success = False; for line in out.splitlines():; if re.match(' Edisp /kcal,au', line):; sline = line.split(); dashd = float(sline[3]); if re.match(' normal termination of dftd3', line):; success = True. if not success:; raise ValidationError('Program dftd3 did not complete successfully.'). # Parse grad output; derivfile = './dftd3_gradient'; dfile = open(derivfile, 'r'); dashdderiv = []; for at in dfile.readlines():; dashdderiv.append([float(x.replace('D', 'E')) for x in at.split()]); dfile.close(); if len(dashdderiv) != self.natom():; raise ValidationError('Program dftd3 gradient file has %d atoms- %d expected.' % \; (len(dashdderiv), self.natom())). # Clean up files and remove scratch directory; # os.unlink(paramfile); # os.unlink(geomfile); # os.unlink(derivfile); if defmoved is True:; os.rename(defaultfile + '_hide', defaultfile). os.chdir('..'); # try:; # shutil.rmtree(dftd3_tmpdir); # except OSError as e:; # ValidationError('Unable to remove dftd3 temporary directory %s' % e, file=sys.stderr); os.chdir(current_directory). # return -D & d(-D)/dx; return dashd, dashdderiv. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  ; PSI4 [beta5]  ; Module code .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/_modules/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/molecule.html
https://psicode.org/psi4manual/4.0b5/_modules/qcdb/molecule.html:1948,Energy Efficiency,Charge,Charge,1948,"; #import re; #import math; #import copy; #from periodictable import *; #from physconst import *; #from vecutil import *; #from exceptions import *; #from coordentry import *; import subprocess; import socket; import shutil; import random; from libmintsmolecule import *. [docs]class Molecule(LibmintsMolecule):; """"""Class to store python extensions to the MoleculeLibmints class.; Multiple classes allows separation of libmints and extension methods. """""". def __init__(self, psi4molstr=None):; """"""Initialize Molecule object from LibmintsMolecule""""""; LibmintsMolecule.__init__(self, psi4molstr). # The comment line; self.tagline = """". def __str__(self):; text = """""" ==> qcdb Molecule %s <==\n\n"""""" % (self.name()); text += """""" => %s <=\n\n"""""" % (self.tagline); text += self.save_string_for_psi4(); return text. @classmethod; [docs] def init_with_xyz(cls, xyzfilename, no_com=False, no_reorient=False):; """"""Pull information from an XYZ file. No fragment info detected.; Charge, multiplicity, tagline pulled from second line if available. >>> H2O = qcdb.Molecule.init_with_xyz('h2o.xyz'). """"""; instance = cls(); instance.lock_frame = False; instance.PYmove_to_com = not no_com; instance.PYfix_orientation = no_reorient. try:; infile = open(xyzfilename, 'r'); except IOError:; raise ValidationError(""""""Molecule::init_with_xyz: given filename '%s' does not exist."""""" % (xyzfilename)); if os.stat(xyzfilename).st_size == 0:; raise ValidationError(""""""Molecule::init_with_xyz: given filename '%s' is blank."""""" % (xyzfilename)); text = infile.readlines(). xyz1 = re.compile(r""^\s*(\d+)\s*(bohr|au)?\s*$"", re.IGNORECASE); xyz2 = re.compile(r'^\s*(-?\d+)\s+(\d+)\s+(.*)\s*$'); xyzN = re.compile(r""(?:\s*)([A-Z](?:[a-z])?)(?:\s+)(-?\d+\.\d+)(?:\s+)(-?\d+\.\d+)(?:\s+)(-?\d+\.\d+)(?:\s*)"", re.IGNORECASE). # Try to match the first line; if xyz1.match(text[0]):; fileNatom = int(xyz1.match(text[0]).group(1)); if xyz1.match(text[0]).group(2) == None:; fileUnits = 'Angstrom'; else:; fileUnits = 'Bohr'; else:; raise",MatchSource.WIKI,psi4manual/4.0b5/_modules/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/molecule.html
https://psicode.org/psi4manual/4.0b5/_modules/qcdb/molecule.html:7869,Energy Efficiency,CHARGE,CHARGE,7869,"or line in self.create_psi4_string_from_molecule().splitlines():; text += ' ' + line + '\n'; text += '}\n'; return text. [docs] def format_molecule_for_qchem(self):; """""". """"""; factor = 1.0 if self.PYunits == 'Angstrom' else psi_bohr2angstroms. text = """"; text += '%d %d %s\n' % (self.molecular_charge(), self.multiplicity(), self.tagline). for i in range(self.natom()):; [x, y, z] = self.atoms[i].compute(); text += '%2s %17.12f %17.12f %17.12f\n' % ((self.symbol(i) if self.Z(i) else ""Gh""), \; x * factor, y * factor, z * factor); return text; pass. [docs] def format_molecule_for_molpro(self):; """""". """"""; factor = 1.0 if self.PYunits == 'Angstrom' else psi_bohr2angstroms; # TODO keep fix_or?; self.fix_orientation(True); self.PYmove_to_com = False; self.update_geometry(). text = """"; text += 'angstrom\n'; text += 'geometry={\n'. for i in range(self.natom()):; [x, y, z] = self.atoms[i].compute(); text += '%2s %17.12f %17.12f %17.12f\n' % (self.symbol(i), \; x * factor, y * factor, z * factor); text += '}\n\n'; text += 'SET,CHARGE=%d\n' % (self.molecular_charge()); text += 'SET,SPIN=%d\n' % (self.multiplicity() - 1) # Molpro wants (mult-1). textDummy = ""dummy""; for fr in range(self.nfragments()):; if self.fragment_types[fr] == 'Ghost':; for at in range(self.fragments[fr][0], self.fragments[fr][1] + 1):; textDummy += """""",%d"""""" % (at + 1) # Molpro atom numbering is 1-indexed; textDummy += '\n'; if len(textDummy) > 6:; text += textDummy; return text. [docs] def format_molecule_for_nwchem(self):; """""". """"""; factor = 1.0 if self.PYunits == 'Angstrom' else psi_bohr2angstroms. text = """"; text += '%d %d %s\n' % (self.molecular_charge(), self.multiplicity(), self.tagline). for i in range(self.natom()):; [x, y, z] = self.atoms[i].compute(); text += '%4s %17.12f %17.12f %17.12f\n' % (("""" if self.Z(i) else 'Bq') + self.symbol(i), \; x * factor, y * factor, z * factor); return text; pass. # if symm print M2OUT ""nosym\nnoorient\n"";; # print DIOUT ""angstrom\ngeometry={\n"";. [docs] def auto_f",MatchSource.WIKI,psi4manual/4.0b5/_modules/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/molecule.html
https://psicode.org/psi4manual/4.0b5/_modules/qcdb/molecule.html:9037,Energy Efficiency,charge,charge,9037,".fragment_types[fr] == 'Ghost':; for at in range(self.fragments[fr][0], self.fragments[fr][1] + 1):; textDummy += """""",%d"""""" % (at + 1) # Molpro atom numbering is 1-indexed; textDummy += '\n'; if len(textDummy) > 6:; text += textDummy; return text. [docs] def format_molecule_for_nwchem(self):; """""". """"""; factor = 1.0 if self.PYunits == 'Angstrom' else psi_bohr2angstroms. text = """"; text += '%d %d %s\n' % (self.molecular_charge(), self.multiplicity(), self.tagline). for i in range(self.natom()):; [x, y, z] = self.atoms[i].compute(); text += '%4s %17.12f %17.12f %17.12f\n' % (("""" if self.Z(i) else 'Bq') + self.symbol(i), \; x * factor, y * factor, z * factor); return text; pass. # if symm print M2OUT ""nosym\nnoorient\n"";; # print DIOUT ""angstrom\ngeometry={\n"";. [docs] def auto_fragments(self):; """"""Detects fragments in an unfragmented molecule using BFS; algorithm. Returns a new Molecule in Cartesian, fixed-geom; (no variable values), no dummy-atom format. Any non-default; charge and multiplicity assigned to first fragment. """"""; if self.nfragments() != 1:; print 'Molecule already fragmented so no further action by auto_fragments().'; return self. flist = self.BFS(). # form new molecule through a string since self may contain; # dummies or zmatrix specs that mayn't be valid with atom shuffling; new_geom = '\n'. if self.PYcharge_specified or self.PYmultiplicity_specified:; new_geom = """"""\n %d %d\n"""""" % (self.molecular_charge(), self.multiplicity()). for fr in range(len(flist)):; new_geom += """" if fr == 0 else "" --\n""; for at in flist[fr]:; geom = self.atoms[at].compute(); new_geom += """"""%-4s """""" % (("""" if self.Z(at) else ""@"") + self.symbol(at)); for j in range(3):; new_geom += """""" %17.12f"""""" % (geom[j]); new_geom += ""\n""; new_geom += "" units %s\n"" % (self.units()); if not self.PYmove_to_com:; new_geom += "" no_com\n""; if self.orientation_fixed():; new_geom += "" no_reorient\n"". subset = Molecule(new_geom); subset.update_geometry(); return subset. [docs] def BFS(self):; """"""Pe",MatchSource.WIKI,psi4manual/4.0b5/_modules/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/molecule.html
https://psicode.org/psi4manual/4.0b5/_modules/qcdb/molecule.html:8980,Modifiability,variab,variable,8980,"wants (mult-1). textDummy = ""dummy""; for fr in range(self.nfragments()):; if self.fragment_types[fr] == 'Ghost':; for at in range(self.fragments[fr][0], self.fragments[fr][1] + 1):; textDummy += """""",%d"""""" % (at + 1) # Molpro atom numbering is 1-indexed; textDummy += '\n'; if len(textDummy) > 6:; text += textDummy; return text. [docs] def format_molecule_for_nwchem(self):; """""". """"""; factor = 1.0 if self.PYunits == 'Angstrom' else psi_bohr2angstroms. text = """"; text += '%d %d %s\n' % (self.molecular_charge(), self.multiplicity(), self.tagline). for i in range(self.natom()):; [x, y, z] = self.atoms[i].compute(); text += '%4s %17.12f %17.12f %17.12f\n' % (("""" if self.Z(i) else 'Bq') + self.symbol(i), \; x * factor, y * factor, z * factor); return text; pass. # if symm print M2OUT ""nosym\nnoorient\n"";; # print DIOUT ""angstrom\ngeometry={\n"";. [docs] def auto_fragments(self):; """"""Detects fragments in an unfragmented molecule using BFS; algorithm. Returns a new Molecule in Cartesian, fixed-geom; (no variable values), no dummy-atom format. Any non-default; charge and multiplicity assigned to first fragment. """"""; if self.nfragments() != 1:; print 'Molecule already fragmented so no further action by auto_fragments().'; return self. flist = self.BFS(). # form new molecule through a string since self may contain; # dummies or zmatrix specs that mayn't be valid with atom shuffling; new_geom = '\n'. if self.PYcharge_specified or self.PYmultiplicity_specified:; new_geom = """"""\n %d %d\n"""""" % (self.molecular_charge(), self.multiplicity()). for fr in range(len(flist)):; new_geom += """" if fr == 0 else "" --\n""; for at in flist[fr]:; geom = self.atoms[at].compute(); new_geom += """"""%-4s """""" % (("""" if self.Z(at) else ""@"") + self.symbol(at)); for j in range(3):; new_geom += """""" %17.12f"""""" % (geom[j]); new_geom += ""\n""; new_geom += "" units %s\n"" % (self.units()); if not self.PYmove_to_com:; new_geom += "" no_com\n""; if self.orientation_fixed():; new_geom += "" no_reorient\n"". subset = Molecule",MatchSource.WIKI,psi4manual/4.0b5/_modules/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/molecule.html
https://psicode.org/psi4manual/4.0b5/_modules/qcdb/molecule.html:10052,Performance,Perform,Perform,10052,"self.nfragments() != 1:; print 'Molecule already fragmented so no further action by auto_fragments().'; return self. flist = self.BFS(). # form new molecule through a string since self may contain; # dummies or zmatrix specs that mayn't be valid with atom shuffling; new_geom = '\n'. if self.PYcharge_specified or self.PYmultiplicity_specified:; new_geom = """"""\n %d %d\n"""""" % (self.molecular_charge(), self.multiplicity()). for fr in range(len(flist)):; new_geom += """" if fr == 0 else "" --\n""; for at in flist[fr]:; geom = self.atoms[at].compute(); new_geom += """"""%-4s """""" % (("""" if self.Z(at) else ""@"") + self.symbol(at)); for j in range(3):; new_geom += """""" %17.12f"""""" % (geom[j]); new_geom += ""\n""; new_geom += "" units %s\n"" % (self.units()); if not self.PYmove_to_com:; new_geom += "" no_com\n""; if self.orientation_fixed():; new_geom += "" no_reorient\n"". subset = Molecule(new_geom); subset.update_geometry(); return subset. [docs] def BFS(self):; """"""Perform a breadth-first search (BFS) on the real atoms; in molecule, returning an array of atom indices of fragments.; Relies upon van der Waals radii and so faulty for close; (esp. hydrogen-bonded) fragments. Original code from; Michael S. Marshall. """"""; vdW_diameter = {; #'H': 1.001 / 1.5, # JMol; 'HE': 1.012 / 1.5, # JMol; 'LI': 0.825 / 1.5, # JMol; 'BE': 1.408 / 1.5, # JMol; #'B': 1.485 / 1.5, # JMol; #'C': 1.452 / 1.5, # JMol; #'N': 1.397 / 1.5, # JMol; #'O': 1.342 / 1.5, # JMol; #'F': 1.287 / 1.5, # JMol; 'NE': 1.243 / 1.5, # JMol; 'NA': 1.144 / 1.5, # JMol; 'MG': 1.364 / 1.5, # JMol; 'AL': 1.639 / 1.5, # JMol; #'SI': 1.716 / 1.5, # JMol; #'P': 1.705 / 1.5, # JMol; #'S': 1.683 / 1.5, # JMol; #'CL': 1.639 / 1.5, # JMol; 'AR': 1.595 / 1.5, # JMol. 'H': 1.06 / 1.5, # Bondi JPC 68 441 (1964); 'B': 1.65 / 1.5, # Bondi JPC 68 441 (1964); 'C': 1.53 / 1.5, # Bondi JPC 68 441 (1964); 'N': 1.46 / 1.5, # Bondi JPC 68 441 (1964); 'O': 1.42 / 1.5, # Bondi JPC 68 441 (1964); 'F': 1.40 / 1.5, # Bondi JPC 68 441 (1964); 'SI': 1.93 / 1.5, #",MatchSource.WIKI,psi4manual/4.0b5/_modules/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/molecule.html
https://psicode.org/psi4manual/4.0b5/_modules/qcdb/molecule.html:11660,Performance,Queue,Queue,11660,"; #'SI': 1.716 / 1.5, # JMol; #'P': 1.705 / 1.5, # JMol; #'S': 1.683 / 1.5, # JMol; #'CL': 1.639 / 1.5, # JMol; 'AR': 1.595 / 1.5, # JMol. 'H': 1.06 / 1.5, # Bondi JPC 68 441 (1964); 'B': 1.65 / 1.5, # Bondi JPC 68 441 (1964); 'C': 1.53 / 1.5, # Bondi JPC 68 441 (1964); 'N': 1.46 / 1.5, # Bondi JPC 68 441 (1964); 'O': 1.42 / 1.5, # Bondi JPC 68 441 (1964); 'F': 1.40 / 1.5, # Bondi JPC 68 441 (1964); 'SI': 1.93 / 1.5, # Bondi JPC 68 441 (1964); 'P': 1.86 / 1.5, # Bondi JPC 68 441 (1964); 'S': 1.80 / 1.5, # Bondi JPC 68 441 (1964); 'CL': 1.75 / 1.5, # Bondi JPC 68 441 (1964); 'GE': 1.98 / 1.5, # Bondi JPC 68 441 (1964); 'AS': 1.94 / 1.5, # Bondi JPC 68 441 (1964); 'SE': 1.90 / 1.5, # Bondi JPC 68 441 (1964); 'BR': 1.87 / 1.5, # Bondi JPC 68 441 (1964); 'SN': 2.16 / 1.5, # Bondi JPC 68 441 (1964); 'SB': 2.12 / 1.5, # Bondi JPC 68 441 (1964); 'TE': 2.08 / 1.5, # Bondi JPC 68 441 (1964); 'I': 2.04 / 1.5, # Bondi JPC 68 441 (1964); 'XE': 2.05 / 1.5} # Bondi JPC 68 441 (1964). Queue = []; White = range(self.natom()) # untouched; Black = [] # touched and all edges discovered; Fragment = [] # stores fragments. start = 0 # starts with the first atom in the list; Queue.append(start); White.remove(start). # Simply start with the first atom, do a BFS when done, go to any; # untouched atom and start again iterate until all atoms belong; # to a fragment group; while len(White) > 0 or len(Queue) > 0: # Iterates to the next fragment; Fragment.append([]). while len(Queue) > 0: # BFS within a fragment; for u in Queue: # find all (still white) nearest neighbors to vertex u; for i in White:; dist = distance(self.xyz(i), self.xyz(u)) * psi_bohr2angstroms; if dist < vdW_diameter[self.symbol(u)] + vdW_diameter[self.symbol(i)]:; Queue.append(i) # if you find you, put in the queue; White.remove(i) # and remove it from the untouched list; Queue.remove(u) # remove focus from Queue; Black.append(u); Fragment[-1].append(int(u)) # add to group (0-indexed); Fragment[-1].sort() # preserve original ",MatchSource.WIKI,psi4manual/4.0b5/_modules/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/molecule.html
https://psicode.org/psi4manual/4.0b5/_modules/qcdb/molecule.html:11846,Performance,Queue,Queue,11846,"6 / 1.5, # Bondi JPC 68 441 (1964); 'B': 1.65 / 1.5, # Bondi JPC 68 441 (1964); 'C': 1.53 / 1.5, # Bondi JPC 68 441 (1964); 'N': 1.46 / 1.5, # Bondi JPC 68 441 (1964); 'O': 1.42 / 1.5, # Bondi JPC 68 441 (1964); 'F': 1.40 / 1.5, # Bondi JPC 68 441 (1964); 'SI': 1.93 / 1.5, # Bondi JPC 68 441 (1964); 'P': 1.86 / 1.5, # Bondi JPC 68 441 (1964); 'S': 1.80 / 1.5, # Bondi JPC 68 441 (1964); 'CL': 1.75 / 1.5, # Bondi JPC 68 441 (1964); 'GE': 1.98 / 1.5, # Bondi JPC 68 441 (1964); 'AS': 1.94 / 1.5, # Bondi JPC 68 441 (1964); 'SE': 1.90 / 1.5, # Bondi JPC 68 441 (1964); 'BR': 1.87 / 1.5, # Bondi JPC 68 441 (1964); 'SN': 2.16 / 1.5, # Bondi JPC 68 441 (1964); 'SB': 2.12 / 1.5, # Bondi JPC 68 441 (1964); 'TE': 2.08 / 1.5, # Bondi JPC 68 441 (1964); 'I': 2.04 / 1.5, # Bondi JPC 68 441 (1964); 'XE': 2.05 / 1.5} # Bondi JPC 68 441 (1964). Queue = []; White = range(self.natom()) # untouched; Black = [] # touched and all edges discovered; Fragment = [] # stores fragments. start = 0 # starts with the first atom in the list; Queue.append(start); White.remove(start). # Simply start with the first atom, do a BFS when done, go to any; # untouched atom and start again iterate until all atoms belong; # to a fragment group; while len(White) > 0 or len(Queue) > 0: # Iterates to the next fragment; Fragment.append([]). while len(Queue) > 0: # BFS within a fragment; for u in Queue: # find all (still white) nearest neighbors to vertex u; for i in White:; dist = distance(self.xyz(i), self.xyz(u)) * psi_bohr2angstroms; if dist < vdW_diameter[self.symbol(u)] + vdW_diameter[self.symbol(i)]:; Queue.append(i) # if you find you, put in the queue; White.remove(i) # and remove it from the untouched list; Queue.remove(u) # remove focus from Queue; Black.append(u); Fragment[-1].append(int(u)) # add to group (0-indexed); Fragment[-1].sort() # preserve original atom ordering. if len(White) != 0: # can't move White -> Queue if no more exist; Queue.append(White[0]); White.remove(White[0]). return Fragment. [d",MatchSource.WIKI,psi4manual/4.0b5/_modules/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/molecule.html
https://psicode.org/psi4manual/4.0b5/_modules/qcdb/molecule.html:12071,Performance,Queue,Queue,12071," # Bondi JPC 68 441 (1964); 'F': 1.40 / 1.5, # Bondi JPC 68 441 (1964); 'SI': 1.93 / 1.5, # Bondi JPC 68 441 (1964); 'P': 1.86 / 1.5, # Bondi JPC 68 441 (1964); 'S': 1.80 / 1.5, # Bondi JPC 68 441 (1964); 'CL': 1.75 / 1.5, # Bondi JPC 68 441 (1964); 'GE': 1.98 / 1.5, # Bondi JPC 68 441 (1964); 'AS': 1.94 / 1.5, # Bondi JPC 68 441 (1964); 'SE': 1.90 / 1.5, # Bondi JPC 68 441 (1964); 'BR': 1.87 / 1.5, # Bondi JPC 68 441 (1964); 'SN': 2.16 / 1.5, # Bondi JPC 68 441 (1964); 'SB': 2.12 / 1.5, # Bondi JPC 68 441 (1964); 'TE': 2.08 / 1.5, # Bondi JPC 68 441 (1964); 'I': 2.04 / 1.5, # Bondi JPC 68 441 (1964); 'XE': 2.05 / 1.5} # Bondi JPC 68 441 (1964). Queue = []; White = range(self.natom()) # untouched; Black = [] # touched and all edges discovered; Fragment = [] # stores fragments. start = 0 # starts with the first atom in the list; Queue.append(start); White.remove(start). # Simply start with the first atom, do a BFS when done, go to any; # untouched atom and start again iterate until all atoms belong; # to a fragment group; while len(White) > 0 or len(Queue) > 0: # Iterates to the next fragment; Fragment.append([]). while len(Queue) > 0: # BFS within a fragment; for u in Queue: # find all (still white) nearest neighbors to vertex u; for i in White:; dist = distance(self.xyz(i), self.xyz(u)) * psi_bohr2angstroms; if dist < vdW_diameter[self.symbol(u)] + vdW_diameter[self.symbol(i)]:; Queue.append(i) # if you find you, put in the queue; White.remove(i) # and remove it from the untouched list; Queue.remove(u) # remove focus from Queue; Black.append(u); Fragment[-1].append(int(u)) # add to group (0-indexed); Fragment[-1].sort() # preserve original atom ordering. if len(White) != 0: # can't move White -> Queue if no more exist; Queue.append(White[0]); White.remove(White[0]). return Fragment. [docs] def inertia_tensor(self, masswt=True):; """"""Compute inertia tensor. >>> print H2OH2O.inertia_tensor(); [[8.704574864178731, -8.828375721817082, 0.0], [-8.828375721817082, 280.8286",MatchSource.WIKI,psi4manual/4.0b5/_modules/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/molecule.html
https://psicode.org/psi4manual/4.0b5/_modules/qcdb/molecule.html:12147,Performance,Queue,Queue,12147,": 1.75 / 1.5, # Bondi JPC 68 441 (1964); 'GE': 1.98 / 1.5, # Bondi JPC 68 441 (1964); 'AS': 1.94 / 1.5, # Bondi JPC 68 441 (1964); 'SE': 1.90 / 1.5, # Bondi JPC 68 441 (1964); 'BR': 1.87 / 1.5, # Bondi JPC 68 441 (1964); 'SN': 2.16 / 1.5, # Bondi JPC 68 441 (1964); 'SB': 2.12 / 1.5, # Bondi JPC 68 441 (1964); 'TE': 2.08 / 1.5, # Bondi JPC 68 441 (1964); 'I': 2.04 / 1.5, # Bondi JPC 68 441 (1964); 'XE': 2.05 / 1.5} # Bondi JPC 68 441 (1964). Queue = []; White = range(self.natom()) # untouched; Black = [] # touched and all edges discovered; Fragment = [] # stores fragments. start = 0 # starts with the first atom in the list; Queue.append(start); White.remove(start). # Simply start with the first atom, do a BFS when done, go to any; # untouched atom and start again iterate until all atoms belong; # to a fragment group; while len(White) > 0 or len(Queue) > 0: # Iterates to the next fragment; Fragment.append([]). while len(Queue) > 0: # BFS within a fragment; for u in Queue: # find all (still white) nearest neighbors to vertex u; for i in White:; dist = distance(self.xyz(i), self.xyz(u)) * psi_bohr2angstroms; if dist < vdW_diameter[self.symbol(u)] + vdW_diameter[self.symbol(i)]:; Queue.append(i) # if you find you, put in the queue; White.remove(i) # and remove it from the untouched list; Queue.remove(u) # remove focus from Queue; Black.append(u); Fragment[-1].append(int(u)) # add to group (0-indexed); Fragment[-1].sort() # preserve original atom ordering. if len(White) != 0: # can't move White -> Queue if no more exist; Queue.append(White[0]); White.remove(White[0]). return Fragment. [docs] def inertia_tensor(self, masswt=True):; """"""Compute inertia tensor. >>> print H2OH2O.inertia_tensor(); [[8.704574864178731, -8.828375721817082, 0.0], [-8.828375721817082, 280.82861714077666, 0.0], [0.0, 0.0, 281.249500988553]]. """"""; return self.inertia_tensor_partial(range(self.natom()), masswt). [docs] def inertia_tensor_partial(self, part, masswt=True):; """"""Compute inertia tensor bas",MatchSource.WIKI,psi4manual/4.0b5/_modules/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/molecule.html
https://psicode.org/psi4manual/4.0b5/_modules/qcdb/molecule.html:12193,Performance,Queue,Queue,12193,": 1.75 / 1.5, # Bondi JPC 68 441 (1964); 'GE': 1.98 / 1.5, # Bondi JPC 68 441 (1964); 'AS': 1.94 / 1.5, # Bondi JPC 68 441 (1964); 'SE': 1.90 / 1.5, # Bondi JPC 68 441 (1964); 'BR': 1.87 / 1.5, # Bondi JPC 68 441 (1964); 'SN': 2.16 / 1.5, # Bondi JPC 68 441 (1964); 'SB': 2.12 / 1.5, # Bondi JPC 68 441 (1964); 'TE': 2.08 / 1.5, # Bondi JPC 68 441 (1964); 'I': 2.04 / 1.5, # Bondi JPC 68 441 (1964); 'XE': 2.05 / 1.5} # Bondi JPC 68 441 (1964). Queue = []; White = range(self.natom()) # untouched; Black = [] # touched and all edges discovered; Fragment = [] # stores fragments. start = 0 # starts with the first atom in the list; Queue.append(start); White.remove(start). # Simply start with the first atom, do a BFS when done, go to any; # untouched atom and start again iterate until all atoms belong; # to a fragment group; while len(White) > 0 or len(Queue) > 0: # Iterates to the next fragment; Fragment.append([]). while len(Queue) > 0: # BFS within a fragment; for u in Queue: # find all (still white) nearest neighbors to vertex u; for i in White:; dist = distance(self.xyz(i), self.xyz(u)) * psi_bohr2angstroms; if dist < vdW_diameter[self.symbol(u)] + vdW_diameter[self.symbol(i)]:; Queue.append(i) # if you find you, put in the queue; White.remove(i) # and remove it from the untouched list; Queue.remove(u) # remove focus from Queue; Black.append(u); Fragment[-1].append(int(u)) # add to group (0-indexed); Fragment[-1].sort() # preserve original atom ordering. if len(White) != 0: # can't move White -> Queue if no more exist; Queue.append(White[0]); White.remove(White[0]). return Fragment. [docs] def inertia_tensor(self, masswt=True):; """"""Compute inertia tensor. >>> print H2OH2O.inertia_tensor(); [[8.704574864178731, -8.828375721817082, 0.0], [-8.828375721817082, 280.82861714077666, 0.0], [0.0, 0.0, 281.249500988553]]. """"""; return self.inertia_tensor_partial(range(self.natom()), masswt). [docs] def inertia_tensor_partial(self, part, masswt=True):; """"""Compute inertia tensor bas",MatchSource.WIKI,psi4manual/4.0b5/_modules/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/molecule.html
https://psicode.org/psi4manual/4.0b5/_modules/qcdb/molecule.html:12409,Performance,Queue,Queue,12409,".5, # Bondi JPC 68 441 (1964); 'SN': 2.16 / 1.5, # Bondi JPC 68 441 (1964); 'SB': 2.12 / 1.5, # Bondi JPC 68 441 (1964); 'TE': 2.08 / 1.5, # Bondi JPC 68 441 (1964); 'I': 2.04 / 1.5, # Bondi JPC 68 441 (1964); 'XE': 2.05 / 1.5} # Bondi JPC 68 441 (1964). Queue = []; White = range(self.natom()) # untouched; Black = [] # touched and all edges discovered; Fragment = [] # stores fragments. start = 0 # starts with the first atom in the list; Queue.append(start); White.remove(start). # Simply start with the first atom, do a BFS when done, go to any; # untouched atom and start again iterate until all atoms belong; # to a fragment group; while len(White) > 0 or len(Queue) > 0: # Iterates to the next fragment; Fragment.append([]). while len(Queue) > 0: # BFS within a fragment; for u in Queue: # find all (still white) nearest neighbors to vertex u; for i in White:; dist = distance(self.xyz(i), self.xyz(u)) * psi_bohr2angstroms; if dist < vdW_diameter[self.symbol(u)] + vdW_diameter[self.symbol(i)]:; Queue.append(i) # if you find you, put in the queue; White.remove(i) # and remove it from the untouched list; Queue.remove(u) # remove focus from Queue; Black.append(u); Fragment[-1].append(int(u)) # add to group (0-indexed); Fragment[-1].sort() # preserve original atom ordering. if len(White) != 0: # can't move White -> Queue if no more exist; Queue.append(White[0]); White.remove(White[0]). return Fragment. [docs] def inertia_tensor(self, masswt=True):; """"""Compute inertia tensor. >>> print H2OH2O.inertia_tensor(); [[8.704574864178731, -8.828375721817082, 0.0], [-8.828375721817082, 280.82861714077666, 0.0], [0.0, 0.0, 281.249500988553]]. """"""; return self.inertia_tensor_partial(range(self.natom()), masswt). [docs] def inertia_tensor_partial(self, part, masswt=True):; """"""Compute inertia tensor based on atoms in *part*. """"""; tensor = [[0, 0, 0], [0, 0, 0], [0, 0, 0]]. for i in part:; if masswt:; # I(alpha, alpha); tensor[0][0] += self.mass(i) * (self.y(i) * self.y(i) + self.z(i) * self",MatchSource.WIKI,psi4manual/4.0b5/_modules/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/molecule.html
https://psicode.org/psi4manual/4.0b5/_modules/qcdb/molecule.html:12455,Performance,queue,queue,12455," 2.16 / 1.5, # Bondi JPC 68 441 (1964); 'SB': 2.12 / 1.5, # Bondi JPC 68 441 (1964); 'TE': 2.08 / 1.5, # Bondi JPC 68 441 (1964); 'I': 2.04 / 1.5, # Bondi JPC 68 441 (1964); 'XE': 2.05 / 1.5} # Bondi JPC 68 441 (1964). Queue = []; White = range(self.natom()) # untouched; Black = [] # touched and all edges discovered; Fragment = [] # stores fragments. start = 0 # starts with the first atom in the list; Queue.append(start); White.remove(start). # Simply start with the first atom, do a BFS when done, go to any; # untouched atom and start again iterate until all atoms belong; # to a fragment group; while len(White) > 0 or len(Queue) > 0: # Iterates to the next fragment; Fragment.append([]). while len(Queue) > 0: # BFS within a fragment; for u in Queue: # find all (still white) nearest neighbors to vertex u; for i in White:; dist = distance(self.xyz(i), self.xyz(u)) * psi_bohr2angstroms; if dist < vdW_diameter[self.symbol(u)] + vdW_diameter[self.symbol(i)]:; Queue.append(i) # if you find you, put in the queue; White.remove(i) # and remove it from the untouched list; Queue.remove(u) # remove focus from Queue; Black.append(u); Fragment[-1].append(int(u)) # add to group (0-indexed); Fragment[-1].sort() # preserve original atom ordering. if len(White) != 0: # can't move White -> Queue if no more exist; Queue.append(White[0]); White.remove(White[0]). return Fragment. [docs] def inertia_tensor(self, masswt=True):; """"""Compute inertia tensor. >>> print H2OH2O.inertia_tensor(); [[8.704574864178731, -8.828375721817082, 0.0], [-8.828375721817082, 280.82861714077666, 0.0], [0.0, 0.0, 281.249500988553]]. """"""; return self.inertia_tensor_partial(range(self.natom()), masswt). [docs] def inertia_tensor_partial(self, part, masswt=True):; """"""Compute inertia tensor based on atoms in *part*. """"""; tensor = [[0, 0, 0], [0, 0, 0], [0, 0, 0]]. for i in part:; if masswt:; # I(alpha, alpha); tensor[0][0] += self.mass(i) * (self.y(i) * self.y(i) + self.z(i) * self.z(i)); tensor[1][1] += self.mass(i)",MatchSource.WIKI,psi4manual/4.0b5/_modules/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/molecule.html
https://psicode.org/psi4manual/4.0b5/_modules/qcdb/molecule.html:12519,Performance,Queue,Queue,12519,"5, # Bondi JPC 68 441 (1964); 'TE': 2.08 / 1.5, # Bondi JPC 68 441 (1964); 'I': 2.04 / 1.5, # Bondi JPC 68 441 (1964); 'XE': 2.05 / 1.5} # Bondi JPC 68 441 (1964). Queue = []; White = range(self.natom()) # untouched; Black = [] # touched and all edges discovered; Fragment = [] # stores fragments. start = 0 # starts with the first atom in the list; Queue.append(start); White.remove(start). # Simply start with the first atom, do a BFS when done, go to any; # untouched atom and start again iterate until all atoms belong; # to a fragment group; while len(White) > 0 or len(Queue) > 0: # Iterates to the next fragment; Fragment.append([]). while len(Queue) > 0: # BFS within a fragment; for u in Queue: # find all (still white) nearest neighbors to vertex u; for i in White:; dist = distance(self.xyz(i), self.xyz(u)) * psi_bohr2angstroms; if dist < vdW_diameter[self.symbol(u)] + vdW_diameter[self.symbol(i)]:; Queue.append(i) # if you find you, put in the queue; White.remove(i) # and remove it from the untouched list; Queue.remove(u) # remove focus from Queue; Black.append(u); Fragment[-1].append(int(u)) # add to group (0-indexed); Fragment[-1].sort() # preserve original atom ordering. if len(White) != 0: # can't move White -> Queue if no more exist; Queue.append(White[0]); White.remove(White[0]). return Fragment. [docs] def inertia_tensor(self, masswt=True):; """"""Compute inertia tensor. >>> print H2OH2O.inertia_tensor(); [[8.704574864178731, -8.828375721817082, 0.0], [-8.828375721817082, 280.82861714077666, 0.0], [0.0, 0.0, 281.249500988553]]. """"""; return self.inertia_tensor_partial(range(self.natom()), masswt). [docs] def inertia_tensor_partial(self, part, masswt=True):; """"""Compute inertia tensor based on atoms in *part*. """"""; tensor = [[0, 0, 0], [0, 0, 0], [0, 0, 0]]. for i in part:; if masswt:; # I(alpha, alpha); tensor[0][0] += self.mass(i) * (self.y(i) * self.y(i) + self.z(i) * self.z(i)); tensor[1][1] += self.mass(i) * (self.x(i) * self.x(i) + self.z(i) * self.z(i)); ten",MatchSource.WIKI,psi4manual/4.0b5/_modules/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/molecule.html
https://psicode.org/psi4manual/4.0b5/_modules/qcdb/molecule.html:12555,Performance,Queue,Queue,12555,"Bondi JPC 68 441 (1964); 'I': 2.04 / 1.5, # Bondi JPC 68 441 (1964); 'XE': 2.05 / 1.5} # Bondi JPC 68 441 (1964). Queue = []; White = range(self.natom()) # untouched; Black = [] # touched and all edges discovered; Fragment = [] # stores fragments. start = 0 # starts with the first atom in the list; Queue.append(start); White.remove(start). # Simply start with the first atom, do a BFS when done, go to any; # untouched atom and start again iterate until all atoms belong; # to a fragment group; while len(White) > 0 or len(Queue) > 0: # Iterates to the next fragment; Fragment.append([]). while len(Queue) > 0: # BFS within a fragment; for u in Queue: # find all (still white) nearest neighbors to vertex u; for i in White:; dist = distance(self.xyz(i), self.xyz(u)) * psi_bohr2angstroms; if dist < vdW_diameter[self.symbol(u)] + vdW_diameter[self.symbol(i)]:; Queue.append(i) # if you find you, put in the queue; White.remove(i) # and remove it from the untouched list; Queue.remove(u) # remove focus from Queue; Black.append(u); Fragment[-1].append(int(u)) # add to group (0-indexed); Fragment[-1].sort() # preserve original atom ordering. if len(White) != 0: # can't move White -> Queue if no more exist; Queue.append(White[0]); White.remove(White[0]). return Fragment. [docs] def inertia_tensor(self, masswt=True):; """"""Compute inertia tensor. >>> print H2OH2O.inertia_tensor(); [[8.704574864178731, -8.828375721817082, 0.0], [-8.828375721817082, 280.82861714077666, 0.0], [0.0, 0.0, 281.249500988553]]. """"""; return self.inertia_tensor_partial(range(self.natom()), masswt). [docs] def inertia_tensor_partial(self, part, masswt=True):; """"""Compute inertia tensor based on atoms in *part*. """"""; tensor = [[0, 0, 0], [0, 0, 0], [0, 0, 0]]. for i in part:; if masswt:; # I(alpha, alpha); tensor[0][0] += self.mass(i) * (self.y(i) * self.y(i) + self.z(i) * self.z(i)); tensor[1][1] += self.mass(i) * (self.x(i) * self.x(i) + self.z(i) * self.z(i)); tensor[2][2] += self.mass(i) * (self.x(i) * self.x(i)",MatchSource.WIKI,psi4manual/4.0b5/_modules/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/molecule.html
https://psicode.org/psi4manual/4.0b5/_modules/qcdb/molecule.html:12732,Performance,Queue,Queue,12732," touched and all edges discovered; Fragment = [] # stores fragments. start = 0 # starts with the first atom in the list; Queue.append(start); White.remove(start). # Simply start with the first atom, do a BFS when done, go to any; # untouched atom and start again iterate until all atoms belong; # to a fragment group; while len(White) > 0 or len(Queue) > 0: # Iterates to the next fragment; Fragment.append([]). while len(Queue) > 0: # BFS within a fragment; for u in Queue: # find all (still white) nearest neighbors to vertex u; for i in White:; dist = distance(self.xyz(i), self.xyz(u)) * psi_bohr2angstroms; if dist < vdW_diameter[self.symbol(u)] + vdW_diameter[self.symbol(i)]:; Queue.append(i) # if you find you, put in the queue; White.remove(i) # and remove it from the untouched list; Queue.remove(u) # remove focus from Queue; Black.append(u); Fragment[-1].append(int(u)) # add to group (0-indexed); Fragment[-1].sort() # preserve original atom ordering. if len(White) != 0: # can't move White -> Queue if no more exist; Queue.append(White[0]); White.remove(White[0]). return Fragment. [docs] def inertia_tensor(self, masswt=True):; """"""Compute inertia tensor. >>> print H2OH2O.inertia_tensor(); [[8.704574864178731, -8.828375721817082, 0.0], [-8.828375721817082, 280.82861714077666, 0.0], [0.0, 0.0, 281.249500988553]]. """"""; return self.inertia_tensor_partial(range(self.natom()), masswt). [docs] def inertia_tensor_partial(self, part, masswt=True):; """"""Compute inertia tensor based on atoms in *part*. """"""; tensor = [[0, 0, 0], [0, 0, 0], [0, 0, 0]]. for i in part:; if masswt:; # I(alpha, alpha); tensor[0][0] += self.mass(i) * (self.y(i) * self.y(i) + self.z(i) * self.z(i)); tensor[1][1] += self.mass(i) * (self.x(i) * self.x(i) + self.z(i) * self.z(i)); tensor[2][2] += self.mass(i) * (self.x(i) * self.x(i) + self.y(i) * self.y(i)). # I(alpha, beta); tensor[0][1] -= self.mass(i) * self.x(i) * self.y(i); tensor[0][2] -= self.mass(i) * self.x(i) * self.z(i); tensor[1][2] -= self.mass(",MatchSource.WIKI,psi4manual/4.0b5/_modules/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/molecule.html
https://psicode.org/psi4manual/4.0b5/_modules/qcdb/molecule.html:12756,Performance,Queue,Queue,12756," touched and all edges discovered; Fragment = [] # stores fragments. start = 0 # starts with the first atom in the list; Queue.append(start); White.remove(start). # Simply start with the first atom, do a BFS when done, go to any; # untouched atom and start again iterate until all atoms belong; # to a fragment group; while len(White) > 0 or len(Queue) > 0: # Iterates to the next fragment; Fragment.append([]). while len(Queue) > 0: # BFS within a fragment; for u in Queue: # find all (still white) nearest neighbors to vertex u; for i in White:; dist = distance(self.xyz(i), self.xyz(u)) * psi_bohr2angstroms; if dist < vdW_diameter[self.symbol(u)] + vdW_diameter[self.symbol(i)]:; Queue.append(i) # if you find you, put in the queue; White.remove(i) # and remove it from the untouched list; Queue.remove(u) # remove focus from Queue; Black.append(u); Fragment[-1].append(int(u)) # add to group (0-indexed); Fragment[-1].sort() # preserve original atom ordering. if len(White) != 0: # can't move White -> Queue if no more exist; Queue.append(White[0]); White.remove(White[0]). return Fragment. [docs] def inertia_tensor(self, masswt=True):; """"""Compute inertia tensor. >>> print H2OH2O.inertia_tensor(); [[8.704574864178731, -8.828375721817082, 0.0], [-8.828375721817082, 280.82861714077666, 0.0], [0.0, 0.0, 281.249500988553]]. """"""; return self.inertia_tensor_partial(range(self.natom()), masswt). [docs] def inertia_tensor_partial(self, part, masswt=True):; """"""Compute inertia tensor based on atoms in *part*. """"""; tensor = [[0, 0, 0], [0, 0, 0], [0, 0, 0]]. for i in part:; if masswt:; # I(alpha, alpha); tensor[0][0] += self.mass(i) * (self.y(i) * self.y(i) + self.z(i) * self.z(i)); tensor[1][1] += self.mass(i) * (self.x(i) * self.x(i) + self.z(i) * self.z(i)); tensor[2][2] += self.mass(i) * (self.x(i) * self.x(i) + self.y(i) * self.y(i)). # I(alpha, beta); tensor[0][1] -= self.mass(i) * self.x(i) * self.y(i); tensor[0][2] -= self.mass(i) * self.x(i) * self.z(i); tensor[1][2] -= self.mass(",MatchSource.WIKI,psi4manual/4.0b5/_modules/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/molecule.html
https://psicode.org/psi4manual/4.0b5/_modules/qcdb/molecule.html:1937,Safety,detect,detected,1937," 02110-1301 USA.; #; #@END LICENSE; #. import os; #import re; #import math; #import copy; #from periodictable import *; #from physconst import *; #from vecutil import *; #from exceptions import *; #from coordentry import *; import subprocess; import socket; import shutil; import random; from libmintsmolecule import *. [docs]class Molecule(LibmintsMolecule):; """"""Class to store python extensions to the MoleculeLibmints class.; Multiple classes allows separation of libmints and extension methods. """""". def __init__(self, psi4molstr=None):; """"""Initialize Molecule object from LibmintsMolecule""""""; LibmintsMolecule.__init__(self, psi4molstr). # The comment line; self.tagline = """". def __str__(self):; text = """""" ==> qcdb Molecule %s <==\n\n"""""" % (self.name()); text += """""" => %s <=\n\n"""""" % (self.tagline); text += self.save_string_for_psi4(); return text. @classmethod; [docs] def init_with_xyz(cls, xyzfilename, no_com=False, no_reorient=False):; """"""Pull information from an XYZ file. No fragment info detected.; Charge, multiplicity, tagline pulled from second line if available. >>> H2O = qcdb.Molecule.init_with_xyz('h2o.xyz'). """"""; instance = cls(); instance.lock_frame = False; instance.PYmove_to_com = not no_com; instance.PYfix_orientation = no_reorient. try:; infile = open(xyzfilename, 'r'); except IOError:; raise ValidationError(""""""Molecule::init_with_xyz: given filename '%s' does not exist."""""" % (xyzfilename)); if os.stat(xyzfilename).st_size == 0:; raise ValidationError(""""""Molecule::init_with_xyz: given filename '%s' is blank."""""" % (xyzfilename)); text = infile.readlines(). xyz1 = re.compile(r""^\s*(\d+)\s*(bohr|au)?\s*$"", re.IGNORECASE); xyz2 = re.compile(r'^\s*(-?\d+)\s+(\d+)\s+(.*)\s*$'); xyzN = re.compile(r""(?:\s*)([A-Z](?:[a-z])?)(?:\s+)(-?\d+\.\d+)(?:\s+)(-?\d+\.\d+)(?:\s+)(-?\d+\.\d+)(?:\s*)"", re.IGNORECASE). # Try to match the first line; if xyz1.match(text[0]):; fileNatom = int(xyz1.match(text[0]).group(1)); if xyz1.match(text[0]).group(2) == None:; fileUnits = 'An",MatchSource.WIKI,psi4manual/4.0b5/_modules/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/molecule.html
https://psicode.org/psi4manual/4.0b5/_modules/qcdb/molecule.html:8859,Safety,Detect,Detects,8859,"GE=%d\n' % (self.molecular_charge()); text += 'SET,SPIN=%d\n' % (self.multiplicity() - 1) # Molpro wants (mult-1). textDummy = ""dummy""; for fr in range(self.nfragments()):; if self.fragment_types[fr] == 'Ghost':; for at in range(self.fragments[fr][0], self.fragments[fr][1] + 1):; textDummy += """""",%d"""""" % (at + 1) # Molpro atom numbering is 1-indexed; textDummy += '\n'; if len(textDummy) > 6:; text += textDummy; return text. [docs] def format_molecule_for_nwchem(self):; """""". """"""; factor = 1.0 if self.PYunits == 'Angstrom' else psi_bohr2angstroms. text = """"; text += '%d %d %s\n' % (self.molecular_charge(), self.multiplicity(), self.tagline). for i in range(self.natom()):; [x, y, z] = self.atoms[i].compute(); text += '%4s %17.12f %17.12f %17.12f\n' % (("""" if self.Z(i) else 'Bq') + self.symbol(i), \; x * factor, y * factor, z * factor); return text; pass. # if symm print M2OUT ""nosym\nnoorient\n"";; # print DIOUT ""angstrom\ngeometry={\n"";. [docs] def auto_fragments(self):; """"""Detects fragments in an unfragmented molecule using BFS; algorithm. Returns a new Molecule in Cartesian, fixed-geom; (no variable values), no dummy-atom format. Any non-default; charge and multiplicity assigned to first fragment. """"""; if self.nfragments() != 1:; print 'Molecule already fragmented so no further action by auto_fragments().'; return self. flist = self.BFS(). # form new molecule through a string since self may contain; # dummies or zmatrix specs that mayn't be valid with atom shuffling; new_geom = '\n'. if self.PYcharge_specified or self.PYmultiplicity_specified:; new_geom = """"""\n %d %d\n"""""" % (self.molecular_charge(), self.multiplicity()). for fr in range(len(flist)):; new_geom += """" if fr == 0 else "" --\n""; for at in flist[fr]:; geom = self.atoms[at].compute(); new_geom += """"""%-4s """""" % (("""" if self.Z(at) else ""@"") + self.symbol(at)); for j in range(3):; new_geom += """""" %17.12f"""""" % (geom[j]); new_geom += ""\n""; new_geom += "" units %s\n"" % (self.units()); if not self.PYmove_to_com:; new",MatchSource.WIKI,psi4manual/4.0b5/_modules/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/molecule.html
https://psicode.org/psi4manual/4.0b5/_modules/qcdb/molecule.html:2259,Security,Validat,ValidationError,2259,"ecule(LibmintsMolecule):; """"""Class to store python extensions to the MoleculeLibmints class.; Multiple classes allows separation of libmints and extension methods. """""". def __init__(self, psi4molstr=None):; """"""Initialize Molecule object from LibmintsMolecule""""""; LibmintsMolecule.__init__(self, psi4molstr). # The comment line; self.tagline = """". def __str__(self):; text = """""" ==> qcdb Molecule %s <==\n\n"""""" % (self.name()); text += """""" => %s <=\n\n"""""" % (self.tagline); text += self.save_string_for_psi4(); return text. @classmethod; [docs] def init_with_xyz(cls, xyzfilename, no_com=False, no_reorient=False):; """"""Pull information from an XYZ file. No fragment info detected.; Charge, multiplicity, tagline pulled from second line if available. >>> H2O = qcdb.Molecule.init_with_xyz('h2o.xyz'). """"""; instance = cls(); instance.lock_frame = False; instance.PYmove_to_com = not no_com; instance.PYfix_orientation = no_reorient. try:; infile = open(xyzfilename, 'r'); except IOError:; raise ValidationError(""""""Molecule::init_with_xyz: given filename '%s' does not exist."""""" % (xyzfilename)); if os.stat(xyzfilename).st_size == 0:; raise ValidationError(""""""Molecule::init_with_xyz: given filename '%s' is blank."""""" % (xyzfilename)); text = infile.readlines(). xyz1 = re.compile(r""^\s*(\d+)\s*(bohr|au)?\s*$"", re.IGNORECASE); xyz2 = re.compile(r'^\s*(-?\d+)\s+(\d+)\s+(.*)\s*$'); xyzN = re.compile(r""(?:\s*)([A-Z](?:[a-z])?)(?:\s+)(-?\d+\.\d+)(?:\s+)(-?\d+\.\d+)(?:\s+)(-?\d+\.\d+)(?:\s*)"", re.IGNORECASE). # Try to match the first line; if xyz1.match(text[0]):; fileNatom = int(xyz1.match(text[0]).group(1)); if xyz1.match(text[0]).group(2) == None:; fileUnits = 'Angstrom'; else:; fileUnits = 'Bohr'; else:; raise ValidationError(""Molecule::init_with_xyz: Malformed first line\n%s"" % (text[0])). # Try to match the second line; if xyz2.match(text[1]):; instance.set_molecular_charge(int(xyz2.match(text[1]).group(1))); instance.set_multiplicity(int(xyz2.match(text[1]).group(2))); instance.tagline =",MatchSource.WIKI,psi4manual/4.0b5/_modules/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/molecule.html
https://psicode.org/psi4manual/4.0b5/_modules/qcdb/molecule.html:2405,Security,Validat,ValidationError,2405,""""""". def __init__(self, psi4molstr=None):; """"""Initialize Molecule object from LibmintsMolecule""""""; LibmintsMolecule.__init__(self, psi4molstr). # The comment line; self.tagline = """". def __str__(self):; text = """""" ==> qcdb Molecule %s <==\n\n"""""" % (self.name()); text += """""" => %s <=\n\n"""""" % (self.tagline); text += self.save_string_for_psi4(); return text. @classmethod; [docs] def init_with_xyz(cls, xyzfilename, no_com=False, no_reorient=False):; """"""Pull information from an XYZ file. No fragment info detected.; Charge, multiplicity, tagline pulled from second line if available. >>> H2O = qcdb.Molecule.init_with_xyz('h2o.xyz'). """"""; instance = cls(); instance.lock_frame = False; instance.PYmove_to_com = not no_com; instance.PYfix_orientation = no_reorient. try:; infile = open(xyzfilename, 'r'); except IOError:; raise ValidationError(""""""Molecule::init_with_xyz: given filename '%s' does not exist."""""" % (xyzfilename)); if os.stat(xyzfilename).st_size == 0:; raise ValidationError(""""""Molecule::init_with_xyz: given filename '%s' is blank."""""" % (xyzfilename)); text = infile.readlines(). xyz1 = re.compile(r""^\s*(\d+)\s*(bohr|au)?\s*$"", re.IGNORECASE); xyz2 = re.compile(r'^\s*(-?\d+)\s+(\d+)\s+(.*)\s*$'); xyzN = re.compile(r""(?:\s*)([A-Z](?:[a-z])?)(?:\s+)(-?\d+\.\d+)(?:\s+)(-?\d+\.\d+)(?:\s+)(-?\d+\.\d+)(?:\s*)"", re.IGNORECASE). # Try to match the first line; if xyz1.match(text[0]):; fileNatom = int(xyz1.match(text[0]).group(1)); if xyz1.match(text[0]).group(2) == None:; fileUnits = 'Angstrom'; else:; fileUnits = 'Bohr'; else:; raise ValidationError(""Molecule::init_with_xyz: Malformed first line\n%s"" % (text[0])). # Try to match the second line; if xyz2.match(text[1]):; instance.set_molecular_charge(int(xyz2.match(text[1]).group(1))); instance.set_multiplicity(int(xyz2.match(text[1]).group(2))); instance.tagline = xyz2.match(text[1]).group(3).strip(); else:; instance.tagline = text[1].strip(). # Next line begins the useful information.; for i in range(fileNatom):; try:; if x",MatchSource.WIKI,psi4manual/4.0b5/_modules/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/molecule.html
https://psicode.org/psi4manual/4.0b5/_modules/qcdb/molecule.html:2982,Security,Validat,ValidationError,2982,"led from second line if available. >>> H2O = qcdb.Molecule.init_with_xyz('h2o.xyz'). """"""; instance = cls(); instance.lock_frame = False; instance.PYmove_to_com = not no_com; instance.PYfix_orientation = no_reorient. try:; infile = open(xyzfilename, 'r'); except IOError:; raise ValidationError(""""""Molecule::init_with_xyz: given filename '%s' does not exist."""""" % (xyzfilename)); if os.stat(xyzfilename).st_size == 0:; raise ValidationError(""""""Molecule::init_with_xyz: given filename '%s' is blank."""""" % (xyzfilename)); text = infile.readlines(). xyz1 = re.compile(r""^\s*(\d+)\s*(bohr|au)?\s*$"", re.IGNORECASE); xyz2 = re.compile(r'^\s*(-?\d+)\s+(\d+)\s+(.*)\s*$'); xyzN = re.compile(r""(?:\s*)([A-Z](?:[a-z])?)(?:\s+)(-?\d+\.\d+)(?:\s+)(-?\d+\.\d+)(?:\s+)(-?\d+\.\d+)(?:\s*)"", re.IGNORECASE). # Try to match the first line; if xyz1.match(text[0]):; fileNatom = int(xyz1.match(text[0]).group(1)); if xyz1.match(text[0]).group(2) == None:; fileUnits = 'Angstrom'; else:; fileUnits = 'Bohr'; else:; raise ValidationError(""Molecule::init_with_xyz: Malformed first line\n%s"" % (text[0])). # Try to match the second line; if xyz2.match(text[1]):; instance.set_molecular_charge(int(xyz2.match(text[1]).group(1))); instance.set_multiplicity(int(xyz2.match(text[1]).group(2))); instance.tagline = xyz2.match(text[1]).group(3).strip(); else:; instance.tagline = text[1].strip(). # Next line begins the useful information.; for i in range(fileNatom):; try:; if xyzN.match(text[2 + i]):. fileAtom = xyzN.match(text[2 + i]).group(1).upper(); fileX = float(xyzN.match(text[2 + i]).group(2)); fileY = float(xyzN.match(text[2 + i]).group(3)); fileZ = float(xyzN.match(text[2 + i]).group(4)). # Check that the atom symbol is valid; if not fileAtom in el2z:; raise ValidationError('Illegal atom symbol in geometry specification: %s' % (atomSym)). # Add it to the molecule.; instance.add_atom(el2z[fileAtom], fileX, fileY, fileZ, fileAtom, el2masses[fileAtom]). else:; raise ValidationError(""Molecule::init_with_xyz: Mal",MatchSource.WIKI,psi4manual/4.0b5/_modules/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/molecule.html
https://psicode.org/psi4manual/4.0b5/_modules/qcdb/molecule.html:3727,Security,Validat,ValidationError,3727,"\s+)(-?\d+\.\d+)(?:\s*)"", re.IGNORECASE). # Try to match the first line; if xyz1.match(text[0]):; fileNatom = int(xyz1.match(text[0]).group(1)); if xyz1.match(text[0]).group(2) == None:; fileUnits = 'Angstrom'; else:; fileUnits = 'Bohr'; else:; raise ValidationError(""Molecule::init_with_xyz: Malformed first line\n%s"" % (text[0])). # Try to match the second line; if xyz2.match(text[1]):; instance.set_molecular_charge(int(xyz2.match(text[1]).group(1))); instance.set_multiplicity(int(xyz2.match(text[1]).group(2))); instance.tagline = xyz2.match(text[1]).group(3).strip(); else:; instance.tagline = text[1].strip(). # Next line begins the useful information.; for i in range(fileNatom):; try:; if xyzN.match(text[2 + i]):. fileAtom = xyzN.match(text[2 + i]).group(1).upper(); fileX = float(xyzN.match(text[2 + i]).group(2)); fileY = float(xyzN.match(text[2 + i]).group(3)); fileZ = float(xyzN.match(text[2 + i]).group(4)). # Check that the atom symbol is valid; if not fileAtom in el2z:; raise ValidationError('Illegal atom symbol in geometry specification: %s' % (atomSym)). # Add it to the molecule.; instance.add_atom(el2z[fileAtom], fileX, fileY, fileZ, fileAtom, el2masses[fileAtom]). else:; raise ValidationError(""Molecule::init_with_xyz: Malformed atom information line %d."" % (i + 3)); except IndexError:; raise ValidationError(""Molecule::init_with_xyz: Expected atom in file at line %d.\n%s"" % (i + 3, text[i + 2])). # We need to make 1 fragment with all atoms; instance.fragments.append([0, fileNatom - 1]); instance.fragment_types.append('Real'); instance.fragment_charges.append(instance.molecular_charge()); instance.fragment_multiplicities.append(instance.multiplicity()); # Set the units properly; instance.PYunits = fileUnits; if fileUnits == 'Bohr':; instance.input_units_to_au = 1.0; elif fileUnits == 'Angstrom':; instance.input_units_to_au = 1.0 / psi_bohr2angstroms. instance.update_geometry(); return instance. [docs] def save_string_xyz(self, save_ghosts=True):; """"""Save a str",MatchSource.WIKI,psi4manual/4.0b5/_modules/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/molecule.html
https://psicode.org/psi4manual/4.0b5/_modules/qcdb/molecule.html:3936,Security,Validat,ValidationError,3936,"; else:; raise ValidationError(""Molecule::init_with_xyz: Malformed first line\n%s"" % (text[0])). # Try to match the second line; if xyz2.match(text[1]):; instance.set_molecular_charge(int(xyz2.match(text[1]).group(1))); instance.set_multiplicity(int(xyz2.match(text[1]).group(2))); instance.tagline = xyz2.match(text[1]).group(3).strip(); else:; instance.tagline = text[1].strip(). # Next line begins the useful information.; for i in range(fileNatom):; try:; if xyzN.match(text[2 + i]):. fileAtom = xyzN.match(text[2 + i]).group(1).upper(); fileX = float(xyzN.match(text[2 + i]).group(2)); fileY = float(xyzN.match(text[2 + i]).group(3)); fileZ = float(xyzN.match(text[2 + i]).group(4)). # Check that the atom symbol is valid; if not fileAtom in el2z:; raise ValidationError('Illegal atom symbol in geometry specification: %s' % (atomSym)). # Add it to the molecule.; instance.add_atom(el2z[fileAtom], fileX, fileY, fileZ, fileAtom, el2masses[fileAtom]). else:; raise ValidationError(""Molecule::init_with_xyz: Malformed atom information line %d."" % (i + 3)); except IndexError:; raise ValidationError(""Molecule::init_with_xyz: Expected atom in file at line %d.\n%s"" % (i + 3, text[i + 2])). # We need to make 1 fragment with all atoms; instance.fragments.append([0, fileNatom - 1]); instance.fragment_types.append('Real'); instance.fragment_charges.append(instance.molecular_charge()); instance.fragment_multiplicities.append(instance.multiplicity()); # Set the units properly; instance.PYunits = fileUnits; if fileUnits == 'Bohr':; instance.input_units_to_au = 1.0; elif fileUnits == 'Angstrom':; instance.input_units_to_au = 1.0 / psi_bohr2angstroms. instance.update_geometry(); return instance. [docs] def save_string_xyz(self, save_ghosts=True):; """"""Save a string for a XYZ-style file. >>> H2OH2O.save_string_xyz(); 6; -2 3 water_dimer; O -1.551007000000 -0.114520000000 0.000000000000; H -1.934259000000 0.762503000000 0.000000000000; H -0.599677000000 0.040712000000 0.000000000000; O 1.3506250",MatchSource.WIKI,psi4manual/4.0b5/_modules/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/molecule.html
https://psicode.org/psi4manual/4.0b5/_modules/qcdb/molecule.html:4053,Security,Validat,ValidationError,4053,"to match the second line; if xyz2.match(text[1]):; instance.set_molecular_charge(int(xyz2.match(text[1]).group(1))); instance.set_multiplicity(int(xyz2.match(text[1]).group(2))); instance.tagline = xyz2.match(text[1]).group(3).strip(); else:; instance.tagline = text[1].strip(). # Next line begins the useful information.; for i in range(fileNatom):; try:; if xyzN.match(text[2 + i]):. fileAtom = xyzN.match(text[2 + i]).group(1).upper(); fileX = float(xyzN.match(text[2 + i]).group(2)); fileY = float(xyzN.match(text[2 + i]).group(3)); fileZ = float(xyzN.match(text[2 + i]).group(4)). # Check that the atom symbol is valid; if not fileAtom in el2z:; raise ValidationError('Illegal atom symbol in geometry specification: %s' % (atomSym)). # Add it to the molecule.; instance.add_atom(el2z[fileAtom], fileX, fileY, fileZ, fileAtom, el2masses[fileAtom]). else:; raise ValidationError(""Molecule::init_with_xyz: Malformed atom information line %d."" % (i + 3)); except IndexError:; raise ValidationError(""Molecule::init_with_xyz: Expected atom in file at line %d.\n%s"" % (i + 3, text[i + 2])). # We need to make 1 fragment with all atoms; instance.fragments.append([0, fileNatom - 1]); instance.fragment_types.append('Real'); instance.fragment_charges.append(instance.molecular_charge()); instance.fragment_multiplicities.append(instance.multiplicity()); # Set the units properly; instance.PYunits = fileUnits; if fileUnits == 'Bohr':; instance.input_units_to_au = 1.0; elif fileUnits == 'Angstrom':; instance.input_units_to_au = 1.0 / psi_bohr2angstroms. instance.update_geometry(); return instance. [docs] def save_string_xyz(self, save_ghosts=True):; """"""Save a string for a XYZ-style file. >>> H2OH2O.save_string_xyz(); 6; -2 3 water_dimer; O -1.551007000000 -0.114520000000 0.000000000000; H -1.934259000000 0.762503000000 0.000000000000; H -0.599677000000 0.040712000000 0.000000000000; O 1.350625000000 0.111469000000 0.000000000000; H 1.680398000000 -0.373741000000 -0.758561000000; H 1.680398000000",MatchSource.WIKI,psi4manual/4.0b5/_modules/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/molecule.html
https://psicode.org/psi4manual/4.0b5/_modules/qcdb/molecule.html:26401,Security,Validat,Validate,26401,"2.2609, 'a2': 3.2297}, # in psi4; 'blyp' : {'s6': 1.000, 'a1': 0.4298, 's8': 2.6996, 'a2': 4.2359}, # in psi4; 'bp86' : {'s6': 1.000, 'a1': 0.3946, 's8': 3.2822, 'a2': 4.8516}, # in psi4; 'dsd-blyp' : {'s6': 0.500, 'a1': 0.000, 's8': 0.2130, 'a2': 6.0519}, # in psi4; 'pbe0' : {'s6': 1.000, 'a1': 0.4145, 's8': 1.2177, 'a2': 4.8593}, # in psi4; 'pbe' : {'s6': 1.000, 'a1': 0.4289, 's8': 0.7875, 'a2': 4.4407}, # in psi4; 'pw6b95' : {'s6': 1.000, 'a1': 0.2076, 's8': 0.7257, 'a2': 6.3750},; 'pwpb95' : {'s6': 0.820, 'a1': 0.0000, 's8': 0.2904, 'a2': 7.3141},; 'revpbe0' : {'s6': 1.000, 'a1': 0.4679, 's8': 1.7588, 'a2': 3.7619},; 'revpbe38' : {'s6': 1.000, 'a1': 0.4309, 's8': 1.4760, 'a2': 3.9446},; 'revpbe' : {'s6': 1.000, 'a1': 0.5238, 's8': 2.3550, 'a2': 3.5016},; 'rpw86pbe' : {'s6': 1.000, 'a1': 0.4613, 's8': 1.3845, 'a2': 4.5062},; 'tpss0' : {'s6': 1.000, 'a1': 0.3768, 's8': 1.2576, 'a2': 4.5865},; 'tpss' : {'s6': 1.000, 'a1': 0.4535, 's8': 1.9435, 'a2': 4.4752},; }; }. # Validate arguments; dashlvl = dashlvl.lower(); if dashlvl not in dashcoeff.keys():; raise ValidationError(""""""-D correction level %s is not available. Choose among %s."""""" % (dashlvl, dashcoeff.keys())). if func is None:; if dashparam is None:; # defunct case; raise ValidationError(""""""Parameters for -D correction missing. Provide a func or a dashparam kwarg.""""""); else:; # case where all param read from dashparam dict (which must have all correct keys); func = 'custom'; dashcoeff[dashlvl][func] = {}; dashparam = dict((k.lower(), v) for k, v in dashparam.iteritems()); for key in dashcoeff[dashlvl]['b3lyp'].keys():; if key in dashparam.keys():; dashcoeff[dashlvl][func][key] = dashparam[key]; else:; raise ValidationError(""""""Parameter %s is missing from dashparam dict %s."""""" % (key, dashparam)); else:; func = func.lower(); if func not in dashcoeff[dashlvl].keys():; raise ValidationError(""""""Functional %s is not available for -D level %s."""""" % (func, dashlvl)); if dashparam is None:; # (normal) case where all pa",MatchSource.WIKI,psi4manual/4.0b5/_modules/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/molecule.html
https://psicode.org/psi4manual/4.0b5/_modules/qcdb/molecule.html:26491,Security,Validat,ValidationError,26491,"59}, # in psi4; 'bp86' : {'s6': 1.000, 'a1': 0.3946, 's8': 3.2822, 'a2': 4.8516}, # in psi4; 'dsd-blyp' : {'s6': 0.500, 'a1': 0.000, 's8': 0.2130, 'a2': 6.0519}, # in psi4; 'pbe0' : {'s6': 1.000, 'a1': 0.4145, 's8': 1.2177, 'a2': 4.8593}, # in psi4; 'pbe' : {'s6': 1.000, 'a1': 0.4289, 's8': 0.7875, 'a2': 4.4407}, # in psi4; 'pw6b95' : {'s6': 1.000, 'a1': 0.2076, 's8': 0.7257, 'a2': 6.3750},; 'pwpb95' : {'s6': 0.820, 'a1': 0.0000, 's8': 0.2904, 'a2': 7.3141},; 'revpbe0' : {'s6': 1.000, 'a1': 0.4679, 's8': 1.7588, 'a2': 3.7619},; 'revpbe38' : {'s6': 1.000, 'a1': 0.4309, 's8': 1.4760, 'a2': 3.9446},; 'revpbe' : {'s6': 1.000, 'a1': 0.5238, 's8': 2.3550, 'a2': 3.5016},; 'rpw86pbe' : {'s6': 1.000, 'a1': 0.4613, 's8': 1.3845, 'a2': 4.5062},; 'tpss0' : {'s6': 1.000, 'a1': 0.3768, 's8': 1.2576, 'a2': 4.5865},; 'tpss' : {'s6': 1.000, 'a1': 0.4535, 's8': 1.9435, 'a2': 4.4752},; }; }. # Validate arguments; dashlvl = dashlvl.lower(); if dashlvl not in dashcoeff.keys():; raise ValidationError(""""""-D correction level %s is not available. Choose among %s."""""" % (dashlvl, dashcoeff.keys())). if func is None:; if dashparam is None:; # defunct case; raise ValidationError(""""""Parameters for -D correction missing. Provide a func or a dashparam kwarg.""""""); else:; # case where all param read from dashparam dict (which must have all correct keys); func = 'custom'; dashcoeff[dashlvl][func] = {}; dashparam = dict((k.lower(), v) for k, v in dashparam.iteritems()); for key in dashcoeff[dashlvl]['b3lyp'].keys():; if key in dashparam.keys():; dashcoeff[dashlvl][func][key] = dashparam[key]; else:; raise ValidationError(""""""Parameter %s is missing from dashparam dict %s."""""" % (key, dashparam)); else:; func = func.lower(); if func not in dashcoeff[dashlvl].keys():; raise ValidationError(""""""Functional %s is not available for -D level %s."""""" % (func, dashlvl)); if dashparam is None:; # (normal) case where all param taken from dashcoeff above; pass; else:; # case where items in dashparam dict can override",MatchSource.WIKI,psi4manual/4.0b5/_modules/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/molecule.html
https://psicode.org/psi4manual/4.0b5/_modules/qcdb/molecule.html:26666,Security,Validat,ValidationError,26666,"2': 6.0519}, # in psi4; 'pbe0' : {'s6': 1.000, 'a1': 0.4145, 's8': 1.2177, 'a2': 4.8593}, # in psi4; 'pbe' : {'s6': 1.000, 'a1': 0.4289, 's8': 0.7875, 'a2': 4.4407}, # in psi4; 'pw6b95' : {'s6': 1.000, 'a1': 0.2076, 's8': 0.7257, 'a2': 6.3750},; 'pwpb95' : {'s6': 0.820, 'a1': 0.0000, 's8': 0.2904, 'a2': 7.3141},; 'revpbe0' : {'s6': 1.000, 'a1': 0.4679, 's8': 1.7588, 'a2': 3.7619},; 'revpbe38' : {'s6': 1.000, 'a1': 0.4309, 's8': 1.4760, 'a2': 3.9446},; 'revpbe' : {'s6': 1.000, 'a1': 0.5238, 's8': 2.3550, 'a2': 3.5016},; 'rpw86pbe' : {'s6': 1.000, 'a1': 0.4613, 's8': 1.3845, 'a2': 4.5062},; 'tpss0' : {'s6': 1.000, 'a1': 0.3768, 's8': 1.2576, 'a2': 4.5865},; 'tpss' : {'s6': 1.000, 'a1': 0.4535, 's8': 1.9435, 'a2': 4.4752},; }; }. # Validate arguments; dashlvl = dashlvl.lower(); if dashlvl not in dashcoeff.keys():; raise ValidationError(""""""-D correction level %s is not available. Choose among %s."""""" % (dashlvl, dashcoeff.keys())). if func is None:; if dashparam is None:; # defunct case; raise ValidationError(""""""Parameters for -D correction missing. Provide a func or a dashparam kwarg.""""""); else:; # case where all param read from dashparam dict (which must have all correct keys); func = 'custom'; dashcoeff[dashlvl][func] = {}; dashparam = dict((k.lower(), v) for k, v in dashparam.iteritems()); for key in dashcoeff[dashlvl]['b3lyp'].keys():; if key in dashparam.keys():; dashcoeff[dashlvl][func][key] = dashparam[key]; else:; raise ValidationError(""""""Parameter %s is missing from dashparam dict %s."""""" % (key, dashparam)); else:; func = func.lower(); if func not in dashcoeff[dashlvl].keys():; raise ValidationError(""""""Functional %s is not available for -D level %s."""""" % (func, dashlvl)); if dashparam is None:; # (normal) case where all param taken from dashcoeff above; pass; else:; # case where items in dashparam dict can override param taken from dashcoeff above; dashparam = dict((k.lower(), v) for k, v in dashparam.iteritems()); for key in dashcoeff[dashlvl]['b3lyp'].keys():",MatchSource.WIKI,psi4manual/4.0b5/_modules/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/molecule.html
https://psicode.org/psi4manual/4.0b5/_modules/qcdb/molecule.html:27110,Security,Validat,ValidationError,27110,"3.9446},; 'revpbe' : {'s6': 1.000, 'a1': 0.5238, 's8': 2.3550, 'a2': 3.5016},; 'rpw86pbe' : {'s6': 1.000, 'a1': 0.4613, 's8': 1.3845, 'a2': 4.5062},; 'tpss0' : {'s6': 1.000, 'a1': 0.3768, 's8': 1.2576, 'a2': 4.5865},; 'tpss' : {'s6': 1.000, 'a1': 0.4535, 's8': 1.9435, 'a2': 4.4752},; }; }. # Validate arguments; dashlvl = dashlvl.lower(); if dashlvl not in dashcoeff.keys():; raise ValidationError(""""""-D correction level %s is not available. Choose among %s."""""" % (dashlvl, dashcoeff.keys())). if func is None:; if dashparam is None:; # defunct case; raise ValidationError(""""""Parameters for -D correction missing. Provide a func or a dashparam kwarg.""""""); else:; # case where all param read from dashparam dict (which must have all correct keys); func = 'custom'; dashcoeff[dashlvl][func] = {}; dashparam = dict((k.lower(), v) for k, v in dashparam.iteritems()); for key in dashcoeff[dashlvl]['b3lyp'].keys():; if key in dashparam.keys():; dashcoeff[dashlvl][func][key] = dashparam[key]; else:; raise ValidationError(""""""Parameter %s is missing from dashparam dict %s."""""" % (key, dashparam)); else:; func = func.lower(); if func not in dashcoeff[dashlvl].keys():; raise ValidationError(""""""Functional %s is not available for -D level %s."""""" % (func, dashlvl)); if dashparam is None:; # (normal) case where all param taken from dashcoeff above; pass; else:; # case where items in dashparam dict can override param taken from dashcoeff above; dashparam = dict((k.lower(), v) for k, v in dashparam.iteritems()); for key in dashcoeff[dashlvl]['b3lyp'].keys():; if key in dashparam.keys():; dashcoeff[dashlvl][func][key] = dashparam[key]. # Move ~/.dftd3par.<hostname> out of the way so it won't interfere; defaultfile = os.path.expanduser('~') + '/.dftd3par.' + socket.gethostname(); defmoved = False; if os.path.isfile(defaultfile):; os.rename(defaultfile, defaultfile + '_hide'); defmoved = True. # Setup unique scratch directory and move in; current_directory = os.getcwd(); dftd3_tmpdir = 'dftd3_' + s",MatchSource.WIKI,psi4manual/4.0b5/_modules/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/molecule.html
https://psicode.org/psi4manual/4.0b5/_modules/qcdb/molecule.html:27278,Security,Validat,ValidationError,27278,".2576, 'a2': 4.5865},; 'tpss' : {'s6': 1.000, 'a1': 0.4535, 's8': 1.9435, 'a2': 4.4752},; }; }. # Validate arguments; dashlvl = dashlvl.lower(); if dashlvl not in dashcoeff.keys():; raise ValidationError(""""""-D correction level %s is not available. Choose among %s."""""" % (dashlvl, dashcoeff.keys())). if func is None:; if dashparam is None:; # defunct case; raise ValidationError(""""""Parameters for -D correction missing. Provide a func or a dashparam kwarg.""""""); else:; # case where all param read from dashparam dict (which must have all correct keys); func = 'custom'; dashcoeff[dashlvl][func] = {}; dashparam = dict((k.lower(), v) for k, v in dashparam.iteritems()); for key in dashcoeff[dashlvl]['b3lyp'].keys():; if key in dashparam.keys():; dashcoeff[dashlvl][func][key] = dashparam[key]; else:; raise ValidationError(""""""Parameter %s is missing from dashparam dict %s."""""" % (key, dashparam)); else:; func = func.lower(); if func not in dashcoeff[dashlvl].keys():; raise ValidationError(""""""Functional %s is not available for -D level %s."""""" % (func, dashlvl)); if dashparam is None:; # (normal) case where all param taken from dashcoeff above; pass; else:; # case where items in dashparam dict can override param taken from dashcoeff above; dashparam = dict((k.lower(), v) for k, v in dashparam.iteritems()); for key in dashcoeff[dashlvl]['b3lyp'].keys():; if key in dashparam.keys():; dashcoeff[dashlvl][func][key] = dashparam[key]. # Move ~/.dftd3par.<hostname> out of the way so it won't interfere; defaultfile = os.path.expanduser('~') + '/.dftd3par.' + socket.gethostname(); defmoved = False; if os.path.isfile(defaultfile):; os.rename(defaultfile, defaultfile + '_hide'); defmoved = True. # Setup unique scratch directory and move in; current_directory = os.getcwd(); dftd3_tmpdir = 'dftd3_' + str(random.randint(0, 99999)); if os.path.exists(dftd3_tmpdir) is False:; os.mkdir(dftd3_tmpdir); os.chdir(dftd3_tmpdir). # Write dftd3_parameters file that governs dispersion calc; paramfile = './",MatchSource.WIKI,psi4manual/4.0b5/_modules/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/molecule.html
https://psicode.org/psi4manual/4.0b5/_modules/qcdb/molecule.html:29496,Security,Validat,ValidationError,29496,", dashcoeff[dashlvl][func]['sr6'], dashcoeff[dashlvl][func]['s8'],; 0.0, dashcoeff[dashlvl][func]['alpha6'], 2)); elif dashlvl == 'd3zero':; # d3zero: s6 sr6 s8 a2=None alpha6 version=3; pfile.write('%12.6f %12.6f %12.6f %12.6f %12.6f %6d\n' %; (dashcoeff[dashlvl][func]['s6'], dashcoeff[dashlvl][func]['sr6'], dashcoeff[dashlvl][func]['s8'],; 1.0, dashcoeff[dashlvl][func]['alpha6'], 3)); elif dashlvl == 'd3bj':; # d3bj: s6 a1 s8 a2 alpha6=None version=4; pfile.write('%12.6f %12.6f %12.6f %12.6f %12.6f %6d\n' %; (dashcoeff[dashlvl][func]['s6'], dashcoeff[dashlvl][func]['a1'], dashcoeff[dashlvl][func]['s8'],; dashcoeff[dashlvl][func]['a2'], 0.0, 4)); pfile.close(). # Write dftd3_geometry file that supplies geometry to dispersion calc; geomfile = './dftd3_geometry.xyz'; gfile = open(geomfile, 'w'); gfile.write(self.save_string_xyz()); gfile.close(). # Call dftd3 program; try:; dashout = subprocess.Popen(['dftd3', geomfile, '-grad'], stdout=subprocess.PIPE); except OSError:; raise ValidationError('Program dftd3 not found in path.'); out, err = dashout.communicate(); if verbosity >= 3:; print out. # Parse output (could go further and break into E6, E8, E10 and Cn coeff); success = False; for line in out.splitlines():; if re.match(' Edisp /kcal,au', line):; sline = line.split(); dashd = float(sline[3]); if re.match(' normal termination of dftd3', line):; success = True. if not success:; raise ValidationError('Program dftd3 did not complete successfully.'). # Parse grad output; derivfile = './dftd3_gradient'; dfile = open(derivfile, 'r'); dashdderiv = []; for at in dfile.readlines():; dashdderiv.append([float(x.replace('D', 'E')) for x in at.split()]); dfile.close(); if len(dashdderiv) != self.natom():; raise ValidationError('Program dftd3 gradient file has %d atoms- %d expected.' % \; (len(dashdderiv), self.natom())). # Clean up files and remove scratch directory; # os.unlink(paramfile); # os.unlink(geomfile); # os.unlink(derivfile); if defmoved is True:; os.rename(defaultf",MatchSource.WIKI,psi4manual/4.0b5/_modules/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/molecule.html
https://psicode.org/psi4manual/4.0b5/_modules/qcdb/molecule.html:29914,Security,Validat,ValidationError,29914,"1 s8 a2 alpha6=None version=4; pfile.write('%12.6f %12.6f %12.6f %12.6f %12.6f %6d\n' %; (dashcoeff[dashlvl][func]['s6'], dashcoeff[dashlvl][func]['a1'], dashcoeff[dashlvl][func]['s8'],; dashcoeff[dashlvl][func]['a2'], 0.0, 4)); pfile.close(). # Write dftd3_geometry file that supplies geometry to dispersion calc; geomfile = './dftd3_geometry.xyz'; gfile = open(geomfile, 'w'); gfile.write(self.save_string_xyz()); gfile.close(). # Call dftd3 program; try:; dashout = subprocess.Popen(['dftd3', geomfile, '-grad'], stdout=subprocess.PIPE); except OSError:; raise ValidationError('Program dftd3 not found in path.'); out, err = dashout.communicate(); if verbosity >= 3:; print out. # Parse output (could go further and break into E6, E8, E10 and Cn coeff); success = False; for line in out.splitlines():; if re.match(' Edisp /kcal,au', line):; sline = line.split(); dashd = float(sline[3]); if re.match(' normal termination of dftd3', line):; success = True. if not success:; raise ValidationError('Program dftd3 did not complete successfully.'). # Parse grad output; derivfile = './dftd3_gradient'; dfile = open(derivfile, 'r'); dashdderiv = []; for at in dfile.readlines():; dashdderiv.append([float(x.replace('D', 'E')) for x in at.split()]); dfile.close(); if len(dashdderiv) != self.natom():; raise ValidationError('Program dftd3 gradient file has %d atoms- %d expected.' % \; (len(dashdderiv), self.natom())). # Clean up files and remove scratch directory; # os.unlink(paramfile); # os.unlink(geomfile); # os.unlink(derivfile); if defmoved is True:; os.rename(defaultfile + '_hide', defaultfile). os.chdir('..'); # try:; # shutil.rmtree(dftd3_tmpdir); # except OSError as e:; # ValidationError('Unable to remove dftd3 temporary directory %s' % e, file=sys.stderr); os.chdir(current_directory). # return -D & d(-D)/dx; return dashd, dashdderiv. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  ; PSI4 [beta5]  ; Module code .  Cop",MatchSource.WIKI,psi4manual/4.0b5/_modules/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/molecule.html
https://psicode.org/psi4manual/4.0b5/_modules/qcdb/molecule.html:30236,Security,Validat,ValidationError,30236,"oeff[dashlvl][func]['s6'], dashcoeff[dashlvl][func]['a1'], dashcoeff[dashlvl][func]['s8'],; dashcoeff[dashlvl][func]['a2'], 0.0, 4)); pfile.close(). # Write dftd3_geometry file that supplies geometry to dispersion calc; geomfile = './dftd3_geometry.xyz'; gfile = open(geomfile, 'w'); gfile.write(self.save_string_xyz()); gfile.close(). # Call dftd3 program; try:; dashout = subprocess.Popen(['dftd3', geomfile, '-grad'], stdout=subprocess.PIPE); except OSError:; raise ValidationError('Program dftd3 not found in path.'); out, err = dashout.communicate(); if verbosity >= 3:; print out. # Parse output (could go further and break into E6, E8, E10 and Cn coeff); success = False; for line in out.splitlines():; if re.match(' Edisp /kcal,au', line):; sline = line.split(); dashd = float(sline[3]); if re.match(' normal termination of dftd3', line):; success = True. if not success:; raise ValidationError('Program dftd3 did not complete successfully.'). # Parse grad output; derivfile = './dftd3_gradient'; dfile = open(derivfile, 'r'); dashdderiv = []; for at in dfile.readlines():; dashdderiv.append([float(x.replace('D', 'E')) for x in at.split()]); dfile.close(); if len(dashdderiv) != self.natom():; raise ValidationError('Program dftd3 gradient file has %d atoms- %d expected.' % \; (len(dashdderiv), self.natom())). # Clean up files and remove scratch directory; # os.unlink(paramfile); # os.unlink(geomfile); # os.unlink(derivfile); if defmoved is True:; os.rename(defaultfile + '_hide', defaultfile). os.chdir('..'); # try:; # shutil.rmtree(dftd3_tmpdir); # except OSError as e:; # ValidationError('Unable to remove dftd3 temporary directory %s' % e, file=sys.stderr); os.chdir(current_directory). # return -D & d(-D)/dx; return dashd, dashdderiv. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  ; PSI4 [beta5]  ; Module code .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/_modules/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/molecule.html
https://psicode.org/psi4manual/4.0b5/_modules/qcdb/molecule.html:30616,Security,Validat,ValidationError,30616,"oeff[dashlvl][func]['s6'], dashcoeff[dashlvl][func]['a1'], dashcoeff[dashlvl][func]['s8'],; dashcoeff[dashlvl][func]['a2'], 0.0, 4)); pfile.close(). # Write dftd3_geometry file that supplies geometry to dispersion calc; geomfile = './dftd3_geometry.xyz'; gfile = open(geomfile, 'w'); gfile.write(self.save_string_xyz()); gfile.close(). # Call dftd3 program; try:; dashout = subprocess.Popen(['dftd3', geomfile, '-grad'], stdout=subprocess.PIPE); except OSError:; raise ValidationError('Program dftd3 not found in path.'); out, err = dashout.communicate(); if verbosity >= 3:; print out. # Parse output (could go further and break into E6, E8, E10 and Cn coeff); success = False; for line in out.splitlines():; if re.match(' Edisp /kcal,au', line):; sline = line.split(); dashd = float(sline[3]); if re.match(' normal termination of dftd3', line):; success = True. if not success:; raise ValidationError('Program dftd3 did not complete successfully.'). # Parse grad output; derivfile = './dftd3_gradient'; dfile = open(derivfile, 'r'); dashdderiv = []; for at in dfile.readlines():; dashdderiv.append([float(x.replace('D', 'E')) for x in at.split()]); dfile.close(); if len(dashdderiv) != self.natom():; raise ValidationError('Program dftd3 gradient file has %d atoms- %d expected.' % \; (len(dashdderiv), self.natom())). # Clean up files and remove scratch directory; # os.unlink(paramfile); # os.unlink(geomfile); # os.unlink(derivfile); if defmoved is True:; os.rename(defaultfile + '_hide', defaultfile). os.chdir('..'); # try:; # shutil.rmtree(dftd3_tmpdir); # except OSError as e:; # ValidationError('Unable to remove dftd3 temporary directory %s' % e, file=sys.stderr); os.chdir(current_directory). # return -D & d(-D)/dx; return dashd, dashdderiv. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  ; PSI4 [beta5]  ; Module code .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/_modules/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/molecule.html
https://psicode.org/psi4manual/4.0b5/_modules/qcdb/molecule.html:11890,Usability,Simpl,Simply,11890," # Bondi JPC 68 441 (1964); 'F': 1.40 / 1.5, # Bondi JPC 68 441 (1964); 'SI': 1.93 / 1.5, # Bondi JPC 68 441 (1964); 'P': 1.86 / 1.5, # Bondi JPC 68 441 (1964); 'S': 1.80 / 1.5, # Bondi JPC 68 441 (1964); 'CL': 1.75 / 1.5, # Bondi JPC 68 441 (1964); 'GE': 1.98 / 1.5, # Bondi JPC 68 441 (1964); 'AS': 1.94 / 1.5, # Bondi JPC 68 441 (1964); 'SE': 1.90 / 1.5, # Bondi JPC 68 441 (1964); 'BR': 1.87 / 1.5, # Bondi JPC 68 441 (1964); 'SN': 2.16 / 1.5, # Bondi JPC 68 441 (1964); 'SB': 2.12 / 1.5, # Bondi JPC 68 441 (1964); 'TE': 2.08 / 1.5, # Bondi JPC 68 441 (1964); 'I': 2.04 / 1.5, # Bondi JPC 68 441 (1964); 'XE': 2.05 / 1.5} # Bondi JPC 68 441 (1964). Queue = []; White = range(self.natom()) # untouched; Black = [] # touched and all edges discovered; Fragment = [] # stores fragments. start = 0 # starts with the first atom in the list; Queue.append(start); White.remove(start). # Simply start with the first atom, do a BFS when done, go to any; # untouched atom and start again iterate until all atoms belong; # to a fragment group; while len(White) > 0 or len(Queue) > 0: # Iterates to the next fragment; Fragment.append([]). while len(Queue) > 0: # BFS within a fragment; for u in Queue: # find all (still white) nearest neighbors to vertex u; for i in White:; dist = distance(self.xyz(i), self.xyz(u)) * psi_bohr2angstroms; if dist < vdW_diameter[self.symbol(u)] + vdW_diameter[self.symbol(i)]:; Queue.append(i) # if you find you, put in the queue; White.remove(i) # and remove it from the untouched list; Queue.remove(u) # remove focus from Queue; Black.append(u); Fragment[-1].append(int(u)) # add to group (0-indexed); Fragment[-1].sort() # preserve original atom ordering. if len(White) != 0: # can't move White -> Queue if no more exist; Queue.append(White[0]); White.remove(White[0]). return Fragment. [docs] def inertia_tensor(self, masswt=True):; """"""Compute inertia tensor. >>> print H2OH2O.inertia_tensor(); [[8.704574864178731, -8.828375721817082, 0.0], [-8.828375721817082, 280.8286",MatchSource.WIKI,psi4manual/4.0b5/_modules/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/molecule.html
https://psicode.org/psi4manual/4.0b5/_modules/qcdb/psiutil.html:1580,Availability,failure,failure,1580,"Y WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU General Public License for more details.; #; # You should have received a copy of the GNU General Public License along; # with this program; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; #@END LICENSE; #. r""""""Stuff stolen from psi. Should import or not as necessary; or some better way. Apologies to the coders. """"""; import sys; import math; import re; from vecutil import *. def _success(label):; """"""Function to print a '*label*...PASSED' line to screen.; Used by :py:func:`util.compare_values` family when functions pass. """"""; print('\t{0:.<66}PASSED'.format(label)); sys.stdout.flush(). [docs]def compare_values(expected, computed, digits, label):; """"""Function to compare two values. Prints :py:func:`util.success`; when value *computed* matches value *expected* to number of *digits*.; Performs a system exit on failure. Used in input files in the test suite. """"""; if abs(expected - computed) > 10 ** (-digits):; print(""\t%s: computed value (%f) does not match (%f) to %d digits."" % (label, computed, expected, digits)); sys.exit(1); if math.isnan(computed):; print(""\t%s: computed value (%f) does not match (%f) to %d digits.\n"" % (label, computed, expected, digits)); print(""\tprobably because the computed value is nan.""); sys.exit(1); _success(label). [docs]def compare_matrices(expected, computed, digits, label):; """"""Function to compare two matrices. Prints :py:func:`util.success`; when elements of matrix *computed* match elements of matrix *expected* to; number of *digits*. Performs a system exit on failure to match symmetry; structure, dimensions, or element values. Used in input files in the test suite. """"""; rows = len(expected); cols = len(expected[0]); failed = 0; for row in range(rows):; for col in range(cols):; if abs(expected[row][col] - computed[row][col]) > 10 ** (-digits):; pr",MatchSource.WIKI,psi4manual/4.0b5/_modules/qcdb/psiutil.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/psiutil.html
https://psicode.org/psi4manual/4.0b5/_modules/qcdb/psiutil.html:2278,Availability,failure,failure,2278,"('\t{0:.<66}PASSED'.format(label)); sys.stdout.flush(). [docs]def compare_values(expected, computed, digits, label):; """"""Function to compare two values. Prints :py:func:`util.success`; when value *computed* matches value *expected* to number of *digits*.; Performs a system exit on failure. Used in input files in the test suite. """"""; if abs(expected - computed) > 10 ** (-digits):; print(""\t%s: computed value (%f) does not match (%f) to %d digits."" % (label, computed, expected, digits)); sys.exit(1); if math.isnan(computed):; print(""\t%s: computed value (%f) does not match (%f) to %d digits.\n"" % (label, computed, expected, digits)); print(""\tprobably because the computed value is nan.""); sys.exit(1); _success(label). [docs]def compare_matrices(expected, computed, digits, label):; """"""Function to compare two matrices. Prints :py:func:`util.success`; when elements of matrix *computed* match elements of matrix *expected* to; number of *digits*. Performs a system exit on failure to match symmetry; structure, dimensions, or element values. Used in input files in the test suite. """"""; rows = len(expected); cols = len(expected[0]); failed = 0; for row in range(rows):; for col in range(cols):; if abs(expected[row][col] - computed[row][col]) > 10 ** (-digits):; print(""\t%s: computed value (%s) does not match (%s)."" % (label, expected[row][col], computed[row][col])); failed = 1; break. if failed:; print(""The Failed Test Matrices\n""); show(computed); print('\n'); show(expected); sys.exit(1); _success(label). [docs]def query_yes_no(question, default=True):; """"""Ask a yes/no question via raw_input() and return their answer. *question* is a string that is presented to the user.; *default* is the presumed answer if the user just hits <Enter>.; It must be yes (the default), no or None (meaning; an answer is required of the user). The return value is one of True or False. """""". yes = re.compile(r'^(y|yes|true|on|1)', re.IGNORECASE); no = re.compile(r'^(n|no|false|off|0)', re.IGNORECASE). ",MatchSource.WIKI,psi4manual/4.0b5/_modules/qcdb/psiutil.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/psiutil.html
https://psicode.org/psi4manual/4.0b5/_modules/qcdb/psiutil.html:3970,Deployability,update,updated,3970,"cs]def compare_matrices(expected, computed, digits, label):; """"""Function to compare two matrices. Prints :py:func:`util.success`; when elements of matrix *computed* match elements of matrix *expected* to; number of *digits*. Performs a system exit on failure to match symmetry; structure, dimensions, or element values. Used in input files in the test suite. """"""; rows = len(expected); cols = len(expected[0]); failed = 0; for row in range(rows):; for col in range(cols):; if abs(expected[row][col] - computed[row][col]) > 10 ** (-digits):; print(""\t%s: computed value (%s) does not match (%s)."" % (label, expected[row][col], computed[row][col])); failed = 1; break. if failed:; print(""The Failed Test Matrices\n""); show(computed); print('\n'); show(expected); sys.exit(1); _success(label). [docs]def query_yes_no(question, default=True):; """"""Ask a yes/no question via raw_input() and return their answer. *question* is a string that is presented to the user.; *default* is the presumed answer if the user just hits <Enter>.; It must be yes (the default), no or None (meaning; an answer is required of the user). The return value is one of True or False. """""". yes = re.compile(r'^(y|yes|true|on|1)', re.IGNORECASE); no = re.compile(r'^(n|no|false|off|0)', re.IGNORECASE). if default == None:; prompt = "" [y/n] ""; elif default == True:; prompt = "" [Y/n] ""; elif default == False:; prompt = "" [y/N] ""; else:; raise ValueError(""invalid default answer: '%s'"" % default). while True:; sys.stdout.write(question + prompt); choice = raw_input().strip().lower(); if default is not None and choice == """":; return default; elif yes.match(choice):; return True; elif no.match(choice):; return False; else:; sys.stdout.write("" Please respond with 'yes' or 'no'.\n""). Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  ; PSI4 [beta5]  ; Module code .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/_modules/qcdb/psiutil.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/psiutil.html
https://psicode.org/psi4manual/4.0b5/_modules/qcdb/psiutil.html:1554,Performance,Perform,Performs,1554,"Y WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU General Public License for more details.; #; # You should have received a copy of the GNU General Public License along; # with this program; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; #@END LICENSE; #. r""""""Stuff stolen from psi. Should import or not as necessary; or some better way. Apologies to the coders. """"""; import sys; import math; import re; from vecutil import *. def _success(label):; """"""Function to print a '*label*...PASSED' line to screen.; Used by :py:func:`util.compare_values` family when functions pass. """"""; print('\t{0:.<66}PASSED'.format(label)); sys.stdout.flush(). [docs]def compare_values(expected, computed, digits, label):; """"""Function to compare two values. Prints :py:func:`util.success`; when value *computed* matches value *expected* to number of *digits*.; Performs a system exit on failure. Used in input files in the test suite. """"""; if abs(expected - computed) > 10 ** (-digits):; print(""\t%s: computed value (%f) does not match (%f) to %d digits."" % (label, computed, expected, digits)); sys.exit(1); if math.isnan(computed):; print(""\t%s: computed value (%f) does not match (%f) to %d digits.\n"" % (label, computed, expected, digits)); print(""\tprobably because the computed value is nan.""); sys.exit(1); _success(label). [docs]def compare_matrices(expected, computed, digits, label):; """"""Function to compare two matrices. Prints :py:func:`util.success`; when elements of matrix *computed* match elements of matrix *expected* to; number of *digits*. Performs a system exit on failure to match symmetry; structure, dimensions, or element values. Used in input files in the test suite. """"""; rows = len(expected); cols = len(expected[0]); failed = 0; for row in range(rows):; for col in range(cols):; if abs(expected[row][col] - computed[row][col]) > 10 ** (-digits):; pr",MatchSource.WIKI,psi4manual/4.0b5/_modules/qcdb/psiutil.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/psiutil.html
https://psicode.org/psi4manual/4.0b5/_modules/qcdb/psiutil.html:2252,Performance,Perform,Performs,2252,"('\t{0:.<66}PASSED'.format(label)); sys.stdout.flush(). [docs]def compare_values(expected, computed, digits, label):; """"""Function to compare two values. Prints :py:func:`util.success`; when value *computed* matches value *expected* to number of *digits*.; Performs a system exit on failure. Used in input files in the test suite. """"""; if abs(expected - computed) > 10 ** (-digits):; print(""\t%s: computed value (%f) does not match (%f) to %d digits."" % (label, computed, expected, digits)); sys.exit(1); if math.isnan(computed):; print(""\t%s: computed value (%f) does not match (%f) to %d digits.\n"" % (label, computed, expected, digits)); print(""\tprobably because the computed value is nan.""); sys.exit(1); _success(label). [docs]def compare_matrices(expected, computed, digits, label):; """"""Function to compare two matrices. Prints :py:func:`util.success`; when elements of matrix *computed* match elements of matrix *expected* to; number of *digits*. Performs a system exit on failure to match symmetry; structure, dimensions, or element values. Used in input files in the test suite. """"""; rows = len(expected); cols = len(expected[0]); failed = 0; for row in range(rows):; for col in range(cols):; if abs(expected[row][col] - computed[row][col]) > 10 ** (-digits):; print(""\t%s: computed value (%s) does not match (%s)."" % (label, expected[row][col], computed[row][col])); failed = 1; break. if failed:; print(""The Failed Test Matrices\n""); show(computed); print('\n'); show(expected); sys.exit(1); _success(label). [docs]def query_yes_no(question, default=True):; """"""Ask a yes/no question via raw_input() and return their answer. *question* is a string that is presented to the user.; *default* is the presumed answer if the user just hits <Enter>.; It must be yes (the default), no or None (meaning; an answer is required of the user). The return value is one of True or False. """""". yes = re.compile(r'^(y|yes|true|on|1)', re.IGNORECASE); no = re.compile(r'^(n|no|false|off|0)', re.IGNORECASE). ",MatchSource.WIKI,psi4manual/4.0b5/_modules/qcdb/psiutil.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/psiutil.html
https://psicode.org/psi4manual/4.0b5/_modules/qcdb/psiutil.html:1616,Testability,test,test,1616,"warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU General Public License for more details.; #; # You should have received a copy of the GNU General Public License along; # with this program; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; #@END LICENSE; #. r""""""Stuff stolen from psi. Should import or not as necessary; or some better way. Apologies to the coders. """"""; import sys; import math; import re; from vecutil import *. def _success(label):; """"""Function to print a '*label*...PASSED' line to screen.; Used by :py:func:`util.compare_values` family when functions pass. """"""; print('\t{0:.<66}PASSED'.format(label)); sys.stdout.flush(). [docs]def compare_values(expected, computed, digits, label):; """"""Function to compare two values. Prints :py:func:`util.success`; when value *computed* matches value *expected* to number of *digits*.; Performs a system exit on failure. Used in input files in the test suite. """"""; if abs(expected - computed) > 10 ** (-digits):; print(""\t%s: computed value (%f) does not match (%f) to %d digits."" % (label, computed, expected, digits)); sys.exit(1); if math.isnan(computed):; print(""\t%s: computed value (%f) does not match (%f) to %d digits.\n"" % (label, computed, expected, digits)); print(""\tprobably because the computed value is nan.""); sys.exit(1); _success(label). [docs]def compare_matrices(expected, computed, digits, label):; """"""Function to compare two matrices. Prints :py:func:`util.success`; when elements of matrix *computed* match elements of matrix *expected* to; number of *digits*. Performs a system exit on failure to match symmetry; structure, dimensions, or element values. Used in input files in the test suite. """"""; rows = len(expected); cols = len(expected[0]); failed = 0; for row in range(rows):; for col in range(cols):; if abs(expected[row][col] - computed[row][col]) > 10 ** (-digits):; print(""\t%s: computed value (%s) does no",MatchSource.WIKI,psi4manual/4.0b5/_modules/qcdb/psiutil.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/psiutil.html
https://psicode.org/psi4manual/4.0b5/_modules/qcdb/psiutil.html:2374,Testability,test,test,2374,"ompare_values(expected, computed, digits, label):; """"""Function to compare two values. Prints :py:func:`util.success`; when value *computed* matches value *expected* to number of *digits*.; Performs a system exit on failure. Used in input files in the test suite. """"""; if abs(expected - computed) > 10 ** (-digits):; print(""\t%s: computed value (%f) does not match (%f) to %d digits."" % (label, computed, expected, digits)); sys.exit(1); if math.isnan(computed):; print(""\t%s: computed value (%f) does not match (%f) to %d digits.\n"" % (label, computed, expected, digits)); print(""\tprobably because the computed value is nan.""); sys.exit(1); _success(label). [docs]def compare_matrices(expected, computed, digits, label):; """"""Function to compare two matrices. Prints :py:func:`util.success`; when elements of matrix *computed* match elements of matrix *expected* to; number of *digits*. Performs a system exit on failure to match symmetry; structure, dimensions, or element values. Used in input files in the test suite. """"""; rows = len(expected); cols = len(expected[0]); failed = 0; for row in range(rows):; for col in range(cols):; if abs(expected[row][col] - computed[row][col]) > 10 ** (-digits):; print(""\t%s: computed value (%s) does not match (%s)."" % (label, expected[row][col], computed[row][col])); failed = 1; break. if failed:; print(""The Failed Test Matrices\n""); show(computed); print('\n'); show(expected); sys.exit(1); _success(label). [docs]def query_yes_no(question, default=True):; """"""Ask a yes/no question via raw_input() and return their answer. *question* is a string that is presented to the user.; *default* is the presumed answer if the user just hits <Enter>.; It must be yes (the default), no or None (meaning; an answer is required of the user). The return value is one of True or False. """""". yes = re.compile(r'^(y|yes|true|on|1)', re.IGNORECASE); no = re.compile(r'^(n|no|false|off|0)', re.IGNORECASE). if default == None:; prompt = "" [y/n] ""; elif default == True:; pro",MatchSource.WIKI,psi4manual/4.0b5/_modules/qcdb/psiutil.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/psiutil.html
https://psicode.org/psi4manual/4.0b5/_modules/qcdb/psiutil.html:2724,Testability,Test,Test,2724,"gits."" % (label, computed, expected, digits)); sys.exit(1); if math.isnan(computed):; print(""\t%s: computed value (%f) does not match (%f) to %d digits.\n"" % (label, computed, expected, digits)); print(""\tprobably because the computed value is nan.""); sys.exit(1); _success(label). [docs]def compare_matrices(expected, computed, digits, label):; """"""Function to compare two matrices. Prints :py:func:`util.success`; when elements of matrix *computed* match elements of matrix *expected* to; number of *digits*. Performs a system exit on failure to match symmetry; structure, dimensions, or element values. Used in input files in the test suite. """"""; rows = len(expected); cols = len(expected[0]); failed = 0; for row in range(rows):; for col in range(cols):; if abs(expected[row][col] - computed[row][col]) > 10 ** (-digits):; print(""\t%s: computed value (%s) does not match (%s)."" % (label, expected[row][col], computed[row][col])); failed = 1; break. if failed:; print(""The Failed Test Matrices\n""); show(computed); print('\n'); show(expected); sys.exit(1); _success(label). [docs]def query_yes_no(question, default=True):; """"""Ask a yes/no question via raw_input() and return their answer. *question* is a string that is presented to the user.; *default* is the presumed answer if the user just hits <Enter>.; It must be yes (the default), no or None (meaning; an answer is required of the user). The return value is one of True or False. """""". yes = re.compile(r'^(y|yes|true|on|1)', re.IGNORECASE); no = re.compile(r'^(n|no|false|off|0)', re.IGNORECASE). if default == None:; prompt = "" [y/n] ""; elif default == True:; prompt = "" [Y/n] ""; elif default == False:; prompt = "" [y/N] ""; else:; raise ValueError(""invalid default answer: '%s'"" % default). while True:; sys.stdout.write(question + prompt); choice = raw_input().strip().lower(); if default is not None and choice == """":; return default; elif yes.match(choice):; return True; elif no.match(choice):; return False; else:; sys.stdout.write("" P",MatchSource.WIKI,psi4manual/4.0b5/_modules/qcdb/psiutil.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/psiutil.html
https://psicode.org/psi4manual/4.0b5/_modules/qcdb/vecutil.html:7034,Deployability,Update,Update,7034,"weep; for p in range(3):; for q in range(p + 1, 3):. g = 100.0 * math.fabs(A[p][q]); if nIter > 4 and (math.fabs(w[p]) + g == math.fabs(w[p])) and \; (math.fabs(w[q]) + g == math.fabs(w[q])):; A[p][q] = 0.0. elif math.fabs(A[p][q]) > thresh:. # Calculate Jacobi transformation; h = w[q] - w[p]; if math.fabs(h) + g == math.fabs(h):; t = A[p][q] / h; else:; theta = 0.5 * h / A[p][q]; if theta < 0.0:; t = -1.0 / (math.sqrt(1.0 + theta * theta) - theta); else:; t = 1.0 / (math.sqrt(1.0 + theta * theta) + theta). c = 1.0 / math.sqrt(1.0 + t * t); s = t * c; z = t * A[p][q]. # Apply Jacobi transformation; A[p][q] = 0.0; w[p] -= z; w[q] += z. for r in range(p):; t = A[r][p]; A[r][p] = c * t - s * A[r][q]; A[r][q] = s * t + c * A[r][q]. for r in range(p + 1, q):; t = A[p][r]; A[p][r] = c * t - s * A[r][q]; A[r][q] = s * t + c * A[r][q]. for r in range(q + 1, 3):; t = A[p][r]; A[p][r] = c * t - s * A[q][r]; A[q][r] = s * t + c * A[q][r]. # Update eigenvectors; for r in range(3):; t = Q[r][p]; Q[r][p] = c * t - s * Q[r][q]; Q[r][q] = s * t + c * Q[r][q]. return None. [docs]def zero(m, n):; """""" Create zero matrix""""""; new_matrix = [[0 for row in range(n)] for col in range(m)]; return new_matrix. [docs]def show(matrix):; """""" Print out matrix""""""; for col in matrix:; print col. [docs]def mscale(matrix, d):; """"""Return *matrix* scaled by scalar *d*""""""; for i in range(len(matrix)):; for j in range(len(matrix[0])):; matrix[i][j] *= d; return matrix. [docs]def mult(matrix1, matrix2):; """""" Matrix multiplication""""""; if len(matrix1[0]) != len(matrix2):; # Check matrix dimensions; raise ValidationError('Matrices must be m*n and n*p to multiply!'). else:; # Multiply if correct dimensions; new_matrix = zero(len(matrix1), len(matrix2[0])); for i in range(len(matrix1)):; for j in range(len(matrix2[0])):; for k in range(len(matrix2)):; new_matrix[i][j] += matrix1[i][k] * matrix2[k][j]; return new_matrix. [docs]def transpose(matrix):; """"""Return matrix transpose""""""; if len(matrix[0]) != len(matrix",MatchSource.WIKI,psi4manual/4.0b5/_modules/qcdb/vecutil.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/vecutil.html
https://psicode.org/psi4manual/4.0b5/_modules/qcdb/vecutil.html:8413,Deployability,update,updated,8413,"q]; if theta < 0.0:; t = -1.0 / (math.sqrt(1.0 + theta * theta) - theta); else:; t = 1.0 / (math.sqrt(1.0 + theta * theta) + theta). c = 1.0 / math.sqrt(1.0 + t * t); s = t * c; z = t * A[p][q]. # Apply Jacobi transformation; A[p][q] = 0.0; w[p] -= z; w[q] += z. for r in range(p):; t = A[r][p]; A[r][p] = c * t - s * A[r][q]; A[r][q] = s * t + c * A[r][q]. for r in range(p + 1, q):; t = A[p][r]; A[p][r] = c * t - s * A[r][q]; A[r][q] = s * t + c * A[r][q]. for r in range(q + 1, 3):; t = A[p][r]; A[p][r] = c * t - s * A[q][r]; A[q][r] = s * t + c * A[q][r]. # Update eigenvectors; for r in range(3):; t = Q[r][p]; Q[r][p] = c * t - s * Q[r][q]; Q[r][q] = s * t + c * Q[r][q]. return None. [docs]def zero(m, n):; """""" Create zero matrix""""""; new_matrix = [[0 for row in range(n)] for col in range(m)]; return new_matrix. [docs]def show(matrix):; """""" Print out matrix""""""; for col in matrix:; print col. [docs]def mscale(matrix, d):; """"""Return *matrix* scaled by scalar *d*""""""; for i in range(len(matrix)):; for j in range(len(matrix[0])):; matrix[i][j] *= d; return matrix. [docs]def mult(matrix1, matrix2):; """""" Matrix multiplication""""""; if len(matrix1[0]) != len(matrix2):; # Check matrix dimensions; raise ValidationError('Matrices must be m*n and n*p to multiply!'). else:; # Multiply if correct dimensions; new_matrix = zero(len(matrix1), len(matrix2[0])); for i in range(len(matrix1)):; for j in range(len(matrix2[0])):; for k in range(len(matrix2)):; new_matrix[i][j] += matrix1[i][k] * matrix2[k][j]; return new_matrix. [docs]def transpose(matrix):; """"""Return matrix transpose""""""; if len(matrix[0]) != len(matrix):; # Check matrix dimensions; raise ValidationError('Matrices must be square.'). tmat = [list(i) for i in zip(*matrix)]; return tmat. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  ; PSI4 [beta5]  ; Module code .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/_modules/qcdb/vecutil.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/vecutil.html
https://psicode.org/psi4manual/4.0b5/_modules/qcdb/vecutil.html:982,Security,access,accessory,982,". qcdb.vecutil  PSI4 [beta5] documentation. Navigation. index. modules  . toc  ; PSI4 [beta5]  ; Module code . Source code for qcdb.vecutil; #; #@BEGIN LICENSE; #; # PSI4: an ab initio quantum chemistry software package; #; # This program is free software; you can redistribute it and/or modify; # it under the terms of the GNU General Public License as published by; # the Free Software Foundation; either version 2 of the License, or; # (at your option) any later version.; #; # This program is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU General Public License for more details.; #; # You should have received a copy of the GNU General Public License along; # with this program; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; #@END LICENSE; #. r""""""File for accessory procedures in the chem module.; Credit for the libmints vector3 class to Justin M. Turney and; incremental improvements by other psi4 developers. """"""; import math; import copy; from exceptions import *. ZERO = 1.0E-14. [docs]def norm(v):; """"""Compute the magnitude of vector *v*.""""""; return math.sqrt(sum(v[i] * v[i] for i in range(len(v)))). [docs]def add(v, u):; """"""Compute sum of vectors *v* and *u*.""""""; return [u[i] + v[i] for i in range(len(v))]. [docs]def sub(v, u):; """"""Compute difference of vectors *v* - *u*.""""""; return [v[i] - u[i] for i in range(len(v))]. [docs]def dot(v, u):; """"""Compute dot product of vectors *v* and *u*.""""""; return sum(u[i] * v[i] for i in range(len(v))). [docs]def scale(v, d):; """"""Compute by-element scale by *d* of vector *v*.""""""; return [d * v[i] for i in range(len(v))]. [docs]def normalize(v):; """"""Compute normalized vector *v*.""""""; vmag = norm(v); return [v[i] / vmag for i in range(len(v))]. [docs]def distance(v, u):; """"""Compute the distance between points defined by ",MatchSource.WIKI,psi4manual/4.0b5/_modules/qcdb/vecutil.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/vecutil.html
https://psicode.org/psi4manual/4.0b5/_modules/qcdb/vecutil.html:2174,Security,Validat,ValidationError,2174,"""""""Compute the magnitude of vector *v*.""""""; return math.sqrt(sum(v[i] * v[i] for i in range(len(v)))). [docs]def add(v, u):; """"""Compute sum of vectors *v* and *u*.""""""; return [u[i] + v[i] for i in range(len(v))]. [docs]def sub(v, u):; """"""Compute difference of vectors *v* - *u*.""""""; return [v[i] - u[i] for i in range(len(v))]. [docs]def dot(v, u):; """"""Compute dot product of vectors *v* and *u*.""""""; return sum(u[i] * v[i] for i in range(len(v))). [docs]def scale(v, d):; """"""Compute by-element scale by *d* of vector *v*.""""""; return [d * v[i] for i in range(len(v))]. [docs]def normalize(v):; """"""Compute normalized vector *v*.""""""; vmag = norm(v); return [v[i] / vmag for i in range(len(v))]. [docs]def distance(v, u):; """"""Compute the distance between points defined by vectors *v* and *u*.""""""; return norm(sub(v, u)). [docs]def cross(v, u):; """"""Compute cross product of length 3 vectors *v* and *u*.""""""; if len(u) != 3 or len(v) != 3:; raise ValidationError('cross() only defined for vectors of length 3\n'); return [v[1] * u[2] - v[2] * u[1],; v[2] * u[0] - v[0] * u[2],; v[0] * u[1] - v[1] * u[0]]. [docs]def rotate(v, theta, axis):; """"""Rotate length 3 vector *v* about *axis* by *theta* radians.""""""; if len(v) != 3 or len(axis) != 3:; raise ValidationError('rotate() only defined for vectors of length 3\n'). unitaxis = normalize(copy.deepcopy(axis)); # split into parallel and perpendicular components along axis; parallel = scale(axis, dot(v, axis) / dot(axis, axis)); perpendicular = sub(v, parallel); # form unit vector perpendicular to parallel and perpendicular; third_axis = perp_unit(axis, perpendicular); third_axis = scale(third_axis, norm(perpendicular)). result = add(parallel, add(scale(perpendicular, math.cos(theta)), scale(third_axis, math.sin(theta)))); for item in range(len(result)):; if math.fabs(result[item]) < ZERO:; result[item] = 0.0; return result. [docs]def perp_unit(u, v):; """"""Compute unit vector perpendicular to length 3 vectors *u* and *v*.""""""; if len(u) != 3 or le",MatchSource.WIKI,psi4manual/4.0b5/_modules/qcdb/vecutil.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/vecutil.html
https://psicode.org/psi4manual/4.0b5/_modules/qcdb/vecutil.html:2476,Security,Validat,ValidationError,2476,"e of vectors *v* - *u*.""""""; return [v[i] - u[i] for i in range(len(v))]. [docs]def dot(v, u):; """"""Compute dot product of vectors *v* and *u*.""""""; return sum(u[i] * v[i] for i in range(len(v))). [docs]def scale(v, d):; """"""Compute by-element scale by *d* of vector *v*.""""""; return [d * v[i] for i in range(len(v))]. [docs]def normalize(v):; """"""Compute normalized vector *v*.""""""; vmag = norm(v); return [v[i] / vmag for i in range(len(v))]. [docs]def distance(v, u):; """"""Compute the distance between points defined by vectors *v* and *u*.""""""; return norm(sub(v, u)). [docs]def cross(v, u):; """"""Compute cross product of length 3 vectors *v* and *u*.""""""; if len(u) != 3 or len(v) != 3:; raise ValidationError('cross() only defined for vectors of length 3\n'); return [v[1] * u[2] - v[2] * u[1],; v[2] * u[0] - v[0] * u[2],; v[0] * u[1] - v[1] * u[0]]. [docs]def rotate(v, theta, axis):; """"""Rotate length 3 vector *v* about *axis* by *theta* radians.""""""; if len(v) != 3 or len(axis) != 3:; raise ValidationError('rotate() only defined for vectors of length 3\n'). unitaxis = normalize(copy.deepcopy(axis)); # split into parallel and perpendicular components along axis; parallel = scale(axis, dot(v, axis) / dot(axis, axis)); perpendicular = sub(v, parallel); # form unit vector perpendicular to parallel and perpendicular; third_axis = perp_unit(axis, perpendicular); third_axis = scale(third_axis, norm(perpendicular)). result = add(parallel, add(scale(perpendicular, math.cos(theta)), scale(third_axis, math.sin(theta)))); for item in range(len(result)):; if math.fabs(result[item]) < ZERO:; result[item] = 0.0; return result. [docs]def perp_unit(u, v):; """"""Compute unit vector perpendicular to length 3 vectors *u* and *v*.""""""; if len(u) != 3 or len(v) != 3:; raise ValidationError('perp_unit() only defined for vectors of length 3\n'). # try cross product; result = cross(u, v); resultdotresult = dot(result, result). if resultdotresult < 1.E-16:; # cross product is too small to normalize; # find the ",MatchSource.WIKI,psi4manual/4.0b5/_modules/qcdb/vecutil.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/vecutil.html
https://psicode.org/psi4manual/4.0b5/_modules/qcdb/vecutil.html:3250,Security,Validat,ValidationError,3250,"v[2] * u[1],; v[2] * u[0] - v[0] * u[2],; v[0] * u[1] - v[1] * u[0]]. [docs]def rotate(v, theta, axis):; """"""Rotate length 3 vector *v* about *axis* by *theta* radians.""""""; if len(v) != 3 or len(axis) != 3:; raise ValidationError('rotate() only defined for vectors of length 3\n'). unitaxis = normalize(copy.deepcopy(axis)); # split into parallel and perpendicular components along axis; parallel = scale(axis, dot(v, axis) / dot(axis, axis)); perpendicular = sub(v, parallel); # form unit vector perpendicular to parallel and perpendicular; third_axis = perp_unit(axis, perpendicular); third_axis = scale(third_axis, norm(perpendicular)). result = add(parallel, add(scale(perpendicular, math.cos(theta)), scale(third_axis, math.sin(theta)))); for item in range(len(result)):; if math.fabs(result[item]) < ZERO:; result[item] = 0.0; return result. [docs]def perp_unit(u, v):; """"""Compute unit vector perpendicular to length 3 vectors *u* and *v*.""""""; if len(u) != 3 or len(v) != 3:; raise ValidationError('perp_unit() only defined for vectors of length 3\n'). # try cross product; result = cross(u, v); resultdotresult = dot(result, result). if resultdotresult < 1.E-16:; # cross product is too small to normalize; # find the largest of this and v; dotprodt = dot(u, u); dotprodv = dot(v, v); if dotprodt < dotprodv:; d = copy.deepcopy(v); dotprodd = dotprodv; else:; d = copy.deepcopy(u); dotprodd = dotprodt. # see if d is big enough; if dotprodd < 1.e-16:; # choose an arbitrary vector, since the biggest vector is small; result = [1.0, 0.0, 0.0]; return result; else:; # choose a vector perpendicular to d; # choose it in one of the planes xy, xz, yz; # choose the plane to be that which contains the two largest components of d; absd = [math.fabs(d[0]), math.fabs(d[1]), math.fabs(d[2])]; if (absd[1] - absd[0]) > 1.0e-12:; #if absd[0] < absd[1]:; axis0 = 1; if (absd[2] - absd[0]) > 1.0e-12:; #if absd[0] < absd[2]:; axis1 = 2; else:; axis1 = 0; else:; axis0 = 0; if (absd[2] - absd[1]) > 1.0e-12:",MatchSource.WIKI,psi4manual/4.0b5/_modules/qcdb/vecutil.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/vecutil.html
https://psicode.org/psi4manual/4.0b5/_modules/qcdb/vecutil.html:4787,Security,Validat,ValidationError,4787,"small; result = [1.0, 0.0, 0.0]; return result; else:; # choose a vector perpendicular to d; # choose it in one of the planes xy, xz, yz; # choose the plane to be that which contains the two largest components of d; absd = [math.fabs(d[0]), math.fabs(d[1]), math.fabs(d[2])]; if (absd[1] - absd[0]) > 1.0e-12:; #if absd[0] < absd[1]:; axis0 = 1; if (absd[2] - absd[0]) > 1.0e-12:; #if absd[0] < absd[2]:; axis1 = 2; else:; axis1 = 0; else:; axis0 = 0; if (absd[2] - absd[1]) > 1.0e-12:; #if absd[1] < absd[2]:; axis1 = 2; else:; axis1 = 1; result = [0.0, 0.0, 0.0]; # do the pi/2 rotation in the plane; result[axis0] = d[axis1]; result[axis1] = -1.0 * d[axis0]; result = normalize(result); return result. else:; # normalize the cross product and return the result; result = scale(result, 1.0 / math.sqrt(resultdotresult)); return result. [docs]def determinant(mat):; """"""Given 3x3 matrix *mat*, compute the determinat. """"""; if len(mat) != 3 or len(mat[0]) != 3 or len(mat[1]) != 3 or len(mat[2]) != 3:; raise ValidationError('determinant() only defined for arrays of dimension 3x3\n'). det = mat[0][0] * mat[1][1] * mat[2][2] - mat[0][2] * mat[1][1] * mat[2][0] + \; mat[0][1] * mat[1][2] * mat[2][0] - mat[0][1] * mat[1][0] * mat[2][2] + \; mat[0][2] * mat[1][0] * mat[2][1] - mat[0][0] * mat[1][2] * mat[2][1]; return det. [docs]def diagonalize3x3symmat(M):; """"""Given an real symmetric 3x3 matrix *M*, compute the eigenvalues. """"""; if len(M) != 3 or len(M[0]) != 3 or len(M[1]) != 3 or len(M[2]) != 3:; raise ValidationError('diagonalize3x3symmat() only defined for arrays of dimension 3x3\n'). A = copy.deepcopy(M) # Symmetric input matrix; Q = [[1, 0, 0], [0, 1, 0], [0, 0, 1]] # Storage buffer for eigenvectors; w = [A[0][0], A[1][1], A[2][2]] # Storage buffer for eigenvalues; # sd, so # Sums of diagonal resp. off-diagonal elements; # s, c, t # sin(phi), cos(phi), tan(phi) and temporary storage; # g, h, z, theta # More temporary storage. # Calculate SQR(tr(A)); sd = 0.0; for i in range(3):; s",MatchSource.WIKI,psi4manual/4.0b5/_modules/qcdb/vecutil.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/vecutil.html
https://psicode.org/psi4manual/4.0b5/_modules/qcdb/vecutil.html:5289,Security,Validat,ValidationError,5289,"axis1 = 2; else:; axis1 = 1; result = [0.0, 0.0, 0.0]; # do the pi/2 rotation in the plane; result[axis0] = d[axis1]; result[axis1] = -1.0 * d[axis0]; result = normalize(result); return result. else:; # normalize the cross product and return the result; result = scale(result, 1.0 / math.sqrt(resultdotresult)); return result. [docs]def determinant(mat):; """"""Given 3x3 matrix *mat*, compute the determinat. """"""; if len(mat) != 3 or len(mat[0]) != 3 or len(mat[1]) != 3 or len(mat[2]) != 3:; raise ValidationError('determinant() only defined for arrays of dimension 3x3\n'). det = mat[0][0] * mat[1][1] * mat[2][2] - mat[0][2] * mat[1][1] * mat[2][0] + \; mat[0][1] * mat[1][2] * mat[2][0] - mat[0][1] * mat[1][0] * mat[2][2] + \; mat[0][2] * mat[1][0] * mat[2][1] - mat[0][0] * mat[1][2] * mat[2][1]; return det. [docs]def diagonalize3x3symmat(M):; """"""Given an real symmetric 3x3 matrix *M*, compute the eigenvalues. """"""; if len(M) != 3 or len(M[0]) != 3 or len(M[1]) != 3 or len(M[2]) != 3:; raise ValidationError('diagonalize3x3symmat() only defined for arrays of dimension 3x3\n'). A = copy.deepcopy(M) # Symmetric input matrix; Q = [[1, 0, 0], [0, 1, 0], [0, 0, 1]] # Storage buffer for eigenvectors; w = [A[0][0], A[1][1], A[2][2]] # Storage buffer for eigenvalues; # sd, so # Sums of diagonal resp. off-diagonal elements; # s, c, t # sin(phi), cos(phi), tan(phi) and temporary storage; # g, h, z, theta # More temporary storage. # Calculate SQR(tr(A)); sd = 0.0; for i in range(3):; sd += math.fabs(w[i]); sd = sd * sd. # Main iteration loop; for nIter in range(50):. # Test for convergence; so = 0.0; for p in range(3):; for q in range(p + 1, 3):; so += math.fabs(A[p][q]); if so == 0.0:; return w, Q # return eval, evec. if nIter < 4:; thresh = 0.2 * so / (3 * 3); else:; thresh = 0.0. # Do sweep; for p in range(3):; for q in range(p + 1, 3):. g = 100.0 * math.fabs(A[p][q]); if nIter > 4 and (math.fabs(w[p]) + g == math.fabs(w[p])) and \; (math.fabs(w[q]) + g == math.fabs(w[q])):; A[p][q]",MatchSource.WIKI,psi4manual/4.0b5/_modules/qcdb/vecutil.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/vecutil.html
https://psicode.org/psi4manual/4.0b5/_modules/qcdb/vecutil.html:7679,Security,Validat,ValidationError,7679,"q]; if theta < 0.0:; t = -1.0 / (math.sqrt(1.0 + theta * theta) - theta); else:; t = 1.0 / (math.sqrt(1.0 + theta * theta) + theta). c = 1.0 / math.sqrt(1.0 + t * t); s = t * c; z = t * A[p][q]. # Apply Jacobi transformation; A[p][q] = 0.0; w[p] -= z; w[q] += z. for r in range(p):; t = A[r][p]; A[r][p] = c * t - s * A[r][q]; A[r][q] = s * t + c * A[r][q]. for r in range(p + 1, q):; t = A[p][r]; A[p][r] = c * t - s * A[r][q]; A[r][q] = s * t + c * A[r][q]. for r in range(q + 1, 3):; t = A[p][r]; A[p][r] = c * t - s * A[q][r]; A[q][r] = s * t + c * A[q][r]. # Update eigenvectors; for r in range(3):; t = Q[r][p]; Q[r][p] = c * t - s * Q[r][q]; Q[r][q] = s * t + c * Q[r][q]. return None. [docs]def zero(m, n):; """""" Create zero matrix""""""; new_matrix = [[0 for row in range(n)] for col in range(m)]; return new_matrix. [docs]def show(matrix):; """""" Print out matrix""""""; for col in matrix:; print col. [docs]def mscale(matrix, d):; """"""Return *matrix* scaled by scalar *d*""""""; for i in range(len(matrix)):; for j in range(len(matrix[0])):; matrix[i][j] *= d; return matrix. [docs]def mult(matrix1, matrix2):; """""" Matrix multiplication""""""; if len(matrix1[0]) != len(matrix2):; # Check matrix dimensions; raise ValidationError('Matrices must be m*n and n*p to multiply!'). else:; # Multiply if correct dimensions; new_matrix = zero(len(matrix1), len(matrix2[0])); for i in range(len(matrix1)):; for j in range(len(matrix2[0])):; for k in range(len(matrix2)):; new_matrix[i][j] += matrix1[i][k] * matrix2[k][j]; return new_matrix. [docs]def transpose(matrix):; """"""Return matrix transpose""""""; if len(matrix[0]) != len(matrix):; # Check matrix dimensions; raise ValidationError('Matrices must be square.'). tmat = [list(i) for i in zip(*matrix)]; return tmat. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  ; PSI4 [beta5]  ; Module code .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/_modules/qcdb/vecutil.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/vecutil.html
https://psicode.org/psi4manual/4.0b5/_modules/qcdb/vecutil.html:8127,Security,Validat,ValidationError,8127,"q]; if theta < 0.0:; t = -1.0 / (math.sqrt(1.0 + theta * theta) - theta); else:; t = 1.0 / (math.sqrt(1.0 + theta * theta) + theta). c = 1.0 / math.sqrt(1.0 + t * t); s = t * c; z = t * A[p][q]. # Apply Jacobi transformation; A[p][q] = 0.0; w[p] -= z; w[q] += z. for r in range(p):; t = A[r][p]; A[r][p] = c * t - s * A[r][q]; A[r][q] = s * t + c * A[r][q]. for r in range(p + 1, q):; t = A[p][r]; A[p][r] = c * t - s * A[r][q]; A[r][q] = s * t + c * A[r][q]. for r in range(q + 1, 3):; t = A[p][r]; A[p][r] = c * t - s * A[q][r]; A[q][r] = s * t + c * A[q][r]. # Update eigenvectors; for r in range(3):; t = Q[r][p]; Q[r][p] = c * t - s * Q[r][q]; Q[r][q] = s * t + c * Q[r][q]. return None. [docs]def zero(m, n):; """""" Create zero matrix""""""; new_matrix = [[0 for row in range(n)] for col in range(m)]; return new_matrix. [docs]def show(matrix):; """""" Print out matrix""""""; for col in matrix:; print col. [docs]def mscale(matrix, d):; """"""Return *matrix* scaled by scalar *d*""""""; for i in range(len(matrix)):; for j in range(len(matrix[0])):; matrix[i][j] *= d; return matrix. [docs]def mult(matrix1, matrix2):; """""" Matrix multiplication""""""; if len(matrix1[0]) != len(matrix2):; # Check matrix dimensions; raise ValidationError('Matrices must be m*n and n*p to multiply!'). else:; # Multiply if correct dimensions; new_matrix = zero(len(matrix1), len(matrix2[0])); for i in range(len(matrix1)):; for j in range(len(matrix2[0])):; for k in range(len(matrix2)):; new_matrix[i][j] += matrix1[i][k] * matrix2[k][j]; return new_matrix. [docs]def transpose(matrix):; """"""Return matrix transpose""""""; if len(matrix[0]) != len(matrix):; # Check matrix dimensions; raise ValidationError('Matrices must be square.'). tmat = [list(i) for i in zip(*matrix)]; return tmat. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  ; PSI4 [beta5]  ; Module code .  Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b5/_modules/qcdb/vecutil.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/vecutil.html
https://psicode.org/psi4manual/4.0b5/_modules/qcdb/vecutil.html:5866,Testability,Test,Test,5866," * mat[1][1] * mat[2][2] - mat[0][2] * mat[1][1] * mat[2][0] + \; mat[0][1] * mat[1][2] * mat[2][0] - mat[0][1] * mat[1][0] * mat[2][2] + \; mat[0][2] * mat[1][0] * mat[2][1] - mat[0][0] * mat[1][2] * mat[2][1]; return det. [docs]def diagonalize3x3symmat(M):; """"""Given an real symmetric 3x3 matrix *M*, compute the eigenvalues. """"""; if len(M) != 3 or len(M[0]) != 3 or len(M[1]) != 3 or len(M[2]) != 3:; raise ValidationError('diagonalize3x3symmat() only defined for arrays of dimension 3x3\n'). A = copy.deepcopy(M) # Symmetric input matrix; Q = [[1, 0, 0], [0, 1, 0], [0, 0, 1]] # Storage buffer for eigenvectors; w = [A[0][0], A[1][1], A[2][2]] # Storage buffer for eigenvalues; # sd, so # Sums of diagonal resp. off-diagonal elements; # s, c, t # sin(phi), cos(phi), tan(phi) and temporary storage; # g, h, z, theta # More temporary storage. # Calculate SQR(tr(A)); sd = 0.0; for i in range(3):; sd += math.fabs(w[i]); sd = sd * sd. # Main iteration loop; for nIter in range(50):. # Test for convergence; so = 0.0; for p in range(3):; for q in range(p + 1, 3):; so += math.fabs(A[p][q]); if so == 0.0:; return w, Q # return eval, evec. if nIter < 4:; thresh = 0.2 * so / (3 * 3); else:; thresh = 0.0. # Do sweep; for p in range(3):; for q in range(p + 1, 3):. g = 100.0 * math.fabs(A[p][q]); if nIter > 4 and (math.fabs(w[p]) + g == math.fabs(w[p])) and \; (math.fabs(w[q]) + g == math.fabs(w[q])):; A[p][q] = 0.0. elif math.fabs(A[p][q]) > thresh:. # Calculate Jacobi transformation; h = w[q] - w[p]; if math.fabs(h) + g == math.fabs(h):; t = A[p][q] / h; else:; theta = 0.5 * h / A[p][q]; if theta < 0.0:; t = -1.0 / (math.sqrt(1.0 + theta * theta) - theta); else:; t = 1.0 / (math.sqrt(1.0 + theta * theta) + theta). c = 1.0 / math.sqrt(1.0 + t * t); s = t * c; z = t * A[p][q]. # Apply Jacobi transformation; A[p][q] = 0.0; w[p] -= z; w[q] += z. for r in range(p):; t = A[r][p]; A[r][p] = c * t - s * A[r][q]; A[r][q] = s * t + c * A[r][q]. for r in range(p + 1, q):; t = A[p][r]; A[p][r] = c",MatchSource.WIKI,psi4manual/4.0b5/_modules/qcdb/vecutil.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/vecutil.html
https://psicode.org/psi4manual/master/api/psi4.core.AngularMomentumInt.html:541,Deployability,update,updated,541,". AngularMomentumInt. Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; AngularMomentumInt. AngularMomentumInt. class psi4.core.AngularMomentumInt; Bases: OneBodyAOInt; Computes angular momentum integrals. table of contents. AngularMomentumInt; AngularMomentumInt. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; AngularMomentumInt.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/api/psi4.core.AngularMomentumInt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.AngularMomentumInt.html
https://psicode.org/psi4manual/master/api/psi4.core.AOShellCombinationsIterator.html:1407,Deployability,update,updated,1407,". AOShellCombinationsIterator. Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; AOShellCombinationsIterator. AOShellCombinationsIterator. class psi4.core.AOShellCombinationsIterator; Bases: pybind11_object; Attributes Summary. p; Returns current P index. q; Returns current Q index. r; Returns current R index. s; Returns current S index. Methods Summary. first(self); docstring. is_done(self); docstring. next(self); docstring. Attributes Documentation. p; Returns current P index. q; Returns current Q index. r; Returns current R index. s; Returns current S index. Methods Documentation. first(self: psi4.core.AOShellCombinationsIterator)  None; docstring. is_done(self: psi4.core.AOShellCombinationsIterator)  bool; docstring. next(self: psi4.core.AOShellCombinationsIterator)  None; docstring. table of contents. AOShellCombinationsIterator; AOShellCombinationsIterator; AOShellCombinationsIterator.p; AOShellCombinationsIterator.q; AOShellCombinationsIterator.r; AOShellCombinationsIterator.s; AOShellCombinationsIterator.first(); AOShellCombinationsIterator.is_done(); AOShellCombinationsIterator.next(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; AOShellCombinationsIterator.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/api/psi4.core.AOShellCombinationsIterator.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.AOShellCombinationsIterator.html
https://psicode.org/psi4manual/master/api/psi4.core.array_variable.html:561,Deployability,update,updated,561,". array_variable. Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; array_variable. array_variable. psi4.core.array_variable(key: str)  psi4.core.Matrix; Returns copy of the Matrix QCVariable key (case-insensitive); prefer variable(). table of contents. array_variable; array_variable(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; array_variable.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/api/psi4.core.array_variable.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.array_variable.html
https://psicode.org/psi4manual/master/api/psi4.core.array_variable.html:288,Modifiability,variab,variable,288,". array_variable. Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; array_variable. array_variable. psi4.core.array_variable(key: str)  psi4.core.Matrix; Returns copy of the Matrix QCVariable key (case-insensitive); prefer variable(). table of contents. array_variable; array_variable(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; array_variable.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/api/psi4.core.array_variable.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.array_variable.html
https://psicode.org/psi4manual/master/api/psi4.core.array_variables.html:556,Deployability,update,updated,556,". array_variables. Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; array_variables. array_variables. psi4.core.array_variables()  dict[str, psi4.core.Matrix]; Returns dictionary of all Matrix QCVariables; prefer variables(). table of contents. array_variables; array_variables(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; array_variables.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/api/psi4.core.array_variables.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.array_variables.html
https://psicode.org/psi4manual/master/api/psi4.core.array_variables.html:279,Modifiability,variab,variables,279,". array_variables. Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; array_variables. array_variables. psi4.core.array_variables()  dict[str, psi4.core.Matrix]; Returns dictionary of all Matrix QCVariables; prefer variables(). table of contents. array_variables; array_variables(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; array_variables.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/api/psi4.core.array_variables.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.array_variables.html
https://psicode.org/psi4manual/master/api/psi4.core.BasisExtents.html:1106,Deployability,update,updated,1106,". BasisExtents. Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; BasisExtents. BasisExtents. class psi4.core.BasisExtents; Bases: pybind11_object; docstring; Methods Summary. basis(self); docstring. delta(self); docstring. maxR(self); docstring. set_delta(self,arg0); docstring. shell_extents(self); docstring. Methods Documentation. basis(self: psi4.core.BasisExtents)  psi4.core.BasisSet; docstring. delta(self: psi4.core.BasisExtents)  float; docstring. maxR(self: psi4.core.BasisExtents)  float; docstring. set_delta(self: psi4.core.BasisExtents, arg0: float)  None; docstring. shell_extents(self: psi4.core.BasisExtents)  psi4.core.Vector; docstring. table of contents. BasisExtents; BasisExtents; BasisExtents.basis(); BasisExtents.delta(); BasisExtents.maxR(); BasisExtents.set_delta(); BasisExtents.shell_extents(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; BasisExtents.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/api/psi4.core.BasisExtents.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.BasisExtents.html
https://psicode.org/psi4manual/master/api/psi4.core.BasisFunctions.html:1347,Deployability,update,updated,1347,". BasisFunctions. Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; BasisFunctions. BasisFunctions. class psi4.core.BasisFunctions; Bases: pybind11_object; docstring; Methods Summary. basis_values(self); docstring. compute_functions(self,arg0); docstring. deriv(self); docstring. max_functions(self); docstring. max_points(self); docstring. set_deriv(self,arg0); docstring. Methods Documentation. basis_values(self: psi4.core.BasisFunctions)  dict[str, psi4.core.Matrix]; docstring. compute_functions(self: psi4.core.BasisFunctions, arg0: psi4.core.BlockOPoints)  None; docstring. deriv(self: psi4.core.BasisFunctions)  int; docstring. max_functions(self: psi4.core.BasisFunctions)  int; docstring. max_points(self: psi4.core.BasisFunctions)  int; docstring. set_deriv(self: psi4.core.BasisFunctions, arg0: int)  None; docstring. table of contents. BasisFunctions; BasisFunctions; BasisFunctions.basis_values(); BasisFunctions.compute_functions(); BasisFunctions.deriv(); BasisFunctions.max_functions(); BasisFunctions.max_points(); BasisFunctions.set_deriv(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; BasisFunctions.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/api/psi4.core.BasisFunctions.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.BasisFunctions.html
https://psicode.org/psi4manual/master/api/psi4.core.BasisSet.html:3890,Availability,avail,available,3890,"oes it correspond to. blend(self: psi4.core.BasisSet)  str; Plus-separated string of [basisname] values. static build(mol, key=None, target=None, fitrole='ORBITAL', other=None, puream=-1, return_atomlist=False, *, quiet=False); Build a primary or auxiliary basis set. Parameters:. mol (Molecule)  Molecule for which to build the basis set instance.; key (Optional[str])  {BASIS, ORBITAL, DF_BASIS_SCF, DF_BASIS_MP2, DF_BASIS_CC, BASIS_RELATIVISTIC, DF_BASIS_SAD}; Label (effectively Psi4 keyword) to append the basis on the molecule.; The primary basis set is indicated by any of values None or; ""ORBITAL"" or ""BASIS"".; target (Union[str, Callable, None])  Defines the basis set to be constructed. Can be a string (naming a; basis file) or a callable (providing shells or multiple basis files).; For auxiliary bases to be built entirely from primary default, can be; an empty string. If None, value taken from key in global options. If; a user-defined-basis callable is available at string target, target; value will be set to it. In practice, setting this argument to a; PSI4 keyword (e.g., core.get_option(""SCF"", ""DF_BASIS_SCF"") or; core.get_global_option(""BASIS"")) works to handle both simple and; user-defined bases.; fitrole (str)  {ORBITAL, JKFIT, RIFIT, DECON}; Role for which to build basis. Only used when key indicates auxiliary; (i.e., is not ""BASIS"") and auxiliary spec from processing target; cant complete the mol. Then, primary spec from other can be used; to complete the auxiliary basis by looking up suitable default basis; according to fitrole.; other (Union[str, Callable, None])  Only used when building auxiliary basis sets. Defines the primary basis through a string or callable like target.; puream (int)  Whether to override the native spherical/cartesian-ness of target for; returned basis? Value 1 forces spherical, value 0 forces; Cartesian, value -1 (default) uses native puream. Note that; explicitly setting PUREAM trumps both native; pur",MatchSource.WIKI,psi4manual/master/api/psi4.core.BasisSet.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.BasisSet.html
https://psicode.org/psi4manual/master/api/psi4.core.BasisSet.html:10284,Deployability,update,updated,10284," psi4.core.GaussianShell. Return the sith Gaussian shell. shell(self: psi4.core.BasisSet, center: int, si: int) -> psi4.core.GaussianShell. Return the sith Gaussian shell on center. shell_on_center(self: psi4.core.BasisSet, c: int, i: int)  int; Return the ith shell on center. shell_to_ao_function(self: psi4.core.BasisSet, i: int)  int; Return the function number for the first function for the ith shell. shell_to_basis_function(self: psi4.core.BasisSet, i: int)  int; Given a shell return its first basis function. shell_to_center(self: psi4.core.BasisSet, i: int)  int; Return the atomic center for the ith shell. static zero_ao_basis_set()  psi4.core.BasisSet; Returns a BasisSet object that actually has a single s-function at the origin with an exponent of 0.0 and contraction of 1.0. table of contents. BasisSet; BasisSet; BasisSet.ao_to_shell(); BasisSet.blend(); BasisSet.build(); BasisSet.compute_phi(); BasisSet.construct_from_pydict(); BasisSet.ecp_shell(); BasisSet.ecp_shell_on_center(); BasisSet.function_to_center(); BasisSet.function_to_shell(); BasisSet.genbas(); BasisSet.has_ECP(); BasisSet.has_puream(); BasisSet.make_filename(); BasisSet.max_am(); BasisSet.max_function_per_shell(); BasisSet.max_nprimitive(); BasisSet.molecule(); BasisSet.move_atom(); BasisSet.n_ecp_core(); BasisSet.n_ecp_shell_on_center(); BasisSet.n_frozen_core(); BasisSet.name(); BasisSet.nao(); BasisSet.nbf(); BasisSet.nprimitive(); BasisSet.nshell(); BasisSet.nshell_on_center(); BasisSet.print_detail_out(); BasisSet.print_out(); BasisSet.shell(); BasisSet.shell_on_center(); BasisSet.shell_to_ao_function(); BasisSet.shell_to_basis_function(); BasisSet.shell_to_center(); BasisSet.zero_ao_basis_set(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; BasisSet.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/api/psi4.core.BasisSet.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.BasisSet.html
https://psicode.org/psi4manual/master/api/psi4.core.BasisSet.html:1934,Integrability,depend,depending,1934,"respond to. genbas(self); Returns basis set per atom in CFOUR format. has_ECP(self); Whether this basis set object has an ECP associated with it. has_puream(self); Spherical harmonics?. make_filename(arg0); Returns filename for basis name: pluses, stars, parentheses replaced and gbs extension added. max_am(self); Returns maximum angular momentum used. max_function_per_shell(self); The max number of basis functions in a shell. max_nprimitive(self); The max number of primitives in a shell. molecule(self); Molecule object. move_atom(self,arg0,arg1); Translate a given atom by a given amount. n_ecp_core(*args,**kwargs); Overloaded function. n_ecp_shell_on_center(self,i); Return the number of ECP shells on a given center. n_frozen_core(self[,local,molecule]); Returns the number of orbital (non-ECP) frozen core electrons. name(self); Callback handle, may represent string or function. nao(self); Returns number of atomic orbitals (Cartesian). nbf(self); Returns number of basis functions (Cartesian or spherical depending on has_puream). nprimitive(self); Returns total number of primitives in all contractions. nshell(self); Returns number of shells. nshell_on_center(self,i); Return the number of shells on a given center. print_detail_out(self); Prints detailed basis set info to outfile. print_out(self); Prints basis set info to outfile. shell(*args,**kwargs); Overloaded function. shell_on_center(self,c,i); Return the i'th shell on center. shell_to_ao_function(self,i); Return the function number for the first function for the i'th shell. shell_to_basis_function(self,i); Given a shell return its first basis function. shell_to_center(self,i); Return the atomic center for the i'th shell. zero_ao_basis_set(); Returns a BasisSet object that actually has a single s-function at the origin with an exponent of 0.0 and contraction of 1.0. Methods Documentation. ao_to_shell(self: psi4.core.BasisSet, i: int)  int; Given a cartesian function (AO) number what shell does it corr",MatchSource.WIKI,psi4manual/master/api/psi4.core.BasisSet.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.BasisSet.html
https://psicode.org/psi4manual/master/api/psi4.core.BasisSet.html:2020,Integrability,contract,contractions,2020,"Whether this basis set object has an ECP associated with it. has_puream(self); Spherical harmonics?. make_filename(arg0); Returns filename for basis name: pluses, stars, parentheses replaced and gbs extension added. max_am(self); Returns maximum angular momentum used. max_function_per_shell(self); The max number of basis functions in a shell. max_nprimitive(self); The max number of primitives in a shell. molecule(self); Molecule object. move_atom(self,arg0,arg1); Translate a given atom by a given amount. n_ecp_core(*args,**kwargs); Overloaded function. n_ecp_shell_on_center(self,i); Return the number of ECP shells on a given center. n_frozen_core(self[,local,molecule]); Returns the number of orbital (non-ECP) frozen core electrons. name(self); Callback handle, may represent string or function. nao(self); Returns number of atomic orbitals (Cartesian). nbf(self); Returns number of basis functions (Cartesian or spherical depending on has_puream). nprimitive(self); Returns total number of primitives in all contractions. nshell(self); Returns number of shells. nshell_on_center(self,i); Return the number of shells on a given center. print_detail_out(self); Prints detailed basis set info to outfile. print_out(self); Prints basis set info to outfile. shell(*args,**kwargs); Overloaded function. shell_on_center(self,c,i); Return the i'th shell on center. shell_to_ao_function(self,i); Return the function number for the first function for the i'th shell. shell_to_basis_function(self,i); Given a shell return its first basis function. shell_to_center(self,i); Return the atomic center for the i'th shell. zero_ao_basis_set(); Returns a BasisSet object that actually has a single s-function at the origin with an exponent of 0.0 and contraction of 1.0. Methods Documentation. ao_to_shell(self: psi4.core.BasisSet, i: int)  int; Given a cartesian function (AO) number what shell does it correspond to. blend(self: psi4.core.BasisSet)  str; Plus-separated string of [basisna",MatchSource.WIKI,psi4manual/master/api/psi4.core.BasisSet.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.BasisSet.html
https://psicode.org/psi4manual/master/api/psi4.core.BasisSet.html:2753,Integrability,contract,contraction,2753,"llback handle, may represent string or function. nao(self); Returns number of atomic orbitals (Cartesian). nbf(self); Returns number of basis functions (Cartesian or spherical depending on has_puream). nprimitive(self); Returns total number of primitives in all contractions. nshell(self); Returns number of shells. nshell_on_center(self,i); Return the number of shells on a given center. print_detail_out(self); Prints detailed basis set info to outfile. print_out(self); Prints basis set info to outfile. shell(*args,**kwargs); Overloaded function. shell_on_center(self,c,i); Return the i'th shell on center. shell_to_ao_function(self,i); Return the function number for the first function for the i'th shell. shell_to_basis_function(self,i); Given a shell return its first basis function. shell_to_center(self,i); Return the atomic center for the i'th shell. zero_ao_basis_set(); Returns a BasisSet object that actually has a single s-function at the origin with an exponent of 0.0 and contraction of 1.0. Methods Documentation. ao_to_shell(self: psi4.core.BasisSet, i: int)  int; Given a cartesian function (AO) number what shell does it correspond to. blend(self: psi4.core.BasisSet)  str; Plus-separated string of [basisname] values. static build(mol, key=None, target=None, fitrole='ORBITAL', other=None, puream=-1, return_atomlist=False, *, quiet=False); Build a primary or auxiliary basis set. Parameters:. mol (Molecule)  Molecule for which to build the basis set instance.; key (Optional[str])  {BASIS, ORBITAL, DF_BASIS_SCF, DF_BASIS_MP2, DF_BASIS_CC, BASIS_RELATIVISTIC, DF_BASIS_SAD}; Label (effectively Psi4 keyword) to append the basis on the molecule.; The primary basis set is indicated by any of values None or; ""ORBITAL"" or ""BASIS"".; target (Union[str, Callable, None])  Defines the basis set to be constructed. Can be a string (naming a; basis file) or a callable (providing shells or multiple basis files).; For auxiliary bases to be built entirely fr",MatchSource.WIKI,psi4manual/master/api/psi4.core.BasisSet.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.BasisSet.html
https://psicode.org/psi4manual/master/api/psi4.core.BasisSet.html:7800,Integrability,depend,depending,7800,"oes not affect the underlying molecule object. n_ecp_core(*args, **kwargs); Overloaded function. n_ecp_core(self: psi4.core.BasisSet) -> int. Returns the total number of core electrons associated with all ECPs in this basis. n_ecp_core(self: psi4.core.BasisSet, arg0: str) -> int. Returns the number of core electrons associated with any ECP on the specified atom type for this basis set. n_ecp_shell_on_center(self: psi4.core.BasisSet, i: int)  int; Return the number of ECP shells on a given center. n_frozen_core(self: psi4.core.BasisSet, local: str = '', molecule: psi4.core.Molecule = None)  int; Returns the number of orbital (non-ECP) frozen core electrons. For a given molecule and FREEZE_CORE, (n_ecp_core()/2 + n_frozen_core()) = constant. name(self: psi4.core.BasisSet)  str; Callback handle, may represent string or function. nao(self: psi4.core.BasisSet)  int; Returns number of atomic orbitals (Cartesian). nbf(self: psi4.core.BasisSet)  int; Returns number of basis functions (Cartesian or spherical depending on has_puream). nprimitive(self: psi4.core.BasisSet)  int; Returns total number of primitives in all contractions. nshell(self: psi4.core.BasisSet)  int; Returns number of shells. nshell_on_center(self: psi4.core.BasisSet, i: int)  int; Return the number of shells on a given center. print_detail_out(self: psi4.core.BasisSet)  None; Prints detailed basis set info to outfile. print_out(self: psi4.core.BasisSet)  None; Prints basis set info to outfile. shell(*args, **kwargs); Overloaded function. shell(self: psi4.core.BasisSet, si: int) -> psi4.core.GaussianShell. Return the sith Gaussian shell. shell(self: psi4.core.BasisSet, center: int, si: int) -> psi4.core.GaussianShell. Return the sith Gaussian shell on center. shell_on_center(self: psi4.core.BasisSet, c: int, i: int)  int; Return the ith shell on center. shell_to_ao_function(self: psi4.core.BasisSet, i: int)  int; Return the function number for the first function for the ith she",MatchSource.WIKI,psi4manual/master/api/psi4.core.BasisSet.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.BasisSet.html
https://psicode.org/psi4manual/master/api/psi4.core.BasisSet.html:7913,Integrability,contract,contractions,7913,"psi4.core.BasisSet) -> int. Returns the total number of core electrons associated with all ECPs in this basis. n_ecp_core(self: psi4.core.BasisSet, arg0: str) -> int. Returns the number of core electrons associated with any ECP on the specified atom type for this basis set. n_ecp_shell_on_center(self: psi4.core.BasisSet, i: int)  int; Return the number of ECP shells on a given center. n_frozen_core(self: psi4.core.BasisSet, local: str = '', molecule: psi4.core.Molecule = None)  int; Returns the number of orbital (non-ECP) frozen core electrons. For a given molecule and FREEZE_CORE, (n_ecp_core()/2 + n_frozen_core()) = constant. name(self: psi4.core.BasisSet)  str; Callback handle, may represent string or function. nao(self: psi4.core.BasisSet)  int; Returns number of atomic orbitals (Cartesian). nbf(self: psi4.core.BasisSet)  int; Returns number of basis functions (Cartesian or spherical depending on has_puream). nprimitive(self: psi4.core.BasisSet)  int; Returns total number of primitives in all contractions. nshell(self: psi4.core.BasisSet)  int; Returns number of shells. nshell_on_center(self: psi4.core.BasisSet, i: int)  int; Return the number of shells on a given center. print_detail_out(self: psi4.core.BasisSet)  None; Prints detailed basis set info to outfile. print_out(self: psi4.core.BasisSet)  None; Prints basis set info to outfile. shell(*args, **kwargs); Overloaded function. shell(self: psi4.core.BasisSet, si: int) -> psi4.core.GaussianShell. Return the sith Gaussian shell. shell(self: psi4.core.BasisSet, center: int, si: int) -> psi4.core.GaussianShell. Return the sith Gaussian shell on center. shell_on_center(self: psi4.core.BasisSet, c: int, i: int)  int; Return the ith shell on center. shell_to_ao_function(self: psi4.core.BasisSet, i: int)  int; Return the function number for the first function for the ith shell. shell_to_basis_function(self: psi4.core.BasisSet, i: int)  int; Given a shell return its first basis function",MatchSource.WIKI,psi4manual/master/api/psi4.core.BasisSet.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.BasisSet.html
https://psicode.org/psi4manual/master/api/psi4.core.BasisSet.html:9151,Integrability,contract,contraction,9151,"ts detailed basis set info to outfile. print_out(self: psi4.core.BasisSet)  None; Prints basis set info to outfile. shell(*args, **kwargs); Overloaded function. shell(self: psi4.core.BasisSet, si: int) -> psi4.core.GaussianShell. Return the sith Gaussian shell. shell(self: psi4.core.BasisSet, center: int, si: int) -> psi4.core.GaussianShell. Return the sith Gaussian shell on center. shell_on_center(self: psi4.core.BasisSet, c: int, i: int)  int; Return the ith shell on center. shell_to_ao_function(self: psi4.core.BasisSet, i: int)  int; Return the function number for the first function for the ith shell. shell_to_basis_function(self: psi4.core.BasisSet, i: int)  int; Given a shell return its first basis function. shell_to_center(self: psi4.core.BasisSet, i: int)  int; Return the atomic center for the ith shell. static zero_ao_basis_set()  psi4.core.BasisSet; Returns a BasisSet object that actually has a single s-function at the origin with an exponent of 0.0 and contraction of 1.0. table of contents. BasisSet; BasisSet; BasisSet.ao_to_shell(); BasisSet.blend(); BasisSet.build(); BasisSet.compute_phi(); BasisSet.construct_from_pydict(); BasisSet.ecp_shell(); BasisSet.ecp_shell_on_center(); BasisSet.function_to_center(); BasisSet.function_to_shell(); BasisSet.genbas(); BasisSet.has_ECP(); BasisSet.has_puream(); BasisSet.make_filename(); BasisSet.max_am(); BasisSet.max_function_per_shell(); BasisSet.max_nprimitive(); BasisSet.molecule(); BasisSet.move_atom(); BasisSet.n_ecp_core(); BasisSet.n_ecp_shell_on_center(); BasisSet.n_frozen_core(); BasisSet.name(); BasisSet.nao(); BasisSet.nbf(); BasisSet.nprimitive(); BasisSet.nshell(); BasisSet.nshell_on_center(); BasisSet.print_detail_out(); BasisSet.print_out(); BasisSet.shell(); BasisSet.shell_on_center(); BasisSet.shell_to_ao_function(); BasisSet.shell_to_basis_function(); BasisSet.shell_to_center(); BasisSet.zero_ao_basis_set(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .",MatchSource.WIKI,psi4manual/master/api/psi4.core.BasisSet.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.BasisSet.html
https://psicode.org/psi4manual/master/api/psi4.core.BasisSet.html:4109,Usability,simpl,simple,4109,"omlist=False, *, quiet=False); Build a primary or auxiliary basis set. Parameters:. mol (Molecule)  Molecule for which to build the basis set instance.; key (Optional[str])  {BASIS, ORBITAL, DF_BASIS_SCF, DF_BASIS_MP2, DF_BASIS_CC, BASIS_RELATIVISTIC, DF_BASIS_SAD}; Label (effectively Psi4 keyword) to append the basis on the molecule.; The primary basis set is indicated by any of values None or; ""ORBITAL"" or ""BASIS"".; target (Union[str, Callable, None])  Defines the basis set to be constructed. Can be a string (naming a; basis file) or a callable (providing shells or multiple basis files).; For auxiliary bases to be built entirely from primary default, can be; an empty string. If None, value taken from key in global options. If; a user-defined-basis callable is available at string target, target; value will be set to it. In practice, setting this argument to a; PSI4 keyword (e.g., core.get_option(""SCF"", ""DF_BASIS_SCF"") or; core.get_global_option(""BASIS"")) works to handle both simple and; user-defined bases.; fitrole (str)  {ORBITAL, JKFIT, RIFIT, DECON}; Role for which to build basis. Only used when key indicates auxiliary; (i.e., is not ""BASIS"") and auxiliary spec from processing target; cant complete the mol. Then, primary spec from other can be used; to complete the auxiliary basis by looking up suitable default basis; according to fitrole.; other (Union[str, Callable, None])  Only used when building auxiliary basis sets. Defines the primary basis through a string or callable like target.; puream (int)  Whether to override the native spherical/cartesian-ness of target for; returned basis? Value 1 forces spherical, value 0 forces; Cartesian, value -1 (default) uses native puream. Note that; explicitly setting PUREAM trumps both native; puream and this puream argument.; return_atomlist (bool)  Build one-atom basis sets (e.g., for SAD) rather than one whole-mol; basis set.; quiet (bool)  When True, do not print to the output file. Ret",MatchSource.WIKI,psi4manual/master/api/psi4.core.BasisSet.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.BasisSet.html
https://psicode.org/psi4manual/master/api/psi4.core.benchmark_blas1.html:606,Deployability,update,updated,606,". benchmark_blas1. Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; benchmark_blas1. benchmark_blas1. psi4.core.benchmark_blas1(max_dim: int, min_time: float)  None; Perform benchmark traverse of BLAS 1 routines. Use up to max_dim with each routine run at least min_time [s]. table of contents. benchmark_blas1; benchmark_blas1(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; benchmark_blas1.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/api/psi4.core.benchmark_blas1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.benchmark_blas1.html
https://psicode.org/psi4manual/master/api/psi4.core.benchmark_blas1.html:269,Integrability,rout,routines,269,". benchmark_blas1. Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; benchmark_blas1. benchmark_blas1. psi4.core.benchmark_blas1(max_dim: int, min_time: float)  None; Perform benchmark traverse of BLAS 1 routines. Use up to max_dim with each routine run at least min_time [s]. table of contents. benchmark_blas1; benchmark_blas1(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; benchmark_blas1.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/api/psi4.core.benchmark_blas1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.benchmark_blas1.html
https://psicode.org/psi4manual/master/api/psi4.core.benchmark_blas1.html:307,Integrability,rout,routine,307,". benchmark_blas1. Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; benchmark_blas1. benchmark_blas1. psi4.core.benchmark_blas1(max_dim: int, min_time: float)  None; Perform benchmark traverse of BLAS 1 routines. Use up to max_dim with each routine run at least min_time [s]. table of contents. benchmark_blas1; benchmark_blas1(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; benchmark_blas1.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/api/psi4.core.benchmark_blas1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.benchmark_blas1.html
https://psicode.org/psi4manual/master/api/psi4.core.benchmark_blas1.html:232,Performance,Perform,Perform,232,". benchmark_blas1. Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; benchmark_blas1. benchmark_blas1. psi4.core.benchmark_blas1(max_dim: int, min_time: float)  None; Perform benchmark traverse of BLAS 1 routines. Use up to max_dim with each routine run at least min_time [s]. table of contents. benchmark_blas1; benchmark_blas1(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; benchmark_blas1.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/api/psi4.core.benchmark_blas1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.benchmark_blas1.html
https://psicode.org/psi4manual/master/api/psi4.core.benchmark_blas1.html:240,Testability,benchmark,benchmark,240,". benchmark_blas1. Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; benchmark_blas1. benchmark_blas1. psi4.core.benchmark_blas1(max_dim: int, min_time: float)  None; Perform benchmark traverse of BLAS 1 routines. Use up to max_dim with each routine run at least min_time [s]. table of contents. benchmark_blas1; benchmark_blas1(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; benchmark_blas1.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/api/psi4.core.benchmark_blas1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.benchmark_blas1.html
https://psicode.org/psi4manual/master/api/psi4.core.benchmark_blas2.html:606,Deployability,update,updated,606,". benchmark_blas2. Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; benchmark_blas2. benchmark_blas2. psi4.core.benchmark_blas2(max_dim: int, min_time: float)  None; Perform benchmark traverse of BLAS 2 routines. Use up to max_dim with each routine run at least min_time [s]. table of contents. benchmark_blas2; benchmark_blas2(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; benchmark_blas2.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/api/psi4.core.benchmark_blas2.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.benchmark_blas2.html
https://psicode.org/psi4manual/master/api/psi4.core.benchmark_blas2.html:269,Integrability,rout,routines,269,". benchmark_blas2. Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; benchmark_blas2. benchmark_blas2. psi4.core.benchmark_blas2(max_dim: int, min_time: float)  None; Perform benchmark traverse of BLAS 2 routines. Use up to max_dim with each routine run at least min_time [s]. table of contents. benchmark_blas2; benchmark_blas2(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; benchmark_blas2.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/api/psi4.core.benchmark_blas2.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.benchmark_blas2.html
https://psicode.org/psi4manual/master/api/psi4.core.benchmark_blas2.html:307,Integrability,rout,routine,307,". benchmark_blas2. Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; benchmark_blas2. benchmark_blas2. psi4.core.benchmark_blas2(max_dim: int, min_time: float)  None; Perform benchmark traverse of BLAS 2 routines. Use up to max_dim with each routine run at least min_time [s]. table of contents. benchmark_blas2; benchmark_blas2(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; benchmark_blas2.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/api/psi4.core.benchmark_blas2.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.benchmark_blas2.html
https://psicode.org/psi4manual/master/api/psi4.core.benchmark_blas2.html:232,Performance,Perform,Perform,232,". benchmark_blas2. Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; benchmark_blas2. benchmark_blas2. psi4.core.benchmark_blas2(max_dim: int, min_time: float)  None; Perform benchmark traverse of BLAS 2 routines. Use up to max_dim with each routine run at least min_time [s]. table of contents. benchmark_blas2; benchmark_blas2(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; benchmark_blas2.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/api/psi4.core.benchmark_blas2.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.benchmark_blas2.html
https://psicode.org/psi4manual/master/api/psi4.core.benchmark_blas2.html:240,Testability,benchmark,benchmark,240,". benchmark_blas2. Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; benchmark_blas2. benchmark_blas2. psi4.core.benchmark_blas2(max_dim: int, min_time: float)  None; Perform benchmark traverse of BLAS 2 routines. Use up to max_dim with each routine run at least min_time [s]. table of contents. benchmark_blas2; benchmark_blas2(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; benchmark_blas2.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/api/psi4.core.benchmark_blas2.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.benchmark_blas2.html
https://psicode.org/psi4manual/master/api/psi4.core.benchmark_blas3.html:635,Deployability,update,updated,635,". benchmark_blas3. Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; benchmark_blas3. benchmark_blas3. psi4.core.benchmark_blas3(max_dim: int, min_time: float, nthread: int = 1)  None; Perform benchmark traverse of BLAS 3 routines. Use up to max_dim with each routine run at least min_time [s] on nthread. table of contents. benchmark_blas3; benchmark_blas3(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; benchmark_blas3.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/api/psi4.core.benchmark_blas3.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.benchmark_blas3.html
https://psicode.org/psi4manual/master/api/psi4.core.benchmark_blas3.html:287,Integrability,rout,routines,287,". benchmark_blas3. Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; benchmark_blas3. benchmark_blas3. psi4.core.benchmark_blas3(max_dim: int, min_time: float, nthread: int = 1)  None; Perform benchmark traverse of BLAS 3 routines. Use up to max_dim with each routine run at least min_time [s] on nthread. table of contents. benchmark_blas3; benchmark_blas3(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; benchmark_blas3.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/api/psi4.core.benchmark_blas3.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.benchmark_blas3.html
https://psicode.org/psi4manual/master/api/psi4.core.benchmark_blas3.html:325,Integrability,rout,routine,325,". benchmark_blas3. Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; benchmark_blas3. benchmark_blas3. psi4.core.benchmark_blas3(max_dim: int, min_time: float, nthread: int = 1)  None; Perform benchmark traverse of BLAS 3 routines. Use up to max_dim with each routine run at least min_time [s] on nthread. table of contents. benchmark_blas3; benchmark_blas3(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; benchmark_blas3.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/api/psi4.core.benchmark_blas3.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.benchmark_blas3.html
https://psicode.org/psi4manual/master/api/psi4.core.benchmark_blas3.html:250,Performance,Perform,Perform,250,". benchmark_blas3. Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; benchmark_blas3. benchmark_blas3. psi4.core.benchmark_blas3(max_dim: int, min_time: float, nthread: int = 1)  None; Perform benchmark traverse of BLAS 3 routines. Use up to max_dim with each routine run at least min_time [s] on nthread. table of contents. benchmark_blas3; benchmark_blas3(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; benchmark_blas3.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/api/psi4.core.benchmark_blas3.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.benchmark_blas3.html
https://psicode.org/psi4manual/master/api/psi4.core.benchmark_blas3.html:258,Testability,benchmark,benchmark,258,". benchmark_blas3. Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; benchmark_blas3. benchmark_blas3. psi4.core.benchmark_blas3(max_dim: int, min_time: float, nthread: int = 1)  None; Perform benchmark traverse of BLAS 3 routines. Use up to max_dim with each routine run at least min_time [s] on nthread. table of contents. benchmark_blas3; benchmark_blas3(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; benchmark_blas3.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/api/psi4.core.benchmark_blas3.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.benchmark_blas3.html
https://psicode.org/psi4manual/master/api/psi4.core.benchmark_disk.html:596,Deployability,update,updated,596,". benchmark_disk. Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; benchmark_disk. benchmark_disk. psi4.core.benchmark_disk(max_dim: int, min_time: float)  None; Perform benchmark of PSIO disk performance. Use up to max_dim with each routine run at least min_time [s]. table of contents. benchmark_disk; benchmark_disk(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; benchmark_disk.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/api/psi4.core.benchmark_disk.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.benchmark_disk.html
https://psicode.org/psi4manual/master/api/psi4.core.benchmark_disk.html:300,Integrability,rout,routine,300,". benchmark_disk. Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; benchmark_disk. benchmark_disk. psi4.core.benchmark_disk(max_dim: int, min_time: float)  None; Perform benchmark of PSIO disk performance. Use up to max_dim with each routine run at least min_time [s]. table of contents. benchmark_disk; benchmark_disk(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; benchmark_disk.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/api/psi4.core.benchmark_disk.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.benchmark_disk.html
https://psicode.org/psi4manual/master/api/psi4.core.benchmark_disk.html:228,Performance,Perform,Perform,228,". benchmark_disk. Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; benchmark_disk. benchmark_disk. psi4.core.benchmark_disk(max_dim: int, min_time: float)  None; Perform benchmark of PSIO disk performance. Use up to max_dim with each routine run at least min_time [s]. table of contents. benchmark_disk; benchmark_disk(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; benchmark_disk.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/api/psi4.core.benchmark_disk.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.benchmark_disk.html
https://psicode.org/psi4manual/master/api/psi4.core.benchmark_disk.html:259,Performance,perform,performance,259,". benchmark_disk. Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; benchmark_disk. benchmark_disk. psi4.core.benchmark_disk(max_dim: int, min_time: float)  None; Perform benchmark of PSIO disk performance. Use up to max_dim with each routine run at least min_time [s]. table of contents. benchmark_disk; benchmark_disk(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; benchmark_disk.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/api/psi4.core.benchmark_disk.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.benchmark_disk.html
https://psicode.org/psi4manual/master/api/psi4.core.benchmark_disk.html:236,Testability,benchmark,benchmark,236,". benchmark_disk. Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; benchmark_disk. benchmark_disk. psi4.core.benchmark_disk(max_dim: int, min_time: float)  None; Perform benchmark of PSIO disk performance. Use up to max_dim with each routine run at least min_time [s]. table of contents. benchmark_disk; benchmark_disk(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; benchmark_disk.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/api/psi4.core.benchmark_disk.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.benchmark_disk.html
https://psicode.org/psi4manual/master/api/psi4.core.benchmark_integrals.html:701,Deployability,update,updated,701,". benchmark_integrals. Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; benchmark_integrals. benchmark_integrals. psi4.core.benchmark_integrals(max_am: int, min_time: float)  None; Perform benchmark of psi integrals (of libmints type). Benchmark integrals called from different centers. For up to max_am with each shell combination run at least min_time [s]. table of contents. benchmark_integrals; benchmark_integrals(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; benchmark_integrals.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/api/psi4.core.benchmark_integrals.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.benchmark_integrals.html
https://psicode.org/psi4manual/master/api/psi4.core.benchmark_integrals.html:247,Performance,Perform,Perform,247,". benchmark_integrals. Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; benchmark_integrals. benchmark_integrals. psi4.core.benchmark_integrals(max_am: int, min_time: float)  None; Perform benchmark of psi integrals (of libmints type). Benchmark integrals called from different centers. For up to max_am with each shell combination run at least min_time [s]. table of contents. benchmark_integrals; benchmark_integrals(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; benchmark_integrals.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/api/psi4.core.benchmark_integrals.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.benchmark_integrals.html
https://psicode.org/psi4manual/master/api/psi4.core.benchmark_integrals.html:255,Testability,benchmark,benchmark,255,". benchmark_integrals. Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; benchmark_integrals. benchmark_integrals. psi4.core.benchmark_integrals(max_am: int, min_time: float)  None; Perform benchmark of psi integrals (of libmints type). Benchmark integrals called from different centers. For up to max_am with each shell combination run at least min_time [s]. table of contents. benchmark_integrals; benchmark_integrals(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; benchmark_integrals.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/api/psi4.core.benchmark_integrals.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.benchmark_integrals.html
https://psicode.org/psi4manual/master/api/psi4.core.benchmark_integrals.html:302,Testability,Benchmark,Benchmark,302,". benchmark_integrals. Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; benchmark_integrals. benchmark_integrals. psi4.core.benchmark_integrals(max_am: int, min_time: float)  None; Perform benchmark of psi integrals (of libmints type). Benchmark integrals called from different centers. For up to max_am with each shell combination run at least min_time [s]. table of contents. benchmark_integrals; benchmark_integrals(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; benchmark_integrals.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/api/psi4.core.benchmark_integrals.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.benchmark_integrals.html
https://psicode.org/psi4manual/master/api/psi4.core.benchmark_math.html:605,Deployability,update,updated,605,". benchmark_math. Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; benchmark_math. benchmark_math. psi4.core.benchmark_math(min_time: float)  None; Perform benchmark of common double floating point operations including most of cmath. For each routine run at least min_time [s]. table of contents. benchmark_math; benchmark_math(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; benchmark_math.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/api/psi4.core.benchmark_math.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.benchmark_math.html
https://psicode.org/psi4manual/master/api/psi4.core.benchmark_math.html:309,Integrability,rout,routine,309,". benchmark_math. Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; benchmark_math. benchmark_math. psi4.core.benchmark_math(min_time: float)  None; Perform benchmark of common double floating point operations including most of cmath. For each routine run at least min_time [s]. table of contents. benchmark_math; benchmark_math(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; benchmark_math.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/api/psi4.core.benchmark_math.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.benchmark_math.html
https://psicode.org/psi4manual/master/api/psi4.core.benchmark_math.html:214,Performance,Perform,Perform,214,". benchmark_math. Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; benchmark_math. benchmark_math. psi4.core.benchmark_math(min_time: float)  None; Perform benchmark of common double floating point operations including most of cmath. For each routine run at least min_time [s]. table of contents. benchmark_math; benchmark_math(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; benchmark_math.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/api/psi4.core.benchmark_math.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.benchmark_math.html
https://psicode.org/psi4manual/master/api/psi4.core.benchmark_math.html:222,Testability,benchmark,benchmark,222,". benchmark_math. Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; benchmark_math. benchmark_math. psi4.core.benchmark_math(min_time: float)  None; Perform benchmark of common double floating point operations including most of cmath. For each routine run at least min_time [s]. table of contents. benchmark_math; benchmark_math(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; benchmark_math.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/api/psi4.core.benchmark_math.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.benchmark_math.html
https://psicode.org/psi4manual/master/api/psi4.core.be_quiet-1.html:537,Deployability,update,updated,537,". be_quiet. Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; be_quiet. be_quiet. psi4.core.be_quiet()  None; Redirects output to /dev/null. To switch back to regular output mode, use reopen_outfile(). Doesnt work with Windows. table of contents. be_quiet; be_quiet(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; be_quiet.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/api/psi4.core.be_quiet-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.be_quiet-1.html
https://psicode.org/psi4manual/master/api/psi4.core.be_quiet.html:537,Deployability,update,updated,537,". be_quiet. Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; be_quiet. be_quiet. psi4.core.be_quiet()  None; Redirects output to /dev/null. To switch back to regular output mode, use reopen_outfile(). Doesnt work with Windows. table of contents. be_quiet; be_quiet(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; be_quiet.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/api/psi4.core.be_quiet.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.be_quiet.html
https://psicode.org/psi4manual/master/api/psi4.core.BlockOPoints.html:1761,Deployability,update,updated,1761,". BlockOPoints. Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; BlockOPoints. BlockOPoints. class psi4.core.BlockOPoints; Bases: pybind11_object; docstring; Methods Summary. functions_local_to_global(self); docstring. npoints(self); docstring. parent_atom(self); Returns the atom number this BlockOfPoints belongs to. print_out(self[,out_fname,print]); docstring. refresh(self); docstring. shells_local_to_global(self); docstring. w(self). x(self). y(self). z(self). Methods Documentation. functions_local_to_global(self: psi4.core.BlockOPoints)  list[int]; docstring. npoints(self: psi4.core.BlockOPoints)  int; docstring. parent_atom(self: psi4.core.BlockOPoints)  int; Returns the atom number this BlockOfPoints belongs to. print_out(self: psi4.core.BlockOPoints, out_fname: str = 'outfile', print: int = 2)  None; docstring. refresh(self: psi4.core.BlockOPoints)  None; docstring. shells_local_to_global(self: psi4.core.BlockOPoints)  list[int]; docstring. w(self: psi4.core.BlockOPoints)  psi4.core.Vector. x(self: psi4.core.BlockOPoints)  psi4.core.Vector. y(self: psi4.core.BlockOPoints)  psi4.core.Vector. z(self: psi4.core.BlockOPoints)  psi4.core.Vector. table of contents. BlockOPoints; BlockOPoints; BlockOPoints.functions_local_to_global(); BlockOPoints.npoints(); BlockOPoints.parent_atom(); BlockOPoints.print_out(); BlockOPoints.refresh(); BlockOPoints.shells_local_to_global(); BlockOPoints.w(); BlockOPoints.x(); BlockOPoints.y(); BlockOPoints.z(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; BlockOPoints.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/api/psi4.core.BlockOPoints.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.BlockOPoints.html
https://psicode.org/psi4manual/master/api/psi4.core.BoysLocalizer.html:502,Deployability,update,updated,502,". BoysLocalizer. Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; BoysLocalizer. BoysLocalizer. class psi4.core.BoysLocalizer; Bases: Localizer; Performs Boys orbital localization. table of contents. BoysLocalizer; BoysLocalizer. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; BoysLocalizer.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/api/psi4.core.BoysLocalizer.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.BoysLocalizer.html
https://psicode.org/psi4manual/master/api/psi4.core.BoysLocalizer.html:210,Performance,Perform,Performs,210,". BoysLocalizer. Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; BoysLocalizer. BoysLocalizer. class psi4.core.BoysLocalizer; Bases: Localizer; Performs Boys orbital localization. table of contents. BoysLocalizer; BoysLocalizer. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; BoysLocalizer.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/api/psi4.core.BoysLocalizer.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.BoysLocalizer.html
https://psicode.org/psi4manual/master/api/psi4.core.BSVec.html:1701,Availability,error,error,1701,".BSVec; Bases: pybind11_object; Methods Summary. append(self,x); Add an item to the end of the list. clear(self); Clear the contents. count(self,x); Return the number of times x appears in the list. extend(*args,**kwargs); Overloaded function. insert(self,i,x); Insert an item at a given position. pop(*args,**kwargs); Overloaded function. remove(self,x); Remove the first item from the list whose value is x. Methods Documentation. append(self: list[psi4.core.ShellInfo], x: psi4.core.ShellInfo)  None; Add an item to the end of the list. clear(self: list[psi4.core.ShellInfo])  None; Clear the contents. count(self: list[psi4.core.ShellInfo], x: psi4.core.ShellInfo)  int; Return the number of times x appears in the list. extend(*args, **kwargs); Overloaded function. extend(self: list[psi4.core.ShellInfo], L: list[psi4.core.ShellInfo]) -> None. Extend the list by appending all the items in the given list. extend(self: list[psi4.core.ShellInfo], L: Iterable) -> None. Extend the list by appending all the items in the given list. insert(self: list[psi4.core.ShellInfo], i: int, x: psi4.core.ShellInfo)  None; Insert an item at a given position. pop(*args, **kwargs); Overloaded function. pop(self: list[psi4.core.ShellInfo]) -> psi4.core.ShellInfo. Remove and return the last item. pop(self: list[psi4.core.ShellInfo], i: int) -> psi4.core.ShellInfo. Remove and return the item at index i. remove(self: list[psi4.core.ShellInfo], x: psi4.core.ShellInfo)  None; Remove the first item from the list whose value is x. It is an error if there is no such item. table of contents. BSVec; BSVec; BSVec.append(); BSVec.clear(); BSVec.count(); BSVec.extend(); BSVec.insert(); BSVec.pop(); BSVec.remove(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; BSVec.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/api/psi4.core.BSVec.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.BSVec.html
https://psicode.org/psi4manual/master/api/psi4.core.BSVec.html:2072,Deployability,update,updated,2072,".BSVec; Bases: pybind11_object; Methods Summary. append(self,x); Add an item to the end of the list. clear(self); Clear the contents. count(self,x); Return the number of times x appears in the list. extend(*args,**kwargs); Overloaded function. insert(self,i,x); Insert an item at a given position. pop(*args,**kwargs); Overloaded function. remove(self,x); Remove the first item from the list whose value is x. Methods Documentation. append(self: list[psi4.core.ShellInfo], x: psi4.core.ShellInfo)  None; Add an item to the end of the list. clear(self: list[psi4.core.ShellInfo])  None; Clear the contents. count(self: list[psi4.core.ShellInfo], x: psi4.core.ShellInfo)  int; Return the number of times x appears in the list. extend(*args, **kwargs); Overloaded function. extend(self: list[psi4.core.ShellInfo], L: list[psi4.core.ShellInfo]) -> None. Extend the list by appending all the items in the given list. extend(self: list[psi4.core.ShellInfo], L: Iterable) -> None. Extend the list by appending all the items in the given list. insert(self: list[psi4.core.ShellInfo], i: int, x: psi4.core.ShellInfo)  None; Insert an item at a given position. pop(*args, **kwargs); Overloaded function. pop(self: list[psi4.core.ShellInfo]) -> psi4.core.ShellInfo. Remove and return the last item. pop(self: list[psi4.core.ShellInfo], i: int) -> psi4.core.ShellInfo. Remove and return the item at index i. remove(self: list[psi4.core.ShellInfo], x: psi4.core.ShellInfo)  None; Remove the first item from the list whose value is x. It is an error if there is no such item. table of contents. BSVec; BSVec; BSVec.append(); BSVec.clear(); BSVec.count(); BSVec.extend(); BSVec.insert(); BSVec.pop(); BSVec.remove(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; BSVec.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/api/psi4.core.BSVec.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.BSVec.html
https://psicode.org/psi4manual/master/api/psi4.core.BSVec.html:353,Modifiability,extend,extend,353,". BSVec. Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; BSVec. BSVec. class psi4.core.BSVec; Bases: pybind11_object; Methods Summary. append(self,x); Add an item to the end of the list. clear(self); Clear the contents. count(self,x); Return the number of times x appears in the list. extend(*args,**kwargs); Overloaded function. insert(self,i,x); Insert an item at a given position. pop(*args,**kwargs); Overloaded function. remove(self,x); Remove the first item from the list whose value is x. Methods Documentation. append(self: list[psi4.core.ShellInfo], x: psi4.core.ShellInfo)  None; Add an item to the end of the list. clear(self: list[psi4.core.ShellInfo])  None; Clear the contents. count(self: list[psi4.core.ShellInfo], x: psi4.core.ShellInfo)  int; Return the number of times x appears in the list. extend(*args, **kwargs); Overloaded function. extend(self: list[psi4.core.ShellInfo], L: list[psi4.core.ShellInfo]) -> None. Extend the list by appending all the items in the given list. extend(self: list[psi4.core.ShellInfo], L: Iterable) -> None. Extend the list by appending all the items in the given list. insert(self: list[psi4.core.ShellInfo], i: int, x: psi4.core.ShellInfo)  None; Insert an item at a given position. pop(*args, **kwargs); Overloaded function. pop(self: list[psi4.core.ShellInfo]) -> psi4.core.ShellInfo. Remove and return the last item. pop(self: list[psi4.core.ShellInfo], i: int) -> psi4.core.ShellInfo. Remove and return the item at index i. remove(self: list[psi4.core.ShellInfo], x: psi4.core.ShellInfo)  None; Remove the first item from the list whose value is x. It is an error if there is no such item. table of contents. BSVec; BSVec; BSVec.append(); BSVec.clear(); BSVec.count(); BSVec.extend(); BSVec.insert(); BSVec.pop(); BSVec.remove(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking",MatchSource.WIKI,psi4manual/master/api/psi4.core.BSVec.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.BSVec.html
https://psicode.org/psi4manual/master/api/psi4.core.BSVec.html:890,Modifiability,extend,extend,890,". BSVec. Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; BSVec. BSVec. class psi4.core.BSVec; Bases: pybind11_object; Methods Summary. append(self,x); Add an item to the end of the list. clear(self); Clear the contents. count(self,x); Return the number of times x appears in the list. extend(*args,**kwargs); Overloaded function. insert(self,i,x); Insert an item at a given position. pop(*args,**kwargs); Overloaded function. remove(self,x); Remove the first item from the list whose value is x. Methods Documentation. append(self: list[psi4.core.ShellInfo], x: psi4.core.ShellInfo)  None; Add an item to the end of the list. clear(self: list[psi4.core.ShellInfo])  None; Clear the contents. count(self: list[psi4.core.ShellInfo], x: psi4.core.ShellInfo)  int; Return the number of times x appears in the list. extend(*args, **kwargs); Overloaded function. extend(self: list[psi4.core.ShellInfo], L: list[psi4.core.ShellInfo]) -> None. Extend the list by appending all the items in the given list. extend(self: list[psi4.core.ShellInfo], L: Iterable) -> None. Extend the list by appending all the items in the given list. insert(self: list[psi4.core.ShellInfo], i: int, x: psi4.core.ShellInfo)  None; Insert an item at a given position. pop(*args, **kwargs); Overloaded function. pop(self: list[psi4.core.ShellInfo]) -> psi4.core.ShellInfo. Remove and return the last item. pop(self: list[psi4.core.ShellInfo], i: int) -> psi4.core.ShellInfo. Remove and return the item at index i. remove(self: list[psi4.core.ShellInfo], x: psi4.core.ShellInfo)  None; Remove the first item from the list whose value is x. It is an error if there is no such item. table of contents. BSVec; BSVec; BSVec.append(); BSVec.clear(); BSVec.count(); BSVec.extend(); BSVec.insert(); BSVec.pop(); BSVec.remove(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking",MatchSource.WIKI,psi4manual/master/api/psi4.core.BSVec.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.BSVec.html
https://psicode.org/psi4manual/master/api/psi4.core.BSVec.html:937,Modifiability,extend,extend,937,". BSVec. Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; BSVec. BSVec. class psi4.core.BSVec; Bases: pybind11_object; Methods Summary. append(self,x); Add an item to the end of the list. clear(self); Clear the contents. count(self,x); Return the number of times x appears in the list. extend(*args,**kwargs); Overloaded function. insert(self,i,x); Insert an item at a given position. pop(*args,**kwargs); Overloaded function. remove(self,x); Remove the first item from the list whose value is x. Methods Documentation. append(self: list[psi4.core.ShellInfo], x: psi4.core.ShellInfo)  None; Add an item to the end of the list. clear(self: list[psi4.core.ShellInfo])  None; Clear the contents. count(self: list[psi4.core.ShellInfo], x: psi4.core.ShellInfo)  int; Return the number of times x appears in the list. extend(*args, **kwargs); Overloaded function. extend(self: list[psi4.core.ShellInfo], L: list[psi4.core.ShellInfo]) -> None. Extend the list by appending all the items in the given list. extend(self: list[psi4.core.ShellInfo], L: Iterable) -> None. Extend the list by appending all the items in the given list. insert(self: list[psi4.core.ShellInfo], i: int, x: psi4.core.ShellInfo)  None; Insert an item at a given position. pop(*args, **kwargs); Overloaded function. pop(self: list[psi4.core.ShellInfo]) -> psi4.core.ShellInfo. Remove and return the last item. pop(self: list[psi4.core.ShellInfo], i: int) -> psi4.core.ShellInfo. Remove and return the item at index i. remove(self: list[psi4.core.ShellInfo], x: psi4.core.ShellInfo)  None; Remove the first item from the list whose value is x. It is an error if there is no such item. table of contents. BSVec; BSVec; BSVec.append(); BSVec.clear(); BSVec.count(); BSVec.extend(); BSVec.insert(); BSVec.pop(); BSVec.remove(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking",MatchSource.WIKI,psi4manual/master/api/psi4.core.BSVec.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.BSVec.html
https://psicode.org/psi4manual/master/api/psi4.core.BSVec.html:1016,Modifiability,Extend,Extend,1016,"  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; BSVec. BSVec. class psi4.core.BSVec; Bases: pybind11_object; Methods Summary. append(self,x); Add an item to the end of the list. clear(self); Clear the contents. count(self,x); Return the number of times x appears in the list. extend(*args,**kwargs); Overloaded function. insert(self,i,x); Insert an item at a given position. pop(*args,**kwargs); Overloaded function. remove(self,x); Remove the first item from the list whose value is x. Methods Documentation. append(self: list[psi4.core.ShellInfo], x: psi4.core.ShellInfo)  None; Add an item to the end of the list. clear(self: list[psi4.core.ShellInfo])  None; Clear the contents. count(self: list[psi4.core.ShellInfo], x: psi4.core.ShellInfo)  int; Return the number of times x appears in the list. extend(*args, **kwargs); Overloaded function. extend(self: list[psi4.core.ShellInfo], L: list[psi4.core.ShellInfo]) -> None. Extend the list by appending all the items in the given list. extend(self: list[psi4.core.ShellInfo], L: Iterable) -> None. Extend the list by appending all the items in the given list. insert(self: list[psi4.core.ShellInfo], i: int, x: psi4.core.ShellInfo)  None; Insert an item at a given position. pop(*args, **kwargs); Overloaded function. pop(self: list[psi4.core.ShellInfo]) -> psi4.core.ShellInfo. Remove and return the last item. pop(self: list[psi4.core.ShellInfo], i: int) -> psi4.core.ShellInfo. Remove and return the item at index i. remove(self: list[psi4.core.ShellInfo], x: psi4.core.ShellInfo)  None; Remove the first item from the list whose value is x. It is an error if there is no such item. table of contents. BSVec; BSVec; BSVec.append(); BSVec.clear(); BSVec.count(); BSVec.extend(); BSVec.insert(); BSVec.pop(); BSVec.remove(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; BSVec.  Copyright 2007-2024",MatchSource.WIKI,psi4manual/master/api/psi4.core.BSVec.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.BSVec.html
https://psicode.org/psi4manual/master/api/psi4.core.BSVec.html:1078,Modifiability,extend,extend,1078,"I4 API: Linking C++ and Python; BSVec. BSVec. class psi4.core.BSVec; Bases: pybind11_object; Methods Summary. append(self,x); Add an item to the end of the list. clear(self); Clear the contents. count(self,x); Return the number of times x appears in the list. extend(*args,**kwargs); Overloaded function. insert(self,i,x); Insert an item at a given position. pop(*args,**kwargs); Overloaded function. remove(self,x); Remove the first item from the list whose value is x. Methods Documentation. append(self: list[psi4.core.ShellInfo], x: psi4.core.ShellInfo)  None; Add an item to the end of the list. clear(self: list[psi4.core.ShellInfo])  None; Clear the contents. count(self: list[psi4.core.ShellInfo], x: psi4.core.ShellInfo)  int; Return the number of times x appears in the list. extend(*args, **kwargs); Overloaded function. extend(self: list[psi4.core.ShellInfo], L: list[psi4.core.ShellInfo]) -> None. Extend the list by appending all the items in the given list. extend(self: list[psi4.core.ShellInfo], L: Iterable) -> None. Extend the list by appending all the items in the given list. insert(self: list[psi4.core.ShellInfo], i: int, x: psi4.core.ShellInfo)  None; Insert an item at a given position. pop(*args, **kwargs); Overloaded function. pop(self: list[psi4.core.ShellInfo]) -> psi4.core.ShellInfo. Remove and return the last item. pop(self: list[psi4.core.ShellInfo], i: int) -> psi4.core.ShellInfo. Remove and return the item at index i. remove(self: list[psi4.core.ShellInfo], x: psi4.core.ShellInfo)  None; Remove the first item from the list whose value is x. It is an error if there is no such item. table of contents. BSVec; BSVec; BSVec.append(); BSVec.clear(); BSVec.count(); BSVec.extend(); BSVec.insert(); BSVec.pop(); BSVec.remove(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; BSVec.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursd",MatchSource.WIKI,psi4manual/master/api/psi4.core.BSVec.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.BSVec.html
https://psicode.org/psi4manual/master/api/psi4.core.BSVec.html:1140,Modifiability,Extend,Extend,1140,".BSVec; Bases: pybind11_object; Methods Summary. append(self,x); Add an item to the end of the list. clear(self); Clear the contents. count(self,x); Return the number of times x appears in the list. extend(*args,**kwargs); Overloaded function. insert(self,i,x); Insert an item at a given position. pop(*args,**kwargs); Overloaded function. remove(self,x); Remove the first item from the list whose value is x. Methods Documentation. append(self: list[psi4.core.ShellInfo], x: psi4.core.ShellInfo)  None; Add an item to the end of the list. clear(self: list[psi4.core.ShellInfo])  None; Clear the contents. count(self: list[psi4.core.ShellInfo], x: psi4.core.ShellInfo)  int; Return the number of times x appears in the list. extend(*args, **kwargs); Overloaded function. extend(self: list[psi4.core.ShellInfo], L: list[psi4.core.ShellInfo]) -> None. Extend the list by appending all the items in the given list. extend(self: list[psi4.core.ShellInfo], L: Iterable) -> None. Extend the list by appending all the items in the given list. insert(self: list[psi4.core.ShellInfo], i: int, x: psi4.core.ShellInfo)  None; Insert an item at a given position. pop(*args, **kwargs); Overloaded function. pop(self: list[psi4.core.ShellInfo]) -> psi4.core.ShellInfo. Remove and return the last item. pop(self: list[psi4.core.ShellInfo], i: int) -> psi4.core.ShellInfo. Remove and return the item at index i. remove(self: list[psi4.core.ShellInfo], x: psi4.core.ShellInfo)  None; Remove the first item from the list whose value is x. It is an error if there is no such item. table of contents. BSVec; BSVec; BSVec.append(); BSVec.clear(); BSVec.count(); BSVec.extend(); BSVec.insert(); BSVec.pop(); BSVec.remove(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; BSVec.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/api/psi4.core.BSVec.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.BSVec.html
https://psicode.org/psi4manual/master/api/psi4.core.BSVec.html:1818,Modifiability,extend,extend,1818,".BSVec; Bases: pybind11_object; Methods Summary. append(self,x); Add an item to the end of the list. clear(self); Clear the contents. count(self,x); Return the number of times x appears in the list. extend(*args,**kwargs); Overloaded function. insert(self,i,x); Insert an item at a given position. pop(*args,**kwargs); Overloaded function. remove(self,x); Remove the first item from the list whose value is x. Methods Documentation. append(self: list[psi4.core.ShellInfo], x: psi4.core.ShellInfo)  None; Add an item to the end of the list. clear(self: list[psi4.core.ShellInfo])  None; Clear the contents. count(self: list[psi4.core.ShellInfo], x: psi4.core.ShellInfo)  int; Return the number of times x appears in the list. extend(*args, **kwargs); Overloaded function. extend(self: list[psi4.core.ShellInfo], L: list[psi4.core.ShellInfo]) -> None. Extend the list by appending all the items in the given list. extend(self: list[psi4.core.ShellInfo], L: Iterable) -> None. Extend the list by appending all the items in the given list. insert(self: list[psi4.core.ShellInfo], i: int, x: psi4.core.ShellInfo)  None; Insert an item at a given position. pop(*args, **kwargs); Overloaded function. pop(self: list[psi4.core.ShellInfo]) -> psi4.core.ShellInfo. Remove and return the last item. pop(self: list[psi4.core.ShellInfo], i: int) -> psi4.core.ShellInfo. Remove and return the item at index i. remove(self: list[psi4.core.ShellInfo], x: psi4.core.ShellInfo)  None; Remove the first item from the list whose value is x. It is an error if there is no such item. table of contents. BSVec; BSVec; BSVec.append(); BSVec.clear(); BSVec.count(); BSVec.extend(); BSVec.insert(); BSVec.pop(); BSVec.remove(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; BSVec.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/api/psi4.core.BSVec.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.BSVec.html
https://psicode.org/psi4manual/master/api/psi4.core.BSVec.html:254,Usability,clear,clear,254,". BSVec. Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; BSVec. BSVec. class psi4.core.BSVec; Bases: pybind11_object; Methods Summary. append(self,x); Add an item to the end of the list. clear(self); Clear the contents. count(self,x); Return the number of times x appears in the list. extend(*args,**kwargs); Overloaded function. insert(self,i,x); Insert an item at a given position. pop(*args,**kwargs); Overloaded function. remove(self,x); Remove the first item from the list whose value is x. Methods Documentation. append(self: list[psi4.core.ShellInfo], x: psi4.core.ShellInfo)  None; Add an item to the end of the list. clear(self: list[psi4.core.ShellInfo])  None; Clear the contents. count(self: list[psi4.core.ShellInfo], x: psi4.core.ShellInfo)  int; Return the number of times x appears in the list. extend(*args, **kwargs); Overloaded function. extend(self: list[psi4.core.ShellInfo], L: list[psi4.core.ShellInfo]) -> None. Extend the list by appending all the items in the given list. extend(self: list[psi4.core.ShellInfo], L: Iterable) -> None. Extend the list by appending all the items in the given list. insert(self: list[psi4.core.ShellInfo], i: int, x: psi4.core.ShellInfo)  None; Insert an item at a given position. pop(*args, **kwargs); Overloaded function. pop(self: list[psi4.core.ShellInfo]) -> psi4.core.ShellInfo. Remove and return the last item. pop(self: list[psi4.core.ShellInfo], i: int) -> psi4.core.ShellInfo. Remove and return the item at index i. remove(self: list[psi4.core.ShellInfo], x: psi4.core.ShellInfo)  None; Remove the first item from the list whose value is x. It is an error if there is no such item. table of contents. BSVec; BSVec; BSVec.append(); BSVec.clear(); BSVec.count(); BSVec.extend(); BSVec.insert(); BSVec.pop(); BSVec.remove(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking",MatchSource.WIKI,psi4manual/master/api/psi4.core.BSVec.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.BSVec.html
https://psicode.org/psi4manual/master/api/psi4.core.BSVec.html:267,Usability,Clear,Clear,267,". BSVec. Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; BSVec. BSVec. class psi4.core.BSVec; Bases: pybind11_object; Methods Summary. append(self,x); Add an item to the end of the list. clear(self); Clear the contents. count(self,x); Return the number of times x appears in the list. extend(*args,**kwargs); Overloaded function. insert(self,i,x); Insert an item at a given position. pop(*args,**kwargs); Overloaded function. remove(self,x); Remove the first item from the list whose value is x. Methods Documentation. append(self: list[psi4.core.ShellInfo], x: psi4.core.ShellInfo)  None; Add an item to the end of the list. clear(self: list[psi4.core.ShellInfo])  None; Clear the contents. count(self: list[psi4.core.ShellInfo], x: psi4.core.ShellInfo)  int; Return the number of times x appears in the list. extend(*args, **kwargs); Overloaded function. extend(self: list[psi4.core.ShellInfo], L: list[psi4.core.ShellInfo]) -> None. Extend the list by appending all the items in the given list. extend(self: list[psi4.core.ShellInfo], L: Iterable) -> None. Extend the list by appending all the items in the given list. insert(self: list[psi4.core.ShellInfo], i: int, x: psi4.core.ShellInfo)  None; Insert an item at a given position. pop(*args, **kwargs); Overloaded function. pop(self: list[psi4.core.ShellInfo]) -> psi4.core.ShellInfo. Remove and return the last item. pop(self: list[psi4.core.ShellInfo], i: int) -> psi4.core.ShellInfo. Remove and return the item at index i. remove(self: list[psi4.core.ShellInfo], x: psi4.core.ShellInfo)  None; Remove the first item from the list whose value is x. It is an error if there is no such item. table of contents. BSVec; BSVec; BSVec.append(); BSVec.clear(); BSVec.count(); BSVec.extend(); BSVec.insert(); BSVec.pop(); BSVec.remove(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking",MatchSource.WIKI,psi4manual/master/api/psi4.core.BSVec.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.BSVec.html
https://psicode.org/psi4manual/master/api/psi4.core.BSVec.html:701,Usability,clear,clear,701,". BSVec. Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; BSVec. BSVec. class psi4.core.BSVec; Bases: pybind11_object; Methods Summary. append(self,x); Add an item to the end of the list. clear(self); Clear the contents. count(self,x); Return the number of times x appears in the list. extend(*args,**kwargs); Overloaded function. insert(self,i,x); Insert an item at a given position. pop(*args,**kwargs); Overloaded function. remove(self,x); Remove the first item from the list whose value is x. Methods Documentation. append(self: list[psi4.core.ShellInfo], x: psi4.core.ShellInfo)  None; Add an item to the end of the list. clear(self: list[psi4.core.ShellInfo])  None; Clear the contents. count(self: list[psi4.core.ShellInfo], x: psi4.core.ShellInfo)  int; Return the number of times x appears in the list. extend(*args, **kwargs); Overloaded function. extend(self: list[psi4.core.ShellInfo], L: list[psi4.core.ShellInfo]) -> None. Extend the list by appending all the items in the given list. extend(self: list[psi4.core.ShellInfo], L: Iterable) -> None. Extend the list by appending all the items in the given list. insert(self: list[psi4.core.ShellInfo], i: int, x: psi4.core.ShellInfo)  None; Insert an item at a given position. pop(*args, **kwargs); Overloaded function. pop(self: list[psi4.core.ShellInfo]) -> psi4.core.ShellInfo. Remove and return the last item. pop(self: list[psi4.core.ShellInfo], i: int) -> psi4.core.ShellInfo. Remove and return the item at index i. remove(self: list[psi4.core.ShellInfo], x: psi4.core.ShellInfo)  None; Remove the first item from the list whose value is x. It is an error if there is no such item. table of contents. BSVec; BSVec; BSVec.append(); BSVec.clear(); BSVec.count(); BSVec.extend(); BSVec.insert(); BSVec.pop(); BSVec.remove(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking",MatchSource.WIKI,psi4manual/master/api/psi4.core.BSVec.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.BSVec.html
https://psicode.org/psi4manual/master/api/psi4.core.BSVec.html:749,Usability,Clear,Clear,749,". BSVec. Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; BSVec. BSVec. class psi4.core.BSVec; Bases: pybind11_object; Methods Summary. append(self,x); Add an item to the end of the list. clear(self); Clear the contents. count(self,x); Return the number of times x appears in the list. extend(*args,**kwargs); Overloaded function. insert(self,i,x); Insert an item at a given position. pop(*args,**kwargs); Overloaded function. remove(self,x); Remove the first item from the list whose value is x. Methods Documentation. append(self: list[psi4.core.ShellInfo], x: psi4.core.ShellInfo)  None; Add an item to the end of the list. clear(self: list[psi4.core.ShellInfo])  None; Clear the contents. count(self: list[psi4.core.ShellInfo], x: psi4.core.ShellInfo)  int; Return the number of times x appears in the list. extend(*args, **kwargs); Overloaded function. extend(self: list[psi4.core.ShellInfo], L: list[psi4.core.ShellInfo]) -> None. Extend the list by appending all the items in the given list. extend(self: list[psi4.core.ShellInfo], L: Iterable) -> None. Extend the list by appending all the items in the given list. insert(self: list[psi4.core.ShellInfo], i: int, x: psi4.core.ShellInfo)  None; Insert an item at a given position. pop(*args, **kwargs); Overloaded function. pop(self: list[psi4.core.ShellInfo]) -> psi4.core.ShellInfo. Remove and return the last item. pop(self: list[psi4.core.ShellInfo], i: int) -> psi4.core.ShellInfo. Remove and return the item at index i. remove(self: list[psi4.core.ShellInfo], x: psi4.core.ShellInfo)  None; Remove the first item from the list whose value is x. It is an error if there is no such item. table of contents. BSVec; BSVec; BSVec.append(); BSVec.clear(); BSVec.count(); BSVec.extend(); BSVec.insert(); BSVec.pop(); BSVec.remove(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking",MatchSource.WIKI,psi4manual/master/api/psi4.core.BSVec.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.BSVec.html
https://psicode.org/psi4manual/master/api/psi4.core.BSVec.html:1788,Usability,clear,clear,1788,".BSVec; Bases: pybind11_object; Methods Summary. append(self,x); Add an item to the end of the list. clear(self); Clear the contents. count(self,x); Return the number of times x appears in the list. extend(*args,**kwargs); Overloaded function. insert(self,i,x); Insert an item at a given position. pop(*args,**kwargs); Overloaded function. remove(self,x); Remove the first item from the list whose value is x. Methods Documentation. append(self: list[psi4.core.ShellInfo], x: psi4.core.ShellInfo)  None; Add an item to the end of the list. clear(self: list[psi4.core.ShellInfo])  None; Clear the contents. count(self: list[psi4.core.ShellInfo], x: psi4.core.ShellInfo)  int; Return the number of times x appears in the list. extend(*args, **kwargs); Overloaded function. extend(self: list[psi4.core.ShellInfo], L: list[psi4.core.ShellInfo]) -> None. Extend the list by appending all the items in the given list. extend(self: list[psi4.core.ShellInfo], L: Iterable) -> None. Extend the list by appending all the items in the given list. insert(self: list[psi4.core.ShellInfo], i: int, x: psi4.core.ShellInfo)  None; Insert an item at a given position. pop(*args, **kwargs); Overloaded function. pop(self: list[psi4.core.ShellInfo]) -> psi4.core.ShellInfo. Remove and return the last item. pop(self: list[psi4.core.ShellInfo], i: int) -> psi4.core.ShellInfo. Remove and return the item at index i. remove(self: list[psi4.core.ShellInfo], x: psi4.core.ShellInfo)  None; Remove the first item from the list whose value is x. It is an error if there is no such item. table of contents. BSVec; BSVec; BSVec.append(); BSVec.clear(); BSVec.count(); BSVec.extend(); BSVec.insert(); BSVec.pop(); BSVec.remove(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; BSVec.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/api/psi4.core.BSVec.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.BSVec.html
https://psicode.org/psi4manual/master/api/psi4.core.ccdensity.html:518,Deployability,update,updated,518,". ccdensity. Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; ccdensity. ccdensity. psi4.core.ccdensity(ref_wfn: psi4.core.CCWavefunction)  float; Runs the code to compute coupled cluster density matrices. table of contents. ccdensity; ccdensity(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; ccdensity.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/api/psi4.core.ccdensity.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.ccdensity.html
https://psicode.org/psi4manual/master/api/psi4.core.ccenergy.html:505,Deployability,update,updated,505,". ccenergy. Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; ccenergy. ccenergy. psi4.core.ccenergy(ref_wfn: psi4.core.Wavefunction)  psi4.core.Wavefunction; Runs the coupled cluster energy code. table of contents. ccenergy; ccenergy(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; ccenergy.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/api/psi4.core.ccenergy.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.ccenergy.html
https://psicode.org/psi4manual/master/api/psi4.core.ccenergy.html:249,Energy Efficiency,energy,energy,249,". ccenergy. Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; ccenergy. ccenergy. psi4.core.ccenergy(ref_wfn: psi4.core.Wavefunction)  psi4.core.Wavefunction; Runs the coupled cluster energy code. table of contents. ccenergy; ccenergy(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; ccenergy.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/api/psi4.core.ccenergy.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.ccenergy.html
https://psicode.org/psi4manual/master/api/psi4.core.cceom.html:500,Deployability,update,updated,500,". cceom. Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; cceom. cceom. psi4.core.cceom(ref_wfn: psi4.core.CCWavefunction)  float; Runs the equation of motion coupled cluster code for excited states. table of contents. cceom; cceom(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; cceom.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/api/psi4.core.cceom.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.cceom.html
https://psicode.org/psi4manual/master/api/psi4.core.cchbar.html:501,Deployability,update,updated,501,". cchbar. Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; cchbar. cchbar. psi4.core.cchbar(ref_wfn: psi4.core.Wavefunction)  None; Runs the code to generate the similarity transformed Hamiltonian. table of contents. cchbar; cchbar(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; cchbar.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/api/psi4.core.cchbar.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.cchbar.html
https://psicode.org/psi4manual/master/api/psi4.core.cclambda.html:515,Deployability,update,updated,515,". cclambda. Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; cclambda. cclambda. psi4.core.cclambda(ref_wfn: psi4.core.Wavefunction)  psi4.core.Wavefunction; Runs the coupled cluster lambda equations code. table of contents. cclambda; cclambda(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; cclambda.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/api/psi4.core.cclambda.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.cclambda.html
https://psicode.org/psi4manual/master/api/psi4.core.ccresponse.html:511,Deployability,update,updated,511,". ccresponse. Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; ccresponse. ccresponse. psi4.core.ccresponse(ref_wfn: psi4.core.Wavefunction)  float; Runs the coupled cluster response theory code. table of contents. ccresponse; ccresponse(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; ccresponse.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/api/psi4.core.ccresponse.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.ccresponse.html
https://psicode.org/psi4manual/master/api/psi4.core.cctransort.html:556,Deployability,update,updated,556,". cctransort. Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; cctransort. cctransort. psi4.core.cctransort(ref_wfn: psi4.core.Wavefunction)  None; Runs cctransort that transforms and reorders integrals for use in the coupled cluster codes. table of contents. cctransort; cctransort(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; cctransort.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/api/psi4.core.cctransort.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.cctransort.html
https://psicode.org/psi4manual/master/api/psi4.core.cctriples.html:499,Deployability,update,updated,499,". cctriples. Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; cctriples. cctriples. psi4.core.cctriples(ref_wfn: psi4.core.Wavefunction)  float; Runs the coupled cluster (T) energy code. table of contents. cctriples; cctriples(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; cctriples.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/api/psi4.core.cctriples.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.cctriples.html
https://psicode.org/psi4manual/master/api/psi4.core.cctriples.html:240,Energy Efficiency,energy,energy,240,". cctriples. Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; cctriples. cctriples. psi4.core.cctriples(ref_wfn: psi4.core.Wavefunction)  float; Runs the coupled cluster (T) energy code. table of contents. cctriples; cctriples(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; cctriples.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/api/psi4.core.cctriples.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.cctriples.html
https://psicode.org/psi4manual/master/api/psi4.core.CCWavefunction.html:1447,Availability,error,error,1447," . PSI4. PSI4 API: Linking C++ and Python; CCWavefunction. CCWavefunction. class psi4.core.CCWavefunction; Bases: Wavefunction; Specialized Wavefunction used by the ccenergy, cceom, ccgradient, etc. modules.; Methods Summary. get_amplitudes(self); Get dict of converged T amplitudes. total_index(self,i,h); Map an index (i) within irrep (h) to its energy-sorted index among all roots. Methods Documentation. get_amplitudes(self: psi4.core.CCWavefunction)  dict[str, psi4.core.Matrix]; Get dict of converged T amplitudes. Returns:. amps (dict (spacestr, SharedMatrix))  spacestr is a description of the amplitude set using the following conventions. I,J,K -> alpha occupied; i,j,k -> beta occupied; A,B,C -> alpha virtual; a,b,c -> beta virtual. The following entries are stored in the amps, depending on the reference type; RHF (tIA, tIjAb); UHF (tIA, tia, tIjAb, tIJAB, tijab); ROHF (tIA, tia, tIjAb, tIJAB, tijab). Examples; RHF T1 diagnostic = sqrt(sum_ia (T_ia * T_ia)/nelec); >>> mol = ;  0 1;  Ne 0.0 0.0 0.0;  symmetry c1; >>> e, wfn = psi4.energy(CCSD/cc-pvdz, return_wfn=True); >>> t1 = wfn.get_amplitudes()[tia].to_array(); >>> t1_diagnostic = np.sqrt(np.dot(t1.ravel(),t1.ravel())/ (2 * wfn.nalpha()); >>> t1_diagnostic == psi4.variable(CC T1 DIAGNOSTIC); True. Warning; Symmetry free calculations only (nirreps > 1 will cause error). Warning; No checks that the amplitudes will fit in core. Do not use for proteins. total_index(self: psi4.core.CCWavefunction, i: int, h: int)  int; Map an index (i) within irrep (h) to its energy-sorted index among all roots. table of contents. CCWavefunction; CCWavefunction; CCWavefunction.get_amplitudes(); CCWavefunction.total_index(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; CCWavefunction.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/api/psi4.core.CCWavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.CCWavefunction.html
https://psicode.org/psi4manual/master/api/psi4.core.CCWavefunction.html:2005,Deployability,update,updated,2005," . PSI4. PSI4 API: Linking C++ and Python; CCWavefunction. CCWavefunction. class psi4.core.CCWavefunction; Bases: Wavefunction; Specialized Wavefunction used by the ccenergy, cceom, ccgradient, etc. modules.; Methods Summary. get_amplitudes(self); Get dict of converged T amplitudes. total_index(self,i,h); Map an index (i) within irrep (h) to its energy-sorted index among all roots. Methods Documentation. get_amplitudes(self: psi4.core.CCWavefunction)  dict[str, psi4.core.Matrix]; Get dict of converged T amplitudes. Returns:. amps (dict (spacestr, SharedMatrix))  spacestr is a description of the amplitude set using the following conventions. I,J,K -> alpha occupied; i,j,k -> beta occupied; A,B,C -> alpha virtual; a,b,c -> beta virtual. The following entries are stored in the amps, depending on the reference type; RHF (tIA, tIjAb); UHF (tIA, tia, tIjAb, tIJAB, tijab); ROHF (tIA, tia, tIjAb, tIJAB, tijab). Examples; RHF T1 diagnostic = sqrt(sum_ia (T_ia * T_ia)/nelec); >>> mol = ;  0 1;  Ne 0.0 0.0 0.0;  symmetry c1; >>> e, wfn = psi4.energy(CCSD/cc-pvdz, return_wfn=True); >>> t1 = wfn.get_amplitudes()[tia].to_array(); >>> t1_diagnostic = np.sqrt(np.dot(t1.ravel(),t1.ravel())/ (2 * wfn.nalpha()); >>> t1_diagnostic == psi4.variable(CC T1 DIAGNOSTIC); True. Warning; Symmetry free calculations only (nirreps > 1 will cause error). Warning; No checks that the amplitudes will fit in core. Do not use for proteins. total_index(self: psi4.core.CCWavefunction, i: int, h: int)  int; Map an index (i) within irrep (h) to its energy-sorted index among all roots. table of contents. CCWavefunction; CCWavefunction; CCWavefunction.get_amplitudes(); CCWavefunction.total_index(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; CCWavefunction.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/api/psi4.core.CCWavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.CCWavefunction.html
https://psicode.org/psi4manual/master/api/psi4.core.CCWavefunction.html:439,Energy Efficiency,energy,energy-sorted,439,". CCWavefunction. Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; CCWavefunction. CCWavefunction. class psi4.core.CCWavefunction; Bases: Wavefunction; Specialized Wavefunction used by the ccenergy, cceom, ccgradient, etc. modules.; Methods Summary. get_amplitudes(self); Get dict of converged T amplitudes. total_index(self,i,h); Map an index (i) within irrep (h) to its energy-sorted index among all roots. Methods Documentation. get_amplitudes(self: psi4.core.CCWavefunction)  dict[str, psi4.core.Matrix]; Get dict of converged T amplitudes. Returns:. amps (dict (spacestr, SharedMatrix))  spacestr is a description of the amplitude set using the following conventions. I,J,K -> alpha occupied; i,j,k -> beta occupied; A,B,C -> alpha virtual; a,b,c -> beta virtual. The following entries are stored in the amps, depending on the reference type; RHF (tIA, tIjAb); UHF (tIA, tia, tIjAb, tIJAB, tijab); ROHF (tIA, tia, tIjAb, tIJAB, tijab). Examples; RHF T1 diagnostic = sqrt(sum_ia (T_ia * T_ia)/nelec); >>> mol = ;  0 1;  Ne 0.0 0.0 0.0;  symmetry c1; >>> e, wfn = psi4.energy(CCSD/cc-pvdz, return_wfn=True); >>> t1 = wfn.get_amplitudes()[tia].to_array(); >>> t1_diagnostic = np.sqrt(np.dot(t1.ravel(),t1.ravel())/ (2 * wfn.nalpha()); >>> t1_diagnostic == psi4.variable(CC T1 DIAGNOSTIC); True. Warning; Symmetry free calculations only (nirreps > 1 will cause error). Warning; No checks that the amplitudes will fit in core. Do not use for proteins. total_index(self: psi4.core.CCWavefunction, i: int, h: int)  int; Map an index (i) within irrep (h) to its energy-sorted index among all roots. table of contents. CCWavefunction; CCWavefunction; CCWavefunction.get_amplitudes(); CCWavefunction.total_index(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; CCWavefunction.  Copyright 2007-2024, The Psi4 Project.; L",MatchSource.WIKI,psi4manual/master/api/psi4.core.CCWavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.CCWavefunction.html
https://psicode.org/psi4manual/master/api/psi4.core.CCWavefunction.html:1151,Energy Efficiency,energy,energy,1151," . PSI4. PSI4 API: Linking C++ and Python; CCWavefunction. CCWavefunction. class psi4.core.CCWavefunction; Bases: Wavefunction; Specialized Wavefunction used by the ccenergy, cceom, ccgradient, etc. modules.; Methods Summary. get_amplitudes(self); Get dict of converged T amplitudes. total_index(self,i,h); Map an index (i) within irrep (h) to its energy-sorted index among all roots. Methods Documentation. get_amplitudes(self: psi4.core.CCWavefunction)  dict[str, psi4.core.Matrix]; Get dict of converged T amplitudes. Returns:. amps (dict (spacestr, SharedMatrix))  spacestr is a description of the amplitude set using the following conventions. I,J,K -> alpha occupied; i,j,k -> beta occupied; A,B,C -> alpha virtual; a,b,c -> beta virtual. The following entries are stored in the amps, depending on the reference type; RHF (tIA, tIjAb); UHF (tIA, tia, tIjAb, tIJAB, tijab); ROHF (tIA, tia, tIjAb, tIJAB, tijab). Examples; RHF T1 diagnostic = sqrt(sum_ia (T_ia * T_ia)/nelec); >>> mol = ;  0 1;  Ne 0.0 0.0 0.0;  symmetry c1; >>> e, wfn = psi4.energy(CCSD/cc-pvdz, return_wfn=True); >>> t1 = wfn.get_amplitudes()[tia].to_array(); >>> t1_diagnostic = np.sqrt(np.dot(t1.ravel(),t1.ravel())/ (2 * wfn.nalpha()); >>> t1_diagnostic == psi4.variable(CC T1 DIAGNOSTIC); True. Warning; Symmetry free calculations only (nirreps > 1 will cause error). Warning; No checks that the amplitudes will fit in core. Do not use for proteins. total_index(self: psi4.core.CCWavefunction, i: int, h: int)  int; Map an index (i) within irrep (h) to its energy-sorted index among all roots. table of contents. CCWavefunction; CCWavefunction; CCWavefunction.get_amplitudes(); CCWavefunction.total_index(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; CCWavefunction.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/api/psi4.core.CCWavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.CCWavefunction.html
https://psicode.org/psi4manual/master/api/psi4.core.CCWavefunction.html:1646,Energy Efficiency,energy,energy-sorted,1646," . PSI4. PSI4 API: Linking C++ and Python; CCWavefunction. CCWavefunction. class psi4.core.CCWavefunction; Bases: Wavefunction; Specialized Wavefunction used by the ccenergy, cceom, ccgradient, etc. modules.; Methods Summary. get_amplitudes(self); Get dict of converged T amplitudes. total_index(self,i,h); Map an index (i) within irrep (h) to its energy-sorted index among all roots. Methods Documentation. get_amplitudes(self: psi4.core.CCWavefunction)  dict[str, psi4.core.Matrix]; Get dict of converged T amplitudes. Returns:. amps (dict (spacestr, SharedMatrix))  spacestr is a description of the amplitude set using the following conventions. I,J,K -> alpha occupied; i,j,k -> beta occupied; A,B,C -> alpha virtual; a,b,c -> beta virtual. The following entries are stored in the amps, depending on the reference type; RHF (tIA, tIjAb); UHF (tIA, tia, tIjAb, tIJAB, tijab); ROHF (tIA, tia, tIjAb, tIJAB, tijab). Examples; RHF T1 diagnostic = sqrt(sum_ia (T_ia * T_ia)/nelec); >>> mol = ;  0 1;  Ne 0.0 0.0 0.0;  symmetry c1; >>> e, wfn = psi4.energy(CCSD/cc-pvdz, return_wfn=True); >>> t1 = wfn.get_amplitudes()[tia].to_array(); >>> t1_diagnostic = np.sqrt(np.dot(t1.ravel(),t1.ravel())/ (2 * wfn.nalpha()); >>> t1_diagnostic == psi4.variable(CC T1 DIAGNOSTIC); True. Warning; Symmetry free calculations only (nirreps > 1 will cause error). Warning; No checks that the amplitudes will fit in core. Do not use for proteins. total_index(self: psi4.core.CCWavefunction, i: int, h: int)  int; Map an index (i) within irrep (h) to its energy-sorted index among all roots. table of contents. CCWavefunction; CCWavefunction; CCWavefunction.get_amplitudes(); CCWavefunction.total_index(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; CCWavefunction.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/api/psi4.core.CCWavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.CCWavefunction.html
https://psicode.org/psi4manual/master/api/psi4.core.CCWavefunction.html:885,Integrability,depend,depending,885,". CCWavefunction. Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; CCWavefunction. CCWavefunction. class psi4.core.CCWavefunction; Bases: Wavefunction; Specialized Wavefunction used by the ccenergy, cceom, ccgradient, etc. modules.; Methods Summary. get_amplitudes(self); Get dict of converged T amplitudes. total_index(self,i,h); Map an index (i) within irrep (h) to its energy-sorted index among all roots. Methods Documentation. get_amplitudes(self: psi4.core.CCWavefunction)  dict[str, psi4.core.Matrix]; Get dict of converged T amplitudes. Returns:. amps (dict (spacestr, SharedMatrix))  spacestr is a description of the amplitude set using the following conventions. I,J,K -> alpha occupied; i,j,k -> beta occupied; A,B,C -> alpha virtual; a,b,c -> beta virtual. The following entries are stored in the amps, depending on the reference type; RHF (tIA, tIjAb); UHF (tIA, tia, tIjAb, tIJAB, tijab); ROHF (tIA, tia, tIjAb, tIJAB, tijab). Examples; RHF T1 diagnostic = sqrt(sum_ia (T_ia * T_ia)/nelec); >>> mol = ;  0 1;  Ne 0.0 0.0 0.0;  symmetry c1; >>> e, wfn = psi4.energy(CCSD/cc-pvdz, return_wfn=True); >>> t1 = wfn.get_amplitudes()[tia].to_array(); >>> t1_diagnostic = np.sqrt(np.dot(t1.ravel(),t1.ravel())/ (2 * wfn.nalpha()); >>> t1_diagnostic == psi4.variable(CC T1 DIAGNOSTIC); True. Warning; Symmetry free calculations only (nirreps > 1 will cause error). Warning; No checks that the amplitudes will fit in core. Do not use for proteins. total_index(self: psi4.core.CCWavefunction, i: int, h: int)  int; Map an index (i) within irrep (h) to its energy-sorted index among all roots. table of contents. CCWavefunction; CCWavefunction; CCWavefunction.get_amplitudes(); CCWavefunction.total_index(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; CCWavefunction.  Copyright 2007-2024, The Psi4 Project.; L",MatchSource.WIKI,psi4manual/master/api/psi4.core.CCWavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.CCWavefunction.html
https://psicode.org/psi4manual/master/api/psi4.core.CCWavefunction.html:1346,Modifiability,variab,variable,1346," . PSI4. PSI4 API: Linking C++ and Python; CCWavefunction. CCWavefunction. class psi4.core.CCWavefunction; Bases: Wavefunction; Specialized Wavefunction used by the ccenergy, cceom, ccgradient, etc. modules.; Methods Summary. get_amplitudes(self); Get dict of converged T amplitudes. total_index(self,i,h); Map an index (i) within irrep (h) to its energy-sorted index among all roots. Methods Documentation. get_amplitudes(self: psi4.core.CCWavefunction)  dict[str, psi4.core.Matrix]; Get dict of converged T amplitudes. Returns:. amps (dict (spacestr, SharedMatrix))  spacestr is a description of the amplitude set using the following conventions. I,J,K -> alpha occupied; i,j,k -> beta occupied; A,B,C -> alpha virtual; a,b,c -> beta virtual. The following entries are stored in the amps, depending on the reference type; RHF (tIA, tIjAb); UHF (tIA, tia, tIjAb, tIJAB, tijab); ROHF (tIA, tia, tIjAb, tIJAB, tijab). Examples; RHF T1 diagnostic = sqrt(sum_ia (T_ia * T_ia)/nelec); >>> mol = ;  0 1;  Ne 0.0 0.0 0.0;  symmetry c1; >>> e, wfn = psi4.energy(CCSD/cc-pvdz, return_wfn=True); >>> t1 = wfn.get_amplitudes()[tia].to_array(); >>> t1_diagnostic = np.sqrt(np.dot(t1.ravel(),t1.ravel())/ (2 * wfn.nalpha()); >>> t1_diagnostic == psi4.variable(CC T1 DIAGNOSTIC); True. Warning; Symmetry free calculations only (nirreps > 1 will cause error). Warning; No checks that the amplitudes will fit in core. Do not use for proteins. total_index(self: psi4.core.CCWavefunction, i: int, h: int)  int; Map an index (i) within irrep (h) to its energy-sorted index among all roots. table of contents. CCWavefunction; CCWavefunction; CCWavefunction.get_amplitudes(); CCWavefunction.total_index(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; CCWavefunction.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/api/psi4.core.CCWavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.CCWavefunction.html
https://psicode.org/psi4manual/master/api/psi4.core.CdSalc.html:1055,Deployability,update,updated,1055,". CdSalc. Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; CdSalc. CdSalc. class psi4.core.CdSalc; Bases: pybind11_object; Cartesian displacement SALC; Methods Summary. irrep(self); Return the irrep bit representation. irrep_index(self); Return the irrep index. print_out(self); Print the irrep index and the coordinates of the SALC of Cartesian displacements. Methods Documentation. irrep(self: psi4.core.CdSalc)  str; Return the irrep bit representation. irrep_index(self: psi4.core.CdSalc)  int; Return the irrep index. print_out(self: psi4.core.CdSalc)  None; Print the irrep index and the coordinates of the SALC of Cartesian displacements. Irrep index is 0-indexed and Cotton ordered. table of contents. CdSalc; CdSalc; CdSalc.irrep(); CdSalc.irrep_index(); CdSalc.print_out(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; CdSalc.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/api/psi4.core.CdSalc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.CdSalc.html
https://psicode.org/psi4manual/master/api/psi4.core.CdSalcList.html:2039,Deployability,update,updated,2039,"Python; CdSalcList. CdSalcList. class psi4.core.CdSalcList; Bases: pybind11_object; Class for generating symmetry adapted linear combinations of Cartesian displacements; Methods Summary. create_matrices(self,basename,factory); Return a vector of matrices with the SALC symmetries. matrix(self); Return the matrix that transforms Cartesian displacements to SALCs. matrix_irrep(self,h); Return the matrix that transforms Cartesian displacements to SALCs of irrep h. ncd(self); Return the number of cartesian displacements SALCs. nirrep(self); Return the number of irreps. print_out(self); Print the SALCs to the output file. salc_name(self,i); Return the name of SALC #i. Methods Documentation. create_matrices(self: psi4.core.CdSalcList, basename: str, factory: psi4.core.MatrixFactory)  list[psi4.core.Matrix]; Return a vector of matrices with the SALC symmetries. Dimensions determined by factory. matrix(self: psi4.core.CdSalcList)  psi4.core.Matrix; Return the matrix that transforms Cartesian displacements to SALCs. matrix_irrep(self: psi4.core.CdSalcList, h: int)  psi4.core.Matrix; Return the matrix that transforms Cartesian displacements to SALCs of irrep h. ncd(self: psi4.core.CdSalcList)  int; Return the number of cartesian displacements SALCs. nirrep(self: psi4.core.CdSalcList)  int; Return the number of irreps. print_out(self: psi4.core.CdSalcList)  None; Print the SALCs to the output file. salc_name(self: psi4.core.CdSalcList, i: int)  str; Return the name of SALC #i. table of contents. CdSalcList; CdSalcList; CdSalcList.create_matrices(); CdSalcList.matrix(); CdSalcList.matrix_irrep(); CdSalcList.ncd(); CdSalcList.nirrep(); CdSalcList.print_out(); CdSalcList.salc_name(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; CdSalcList.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/api/psi4.core.CdSalcList.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.CdSalcList.html
https://psicode.org/psi4manual/master/api/psi4.core.CdSalcList.html:234,Energy Efficiency,adapt,adapted,234,". CdSalcList. Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; CdSalcList. CdSalcList. class psi4.core.CdSalcList; Bases: pybind11_object; Class for generating symmetry adapted linear combinations of Cartesian displacements; Methods Summary. create_matrices(self,basename,factory); Return a vector of matrices with the SALC symmetries. matrix(self); Return the matrix that transforms Cartesian displacements to SALCs. matrix_irrep(self,h); Return the matrix that transforms Cartesian displacements to SALCs of irrep h. ncd(self); Return the number of cartesian displacements SALCs. nirrep(self); Return the number of irreps. print_out(self); Print the SALCs to the output file. salc_name(self,i); Return the name of SALC #i. Methods Documentation. create_matrices(self: psi4.core.CdSalcList, basename: str, factory: psi4.core.MatrixFactory)  list[psi4.core.Matrix]; Return a vector of matrices with the SALC symmetries. Dimensions determined by factory. matrix(self: psi4.core.CdSalcList)  psi4.core.Matrix; Return the matrix that transforms Cartesian displacements to SALCs. matrix_irrep(self: psi4.core.CdSalcList, h: int)  psi4.core.Matrix; Return the matrix that transforms Cartesian displacements to SALCs of irrep h. ncd(self: psi4.core.CdSalcList)  int; Return the number of cartesian displacements SALCs. nirrep(self: psi4.core.CdSalcList)  int; Return the number of irreps. print_out(self: psi4.core.CdSalcList)  None; Print the SALCs to the output file. salc_name(self: psi4.core.CdSalcList, i: int)  str; Return the name of SALC #i. table of contents. CdSalcList; CdSalcList; CdSalcList.create_matrices(); CdSalcList.matrix(); CdSalcList.matrix_irrep(); CdSalcList.ncd(); CdSalcList.nirrep(); CdSalcList.print_out(); CdSalcList.salc_name(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; CdSalcList.  Copyrig",MatchSource.WIKI,psi4manual/master/api/psi4.core.CdSalcList.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.CdSalcList.html
https://psicode.org/psi4manual/master/api/psi4.core.CdSalcList.html:234,Modifiability,adapt,adapted,234,". CdSalcList. Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; CdSalcList. CdSalcList. class psi4.core.CdSalcList; Bases: pybind11_object; Class for generating symmetry adapted linear combinations of Cartesian displacements; Methods Summary. create_matrices(self,basename,factory); Return a vector of matrices with the SALC symmetries. matrix(self); Return the matrix that transforms Cartesian displacements to SALCs. matrix_irrep(self,h); Return the matrix that transforms Cartesian displacements to SALCs of irrep h. ncd(self); Return the number of cartesian displacements SALCs. nirrep(self); Return the number of irreps. print_out(self); Print the SALCs to the output file. salc_name(self,i); Return the name of SALC #i. Methods Documentation. create_matrices(self: psi4.core.CdSalcList, basename: str, factory: psi4.core.MatrixFactory)  list[psi4.core.Matrix]; Return a vector of matrices with the SALC symmetries. Dimensions determined by factory. matrix(self: psi4.core.CdSalcList)  psi4.core.Matrix; Return the matrix that transforms Cartesian displacements to SALCs. matrix_irrep(self: psi4.core.CdSalcList, h: int)  psi4.core.Matrix; Return the matrix that transforms Cartesian displacements to SALCs of irrep h. ncd(self: psi4.core.CdSalcList)  int; Return the number of cartesian displacements SALCs. nirrep(self: psi4.core.CdSalcList)  int; Return the number of irreps. print_out(self: psi4.core.CdSalcList)  None; Print the SALCs to the output file. salc_name(self: psi4.core.CdSalcList, i: int)  str; Return the name of SALC #i. table of contents. CdSalcList; CdSalcList; CdSalcList.create_matrices(); CdSalcList.matrix(); CdSalcList.matrix_irrep(); CdSalcList.ncd(); CdSalcList.nirrep(); CdSalcList.print_out(); CdSalcList.salc_name(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; CdSalcList.  Copyrig",MatchSource.WIKI,psi4manual/master/api/psi4.core.CdSalcList.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.CdSalcList.html
https://psicode.org/psi4manual/master/api/psi4.core.CharacterTable.html:1217,Deployability,update,updated,1217,". CharacterTable. Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; CharacterTable. CharacterTable. class psi4.core.CharacterTable; Bases: pybind11_object; Contains the character table of the point group; Methods Summary. gamma(self,arg0); Returns the irrep with the given index in the character table. order(self); Return the order of the point group. symm_operation(self,arg0); Return the i'th symmetry operation. Methods Documentation. gamma(self: psi4.core.CharacterTable, arg0: int)  psi4.core.IrreducibleRepresentation; Returns the irrep with the given index in the character table. order(self: psi4.core.CharacterTable)  int; Return the order of the point group. symm_operation(self: psi4.core.CharacterTable, arg0: int)  psi4.core.SymmetryOperation; Return the ith symmetry operation. 0-indexed. table of contents. CharacterTable; CharacterTable; CharacterTable.gamma(); CharacterTable.order(); CharacterTable.symm_operation(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; CharacterTable.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/api/psi4.core.CharacterTable.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.CharacterTable.html
https://psicode.org/psi4manual/master/api/psi4.core.CIVector.html:2975,Deployability,update,updated,2975,"rg1: psi4.core.CIVector, arg2: int, arg3: int)  None; docstring. close_io_files(self: psi4.core.CIVector, arg0: int)  None; docstring. copy(self: psi4.core.CIVector, arg0: psi4.core.CIVector, arg1: int, arg2: int)  None; docstring. dcalc(self: psi4.core.CIVector, arg0: float, arg1: psi4.core.CIVector, arg2: int)  float; docstring. divide(self: psi4.core.CIVector, arg0: psi4.core.CIVector, arg1: float, arg2: int, arg3: int)  None; docstring. init_io_files(self: psi4.core.CIVector, arg0: bool)  None; docstring. norm(self: psi4.core.CIVector, arg0: int)  float; docstring. read(self: psi4.core.CIVector, arg0: int, arg1: int)  int; docstring. scale(self: psi4.core.CIVector, arg0: float, arg1: int)  None; docstring. set_nvec(self: psi4.core.CIVector, arg0: int)  None; docstring. shift(self: psi4.core.CIVector, arg0: float, arg1: int)  None; docstring. symnormalize(self: psi4.core.CIVector, arg0: float, arg1: int)  None; docstring. vdot(self: psi4.core.CIVector, arg0: psi4.core.CIVector, arg1: int, arg2: int)  float; docstring. vector_multiply(self: psi4.core.CIVector, arg0: float, arg1: psi4.core.CIVector, arg2: psi4.core.CIVector, arg3: int, arg4: int, arg5: int)  None; docstring. write(self: psi4.core.CIVector, arg0: int, arg1: int)  int; docstring. zero(self: psi4.core.CIVector)  None; docstring. table of contents. CIVector; CIVector; CIVector.np; CIVector.axpy(); CIVector.close_io_files(); CIVector.copy(); CIVector.dcalc(); CIVector.divide(); CIVector.init_io_files(); CIVector.norm(); CIVector.read(); CIVector.scale(); CIVector.set_nvec(); CIVector.shift(); CIVector.symnormalize(); CIVector.vdot(); CIVector.vector_multiply(); CIVector.write(); CIVector.zero(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; CIVector.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/api/psi4.core.CIVector.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.CIVector.html
https://psicode.org/psi4manual/master/api/psi4.core.CIWavefunction.html:7655,Deployability,update,updated,7655," **kwargs); Overloaded function. sigma(self: psi4.core.CIWavefunction, arg0: psi4.core.CIVector, arg1: psi4.core.CIVector, arg2: int, arg3: int) -> None. docstring. sigma(self: psi4.core.CIWavefunction, arg0: psi4.core.CIVector, arg1: psi4.core.CIVector, arg2: int, arg3: int, arg4: psi4.core.Vector, arg5: psi4.core.Vector) -> None. docstring. tpdm(self: psi4.core.CIWavefunction, arg0: psi4.core.CIVector, arg1: psi4.core.CIVector, arg2: int, arg3: int)  list[psi4.core.Matrix]; docstring. transform_ci_integrals(self: psi4.core.CIWavefunction)  None; Transforms the one- and two-electron integrals for a CI computation. transform_mcscf_integrals(self: psi4.core.CIWavefunction, arg0: bool)  None; docstring. table of contents. CIWavefunction; CIWavefunction; CIWavefunction.D_vector(); CIWavefunction.Hd_vector(); CIWavefunction.ci_nat_orbs(); CIWavefunction.cleanup_ci(); CIWavefunction.cleanup_dpd(); CIWavefunction.compute_state_transfer(); CIWavefunction.diag_h(); CIWavefunction.form_opdm(); CIWavefunction.form_tpdm(); CIWavefunction.get_dimension(); CIWavefunction.get_opdm(); CIWavefunction.get_orbitals(); CIWavefunction.get_tpdm(); CIWavefunction.hamiltonian(); CIWavefunction.mcscf_object(); CIWavefunction.ndet(); CIWavefunction.new_civector(); CIWavefunction.opdm(); CIWavefunction.pitzer_to_ci_order_onel(); CIWavefunction.pitzer_to_ci_order_twoel(); CIWavefunction.print_vector(); CIWavefunction.reset_ci_H0block(); CIWavefunction.rotate_mcscf_integrals(); CIWavefunction.semicanonical_orbs(); CIWavefunction.set_ci_guess(); CIWavefunction.set_orbitals(); CIWavefunction.sigma(); CIWavefunction.tpdm(); CIWavefunction.transform_ci_integrals(); CIWavefunction.transform_mcscf_integrals(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; CIWavefunction.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/api/psi4.core.CIWavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.CIWavefunction.html
https://psicode.org/psi4manual/master/api/psi4.core.CIWavefunction.html:4046,Integrability,contract,contract,4046,"ulations.; Jroot (int)  The index of the root in the ket. Select -1 for the same as Iroot.; Always use -1 for single-state calculations.; spin (str)  {A, B, SUM}; Return the alpha density matrix, the beta density matrix, or their sum?; full_space (bool)  Return a density matrix in the space of all orbitals (true) or the active orbitals (false)?. Returns:; The selected one-particle density/transition matrix with Pitzer-ordered orbitals.; Irrep h of the matrix corresponds to orbitals of irrep h.; Element pq is <|a^p a_q|>. Return type:; Matrix. get_orbitals(self: psi4.core.CIWavefunction, arg0: str)  psi4.core.Matrix; docstring. get_tpdm(self: psi4.core.CIWavefunction, spin: str, symmetrize: bool)  psi4.core.Matrix; Returns the two-particle density matrix. Parameters:. spin (str)  {AA, AB, BB, SUM}; Which spin-block of the TPDM should be returned? SUM sums over all possible spin cases.; symmetrize (bool)  Return a genuine TPDM element (false) or an average of TPDM elements that contract with the same integral (true)?; Only working for SUM. Returns:; The two-particle density matrix with Pitzer-ordered orbitals, restricted to the active space.; If symmetrize is false, element pqrs is <|a^p a^r a_s a_q|>.; If symmetrize is true, element pqrs is obtained by summing over all flips of p/s, q/r, and multiplying by 0.5. Return type:; Matrix. hamiltonian(self: psi4.core.CIWavefunction, arg0: int)  psi4.core.Matrix; docstring. mcscf_object(self: psi4.core.CIWavefunction)  psi4.core.SOMCSCF; docstring. ndet(self: psi4.core.CIWavefunction)  int; docstring. new_civector(self: psi4.core.CIWavefunction, arg0: int, arg1: int, arg2: bool, arg3: bool)  psi4.core.CIVector; docstring. opdm(self: psi4.core.CIWavefunction, arg0: psi4.core.CIVector, arg1: psi4.core.CIVector, arg2: int, arg3: int)  list[psi4.core.Matrix]; docstring. pitzer_to_ci_order_onel(self: psi4.core.CIWavefunction, arg0: psi4.core.Matrix, arg1: psi4.core.Vector)  None; docstri",MatchSource.WIKI,psi4manual/master/api/psi4.core.CIWavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.CIWavefunction.html
https://psicode.org/psi4manual/master/api/psi4.core.clean.html:450,Deployability,update,updated,450,". clean. Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; clean. clean. psi4.core.clean()  None; Remove scratch files. Call between independent jobs. table of contents. clean; clean(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; clean.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/api/psi4.core.clean.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.clean.html
https://psicode.org/psi4manual/master/api/psi4.core.clean_options.html:483,Deployability,update,updated,483,". clean_options. Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; clean_options. clean_options. psi4.core.clean_options()  None; Reset options to clean state. table of contents. clean_options; clean_options(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; clean_options.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/api/psi4.core.clean_options.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.clean_options.html
https://psicode.org/psi4manual/master/api/psi4.core.clean_timers.html:558,Deployability,update,updated,558,". clean_timers. Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; clean_timers. clean_timers. psi4.core.clean_timers()  None; Reinitialize timers for independent timer.dat entries. Vital when earlier independent calc finished improperly. table of contents. clean_timers; clean_timers(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; clean_timers.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/api/psi4.core.clean_timers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.clean_timers.html
https://psicode.org/psi4manual/master/api/psi4.core.clean_variables.html:546,Deployability,update,updated,546,". clean_variables. Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; clean_variables. clean_variables. psi4.core.clean_variables()  None; Empties all double and Matrix QCVariables that have been set in global memory. table of contents. clean_variables; clean_variables(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; clean_variables.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/api/psi4.core.clean_variables.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.clean_variables.html
https://psicode.org/psi4manual/master/api/psi4.core.close_outfile.html:477,Deployability,update,updated,477,". close_outfile. Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; close_outfile. close_outfile. psi4.core.close_outfile()  None; Closes the output file. table of contents. close_outfile; close_outfile(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; close_outfile.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/api/psi4.core.close_outfile.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.close_outfile.html
https://psicode.org/psi4manual/master/api/psi4.core.CompositeJK.html:1532,Deployability,update,updated,1532,". CompositeJK. Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; CompositeJK. CompositeJK. class psi4.core.CompositeJK; Bases: JK; docstring; Methods Summary. clear_D_prev(self); Clear previous D matrices. do_incfock_iter(self); Was the last Fock build incremental?. get_COSX_grid(self); Return grid used for COSX for this SCF iteration. get_snLinK_max_am(self); Return maximum AM supported by current GauXC instance, if GauXC support is enabled. set_COSX_grid(self,arg0); Set grid to use for COSX for this SCF iteration. Methods Documentation. clear_D_prev(self: psi4.core.CompositeJK)  None; Clear previous D matrices. do_incfock_iter(self: psi4.core.CompositeJK)  bool; Was the last Fock build incremental?. get_COSX_grid(self: psi4.core.CompositeJK)  str; Return grid used for COSX for this SCF iteration. get_snLinK_max_am(self: psi4.core.CompositeJK)  int; Return maximum AM supported by current GauXC instance, if GauXC support is enabled. set_COSX_grid(self: psi4.core.CompositeJK, arg0: str)  None; Set grid to use for COSX for this SCF iteration. table of contents. CompositeJK; CompositeJK; CompositeJK.clear_D_prev(); CompositeJK.do_incfock_iter(); CompositeJK.get_COSX_grid(); CompositeJK.get_snLinK_max_am(); CompositeJK.set_COSX_grid(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; CompositeJK.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/api/psi4.core.CompositeJK.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.CompositeJK.html
https://psicode.org/psi4manual/master/api/psi4.core.CompositeJK.html:243,Usability,Clear,Clear,243,". CompositeJK. Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; CompositeJK. CompositeJK. class psi4.core.CompositeJK; Bases: JK; docstring; Methods Summary. clear_D_prev(self); Clear previous D matrices. do_incfock_iter(self); Was the last Fock build incremental?. get_COSX_grid(self); Return grid used for COSX for this SCF iteration. get_snLinK_max_am(self); Return maximum AM supported by current GauXC instance, if GauXC support is enabled. set_COSX_grid(self,arg0); Set grid to use for COSX for this SCF iteration. Methods Documentation. clear_D_prev(self: psi4.core.CompositeJK)  None; Clear previous D matrices. do_incfock_iter(self: psi4.core.CompositeJK)  bool; Was the last Fock build incremental?. get_COSX_grid(self: psi4.core.CompositeJK)  str; Return grid used for COSX for this SCF iteration. get_snLinK_max_am(self: psi4.core.CompositeJK)  int; Return maximum AM supported by current GauXC instance, if GauXC support is enabled. set_COSX_grid(self: psi4.core.CompositeJK, arg0: str)  None; Set grid to use for COSX for this SCF iteration. table of contents. CompositeJK; CompositeJK; CompositeJK.clear_D_prev(); CompositeJK.do_incfock_iter(); CompositeJK.get_COSX_grid(); CompositeJK.get_snLinK_max_am(); CompositeJK.set_COSX_grid(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; CompositeJK.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/api/psi4.core.CompositeJK.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.CompositeJK.html
https://psicode.org/psi4manual/master/api/psi4.core.CompositeJK.html:661,Usability,Clear,Clear,661,". CompositeJK. Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; CompositeJK. CompositeJK. class psi4.core.CompositeJK; Bases: JK; docstring; Methods Summary. clear_D_prev(self); Clear previous D matrices. do_incfock_iter(self); Was the last Fock build incremental?. get_COSX_grid(self); Return grid used for COSX for this SCF iteration. get_snLinK_max_am(self); Return maximum AM supported by current GauXC instance, if GauXC support is enabled. set_COSX_grid(self,arg0); Set grid to use for COSX for this SCF iteration. Methods Documentation. clear_D_prev(self: psi4.core.CompositeJK)  None; Clear previous D matrices. do_incfock_iter(self: psi4.core.CompositeJK)  bool; Was the last Fock build incremental?. get_COSX_grid(self: psi4.core.CompositeJK)  str; Return grid used for COSX for this SCF iteration. get_snLinK_max_am(self: psi4.core.CompositeJK)  int; Return maximum AM supported by current GauXC instance, if GauXC support is enabled. set_COSX_grid(self: psi4.core.CompositeJK, arg0: str)  None; Set grid to use for COSX for this SCF iteration. table of contents. CompositeJK; CompositeJK; CompositeJK.clear_D_prev(); CompositeJK.do_incfock_iter(); CompositeJK.get_COSX_grid(); CompositeJK.get_snLinK_max_am(); CompositeJK.set_COSX_grid(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; CompositeJK.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/api/psi4.core.CompositeJK.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.CompositeJK.html
https://psicode.org/psi4manual/master/api/psi4.core.CorrelationFactor.html:786,Deployability,update,updated,786,". CorrelationFactor. Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; CorrelationFactor. CorrelationFactor. class psi4.core.CorrelationFactor; Bases: pybind11_object; docstring; Methods Summary. set_params(self,coeff,exponent); Set coefficient and exponent. Methods Documentation. set_params(self: psi4.core.CorrelationFactor, coeff: psi4.core.Vector, exponent: psi4.core.Vector)  None; Set coefficient and exponent. table of contents. CorrelationFactor; CorrelationFactor; CorrelationFactor.set_params(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; CorrelationFactor.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/api/psi4.core.CorrelationFactor.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.CorrelationFactor.html
https://psicode.org/psi4manual/master/api/psi4.core.CorrelationTable.html:2134,Deployability,update,updated,2134,"bind11_object; Provides a correlation table between two point groups; Methods Summary. degen(self,arg0); Returns the degenercy of the irrep. group(*args,**kwargs); Overloaded function. n(self); Returns the number of irreps in high order group. ngamma(self,arg0); Returns the number of irreps in the low order group that an irrep from the high order group can be reduced to. subdegen(self,arg0); Returns the degeneracy of the subgroup irrep. subgroup(self); Returns lower order pointgroup. subn(self); Returns number of irreps in subgroup. Methods Documentation. degen(self: psi4.core.CorrelationTable, arg0: int)  int; Returns the degenercy of the irrep. group(*args, **kwargs); Overloaded function. group(self: psi4.core.CorrelationTable) -> psi4.core.PointGroup. Returns higher order point group. group(self: psi4.core.CorrelationTable, arg0: int, arg1: int) -> int. Returns the higher order point group. n(self: psi4.core.CorrelationTable)  int; Returns the number of irreps in high order group. ngamma(self: psi4.core.CorrelationTable, arg0: int)  int; Returns the number of irreps in the low order group that an irrep from the high order group can be reduced to. subdegen(self: psi4.core.CorrelationTable, arg0: int)  int; Returns the degeneracy of the subgroup irrep. subgroup(self: psi4.core.CorrelationTable)  psi4.core.PointGroup; Returns lower order pointgroup. subn(self: psi4.core.CorrelationTable)  int; Returns number of irreps in subgroup. table of contents. CorrelationTable; CorrelationTable; CorrelationTable.degen(); CorrelationTable.group(); CorrelationTable.n(); CorrelationTable.ngamma(); CorrelationTable.subdegen(); CorrelationTable.subgroup(); CorrelationTable.subn(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; CorrelationTable.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/api/psi4.core.CorrelationTable.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.CorrelationTable.html
https://psicode.org/psi4manual/master/api/psi4.core.CorrelationTable.html:578,Energy Efficiency,reduce,reduced,578,". CorrelationTable. Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; CorrelationTable. CorrelationTable. class psi4.core.CorrelationTable; Bases: pybind11_object; Provides a correlation table between two point groups; Methods Summary. degen(self,arg0); Returns the degenercy of the irrep. group(*args,**kwargs); Overloaded function. n(self); Returns the number of irreps in high order group. ngamma(self,arg0); Returns the number of irreps in the low order group that an irrep from the high order group can be reduced to. subdegen(self,arg0); Returns the degeneracy of the subgroup irrep. subgroup(self); Returns lower order pointgroup. subn(self); Returns number of irreps in subgroup. Methods Documentation. degen(self: psi4.core.CorrelationTable, arg0: int)  int; Returns the degenercy of the irrep. group(*args, **kwargs); Overloaded function. group(self: psi4.core.CorrelationTable) -> psi4.core.PointGroup. Returns higher order point group. group(self: psi4.core.CorrelationTable, arg0: int, arg1: int) -> int. Returns the higher order point group. n(self: psi4.core.CorrelationTable)  int; Returns the number of irreps in high order group. ngamma(self: psi4.core.CorrelationTable, arg0: int)  int; Returns the number of irreps in the low order group that an irrep from the high order group can be reduced to. subdegen(self: psi4.core.CorrelationTable, arg0: int)  int; Returns the degeneracy of the subgroup irrep. subgroup(self: psi4.core.CorrelationTable)  psi4.core.PointGroup; Returns lower order pointgroup. subn(self: psi4.core.CorrelationTable)  int; Returns number of irreps in subgroup. table of contents. CorrelationTable; CorrelationTable; CorrelationTable.degen(); CorrelationTable.group(); CorrelationTable.n(); CorrelationTable.ngamma(); CorrelationTable.subdegen(); CorrelationTable.subgroup(); CorrelationTable.subn(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  . ",MatchSource.WIKI,psi4manual/master/api/psi4.core.CorrelationTable.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.CorrelationTable.html
https://psicode.org/psi4manual/master/api/psi4.core.CorrelationTable.html:1380,Energy Efficiency,reduce,reduced,1380,"bind11_object; Provides a correlation table between two point groups; Methods Summary. degen(self,arg0); Returns the degenercy of the irrep. group(*args,**kwargs); Overloaded function. n(self); Returns the number of irreps in high order group. ngamma(self,arg0); Returns the number of irreps in the low order group that an irrep from the high order group can be reduced to. subdegen(self,arg0); Returns the degeneracy of the subgroup irrep. subgroup(self); Returns lower order pointgroup. subn(self); Returns number of irreps in subgroup. Methods Documentation. degen(self: psi4.core.CorrelationTable, arg0: int)  int; Returns the degenercy of the irrep. group(*args, **kwargs); Overloaded function. group(self: psi4.core.CorrelationTable) -> psi4.core.PointGroup. Returns higher order point group. group(self: psi4.core.CorrelationTable, arg0: int, arg1: int) -> int. Returns the higher order point group. n(self: psi4.core.CorrelationTable)  int; Returns the number of irreps in high order group. ngamma(self: psi4.core.CorrelationTable, arg0: int)  int; Returns the number of irreps in the low order group that an irrep from the high order group can be reduced to. subdegen(self: psi4.core.CorrelationTable, arg0: int)  int; Returns the degeneracy of the subgroup irrep. subgroup(self: psi4.core.CorrelationTable)  psi4.core.PointGroup; Returns lower order pointgroup. subn(self: psi4.core.CorrelationTable)  int; Returns number of irreps in subgroup. table of contents. CorrelationTable; CorrelationTable; CorrelationTable.degen(); CorrelationTable.group(); CorrelationTable.n(); CorrelationTable.ngamma(); CorrelationTable.subdegen(); CorrelationTable.subgroup(); CorrelationTable.subn(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; CorrelationTable.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/api/psi4.core.CorrelationTable.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.CorrelationTable.html
https://psicode.org/psi4manual/master/api/psi4.core.CubeProperties.html:1807,Deployability,update,updated,1807,". CubeProperties. Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; CubeProperties. CubeProperties. class psi4.core.CubeProperties; Bases: pybind11_object; docstring; Methods Summary. basisset(self); Returns orbital/primary basis set associated with cubeprop. compute_density(self,D,key); Compute and dump a cube file for a density matrix. compute_orbitals(self,C,indices,labels,key); Compute and dump a cube file for a set of orbitals. compute_properties(); Filesystem wrapper for CubeProperties::raw_compute_properties. raw_compute_properties(self); Compute all relevant properties from options object specifications. Methods Documentation. basisset(self: psi4.core.CubeProperties)  psi4.core.BasisSet; Returns orbital/primary basis set associated with cubeprop. compute_density(self: psi4.core.CubeProperties, D: psi4.core.Matrix, key: str)  None; Compute and dump a cube file for a density matrix. compute_orbitals(self: psi4.core.CubeProperties, C: psi4.core.Matrix, indices: list[int], labels: list[str], key: str)  None; Compute and dump a cube file for a set of orbitals. compute_properties(); Filesystem wrapper for CubeProperties::raw_compute_properties. raw_compute_properties(self: psi4.core.CubeProperties)  None; Compute all relevant properties from options object specifications. table of contents. CubeProperties; CubeProperties; CubeProperties.basisset(); CubeProperties.compute_density(); CubeProperties.compute_orbitals(); CubeProperties.compute_properties(); CubeProperties.raw_compute_properties(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; CubeProperties.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/api/psi4.core.CubeProperties.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.CubeProperties.html
https://psicode.org/psi4manual/master/api/psi4.core.CubeProperties.html:540,Integrability,wrap,wrapper,540,". CubeProperties. Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; CubeProperties. CubeProperties. class psi4.core.CubeProperties; Bases: pybind11_object; docstring; Methods Summary. basisset(self); Returns orbital/primary basis set associated with cubeprop. compute_density(self,D,key); Compute and dump a cube file for a density matrix. compute_orbitals(self,C,indices,labels,key); Compute and dump a cube file for a set of orbitals. compute_properties(); Filesystem wrapper for CubeProperties::raw_compute_properties. raw_compute_properties(self); Compute all relevant properties from options object specifications. Methods Documentation. basisset(self: psi4.core.CubeProperties)  psi4.core.BasisSet; Returns orbital/primary basis set associated with cubeprop. compute_density(self: psi4.core.CubeProperties, D: psi4.core.Matrix, key: str)  None; Compute and dump a cube file for a density matrix. compute_orbitals(self: psi4.core.CubeProperties, C: psi4.core.Matrix, indices: list[int], labels: list[str], key: str)  None; Compute and dump a cube file for a set of orbitals. compute_properties(); Filesystem wrapper for CubeProperties::raw_compute_properties. raw_compute_properties(self: psi4.core.CubeProperties)  None; Compute all relevant properties from options object specifications. table of contents. CubeProperties; CubeProperties; CubeProperties.basisset(); CubeProperties.compute_density(); CubeProperties.compute_orbitals(); CubeProperties.compute_properties(); CubeProperties.raw_compute_properties(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; CubeProperties.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/api/psi4.core.CubeProperties.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.CubeProperties.html
https://psicode.org/psi4manual/master/api/psi4.core.CubeProperties.html:1190,Integrability,wrap,wrapper,1190,". CubeProperties. Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; CubeProperties. CubeProperties. class psi4.core.CubeProperties; Bases: pybind11_object; docstring; Methods Summary. basisset(self); Returns orbital/primary basis set associated with cubeprop. compute_density(self,D,key); Compute and dump a cube file for a density matrix. compute_orbitals(self,C,indices,labels,key); Compute and dump a cube file for a set of orbitals. compute_properties(); Filesystem wrapper for CubeProperties::raw_compute_properties. raw_compute_properties(self); Compute all relevant properties from options object specifications. Methods Documentation. basisset(self: psi4.core.CubeProperties)  psi4.core.BasisSet; Returns orbital/primary basis set associated with cubeprop. compute_density(self: psi4.core.CubeProperties, D: psi4.core.Matrix, key: str)  None; Compute and dump a cube file for a density matrix. compute_orbitals(self: psi4.core.CubeProperties, C: psi4.core.Matrix, indices: list[int], labels: list[str], key: str)  None; Compute and dump a cube file for a set of orbitals. compute_properties(); Filesystem wrapper for CubeProperties::raw_compute_properties. raw_compute_properties(self: psi4.core.CubeProperties)  None; Compute all relevant properties from options object specifications. table of contents. CubeProperties; CubeProperties; CubeProperties.basisset(); CubeProperties.compute_density(); CubeProperties.compute_orbitals(); CubeProperties.compute_properties(); CubeProperties.raw_compute_properties(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; CubeProperties.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/api/psi4.core.CubeProperties.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.CubeProperties.html
https://psicode.org/psi4manual/master/api/psi4.core.CUHF.html:1280,Deployability,update,updated,1280,". CUHF. Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; CUHF. CUHF. class psi4.core.CUHF; Bases: HF; docstring; Methods Summary. c1_deep_copy(self,basis); Returns a new wavefunction with internal data converted to C_1 symmetry, using pre-c1-constructed BasisSet basis. compute_orbital_gradient(save_fock,...); docstring. diis(self,arg0); docstring. mintshelper(self); The MintsHelper object. Methods Documentation. c1_deep_copy(self: psi4.core.CUHF, basis: psi4.core.BasisSet)  psi4.core.CUHF; Returns a new wavefunction with internal data converted to C_1 symmetry, using pre-c1-constructed BasisSet basis. compute_orbital_gradient(save_fock, max_diis_vectors); docstring. Return type:; float. Parameters:. save_fock (bool); max_diis_vectors (int). diis(self: psi4.core.HF, arg0: float)  bool; docstring. mintshelper(self: psi4.core.CUHF)  psi4.core.MintsHelper; The MintsHelper object. table of contents. CUHF; CUHF; CUHF.c1_deep_copy(); CUHF.compute_orbital_gradient(); CUHF.diis(); CUHF.mintshelper(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; CUHF.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/api/psi4.core.CUHF.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.CUHF.html
https://psicode.org/psi4manual/master/api/psi4.core.DASUM.html:459,Deployability,update,updated,459,". DASUM. Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; DASUM. DASUM. psi4.core.DASUM(arg0: int, arg1: int, arg2: psi::Vector, arg3: int)  float; docstring. table of contents. DASUM; DASUM(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; DASUM.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/api/psi4.core.DASUM.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.DASUM.html
https://psicode.org/psi4manual/master/api/psi4.core.DAXPY.html:501,Deployability,update,updated,501,". DAXPY. Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; DAXPY. DAXPY. psi4.core.DAXPY(arg0: int, arg1: int, arg2: float, arg3: psi::Vector, arg4: int, arg5: psi::Vector, arg6: int)  None; docstring. table of contents. DAXPY; DAXPY(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; DAXPY.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/api/psi4.core.DAXPY.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.DAXPY.html
https://psicode.org/psi4manual/master/api/psi4.core.DCOPY.html:488,Deployability,update,updated,488,". DCOPY. Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; DCOPY. DCOPY. psi4.core.DCOPY(arg0: int, arg1: int, arg2: psi::Vector, arg3: int, arg4: psi::Vector, arg5: int)  None; docstring. table of contents. DCOPY; DCOPY(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; DCOPY.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/api/psi4.core.DCOPY.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.DCOPY.html
https://psicode.org/psi4manual/master/api/psi4.core.dct.html:484,Deployability,update,updated,484,". dct. Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; dct. dct. psi4.core.dct(ref_wfn: psi4.core.Wavefunction)  psi4.core.Wavefunction; Runs the density cumulant (functional) theory code. table of contents. dct; dct(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; dct.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/api/psi4.core.dct.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.dct.html
https://psicode.org/psi4manual/master/api/psi4.core.DDOT.html:482,Deployability,update,updated,482,". DDOT. Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; DDOT. DDOT. psi4.core.DDOT(arg0: int, arg1: int, arg2: psi::Vector, arg3: int, arg4: psi::Vector, arg5: int)  float; docstring. table of contents. DDOT; DDOT(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; DDOT.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/api/psi4.core.DDOT.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.DDOT.html
https://psicode.org/psi4manual/master/api/psi4.core.del_array_variable.html:573,Deployability,update,updated,573,". del_array_variable. Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; del_array_variable. del_array_variable. psi4.core.del_array_variable(key: str)  None; Removes the Matrix QCVariable key (case-insensitive); prefer del_variable(). table of contents. del_array_variable; del_array_variable(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; del_array_variable.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/api/psi4.core.del_array_variable.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.del_array_variable.html
https://psicode.org/psi4manual/master/api/psi4.core.del_scalar_variable.html:580,Deployability,update,updated,580,". del_scalar_variable. Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; del_scalar_variable. del_scalar_variable. psi4.core.del_scalar_variable(key: str)  None; Removes the double QCVariable key (case-insensitive); prefer del_variable(). table of contents. del_scalar_variable; del_scalar_variable(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; del_scalar_variable.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/api/psi4.core.del_scalar_variable.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.del_scalar_variable.html
https://psicode.org/psi4manual/master/api/psi4.core.del_variable.html:620,Deployability,update,updated,620,". del_variable. Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; del_variable. del_variable. psi4.core.del_variable(key); Removes scalar or array QCVariable key from global memory if present. Parameters:; key (str)  Case-insensitive key to global double or Matrix; storage maps. Return type:; None. table of contents. del_variable; del_variable(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; del_variable.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/api/psi4.core.del_variable.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.del_variable.html
https://psicode.org/psi4manual/master/api/psi4.core.Deriv.html:1712,Deployability,update,updated,1712,". Deriv. Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; Deriv. Deriv. class psi4.core.Deriv; Bases: pybind11_object; Computes gradients of wavefunctions; Methods Summary. compute(self,deriv_calc_type); Compute the gradient. compute_df(self,arg0,arg1); Compute the density-fitted gradient. set_deriv_density_backtransformed(self[,val]); Is the deriv_density already backtransformed? Default is False. set_ignore_reference(self[,val]); Ignore reference contributions to the gradient? Default is False. set_tpdm_presorted(self[,val]); Is the TPDM already presorted? Default is False. Methods Documentation. compute(self: psi4.core.Deriv, deriv_calc_type: psi4.core.DerivCalcType = <DerivCalcType.Default: 0>)  psi4.core.Matrix; Compute the gradient. compute_df(self: psi4.core.Deriv, arg0: str, arg1: str)  psi4.core.Matrix; Compute the density-fitted gradient. set_deriv_density_backtransformed(self: psi4.core.Deriv, val: bool = False)  None; Is the deriv_density already backtransformed? Default is False. set_ignore_reference(self: psi4.core.Deriv, val: bool = False)  None; Ignore reference contributions to the gradient? Default is False. set_tpdm_presorted(self: psi4.core.Deriv, val: bool = False)  None; Is the TPDM already presorted? Default is False. table of contents. Deriv; Deriv; Deriv.compute(); Deriv.compute_df(); Deriv.set_deriv_density_backtransformed(); Deriv.set_ignore_reference(); Deriv.set_tpdm_presorted(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; Deriv.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/api/psi4.core.Deriv.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.Deriv.html
https://psicode.org/psi4manual/master/api/psi4.core.DerivCalcType.html:855,Deployability,update,updated,855,". DerivCalcType. Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; DerivCalcType. DerivCalcType. class psi4.core.DerivCalcType; Bases: pybind11_object; Members:; Default : Use internal logic.; Correlated : Correlated methods that write RDMs and Lagrangian to disk.; Attributes Summary. Correlated. Default. name. value. Attributes Documentation. Correlated = <DerivCalcType.Correlated: 1>. Default = <DerivCalcType.Default: 0>. name. value. table of contents. DerivCalcType; DerivCalcType; DerivCalcType.Correlated; DerivCalcType.Default; DerivCalcType.name; DerivCalcType.value. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; DerivCalcType.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/api/psi4.core.DerivCalcType.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.DerivCalcType.html
https://psicode.org/psi4manual/master/api/psi4.core.DerivCalcType.html:249,Testability,log,logic,249,". DerivCalcType. Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; DerivCalcType. DerivCalcType. class psi4.core.DerivCalcType; Bases: pybind11_object; Members:; Default : Use internal logic.; Correlated : Correlated methods that write RDMs and Lagrangian to disk.; Attributes Summary. Correlated. Default. name. value. Attributes Documentation. Correlated = <DerivCalcType.Correlated: 1>. Default = <DerivCalcType.Default: 0>. name. value. table of contents. DerivCalcType; DerivCalcType; DerivCalcType.Correlated; DerivCalcType.Default; DerivCalcType.name; DerivCalcType.value. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; DerivCalcType.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/api/psi4.core.DerivCalcType.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.DerivCalcType.html
https://psicode.org/psi4manual/master/api/psi4.core.detci.html:239,Deployability,configurat,configuration,239,". detci. Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; detci. detci. psi4.core.detci(ref_wfn: psi4.core.Wavefunction)  psi4.core.Wavefunction; Runs the determinant-based configuration interaction code. table of contents. detci; detci(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; detci.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/api/psi4.core.detci.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.detci.html
https://psicode.org/psi4manual/master/api/psi4.core.detci.html:505,Deployability,update,updated,505,". detci. Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; detci. detci. psi4.core.detci(ref_wfn: psi4.core.Wavefunction)  psi4.core.Wavefunction; Runs the determinant-based configuration interaction code. table of contents. detci; detci(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; detci.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/api/psi4.core.detci.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.detci.html
https://psicode.org/psi4manual/master/api/psi4.core.detci.html:239,Modifiability,config,configuration,239,". detci. Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; detci. detci. psi4.core.detci(ref_wfn: psi4.core.Wavefunction)  psi4.core.Wavefunction; Runs the determinant-based configuration interaction code. table of contents. detci; detci(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; detci.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/api/psi4.core.detci.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.detci.html
https://psicode.org/psi4manual/master/api/psi4.core.DFEP2Wavefunction.html:880,Deployability,update,updated,880,". DFEP2Wavefunction. Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; DFEP2Wavefunction. DFEP2Wavefunction. class psi4.core.DFEP2Wavefunction; Bases: Wavefunction; A density-fitted second-order Electron Propagator Wavefunction.; Methods Summary. compute(self,arg0); Computes the density-fitted EP2 energy for the input orbitals. Methods Documentation. compute(self: psi4.core.DFEP2Wavefunction, arg0: list[list[int]])  list[list[tuple[float, float]]]; Computes the density-fitted EP2 energy for the input orbitals. table of contents. DFEP2Wavefunction; DFEP2Wavefunction; DFEP2Wavefunction.compute(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; DFEP2Wavefunction.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/api/psi4.core.DFEP2Wavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.DFEP2Wavefunction.html
https://psicode.org/psi4manual/master/api/psi4.core.DFEP2Wavefunction.html:364,Energy Efficiency,energy,energy,364,". DFEP2Wavefunction. Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; DFEP2Wavefunction. DFEP2Wavefunction. class psi4.core.DFEP2Wavefunction; Bases: Wavefunction; A density-fitted second-order Electron Propagator Wavefunction.; Methods Summary. compute(self,arg0); Computes the density-fitted EP2 energy for the input orbitals. Methods Documentation. compute(self: psi4.core.DFEP2Wavefunction, arg0: list[list[int]])  list[list[tuple[float, float]]]; Computes the density-fitted EP2 energy for the input orbitals. table of contents. DFEP2Wavefunction; DFEP2Wavefunction; DFEP2Wavefunction.compute(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; DFEP2Wavefunction.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/api/psi4.core.DFEP2Wavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.DFEP2Wavefunction.html
https://psicode.org/psi4manual/master/api/psi4.core.DFEP2Wavefunction.html:552,Energy Efficiency,energy,energy,552,". DFEP2Wavefunction. Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; DFEP2Wavefunction. DFEP2Wavefunction. class psi4.core.DFEP2Wavefunction; Bases: Wavefunction; A density-fitted second-order Electron Propagator Wavefunction.; Methods Summary. compute(self,arg0); Computes the density-fitted EP2 energy for the input orbitals. Methods Documentation. compute(self: psi4.core.DFEP2Wavefunction, arg0: list[list[int]])  list[list[tuple[float, float]]]; Computes the density-fitted EP2 energy for the input orbitals. table of contents. DFEP2Wavefunction; DFEP2Wavefunction; DFEP2Wavefunction.compute(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; DFEP2Wavefunction.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/api/psi4.core.DFEP2Wavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.DFEP2Wavefunction.html
https://psicode.org/psi4manual/master/api/psi4.core.DFHelper.html:3491,Deployability,update,updated,3491,"ed function. get_tensor(self: psi4.core.DFHelper, arg0: str) -> psi4.core.Matrix; get_tensor(self: psi4.core.DFHelper, arg0: str, arg1: list[int], arg2: list[int], arg3: list[int]) -> psi4.core.Matrix. get_tensor_shape(self: psi4.core.DFHelper, arg0: str)  tuple[int, int, int]. get_tensor_size(self: psi4.core.DFHelper, arg0: str)  int. hold_met(self: psi4.core.DFHelper, arg0: bool)  None. initialize(self: psi4.core.DFHelper)  None. print_header(self: psi4.core.DFHelper)  None. set_AO_core(self: psi4.core.DFHelper, arg0: bool)  None. set_MO_core(self: psi4.core.DFHelper, arg0: bool)  None. set_memory(self: psi4.core.DFHelper, arg0: int)  None. set_method(self: psi4.core.DFHelper, arg0: str)  None. set_nthreads(self: psi4.core.DFHelper, arg0: int)  None. set_schwarz_cutoff(self: psi4.core.DFHelper, arg0: float)  None. set_subalgo(self: psi4.core.DFHelper, arg0: str)  None. transform(self: psi4.core.DFHelper)  None. transpose(self: psi4.core.DFHelper, arg0: str, arg1: tuple[int, int, int])  None. table of contents. DFHelper; DFHelper; DFHelper.add_space(); DFHelper.add_transformation(); DFHelper.clear_all(); DFHelper.clear_spaces(); DFHelper.get_AO_core(); DFHelper.get_AO_size(); DFHelper.get_MO_core(); DFHelper.get_memory(); DFHelper.get_method(); DFHelper.get_schwarz_cutoff(); DFHelper.get_space_size(); DFHelper.get_tensor(); DFHelper.get_tensor_shape(); DFHelper.get_tensor_size(); DFHelper.hold_met(); DFHelper.initialize(); DFHelper.print_header(); DFHelper.set_AO_core(); DFHelper.set_MO_core(); DFHelper.set_memory(); DFHelper.set_method(); DFHelper.set_nthreads(); DFHelper.set_schwarz_cutoff(); DFHelper.set_subalgo(); DFHelper.transform(); DFHelper.transpose(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; DFHelper.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/api/psi4.core.DFHelper.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.DFHelper.html
https://psicode.org/psi4manual/master/api/psi4.core.dfmp2.html:468,Deployability,update,updated,468,". dfmp2. Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; dfmp2. dfmp2. psi4.core.dfmp2(ref_wfn: psi4.core.Wavefunction)  psi4.core.Wavefunction; Runs the DF-MP2 code. table of contents. dfmp2; dfmp2(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; dfmp2.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/api/psi4.core.dfmp2.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.dfmp2.html
https://psicode.org/psi4manual/master/api/psi4.core.dfocc.html:498,Deployability,update,updated,498,". dfocc. Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; dfocc. dfocc. psi4.core.dfocc(ref_wfn: psi4.core.Wavefunction)  psi4.core.Wavefunction; Runs the density-fitted orbital optimized CC codes. table of contents. dfocc; dfocc(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; dfocc.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/api/psi4.core.dfocc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.dfocc.html
https://psicode.org/psi4manual/master/api/psi4.core.dfocc.html:244,Performance,optimiz,optimized,244,". dfocc. Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; dfocc. dfocc. psi4.core.dfocc(ref_wfn: psi4.core.Wavefunction)  psi4.core.Wavefunction; Runs the density-fitted orbital optimized CC codes. table of contents. dfocc; dfocc(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; dfocc.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/api/psi4.core.dfocc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.dfocc.html
https://psicode.org/psi4manual/master/api/psi4.core.DFSOMCSCF.html:447,Deployability,update,updated,447,". DFSOMCSCF. Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; DFSOMCSCF. DFSOMCSCF. class psi4.core.DFSOMCSCF; Bases: SOMCSCF; docstring. table of contents. DFSOMCSCF; DFSOMCSCF. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; DFSOMCSCF.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/api/psi4.core.DFSOMCSCF.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.DFSOMCSCF.html
https://psicode.org/psi4manual/master/api/psi4.core.DFTensor.html:1194,Deployability,update,updated,1194,". DFTensor. Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; DFTensor. DFTensor. class psi4.core.DFTensor; Bases: pybind11_object; docstring; Methods Summary. Idfmo(self); doctsring. Imo(self); doctsring. Qmo(self); doctsring. Qoo(self); doctsring. Qov(self); doctsring. Qso(self); doctsring. Qvv(self); doctsring. Methods Documentation. Idfmo(self: psi4.core.DFTensor)  psi4.core.Matrix; doctsring. Imo(self: psi4.core.DFTensor)  psi4.core.Matrix; doctsring. Qmo(self: psi4.core.DFTensor)  psi4.core.Matrix; doctsring. Qoo(self: psi4.core.DFTensor)  psi4.core.Matrix; doctsring. Qov(self: psi4.core.DFTensor)  psi4.core.Matrix; doctsring. Qso(self: psi4.core.DFTensor)  psi4.core.Matrix; doctsring. Qvv(self: psi4.core.DFTensor)  psi4.core.Matrix; doctsring. table of contents. DFTensor; DFTensor; DFTensor.Idfmo(); DFTensor.Imo(); DFTensor.Qmo(); DFTensor.Qoo(); DFTensor.Qov(); DFTensor.Qso(); DFTensor.Qvv(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; DFTensor.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/api/psi4.core.DFTensor.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.DFTensor.html
https://psicode.org/psi4manual/master/api/psi4.core.DFTGrid.html:798,Deployability,update,updated,798,". DFTGrid. Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; DFTGrid. DFTGrid. class psi4.core.DFTGrid; Bases: MolecularGrid; docstring; Methods Summary. build(*args,**kwargs); Overloaded function. Methods Documentation. static build(*args, **kwargs); Overloaded function. build(arg0: psi4.core.Molecule, arg1: psi4.core.BasisSet) -> psi4.core.DFTGrid; build(arg0: psi4.core.Molecule, arg1: psi4.core.BasisSet, arg2: dict[str, int], arg3: dict[str, str]) -> psi4.core.DFTGrid. table of contents. DFTGrid; DFTGrid; DFTGrid.build(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; DFTGrid.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/api/psi4.core.DFTGrid.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.DFTGrid.html
https://psicode.org/psi4manual/master/api/psi4.core.DGBMV.html:592,Deployability,update,updated,592,". DGBMV. Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; DGBMV. DGBMV. psi4.core.DGBMV(arg0: int, arg1: str, arg2: int, arg3: int, arg4: int, arg5: int, arg6: float, arg7: psi::Matrix, arg8: int, arg9: psi::Vector, arg10: int, arg11: float, arg12: psi::Vector, arg13: int)  None; docstring. table of contents. DGBMV; DGBMV(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; DGBMV.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/api/psi4.core.DGBMV.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.DGBMV.html
https://psicode.org/psi4manual/master/api/psi4.core.DGEEV.html:611,Deployability,update,updated,611,". DGEEV. Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; DGEEV. DGEEV. psi4.core.DGEEV(arg0: int, arg1: str, arg2: str, arg3: int, arg4: psi::Matrix, arg5: int, arg6: psi::Vector, arg7: psi::Vector, arg8: psi::Matrix, arg9: int, arg10: psi::Matrix, arg11: int, arg12: psi::Vector, arg13: int)  int; docstring. table of contents. DGEEV; DGEEV(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; DGEEV.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/api/psi4.core.DGEEV.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.DGEEV.html
https://psicode.org/psi4manual/master/api/psi4.core.DGEMM.html:592,Deployability,update,updated,592,". DGEMM. Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; DGEMM. DGEMM. psi4.core.DGEMM(arg0: int, arg1: str, arg2: str, arg3: int, arg4: int, arg5: int, arg6: float, arg7: psi::Matrix, arg8: int, arg9: psi::Matrix, arg10: int, arg11: float, arg12: psi::Matrix, arg13: int)  None; docstring. table of contents. DGEMM; DGEMM(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; DGEMM.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/api/psi4.core.DGEMM.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.DGEMM.html
https://psicode.org/psi4manual/master/api/psi4.core.DGEMV.html:568,Deployability,update,updated,568,". DGEMV. Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; DGEMV. DGEMV. psi4.core.DGEMV(arg0: int, arg1: str, arg2: int, arg3: int, arg4: float, arg5: psi::Matrix, arg6: int, arg7: psi::Vector, arg8: int, arg9: float, arg10: psi::Vector, arg11: int)  None; docstring. table of contents. DGEMV; DGEMV(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; DGEMV.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/api/psi4.core.DGEMV.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.DGEMV.html
https://psicode.org/psi4manual/master/api/psi4.core.DGER.html:535,Deployability,update,updated,535,". DGER. Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; DGER. DGER. psi4.core.DGER(arg0: int, arg1: int, arg2: int, arg3: float, arg4: psi::Vector, arg5: int, arg6: psi::Vector, arg7: int, arg8: psi::Matrix, arg9: int)  None; docstring. table of contents. DGER; DGER(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; DGER.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/api/psi4.core.DGER.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.DGER.html
https://psicode.org/psi4manual/master/api/psi4.core.DGETRF.html:497,Deployability,update,updated,497,". DGETRF. Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; DGETRF. DGETRF. psi4.core.DGETRF(arg0: int, arg1: int, arg2: int, arg3: psi::Matrix, arg4: int, arg5: psi::IntVector)  int; docstring. table of contents. DGETRF; DGETRF(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; DGETRF.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/api/psi4.core.DGETRF.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.DGETRF.html
https://psicode.org/psi4manual/master/api/psi4.core.DGETRI.html:516,Deployability,update,updated,516,". DGETRI. Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; DGETRI. DGETRI. psi4.core.DGETRI(arg0: int, arg1: int, arg2: psi::Matrix, arg3: int, arg4: psi::IntVector, arg5: psi::Vector, arg6: int)  int; docstring. table of contents. DGETRI; DGETRI(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; DGETRI.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/api/psi4.core.DGETRI.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.DGETRI.html
https://psicode.org/psi4manual/master/api/psi4.core.DGETRS.html:538,Deployability,update,updated,538,". DGETRS. Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; DGETRS. DGETRS. psi4.core.DGETRS(arg0: int, arg1: str, arg2: int, arg3: int, arg4: psi::Matrix, arg5: int, arg6: psi::IntVector, arg7: psi::Matrix, arg8: int)  int; docstring. table of contents. DGETRS; DGETRS(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; DGETRS.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/api/psi4.core.DGETRS.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.DGETRS.html
https://psicode.org/psi4manual/master/api/psi4.core.DiagonalizeOrder.html:876,Deployability,update,updated,876,". DiagonalizeOrder. Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; DiagonalizeOrder. DiagonalizeOrder. class psi4.core.DiagonalizeOrder; Bases: pybind11_object; Defines ordering of eigenvalues after diagonalization; Members:. Ascending; Descending. Attributes Summary. Ascending. Descending. name. value. Attributes Documentation. Ascending = <DiagonalizeOrder.Ascending: 1>. Descending = <DiagonalizeOrder.Descending: 3>. name. value. table of contents. DiagonalizeOrder; DiagonalizeOrder; DiagonalizeOrder.Ascending; DiagonalizeOrder.Descending; DiagonalizeOrder.name; DiagonalizeOrder.value. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; DiagonalizeOrder.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/api/psi4.core.DiagonalizeOrder.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.DiagonalizeOrder.html
https://psicode.org/psi4manual/master/api/psi4.core.Dimension.html:2715,Deployability,update,updated,2715,"tes Documentation. name; The name of the dimension. Used in printing. Methods Documentation. fill(self: psi4.core.Dimension, val: int)  None; Fill all elements with given value. classmethod from_list(dims, name='New Dimension'); Builds a Dimension object from a Python list or tuple. If a Dimension object is passed, a copy will be returned. Parameters:. dims (Union[Tuple[int], List[int], ndarray, Dimension])  Iterable of integers defining irrep dimensions.; name  Name for new instance. Return type:; Dimension. init(self: psi4.core.Dimension, arg0: int, arg1: str)  None; Re-initializes the dimension object. max(*args, **kwargs); Overloaded function. max(self: psi4.core.Dimension) -> int. Gets the maximum value from the dimension object. max(self: psi4.core.Dimension) -> int. Return the maximum element. n(self: psi4.core.Dimension)  int; The order of the dimension. print_out(self: psi4.core.Dimension)  None; Print out the dimension object to the output file. sum(*args, **kwargs); Overloaded function. sum(self: psi4.core.Dimension) -> int. Gets the sum of the values in the dimension object. sum(self: psi4.core.Dimension) -> int. Return the sum of constituent dimensions. to_tuple(); Serializes Dimension to a tuple. Return type:; Tuple[int]. Parameters:; self (Dimension). zero(*args, **kwargs); Overloaded function. zero(self: psi4.core.Dimension) -> None. Zeros all values in the dimension object. zero(self: psi4.core.Dimension) -> None. Zero all elements. table of contents. Dimension; Dimension; Dimension.name; Dimension.fill(); Dimension.from_list(); Dimension.init(); Dimension.max(); Dimension.n(); Dimension.print_out(); Dimension.sum(); Dimension.to_tuple(); Dimension.zero(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; Dimension.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/api/psi4.core.Dimension.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.Dimension.html
https://psicode.org/psi4manual/master/api/psi4.core.DipoleInt.html:468,Deployability,update,updated,468,". DipoleInt. Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; DipoleInt. DipoleInt. class psi4.core.DipoleInt; Bases: OneBodyAOInt; Computes dipole integrals. table of contents. DipoleInt; DipoleInt. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; DipoleInt.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/api/psi4.core.DipoleInt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.DipoleInt.html
https://psicode.org/psi4manual/master/api/psi4.core.DirectJK.html:653,Deployability,update,updated,653,". DirectJK. Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; DirectJK. DirectJK. class psi4.core.DirectJK; Bases: JK; docstring; Methods Summary. do_incfock_iter(self); Was the last Fock build incremental?. Methods Documentation. do_incfock_iter(self: psi4.core.DirectJK)  bool; Was the last Fock build incremental?. table of contents. DirectJK; DirectJK; DirectJK.do_incfock_iter(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; DirectJK.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/api/psi4.core.DirectJK.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.DirectJK.html
https://psicode.org/psi4manual/master/api/psi4.core.DiskSOMCSCF.html:461,Deployability,update,updated,461,". DiskSOMCSCF. Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; DiskSOMCSCF. DiskSOMCSCF. class psi4.core.DiskSOMCSCF; Bases: SOMCSCF; docstring. table of contents. DiskSOMCSCF; DiskSOMCSCF. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; DiskSOMCSCF.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/api/psi4.core.DiskSOMCSCF.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.DiskSOMCSCF.html
https://psicode.org/psi4manual/master/api/psi4.core.Dispersion.html:3523,Deployability,update,updated,3523,"e_gradient(self: psi4.core.Dispersion, arg0: psi4.core.Molecule)  psi4.core.Matrix; docstring. compute_hessian(self: psi4.core.Dispersion, arg0: psi4.core.Molecule)  psi4.core.Matrix; docstring. d(self: psi4.core.Dispersion)  float; docstring. description(self: psi4.core.Dispersion)  str; docstring. name(self: psi4.core.Dispersion)  str; docstring. print_energy(self: psi4.core.Dispersion, arg0: psi4.core.Molecule)  str; docstring. print_gradient(self: psi4.core.Dispersion, arg0: psi4.core.Molecule)  str; docstring. print_hessian(self: psi4.core.Dispersion, arg0: psi4.core.Molecule)  str; docstring. print_out(self: psi4.core.Dispersion)  None; docstring. s6(self: psi4.core.Dispersion)  float; docstring. s8(self: psi4.core.Dispersion)  float; docstring. set_bibtex(self: psi4.core.Dispersion, arg0: str)  None; Set the BibTeX key for the literature reference. set_citation(self: psi4.core.Dispersion, arg0: str)  None; docstring. set_description(self: psi4.core.Dispersion, arg0: str)  None; docstring. set_name(self: psi4.core.Dispersion, arg0: str)  None; docstring. sr6(self: psi4.core.Dispersion)  float; docstring. table of contents. Dispersion; Dispersion; Dispersion.a1(); Dispersion.a2(); Dispersion.bibtex(); Dispersion.build(); Dispersion.citation(); Dispersion.compute_energy(); Dispersion.compute_gradient(); Dispersion.compute_hessian(); Dispersion.d(); Dispersion.description(); Dispersion.name(); Dispersion.print_energy(); Dispersion.print_gradient(); Dispersion.print_hessian(); Dispersion.print_out(); Dispersion.s6(); Dispersion.s8(); Dispersion.set_bibtex(); Dispersion.set_citation(); Dispersion.set_description(); Dispersion.set_name(); Dispersion.sr6(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; Dispersion.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/api/psi4.core.Dispersion.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.Dispersion.html
https://psicode.org/psi4manual/master/api/psi4.core.dlpno.html:465,Deployability,update,updated,465,". dlpno. Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; dlpno. dlpno. psi4.core.dlpno(arg0: psi4.core.Wavefunction)  psi4.core.Wavefunction; Runs the DLPNO codes. table of contents. dlpno; dlpno(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; dlpno.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/api/psi4.core.dlpno.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.dlpno.html
https://psicode.org/psi4manual/master/api/psi4.core.dmrg.html:460,Deployability,update,updated,460,". dmrg. Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; dmrg. dmrg. psi4.core.dmrg(ref_wfn: psi4.core.Wavefunction)  float; Runs the CheMPS2 interface DMRG code. table of contents. dmrg; dmrg(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; dmrg.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/api/psi4.core.dmrg.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.dmrg.html
https://psicode.org/psi4manual/master/api/psi4.core.dmrg.html:208,Integrability,interface,interface,208,". dmrg. Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; dmrg. dmrg. psi4.core.dmrg(ref_wfn: psi4.core.Wavefunction)  float; Runs the CheMPS2 interface DMRG code. table of contents. dmrg; dmrg(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; dmrg.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/api/psi4.core.dmrg.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.dmrg.html
https://psicode.org/psi4manual/master/api/psi4.core.DNRM2.html:459,Deployability,update,updated,459,". DNRM2. Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; DNRM2. DNRM2. psi4.core.DNRM2(arg0: int, arg1: int, arg2: psi::Vector, arg3: int)  float; docstring. table of contents. DNRM2; DNRM2(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; DNRM2.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/api/psi4.core.DNRM2.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.DNRM2.html
https://psicode.org/psi4manual/master/api/psi4.core.doublet.html:602,Deployability,update,updated,602,". doublet. Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; doublet. doublet. psi4.core.doublet(A: psi4.core.Matrix, B: psi4.core.Matrix, transA: bool = False, transB: bool = False)  psi4.core.Matrix; Returns the multiplication of two matrices A and B, with options to transpose each beforehand. table of contents. doublet; doublet(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; doublet.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/api/psi4.core.doublet.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.doublet.html
https://psicode.org/psi4manual/master/api/psi4.core.dpdbuf4.html:1135,Deployability,update,updated,1135,". dpdbuf4. Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; dpdbuf4. dpdbuf4. class psi4.core.dpdbuf4; Bases: pybind11_object; docstring; Methods Summary. axpy_matrix(self,arg0,arg1); Add 'a' times a Matrix to this. coldim(self); Return the dimensions of the column index. rowdim(self); Return the dimensions of the row index. zero(self); Fill all with entries. Methods Documentation. axpy_matrix(self: psi4.core.dpdbuf4, arg0: psi4.core.Matrix, arg1: float)  int; Add a times a Matrix to this. coldim(self: psi4.core.dpdbuf4)  psi4.core.Dimension; Return the dimensions of the column index. rowdim(self: psi4.core.dpdbuf4)  psi4.core.Dimension; Return the dimensions of the row index. zero(self: psi4.core.dpdbuf4)  int; Fill all with entries. table of contents. dpdbuf4; dpdbuf4; dpdbuf4.axpy_matrix(); dpdbuf4.coldim(); dpdbuf4.rowdim(); dpdbuf4.zero(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; dpdbuf4.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/api/psi4.core.dpdbuf4.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.dpdbuf4.html
https://psicode.org/psi4manual/master/api/psi4.core.dpdfile2.html:1164,Deployability,update,updated,1164,". dpdfile2. Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; dpdfile2. dpdfile2. class psi4.core.dpdfile2; Bases: pybind11_object; docstring; Methods Summary. axpy_matrix(self,arg0,arg1); Add 'a' times a Matrix to this. coldim(self); Return the dimensions of the column index. rowdim(self); Return the dimensions of the row index. zero(self); Fill all entries with zeroes. Methods Documentation. axpy_matrix(self: psi4.core.dpdfile2, arg0: psi4.core.Matrix, arg1: float)  int; Add a times a Matrix to this. coldim(self: psi4.core.dpdfile2)  psi4.core.Dimension; Return the dimensions of the column index. rowdim(self: psi4.core.dpdfile2)  psi4.core.Dimension; Return the dimensions of the row index. zero(self: psi4.core.dpdfile2)  int; Fill all entries with zeroes. table of contents. dpdfile2; dpdfile2; dpdfile2.axpy_matrix(); dpdfile2.coldim(); dpdfile2.rowdim(); dpdfile2.zero(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; dpdfile2.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/api/psi4.core.dpdfile2.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.dpdfile2.html
https://psicode.org/psi4manual/master/api/psi4.core.DPOTRF.html:475,Deployability,update,updated,475,". DPOTRF. Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; DPOTRF. DPOTRF. psi4.core.DPOTRF(arg0: int, arg1: str, arg2: int, arg3: psi::Matrix, arg4: int)  int; docstring. table of contents. DPOTRF; DPOTRF(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; DPOTRF.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/api/psi4.core.DPOTRF.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.DPOTRF.html
https://psicode.org/psi4manual/master/api/psi4.core.DPOTRI.html:475,Deployability,update,updated,475,". DPOTRI. Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; DPOTRI. DPOTRI. psi4.core.DPOTRI(arg0: int, arg1: str, arg2: int, arg3: psi::Matrix, arg4: int)  int; docstring. table of contents. DPOTRI; DPOTRI(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; DPOTRI.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/api/psi4.core.DPOTRI.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.DPOTRI.html
https://psicode.org/psi4manual/master/api/psi4.core.DPOTRS.html:516,Deployability,update,updated,516,". DPOTRS. Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; DPOTRS. DPOTRS. psi4.core.DPOTRS(arg0: int, arg1: str, arg2: int, arg3: int, arg4: psi::Matrix, arg5: int, arg6: psi::Matrix, arg7: int)  int; docstring. table of contents. DPOTRS; DPOTRS(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; DPOTRS.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/api/psi4.core.DPOTRS.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.DPOTRS.html
https://psicode.org/psi4manual/master/api/psi4.core.DROT.html:507,Deployability,update,updated,507,". DROT. Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; DROT. DROT. psi4.core.DROT(arg0: int, arg1: int, arg2: psi::Vector, arg3: int, arg4: psi::Vector, arg5: int, arg6: float, arg7: float)  None; docstring. table of contents. DROT; DROT(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; DROT.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/api/psi4.core.DROT.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.DROT.html
https://psicode.org/psi4manual/master/api/psi4.core.DSBMV.html:568,Deployability,update,updated,568,". DSBMV. Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; DSBMV. DSBMV. psi4.core.DSBMV(arg0: int, arg1: str, arg2: int, arg3: int, arg4: float, arg5: psi::Matrix, arg6: int, arg7: psi::Vector, arg8: int, arg9: float, arg10: psi::Vector, arg11: int)  None; docstring. table of contents. DSBMV; DSBMV(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; DSBMV.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/api/psi4.core.DSBMV.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.DSBMV.html
https://psicode.org/psi4manual/master/api/psi4.core.DSCAL.html:471,Deployability,update,updated,471,". DSCAL. Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; DSCAL. DSCAL. psi4.core.DSCAL(arg0: int, arg1: int, arg2: float, arg3: psi::Vector, arg4: int)  None; docstring. table of contents. DSCAL; DSCAL(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; DSCAL.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/api/psi4.core.DSCAL.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.DSCAL.html
https://psicode.org/psi4manual/master/api/psi4.core.DSWAP.html:488,Deployability,update,updated,488,". DSWAP. Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; DSWAP. DSWAP. psi4.core.DSWAP(arg0: int, arg1: int, arg2: psi::Vector, arg3: int, arg4: psi::Vector, arg5: int)  None; docstring. table of contents. DSWAP; DSWAP(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; DSWAP.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/api/psi4.core.DSWAP.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.DSWAP.html
https://psicode.org/psi4manual/master/api/psi4.core.DSYEV.html:528,Deployability,update,updated,528,". DSYEV. Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; DSYEV. DSYEV. psi4.core.DSYEV(arg0: int, arg1: str, arg2: str, arg3: int, arg4: psi::Matrix, arg5: int, arg6: psi::Vector, arg7: psi::Vector, arg8: int)  int; docstring. table of contents. DSYEV; DSYEV(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; DSYEV.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/api/psi4.core.DSYEV.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.DSYEV.html
https://psicode.org/psi4manual/master/api/psi4.core.DSYMM.html:580,Deployability,update,updated,580,". DSYMM. Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; DSYMM. DSYMM. psi4.core.DSYMM(arg0: int, arg1: str, arg2: str, arg3: int, arg4: int, arg5: float, arg6: psi::Matrix, arg7: int, arg8: psi::Matrix, arg9: int, arg10: float, arg11: psi::Matrix, arg12: int)  None; docstring. table of contents. DSYMM; DSYMM(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; DSYMM.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/api/psi4.core.DSYMM.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.DSYMM.html
https://psicode.org/psi4manual/master/api/psi4.core.DSYMV.html:556,Deployability,update,updated,556,". DSYMV. Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; DSYMV. DSYMV. psi4.core.DSYMV(arg0: int, arg1: str, arg2: int, arg3: float, arg4: psi::Matrix, arg5: int, arg6: psi::Vector, arg7: int, arg8: float, arg9: psi::Vector, arg10: int)  None; docstring. table of contents. DSYMV; DSYMV(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; DSYMV.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/api/psi4.core.DSYMV.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.DSYMV.html
https://psicode.org/psi4manual/master/api/psi4.core.DSYR.html:505,Deployability,update,updated,505,". DSYR. Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; DSYR. DSYR. psi4.core.DSYR(arg0: int, arg1: str, arg2: int, arg3: float, arg4: psi::Vector, arg5: int, arg6: psi::Matrix, arg7: int)  None; docstring. table of contents. DSYR; DSYR(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; DSYR.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/api/psi4.core.DSYR.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.DSYR.html
https://psicode.org/psi4manual/master/api/psi4.core.DSYR2.html:542,Deployability,update,updated,542,". DSYR2. Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; DSYR2. DSYR2. psi4.core.DSYR2(arg0: int, arg1: str, arg2: int, arg3: float, arg4: psi::Vector, arg5: int, arg6: psi::Vector, arg7: int, arg8: psi::Matrix, arg9: int)  None; docstring. table of contents. DSYR2; DSYR2(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; DSYR2.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/api/psi4.core.DSYR2.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.DSYR2.html
https://psicode.org/psi4manual/master/api/psi4.core.DSYR2K.html:587,Deployability,update,updated,587,". DSYR2K. Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; DSYR2K. DSYR2K. psi4.core.DSYR2K(arg0: int, arg1: str, arg2: str, arg3: int, arg4: int, arg5: float, arg6: psi::Matrix, arg7: int, arg8: psi::Matrix, arg9: int, arg10: float, arg11: psi::Matrix, arg12: int)  None; docstring. table of contents. DSYR2K; DSYR2K(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; DSYR2K.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/api/psi4.core.DSYR2K.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.DSYR2K.html
https://psicode.org/psi4manual/master/api/psi4.core.DSYRK.html:548,Deployability,update,updated,548,". DSYRK. Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; DSYRK. DSYRK. psi4.core.DSYRK(arg0: int, arg1: str, arg2: str, arg3: int, arg4: int, arg5: float, arg6: psi::Matrix, arg7: int, arg8: float, arg9: psi::Matrix, arg10: int)  None; docstring. table of contents. DSYRK; DSYRK(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; DSYRK.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/api/psi4.core.DSYRK.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.DSYRK.html
https://psicode.org/psi4manual/master/api/psi4.core.DSYSV.html:562,Deployability,update,updated,562,". DSYSV. Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; DSYSV. DSYSV. psi4.core.DSYSV(arg0: int, arg1: str, arg2: int, arg3: int, arg4: psi::Matrix, arg5: int, arg6: psi::IntVector, arg7: psi::Matrix, arg8: int, arg9: psi::Vector, arg10: int)  int; docstring. table of contents. DSYSV; DSYSV(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; DSYSV.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/api/psi4.core.DSYSV.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.DSYSV.html
https://psicode.org/psi4manual/master/api/psi4.core.DTBMV.html:532,Deployability,update,updated,532,". DTBMV. Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; DTBMV. DTBMV. psi4.core.DTBMV(arg0: int, arg1: str, arg2: str, arg3: str, arg4: int, arg5: int, arg6: psi::Matrix, arg7: int, arg8: psi::Vector, arg9: int)  None; docstring. table of contents. DTBMV; DTBMV(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; DTBMV.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/api/psi4.core.DTBMV.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.DTBMV.html
https://psicode.org/psi4manual/master/api/psi4.core.DTBSV.html:532,Deployability,update,updated,532,". DTBSV. Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; DTBSV. DTBSV. psi4.core.DTBSV(arg0: int, arg1: str, arg2: str, arg3: str, arg4: int, arg5: int, arg6: psi::Matrix, arg7: int, arg8: psi::Vector, arg9: int)  None; docstring. table of contents. DTBSV; DTBSV(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; DTBSV.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/api/psi4.core.DTBSV.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.DTBSV.html
https://psicode.org/psi4manual/master/api/psi4.core.DTRMM.html:558,Deployability,update,updated,558,". DTRMM. Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; DTRMM. DTRMM. psi4.core.DTRMM(arg0: int, arg1: str, arg2: str, arg3: str, arg4: str, arg5: int, arg6: int, arg7: float, arg8: psi::Matrix, arg9: int, arg10: psi::Matrix, arg11: int)  None; docstring. table of contents. DTRMM; DTRMM(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; DTRMM.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/api/psi4.core.DTRMM.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.DTRMM.html
https://psicode.org/psi4manual/master/api/psi4.core.DTRMV.html:521,Deployability,update,updated,521,". DTRMV. Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; DTRMV. DTRMV. psi4.core.DTRMV(arg0: int, arg1: str, arg2: str, arg3: str, arg4: int, arg5: psi::Matrix, arg6: int, arg7: psi::Vector, arg8: int)  None; docstring. table of contents. DTRMV; DTRMV(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; DTRMV.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/api/psi4.core.DTRMV.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.DTRMV.html
https://psicode.org/psi4manual/master/api/psi4.core.DTRSM.html:558,Deployability,update,updated,558,". DTRSM. Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; DTRSM. DTRSM. psi4.core.DTRSM(arg0: int, arg1: str, arg2: str, arg3: str, arg4: str, arg5: int, arg6: int, arg7: float, arg8: psi::Matrix, arg9: int, arg10: psi::Matrix, arg11: int)  None; docstring. table of contents. DTRSM; DTRSM(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; DTRSM.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/api/psi4.core.DTRSM.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.DTRSM.html
https://psicode.org/psi4manual/master/api/psi4.core.DTRSV.html:521,Deployability,update,updated,521,". DTRSV. Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; DTRSV. DTRSV. psi4.core.DTRSV(arg0: int, arg1: str, arg2: str, arg3: str, arg4: int, arg5: psi::Matrix, arg6: int, arg7: psi::Vector, arg8: int)  None; docstring. table of contents. DTRSV; DTRSV(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; DTRSV.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/api/psi4.core.DTRSV.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.DTRSV.html
https://psicode.org/psi4manual/master/api/psi4.core.dummy_einsums.html:520,Deployability,update,updated,520,". dummy_einsums. Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; dummy_einsums. dummy_einsums. psi4.core.dummy_einsums(ref_wfn: psi4.core.Wavefunction)  float; Runs the einsums placeholder code. table of contents. dummy_einsums; dummy_einsums(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; dummy_einsums.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/api/psi4.core.dummy_einsums.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.dummy_einsums.html
https://psicode.org/psi4manual/master/api/psi4.core.dummy_integratorxx.html:256,Deployability,integrat,integratorxx,256,". dummy_integratorxx. Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; dummy_integratorxx. dummy_integratorxx. psi4.core.dummy_integratorxx(ref_wfn: psi4.core.Wavefunction)  float; Runs the integratorxx placeholder code. table of contents. dummy_integratorxx; dummy_integratorxx(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; dummy_integratorxx.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/api/psi4.core.dummy_integratorxx.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.dummy_integratorxx.html
https://psicode.org/psi4manual/master/api/psi4.core.dummy_integratorxx.html:560,Deployability,update,updated,560,". dummy_integratorxx. Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; dummy_integratorxx. dummy_integratorxx. psi4.core.dummy_integratorxx(ref_wfn: psi4.core.Wavefunction)  float; Runs the integratorxx placeholder code. table of contents. dummy_integratorxx; dummy_integratorxx(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; dummy_integratorxx.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/api/psi4.core.dummy_integratorxx.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.dummy_integratorxx.html
https://psicode.org/psi4manual/master/api/psi4.core.dummy_integratorxx.html:256,Integrability,integrat,integratorxx,256,". dummy_integratorxx. Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; dummy_integratorxx. dummy_integratorxx. psi4.core.dummy_integratorxx(ref_wfn: psi4.core.Wavefunction)  float; Runs the integratorxx placeholder code. table of contents. dummy_integratorxx; dummy_integratorxx(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; dummy_integratorxx.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/api/psi4.core.dummy_integratorxx.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.dummy_integratorxx.html
https://psicode.org/psi4manual/master/api/psi4.core.ElectricFieldInt.html:525,Deployability,update,updated,525,". ElectricFieldInt. Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; ElectricFieldInt. ElectricFieldInt. class psi4.core.ElectricFieldInt; Bases: OneBodyAOInt; Computes electric field integrals. table of contents. ElectricFieldInt; ElectricFieldInt. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; ElectricFieldInt.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/api/psi4.core.ElectricFieldInt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.ElectricFieldInt.html
https://psicode.org/psi4manual/master/api/psi4.core.ElectrostaticInt.html:524,Deployability,update,updated,524,". ElectrostaticInt. Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; ElectrostaticInt. ElectrostaticInt. class psi4.core.ElectrostaticInt; Bases: OneBodyAOInt; Computes electrostatic integrals. table of contents. ElectrostaticInt; ElectrostaticInt. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; ElectrostaticInt.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/api/psi4.core.ElectrostaticInt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.ElectrostaticInt.html
https://psicode.org/psi4manual/master/api/psi4.core.ERI.html:449,Deployability,update,updated,449,". ERI. Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; ERI. ERI. class psi4.core.ERI; Bases: TwoBodyAOInt; Computes normal two electron repulsion integrals. table of contents. ERI; ERI. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; ERI.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/api/psi4.core.ERI.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.ERI.html
https://psicode.org/psi4manual/master/api/psi4.core.ESPPropCalc.html:1241,Deployability,update,updated,1241,". ESPPropCalc. Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; ESPPropCalc. ESPPropCalc. class psi4.core.ESPPropCalc; Bases: Prop; ESPPropCalc gives access to routines calculating the ESP on a grid; Methods Summary. compute_esp_over_grid_in_memory(self,arg0); Computes ESP on specified grid Nx3 (as SharedMatrix, in input units). compute_field_over_grid_in_memory(self,arg0); Computes field on specified grid Nx3 (as SharedMatrix, in input units). Methods Documentation. compute_esp_over_grid_in_memory(self: psi4.core.ESPPropCalc, arg0: psi4.core.Matrix)  psi4.core.Vector; Computes ESP on specified grid Nx3 (as SharedMatrix, in input units). compute_field_over_grid_in_memory(self: psi4.core.ESPPropCalc, arg0: psi4.core.Matrix)  psi4.core.Matrix; Computes field on specified grid Nx3 (as SharedMatrix, in input units). table of contents. ESPPropCalc; ESPPropCalc; ESPPropCalc.compute_esp_over_grid_in_memory(); ESPPropCalc.compute_field_over_grid_in_memory(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; ESPPropCalc.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/api/psi4.core.ESPPropCalc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.ESPPropCalc.html
https://psicode.org/psi4manual/master/api/psi4.core.ESPPropCalc.html:225,Integrability,rout,routines,225,". ESPPropCalc. Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; ESPPropCalc. ESPPropCalc. class psi4.core.ESPPropCalc; Bases: Prop; ESPPropCalc gives access to routines calculating the ESP on a grid; Methods Summary. compute_esp_over_grid_in_memory(self,arg0); Computes ESP on specified grid Nx3 (as SharedMatrix, in input units). compute_field_over_grid_in_memory(self,arg0); Computes field on specified grid Nx3 (as SharedMatrix, in input units). Methods Documentation. compute_esp_over_grid_in_memory(self: psi4.core.ESPPropCalc, arg0: psi4.core.Matrix)  psi4.core.Vector; Computes ESP on specified grid Nx3 (as SharedMatrix, in input units). compute_field_over_grid_in_memory(self: psi4.core.ESPPropCalc, arg0: psi4.core.Matrix)  psi4.core.Matrix; Computes field on specified grid Nx3 (as SharedMatrix, in input units). table of contents. ESPPropCalc; ESPPropCalc; ESPPropCalc.compute_esp_over_grid_in_memory(); ESPPropCalc.compute_field_over_grid_in_memory(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; ESPPropCalc.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/api/psi4.core.ESPPropCalc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.ESPPropCalc.html
https://psicode.org/psi4manual/master/api/psi4.core.ESPPropCalc.html:215,Security,access,access,215,". ESPPropCalc. Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; ESPPropCalc. ESPPropCalc. class psi4.core.ESPPropCalc; Bases: Prop; ESPPropCalc gives access to routines calculating the ESP on a grid; Methods Summary. compute_esp_over_grid_in_memory(self,arg0); Computes ESP on specified grid Nx3 (as SharedMatrix, in input units). compute_field_over_grid_in_memory(self,arg0); Computes field on specified grid Nx3 (as SharedMatrix, in input units). Methods Documentation. compute_esp_over_grid_in_memory(self: psi4.core.ESPPropCalc, arg0: psi4.core.Matrix)  psi4.core.Vector; Computes ESP on specified grid Nx3 (as SharedMatrix, in input units). compute_field_over_grid_in_memory(self: psi4.core.ESPPropCalc, arg0: psi4.core.Matrix)  psi4.core.Matrix; Computes field on specified grid Nx3 (as SharedMatrix, in input units). table of contents. ESPPropCalc; ESPPropCalc; ESPPropCalc.compute_esp_over_grid_in_memory(); ESPPropCalc.compute_field_over_grid_in_memory(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; ESPPropCalc.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/api/psi4.core.ESPPropCalc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.ESPPropCalc.html
https://psicode.org/psi4manual/master/api/psi4.core.ExternalPotential.html:3352,Deployability,update,updated,3352,": float)  None; Add a charge Z at (x,y,z). appendCharges(self: psi4.core.ExternalPotential, arg0: list[tuple[float, float, float, float]])  None; Append a vector of charge tuples to a current ExternalPotential. clear(self: psi4.core.ExternalPotential)  None; Reset the field to zero (eliminates all entries). computeExternExternInteraction(self: psi4.core.ExternalPotential, arg0: psi4.core.ExternalPotential)  float; Compute the interaction between this potential and other external potential. computeNuclearEnergy(self: psi4.core.ExternalPotential, arg0: psi4.core.Molecule)  float; Compute the contribution to the nuclear repulsion energy for the given molecule. computePotentialMatrix(self: psi4.core.ExternalPotential, basis: psi4.core.BasisSet)  psi4.core.Matrix; Compute the external potential matrix in the given basis set. getCharges(self: psi4.core.ExternalPotential)  list[tuple[float, float, float, float]]; Get the vector of charge tuples. gradient_on_charges(self: psi4.core.ExternalPotential)  psi4.core.Matrix; Get the gradient on the embedded charges. print_out(self: psi4.core.ExternalPotential)  None; Print python print helper to the outfile. setName(self: psi4.core.ExternalPotential, arg0: str)  None; Sets the name. table of contents. ExternalPotential; ExternalPotential; ExternalPotential.addBasis(); ExternalPotential.addCharge(); ExternalPotential.appendCharges(); ExternalPotential.clear(); ExternalPotential.computeExternExternInteraction(); ExternalPotential.computeNuclearEnergy(); ExternalPotential.computePotentialMatrix(); ExternalPotential.getCharges(); ExternalPotential.gradient_on_charges(); ExternalPotential.print_out(); ExternalPotential.setName(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; ExternalPotential.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/api/psi4.core.ExternalPotential.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.ExternalPotential.html
https://psicode.org/psi4manual/master/api/psi4.core.ExternalPotential.html:442,Energy Efficiency,charge,charge,442,". ExternalPotential. Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; ExternalPotential. ExternalPotential. class psi4.core.ExternalPotential; Bases: pybind11_object; Stores external potential field, computes external potential matrix; Methods Summary. addBasis(self,basis,coefs); Add a basis of S auxiliary functions iwth Df coefficients. addCharge(self,Z,x,y,z); Add a charge Z at (x,y,z). appendCharges(self,arg0); Append a vector of charge tuples to a current ExternalPotential. clear(self); Reset the field to zero (eliminates all entries). computeExternExternInteraction(self,arg0); Compute the interaction between this potential and other external potential. computeNuclearEnergy(self,arg0); Compute the contribution to the nuclear repulsion energy for the given molecule. computePotentialMatrix(self,basis); Compute the external potential matrix in the given basis set. getCharges(self); Get the vector of charge tuples. gradient_on_charges(self); Get the gradient on the embedded charges. print_out(self); Print python print helper to the outfile. setName(self,arg0); Sets the name. Methods Documentation. addBasis(self: psi4.core.ExternalPotential, basis: psi4.core.BasisSet, coefs: psi4.core.Vector)  None; Add a basis of S auxiliary functions iwth Df coefficients. addCharge(self: psi4.core.ExternalPotential, Z: float, x: float, y: float, z: float)  None; Add a charge Z at (x,y,z). appendCharges(self: psi4.core.ExternalPotential, arg0: list[tuple[float, float, float, float]])  None; Append a vector of charge tuples to a current ExternalPotential. clear(self: psi4.core.ExternalPotential)  None; Reset the field to zero (eliminates all entries). computeExternExternInteraction(self: psi4.core.ExternalPotential, arg0: psi4.core.ExternalPotential)  float; Compute the interaction between this potential and other external potential. computeNuclearEnergy(self: psi4.core.ExternalPotential, arg0: psi4.",MatchSource.WIKI,psi4manual/master/api/psi4.core.ExternalPotential.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.ExternalPotential.html
https://psicode.org/psi4manual/master/api/psi4.core.ExternalPotential.html:509,Energy Efficiency,charge,charge,509,". ExternalPotential. Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; ExternalPotential. ExternalPotential. class psi4.core.ExternalPotential; Bases: pybind11_object; Stores external potential field, computes external potential matrix; Methods Summary. addBasis(self,basis,coefs); Add a basis of S auxiliary functions iwth Df coefficients. addCharge(self,Z,x,y,z); Add a charge Z at (x,y,z). appendCharges(self,arg0); Append a vector of charge tuples to a current ExternalPotential. clear(self); Reset the field to zero (eliminates all entries). computeExternExternInteraction(self,arg0); Compute the interaction between this potential and other external potential. computeNuclearEnergy(self,arg0); Compute the contribution to the nuclear repulsion energy for the given molecule. computePotentialMatrix(self,basis); Compute the external potential matrix in the given basis set. getCharges(self); Get the vector of charge tuples. gradient_on_charges(self); Get the gradient on the embedded charges. print_out(self); Print python print helper to the outfile. setName(self,arg0); Sets the name. Methods Documentation. addBasis(self: psi4.core.ExternalPotential, basis: psi4.core.BasisSet, coefs: psi4.core.Vector)  None; Add a basis of S auxiliary functions iwth Df coefficients. addCharge(self: psi4.core.ExternalPotential, Z: float, x: float, y: float, z: float)  None; Add a charge Z at (x,y,z). appendCharges(self: psi4.core.ExternalPotential, arg0: list[tuple[float, float, float, float]])  None; Append a vector of charge tuples to a current ExternalPotential. clear(self: psi4.core.ExternalPotential)  None; Reset the field to zero (eliminates all entries). computeExternExternInteraction(self: psi4.core.ExternalPotential, arg0: psi4.core.ExternalPotential)  float; Compute the interaction between this potential and other external potential. computeNuclearEnergy(self: psi4.core.ExternalPotential, arg0: psi4.",MatchSource.WIKI,psi4manual/master/api/psi4.core.ExternalPotential.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.ExternalPotential.html
https://psicode.org/psi4manual/master/api/psi4.core.ExternalPotential.html:823,Energy Efficiency,energy,energy,823,". ExternalPotential. Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; ExternalPotential. ExternalPotential. class psi4.core.ExternalPotential; Bases: pybind11_object; Stores external potential field, computes external potential matrix; Methods Summary. addBasis(self,basis,coefs); Add a basis of S auxiliary functions iwth Df coefficients. addCharge(self,Z,x,y,z); Add a charge Z at (x,y,z). appendCharges(self,arg0); Append a vector of charge tuples to a current ExternalPotential. clear(self); Reset the field to zero (eliminates all entries). computeExternExternInteraction(self,arg0); Compute the interaction between this potential and other external potential. computeNuclearEnergy(self,arg0); Compute the contribution to the nuclear repulsion energy for the given molecule. computePotentialMatrix(self,basis); Compute the external potential matrix in the given basis set. getCharges(self); Get the vector of charge tuples. gradient_on_charges(self); Get the gradient on the embedded charges. print_out(self); Print python print helper to the outfile. setName(self,arg0); Sets the name. Methods Documentation. addBasis(self: psi4.core.ExternalPotential, basis: psi4.core.BasisSet, coefs: psi4.core.Vector)  None; Add a basis of S auxiliary functions iwth Df coefficients. addCharge(self: psi4.core.ExternalPotential, Z: float, x: float, y: float, z: float)  None; Add a charge Z at (x,y,z). appendCharges(self: psi4.core.ExternalPotential, arg0: list[tuple[float, float, float, float]])  None; Append a vector of charge tuples to a current ExternalPotential. clear(self: psi4.core.ExternalPotential)  None; Reset the field to zero (eliminates all entries). computeExternExternInteraction(self: psi4.core.ExternalPotential, arg0: psi4.core.ExternalPotential)  float; Compute the interaction between this potential and other external potential. computeNuclearEnergy(self: psi4.core.ExternalPotential, arg0: psi4.",MatchSource.WIKI,psi4manual/master/api/psi4.core.ExternalPotential.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.ExternalPotential.html
https://psicode.org/psi4manual/master/api/psi4.core.ExternalPotential.html:989,Energy Efficiency,charge,charge,989,". ExternalPotential. Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; ExternalPotential. ExternalPotential. class psi4.core.ExternalPotential; Bases: pybind11_object; Stores external potential field, computes external potential matrix; Methods Summary. addBasis(self,basis,coefs); Add a basis of S auxiliary functions iwth Df coefficients. addCharge(self,Z,x,y,z); Add a charge Z at (x,y,z). appendCharges(self,arg0); Append a vector of charge tuples to a current ExternalPotential. clear(self); Reset the field to zero (eliminates all entries). computeExternExternInteraction(self,arg0); Compute the interaction between this potential and other external potential. computeNuclearEnergy(self,arg0); Compute the contribution to the nuclear repulsion energy for the given molecule. computePotentialMatrix(self,basis); Compute the external potential matrix in the given basis set. getCharges(self); Get the vector of charge tuples. gradient_on_charges(self); Get the gradient on the embedded charges. print_out(self); Print python print helper to the outfile. setName(self,arg0); Sets the name. Methods Documentation. addBasis(self: psi4.core.ExternalPotential, basis: psi4.core.BasisSet, coefs: psi4.core.Vector)  None; Add a basis of S auxiliary functions iwth Df coefficients. addCharge(self: psi4.core.ExternalPotential, Z: float, x: float, y: float, z: float)  None; Add a charge Z at (x,y,z). appendCharges(self: psi4.core.ExternalPotential, arg0: list[tuple[float, float, float, float]])  None; Append a vector of charge tuples to a current ExternalPotential. clear(self: psi4.core.ExternalPotential)  None; Reset the field to zero (eliminates all entries). computeExternExternInteraction(self: psi4.core.ExternalPotential, arg0: psi4.core.ExternalPotential)  float; Compute the interaction between this potential and other external potential. computeNuclearEnergy(self: psi4.core.ExternalPotential, arg0: psi4.",MatchSource.WIKI,psi4manual/master/api/psi4.core.ExternalPotential.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.ExternalPotential.html
https://psicode.org/psi4manual/master/api/psi4.core.ExternalPotential.html:1064,Energy Efficiency,charge,charges,1064,"ex. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; ExternalPotential. ExternalPotential. class psi4.core.ExternalPotential; Bases: pybind11_object; Stores external potential field, computes external potential matrix; Methods Summary. addBasis(self,basis,coefs); Add a basis of S auxiliary functions iwth Df coefficients. addCharge(self,Z,x,y,z); Add a charge Z at (x,y,z). appendCharges(self,arg0); Append a vector of charge tuples to a current ExternalPotential. clear(self); Reset the field to zero (eliminates all entries). computeExternExternInteraction(self,arg0); Compute the interaction between this potential and other external potential. computeNuclearEnergy(self,arg0); Compute the contribution to the nuclear repulsion energy for the given molecule. computePotentialMatrix(self,basis); Compute the external potential matrix in the given basis set. getCharges(self); Get the vector of charge tuples. gradient_on_charges(self); Get the gradient on the embedded charges. print_out(self); Print python print helper to the outfile. setName(self,arg0); Sets the name. Methods Documentation. addBasis(self: psi4.core.ExternalPotential, basis: psi4.core.BasisSet, coefs: psi4.core.Vector)  None; Add a basis of S auxiliary functions iwth Df coefficients. addCharge(self: psi4.core.ExternalPotential, Z: float, x: float, y: float, z: float)  None; Add a charge Z at (x,y,z). appendCharges(self: psi4.core.ExternalPotential, arg0: list[tuple[float, float, float, float]])  None; Append a vector of charge tuples to a current ExternalPotential. clear(self: psi4.core.ExternalPotential)  None; Reset the field to zero (eliminates all entries). computeExternExternInteraction(self: psi4.core.ExternalPotential, arg0: psi4.core.ExternalPotential)  float; Compute the interaction between this potential and other external potential. computeNuclearEnergy(self: psi4.core.ExternalPotential, arg0: psi4.core.Molecule)  float; Compute the ",MatchSource.WIKI,psi4manual/master/api/psi4.core.ExternalPotential.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.ExternalPotential.html
https://psicode.org/psi4manual/master/api/psi4.core.ExternalPotential.html:1455,Energy Efficiency,charge,charge,1455,"y,z); Add a charge Z at (x,y,z). appendCharges(self,arg0); Append a vector of charge tuples to a current ExternalPotential. clear(self); Reset the field to zero (eliminates all entries). computeExternExternInteraction(self,arg0); Compute the interaction between this potential and other external potential. computeNuclearEnergy(self,arg0); Compute the contribution to the nuclear repulsion energy for the given molecule. computePotentialMatrix(self,basis); Compute the external potential matrix in the given basis set. getCharges(self); Get the vector of charge tuples. gradient_on_charges(self); Get the gradient on the embedded charges. print_out(self); Print python print helper to the outfile. setName(self,arg0); Sets the name. Methods Documentation. addBasis(self: psi4.core.ExternalPotential, basis: psi4.core.BasisSet, coefs: psi4.core.Vector)  None; Add a basis of S auxiliary functions iwth Df coefficients. addCharge(self: psi4.core.ExternalPotential, Z: float, x: float, y: float, z: float)  None; Add a charge Z at (x,y,z). appendCharges(self: psi4.core.ExternalPotential, arg0: list[tuple[float, float, float, float]])  None; Append a vector of charge tuples to a current ExternalPotential. clear(self: psi4.core.ExternalPotential)  None; Reset the field to zero (eliminates all entries). computeExternExternInteraction(self: psi4.core.ExternalPotential, arg0: psi4.core.ExternalPotential)  float; Compute the interaction between this potential and other external potential. computeNuclearEnergy(self: psi4.core.ExternalPotential, arg0: psi4.core.Molecule)  float; Compute the contribution to the nuclear repulsion energy for the given molecule. computePotentialMatrix(self: psi4.core.ExternalPotential, basis: psi4.core.BasisSet)  psi4.core.Matrix; Compute the external potential matrix in the given basis set. getCharges(self: psi4.core.ExternalPotential)  list[tuple[float, float, float, float]]; Get the vector of charge tuples. gradient_on_charges(self: psi4",MatchSource.WIKI,psi4manual/master/api/psi4.core.ExternalPotential.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.ExternalPotential.html
https://psicode.org/psi4manual/master/api/psi4.core.ExternalPotential.html:1600,Energy Efficiency,charge,charge,1600,"he field to zero (eliminates all entries). computeExternExternInteraction(self,arg0); Compute the interaction between this potential and other external potential. computeNuclearEnergy(self,arg0); Compute the contribution to the nuclear repulsion energy for the given molecule. computePotentialMatrix(self,basis); Compute the external potential matrix in the given basis set. getCharges(self); Get the vector of charge tuples. gradient_on_charges(self); Get the gradient on the embedded charges. print_out(self); Print python print helper to the outfile. setName(self,arg0); Sets the name. Methods Documentation. addBasis(self: psi4.core.ExternalPotential, basis: psi4.core.BasisSet, coefs: psi4.core.Vector)  None; Add a basis of S auxiliary functions iwth Df coefficients. addCharge(self: psi4.core.ExternalPotential, Z: float, x: float, y: float, z: float)  None; Add a charge Z at (x,y,z). appendCharges(self: psi4.core.ExternalPotential, arg0: list[tuple[float, float, float, float]])  None; Append a vector of charge tuples to a current ExternalPotential. clear(self: psi4.core.ExternalPotential)  None; Reset the field to zero (eliminates all entries). computeExternExternInteraction(self: psi4.core.ExternalPotential, arg0: psi4.core.ExternalPotential)  float; Compute the interaction between this potential and other external potential. computeNuclearEnergy(self: psi4.core.ExternalPotential, arg0: psi4.core.Molecule)  float; Compute the contribution to the nuclear repulsion energy for the given molecule. computePotentialMatrix(self: psi4.core.ExternalPotential, basis: psi4.core.BasisSet)  psi4.core.Matrix; Compute the external potential matrix in the given basis set. getCharges(self: psi4.core.ExternalPotential)  list[tuple[float, float, float, float]]; Get the vector of charge tuples. gradient_on_charges(self: psi4.core.ExternalPotential)  psi4.core.Matrix; Get the gradient on the embedded charges. print_out(self: psi4.core.ExternalPotential)  None; Print ",MatchSource.WIKI,psi4manual/master/api/psi4.core.ExternalPotential.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.ExternalPotential.html
https://psicode.org/psi4manual/master/api/psi4.core.ExternalPotential.html:2076,Energy Efficiency,energy,energy,2076,"mbedded charges. print_out(self); Print python print helper to the outfile. setName(self,arg0); Sets the name. Methods Documentation. addBasis(self: psi4.core.ExternalPotential, basis: psi4.core.BasisSet, coefs: psi4.core.Vector)  None; Add a basis of S auxiliary functions iwth Df coefficients. addCharge(self: psi4.core.ExternalPotential, Z: float, x: float, y: float, z: float)  None; Add a charge Z at (x,y,z). appendCharges(self: psi4.core.ExternalPotential, arg0: list[tuple[float, float, float, float]])  None; Append a vector of charge tuples to a current ExternalPotential. clear(self: psi4.core.ExternalPotential)  None; Reset the field to zero (eliminates all entries). computeExternExternInteraction(self: psi4.core.ExternalPotential, arg0: psi4.core.ExternalPotential)  float; Compute the interaction between this potential and other external potential. computeNuclearEnergy(self: psi4.core.ExternalPotential, arg0: psi4.core.Molecule)  float; Compute the contribution to the nuclear repulsion energy for the given molecule. computePotentialMatrix(self: psi4.core.ExternalPotential, basis: psi4.core.BasisSet)  psi4.core.Matrix; Compute the external potential matrix in the given basis set. getCharges(self: psi4.core.ExternalPotential)  list[tuple[float, float, float, float]]; Get the vector of charge tuples. gradient_on_charges(self: psi4.core.ExternalPotential)  psi4.core.Matrix; Get the gradient on the embedded charges. print_out(self: psi4.core.ExternalPotential)  None; Print python print helper to the outfile. setName(self: psi4.core.ExternalPotential, arg0: str)  None; Sets the name. table of contents. ExternalPotential; ExternalPotential; ExternalPotential.addBasis(); ExternalPotential.addCharge(); ExternalPotential.appendCharges(); ExternalPotential.clear(); ExternalPotential.computeExternExternInteraction(); ExternalPotential.computeNuclearEnergy(); ExternalPotential.computePotentialMatrix(); ExternalPotential.getCharges(); ExternalPotentia",MatchSource.WIKI,psi4manual/master/api/psi4.core.ExternalPotential.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.ExternalPotential.html
https://psicode.org/psi4manual/master/api/psi4.core.ExternalPotential.html:2383,Energy Efficiency,charge,charge,2383,"ents. addCharge(self: psi4.core.ExternalPotential, Z: float, x: float, y: float, z: float)  None; Add a charge Z at (x,y,z). appendCharges(self: psi4.core.ExternalPotential, arg0: list[tuple[float, float, float, float]])  None; Append a vector of charge tuples to a current ExternalPotential. clear(self: psi4.core.ExternalPotential)  None; Reset the field to zero (eliminates all entries). computeExternExternInteraction(self: psi4.core.ExternalPotential, arg0: psi4.core.ExternalPotential)  float; Compute the interaction between this potential and other external potential. computeNuclearEnergy(self: psi4.core.ExternalPotential, arg0: psi4.core.Molecule)  float; Compute the contribution to the nuclear repulsion energy for the given molecule. computePotentialMatrix(self: psi4.core.ExternalPotential, basis: psi4.core.BasisSet)  psi4.core.Matrix; Compute the external potential matrix in the given basis set. getCharges(self: psi4.core.ExternalPotential)  list[tuple[float, float, float, float]]; Get the vector of charge tuples. gradient_on_charges(self: psi4.core.ExternalPotential)  psi4.core.Matrix; Get the gradient on the embedded charges. print_out(self: psi4.core.ExternalPotential)  None; Print python print helper to the outfile. setName(self: psi4.core.ExternalPotential, arg0: str)  None; Sets the name. table of contents. ExternalPotential; ExternalPotential; ExternalPotential.addBasis(); ExternalPotential.addCharge(); ExternalPotential.appendCharges(); ExternalPotential.clear(); ExternalPotential.computeExternExternInteraction(); ExternalPotential.computeNuclearEnergy(); ExternalPotential.computePotentialMatrix(); ExternalPotential.getCharges(); ExternalPotential.gradient_on_charges(); ExternalPotential.print_out(); ExternalPotential.setName(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; ExternalPotential.  Copyright 2007-2024, The Psi4 Project.; Las",MatchSource.WIKI,psi4manual/master/api/psi4.core.ExternalPotential.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.ExternalPotential.html
https://psicode.org/psi4manual/master/api/psi4.core.ExternalPotential.html:2507,Energy Efficiency,charge,charges,2507,": float)  None; Add a charge Z at (x,y,z). appendCharges(self: psi4.core.ExternalPotential, arg0: list[tuple[float, float, float, float]])  None; Append a vector of charge tuples to a current ExternalPotential. clear(self: psi4.core.ExternalPotential)  None; Reset the field to zero (eliminates all entries). computeExternExternInteraction(self: psi4.core.ExternalPotential, arg0: psi4.core.ExternalPotential)  float; Compute the interaction between this potential and other external potential. computeNuclearEnergy(self: psi4.core.ExternalPotential, arg0: psi4.core.Molecule)  float; Compute the contribution to the nuclear repulsion energy for the given molecule. computePotentialMatrix(self: psi4.core.ExternalPotential, basis: psi4.core.BasisSet)  psi4.core.Matrix; Compute the external potential matrix in the given basis set. getCharges(self: psi4.core.ExternalPotential)  list[tuple[float, float, float, float]]; Get the vector of charge tuples. gradient_on_charges(self: psi4.core.ExternalPotential)  psi4.core.Matrix; Get the gradient on the embedded charges. print_out(self: psi4.core.ExternalPotential)  None; Print python print helper to the outfile. setName(self: psi4.core.ExternalPotential, arg0: str)  None; Sets the name. table of contents. ExternalPotential; ExternalPotential; ExternalPotential.addBasis(); ExternalPotential.addCharge(); ExternalPotential.appendCharges(); ExternalPotential.clear(); ExternalPotential.computeExternExternInteraction(); ExternalPotential.computeNuclearEnergy(); ExternalPotential.computePotentialMatrix(); ExternalPotential.getCharges(); ExternalPotential.gradient_on_charges(); ExternalPotential.print_out(); ExternalPotential.setName(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; ExternalPotential.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/api/psi4.core.ExternalPotential.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.ExternalPotential.html
https://psicode.org/psi4manual/master/api/psi4.core.ExternalPotential.html:555,Usability,clear,clear,555,". ExternalPotential. Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; ExternalPotential. ExternalPotential. class psi4.core.ExternalPotential; Bases: pybind11_object; Stores external potential field, computes external potential matrix; Methods Summary. addBasis(self,basis,coefs); Add a basis of S auxiliary functions iwth Df coefficients. addCharge(self,Z,x,y,z); Add a charge Z at (x,y,z). appendCharges(self,arg0); Append a vector of charge tuples to a current ExternalPotential. clear(self); Reset the field to zero (eliminates all entries). computeExternExternInteraction(self,arg0); Compute the interaction between this potential and other external potential. computeNuclearEnergy(self,arg0); Compute the contribution to the nuclear repulsion energy for the given molecule. computePotentialMatrix(self,basis); Compute the external potential matrix in the given basis set. getCharges(self); Get the vector of charge tuples. gradient_on_charges(self); Get the gradient on the embedded charges. print_out(self); Print python print helper to the outfile. setName(self,arg0); Sets the name. Methods Documentation. addBasis(self: psi4.core.ExternalPotential, basis: psi4.core.BasisSet, coefs: psi4.core.Vector)  None; Add a basis of S auxiliary functions iwth Df coefficients. addCharge(self: psi4.core.ExternalPotential, Z: float, x: float, y: float, z: float)  None; Add a charge Z at (x,y,z). appendCharges(self: psi4.core.ExternalPotential, arg0: list[tuple[float, float, float, float]])  None; Append a vector of charge tuples to a current ExternalPotential. clear(self: psi4.core.ExternalPotential)  None; Reset the field to zero (eliminates all entries). computeExternExternInteraction(self: psi4.core.ExternalPotential, arg0: psi4.core.ExternalPotential)  float; Compute the interaction between this potential and other external potential. computeNuclearEnergy(self: psi4.core.ExternalPotential, arg0: psi4.",MatchSource.WIKI,psi4manual/master/api/psi4.core.ExternalPotential.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.ExternalPotential.html
https://psicode.org/psi4manual/master/api/psi4.core.ExternalPotential.html:1646,Usability,clear,clear,1646,"arg0); Compute the interaction between this potential and other external potential. computeNuclearEnergy(self,arg0); Compute the contribution to the nuclear repulsion energy for the given molecule. computePotentialMatrix(self,basis); Compute the external potential matrix in the given basis set. getCharges(self); Get the vector of charge tuples. gradient_on_charges(self); Get the gradient on the embedded charges. print_out(self); Print python print helper to the outfile. setName(self,arg0); Sets the name. Methods Documentation. addBasis(self: psi4.core.ExternalPotential, basis: psi4.core.BasisSet, coefs: psi4.core.Vector)  None; Add a basis of S auxiliary functions iwth Df coefficients. addCharge(self: psi4.core.ExternalPotential, Z: float, x: float, y: float, z: float)  None; Add a charge Z at (x,y,z). appendCharges(self: psi4.core.ExternalPotential, arg0: list[tuple[float, float, float, float]])  None; Append a vector of charge tuples to a current ExternalPotential. clear(self: psi4.core.ExternalPotential)  None; Reset the field to zero (eliminates all entries). computeExternExternInteraction(self: psi4.core.ExternalPotential, arg0: psi4.core.ExternalPotential)  float; Compute the interaction between this potential and other external potential. computeNuclearEnergy(self: psi4.core.ExternalPotential, arg0: psi4.core.Molecule)  float; Compute the contribution to the nuclear repulsion energy for the given molecule. computePotentialMatrix(self: psi4.core.ExternalPotential, basis: psi4.core.BasisSet)  psi4.core.Matrix; Compute the external potential matrix in the given basis set. getCharges(self: psi4.core.ExternalPotential)  list[tuple[float, float, float, float]]; Get the vector of charge tuples. gradient_on_charges(self: psi4.core.ExternalPotential)  psi4.core.Matrix; Get the gradient on the embedded charges. print_out(self: psi4.core.ExternalPotential)  None; Print python print helper to the outfile. setName(self: psi4.core.ExternalPotential,",MatchSource.WIKI,psi4manual/master/api/psi4.core.ExternalPotential.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.ExternalPotential.html
https://psicode.org/psi4manual/master/api/psi4.core.ExternalPotential.html:2861,Usability,clear,clear,2861,": float)  None; Add a charge Z at (x,y,z). appendCharges(self: psi4.core.ExternalPotential, arg0: list[tuple[float, float, float, float]])  None; Append a vector of charge tuples to a current ExternalPotential. clear(self: psi4.core.ExternalPotential)  None; Reset the field to zero (eliminates all entries). computeExternExternInteraction(self: psi4.core.ExternalPotential, arg0: psi4.core.ExternalPotential)  float; Compute the interaction between this potential and other external potential. computeNuclearEnergy(self: psi4.core.ExternalPotential, arg0: psi4.core.Molecule)  float; Compute the contribution to the nuclear repulsion energy for the given molecule. computePotentialMatrix(self: psi4.core.ExternalPotential, basis: psi4.core.BasisSet)  psi4.core.Matrix; Compute the external potential matrix in the given basis set. getCharges(self: psi4.core.ExternalPotential)  list[tuple[float, float, float, float]]; Get the vector of charge tuples. gradient_on_charges(self: psi4.core.ExternalPotential)  psi4.core.Matrix; Get the gradient on the embedded charges. print_out(self: psi4.core.ExternalPotential)  None; Print python print helper to the outfile. setName(self: psi4.core.ExternalPotential, arg0: str)  None; Sets the name. table of contents. ExternalPotential; ExternalPotential; ExternalPotential.addBasis(); ExternalPotential.addCharge(); ExternalPotential.appendCharges(); ExternalPotential.clear(); ExternalPotential.computeExternExternInteraction(); ExternalPotential.computeNuclearEnergy(); ExternalPotential.computePotentialMatrix(); ExternalPotential.getCharges(); ExternalPotential.gradient_on_charges(); ExternalPotential.print_out(); ExternalPotential.setName(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; ExternalPotential.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/api/psi4.core.ExternalPotential.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.ExternalPotential.html
https://psicode.org/psi4manual/master/api/psi4.core.FCHKWriter.html:1118,Deployability,update,updated,1118,". FCHKWriter. Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; FCHKWriter. FCHKWriter. class psi4.core.FCHKWriter; Bases: pybind11_object; Extracts information from a wavefunction object, and writes it to an FCHK file; Methods Summary. SCF_Dtot(self). set_postscf_density_label(self,label); Set base label for post-SCF density, e.g. ' CC Density'. write(self,filename); Write wavefunction information to file. Methods Documentation. SCF_Dtot(self: psi4.core.FCHKWriter)  psi4.core.Matrix. set_postscf_density_label(self: psi4.core.FCHKWriter, label: str)  None; Set base label for post-SCF density, e.g.  CC Density. write(self: psi4.core.FCHKWriter, filename: str)  None; Write wavefunction information to file. table of contents. FCHKWriter; FCHKWriter; FCHKWriter.SCF_Dtot(); FCHKWriter.set_postscf_density_label(); FCHKWriter.write(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; FCHKWriter.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/api/psi4.core.FCHKWriter.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.FCHKWriter.html
https://psicode.org/psi4manual/master/api/psi4.core.fcidump_tei_helper.html:633,Deployability,update,updated,633,". fcidump_tei_helper. Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; fcidump_tei_helper. fcidump_tei_helper. psi4.core.fcidump_tei_helper(nirrep: int, restricted: bool, DPD_info: dict[str, int], ints_tolerance: float, fname: str = 'INTDUMP')  None; Write integrals to file in FCIDUMP format. table of contents. fcidump_tei_helper; fcidump_tei_helper(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; fcidump_tei_helper.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/api/psi4.core.fcidump_tei_helper.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.fcidump_tei_helper.html
https://psicode.org/psi4manual/master/api/psi4.core.FDDS_Dispersion.html:2870,Deployability,update,updated,2870," auxiliary AO space. Methods Documentation. R_A(self: psi4.core.FDDS_Dispersion)  psi4.core.Matrix; Obtains (R^t)^-1 for monomer A. R_B(self: psi4.core.FDDS_Dispersion)  psi4.core.Matrix; Obtains (R^t)^-1 for monomer B. aux_overlap(self: psi4.core.FDDS_Dispersion)  psi4.core.Matrix; Obtains the FDDS aux_overlap. form_aux_matrices(self: psi4.core.FDDS_Dispersion, arg0: str, arg1: float)  dict[str, psi4.core.Matrix]; Forms the uncoupled amplitudes and other matrices for either monomer. form_unc_amplitude(self: psi4.core.FDDS_Dispersion, arg0: str, arg1: float)  psi4.core.Matrix; Forms the uncoupled amplitudes for either monomer. get_tensor_pqQ(self: psi4.core.FDDS_Dispersion, arg0: str, arg1: tuple[int, int, int])  psi4.core.Matrix; Debug only: fetches 3-index intermediate from disk and return as matrix. metric(self: psi4.core.FDDS_Dispersion)  psi4.core.Matrix; Obtains the FDDS metric. metric_inv(self: psi4.core.FDDS_Dispersion)  psi4.core.Matrix; Obtains the FDDS metric_inv. print_tensor_pqQ(self: psi4.core.FDDS_Dispersion, arg0: str, arg1: str, arg2: tuple[int, int, int])  None; Debug only: prints formatted 3-index intermediate to file. project_densities(self: psi4.core.FDDS_Dispersion, arg0: list[psi4.core.Matrix])  list[psi4.core.Matrix]; Projects a density from the primary AO to auxiliary AO space. table of contents. FDDS_Dispersion; FDDS_Dispersion; FDDS_Dispersion.R_A(); FDDS_Dispersion.R_B(); FDDS_Dispersion.aux_overlap(); FDDS_Dispersion.form_aux_matrices(); FDDS_Dispersion.form_unc_amplitude(); FDDS_Dispersion.get_tensor_pqQ(); FDDS_Dispersion.metric(); FDDS_Dispersion.metric_inv(); FDDS_Dispersion.print_tensor_pqQ(); FDDS_Dispersion.project_densities(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; FDDS_Dispersion.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/api/psi4.core.FDDS_Dispersion.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.FDDS_Dispersion.html
https://psicode.org/psi4manual/master/api/psi4.core.finalize.html:473,Deployability,update,updated,473,". finalize. Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; finalize. finalize. psi4.core.finalize()  None; Called upon psi4 module exit to closes timers and I/O. table of contents. finalize; finalize(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; finalize.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/api/psi4.core.finalize.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.finalize.html
https://psicode.org/psi4manual/master/api/psi4.core.FISAPT.html:4976,Deployability,update,updated,4976," molecule. nuclear(self: psi4.core.FISAPT)  None; Build the nuclear potentials V and interaction energies. overlap(self: psi4.core.FISAPT)  None; Build the overlap integrals S. partition(self: psi4.core.FISAPT)  None; Partition the nuclei and electrons. print_header(self: psi4.core.FISAPT)  None; Print header, bases, sizes, etc. print_trailer(self: psi4.core.FISAPT)  None; Print SAPT results. raw_plot(self: psi4.core.FISAPT, arg0: str)  None; Plot some analysis files. scalars(self: psi4.core.FISAPT)  dict[str, float]; Return the interally computed scalars (not copied). scf(self: psi4.core.FISAPT)  None; Solve the relaxed SCF equations for A0 and B0. sinf_disp(self: psi4.core.FISAPT, arg0: dict[str, psi4.core.Matrix], arg1: dict[str, psi4.core.Vector], arg2: bool)  None; Computes the MP2-based DispE20 and Exch-DispE20 energy without S^2. unify(self: psi4.core.FISAPT)  None; Produce unified matrices for A, B, and C. unify_part2(self: psi4.core.FISAPT)  None; Finish producing unified matrices for A, B, and C. vectors(self: psi4.core.FISAPT)  dict[str, psi4.core.Vector]; Return the interally computed vectors (not copied). table of contents. FISAPT; FISAPT; FISAPT.coulomb(); FISAPT.dHF(); FISAPT.disp(); FISAPT.do_cubes(); FISAPT.elst(); FISAPT.exch(); FISAPT.fdisp(); FISAPT.felst(); FISAPT.fexch(); FISAPT.find(); FISAPT.flocalize(); FISAPT.freeze_core(); FISAPT.ind(); FISAPT.kinetic(); FISAPT.localize(); FISAPT.matrices(); FISAPT.molecule(); FISAPT.nuclear(); FISAPT.overlap(); FISAPT.partition(); FISAPT.print_header(); FISAPT.print_trailer(); FISAPT.raw_plot(); FISAPT.scalars(); FISAPT.scf(); FISAPT.sinf_disp(); FISAPT.unify(); FISAPT.unify_part2(); FISAPT.vectors(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; FISAPT.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/api/psi4.core.FISAPT.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.FISAPT.html
https://psicode.org/psi4manual/master/api/psi4.core.FISAPT.html:397,Energy Efficiency,energy,energy,397,". FISAPT. Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; FISAPT. FISAPT. class psi4.core.FISAPT; Bases: pybind11_object; A Fragment-SAPT Wavefunction; Methods Summary. coulomb(self); Build the J/K potentials for C, D, and E. dHF(self); SAPT0 delta HF. disp(self,arg0,arg1,arg2); Computes the MP2-based DispE20 and Exch-DispE20 energy. do_cubes(self); Prepare cube files for orbital/density pictures. elst(self); SAPT0 electrostatics. exch(self); SAPT0 exchange. fdisp(self); F-SAPT0 dispersion. felst(self); F-SAPT0 electrostatics. fexch(self); F-SAPT0 exchange. find(self); F-SAPT0 induction. flocalize(self); F-SAPT0 localize. freeze_core(self); Freeze the core orbitals. ind(self); SAPT0 induction. kinetic(self); Build the kinetic integrals T. localize(self); Localize the active occupied orbitals via IBO2. matrices(self); Return the interally computed matrices (not copied). molecule(self); Returns the FISAPT's molecule. nuclear(self); Build the nuclear potentials V and interaction energies. overlap(self); Build the overlap integrals S. partition(self); Partition the nuclei and electrons. print_header(self); Print header, bases, sizes, etc. print_trailer(self); Print SAPT results. raw_plot(self,arg0); Plot some analysis files. scalars(self); Return the interally computed scalars (not copied). scf(self); Solve the relaxed SCF equations for A0 and B0. sinf_disp(self,arg0,arg1,arg2); Computes the MP2-based DispE20 and Exch-DispE20 energy without S^2. unify(self); Produce unified matrices for A', B', and C'. unify_part2(self); Finish producing unified matrices for A', B', and C'. vectors(self); Return the interally computed vectors (not copied). Methods Documentation. coulomb(self: psi4.core.FISAPT)  None; Build the J/K potentials for C, D, and E. dHF(self: psi4.core.FISAPT)  None; SAPT0 delta HF. disp(self: psi4.core.FISAPT, arg0: dict[str, psi4.core.Matrix], arg1: dict[str, psi4.core.Vector], arg2: ",MatchSource.WIKI,psi4manual/master/api/psi4.core.FISAPT.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.FISAPT.html
https://psicode.org/psi4manual/master/api/psi4.core.FISAPT.html:1519,Energy Efficiency,energy,energy,1519,"0 electrostatics. exch(self); SAPT0 exchange. fdisp(self); F-SAPT0 dispersion. felst(self); F-SAPT0 electrostatics. fexch(self); F-SAPT0 exchange. find(self); F-SAPT0 induction. flocalize(self); F-SAPT0 localize. freeze_core(self); Freeze the core orbitals. ind(self); SAPT0 induction. kinetic(self); Build the kinetic integrals T. localize(self); Localize the active occupied orbitals via IBO2. matrices(self); Return the interally computed matrices (not copied). molecule(self); Returns the FISAPT's molecule. nuclear(self); Build the nuclear potentials V and interaction energies. overlap(self); Build the overlap integrals S. partition(self); Partition the nuclei and electrons. print_header(self); Print header, bases, sizes, etc. print_trailer(self); Print SAPT results. raw_plot(self,arg0); Plot some analysis files. scalars(self); Return the interally computed scalars (not copied). scf(self); Solve the relaxed SCF equations for A0 and B0. sinf_disp(self,arg0,arg1,arg2); Computes the MP2-based DispE20 and Exch-DispE20 energy without S^2. unify(self); Produce unified matrices for A', B', and C'. unify_part2(self); Finish producing unified matrices for A', B', and C'. vectors(self); Return the interally computed vectors (not copied). Methods Documentation. coulomb(self: psi4.core.FISAPT)  None; Build the J/K potentials for C, D, and E. dHF(self: psi4.core.FISAPT)  None; SAPT0 delta HF. disp(self: psi4.core.FISAPT, arg0: dict[str, psi4.core.Matrix], arg1: dict[str, psi4.core.Vector], arg2: bool)  None; Computes the MP2-based DispE20 and Exch-DispE20 energy. do_cubes(self: psi4.core.FISAPT)  None; Prepare cube files for orbital/density pictures. elst(self: psi4.core.FISAPT)  None; SAPT0 electrostatics. exch(self: psi4.core.FISAPT)  None; SAPT0 exchange. fdisp(self: psi4.core.FISAPT)  None; F-SAPT0 dispersion. felst(self: psi4.core.FISAPT)  None; F-SAPT0 electrostatics. fexch(self: psi4.core.FISAPT)  None; F-SAPT0 exchange. find(self: psi4.core.FISAPT)  ",MatchSource.WIKI,psi4manual/master/api/psi4.core.FISAPT.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.FISAPT.html
https://psicode.org/psi4manual/master/api/psi4.core.FISAPT.html:2064,Energy Efficiency,energy,energy,2064,"ar potentials V and interaction energies. overlap(self); Build the overlap integrals S. partition(self); Partition the nuclei and electrons. print_header(self); Print header, bases, sizes, etc. print_trailer(self); Print SAPT results. raw_plot(self,arg0); Plot some analysis files. scalars(self); Return the interally computed scalars (not copied). scf(self); Solve the relaxed SCF equations for A0 and B0. sinf_disp(self,arg0,arg1,arg2); Computes the MP2-based DispE20 and Exch-DispE20 energy without S^2. unify(self); Produce unified matrices for A', B', and C'. unify_part2(self); Finish producing unified matrices for A', B', and C'. vectors(self); Return the interally computed vectors (not copied). Methods Documentation. coulomb(self: psi4.core.FISAPT)  None; Build the J/K potentials for C, D, and E. dHF(self: psi4.core.FISAPT)  None; SAPT0 delta HF. disp(self: psi4.core.FISAPT, arg0: dict[str, psi4.core.Matrix], arg1: dict[str, psi4.core.Vector], arg2: bool)  None; Computes the MP2-based DispE20 and Exch-DispE20 energy. do_cubes(self: psi4.core.FISAPT)  None; Prepare cube files for orbital/density pictures. elst(self: psi4.core.FISAPT)  None; SAPT0 electrostatics. exch(self: psi4.core.FISAPT)  None; SAPT0 exchange. fdisp(self: psi4.core.FISAPT)  None; F-SAPT0 dispersion. felst(self: psi4.core.FISAPT)  None; F-SAPT0 electrostatics. fexch(self: psi4.core.FISAPT)  None; F-SAPT0 exchange. find(self: psi4.core.FISAPT)  None; F-SAPT0 induction. flocalize(self: psi4.core.FISAPT)  None; F-SAPT0 localize. freeze_core(self: psi4.core.FISAPT)  None; Freeze the core orbitals. ind(self: psi4.core.FISAPT)  None; SAPT0 induction. kinetic(self: psi4.core.FISAPT)  None; Build the kinetic integrals T. localize(self: psi4.core.FISAPT)  None; Localize the active occupied orbitals via IBO2. matrices(self: psi4.core.FISAPT)  dict[str, psi4.core.Matrix]; Return the interally computed matrices (not copied). molecule(self: psi4.core.FISAPT)  psi4.core.Molec",MatchSource.WIKI,psi4manual/master/api/psi4.core.FISAPT.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.FISAPT.html
https://psicode.org/psi4manual/master/api/psi4.core.FISAPT.html:3902,Energy Efficiency,energy,energy,3902,"lf: psi4.core.FISAPT)  dict[str, psi4.core.Matrix]; Return the interally computed matrices (not copied). molecule(self: psi4.core.FISAPT)  psi4.core.Molecule; Returns the FISAPTs molecule. nuclear(self: psi4.core.FISAPT)  None; Build the nuclear potentials V and interaction energies. overlap(self: psi4.core.FISAPT)  None; Build the overlap integrals S. partition(self: psi4.core.FISAPT)  None; Partition the nuclei and electrons. print_header(self: psi4.core.FISAPT)  None; Print header, bases, sizes, etc. print_trailer(self: psi4.core.FISAPT)  None; Print SAPT results. raw_plot(self: psi4.core.FISAPT, arg0: str)  None; Plot some analysis files. scalars(self: psi4.core.FISAPT)  dict[str, float]; Return the interally computed scalars (not copied). scf(self: psi4.core.FISAPT)  None; Solve the relaxed SCF equations for A0 and B0. sinf_disp(self: psi4.core.FISAPT, arg0: dict[str, psi4.core.Matrix], arg1: dict[str, psi4.core.Vector], arg2: bool)  None; Computes the MP2-based DispE20 and Exch-DispE20 energy without S^2. unify(self: psi4.core.FISAPT)  None; Produce unified matrices for A, B, and C. unify_part2(self: psi4.core.FISAPT)  None; Finish producing unified matrices for A, B, and C. vectors(self: psi4.core.FISAPT)  dict[str, psi4.core.Vector]; Return the interally computed vectors (not copied). table of contents. FISAPT; FISAPT; FISAPT.coulomb(); FISAPT.dHF(); FISAPT.disp(); FISAPT.do_cubes(); FISAPT.elst(); FISAPT.exch(); FISAPT.fdisp(); FISAPT.felst(); FISAPT.fexch(); FISAPT.find(); FISAPT.flocalize(); FISAPT.freeze_core(); FISAPT.ind(); FISAPT.kinetic(); FISAPT.localize(); FISAPT.matrices(); FISAPT.molecule(); FISAPT.nuclear(); FISAPT.overlap(); FISAPT.partition(); FISAPT.print_header(); FISAPT.print_trailer(); FISAPT.raw_plot(); FISAPT.scalars(); FISAPT.scf(); FISAPT.sinf_disp(); FISAPT.unify(); FISAPT.unify_part2(); FISAPT.vectors(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev6",MatchSource.WIKI,psi4manual/master/api/psi4.core.FISAPT.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.FISAPT.html
https://psicode.org/psi4manual/master/api/psi4.core.FittedSlaterCorrelationFactor.html:761,Deployability,update,updated,761,". FittedSlaterCorrelationFactor. Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; FittedSlaterCorrelationFactor. FittedSlaterCorrelationFactor. class psi4.core.FittedSlaterCorrelationFactor; Bases: CorrelationFactor; docstring; Methods Summary. exponent(self). Methods Documentation. exponent(self: psi4.core.FittedSlaterCorrelationFactor)  float. table of contents. FittedSlaterCorrelationFactor; FittedSlaterCorrelationFactor; FittedSlaterCorrelationFactor.exponent(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; FittedSlaterCorrelationFactor.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/api/psi4.core.FittedSlaterCorrelationFactor.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.FittedSlaterCorrelationFactor.html
https://psicode.org/psi4manual/master/api/psi4.core.FittingMetric.html:2061,Deployability,update,updated,2061,"ic. FittingMetric. class psi4.core.FittingMetric; Bases: pybind11_object; docstring; Methods Summary. form_QR_inverse(self,arg0); docstring. form_cholesky_inverse(self); docstring. form_eig_inverse(self,arg0); docstring. form_fitting_metric(self); docstring. form_full_inverse(self); docstring. get_algorithm(self); docstring. get_metric(self); docstring. get_pivots(self); docstring. get_reverse_pivots(self); docstring. is_inverted(self); docstring. is_poisson(self); docstring. Methods Documentation. form_QR_inverse(self: psi4.core.FittingMetric, arg0: float)  None; docstring. form_cholesky_inverse(self: psi4.core.FittingMetric)  None; docstring. form_eig_inverse(self: psi4.core.FittingMetric, arg0: float)  None; docstring. form_fitting_metric(self: psi4.core.FittingMetric)  None; docstring. form_full_inverse(self: psi4.core.FittingMetric)  None; docstring. get_algorithm(self: psi4.core.FittingMetric)  str; docstring. get_metric(self: psi4.core.FittingMetric)  psi4.core.Matrix; docstring. get_pivots(self: psi4.core.FittingMetric)  psi4.core.IntVector; docstring. get_reverse_pivots(self: psi4.core.FittingMetric)  psi4.core.IntVector; docstring. is_inverted(self: psi4.core.FittingMetric)  bool; docstring. is_poisson(self: psi4.core.FittingMetric)  bool; docstring. table of contents. FittingMetric; FittingMetric; FittingMetric.form_QR_inverse(); FittingMetric.form_cholesky_inverse(); FittingMetric.form_eig_inverse(); FittingMetric.form_fitting_metric(); FittingMetric.form_full_inverse(); FittingMetric.get_algorithm(); FittingMetric.get_metric(); FittingMetric.get_pivots(); FittingMetric.get_reverse_pivots(); FittingMetric.is_inverted(); FittingMetric.is_poisson(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; FittingMetric.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/api/psi4.core.FittingMetric.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.FittingMetric.html
https://psicode.org/psi4manual/master/api/psi4.core.flush_outfile.html:478,Deployability,update,updated,478,". flush_outfile. Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; flush_outfile. flush_outfile. psi4.core.flush_outfile()  None; Flushes the output file. table of contents. flush_outfile; flush_outfile(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; flush_outfile.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/api/psi4.core.flush_outfile.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.flush_outfile.html
https://psicode.org/psi4manual/master/api/psi4.core.fnocc.html:498,Deployability,update,updated,498,". fnocc. Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; fnocc. fnocc. psi4.core.fnocc(ref_wfn: psi4.core.Wavefunction)  psi4.core.Wavefunction; Runs the FNO-CCSD(T)/QCISD(T)/MP4/CEPA energy code. table of contents. fnocc; fnocc(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; fnocc.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/api/psi4.core.fnocc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.fnocc.html
https://psicode.org/psi4manual/master/api/psi4.core.fnocc.html:251,Energy Efficiency,energy,energy,251,". fnocc. Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; fnocc. fnocc. psi4.core.fnocc(ref_wfn: psi4.core.Wavefunction)  psi4.core.Wavefunction; Runs the FNO-CCSD(T)/QCISD(T)/MP4/CEPA energy code. table of contents. fnocc; fnocc(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; fnocc.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/api/psi4.core.fnocc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.fnocc.html
https://psicode.org/psi4manual/master/api/psi4.core.FragmentType.html:820,Deployability,update,updated,820,". FragmentType. Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; FragmentType. FragmentType. class psi4.core.FragmentType; Bases: pybind11_object; Fragment activation status; Members:. Absent; Real; Ghost. Attributes Summary. Absent. Ghost. Real. name. value. Attributes Documentation. Absent = <FragmentType.Absent: 0>. Ghost = <FragmentType.Ghost: 2>. Real = <FragmentType.Real: 1>. name. value. table of contents. FragmentType; FragmentType; FragmentType.Absent; FragmentType.Ghost; FragmentType.Real; FragmentType.name; FragmentType.value. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; FragmentType.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/api/psi4.core.FragmentType.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.FragmentType.html
https://psicode.org/psi4manual/master/api/psi4.core.Functional.html:3819,Deployability,update,updated,3819," str; docstring. omega(self: psi4.core.Functional)  float; docstring. print_detail(self: psi4.core.Functional, arg0: int)  None; docstring. print_out(self: psi4.core.Functional)  None; docstring. set_alpha(self: psi4.core.Functional, arg0: float)  None; docstring. set_citation(self: psi4.core.Functional, arg0: str)  None; docstring. set_density_cutoff(self: psi4.core.Functional, arg0: float)  None; docstring. set_description(self: psi4.core.Functional, arg0: str)  None; docstring. set_gga(self: psi4.core.Functional, arg0: bool)  None; docstring. set_lsda_cutoff(self: psi4.core.Functional, arg0: float)  None; docstring. set_meta(self: psi4.core.Functional, arg0: bool)  None; docstring. set_meta_cutoff(self: psi4.core.Functional, arg0: float)  None; docstring. set_name(self: psi4.core.Functional, arg0: str)  None; docstring. set_omega(self: psi4.core.Functional, arg0: float)  None; docstring. set_parameter(self: psi4.core.Functional, arg0: str, arg1: float)  None; docstring. table of contents. Functional; Functional; Functional.alpha(); Functional.build_base(); Functional.citation(); Functional.compute_functional(); Functional.density_cutoff(); Functional.description(); Functional.is_gga(); Functional.is_lrc(); Functional.is_meta(); Functional.lsda_cutoff(); Functional.meta_cutoff(); Functional.name(); Functional.omega(); Functional.print_detail(); Functional.print_out(); Functional.set_alpha(); Functional.set_citation(); Functional.set_density_cutoff(); Functional.set_description(); Functional.set_gga(); Functional.set_lsda_cutoff(); Functional.set_meta(); Functional.set_meta_cutoff(); Functional.set_name(); Functional.set_omega(); Functional.set_parameter(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; Functional.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/api/psi4.core.Functional.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.Functional.html
https://psicode.org/psi4manual/master/api/psi4.core.GaussianShell.html:3239,Deployability,update,updated,3239,"tation. AMCHAR; The upper-case character symbol for the angular momentum of the given contraction. am; The angular momentum of the given contraction. amchar; The character symbol for the angular momentum of the given contraction. function_index; Basis function index where this shell starts. ncartesian; Total number of basis functions if this shell was Cartesian. ncenter; Returns atom number this shell is on. nfunction; Total number of basis functions. nprimitive; The number of primitive gaussians. Methods Documentation. coef(self: psi4.core.GaussianShell, pi: int)  float; Return coefficient of the pith primitive. coord(self: psi4.core.GaussianShell, arg0: int)  float; Returns ith coordinate this shell is on. erd_coef(self: psi4.core.GaussianShell, pi: int)  float; Return ERD normalized coefficient of pith primitive. exp(self: psi4.core.GaussianShell, prim: int)  float; Returns the exponent of the given primitive. is_cartesian(self: psi4.core.GaussianShell)  bool; Returns true if the contraction is Cartesian. is_pure(self: psi4.core.GaussianShell)  bool; Returns true if the contraction is pure, i.e. a spherical harmonic basis function. original_coef(self: psi4.core.GaussianShell, pi: int)  float; Return unnormalized coefficient of the pith primitive. table of contents. GaussianShell; GaussianShell; GaussianShell.AMCHAR; GaussianShell.am; GaussianShell.amchar; GaussianShell.function_index; GaussianShell.ncartesian; GaussianShell.ncenter; GaussianShell.nfunction; GaussianShell.nprimitive; GaussianShell.coef(); GaussianShell.coord(); GaussianShell.erd_coef(); GaussianShell.exp(); GaussianShell.is_cartesian(); GaussianShell.is_pure(); GaussianShell.original_coef(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; GaussianShell.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/api/psi4.core.GaussianShell.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.GaussianShell.html
https://psicode.org/psi4manual/master/api/psi4.core.GaussianShell.html:366,Integrability,contract,contraction,366,". GaussianShell. Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; GaussianShell. GaussianShell. class psi4.core.GaussianShell; Bases: pybind11_object; Class containing information about basis functions; Attributes Summary. AMCHAR; The upper-case character symbol for the angular momentum of the given contraction. am; The angular momentum of the given contraction. amchar; The character symbol for the angular momentum of the given contraction. function_index; Basis function index where this shell starts. ncartesian; Total number of basis functions if this shell was Cartesian. ncenter; Returns atom number this shell is on. nfunction; Total number of basis functions. nprimitive; The number of primitive gaussians. Methods Summary. coef(self,pi); Return coefficient of the pi'th primitive. coord(self,arg0); Returns ith coordinate this shell is on. erd_coef(self,pi); Return ERD normalized coefficient of pi'th primitive. exp(self,prim); Returns the exponent of the given primitive. is_cartesian(self); Returns true if the contraction is Cartesian. is_pure(self); Returns true if the contraction is pure, i.e. a spherical harmonic basis function. original_coef(self,pi); Return unnormalized coefficient of the pi'th primitive. Attributes Documentation. AMCHAR; The upper-case character symbol for the angular momentum of the given contraction. am; The angular momentum of the given contraction. amchar; The character symbol for the angular momentum of the given contraction. function_index; Basis function index where this shell starts. ncartesian; Total number of basis functions if this shell was Cartesian. ncenter; Returns atom number this shell is on. nfunction; Total number of basis functions. nprimitive; The number of primitive gaussians. Methods Documentation. coef(self: psi4.core.GaussianShell, pi: int)  float; Return coefficient of the pith primitive. coord(self: psi4.core.GaussianShell, arg0: int)  f",MatchSource.WIKI,psi4manual/master/api/psi4.core.GaussianShell.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.GaussianShell.html
https://psicode.org/psi4manual/master/api/psi4.core.GaussianShell.html:417,Integrability,contract,contraction,417,". GaussianShell. Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; GaussianShell. GaussianShell. class psi4.core.GaussianShell; Bases: pybind11_object; Class containing information about basis functions; Attributes Summary. AMCHAR; The upper-case character symbol for the angular momentum of the given contraction. am; The angular momentum of the given contraction. amchar; The character symbol for the angular momentum of the given contraction. function_index; Basis function index where this shell starts. ncartesian; Total number of basis functions if this shell was Cartesian. ncenter; Returns atom number this shell is on. nfunction; Total number of basis functions. nprimitive; The number of primitive gaussians. Methods Summary. coef(self,pi); Return coefficient of the pi'th primitive. coord(self,arg0); Returns ith coordinate this shell is on. erd_coef(self,pi); Return ERD normalized coefficient of pi'th primitive. exp(self,prim); Returns the exponent of the given primitive. is_cartesian(self); Returns true if the contraction is Cartesian. is_pure(self); Returns true if the contraction is pure, i.e. a spherical harmonic basis function. original_coef(self,pi); Return unnormalized coefficient of the pi'th primitive. Attributes Documentation. AMCHAR; The upper-case character symbol for the angular momentum of the given contraction. am; The angular momentum of the given contraction. amchar; The character symbol for the angular momentum of the given contraction. function_index; Basis function index where this shell starts. ncartesian; Total number of basis functions if this shell was Cartesian. ncenter; Returns atom number this shell is on. nfunction; Total number of basis functions. nprimitive; The number of primitive gaussians. Methods Documentation. coef(self: psi4.core.GaussianShell, pi: int)  float; Return coefficient of the pith primitive. coord(self: psi4.core.GaussianShell, arg0: int)  f",MatchSource.WIKI,psi4manual/master/api/psi4.core.GaussianShell.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.GaussianShell.html
https://psicode.org/psi4manual/master/api/psi4.core.GaussianShell.html:497,Integrability,contract,contraction,497,". GaussianShell. Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; GaussianShell. GaussianShell. class psi4.core.GaussianShell; Bases: pybind11_object; Class containing information about basis functions; Attributes Summary. AMCHAR; The upper-case character symbol for the angular momentum of the given contraction. am; The angular momentum of the given contraction. amchar; The character symbol for the angular momentum of the given contraction. function_index; Basis function index where this shell starts. ncartesian; Total number of basis functions if this shell was Cartesian. ncenter; Returns atom number this shell is on. nfunction; Total number of basis functions. nprimitive; The number of primitive gaussians. Methods Summary. coef(self,pi); Return coefficient of the pi'th primitive. coord(self,arg0); Returns ith coordinate this shell is on. erd_coef(self,pi); Return ERD normalized coefficient of pi'th primitive. exp(self,prim); Returns the exponent of the given primitive. is_cartesian(self); Returns true if the contraction is Cartesian. is_pure(self); Returns true if the contraction is pure, i.e. a spherical harmonic basis function. original_coef(self,pi); Return unnormalized coefficient of the pi'th primitive. Attributes Documentation. AMCHAR; The upper-case character symbol for the angular momentum of the given contraction. am; The angular momentum of the given contraction. amchar; The character symbol for the angular momentum of the given contraction. function_index; Basis function index where this shell starts. ncartesian; Total number of basis functions if this shell was Cartesian. ncenter; Returns atom number this shell is on. nfunction; Total number of basis functions. nprimitive; The number of primitive gaussians. Methods Documentation. coef(self: psi4.core.GaussianShell, pi: int)  float; Return coefficient of the pith primitive. coord(self: psi4.core.GaussianShell, arg0: int)  f",MatchSource.WIKI,psi4manual/master/api/psi4.core.GaussianShell.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.GaussianShell.html
https://psicode.org/psi4manual/master/api/psi4.core.GaussianShell.html:1095,Integrability,contract,contraction,1095,". PSI4. PSI4 API: Linking C++ and Python; GaussianShell. GaussianShell. class psi4.core.GaussianShell; Bases: pybind11_object; Class containing information about basis functions; Attributes Summary. AMCHAR; The upper-case character symbol for the angular momentum of the given contraction. am; The angular momentum of the given contraction. amchar; The character symbol for the angular momentum of the given contraction. function_index; Basis function index where this shell starts. ncartesian; Total number of basis functions if this shell was Cartesian. ncenter; Returns atom number this shell is on. nfunction; Total number of basis functions. nprimitive; The number of primitive gaussians. Methods Summary. coef(self,pi); Return coefficient of the pi'th primitive. coord(self,arg0); Returns ith coordinate this shell is on. erd_coef(self,pi); Return ERD normalized coefficient of pi'th primitive. exp(self,prim); Returns the exponent of the given primitive. is_cartesian(self); Returns true if the contraction is Cartesian. is_pure(self); Returns true if the contraction is pure, i.e. a spherical harmonic basis function. original_coef(self,pi); Return unnormalized coefficient of the pi'th primitive. Attributes Documentation. AMCHAR; The upper-case character symbol for the angular momentum of the given contraction. am; The angular momentum of the given contraction. amchar; The character symbol for the angular momentum of the given contraction. function_index; Basis function index where this shell starts. ncartesian; Total number of basis functions if this shell was Cartesian. ncenter; Returns atom number this shell is on. nfunction; Total number of basis functions. nprimitive; The number of primitive gaussians. Methods Documentation. coef(self: psi4.core.GaussianShell, pi: int)  float; Return coefficient of the pith primitive. coord(self: psi4.core.GaussianShell, arg0: int)  float; Returns ith coordinate this shell is on. erd_coef(self: psi4.core.GaussianShell",MatchSource.WIKI,psi4manual/master/api/psi4.core.GaussianShell.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.GaussianShell.html
https://psicode.org/psi4manual/master/api/psi4.core.GaussianShell.html:1156,Integrability,contract,contraction,1156,"ianShell. class psi4.core.GaussianShell; Bases: pybind11_object; Class containing information about basis functions; Attributes Summary. AMCHAR; The upper-case character symbol for the angular momentum of the given contraction. am; The angular momentum of the given contraction. amchar; The character symbol for the angular momentum of the given contraction. function_index; Basis function index where this shell starts. ncartesian; Total number of basis functions if this shell was Cartesian. ncenter; Returns atom number this shell is on. nfunction; Total number of basis functions. nprimitive; The number of primitive gaussians. Methods Summary. coef(self,pi); Return coefficient of the pi'th primitive. coord(self,arg0); Returns ith coordinate this shell is on. erd_coef(self,pi); Return ERD normalized coefficient of pi'th primitive. exp(self,prim); Returns the exponent of the given primitive. is_cartesian(self); Returns true if the contraction is Cartesian. is_pure(self); Returns true if the contraction is pure, i.e. a spherical harmonic basis function. original_coef(self,pi); Return unnormalized coefficient of the pi'th primitive. Attributes Documentation. AMCHAR; The upper-case character symbol for the angular momentum of the given contraction. am; The angular momentum of the given contraction. amchar; The character symbol for the angular momentum of the given contraction. function_index; Basis function index where this shell starts. ncartesian; Total number of basis functions if this shell was Cartesian. ncenter; Returns atom number this shell is on. nfunction; Total number of basis functions. nprimitive; The number of primitive gaussians. Methods Documentation. coef(self: psi4.core.GaussianShell, pi: int)  float; Return coefficient of the pith primitive. coord(self: psi4.core.GaussianShell, arg0: int)  float; Returns ith coordinate this shell is on. erd_coef(self: psi4.core.GaussianShell, pi: int)  float; Return ERD normalized coefficient of pith",MatchSource.WIKI,psi4manual/master/api/psi4.core.GaussianShell.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.GaussianShell.html
https://psicode.org/psi4manual/master/api/psi4.core.GaussianShell.html:1405,Integrability,contract,contraction,1405,"action. am; The angular momentum of the given contraction. amchar; The character symbol for the angular momentum of the given contraction. function_index; Basis function index where this shell starts. ncartesian; Total number of basis functions if this shell was Cartesian. ncenter; Returns atom number this shell is on. nfunction; Total number of basis functions. nprimitive; The number of primitive gaussians. Methods Summary. coef(self,pi); Return coefficient of the pi'th primitive. coord(self,arg0); Returns ith coordinate this shell is on. erd_coef(self,pi); Return ERD normalized coefficient of pi'th primitive. exp(self,prim); Returns the exponent of the given primitive. is_cartesian(self); Returns true if the contraction is Cartesian. is_pure(self); Returns true if the contraction is pure, i.e. a spherical harmonic basis function. original_coef(self,pi); Return unnormalized coefficient of the pi'th primitive. Attributes Documentation. AMCHAR; The upper-case character symbol for the angular momentum of the given contraction. am; The angular momentum of the given contraction. amchar; The character symbol for the angular momentum of the given contraction. function_index; Basis function index where this shell starts. ncartesian; Total number of basis functions if this shell was Cartesian. ncenter; Returns atom number this shell is on. nfunction; Total number of basis functions. nprimitive; The number of primitive gaussians. Methods Documentation. coef(self: psi4.core.GaussianShell, pi: int)  float; Return coefficient of the pith primitive. coord(self: psi4.core.GaussianShell, arg0: int)  float; Returns ith coordinate this shell is on. erd_coef(self: psi4.core.GaussianShell, pi: int)  float; Return ERD normalized coefficient of pith primitive. exp(self: psi4.core.GaussianShell, prim: int)  float; Returns the exponent of the given primitive. is_cartesian(self: psi4.core.GaussianShell)  bool; Returns true if the contraction is Cartesian. is_pure(s",MatchSource.WIKI,psi4manual/master/api/psi4.core.GaussianShell.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.GaussianShell.html
https://psicode.org/psi4manual/master/api/psi4.core.GaussianShell.html:1457,Integrability,contract,contraction,1457,"haracter symbol for the angular momentum of the given contraction. function_index; Basis function index where this shell starts. ncartesian; Total number of basis functions if this shell was Cartesian. ncenter; Returns atom number this shell is on. nfunction; Total number of basis functions. nprimitive; The number of primitive gaussians. Methods Summary. coef(self,pi); Return coefficient of the pi'th primitive. coord(self,arg0); Returns ith coordinate this shell is on. erd_coef(self,pi); Return ERD normalized coefficient of pi'th primitive. exp(self,prim); Returns the exponent of the given primitive. is_cartesian(self); Returns true if the contraction is Cartesian. is_pure(self); Returns true if the contraction is pure, i.e. a spherical harmonic basis function. original_coef(self,pi); Return unnormalized coefficient of the pi'th primitive. Attributes Documentation. AMCHAR; The upper-case character symbol for the angular momentum of the given contraction. am; The angular momentum of the given contraction. amchar; The character symbol for the angular momentum of the given contraction. function_index; Basis function index where this shell starts. ncartesian; Total number of basis functions if this shell was Cartesian. ncenter; Returns atom number this shell is on. nfunction; Total number of basis functions. nprimitive; The number of primitive gaussians. Methods Documentation. coef(self: psi4.core.GaussianShell, pi: int)  float; Return coefficient of the pith primitive. coord(self: psi4.core.GaussianShell, arg0: int)  float; Returns ith coordinate this shell is on. erd_coef(self: psi4.core.GaussianShell, pi: int)  float; Return ERD normalized coefficient of pith primitive. exp(self: psi4.core.GaussianShell, prim: int)  float; Returns the exponent of the given primitive. is_cartesian(self: psi4.core.GaussianShell)  bool; Returns true if the contraction is Cartesian. is_pure(self: psi4.core.GaussianShell)  bool; Returns true if the contraction i",MatchSource.WIKI,psi4manual/master/api/psi4.core.GaussianShell.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.GaussianShell.html
https://psicode.org/psi4manual/master/api/psi4.core.GaussianShell.html:1538,Integrability,contract,contraction,1538," function_index; Basis function index where this shell starts. ncartesian; Total number of basis functions if this shell was Cartesian. ncenter; Returns atom number this shell is on. nfunction; Total number of basis functions. nprimitive; The number of primitive gaussians. Methods Summary. coef(self,pi); Return coefficient of the pi'th primitive. coord(self,arg0); Returns ith coordinate this shell is on. erd_coef(self,pi); Return ERD normalized coefficient of pi'th primitive. exp(self,prim); Returns the exponent of the given primitive. is_cartesian(self); Returns true if the contraction is Cartesian. is_pure(self); Returns true if the contraction is pure, i.e. a spherical harmonic basis function. original_coef(self,pi); Return unnormalized coefficient of the pi'th primitive. Attributes Documentation. AMCHAR; The upper-case character symbol for the angular momentum of the given contraction. am; The angular momentum of the given contraction. amchar; The character symbol for the angular momentum of the given contraction. function_index; Basis function index where this shell starts. ncartesian; Total number of basis functions if this shell was Cartesian. ncenter; Returns atom number this shell is on. nfunction; Total number of basis functions. nprimitive; The number of primitive gaussians. Methods Documentation. coef(self: psi4.core.GaussianShell, pi: int)  float; Return coefficient of the pith primitive. coord(self: psi4.core.GaussianShell, arg0: int)  float; Returns ith coordinate this shell is on. erd_coef(self: psi4.core.GaussianShell, pi: int)  float; Return ERD normalized coefficient of pith primitive. exp(self: psi4.core.GaussianShell, prim: int)  float; Returns the exponent of the given primitive. is_cartesian(self: psi4.core.GaussianShell)  bool; Returns true if the contraction is Cartesian. is_pure(self: psi4.core.GaussianShell)  bool; Returns true if the contraction is pure, i.e. a spherical harmonic basis function. original_coef(sel",MatchSource.WIKI,psi4manual/master/api/psi4.core.GaussianShell.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.GaussianShell.html
https://psicode.org/psi4manual/master/api/psi4.core.GaussianShell.html:2336,Integrability,contract,contraction,2336,"tation. AMCHAR; The upper-case character symbol for the angular momentum of the given contraction. am; The angular momentum of the given contraction. amchar; The character symbol for the angular momentum of the given contraction. function_index; Basis function index where this shell starts. ncartesian; Total number of basis functions if this shell was Cartesian. ncenter; Returns atom number this shell is on. nfunction; Total number of basis functions. nprimitive; The number of primitive gaussians. Methods Documentation. coef(self: psi4.core.GaussianShell, pi: int)  float; Return coefficient of the pith primitive. coord(self: psi4.core.GaussianShell, arg0: int)  float; Returns ith coordinate this shell is on. erd_coef(self: psi4.core.GaussianShell, pi: int)  float; Return ERD normalized coefficient of pith primitive. exp(self: psi4.core.GaussianShell, prim: int)  float; Returns the exponent of the given primitive. is_cartesian(self: psi4.core.GaussianShell)  bool; Returns true if the contraction is Cartesian. is_pure(self: psi4.core.GaussianShell)  bool; Returns true if the contraction is pure, i.e. a spherical harmonic basis function. original_coef(self: psi4.core.GaussianShell, pi: int)  float; Return unnormalized coefficient of the pith primitive. table of contents. GaussianShell; GaussianShell; GaussianShell.AMCHAR; GaussianShell.am; GaussianShell.amchar; GaussianShell.function_index; GaussianShell.ncartesian; GaussianShell.ncenter; GaussianShell.nfunction; GaussianShell.nprimitive; GaussianShell.coef(); GaussianShell.coord(); GaussianShell.erd_coef(); GaussianShell.exp(); GaussianShell.is_cartesian(); GaussianShell.is_pure(); GaussianShell.original_coef(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; GaussianShell.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/api/psi4.core.GaussianShell.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.GaussianShell.html
https://psicode.org/psi4manual/master/api/psi4.core.GaussianShell.html:2430,Integrability,contract,contraction,2430,"tation. AMCHAR; The upper-case character symbol for the angular momentum of the given contraction. am; The angular momentum of the given contraction. amchar; The character symbol for the angular momentum of the given contraction. function_index; Basis function index where this shell starts. ncartesian; Total number of basis functions if this shell was Cartesian. ncenter; Returns atom number this shell is on. nfunction; Total number of basis functions. nprimitive; The number of primitive gaussians. Methods Documentation. coef(self: psi4.core.GaussianShell, pi: int)  float; Return coefficient of the pith primitive. coord(self: psi4.core.GaussianShell, arg0: int)  float; Returns ith coordinate this shell is on. erd_coef(self: psi4.core.GaussianShell, pi: int)  float; Return ERD normalized coefficient of pith primitive. exp(self: psi4.core.GaussianShell, prim: int)  float; Returns the exponent of the given primitive. is_cartesian(self: psi4.core.GaussianShell)  bool; Returns true if the contraction is Cartesian. is_pure(self: psi4.core.GaussianShell)  bool; Returns true if the contraction is pure, i.e. a spherical harmonic basis function. original_coef(self: psi4.core.GaussianShell, pi: int)  float; Return unnormalized coefficient of the pith primitive. table of contents. GaussianShell; GaussianShell; GaussianShell.AMCHAR; GaussianShell.am; GaussianShell.amchar; GaussianShell.function_index; GaussianShell.ncartesian; GaussianShell.ncenter; GaussianShell.nfunction; GaussianShell.nprimitive; GaussianShell.coef(); GaussianShell.coord(); GaussianShell.erd_coef(); GaussianShell.exp(); GaussianShell.is_cartesian(); GaussianShell.is_pure(); GaussianShell.original_coef(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; GaussianShell.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/api/psi4.core.GaussianShell.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.GaussianShell.html
https://psicode.org/psi4manual/master/api/psi4.core.GaussianType.html:808,Deployability,update,updated,808,". GaussianType. Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; GaussianType. GaussianType. class psi4.core.GaussianType; Bases: pybind11_object; 0 if Cartesian, 1 if Pure; Members:. Cartesian : (n+1)(n+2)/2 functions; Pure : 2n+1 functions. Attributes Summary. Cartesian. Pure. name. value. Attributes Documentation. Cartesian = <GaussianType.Cartesian: 0>. Pure = <GaussianType.Pure: 1>. name. value. table of contents. GaussianType; GaussianType; GaussianType.Cartesian; GaussianType.Pure; GaussianType.name; GaussianType.value. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; GaussianType.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/api/psi4.core.GaussianType.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.GaussianType.html
https://psicode.org/psi4manual/master/api/psi4.core.GeometryUnits.html:786,Deployability,update,updated,786,". GeometryUnits. Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; GeometryUnits. GeometryUnits. class psi4.core.GeometryUnits; Bases: pybind11_object; The units used to define the geometry; Members:. Angstrom; Bohr. Attributes Summary. Angstrom. Bohr. name. value. Attributes Documentation. Angstrom = <GeometryUnits.Angstrom: 0>. Bohr = <GeometryUnits.Bohr: 1>. name. value. table of contents. GeometryUnits; GeometryUnits; GeometryUnits.Angstrom; GeometryUnits.Bohr; GeometryUnits.name; GeometryUnits.value. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; GeometryUnits.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/api/psi4.core.GeometryUnits.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.GeometryUnits.html
https://psicode.org/psi4manual/master/api/psi4.core.get_active_molecule.html:555,Deployability,update,updated,555,". get_active_molecule. Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; get_active_molecule. get_active_molecule. psi4.core.get_active_molecule()  psi4.core.Molecule; Returns the currently active molecule object. table of contents. get_active_molecule; get_active_molecule(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; get_active_molecule.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/api/psi4.core.get_active_molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.get_active_molecule.html
https://psicode.org/psi4manual/master/api/psi4.core.get_array_variable.html:299,Availability,Error,Errors,299,". get_array_variable. Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; get_array_variable. get_array_variable. psi4.core.get_array_variable(key). Deprecated since version 1.4: Use psi4.core.variable() instead. Changed in version 1.9: Errors rather than warn-and-forward. table of contents. get_array_variable; get_array_variable(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; get_array_variable.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/api/psi4.core.get_array_variable.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.get_array_variable.html
https://psicode.org/psi4manual/master/api/psi4.core.get_array_variable.html:609,Deployability,update,updated,609,". get_array_variable. Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; get_array_variable. get_array_variable. psi4.core.get_array_variable(key). Deprecated since version 1.4: Use psi4.core.variable() instead. Changed in version 1.9: Errors rather than warn-and-forward. table of contents. get_array_variable; get_array_variable(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; get_array_variable.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/api/psi4.core.get_array_variable.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.get_array_variable.html
https://psicode.org/psi4manual/master/api/psi4.core.get_array_variable.html:255,Modifiability,variab,variable,255,". get_array_variable. Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; get_array_variable. get_array_variable. psi4.core.get_array_variable(key). Deprecated since version 1.4: Use psi4.core.variable() instead. Changed in version 1.9: Errors rather than warn-and-forward. table of contents. get_array_variable; get_array_variable(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; get_array_variable.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/api/psi4.core.get_array_variable.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.get_array_variable.html
https://psicode.org/psi4manual/master/api/psi4.core.get_array_variables.html:301,Availability,Error,Errors,301,". get_array_variables. Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; get_array_variables. get_array_variables. psi4.core.get_array_variables(). Deprecated since version 1.4: Use psi4.core.variables() instead. Changed in version 1.9: Errors rather than warn-and-forward. table of contents. get_array_variables; get_array_variables(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; get_array_variables.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/api/psi4.core.get_array_variables.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.get_array_variables.html
https://psicode.org/psi4manual/master/api/psi4.core.get_array_variables.html:614,Deployability,update,updated,614,". get_array_variables. Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; get_array_variables. get_array_variables. psi4.core.get_array_variables(). Deprecated since version 1.4: Use psi4.core.variables() instead. Changed in version 1.9: Errors rather than warn-and-forward. table of contents. get_array_variables; get_array_variables(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; get_array_variables.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/api/psi4.core.get_array_variables.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.get_array_variables.html
https://psicode.org/psi4manual/master/api/psi4.core.get_array_variables.html:256,Modifiability,variab,variables,256,". get_array_variables. Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; get_array_variables. get_array_variables. psi4.core.get_array_variables(). Deprecated since version 1.4: Use psi4.core.variables() instead. Changed in version 1.9: Errors rather than warn-and-forward. table of contents. get_array_variables; get_array_variables(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; get_array_variables.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/api/psi4.core.get_array_variables.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.get_array_variables.html
https://psicode.org/psi4manual/master/api/psi4.core.get_datadir.html:493,Deployability,update,updated,493,". get_datadir. Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; get_datadir. get_datadir. psi4.core.get_datadir()  str; Returns the path to shared text resources, PSIDATADIR. table of contents. get_datadir; get_datadir(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; get_datadir.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/api/psi4.core.get_datadir.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.get_datadir.html
https://psicode.org/psi4manual/master/api/psi4.core.get_global_option.html:401,Availability,error,error,401,". get_global_option. Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; get_global_option. get_global_option. psi4.core.get_global_option(key: str)  object; Return keyword key value at global (all-module) scope. Use psi4.core.get_option() for more common usage of negotiated value between global and local defaults and settings. Returns error if key is not recognized. table of contents. get_global_option; get_global_option(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; get_global_option.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/api/psi4.core.get_global_option.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.get_global_option.html
https://psicode.org/psi4manual/master/api/psi4.core.get_global_option.html:703,Deployability,update,updated,703,". get_global_option. Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; get_global_option. get_global_option. psi4.core.get_global_option(key: str)  object; Return keyword key value at global (all-module) scope. Use psi4.core.get_option() for more common usage of negotiated value between global and local defaults and settings. Returns error if key is not recognized. table of contents. get_global_option; get_global_option(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; get_global_option.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/api/psi4.core.get_global_option.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.get_global_option.html
https://psicode.org/psi4manual/master/api/psi4.core.get_global_option_list.html:559,Deployability,update,updated,559,". get_global_option_list. Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; get_global_option_list. get_global_option_list. psi4.core.get_global_option_list()  list[str]; Returns a list of all global options. table of contents. get_global_option_list; get_global_option_list(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; get_global_option_list.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/api/psi4.core.get_global_option_list.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.get_global_option_list.html
https://psicode.org/psi4manual/master/api/psi4.core.get_local_option.html:397,Availability,error,error,397,". get_local_option. Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; get_local_option. get_local_option. psi4.core.get_local_option(module: str, key: str)  object; Return keyword key value at module scope. Use psi4.core.get_option() for more common usage of negotiated value between global and local defaults and settings. Returns error if key is not recognized for the module. table of contents. get_local_option; get_local_option(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; get_local_option.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/api/psi4.core.get_local_option.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.get_local_option.html
https://psicode.org/psi4manual/master/api/psi4.core.get_local_option.html:711,Deployability,update,updated,711,". get_local_option. Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; get_local_option. get_local_option. psi4.core.get_local_option(module: str, key: str)  object; Return keyword key value at module scope. Use psi4.core.get_option() for more common usage of negotiated value between global and local defaults and settings. Returns error if key is not recognized for the module. table of contents. get_local_option; get_local_option(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; get_local_option.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/api/psi4.core.get_local_option.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.get_local_option.html
https://psicode.org/psi4manual/master/api/psi4.core.get_memory.html:211,Availability,avail,available,211,". get_memory. Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; get_memory. get_memory. psi4.core.get_memory()  int; Returns the amount of memory available to Psi (in bytes). table of contents. get_memory; get_memory(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; get_memory.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/api/psi4.core.get_memory.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.get_memory.html
https://psicode.org/psi4manual/master/api/psi4.core.get_memory.html:489,Deployability,update,updated,489,". get_memory. Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; get_memory. get_memory. psi4.core.get_memory()  int; Returns the amount of memory available to Psi (in bytes). table of contents. get_memory; get_memory(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; get_memory.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/api/psi4.core.get_memory.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.get_memory.html
https://psicode.org/psi4manual/master/api/psi4.core.get_num_threads.html:533,Deployability,update,updated,533,". get_num_threads. Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; get_num_threads. get_num_threads. psi4.core.get_num_threads()  int; Returns the number of threads to use in SMP parallel computations. table of contents. get_num_threads; get_num_threads(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; get_num_threads.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/api/psi4.core.get_num_threads.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.get_num_threads.html
https://psicode.org/psi4manual/master/api/psi4.core.get_option.html:395,Availability,error,error,395,". get_option. Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; get_option. get_option. psi4.core.get_option(module: str, key: str)  object; Return keyword key value used by module. Returns the local value associated with the keyword if its been set, else the global value if its been set, else the local default value. Returns error if key is not recognized globally or if key is not recognized for the module. table of contents. get_option; get_option(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; get_option.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/api/psi4.core.get_option.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.get_option.html
https://psicode.org/psi4manual/master/api/psi4.core.get_option.html:728,Deployability,update,updated,728,". get_option. Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; get_option. get_option. psi4.core.get_option(module: str, key: str)  object; Return keyword key value used by module. Returns the local value associated with the keyword if its been set, else the global value if its been set, else the local default value. Returns error if key is not recognized globally or if key is not recognized for the module. table of contents. get_option; get_option(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; get_option.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/api/psi4.core.get_option.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.get_option.html
https://psicode.org/psi4manual/master/api/psi4.core.get_options.html:465,Deployability,update,updated,465,". get_options. Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; get_options. get_options. psi4.core.get_options()  psi4.core.Options; Get options. table of contents. get_options; get_options(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; get_options.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/api/psi4.core.get_options.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.get_options.html
https://psicode.org/psi4manual/master/api/psi4.core.get_output_file.html:532,Deployability,update,updated,532,". get_output_file. Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; get_output_file. get_output_file. psi4.core.get_output_file()  str; Returns output file name (stem + suffix, no directory). stdout. table of contents. get_output_file; get_output_file(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; get_output_file.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/api/psi4.core.get_output_file.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.get_output_file.html
https://psicode.org/psi4manual/master/api/psi4.core.get_variable.html:275,Availability,Error,Errors,275,". get_variable. Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; get_variable. get_variable. psi4.core.get_variable(key). Deprecated since version 1.4: Use psi4.core.variable() instead. Changed in version 1.9: Errors rather than warn-and-forward. table of contents. get_variable; get_variable(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; get_variable.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/api/psi4.core.get_variable.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.get_variable.html
https://psicode.org/psi4manual/master/api/psi4.core.get_variable.html:567,Deployability,update,updated,567,". get_variable. Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; get_variable. get_variable. psi4.core.get_variable(key). Deprecated since version 1.4: Use psi4.core.variable() instead. Changed in version 1.9: Errors rather than warn-and-forward. table of contents. get_variable; get_variable(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; get_variable.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/api/psi4.core.get_variable.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.get_variable.html
https://psicode.org/psi4manual/master/api/psi4.core.get_variable.html:231,Modifiability,variab,variable,231,". get_variable. Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; get_variable. get_variable. psi4.core.get_variable(key). Deprecated since version 1.4: Use psi4.core.variable() instead. Changed in version 1.9: Errors rather than warn-and-forward. table of contents. get_variable; get_variable(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; get_variable.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/api/psi4.core.get_variable.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.get_variable.html
https://psicode.org/psi4manual/master/api/psi4.core.get_variables.html:277,Availability,Error,Errors,277,". get_variables. Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; get_variables. get_variables. psi4.core.get_variables(). Deprecated since version 1.4: Use psi4.core.variables() instead. Changed in version 1.9: Errors rather than warn-and-forward. table of contents. get_variables; get_variables(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; get_variables.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/api/psi4.core.get_variables.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.get_variables.html
https://psicode.org/psi4manual/master/api/psi4.core.get_variables.html:572,Deployability,update,updated,572,". get_variables. Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; get_variables. get_variables. psi4.core.get_variables(). Deprecated since version 1.4: Use psi4.core.variables() instead. Changed in version 1.9: Errors rather than warn-and-forward. table of contents. get_variables; get_variables(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; get_variables.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/api/psi4.core.get_variables.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.get_variables.html
https://psicode.org/psi4manual/master/api/psi4.core.get_variables.html:232,Modifiability,variab,variables,232,". get_variables. Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; get_variables. get_variables. psi4.core.get_variables(). Deprecated since version 1.4: Use psi4.core.variables() instead. Changed in version 1.9: Errors rather than warn-and-forward. table of contents. get_variables; get_variables(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; get_variables.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/api/psi4.core.get_variables.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.get_variables.html
https://psicode.org/psi4manual/master/api/psi4.core.get_writer_file_prefix.html:600,Deployability,update,updated,600,". get_writer_file_prefix. Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; get_writer_file_prefix. get_writer_file_prefix. psi4.core.get_writer_file_prefix(molecule_name: str)  str; Returns the prefix to use for writing files for external programs. table of contents. get_writer_file_prefix; get_writer_file_prefix(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; get_writer_file_prefix.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/api/psi4.core.get_writer_file_prefix.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.get_writer_file_prefix.html
https://psicode.org/psi4manual/master/api/psi4.core.git_version.html:469,Deployability,update,updated,469,". git_version. Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; git_version. git_version. psi4.core.git_version()  None. Deprecated since version 1.4. table of contents. git_version; git_version(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; git_version.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/api/psi4.core.git_version.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.git_version.html
https://psicode.org/psi4manual/master/api/psi4.core.has_array_variable.html:572,Deployability,update,updated,572,". has_array_variable. Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; has_array_variable. has_array_variable. psi4.core.has_array_variable(key: str)  bool; Is the Matrix QCVariable key (case-insensitive) set? Prefer has_variable(). table of contents. has_array_variable; has_array_variable(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; has_array_variable.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/api/psi4.core.has_array_variable.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.has_array_variable.html
https://psicode.org/psi4manual/master/api/psi4.core.has_global_option_changed.html:821,Deployability,update,updated,821,". has_global_option_changed. Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; has_global_option_changed. has_global_option_changed. psi4.core.has_global_option_changed(key: str)  bool; Whether keyword key value has been touched at global (all-module) scope. Has it been touched in the global scope, by either user or code. Notwithstanding, code is written such that in practice, this returns whether the option has been touched in the global scope by the user. table of contents. has_global_option_changed; has_global_option_changed(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; has_global_option_changed.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/api/psi4.core.has_global_option_changed.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.has_global_option_changed.html
https://psicode.org/psi4manual/master/api/psi4.core.has_local_option_changed.html:829,Deployability,update,updated,829,". has_local_option_changed. Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; has_local_option_changed. has_local_option_changed. psi4.core.has_local_option_changed(module: str, key: str)  bool; Whether keyword key value has been touched at module scope. Has it been touched in the scope of the specified module by either user or code.Notwithstanding, code is written such that in practice, this returns whether the option has been touched in the module scope by the user. table of contents. has_local_option_changed; has_local_option_changed(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; has_local_option_changed.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/api/psi4.core.has_local_option_changed.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.has_local_option_changed.html
https://psicode.org/psi4manual/master/api/psi4.core.has_option_changed.html:781,Deployability,update,updated,781,". has_option_changed. Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; has_option_changed. has_option_changed. psi4.core.has_option_changed(module: str, key: str)  bool; Whether keyword key value has been touched or is default. Has it been touched either locally to the specified module or globally, by either user or code. Notwithstanding, code is written such that in practice, this returns whether the option has been touched by the user. table of contents. has_option_changed; has_option_changed(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; has_option_changed.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/api/psi4.core.has_option_changed.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.has_option_changed.html
https://psicode.org/psi4manual/master/api/psi4.core.has_scalar_variable.html:579,Deployability,update,updated,579,". has_scalar_variable. Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; has_scalar_variable. has_scalar_variable. psi4.core.has_scalar_variable(key: str)  bool; Is the double QCVariable key (case-insensitive) set? Prefer has_variable(). table of contents. has_scalar_variable; has_scalar_variable(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; has_scalar_variable.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/api/psi4.core.has_scalar_variable.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.has_scalar_variable.html
https://psicode.org/psi4manual/master/api/psi4.core.has_variable.html:620,Deployability,update,updated,620,". has_variable. Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; has_variable. has_variable. psi4.core.has_variable(key); Whether scalar or array QCVariable key has been set in global memory. Parameters:; key (str)  Case-insensitive key to global double or Matrix; storage maps. Return type:; bool. table of contents. has_variable; has_variable(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; has_variable.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/api/psi4.core.has_variable.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.has_variable.html
https://psicode.org/psi4manual/master/api/psi4.core.HF.html:1288,Deployability,Update,Update,1288,"?. attempt_number_; Current macroiteration (1-indexed) for stability analysis. diis_enabled_; docstring. diis_manager_; The DIIS object. diis_start_; docstring. frac_performed_; Frac performed current iteration?. initialized_diis_manager_; Has the DIIS object been initialized?. iteration_; Internal iterator for SCF cycles. iteration_energies. reset_occ_; Do reset the occupation after the guess to the inital occupation. sad_; Do assume a non-idempotent density matrix and no orbitals after the guess. Methods Summary. V_potential(self); Returns the internal DFT V object. Va(self); Returns the Alpha Kohn-Sham Potential Matrix. Vb(self); Returns the Beta Kohn-Sham Potential Matrix. check_phases(self); docstring. clear_external_cpscf_perturbations(self); Clear private external_cpscf_perturbations map. clear_external_potentials(self); Clear private external_potentials list. compute_E(self); docstring. compute_energy(); Base class Wavefunction requires this function. compute_fvpi(self); Update number of frozen virtuals. compute_initial_E(self); docstring. compute_orbital_gradient(self,arg0,arg1); docstring. compute_spin_contamination(self); docstring. cphf_Hx(self,arg0); CPHF Hessian-vector prodcuts (4 * J - K - K.T). cphf_converged(self); Adds occupied guess alpha orbitals. cphf_solve(self,x_vec,conv_tol,max_iter); Solves the CPHF equations for a given set of x vectors. damping_update(self,arg0); docstring. diis(self,arg0); docstring. finalize(self); Cleans up the the Wavefunction's temporary data. finalize_energy(); Performs stability analysis and calls back SCF with new guess if needed, Returns the SCF energy. find_occupation(self); docstring. form_C(self[,shift]); Forms the Orbital Matrices from the current Fock Matrices. form_D(self); Forms the Density Matrices from the current Orbitals Matrices. form_F(self); Forms the F matrix. form_FDSmSDF(self,arg0,arg1); Forms the residual of SCF theory. form_G(self); Forms the G matrix. form_H(self); Forms the core Ham",MatchSource.WIKI,psi4manual/master/api/psi4.core.HF.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.HF.html
https://psicode.org/psi4manual/master/api/psi4.core.HF.html:4354,Deployability,update,update,4354,"nergies(). print_header(self); docstring. print_orbitals(self); docstring. print_preiterations([small]). print_stability_analysis(self,arg0); docstring. push_back_external_potential(self,V); Add an external potential to the private external_potentials list. reset_occupation(self); docstring. rotate_orbitals(self,arg0,arg1); docstring. save_density_and_energy(self); docstring. scf_type(self); Return the value of scf_type used in the SCF computation. semicanonicalize(self); Semicanonicalizes the orbitals for ROHF. set_energies(self,arg0,arg1); docstring. set_external_cpscf_perturbation(self,name,...); Add an external potential/perturbation to the private external_cpscf_perturbations map for CPSCF. set_jk(self,arg0); Sets the internal JK object !expert. set_sad_basissets(self,arg0); Sets the Superposition of Atomic Densities basisset. set_sad_fitting_basissets(self,arg0); Sets the Superposition of Atomic Densities density-fitted basisset. soscf_update(self,arg0,arg1,arg2,arg3); Computes a second-order SCF update. stability_analysis(self); Assess wfn stability and correct if requested. twoel_Hx(self,arg0,arg1,arg2); Two-electron Hessian-vector products. validate_diis(); Sanity-checks DIIS control options. Attributes Documentation. MOM_excited_; Are we to do excited-state MOM?. MOM_performed_; MOM performed current iteration?. attempt_number_; Current macroiteration (1-indexed) for stability analysis. diis_enabled_; docstring. diis_manager_; The DIIS object. diis_start_; docstring. frac_performed_; Frac performed current iteration?. initialized_diis_manager_; Has the DIIS object been initialized?. iteration_; Internal iterator for SCF cycles. After completion, this equals the number of iterations taken to converge the SCF equations. iteration_energies = []. reset_occ_; Do reset the occupation after the guess to the inital occupation. sad_; Do assume a non-idempotent density matrix and no orbitals after the guess. Methods Documentation. V_pot",MatchSource.WIKI,psi4manual/master/api/psi4.core.HF.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.HF.html
https://psicode.org/psi4manual/master/api/psi4.core.HF.html:6143,Deployability,Update,Update,6143," the occupation after the guess to the inital occupation. sad_; Do assume a non-idempotent density matrix and no orbitals after the guess. Methods Documentation. V_potential(self: psi4.core.HF)  psi4.core.VBase; Returns the internal DFT V object. Va(self: psi4.core.HF)  psi4.core.Matrix; Returns the Alpha Kohn-Sham Potential Matrix. Vb(self: psi4.core.HF)  psi4.core.Matrix; Returns the Beta Kohn-Sham Potential Matrix. check_phases(self: psi4.core.HF)  None; docstring. clear_external_cpscf_perturbations(self: psi4.core.HF)  None; Clear private external_cpscf_perturbations map. clear_external_potentials(self: psi4.core.HF)  None; Clear private external_potentials list. compute_E(self: psi4.core.HF)  float; docstring. compute_energy(); Base class Wavefunction requires this function. Here it is; simply a wrapper around initialize(), iterations(), finalize_energy(). It; returns the SCF energy computed by finalize_energy(). compute_fvpi(self: psi4.core.HF)  None; Update number of frozen virtuals. compute_initial_E(self: psi4.core.HF)  float; docstring. compute_orbital_gradient(self: psi4.core.HF, arg0: bool, arg1: int)  float; docstring. compute_spin_contamination(self: psi4.core.HF)  None; docstring. cphf_Hx(self: psi4.core.HF, arg0: list[psi4.core.Matrix])  list[psi4.core.Matrix]; CPHF Hessian-vector prodcuts (4 * J - K - K.T). cphf_converged(self: psi4.core.HF)  bool; Adds occupied guess alpha orbitals. cphf_solve(self: psi4.core.HF, x_vec: list[psi4.core.Matrix], conv_tol: float, max_iter: int, print_lvl: int = 2)  list[psi4.core.Matrix]; Solves the CPHF equations for a given set of x vectors. damping_update(self: psi4.core.HF, arg0: float)  None; docstring. diis(self: psi4.core.HF, arg0: float)  bool; docstring. finalize(self: psi4.core.HF)  None; Cleans up the the Wavefunctions temporary data. finalize_energy(); Performs stability analysis and calls back SCF with new guess; if needed, Returns the SCF energy. This function should",MatchSource.WIKI,psi4manual/master/api/psi4.core.HF.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.HF.html
https://psicode.org/psi4manual/master/api/psi4.core.HF.html:10946,Deployability,update,update,10946,"ensity_and_energy(self: psi4.core.HF)  None; docstring. scf_type(self: psi4.core.HF)  str; Return the value of scf_type used in the SCF computation. semicanonicalize(self: psi4.core.HF)  None; Semicanonicalizes the orbitals for ROHF. set_energies(self: psi4.core.HF, arg0: str, arg1: float)  None; docstring. set_external_cpscf_perturbation(self: psi4.core.HF, name: str, function: Callable[[psi4.core.Matrix], psi4.core.Matrix])  None; Add an external potential/perturbation to the private external_cpscf_perturbations map for CPSCF. set_jk(self: psi4.core.HF, arg0: psi4.core.JK)  None; Sets the internal JK object !expert. set_sad_basissets(self: psi4.core.HF, arg0: list[psi4.core.BasisSet])  None; Sets the Superposition of Atomic Densities basisset. set_sad_fitting_basissets(self: psi4.core.HF, arg0: list[psi4.core.BasisSet])  None; Sets the Superposition of Atomic Densities density-fitted basisset. soscf_update(self: psi4.core.HF, arg0: float, arg1: int, arg2: int, arg3: int)  int; Computes a second-order SCF update. stability_analysis(self: psi4.core.HF)  bool; Assess wfn stability and correct if requested. twoel_Hx(self: psi4.core.HF, arg0: list[psi4.core.Matrix], arg1: bool, arg2: str)  list[psi4.core.Matrix]; Two-electron Hessian-vector products. validate_diis(); Sanity-checks DIIS control options. Raises:; psi4.driver.p4util.exceptions.ValidationError  If any of DIIS options dont play well together. Returns:; Whether some form of DIIS is enabled during SCF. Return type:; bool. table of contents. HF; HF; HF.MOM_excited_; HF.MOM_performed_; HF.attempt_number_; HF.diis_enabled_; HF.diis_manager_; HF.diis_start_; HF.frac_performed_; HF.initialized_diis_manager_; HF.iteration_; HF.iteration_energies; HF.reset_occ_; HF.sad_; HF.V_potential(); HF.Va(); HF.Vb(); HF.check_phases(); HF.clear_external_cpscf_perturbations(); HF.clear_external_potentials(); HF.compute_E(); HF.compute_energy(); HF.compute_fvpi(); HF.compute_initial_E(); HF.compute_orbita",MatchSource.WIKI,psi4manual/master/api/psi4.core.HF.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.HF.html
https://psicode.org/psi4manual/master/api/psi4.core.HF.html:13163,Deployability,update,updated,13163,"ptions. Raises:; psi4.driver.p4util.exceptions.ValidationError  If any of DIIS options dont play well together. Returns:; Whether some form of DIIS is enabled during SCF. Return type:; bool. table of contents. HF; HF; HF.MOM_excited_; HF.MOM_performed_; HF.attempt_number_; HF.diis_enabled_; HF.diis_manager_; HF.diis_start_; HF.frac_performed_; HF.initialized_diis_manager_; HF.iteration_; HF.iteration_energies; HF.reset_occ_; HF.sad_; HF.V_potential(); HF.Va(); HF.Vb(); HF.check_phases(); HF.clear_external_cpscf_perturbations(); HF.clear_external_potentials(); HF.compute_E(); HF.compute_energy(); HF.compute_fvpi(); HF.compute_initial_E(); HF.compute_orbital_gradient(); HF.compute_spin_contamination(); HF.cphf_Hx(); HF.cphf_converged(); HF.cphf_solve(); HF.damping_update(); HF.diis(); HF.finalize(); HF.finalize_energy(); HF.find_occupation(); HF.form_C(); HF.form_D(); HF.form_F(); HF.form_FDSmSDF(); HF.form_G(); HF.form_H(); HF.form_Shalf(); HF.form_V(); HF.form_initial_C(); HF.form_initial_F(); HF.frac_renormalize(); HF.functional(); HF.get_energies(); HF.guess(); HF.guess_Ca(); HF.guess_Cb(); HF.initialize(); HF.initialize_gtfock_jk(); HF.initialize_jk(); HF.iterations(); HF.jk(); HF.occupation_a(); HF.occupation_b(); HF.onel_Hx(); HF.print_energies(); HF.print_header(); HF.print_orbitals(); HF.print_preiterations(); HF.print_stability_analysis(); HF.push_back_external_potential(); HF.reset_occupation(); HF.rotate_orbitals(); HF.save_density_and_energy(); HF.scf_type(); HF.semicanonicalize(); HF.set_energies(); HF.set_external_cpscf_perturbation(); HF.set_jk(); HF.set_sad_basissets(); HF.set_sad_fitting_basissets(); HF.soscf_update(); HF.stability_analysis(); HF.twoel_Hx(); HF.validate_diis(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; HF.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/api/psi4.core.HF.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.HF.html
https://psicode.org/psi4manual/master/api/psi4.core.HF.html:1927,Energy Efficiency,energy,energy,1927,"); Returns the Alpha Kohn-Sham Potential Matrix. Vb(self); Returns the Beta Kohn-Sham Potential Matrix. check_phases(self); docstring. clear_external_cpscf_perturbations(self); Clear private external_cpscf_perturbations map. clear_external_potentials(self); Clear private external_potentials list. compute_E(self); docstring. compute_energy(); Base class Wavefunction requires this function. compute_fvpi(self); Update number of frozen virtuals. compute_initial_E(self); docstring. compute_orbital_gradient(self,arg0,arg1); docstring. compute_spin_contamination(self); docstring. cphf_Hx(self,arg0); CPHF Hessian-vector prodcuts (4 * J - K - K.T). cphf_converged(self); Adds occupied guess alpha orbitals. cphf_solve(self,x_vec,conv_tol,max_iter); Solves the CPHF equations for a given set of x vectors. damping_update(self,arg0); docstring. diis(self,arg0); docstring. finalize(self); Cleans up the the Wavefunction's temporary data. finalize_energy(); Performs stability analysis and calls back SCF with new guess if needed, Returns the SCF energy. find_occupation(self); docstring. form_C(self[,shift]); Forms the Orbital Matrices from the current Fock Matrices. form_D(self); Forms the Density Matrices from the current Orbitals Matrices. form_F(self); Forms the F matrix. form_FDSmSDF(self,arg0,arg1); Forms the residual of SCF theory. form_G(self); Forms the G matrix. form_H(self); Forms the core Hamiltonian. form_Shalf(self); Forms the S^1/2 matrix. form_V(self); Form the Kohn-Sham Potential Matrices from the current Density Matrices. form_initial_C(self); Forms the initial Orbital Matrices from the current Fock Matrices. form_initial_F(self); Forms the initial F matrix. frac_renormalize(self); docstring. functional(self); Returns the internal DFT Superfunctional. get_energies(self,arg0); docstring. guess(self); Forms the guess (guarantees C, D, and E). guess_Ca(self,arg0); Sets the guess Alpha Orbital Matrix. guess_Cb(self,arg0); Sets the guess Beta Orbital Matrix. ",MatchSource.WIKI,psi4manual/master/api/psi4.core.HF.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.HF.html
https://psicode.org/psi4manual/master/api/psi4.core.HF.html:6063,Energy Efficiency,energy,energy,6063,"ken to converge the SCF equations. iteration_energies = []. reset_occ_; Do reset the occupation after the guess to the inital occupation. sad_; Do assume a non-idempotent density matrix and no orbitals after the guess. Methods Documentation. V_potential(self: psi4.core.HF)  psi4.core.VBase; Returns the internal DFT V object. Va(self: psi4.core.HF)  psi4.core.Matrix; Returns the Alpha Kohn-Sham Potential Matrix. Vb(self: psi4.core.HF)  psi4.core.Matrix; Returns the Beta Kohn-Sham Potential Matrix. check_phases(self: psi4.core.HF)  None; docstring. clear_external_cpscf_perturbations(self: psi4.core.HF)  None; Clear private external_cpscf_perturbations map. clear_external_potentials(self: psi4.core.HF)  None; Clear private external_potentials list. compute_E(self: psi4.core.HF)  float; docstring. compute_energy(); Base class Wavefunction requires this function. Here it is; simply a wrapper around initialize(), iterations(), finalize_energy(). It; returns the SCF energy computed by finalize_energy(). compute_fvpi(self: psi4.core.HF)  None; Update number of frozen virtuals. compute_initial_E(self: psi4.core.HF)  float; docstring. compute_orbital_gradient(self: psi4.core.HF, arg0: bool, arg1: int)  float; docstring. compute_spin_contamination(self: psi4.core.HF)  None; docstring. cphf_Hx(self: psi4.core.HF, arg0: list[psi4.core.Matrix])  list[psi4.core.Matrix]; CPHF Hessian-vector prodcuts (4 * J - K - K.T). cphf_converged(self: psi4.core.HF)  bool; Adds occupied guess alpha orbitals. cphf_solve(self: psi4.core.HF, x_vec: list[psi4.core.Matrix], conv_tol: float, max_iter: int, print_lvl: int = 2)  list[psi4.core.Matrix]; Solves the CPHF equations for a given set of x vectors. damping_update(self: psi4.core.HF, arg0: float)  None; docstring. diis(self: psi4.core.HF, arg0: float)  bool; docstring. finalize(self: psi4.core.HF)  None; Cleans up the the Wavefunctions temporary data. finalize_energy(); Performs stability analysis and call",MatchSource.WIKI,psi4manual/master/api/psi4.core.HF.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.HF.html
https://psicode.org/psi4manual/master/api/psi4.core.HF.html:7125,Energy Efficiency,energy,energy,7125,"puted by finalize_energy(). compute_fvpi(self: psi4.core.HF)  None; Update number of frozen virtuals. compute_initial_E(self: psi4.core.HF)  float; docstring. compute_orbital_gradient(self: psi4.core.HF, arg0: bool, arg1: int)  float; docstring. compute_spin_contamination(self: psi4.core.HF)  None; docstring. cphf_Hx(self: psi4.core.HF, arg0: list[psi4.core.Matrix])  list[psi4.core.Matrix]; CPHF Hessian-vector prodcuts (4 * J - K - K.T). cphf_converged(self: psi4.core.HF)  bool; Adds occupied guess alpha orbitals. cphf_solve(self: psi4.core.HF, x_vec: list[psi4.core.Matrix], conv_tol: float, max_iter: int, print_lvl: int = 2)  list[psi4.core.Matrix]; Solves the CPHF equations for a given set of x vectors. damping_update(self: psi4.core.HF, arg0: float)  None; docstring. diis(self: psi4.core.HF, arg0: float)  bool; docstring. finalize(self: psi4.core.HF)  None; Cleans up the the Wavefunctions temporary data. finalize_energy(); Performs stability analysis and calls back SCF with new guess; if needed, Returns the SCF energy. This function should be called; once orbitals are ready for energy/property computations, usually; after iterations() is called. find_occupation(self: psi4.core.HF)  None; docstring. form_C(self: psi4.core.HF, shift: float = 0.0)  None; Forms the Orbital Matrices from the current Fock Matrices. form_D(self: psi4.core.HF)  None; Forms the Density Matrices from the current Orbitals Matrices. form_F(self: psi4.core.HF)  None; Forms the F matrix. form_FDSmSDF(self: psi4.core.HF, arg0: psi4.core.Matrix, arg1: psi4.core.Matrix)  psi4.core.Matrix; Forms the residual of SCF theory. form_G(self: psi4.core.HF)  None; Forms the G matrix. form_H(self: psi4.core.HF)  None; Forms the core Hamiltonian. form_Shalf(self: psi4.core.HF)  None; Forms the S^1/2 matrix. form_V(self: psi4.core.HF)  None; Form the Kohn-Sham Potential Matrices from the current Density Matrices. form_initial_C(self: psi4.core.HF)  None; Forms the in",MatchSource.WIKI,psi4manual/master/api/psi4.core.HF.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.HF.html
https://psicode.org/psi4manual/master/api/psi4.core.HF.html:7193,Energy Efficiency,energy,energy,7193,"elf: psi4.core.HF)  float; docstring. compute_orbital_gradient(self: psi4.core.HF, arg0: bool, arg1: int)  float; docstring. compute_spin_contamination(self: psi4.core.HF)  None; docstring. cphf_Hx(self: psi4.core.HF, arg0: list[psi4.core.Matrix])  list[psi4.core.Matrix]; CPHF Hessian-vector prodcuts (4 * J - K - K.T). cphf_converged(self: psi4.core.HF)  bool; Adds occupied guess alpha orbitals. cphf_solve(self: psi4.core.HF, x_vec: list[psi4.core.Matrix], conv_tol: float, max_iter: int, print_lvl: int = 2)  list[psi4.core.Matrix]; Solves the CPHF equations for a given set of x vectors. damping_update(self: psi4.core.HF, arg0: float)  None; docstring. diis(self: psi4.core.HF, arg0: float)  bool; docstring. finalize(self: psi4.core.HF)  None; Cleans up the the Wavefunctions temporary data. finalize_energy(); Performs stability analysis and calls back SCF with new guess; if needed, Returns the SCF energy. This function should be called; once orbitals are ready for energy/property computations, usually; after iterations() is called. find_occupation(self: psi4.core.HF)  None; docstring. form_C(self: psi4.core.HF, shift: float = 0.0)  None; Forms the Orbital Matrices from the current Fock Matrices. form_D(self: psi4.core.HF)  None; Forms the Density Matrices from the current Orbitals Matrices. form_F(self: psi4.core.HF)  None; Forms the F matrix. form_FDSmSDF(self: psi4.core.HF, arg0: psi4.core.Matrix, arg1: psi4.core.Matrix)  psi4.core.Matrix; Forms the residual of SCF theory. form_G(self: psi4.core.HF)  None; Forms the G matrix. form_H(self: psi4.core.HF)  None; Forms the core Hamiltonian. form_Shalf(self: psi4.core.HF)  None; Forms the S^1/2 matrix. form_V(self: psi4.core.HF)  None; Form the Kohn-Sham Potential Matrices from the current Density Matrices. form_initial_C(self: psi4.core.HF)  None; Forms the initial Orbital Matrices from the current Fock Matrices. form_initial_F(self: psi4.core.HF)  None; Forms the initial F matri",MatchSource.WIKI,psi4manual/master/api/psi4.core.HF.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.HF.html
https://psicode.org/psi4manual/master/api/psi4.core.HF.html:5981,Integrability,wrap,wrapper,5981,"r SCF cycles. After completion, this equals the number of iterations taken to converge the SCF equations. iteration_energies = []. reset_occ_; Do reset the occupation after the guess to the inital occupation. sad_; Do assume a non-idempotent density matrix and no orbitals after the guess. Methods Documentation. V_potential(self: psi4.core.HF)  psi4.core.VBase; Returns the internal DFT V object. Va(self: psi4.core.HF)  psi4.core.Matrix; Returns the Alpha Kohn-Sham Potential Matrix. Vb(self: psi4.core.HF)  psi4.core.Matrix; Returns the Beta Kohn-Sham Potential Matrix. check_phases(self: psi4.core.HF)  None; docstring. clear_external_cpscf_perturbations(self: psi4.core.HF)  None; Clear private external_cpscf_perturbations map. clear_external_potentials(self: psi4.core.HF)  None; Clear private external_potentials list. compute_E(self: psi4.core.HF)  float; docstring. compute_energy(); Base class Wavefunction requires this function. Here it is; simply a wrapper around initialize(), iterations(), finalize_energy(). It; returns the SCF energy computed by finalize_energy(). compute_fvpi(self: psi4.core.HF)  None; Update number of frozen virtuals. compute_initial_E(self: psi4.core.HF)  float; docstring. compute_orbital_gradient(self: psi4.core.HF, arg0: bool, arg1: int)  float; docstring. compute_spin_contamination(self: psi4.core.HF)  None; docstring. cphf_Hx(self: psi4.core.HF, arg0: list[psi4.core.Matrix])  list[psi4.core.Matrix]; CPHF Hessian-vector prodcuts (4 * J - K - K.T). cphf_converged(self: psi4.core.HF)  bool; Adds occupied guess alpha orbitals. cphf_solve(self: psi4.core.HF, x_vec: list[psi4.core.Matrix], conv_tol: float, max_iter: int, print_lvl: int = 2)  list[psi4.core.Matrix]; Solves the CPHF equations for a given set of x vectors. damping_update(self: psi4.core.HF, arg0: float)  None; docstring. diis(self: psi4.core.HF, arg0: float)  bool; docstring. finalize(self: psi4.core.HF)  None; Cleans up the the Wavefunctions te",MatchSource.WIKI,psi4manual/master/api/psi4.core.HF.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.HF.html
https://psicode.org/psi4manual/master/api/psi4.core.HF.html:267,Performance,perform,performed,267,". HF. Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; HF. HF. class psi4.core.HF; Bases: Wavefunction; docstring; Attributes Summary. MOM_excited_; Are we to do excited-state MOM?. MOM_performed_; MOM performed current iteration?. attempt_number_; Current macroiteration (1-indexed) for stability analysis. diis_enabled_; docstring. diis_manager_; The DIIS object. diis_start_; docstring. frac_performed_; Frac performed current iteration?. initialized_diis_manager_; Has the DIIS object been initialized?. iteration_; Internal iterator for SCF cycles. iteration_energies. reset_occ_; Do reset the occupation after the guess to the inital occupation. sad_; Do assume a non-idempotent density matrix and no orbitals after the guess. Methods Summary. V_potential(self); Returns the internal DFT V object. Va(self); Returns the Alpha Kohn-Sham Potential Matrix. Vb(self); Returns the Beta Kohn-Sham Potential Matrix. check_phases(self); docstring. clear_external_cpscf_perturbations(self); Clear private external_cpscf_perturbations map. clear_external_potentials(self); Clear private external_potentials list. compute_E(self); docstring. compute_energy(); Base class Wavefunction requires this function. compute_fvpi(self); Update number of frozen virtuals. compute_initial_E(self); docstring. compute_orbital_gradient(self,arg0,arg1); docstring. compute_spin_contamination(self); docstring. cphf_Hx(self,arg0); CPHF Hessian-vector prodcuts (4 * J - K - K.T). cphf_converged(self); Adds occupied guess alpha orbitals. cphf_solve(self,x_vec,conv_tol,max_iter); Solves the CPHF equations for a given set of x vectors. damping_update(self,arg0); docstring. diis(self,arg0); docstring. finalize(self); Cleans up the the Wavefunction's temporary data. finalize_energy(); Performs stability analysis and calls back SCF with new guess if needed, Returns the SCF energy. find_occupation(self); docstring. form_C(self[,shift]); Forms the",MatchSource.WIKI,psi4manual/master/api/psi4.core.HF.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.HF.html
https://psicode.org/psi4manual/master/api/psi4.core.HF.html:477,Performance,perform,performed,477,". HF. Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; HF. HF. class psi4.core.HF; Bases: Wavefunction; docstring; Attributes Summary. MOM_excited_; Are we to do excited-state MOM?. MOM_performed_; MOM performed current iteration?. attempt_number_; Current macroiteration (1-indexed) for stability analysis. diis_enabled_; docstring. diis_manager_; The DIIS object. diis_start_; docstring. frac_performed_; Frac performed current iteration?. initialized_diis_manager_; Has the DIIS object been initialized?. iteration_; Internal iterator for SCF cycles. iteration_energies. reset_occ_; Do reset the occupation after the guess to the inital occupation. sad_; Do assume a non-idempotent density matrix and no orbitals after the guess. Methods Summary. V_potential(self); Returns the internal DFT V object. Va(self); Returns the Alpha Kohn-Sham Potential Matrix. Vb(self); Returns the Beta Kohn-Sham Potential Matrix. check_phases(self); docstring. clear_external_cpscf_perturbations(self); Clear private external_cpscf_perturbations map. clear_external_potentials(self); Clear private external_potentials list. compute_E(self); docstring. compute_energy(); Base class Wavefunction requires this function. compute_fvpi(self); Update number of frozen virtuals. compute_initial_E(self); docstring. compute_orbital_gradient(self,arg0,arg1); docstring. compute_spin_contamination(self); docstring. cphf_Hx(self,arg0); CPHF Hessian-vector prodcuts (4 * J - K - K.T). cphf_converged(self); Adds occupied guess alpha orbitals. cphf_solve(self,x_vec,conv_tol,max_iter); Solves the CPHF equations for a given set of x vectors. damping_update(self,arg0); docstring. diis(self,arg0); docstring. finalize(self); Cleans up the the Wavefunction's temporary data. finalize_energy(); Performs stability analysis and calls back SCF with new guess if needed, Returns the SCF energy. find_occupation(self); docstring. form_C(self[,shift]); Forms the",MatchSource.WIKI,psi4manual/master/api/psi4.core.HF.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.HF.html
https://psicode.org/psi4manual/master/api/psi4.core.HF.html:1838,Performance,Perform,Performs,1838,"); Returns the Alpha Kohn-Sham Potential Matrix. Vb(self); Returns the Beta Kohn-Sham Potential Matrix. check_phases(self); docstring. clear_external_cpscf_perturbations(self); Clear private external_cpscf_perturbations map. clear_external_potentials(self); Clear private external_potentials list. compute_E(self); docstring. compute_energy(); Base class Wavefunction requires this function. compute_fvpi(self); Update number of frozen virtuals. compute_initial_E(self); docstring. compute_orbital_gradient(self,arg0,arg1); docstring. compute_spin_contamination(self); docstring. cphf_Hx(self,arg0); CPHF Hessian-vector prodcuts (4 * J - K - K.T). cphf_converged(self); Adds occupied guess alpha orbitals. cphf_solve(self,x_vec,conv_tol,max_iter); Solves the CPHF equations for a given set of x vectors. damping_update(self,arg0); docstring. diis(self,arg0); docstring. finalize(self); Cleans up the the Wavefunction's temporary data. finalize_energy(); Performs stability analysis and calls back SCF with new guess if needed, Returns the SCF energy. find_occupation(self); docstring. form_C(self[,shift]); Forms the Orbital Matrices from the current Fock Matrices. form_D(self); Forms the Density Matrices from the current Orbitals Matrices. form_F(self); Forms the F matrix. form_FDSmSDF(self,arg0,arg1); Forms the residual of SCF theory. form_G(self); Forms the G matrix. form_H(self); Forms the core Hamiltonian. form_Shalf(self); Forms the S^1/2 matrix. form_V(self); Form the Kohn-Sham Potential Matrices from the current Density Matrices. form_initial_C(self); Forms the initial Orbital Matrices from the current Fock Matrices. form_initial_F(self); Forms the initial F matrix. frac_renormalize(self); docstring. functional(self); Returns the internal DFT Superfunctional. get_energies(self,arg0); docstring. guess(self); Forms the guess (guarantees C, D, and E). guess_Ca(self,arg0); Sets the guess Alpha Orbital Matrix. guess_Cb(self,arg0); Sets the guess Beta Orbital Matrix. ",MatchSource.WIKI,psi4manual/master/api/psi4.core.HF.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.HF.html
https://psicode.org/psi4manual/master/api/psi4.core.HF.html:4655,Performance,perform,performed,4655,"ng. save_density_and_energy(self); docstring. scf_type(self); Return the value of scf_type used in the SCF computation. semicanonicalize(self); Semicanonicalizes the orbitals for ROHF. set_energies(self,arg0,arg1); docstring. set_external_cpscf_perturbation(self,name,...); Add an external potential/perturbation to the private external_cpscf_perturbations map for CPSCF. set_jk(self,arg0); Sets the internal JK object !expert. set_sad_basissets(self,arg0); Sets the Superposition of Atomic Densities basisset. set_sad_fitting_basissets(self,arg0); Sets the Superposition of Atomic Densities density-fitted basisset. soscf_update(self,arg0,arg1,arg2,arg3); Computes a second-order SCF update. stability_analysis(self); Assess wfn stability and correct if requested. twoel_Hx(self,arg0,arg1,arg2); Two-electron Hessian-vector products. validate_diis(); Sanity-checks DIIS control options. Attributes Documentation. MOM_excited_; Are we to do excited-state MOM?. MOM_performed_; MOM performed current iteration?. attempt_number_; Current macroiteration (1-indexed) for stability analysis. diis_enabled_; docstring. diis_manager_; The DIIS object. diis_start_; docstring. frac_performed_; Frac performed current iteration?. initialized_diis_manager_; Has the DIIS object been initialized?. iteration_; Internal iterator for SCF cycles. After completion, this equals the number of iterations taken to converge the SCF equations. iteration_energies = []. reset_occ_; Do reset the occupation after the guess to the inital occupation. sad_; Do assume a non-idempotent density matrix and no orbitals after the guess. Methods Documentation. V_potential(self: psi4.core.HF)  psi4.core.VBase; Returns the internal DFT V object. Va(self: psi4.core.HF)  psi4.core.Matrix; Returns the Alpha Kohn-Sham Potential Matrix. Vb(self: psi4.core.HF)  psi4.core.Matrix; Returns the Beta Kohn-Sham Potential Matrix. check_phases(self: psi4.core.HF)  None; docstring. clear_external_cpscf_per",MatchSource.WIKI,psi4manual/master/api/psi4.core.HF.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.HF.html
https://psicode.org/psi4manual/master/api/psi4.core.HF.html:4870,Performance,perform,performed,4870,"); docstring. set_external_cpscf_perturbation(self,name,...); Add an external potential/perturbation to the private external_cpscf_perturbations map for CPSCF. set_jk(self,arg0); Sets the internal JK object !expert. set_sad_basissets(self,arg0); Sets the Superposition of Atomic Densities basisset. set_sad_fitting_basissets(self,arg0); Sets the Superposition of Atomic Densities density-fitted basisset. soscf_update(self,arg0,arg1,arg2,arg3); Computes a second-order SCF update. stability_analysis(self); Assess wfn stability and correct if requested. twoel_Hx(self,arg0,arg1,arg2); Two-electron Hessian-vector products. validate_diis(); Sanity-checks DIIS control options. Attributes Documentation. MOM_excited_; Are we to do excited-state MOM?. MOM_performed_; MOM performed current iteration?. attempt_number_; Current macroiteration (1-indexed) for stability analysis. diis_enabled_; docstring. diis_manager_; The DIIS object. diis_start_; docstring. frac_performed_; Frac performed current iteration?. initialized_diis_manager_; Has the DIIS object been initialized?. iteration_; Internal iterator for SCF cycles. After completion, this equals the number of iterations taken to converge the SCF equations. iteration_energies = []. reset_occ_; Do reset the occupation after the guess to the inital occupation. sad_; Do assume a non-idempotent density matrix and no orbitals after the guess. Methods Documentation. V_potential(self: psi4.core.HF)  psi4.core.VBase; Returns the internal DFT V object. Va(self: psi4.core.HF)  psi4.core.Matrix; Returns the Alpha Kohn-Sham Potential Matrix. Vb(self: psi4.core.HF)  psi4.core.Matrix; Returns the Beta Kohn-Sham Potential Matrix. check_phases(self: psi4.core.HF)  None; docstring. clear_external_cpscf_perturbations(self: psi4.core.HF)  None; Clear private external_cpscf_perturbations map. clear_external_potentials(self: psi4.core.HF)  None; Clear private external_potentials list. compute_E(self: psi4.core.HF) ",MatchSource.WIKI,psi4manual/master/api/psi4.core.HF.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.HF.html
https://psicode.org/psi4manual/master/api/psi4.core.HF.html:7035,Performance,Perform,Performs,7035,"puted by finalize_energy(). compute_fvpi(self: psi4.core.HF)  None; Update number of frozen virtuals. compute_initial_E(self: psi4.core.HF)  float; docstring. compute_orbital_gradient(self: psi4.core.HF, arg0: bool, arg1: int)  float; docstring. compute_spin_contamination(self: psi4.core.HF)  None; docstring. cphf_Hx(self: psi4.core.HF, arg0: list[psi4.core.Matrix])  list[psi4.core.Matrix]; CPHF Hessian-vector prodcuts (4 * J - K - K.T). cphf_converged(self: psi4.core.HF)  bool; Adds occupied guess alpha orbitals. cphf_solve(self: psi4.core.HF, x_vec: list[psi4.core.Matrix], conv_tol: float, max_iter: int, print_lvl: int = 2)  list[psi4.core.Matrix]; Solves the CPHF equations for a given set of x vectors. damping_update(self: psi4.core.HF, arg0: float)  None; docstring. diis(self: psi4.core.HF, arg0: float)  bool; docstring. finalize(self: psi4.core.HF)  None; Cleans up the the Wavefunctions temporary data. finalize_energy(); Performs stability analysis and calls back SCF with new guess; if needed, Returns the SCF energy. This function should be called; once orbitals are ready for energy/property computations, usually; after iterations() is called. find_occupation(self: psi4.core.HF)  None; docstring. form_C(self: psi4.core.HF, shift: float = 0.0)  None; Forms the Orbital Matrices from the current Fock Matrices. form_D(self: psi4.core.HF)  None; Forms the Density Matrices from the current Orbitals Matrices. form_F(self: psi4.core.HF)  None; Forms the F matrix. form_FDSmSDF(self: psi4.core.HF, arg0: psi4.core.Matrix, arg1: psi4.core.Matrix)  psi4.core.Matrix; Forms the residual of SCF theory. form_G(self: psi4.core.HF)  None; Forms the G matrix. form_H(self: psi4.core.HF)  None; Forms the core Hamiltonian. form_Shalf(self: psi4.core.HF)  None; Forms the S^1/2 matrix. form_V(self: psi4.core.HF)  None; Form the Kohn-Sham Potential Matrices from the current Density Matrices. form_initial_C(self: psi4.core.HF)  None; Forms the in",MatchSource.WIKI,psi4manual/master/api/psi4.core.HF.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.HF.html
https://psicode.org/psi4manual/master/api/psi4.core.HF.html:11289,Security,Validat,ValidationError,11289,"], psi4.core.Matrix])  None; Add an external potential/perturbation to the private external_cpscf_perturbations map for CPSCF. set_jk(self: psi4.core.HF, arg0: psi4.core.JK)  None; Sets the internal JK object !expert. set_sad_basissets(self: psi4.core.HF, arg0: list[psi4.core.BasisSet])  None; Sets the Superposition of Atomic Densities basisset. set_sad_fitting_basissets(self: psi4.core.HF, arg0: list[psi4.core.BasisSet])  None; Sets the Superposition of Atomic Densities density-fitted basisset. soscf_update(self: psi4.core.HF, arg0: float, arg1: int, arg2: int, arg3: int)  int; Computes a second-order SCF update. stability_analysis(self: psi4.core.HF)  bool; Assess wfn stability and correct if requested. twoel_Hx(self: psi4.core.HF, arg0: list[psi4.core.Matrix], arg1: bool, arg2: str)  list[psi4.core.Matrix]; Two-electron Hessian-vector products. validate_diis(); Sanity-checks DIIS control options. Raises:; psi4.driver.p4util.exceptions.ValidationError  If any of DIIS options dont play well together. Returns:; Whether some form of DIIS is enabled during SCF. Return type:; bool. table of contents. HF; HF; HF.MOM_excited_; HF.MOM_performed_; HF.attempt_number_; HF.diis_enabled_; HF.diis_manager_; HF.diis_start_; HF.frac_performed_; HF.initialized_diis_manager_; HF.iteration_; HF.iteration_energies; HF.reset_occ_; HF.sad_; HF.V_potential(); HF.Va(); HF.Vb(); HF.check_phases(); HF.clear_external_cpscf_perturbations(); HF.clear_external_potentials(); HF.compute_E(); HF.compute_energy(); HF.compute_fvpi(); HF.compute_initial_E(); HF.compute_orbital_gradient(); HF.compute_spin_contamination(); HF.cphf_Hx(); HF.cphf_converged(); HF.cphf_solve(); HF.damping_update(); HF.diis(); HF.finalize(); HF.finalize_energy(); HF.find_occupation(); HF.form_C(); HF.form_D(); HF.form_F(); HF.form_FDSmSDF(); HF.form_G(); HF.form_H(); HF.form_Shalf(); HF.form_V(); HF.form_initial_C(); HF.form_initial_F(); HF.frac_renormalize(); HF.functional(); HF.get_energies(); HF.guess()",MatchSource.WIKI,psi4manual/master/api/psi4.core.HF.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.HF.html
https://psicode.org/psi4manual/master/api/psi4.core.HF.html:1053,Usability,Clear,Clear,1053,"; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; HF. HF. class psi4.core.HF; Bases: Wavefunction; docstring; Attributes Summary. MOM_excited_; Are we to do excited-state MOM?. MOM_performed_; MOM performed current iteration?. attempt_number_; Current macroiteration (1-indexed) for stability analysis. diis_enabled_; docstring. diis_manager_; The DIIS object. diis_start_; docstring. frac_performed_; Frac performed current iteration?. initialized_diis_manager_; Has the DIIS object been initialized?. iteration_; Internal iterator for SCF cycles. iteration_energies. reset_occ_; Do reset the occupation after the guess to the inital occupation. sad_; Do assume a non-idempotent density matrix and no orbitals after the guess. Methods Summary. V_potential(self); Returns the internal DFT V object. Va(self); Returns the Alpha Kohn-Sham Potential Matrix. Vb(self); Returns the Beta Kohn-Sham Potential Matrix. check_phases(self); docstring. clear_external_cpscf_perturbations(self); Clear private external_cpscf_perturbations map. clear_external_potentials(self); Clear private external_potentials list. compute_E(self); docstring. compute_energy(); Base class Wavefunction requires this function. compute_fvpi(self); Update number of frozen virtuals. compute_initial_E(self); docstring. compute_orbital_gradient(self,arg0,arg1); docstring. compute_spin_contamination(self); docstring. cphf_Hx(self,arg0); CPHF Hessian-vector prodcuts (4 * J - K - K.T). cphf_converged(self); Adds occupied guess alpha orbitals. cphf_solve(self,x_vec,conv_tol,max_iter); Solves the CPHF equations for a given set of x vectors. damping_update(self,arg0); docstring. diis(self,arg0); docstring. finalize(self); Cleans up the the Wavefunction's temporary data. finalize_energy(); Performs stability analysis and calls back SCF with new guess if needed, Returns the SCF energy. find_occupation(self); docstring. form_C(self[,shift]); Forms the Orbital Matrices from the current Fock Matrices. form",MatchSource.WIKI,psi4manual/master/api/psi4.core.HF.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.HF.html
https://psicode.org/psi4manual/master/api/psi4.core.HF.html:1134,Usability,Clear,Clear,1134,"4.core.HF; Bases: Wavefunction; docstring; Attributes Summary. MOM_excited_; Are we to do excited-state MOM?. MOM_performed_; MOM performed current iteration?. attempt_number_; Current macroiteration (1-indexed) for stability analysis. diis_enabled_; docstring. diis_manager_; The DIIS object. diis_start_; docstring. frac_performed_; Frac performed current iteration?. initialized_diis_manager_; Has the DIIS object been initialized?. iteration_; Internal iterator for SCF cycles. iteration_energies. reset_occ_; Do reset the occupation after the guess to the inital occupation. sad_; Do assume a non-idempotent density matrix and no orbitals after the guess. Methods Summary. V_potential(self); Returns the internal DFT V object. Va(self); Returns the Alpha Kohn-Sham Potential Matrix. Vb(self); Returns the Beta Kohn-Sham Potential Matrix. check_phases(self); docstring. clear_external_cpscf_perturbations(self); Clear private external_cpscf_perturbations map. clear_external_potentials(self); Clear private external_potentials list. compute_E(self); docstring. compute_energy(); Base class Wavefunction requires this function. compute_fvpi(self); Update number of frozen virtuals. compute_initial_E(self); docstring. compute_orbital_gradient(self,arg0,arg1); docstring. compute_spin_contamination(self); docstring. cphf_Hx(self,arg0); CPHF Hessian-vector prodcuts (4 * J - K - K.T). cphf_converged(self); Adds occupied guess alpha orbitals. cphf_solve(self,x_vec,conv_tol,max_iter); Solves the CPHF equations for a given set of x vectors. damping_update(self,arg0); docstring. diis(self,arg0); docstring. finalize(self); Cleans up the the Wavefunction's temporary data. finalize_energy(); Performs stability analysis and calls back SCF with new guess if needed, Returns the SCF energy. find_occupation(self); docstring. form_C(self[,shift]); Forms the Orbital Matrices from the current Fock Matrices. form_D(self); Forms the Density Matrices from the current Orbitals Matrices. form_F(se",MatchSource.WIKI,psi4manual/master/api/psi4.core.HF.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.HF.html
https://psicode.org/psi4manual/master/api/psi4.core.HF.html:5699,Usability,Clear,Clear,5699,"iteration (1-indexed) for stability analysis. diis_enabled_; docstring. diis_manager_; The DIIS object. diis_start_; docstring. frac_performed_; Frac performed current iteration?. initialized_diis_manager_; Has the DIIS object been initialized?. iteration_; Internal iterator for SCF cycles. After completion, this equals the number of iterations taken to converge the SCF equations. iteration_energies = []. reset_occ_; Do reset the occupation after the guess to the inital occupation. sad_; Do assume a non-idempotent density matrix and no orbitals after the guess. Methods Documentation. V_potential(self: psi4.core.HF)  psi4.core.VBase; Returns the internal DFT V object. Va(self: psi4.core.HF)  psi4.core.Matrix; Returns the Alpha Kohn-Sham Potential Matrix. Vb(self: psi4.core.HF)  psi4.core.Matrix; Returns the Beta Kohn-Sham Potential Matrix. check_phases(self: psi4.core.HF)  None; docstring. clear_external_cpscf_perturbations(self: psi4.core.HF)  None; Clear private external_cpscf_perturbations map. clear_external_potentials(self: psi4.core.HF)  None; Clear private external_potentials list. compute_E(self: psi4.core.HF)  float; docstring. compute_energy(); Base class Wavefunction requires this function. Here it is; simply a wrapper around initialize(), iterations(), finalize_energy(). It; returns the SCF energy computed by finalize_energy(). compute_fvpi(self: psi4.core.HF)  None; Update number of frozen virtuals. compute_initial_E(self: psi4.core.HF)  float; docstring. compute_orbital_gradient(self: psi4.core.HF, arg0: bool, arg1: int)  float; docstring. compute_spin_contamination(self: psi4.core.HF)  None; docstring. cphf_Hx(self: psi4.core.HF, arg0: list[psi4.core.Matrix])  list[psi4.core.Matrix]; CPHF Hessian-vector prodcuts (4 * J - K - K.T). cphf_converged(self: psi4.core.HF)  bool; Adds occupied guess alpha orbitals. cphf_solve(self: psi4.core.HF, x_vec: list[psi4.core.Matrix], conv_tol: float, max_iter: int, print_lvl: int = ",MatchSource.WIKI,psi4manual/master/api/psi4.core.HF.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.HF.html
https://psicode.org/psi4manual/master/api/psi4.core.HF.html:5802,Usability,Clear,Clear,5802,"bject. diis_start_; docstring. frac_performed_; Frac performed current iteration?. initialized_diis_manager_; Has the DIIS object been initialized?. iteration_; Internal iterator for SCF cycles. After completion, this equals the number of iterations taken to converge the SCF equations. iteration_energies = []. reset_occ_; Do reset the occupation after the guess to the inital occupation. sad_; Do assume a non-idempotent density matrix and no orbitals after the guess. Methods Documentation. V_potential(self: psi4.core.HF)  psi4.core.VBase; Returns the internal DFT V object. Va(self: psi4.core.HF)  psi4.core.Matrix; Returns the Alpha Kohn-Sham Potential Matrix. Vb(self: psi4.core.HF)  psi4.core.Matrix; Returns the Beta Kohn-Sham Potential Matrix. check_phases(self: psi4.core.HF)  None; docstring. clear_external_cpscf_perturbations(self: psi4.core.HF)  None; Clear private external_cpscf_perturbations map. clear_external_potentials(self: psi4.core.HF)  None; Clear private external_potentials list. compute_E(self: psi4.core.HF)  float; docstring. compute_energy(); Base class Wavefunction requires this function. Here it is; simply a wrapper around initialize(), iterations(), finalize_energy(). It; returns the SCF energy computed by finalize_energy(). compute_fvpi(self: psi4.core.HF)  None; Update number of frozen virtuals. compute_initial_E(self: psi4.core.HF)  float; docstring. compute_orbital_gradient(self: psi4.core.HF, arg0: bool, arg1: int)  float; docstring. compute_spin_contamination(self: psi4.core.HF)  None; docstring. cphf_Hx(self: psi4.core.HF, arg0: list[psi4.core.Matrix])  list[psi4.core.Matrix]; CPHF Hessian-vector prodcuts (4 * J - K - K.T). cphf_converged(self: psi4.core.HF)  bool; Adds occupied guess alpha orbitals. cphf_solve(self: psi4.core.HF, x_vec: list[psi4.core.Matrix], conv_tol: float, max_iter: int, print_lvl: int = 2)  list[psi4.core.Matrix]; Solves the CPHF equations for a given set of x vectors. damping_updat",MatchSource.WIKI,psi4manual/master/api/psi4.core.HF.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.HF.html
https://psicode.org/psi4manual/master/api/psi4.core.HF.html:5972,Usability,simpl,simply,5972,"r SCF cycles. After completion, this equals the number of iterations taken to converge the SCF equations. iteration_energies = []. reset_occ_; Do reset the occupation after the guess to the inital occupation. sad_; Do assume a non-idempotent density matrix and no orbitals after the guess. Methods Documentation. V_potential(self: psi4.core.HF)  psi4.core.VBase; Returns the internal DFT V object. Va(self: psi4.core.HF)  psi4.core.Matrix; Returns the Alpha Kohn-Sham Potential Matrix. Vb(self: psi4.core.HF)  psi4.core.Matrix; Returns the Beta Kohn-Sham Potential Matrix. check_phases(self: psi4.core.HF)  None; docstring. clear_external_cpscf_perturbations(self: psi4.core.HF)  None; Clear private external_cpscf_perturbations map. clear_external_potentials(self: psi4.core.HF)  None; Clear private external_potentials list. compute_E(self: psi4.core.HF)  float; docstring. compute_energy(); Base class Wavefunction requires this function. Here it is; simply a wrapper around initialize(), iterations(), finalize_energy(). It; returns the SCF energy computed by finalize_energy(). compute_fvpi(self: psi4.core.HF)  None; Update number of frozen virtuals. compute_initial_E(self: psi4.core.HF)  float; docstring. compute_orbital_gradient(self: psi4.core.HF, arg0: bool, arg1: int)  float; docstring. compute_spin_contamination(self: psi4.core.HF)  None; docstring. cphf_Hx(self: psi4.core.HF, arg0: list[psi4.core.Matrix])  list[psi4.core.Matrix]; CPHF Hessian-vector prodcuts (4 * J - K - K.T). cphf_converged(self: psi4.core.HF)  bool; Adds occupied guess alpha orbitals. cphf_solve(self: psi4.core.HF, x_vec: list[psi4.core.Matrix], conv_tol: float, max_iter: int, print_lvl: int = 2)  list[psi4.core.Matrix]; Solves the CPHF equations for a given set of x vectors. damping_update(self: psi4.core.HF, arg0: float)  None; docstring. diis(self: psi4.core.HF, arg0: float)  bool; docstring. finalize(self: psi4.core.HF)  None; Cleans up the the Wavefunctions te",MatchSource.WIKI,psi4manual/master/api/psi4.core.HF.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.HF.html
https://psicode.org/psi4manual/master/api/psi4.core.IDAMAX.html:464,Deployability,update,updated,464,". IDAMAX. Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; IDAMAX. IDAMAX. psi4.core.IDAMAX(arg0: int, arg1: int, arg2: psi::Vector, arg3: int)  int; docstring. table of contents. IDAMAX; IDAMAX(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; IDAMAX.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/api/psi4.core.IDAMAX.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.IDAMAX.html
https://psicode.org/psi4manual/master/api/psi4.core.initialize.html:518,Deployability,update,updated,518,". initialize. Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; initialize. initialize. psi4.core.initialize()  bool; Called upon psi4 module import to initialize timers, singletons, and I/O. Idempotent. table of contents. initialize; initialize(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; initialize.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/api/psi4.core.initialize.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.initialize.html
https://psicode.org/psi4manual/master/api/psi4.core.IntegralFactory.html:9219,Deployability,update,updated,9219,"4.core.OneBodySOInt; Returns a OneBodyInt that computes the SO nabla integral. so_overlap(self: psi4.core.IntegralFactory, deriv: int = 0)  psi4.core.OneBodySOInt; Returns a OneBodyInt that computes the SO overlap integrals. so_potential(self: psi4.core.IntegralFactory, deriv: int = 0)  psi4.core.OneBodySOInt; Returns a OneBodyInt that computes the SO nuclear attraction integral. so_quadrupole(self: psi4.core.IntegralFactory)  psi4.core.OneBodySOInt; Returns a OneBodyInt that computes SO the quadrupole integral. so_traceless_quadrupole(self: psi4.core.IntegralFactory)  psi4.core.OneBodySOInt; Returns a OneBodyInt that computes the traceless SO quadrupole integral. table of contents. IntegralFactory; IntegralFactory; IntegralFactory.ao_angular_momentum(); IntegralFactory.ao_dipole(); IntegralFactory.ao_kinetic(); IntegralFactory.ao_multipole_potential(); IntegralFactory.ao_multipoles(); IntegralFactory.ao_nabla(); IntegralFactory.ao_overlap(); IntegralFactory.ao_potential(); IntegralFactory.ao_quadrupole(); IntegralFactory.ao_traceless_quadrupole(); IntegralFactory.electric_field(); IntegralFactory.electrostatic(); IntegralFactory.erf_complement_eri(); IntegralFactory.erf_eri(); IntegralFactory.eri(); IntegralFactory.f12(); IntegralFactory.f12_double_commutator(); IntegralFactory.f12_squared(); IntegralFactory.f12g12(); IntegralFactory.overlap_3c(); IntegralFactory.shells_iterator(); IntegralFactory.so_angular_momentum(); IntegralFactory.so_dipole(); IntegralFactory.so_kinetic(); IntegralFactory.so_multipoles(); IntegralFactory.so_nabla(); IntegralFactory.so_overlap(); IntegralFactory.so_potential(); IntegralFactory.so_quadrupole(); IntegralFactory.so_traceless_quadrupole(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; IntegralFactory.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/api/psi4.core.IntegralFactory.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.IntegralFactory.html
https://psicode.org/psi4manual/master/api/psi4.core.IntegralTransform.html:7201,Deployability,update,updated,7201,"update_orbitals(self: psi4.core.IntegralTransform)  None; docstring. table of contents. IntegralTransform; IntegralTransform; IntegralTransform.DPD_ID(); IntegralTransform.alpha_corr_to_pitzer(); IntegralTransform.backtransform_density(); IntegralTransform.backtransform_tpdm_restricted(); IntegralTransform.backtransform_tpdm_unrestricted(); IntegralTransform.beta_corr_to_pitzer(); IntegralTransform.compute_fock_like_matrices(); IntegralTransform.get_dpd_id(); IntegralTransform.get_frozen_core_energy(); IntegralTransform.get_keep_dpd_so_ints(); IntegralTransform.get_keep_ht_ints(); IntegralTransform.get_keep_iwl_so_ints(); IntegralTransform.get_memory(); IntegralTransform.get_print(); IntegralTransform.get_psio(); IntegralTransform.get_tei_already_presorted(); IntegralTransform.initialize(); IntegralTransform.nirrep(); IntegralTransform.presort_so_tei(); IntegralTransform.print_dpd_lookup(); IntegralTransform.reset_so_int(); IntegralTransform.set_aa_int_name(); IntegralTransform.set_ab_int_name(); IntegralTransform.set_bb_int_name(); IntegralTransform.set_dpd_id(); IntegralTransform.set_dpd_int_file(); IntegralTransform.set_keep_dpd_so_ints(); IntegralTransform.set_keep_ht_ints(); IntegralTransform.set_keep_iwl_so_ints(); IntegralTransform.set_memory(); IntegralTransform.set_orbitals(); IntegralTransform.set_print(); IntegralTransform.set_psio(); IntegralTransform.set_so_tei_file(); IntegralTransform.set_tei_already_presorted(); IntegralTransform.set_tpdm_already_presorted(); IntegralTransform.set_write_dpd_so_tpdm(); IntegralTransform.transform_tei(); IntegralTransform.transform_tei_first_half(); IntegralTransform.transform_tei_second_half(); IntegralTransform.update_orbitals(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; IntegralTransform.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/api/psi4.core.IntegralTransform.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.IntegralTransform.html
https://psicode.org/psi4manual/master/api/psi4.core.IntVector.html:3323,Deployability,update,updated,3323,"core.ProtoIntVector)  None; Copy another vector into this. dim(self: psi4.core.IntVector, h: int = 0)  int; Returns the number of dimensions per irrep h. dimpi(self: psi4.core.IntVector)  psi4.core.Dimension; Returns the Dimension object. get(*args, **kwargs); Overloaded function. get(self: psi4.core.IntVector, m: int) -> int. Returns a single element value located at m. get(self: psi4.core.IntVector, h: int, m: int) -> int. Returns a single element value located at m in irrep h. get_block(self: psi4.core.IntVector, slice: psi4.core.Slice)  psi4.core.IntVector; Get a vector block. init(self: psi4.core.IntVector, arg0: psi4.core.Dimension)  None; Reallocate the data of the Vector. Consider making a new object. static iota(arg0: psi4.core.Dimension)  psi4.core.IntVector. nirrep(self: psi4.core.IntVector)  int; Returns the number of irreps. print_out(self: psi4.core.IntVector)  None; Prints the vector to the output file. set(*args, **kwargs); Overloaded function. set(self: psi4.core.IntVector, m: int, val: int) -> None. Sets a single element value located at m. set(self: psi4.core.IntVector, h: int, m: int, val: int) -> None. Sets a single element value located at m in irrep h. set_block(self: psi4.core.IntVector, slice: psi4.core.Slice, block: psi4.core.ProtoIntVector)  None; Set a vector block. zero(self: psi4.core.IntVector)  None; Zeros the vector. table of contents. IntVector; IntVector; IntVector.name; IntVector.add(); IntVector.clone(); IntVector.copy(); IntVector.dim(); IntVector.dimpi(); IntVector.get(); IntVector.get_block(); IntVector.init(); IntVector.iota(); IntVector.nirrep(); IntVector.print_out(); IntVector.set(); IntVector.set_block(); IntVector.zero(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; IntVector.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/api/psi4.core.IntVector.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.IntVector.html
https://psicode.org/psi4manual/master/api/psi4.core.IO.html:3676,Deployability,update,updated,3676,"ookup process id. open(self: psi4.core.IO, unit: int, status: int)  None; Open unit. Status can be PSIO_OPEN_OLD (if existing file is to be opened) or PSIO_OPEN_NEW if new file should be open. open_check(self: psi4.core.IO, unit: int)  int; Return 1 if unit is open. rehash(self: psi4.core.IO, unit: int)  None; Sync up the object to the file on disk by closing and opening the file, if necessary. static set_default_namespace(ns: str)  None; Set the current namespace (for PREFIX.NAMESPACE.UNIT file numbering). set_pid(self: psi4.core.IO, pid: str)  None; Set process id. static shared_object()  psi4.core.IO; Return the global shared object. state(self: psi4.core.IO)  int; Return 1 if PSIO library is activated. tocclean(self: psi4.core.IO, unit: int, key: str)  None; Delete all TOC entries after the given key. If a blank key is given, the entire TOC will be wiped. tocentry_exists(self: psi4.core.IO, arg0: int, arg1: str)  bool; Checks the TOC to see if a particular keyword exists there or not. tocprint(self: psi4.core.IO, arg0: int)  None; Print the table of contents for the given unit. tocscan(self: psi4.core.IO, arg0: int, arg1: str)  psi4.core.psio_entry; Seek string in binary file. This export is only good for catching None, as returned success object not exported. tocwrite(self: psi4.core.IO, arg0: int)  None; Write the table of contents for passed file number. table of contents. IO; IO; IO.change_file_namespace(); IO.close(); IO.exists(); IO.get_default_namespace(); IO.getpid(); IO.open(); IO.open_check(); IO.rehash(); IO.set_default_namespace(); IO.set_pid(); IO.shared_object(); IO.state(); IO.tocclean(); IO.tocentry_exists(); IO.tocprint(); IO.tocscan(); IO.tocwrite(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; IO.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/api/psi4.core.IO.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.IO.html
https://psicode.org/psi4manual/master/api/psi4.core.IOManager.html:3222,Deployability,update,updated,3222,"IOManager)  None; Clean from disk-mirrored image after crash. NOT to be called during regular computation. get_default_path(self: psi4.core.IOManager)  str; Return the default path. get_file_path(self: psi4.core.IOManager, fileno: int)  str; Get the path for a specific file number. mark_file_for_retention(self: psi4.core.IOManager, full_path: str, retain: bool)  None; Mark a file to be retained after a psiclean operation, ie for use in a later computation. print_out(self: psi4.core.IOManager)  None; Print the current status of PSI4 files. psiclean(self: psi4.core.IOManager)  None; Execute the psiclean protocol, deleting all recorded files, except those currently marked for retention. set_default_path(self: psi4.core.IOManager, path: str)  None; Set the default path for files to be stored. set_specific_path(self: psi4.core.IOManager, fileno: int, path: str)  None; Set the path for specific file numbers. set_specific_retention(self: psi4.core.IOManager, fileno: int, retain: bool)  None; Set the specific file number to be retained. static shared_object()  psi4.core.IOManager; The one and (should be) only instance of PSIOManager for a PSI4 instance. write_scratch_file(self: psi4.core.IOManager, full_path: str, text: str)  None; Write a string to a temporary file. The scratch file is opened and closed by this function. table of contents. IOManager; IOManager; IOManager.crashclean(); IOManager.get_default_path(); IOManager.get_file_path(); IOManager.mark_file_for_retention(); IOManager.print_out(); IOManager.psiclean(); IOManager.set_default_path(); IOManager.set_specific_path(); IOManager.set_specific_retention(); IOManager.shared_object(); IOManager.write_scratch_file(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; IOManager.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/api/psi4.core.IOManager.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.IOManager.html
https://psicode.org/psi4manual/master/api/psi4.core.IOManager.html:752,Integrability,protocol,protocol,752,". IOManager. Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; IOManager. IOManager. class psi4.core.IOManager; Bases: pybind11_object; PSIOManager is a class designed to be used as a static object to track all PSIO operations in a given PSI4 computation; Methods Summary. crashclean(self); Clean from disk-mirrored image after crash. get_default_path(self); Return the default path. get_file_path(self,fileno); Get the path for a specific file number. mark_file_for_retention(self,full_path,retain); Mark a file to be retained after a psiclean operation, ie for use in a later computation. print_out(self); Print the current status of PSI4 files. psiclean(self); Execute the psiclean protocol, deleting all recorded files, except those currently marked for retention. set_default_path(self,path); Set the default path for files to be stored. set_specific_path(self,fileno,path); Set the path for specific file numbers. set_specific_retention(self,fileno,retain); Set the specific file number to be retained. shared_object(); The one and (should be) only instance of PSIOManager for a PSI4 instance. write_scratch_file(self,full_path,text); Write a string to a temporary file. Methods Documentation. crashclean(self: psi4.core.IOManager)  None; Clean from disk-mirrored image after crash. NOT to be called during regular computation. get_default_path(self: psi4.core.IOManager)  str; Return the default path. get_file_path(self: psi4.core.IOManager, fileno: int)  str; Get the path for a specific file number. mark_file_for_retention(self: psi4.core.IOManager, full_path: str, retain: bool)  None; Mark a file to be retained after a psiclean operation, ie for use in a later computation. print_out(self: psi4.core.IOManager)  None; Print the current status of PSI4 files. psiclean(self: psi4.core.IOManager)  None; Execute the psiclean protocol, deleting all recorded files, except those currently marked for retent",MatchSource.WIKI,psi4manual/master/api/psi4.core.IOManager.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.IOManager.html
https://psicode.org/psi4manual/master/api/psi4.core.IOManager.html:1922,Integrability,protocol,protocol,1922,"path); Set the path for specific file numbers. set_specific_retention(self,fileno,retain); Set the specific file number to be retained. shared_object(); The one and (should be) only instance of PSIOManager for a PSI4 instance. write_scratch_file(self,full_path,text); Write a string to a temporary file. Methods Documentation. crashclean(self: psi4.core.IOManager)  None; Clean from disk-mirrored image after crash. NOT to be called during regular computation. get_default_path(self: psi4.core.IOManager)  str; Return the default path. get_file_path(self: psi4.core.IOManager, fileno: int)  str; Get the path for a specific file number. mark_file_for_retention(self: psi4.core.IOManager, full_path: str, retain: bool)  None; Mark a file to be retained after a psiclean operation, ie for use in a later computation. print_out(self: psi4.core.IOManager)  None; Print the current status of PSI4 files. psiclean(self: psi4.core.IOManager)  None; Execute the psiclean protocol, deleting all recorded files, except those currently marked for retention. set_default_path(self: psi4.core.IOManager, path: str)  None; Set the default path for files to be stored. set_specific_path(self: psi4.core.IOManager, fileno: int, path: str)  None; Set the path for specific file numbers. set_specific_retention(self: psi4.core.IOManager, fileno: int, retain: bool)  None; Set the specific file number to be retained. static shared_object()  psi4.core.IOManager; The one and (should be) only instance of PSIOManager for a PSI4 instance. write_scratch_file(self: psi4.core.IOManager, full_path: str, text: str)  None; Write a string to a temporary file. The scratch file is opened and closed by this function. table of contents. IOManager; IOManager; IOManager.crashclean(); IOManager.get_default_path(); IOManager.get_file_path(); IOManager.mark_file_for_retention(); IOManager.print_out(); IOManager.psiclean(); IOManager.set_default_path(); IOManager.set_specific_path(); IOManager.set_speci",MatchSource.WIKI,psi4manual/master/api/psi4.core.IOManager.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.IOManager.html
https://psicode.org/psi4manual/master/api/psi4.core.IrreducibleRepresentation.html:1101,Deployability,update,updated,1101,". IrreducibleRepresentation. Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; IrreducibleRepresentation. IrreducibleRepresentation. class psi4.core.IrreducibleRepresentation; Bases: pybind11_object; An irreducible representation of the point group; Methods Summary. character(self,arg0); Return the character of the i'th symmetry operation for the irrep. symbol(self); Return the symbol for the irrep. Methods Documentation. character(self: psi4.core.IrreducibleRepresentation, arg0: int)  float; Return the character of the ith symmetry operation for the irrep. 0-indexed. symbol(self: psi4.core.IrreducibleRepresentation)  str; Return the symbol for the irrep. table of contents. IrreducibleRepresentation; IrreducibleRepresentation; IrreducibleRepresentation.character(); IrreducibleRepresentation.symbol(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; IrreducibleRepresentation.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/api/psi4.core.IrreducibleRepresentation.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.IrreducibleRepresentation.html
https://psicode.org/psi4manual/master/api/psi4.core.JK.html:5644,Deployability,update,updated,5644,"arated DFT. get_omega_beta(self: psi4.core.JK)  float; Weight for dampened exchange term in range-separated DFT. get_wcombine(self: psi4.core.JK)  bool; wcombine. initialize(self: psi4.core.JK)  None. memory_estimate(self: psi4.core.JK)  int. name(self: psi4.core.JK)  str. print_header(self: psi4.core.JK)  None; docstring. set_cutoff(self: psi4.core.JK, arg0: float)  None. set_do_J(self: psi4.core.JK, arg0: bool)  None. set_do_K(self: psi4.core.JK, arg0: bool)  None. set_do_wK(self: psi4.core.JK, arg0: bool)  None. set_memory(self: psi4.core.JK, arg0: int)  None. set_omega(self: psi4.core.JK, omega: float)  None; Dampening term for range separated DFT. set_omega_alpha(self: psi4.core.JK, alpha: float)  None; Weight for HF exchange term in range-separated DFT. set_omega_beta(self: psi4.core.JK, beta: float)  None; Weight for dampened exchange term in range-separated DFT. set_omp_nthread(self: psi4.core.JK, arg0: int)  None. set_print(self: psi4.core.JK, arg0: int)  None. set_wcombine(self: psi4.core.JK, wcombine: bool)  None; Are Exchange terms in one Matrix. wK(self: psi4.core.JK)  list[psi4.core.Matrix]. table of contents. JK; JK; JK.C_add(); JK.C_clear(); JK.C_left_add(); JK.C_right_add(); JK.D(); JK.J(); JK.K(); JK.basisset(); JK.build(); JK.build_JK(); JK.compute(); JK.computed_shells_per_iter(); JK.finalize(); JK.get_omega(); JK.get_omega_alpha(); JK.get_omega_beta(); JK.get_wcombine(); JK.initialize(); JK.memory_estimate(); JK.name(); JK.print_header(); JK.set_cutoff(); JK.set_do_J(); JK.set_do_K(); JK.set_do_wK(); JK.set_memory(); JK.set_omega(); JK.set_omega_alpha(); JK.set_omega_beta(); JK.set_omp_nthread(); JK.set_print(); JK.set_wcombine(); JK.wK(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; JK.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/api/psi4.core.JK.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.JK.html
https://psicode.org/psi4manual/master/api/psi4.core.KineticInt.html:476,Deployability,update,updated,476,". KineticInt. Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; KineticInt. KineticInt. class psi4.core.KineticInt; Bases: OneBodyAOInt; Computes kinetic integrals. table of contents. KineticInt; KineticInt. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; KineticInt.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/api/psi4.core.KineticInt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.KineticInt.html
https://psicode.org/psi4manual/master/api/psi4.core.LaplaceDenominator.html:1331,Deployability,update,updated,1331,". LaplaceDenominator. Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; LaplaceDenominator. LaplaceDenominator. class psi4.core.LaplaceDenominator; Bases: pybind11_object; Computer class for a Laplace factorization of the four-index energy denominator in MP2 and coupled-cluster; Methods Summary. denominator_occ(self); Returns the occupied orbital Laplace weights of the factorized doubles denominator (nweights * nocc). denominator_vir(self); Returns the virtual orbital Laplace weights of the factorized doubles denominator (nweights * nvirt). Methods Documentation. denominator_occ(self: psi4.core.LaplaceDenominator)  psi4.core.Matrix; Returns the occupied orbital Laplace weights of the factorized doubles denominator (nweights * nocc). denominator_vir(self: psi4.core.LaplaceDenominator)  psi4.core.Matrix; Returns the virtual orbital Laplace weights of the factorized doubles denominator (nweights * nvirt). table of contents. LaplaceDenominator; LaplaceDenominator; LaplaceDenominator.denominator_occ(); LaplaceDenominator.denominator_vir(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; LaplaceDenominator.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/api/psi4.core.LaplaceDenominator.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.LaplaceDenominator.html
https://psicode.org/psi4manual/master/api/psi4.core.LaplaceDenominator.html:297,Energy Efficiency,energy,energy,297,". LaplaceDenominator. Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; LaplaceDenominator. LaplaceDenominator. class psi4.core.LaplaceDenominator; Bases: pybind11_object; Computer class for a Laplace factorization of the four-index energy denominator in MP2 and coupled-cluster; Methods Summary. denominator_occ(self); Returns the occupied orbital Laplace weights of the factorized doubles denominator (nweights * nocc). denominator_vir(self); Returns the virtual orbital Laplace weights of the factorized doubles denominator (nweights * nvirt). Methods Documentation. denominator_occ(self: psi4.core.LaplaceDenominator)  psi4.core.Matrix; Returns the occupied orbital Laplace weights of the factorized doubles denominator (nweights * nocc). denominator_vir(self: psi4.core.LaplaceDenominator)  psi4.core.Matrix; Returns the virtual orbital Laplace weights of the factorized doubles denominator (nweights * nvirt). table of contents. LaplaceDenominator; LaplaceDenominator; LaplaceDenominator.denominator_occ(); LaplaceDenominator.denominator_vir(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; LaplaceDenominator.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/api/psi4.core.LaplaceDenominator.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.LaplaceDenominator.html
https://psicode.org/psi4manual/master/api/psi4.core.libint2_solid_harmonics_ordering.html:651,Deployability,update,updated,651,". libint2_solid_harmonics_ordering. Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; libint2_solid_harmonics_ordering. libint2_solid_harmonics_ordering. psi4.core.libint2_solid_harmonics_ordering()  str; The solid harmonics setting of Libint2 currently active for Psi4. table of contents. libint2_solid_harmonics_ordering; libint2_solid_harmonics_ordering(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; libint2_solid_harmonics_ordering.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/api/psi4.core.libint2_solid_harmonics_ordering.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.libint2_solid_harmonics_ordering.html
https://psicode.org/psi4manual/master/api/psi4.core.LibXCFunctional.html:2028,Deployability,update,updated,2028,"Linking C++ and Python; LibXCFunctional. LibXCFunctional. class psi4.core.LibXCFunctional; Bases: Functional; docstring; Methods Summary. density_cutoff(self); docstring. get_mix_data(self); docstring. query_libxc(self,arg0); query libxc regarding functional parameters. set_density_cutoff(self,arg0); docstring. set_omega(self,arg0); docstring. set_tweak(*args,**kwargs); Overloaded function. xclib_description(); query libxc for version and citation. Methods Documentation. density_cutoff(self: psi4.core.LibXCFunctional)  float; docstring. get_mix_data(self: psi4.core.LibXCFunctional)  list[tuple[str, int, float]]; docstring. query_libxc(self: psi4.core.LibXCFunctional, arg0: str)  dict[str, float]; query libxc regarding functional parameters. set_density_cutoff(self: psi4.core.LibXCFunctional, arg0: float)  None; docstring. set_omega(self: psi4.core.LibXCFunctional, arg0: float)  None; docstring. set_tweak(*args, **kwargs); Overloaded function. set_tweak(self: psi4.core.LibXCFunctional, tweaks: list[float], quiet: bool = False) -> None. Set all tweaks on a LibXC functional through a list. Deprecated in v1.4. set_tweak(self: psi4.core.LibXCFunctional, tweaks: dict[str, float], quiet: bool = False) -> None. Set all tweaks on a LibXC functional through a dictionary of names (usually underscore prepended) and values. New in v1.4. xclib_description()  str; query libxc for version and citation. table of contents. LibXCFunctional; LibXCFunctional; LibXCFunctional.density_cutoff(); LibXCFunctional.get_mix_data(); LibXCFunctional.query_libxc(); LibXCFunctional.set_density_cutoff(); LibXCFunctional.set_omega(); LibXCFunctional.set_tweak(); LibXCFunctional.xclib_description(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; LibXCFunctional.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/api/psi4.core.LibXCFunctional.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.LibXCFunctional.html
https://psicode.org/psi4manual/master/api/psi4.core.Localizer.html:1221,Deployability,update,updated,1221,". Localizer. Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; Localizer. Localizer. class psi4.core.Localizer; Bases: pybind11_object; Class containing orbital localization procedures; Attributes Summary. L; Localized orbital coefficients. U; Orbital rotation matrix. converged; Did the localization procedure converge?. Methods Summary. build(arg0,arg1,arg2); Build the localization scheme. localize(self); Perform the localization procedure. Attributes Documentation. L; Localized orbital coefficients. U; Orbital rotation matrix. converged; Did the localization procedure converge?. Methods Documentation. static build(arg0: str, arg1: psi4.core.BasisSet, arg2: psi4.core.Matrix)  psi4.core.Localizer; Build the localization scheme. localize(self: psi4.core.Localizer)  None; Perform the localization procedure. table of contents. Localizer; Localizer; Localizer.L; Localizer.U; Localizer.converged; Localizer.build(); Localizer.localize(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; Localizer.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/api/psi4.core.Localizer.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.Localizer.html
https://psicode.org/psi4manual/master/api/psi4.core.Localizer.html:475,Performance,Perform,Perform,475,". Localizer. Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; Localizer. Localizer. class psi4.core.Localizer; Bases: pybind11_object; Class containing orbital localization procedures; Attributes Summary. L; Localized orbital coefficients. U; Orbital rotation matrix. converged; Did the localization procedure converge?. Methods Summary. build(arg0,arg1,arg2); Build the localization scheme. localize(self); Perform the localization procedure. Attributes Documentation. L; Localized orbital coefficients. U; Orbital rotation matrix. converged; Did the localization procedure converge?. Methods Documentation. static build(arg0: str, arg1: psi4.core.BasisSet, arg2: psi4.core.Matrix)  psi4.core.Localizer; Build the localization scheme. localize(self: psi4.core.Localizer)  None; Perform the localization procedure. table of contents. Localizer; Localizer; Localizer.L; Localizer.U; Localizer.converged; Localizer.build(); Localizer.localize(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; Localizer.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/api/psi4.core.Localizer.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.Localizer.html
https://psicode.org/psi4manual/master/api/psi4.core.Localizer.html:853,Performance,Perform,Perform,853,". Localizer. Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; Localizer. Localizer. class psi4.core.Localizer; Bases: pybind11_object; Class containing orbital localization procedures; Attributes Summary. L; Localized orbital coefficients. U; Orbital rotation matrix. converged; Did the localization procedure converge?. Methods Summary. build(arg0,arg1,arg2); Build the localization scheme. localize(self); Perform the localization procedure. Attributes Documentation. L; Localized orbital coefficients. U; Orbital rotation matrix. converged; Did the localization procedure converge?. Methods Documentation. static build(arg0: str, arg1: psi4.core.BasisSet, arg2: psi4.core.Matrix)  psi4.core.Localizer; Build the localization scheme. localize(self: psi4.core.Localizer)  None; Perform the localization procedure. table of contents. Localizer; Localizer; Localizer.L; Localizer.U; Localizer.converged; Localizer.build(); Localizer.localize(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; Localizer.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/api/psi4.core.Localizer.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.Localizer.html
https://psicode.org/psi4manual/master/api/psi4.core.LS_THC_Computer.html:1866,Deployability,update,updated,1866,". LS_THC_Computer. Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; LS_THC_Computer. LS_THC_Computer. class psi4.core.LS_THC_Computer; Bases: pybind11_object; Computer class for grid-based tensor hypercontraction (THC) of two-electron integrals (Parrish 2012); Methods Summary. compute_thc_factorization(self); Compute the THC (x1, x2, Z, x3, x4) factors through grid based LS-THC. get_Z(self); Returns Z factor from LS-THC factorization. get_x1(self); Returns x1 factor from LS-THC factorization. get_x2(self); Returns x2 factor from LS-THC factorization. get_x3(self); Returns x3 factor from LS-THC factorization. get_x4(self); Returns x4 factor from LS-THC factorization. Methods Documentation. compute_thc_factorization(self: psi4.core.LS_THC_Computer)  None; Compute the THC (x1, x2, Z, x3, x4) factors through grid based LS-THC. get_Z(self: psi4.core.LS_THC_Computer)  psi4.core.Matrix; Returns Z factor from LS-THC factorization. get_x1(self: psi4.core.LS_THC_Computer)  psi4.core.Matrix; Returns x1 factor from LS-THC factorization. get_x2(self: psi4.core.LS_THC_Computer)  psi4.core.Matrix; Returns x2 factor from LS-THC factorization. get_x3(self: psi4.core.LS_THC_Computer)  psi4.core.Matrix; Returns x3 factor from LS-THC factorization. get_x4(self: psi4.core.LS_THC_Computer)  psi4.core.Matrix; Returns x4 factor from LS-THC factorization. table of contents. LS_THC_Computer; LS_THC_Computer; LS_THC_Computer.compute_thc_factorization(); LS_THC_Computer.get_Z(); LS_THC_Computer.get_x1(); LS_THC_Computer.get_x2(); LS_THC_Computer.get_x3(); LS_THC_Computer.get_x4(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; LS_THC_Computer.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/api/psi4.core.LS_THC_Computer.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.LS_THC_Computer.html
https://psicode.org/psi4manual/master/api/psi4.core.Matrix.html:19736,Deployability,update,updated,19736," all elements of the matrix. zero_diagonal(self: psi4.core.Matrix)  None; Zero the diagonal of the matrix. zero_lower(self: psi4.core.Matrix)  None; Zero the lower triangle. zero_upper(self: psi4.core.Matrix)  None; Zero the upper triangle. table of contents. Matrix; Matrix; Matrix.name; Matrix.np; Matrix.nph; Matrix.shape; Matrix.absmax(); Matrix.accumulate_product(); Matrix.add(); Matrix.add_and_orthogonalize_row(); Matrix.apply_denominator(); Matrix.array_interface(); Matrix.axpy(); Matrix.back_transform(); Matrix.chain_dot(); Matrix.cholesky_factorize(); Matrix.clone(); Matrix.coldim(); Matrix.cols(); Matrix.copy(); Matrix.copy_lower_to_upper(); Matrix.copy_upper_to_lower(); Matrix.diagonalize(); Matrix.doublet(); Matrix.from_array(); Matrix.from_list(); Matrix.from_serial(); Matrix.gemm(); Matrix.general_invert(); Matrix.get(); Matrix.get_block(); Matrix.hermitivitize(); Matrix.hermitize(); Matrix.identity(); Matrix.invert(); Matrix.load(); Matrix.load_mpqc(); Matrix.nirrep(); Matrix.np_read(); Matrix.np_write(); Matrix.partial_cholesky_factorize(); Matrix.power(); Matrix.print_atom_vector(); Matrix.print_out(); Matrix.pseudoinverse(); Matrix.remove_symmetry(); Matrix.rms(); Matrix.rotate_columns(); Matrix.rowdim(); Matrix.rows(); Matrix.save(); Matrix.scale(); Matrix.scale_column(); Matrix.scale_row(); Matrix.schmidt(); Matrix.set(); Matrix.set_block(); Matrix.subtract(); Matrix.sum_of_squares(); Matrix.symmetrize_gradient(); Matrix.symmetry(); Matrix.to_array(); Matrix.to_serial(); Matrix.trace(); Matrix.transform(); Matrix.transpose(); Matrix.transpose_this(); Matrix.triplet(); Matrix.vector_dot(); Matrix.zero(); Matrix.zero_diagonal(); Matrix.zero_lower(); Matrix.zero_upper(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; Matrix.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/api/psi4.core.Matrix.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.Matrix.html
https://psicode.org/psi4manual/master/api/psi4.core.Matrix.html:3304,Energy Efficiency,power,power,3304,"rix using LU factorization. get(*args,**kwargs); Overloaded function. get_block(self,rows,cols); Get a matrix block. hermitivitize(self); Average off-diagonal element in-place. hermitize(self); Makes a real matrix symmetric by averaging the matrix and its transpose. identity(self); Sets the matrix to the identity. invert(self); Computes the inverse of a real symmetric positive definite matrix. load(*args,**kwargs); Overloaded function. load_mpqc(self,filename); Loads a matrix from an ASCII file in MPQC format. nirrep(self); Returns the number of irreps. np_read([prefix]); Reads the data from a NumPy compressed or uncompressed file using numpy.load(). np_write([filename,prefix]); Writes the irrepped matrix to a NumPy uncompressed file using numpy.savez(). partial_cholesky_factorize(self[,delta,...]); Computes the fully pivoted partial Cholesky factorization of a real symmetric positive semidefinite matrix, to numerical precision delta. power(self,alpha[,cutoff]); Takes the matrix to the alpha power with precision cutoff. print_atom_vector(self[,RMRoutfile]); Print the matrix with atom labels, assuming it is an natom X 3 tensor. print_out(self); Prints the matrix to the output file. pseudoinverse(self,condition,nremoved); Computes the matrix which is the conditioned pseudoinverse of this matrix. remove_symmetry(self,a,transformer); Remove symmetry from a matrix A with PetiteList::sotoao(). rms(self); Returns the rms of this matrix. rotate_columns(self,h,i,j,theta); Rotates columns i and j in irrep h by angle theta. rowdim(self); Returns the rows per irrep array. rows(self[,h]); Returns the rows in irrep h. save(*args,**kwargs); Overloaded function. scale(self,a); Scales the matrix by the floating point value a. scale_column(self,h,n,a); Scales column n of irrep h by a. scale_row(self,h,m,a); Scales row m of irrep h by a. schmidt(self); Calls the libqt schmidt function. set(*args,**kwargs); Overloaded function. set_block(self,rows,cols,bl",MatchSource.WIKI,psi4manual/master/api/psi4.core.Matrix.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.Matrix.html
https://psicode.org/psi4manual/master/api/psi4.core.Matrix.html:3364,Energy Efficiency,power,power,3364,"rix using LU factorization. get(*args,**kwargs); Overloaded function. get_block(self,rows,cols); Get a matrix block. hermitivitize(self); Average off-diagonal element in-place. hermitize(self); Makes a real matrix symmetric by averaging the matrix and its transpose. identity(self); Sets the matrix to the identity. invert(self); Computes the inverse of a real symmetric positive definite matrix. load(*args,**kwargs); Overloaded function. load_mpqc(self,filename); Loads a matrix from an ASCII file in MPQC format. nirrep(self); Returns the number of irreps. np_read([prefix]); Reads the data from a NumPy compressed or uncompressed file using numpy.load(). np_write([filename,prefix]); Writes the irrepped matrix to a NumPy uncompressed file using numpy.savez(). partial_cholesky_factorize(self[,delta,...]); Computes the fully pivoted partial Cholesky factorization of a real symmetric positive semidefinite matrix, to numerical precision delta. power(self,alpha[,cutoff]); Takes the matrix to the alpha power with precision cutoff. print_atom_vector(self[,RMRoutfile]); Print the matrix with atom labels, assuming it is an natom X 3 tensor. print_out(self); Prints the matrix to the output file. pseudoinverse(self,condition,nremoved); Computes the matrix which is the conditioned pseudoinverse of this matrix. remove_symmetry(self,a,transformer); Remove symmetry from a matrix A with PetiteList::sotoao(). rms(self); Returns the rms of this matrix. rotate_columns(self,h,i,j,theta); Rotates columns i and j in irrep h by angle theta. rowdim(self); Returns the rows per irrep array. rows(self[,h]); Returns the rows in irrep h. save(*args,**kwargs); Overloaded function. scale(self,a); Scales the matrix by the floating point value a. scale_column(self,h,n,a); Scales column n of irrep h by a. scale_row(self,h,m,a); Scales row m of irrep h by a. schmidt(self); Calls the libqt schmidt function. set(*args,**kwargs); Overloaded function. set_block(self,rows,cols,bl",MatchSource.WIKI,psi4manual/master/api/psi4.core.Matrix.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.Matrix.html
https://psicode.org/psi4manual/master/api/psi4.core.Matrix.html:13014,Energy Efficiency,power,power,13014,"ucted.; filename (str)  File name to read.; prefix (str)  Name under which array was saved for NumPy. Return type:; Union[Matrix, Vector]. np_write(filename=None, prefix=''); Writes the irrepped matrix to a NumPy uncompressed file using numpy.savez().; Can return the packed data for saving many matrices into the same file. Parameters:. self (Union[Matrix, Vector])  Instance to be serialized.; filename (Optional[str])  File name where the data will be saved.; prefix (str)  Name of instance prepared for NumPy. Returns:; When filename given, it and dict serialization passed to; numpy.savez(), so .npz file saved and None returned.; When filename None, dict serialization returned. Return type:; None or Dict[str, Any]. partial_cholesky_factorize(self: psi4.core.Matrix, delta: float = 0.0, throw_if_negative: bool = False)  psi4.core.Matrix; Computes the fully pivoted partial Cholesky factorization of a real symmetric positive semidefinite matrix, to numerical precision delta. power(self: psi4.core.Matrix, alpha: float, cutoff: float = 1e-12)  psi4.core.Dimension; Takes the matrix to the alpha power with precision cutoff. print_atom_vector(self: psi4.core.Matrix, RMRoutfile: str = 'outfile')  None; Print the matrix with atom labels, assuming it is an natom X 3 tensor. print_out(self: psi4.core.Matrix)  None; Prints the matrix to the output file. pseudoinverse(self: psi4.core.Matrix, condition: float, nremoved: int)  psi4.core.Matrix; Computes the matrix which is the conditioned pseudoinverse of this matrix. remove_symmetry(self: psi4.core.Matrix, a: psi4.core.Matrix, transformer: psi4.core.Matrix)  None; Remove symmetry from a matrix A with PetiteList::sotoao(). rms(self: psi4.core.Matrix)  float; Returns the rms of this matrix. rotate_columns(self: psi4.core.Matrix, h: int, i: int, j: int, theta: float)  None; Rotates columns i and j in irrep h by angle theta. rowdim(self: psi4.core.Matrix)  psi4.core.Dimension; Returns the rows per irrep array. row",MatchSource.WIKI,psi4manual/master/api/psi4.core.Matrix.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.Matrix.html
https://psicode.org/psi4manual/master/api/psi4.core.Matrix.html:13135,Energy Efficiency,power,power,13135,"turn type:; Union[Matrix, Vector]. np_write(filename=None, prefix=''); Writes the irrepped matrix to a NumPy uncompressed file using numpy.savez().; Can return the packed data for saving many matrices into the same file. Parameters:. self (Union[Matrix, Vector])  Instance to be serialized.; filename (Optional[str])  File name where the data will be saved.; prefix (str)  Name of instance prepared for NumPy. Returns:; When filename given, it and dict serialization passed to; numpy.savez(), so .npz file saved and None returned.; When filename None, dict serialization returned. Return type:; None or Dict[str, Any]. partial_cholesky_factorize(self: psi4.core.Matrix, delta: float = 0.0, throw_if_negative: bool = False)  psi4.core.Matrix; Computes the fully pivoted partial Cholesky factorization of a real symmetric positive semidefinite matrix, to numerical precision delta. power(self: psi4.core.Matrix, alpha: float, cutoff: float = 1e-12)  psi4.core.Dimension; Takes the matrix to the alpha power with precision cutoff. print_atom_vector(self: psi4.core.Matrix, RMRoutfile: str = 'outfile')  None; Print the matrix with atom labels, assuming it is an natom X 3 tensor. print_out(self: psi4.core.Matrix)  None; Prints the matrix to the output file. pseudoinverse(self: psi4.core.Matrix, condition: float, nremoved: int)  psi4.core.Matrix; Computes the matrix which is the conditioned pseudoinverse of this matrix. remove_symmetry(self: psi4.core.Matrix, a: psi4.core.Matrix, transformer: psi4.core.Matrix)  None; Remove symmetry from a matrix A with PetiteList::sotoao(). rms(self: psi4.core.Matrix)  float; Returns the rms of this matrix. rotate_columns(self: psi4.core.Matrix, h: int, i: int, j: int, theta: float)  None; Rotates columns i and j in irrep h by angle theta. rowdim(self: psi4.core.Matrix)  psi4.core.Dimension; Returns the rows per irrep array. rows(self: psi4.core.Matrix, h: int = 0)  int; Returns the rows in irrep h. save(*args, **kwargs); Overloa",MatchSource.WIKI,psi4manual/master/api/psi4.core.Matrix.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.Matrix.html
https://psicode.org/psi4manual/master/api/psi4.core.Matrix.html:18899,Energy Efficiency,power,power,18899," all elements of the matrix. zero_diagonal(self: psi4.core.Matrix)  None; Zero the diagonal of the matrix. zero_lower(self: psi4.core.Matrix)  None; Zero the lower triangle. zero_upper(self: psi4.core.Matrix)  None; Zero the upper triangle. table of contents. Matrix; Matrix; Matrix.name; Matrix.np; Matrix.nph; Matrix.shape; Matrix.absmax(); Matrix.accumulate_product(); Matrix.add(); Matrix.add_and_orthogonalize_row(); Matrix.apply_denominator(); Matrix.array_interface(); Matrix.axpy(); Matrix.back_transform(); Matrix.chain_dot(); Matrix.cholesky_factorize(); Matrix.clone(); Matrix.coldim(); Matrix.cols(); Matrix.copy(); Matrix.copy_lower_to_upper(); Matrix.copy_upper_to_lower(); Matrix.diagonalize(); Matrix.doublet(); Matrix.from_array(); Matrix.from_list(); Matrix.from_serial(); Matrix.gemm(); Matrix.general_invert(); Matrix.get(); Matrix.get_block(); Matrix.hermitivitize(); Matrix.hermitize(); Matrix.identity(); Matrix.invert(); Matrix.load(); Matrix.load_mpqc(); Matrix.nirrep(); Matrix.np_read(); Matrix.np_write(); Matrix.partial_cholesky_factorize(); Matrix.power(); Matrix.print_atom_vector(); Matrix.print_out(); Matrix.pseudoinverse(); Matrix.remove_symmetry(); Matrix.rms(); Matrix.rotate_columns(); Matrix.rowdim(); Matrix.rows(); Matrix.save(); Matrix.scale(); Matrix.scale_column(); Matrix.scale_row(); Matrix.schmidt(); Matrix.set(); Matrix.set_block(); Matrix.subtract(); Matrix.sum_of_squares(); Matrix.symmetrize_gradient(); Matrix.symmetry(); Matrix.to_array(); Matrix.to_serial(); Matrix.trace(); Matrix.transform(); Matrix.transpose(); Matrix.transpose_this(); Matrix.triplet(); Matrix.vector_dot(); Matrix.zero(); Matrix.zero_diagonal(); Matrix.zero_lower(); Matrix.zero_upper(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; Matrix.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/api/psi4.core.Matrix.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.Matrix.html
https://psicode.org/psi4manual/master/api/psi4.core.Matrix.html:16423,Integrability,depend,depending,16423,"ce, cols: psi4.core.Slice, block: psi4.core.Matrix)  None; Set a matrix block. subtract(self: psi4.core.Matrix, arg0: psi4.core.Matrix)  None; Substract a matrix from this matrix. sum_of_squares(self: psi4.core.Matrix)  float; Returns the sum of the squares of this matrix. symmetrize_gradient(self: psi4.core.Matrix, mol: psi::Molecule)  None; Symmetrizes a gradient-like matrix (N,3) using information from a given molecule. symmetry(self: psi4.core.Matrix)  int; Returns the overall symmetry of the matrix. to_array(copy=True, dense=False); Converts a PSI4 Matrix or Vector to a NumPy array. Either copies the; data or simply constructs a view. Parameters:. matrix (Union[Matrix, Vector])  Pointers to which Psi4 core class should be used in the construction.; copy (bool)  Copy the data if True, return a view otherwise; dense (bool)  Converts irrepped Psi4 objects to diagonally blocked dense arrays if; True. Returns a list of arrays otherwise. Returns:; Returns a single or list of NumPy arrays depending on options. Return type:; ndarray or List[ndarray]. Notes; This is a generalized function to convert a Psi4 object to a NumPy array; Examples; >>> data = psi4.core.Matrix(3, 3); >>> data.to_array(); [[ 0. 0. 0.]; [ 0. 0. 0.]; [ 0. 0. 0.]]. to_serial(); Converts an object with a .nph accessor to a serialized dictionary. Parameters:; self (Union[Matrix, Vector])  Matrix or Vector instance. Returns:; Serialized dictionary with keys:. shape; data : List[str]; type : {matrix, vector}. Return type:; Dict[str, Any]. trace(self: psi4.core.Matrix)  float; Returns the trace of the matrix. transform(*args, **kwargs); Overloaded function. transform(self: psi4.core.Matrix, transformer: psi4.core.Matrix) -> None. Transform this matrix with transformer. transform(self: psi4.core.Matrix, a: psi4.core.Matrix, transformer: psi4.core.Matrix) -> None. Transform A with transformer. transpose(self: psi4.core.Matrix)  psi4.core.Matrix; Creates a new matrix that is the tran",MatchSource.WIKI,psi4manual/master/api/psi4.core.Matrix.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.Matrix.html
https://psicode.org/psi4manual/master/api/psi4.core.Matrix.html:2747,Performance,load,load,2747,"im1,dim2]); Converts a NumPy array or list of NumPy arrays into a PSI4 Matrix or Vector (irrepped if list). from_list(x). from_serial(); Converts serialized data to the correct Psi4 data type. gemm(self,transa,transb,alpha,a,b,beta); Generalized matrix multiplication argument transa Transpose the left matrix? argument transb Transpose the right matrix? argument alpha Prefactor for the matrix multiplication argument A Left matrix argument B Right matrix argument beta Prefactor for the resulting matrix. general_invert(self); Computes the inverse of any nonsingular matrix using LU factorization. get(*args,**kwargs); Overloaded function. get_block(self,rows,cols); Get a matrix block. hermitivitize(self); Average off-diagonal element in-place. hermitize(self); Makes a real matrix symmetric by averaging the matrix and its transpose. identity(self); Sets the matrix to the identity. invert(self); Computes the inverse of a real symmetric positive definite matrix. load(*args,**kwargs); Overloaded function. load_mpqc(self,filename); Loads a matrix from an ASCII file in MPQC format. nirrep(self); Returns the number of irreps. np_read([prefix]); Reads the data from a NumPy compressed or uncompressed file using numpy.load(). np_write([filename,prefix]); Writes the irrepped matrix to a NumPy uncompressed file using numpy.savez(). partial_cholesky_factorize(self[,delta,...]); Computes the fully pivoted partial Cholesky factorization of a real symmetric positive semidefinite matrix, to numerical precision delta. power(self,alpha[,cutoff]); Takes the matrix to the alpha power with precision cutoff. print_atom_vector(self[,RMRoutfile]); Print the matrix with atom labels, assuming it is an natom X 3 tensor. print_out(self); Prints the matrix to the output file. pseudoinverse(self,condition,nremoved); Computes the matrix which is the conditioned pseudoinverse of this matrix. remove_symmetry(self,a,transformer); Remove symmetry from a matrix A with PetiteList::sotoa",MatchSource.WIKI,psi4manual/master/api/psi4.core.Matrix.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.Matrix.html
https://psicode.org/psi4manual/master/api/psi4.core.Matrix.html:2818,Performance,Load,Loads,2818,"into a PSI4 Matrix or Vector (irrepped if list). from_list(x). from_serial(); Converts serialized data to the correct Psi4 data type. gemm(self,transa,transb,alpha,a,b,beta); Generalized matrix multiplication argument transa Transpose the left matrix? argument transb Transpose the right matrix? argument alpha Prefactor for the matrix multiplication argument A Left matrix argument B Right matrix argument beta Prefactor for the resulting matrix. general_invert(self); Computes the inverse of any nonsingular matrix using LU factorization. get(*args,**kwargs); Overloaded function. get_block(self,rows,cols); Get a matrix block. hermitivitize(self); Average off-diagonal element in-place. hermitize(self); Makes a real matrix symmetric by averaging the matrix and its transpose. identity(self); Sets the matrix to the identity. invert(self); Computes the inverse of a real symmetric positive definite matrix. load(*args,**kwargs); Overloaded function. load_mpqc(self,filename); Loads a matrix from an ASCII file in MPQC format. nirrep(self); Returns the number of irreps. np_read([prefix]); Reads the data from a NumPy compressed or uncompressed file using numpy.load(). np_write([filename,prefix]); Writes the irrepped matrix to a NumPy uncompressed file using numpy.savez(). partial_cholesky_factorize(self[,delta,...]); Computes the fully pivoted partial Cholesky factorization of a real symmetric positive semidefinite matrix, to numerical precision delta. power(self,alpha[,cutoff]); Takes the matrix to the alpha power with precision cutoff. print_atom_vector(self[,RMRoutfile]); Print the matrix with atom labels, assuming it is an natom X 3 tensor. print_out(self); Prints the matrix to the output file. pseudoinverse(self,condition,nremoved); Computes the matrix which is the conditioned pseudoinverse of this matrix. remove_symmetry(self,a,transformer); Remove symmetry from a matrix A with PetiteList::sotoao(). rms(self); Returns the rms of this matrix. rotate_column",MatchSource.WIKI,psi4manual/master/api/psi4.core.Matrix.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.Matrix.html
https://psicode.org/psi4manual/master/api/psi4.core.Matrix.html:3003,Performance,load,load,3003,"); Generalized matrix multiplication argument transa Transpose the left matrix? argument transb Transpose the right matrix? argument alpha Prefactor for the matrix multiplication argument A Left matrix argument B Right matrix argument beta Prefactor for the resulting matrix. general_invert(self); Computes the inverse of any nonsingular matrix using LU factorization. get(*args,**kwargs); Overloaded function. get_block(self,rows,cols); Get a matrix block. hermitivitize(self); Average off-diagonal element in-place. hermitize(self); Makes a real matrix symmetric by averaging the matrix and its transpose. identity(self); Sets the matrix to the identity. invert(self); Computes the inverse of a real symmetric positive definite matrix. load(*args,**kwargs); Overloaded function. load_mpqc(self,filename); Loads a matrix from an ASCII file in MPQC format. nirrep(self); Returns the number of irreps. np_read([prefix]); Reads the data from a NumPy compressed or uncompressed file using numpy.load(). np_write([filename,prefix]); Writes the irrepped matrix to a NumPy uncompressed file using numpy.savez(). partial_cholesky_factorize(self[,delta,...]); Computes the fully pivoted partial Cholesky factorization of a real symmetric positive semidefinite matrix, to numerical precision delta. power(self,alpha[,cutoff]); Takes the matrix to the alpha power with precision cutoff. print_atom_vector(self[,RMRoutfile]); Print the matrix with atom labels, assuming it is an natom X 3 tensor. print_out(self); Prints the matrix to the output file. pseudoinverse(self,condition,nremoved); Computes the matrix which is the conditioned pseudoinverse of this matrix. remove_symmetry(self,a,transformer); Remove symmetry from a matrix A with PetiteList::sotoao(). rms(self); Returns the rms of this matrix. rotate_columns(self,h,i,j,theta); Rotates columns i and j in irrep h by angle theta. rowdim(self); Returns the rows per irrep array. rows(self[,h]); Returns the rows in irrep h. save(*ar",MatchSource.WIKI,psi4manual/master/api/psi4.core.Matrix.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.Matrix.html
https://psicode.org/psi4manual/master/api/psi4.core.Matrix.html:11115,Performance,load,load,11115,"ix argument B Right matrix argument beta Prefactor for the resulting matrix. general_invert(self: psi4.core.Matrix)  None; Computes the inverse of any nonsingular matrix using LU factorization. get(*args, **kwargs); Overloaded function. get(self: psi4.core.Matrix, h: int, m: int, n: int) -> float. Returns a single element of a matrix in subblock h, row m, col n. get(self: psi4.core.Matrix, m: int, n: int) -> float. Returns a single element of a matrix, row m, col n. get_block(self: psi4.core.Matrix, rows: psi4.core.Slice, cols: psi4.core.Slice)  psi4.core.Matrix; Get a matrix block. hermitivitize(self: psi4.core.Matrix)  None; Average off-diagonal element in-place. hermitize(self: psi4.core.Matrix)  None; Makes a real matrix symmetric by averaging the matrix and its transpose. identity(self: psi4.core.Matrix)  None; Sets the matrix to the identity. invert(self: psi4.core.Matrix)  None; Computes the inverse of a real symmetric positive definite matrix. load(*args, **kwargs); Overloaded function. load(self: psi4.core.Matrix, filename: str) -> None. Loads a block matrix from an ASCII file (see tests/mints3 for format). load(self: psi4.core.Matrix, psio: psi4.core.IO, fileno: int, tocentry: str, nso: int) -> bool. Load a matrix from a PSIO object from fileno with tocentry of size nso. load(self: psi4.core.Matrix, psio: psi4.core.IO, fileno: int, savetype: psi4.core.SaveType = <SaveType.LowerTriangle: 2>) -> None. Load a matrix from a PSIO object from fileno and with toc position of the name of the matrix. load_mpqc(self: psi4.core.Matrix, filename: str)  None; Loads a matrix from an ASCII file in MPQC format. nirrep(self: psi4.core.Matrix)  int; Returns the number of irreps. classmethod np_read(prefix=''); Reads the data from a NumPy compressed or uncompressed file using numpy.load(). Parameters:. self  Pointer to which class to be constructed.; filename (str)  File name to read.; prefix (str)  Name under which array was saved for NumPy. Return type",MatchSource.WIKI,psi4manual/master/api/psi4.core.Matrix.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.Matrix.html
https://psicode.org/psi4manual/master/api/psi4.core.Matrix.html:11160,Performance,load,load,11160,"ment beta Prefactor for the resulting matrix. general_invert(self: psi4.core.Matrix)  None; Computes the inverse of any nonsingular matrix using LU factorization. get(*args, **kwargs); Overloaded function. get(self: psi4.core.Matrix, h: int, m: int, n: int) -> float. Returns a single element of a matrix in subblock h, row m, col n. get(self: psi4.core.Matrix, m: int, n: int) -> float. Returns a single element of a matrix, row m, col n. get_block(self: psi4.core.Matrix, rows: psi4.core.Slice, cols: psi4.core.Slice)  psi4.core.Matrix; Get a matrix block. hermitivitize(self: psi4.core.Matrix)  None; Average off-diagonal element in-place. hermitize(self: psi4.core.Matrix)  None; Makes a real matrix symmetric by averaging the matrix and its transpose. identity(self: psi4.core.Matrix)  None; Sets the matrix to the identity. invert(self: psi4.core.Matrix)  None; Computes the inverse of a real symmetric positive definite matrix. load(*args, **kwargs); Overloaded function. load(self: psi4.core.Matrix, filename: str) -> None. Loads a block matrix from an ASCII file (see tests/mints3 for format). load(self: psi4.core.Matrix, psio: psi4.core.IO, fileno: int, tocentry: str, nso: int) -> bool. Load a matrix from a PSIO object from fileno with tocentry of size nso. load(self: psi4.core.Matrix, psio: psi4.core.IO, fileno: int, savetype: psi4.core.SaveType = <SaveType.LowerTriangle: 2>) -> None. Load a matrix from a PSIO object from fileno and with toc position of the name of the matrix. load_mpqc(self: psi4.core.Matrix, filename: str)  None; Loads a matrix from an ASCII file in MPQC format. nirrep(self: psi4.core.Matrix)  int; Returns the number of irreps. classmethod np_read(prefix=''); Reads the data from a NumPy compressed or uncompressed file using numpy.load(). Parameters:. self  Pointer to which class to be constructed.; filename (str)  File name to read.; prefix (str)  Name under which array was saved for NumPy. Return type:; Union[Matrix, Vector]. np_wr",MatchSource.WIKI,psi4manual/master/api/psi4.core.Matrix.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.Matrix.html
https://psicode.org/psi4manual/master/api/psi4.core.Matrix.html:11213,Performance,Load,Loads,11213,"rix)  None; Computes the inverse of any nonsingular matrix using LU factorization. get(*args, **kwargs); Overloaded function. get(self: psi4.core.Matrix, h: int, m: int, n: int) -> float. Returns a single element of a matrix in subblock h, row m, col n. get(self: psi4.core.Matrix, m: int, n: int) -> float. Returns a single element of a matrix, row m, col n. get_block(self: psi4.core.Matrix, rows: psi4.core.Slice, cols: psi4.core.Slice)  psi4.core.Matrix; Get a matrix block. hermitivitize(self: psi4.core.Matrix)  None; Average off-diagonal element in-place. hermitize(self: psi4.core.Matrix)  None; Makes a real matrix symmetric by averaging the matrix and its transpose. identity(self: psi4.core.Matrix)  None; Sets the matrix to the identity. invert(self: psi4.core.Matrix)  None; Computes the inverse of a real symmetric positive definite matrix. load(*args, **kwargs); Overloaded function. load(self: psi4.core.Matrix, filename: str) -> None. Loads a block matrix from an ASCII file (see tests/mints3 for format). load(self: psi4.core.Matrix, psio: psi4.core.IO, fileno: int, tocentry: str, nso: int) -> bool. Load a matrix from a PSIO object from fileno with tocentry of size nso. load(self: psi4.core.Matrix, psio: psi4.core.IO, fileno: int, savetype: psi4.core.SaveType = <SaveType.LowerTriangle: 2>) -> None. Load a matrix from a PSIO object from fileno and with toc position of the name of the matrix. load_mpqc(self: psi4.core.Matrix, filename: str)  None; Loads a matrix from an ASCII file in MPQC format. nirrep(self: psi4.core.Matrix)  int; Returns the number of irreps. classmethod np_read(prefix=''); Reads the data from a NumPy compressed or uncompressed file using numpy.load(). Parameters:. self  Pointer to which class to be constructed.; filename (str)  File name to read.; prefix (str)  Name under which array was saved for NumPy. Return type:; Union[Matrix, Vector]. np_write(filename=None, prefix=''); Writes the irrepped matrix to a NumPy uncompress",MatchSource.WIKI,psi4manual/master/api/psi4.core.Matrix.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.Matrix.html
https://psicode.org/psi4manual/master/api/psi4.core.Matrix.html:11284,Performance,load,load,11284,"nsingular matrix using LU factorization. get(*args, **kwargs); Overloaded function. get(self: psi4.core.Matrix, h: int, m: int, n: int) -> float. Returns a single element of a matrix in subblock h, row m, col n. get(self: psi4.core.Matrix, m: int, n: int) -> float. Returns a single element of a matrix, row m, col n. get_block(self: psi4.core.Matrix, rows: psi4.core.Slice, cols: psi4.core.Slice)  psi4.core.Matrix; Get a matrix block. hermitivitize(self: psi4.core.Matrix)  None; Average off-diagonal element in-place. hermitize(self: psi4.core.Matrix)  None; Makes a real matrix symmetric by averaging the matrix and its transpose. identity(self: psi4.core.Matrix)  None; Sets the matrix to the identity. invert(self: psi4.core.Matrix)  None; Computes the inverse of a real symmetric positive definite matrix. load(*args, **kwargs); Overloaded function. load(self: psi4.core.Matrix, filename: str) -> None. Loads a block matrix from an ASCII file (see tests/mints3 for format). load(self: psi4.core.Matrix, psio: psi4.core.IO, fileno: int, tocentry: str, nso: int) -> bool. Load a matrix from a PSIO object from fileno with tocentry of size nso. load(self: psi4.core.Matrix, psio: psi4.core.IO, fileno: int, savetype: psi4.core.SaveType = <SaveType.LowerTriangle: 2>) -> None. Load a matrix from a PSIO object from fileno and with toc position of the name of the matrix. load_mpqc(self: psi4.core.Matrix, filename: str)  None; Loads a matrix from an ASCII file in MPQC format. nirrep(self: psi4.core.Matrix)  int; Returns the number of irreps. classmethod np_read(prefix=''); Reads the data from a NumPy compressed or uncompressed file using numpy.load(). Parameters:. self  Pointer to which class to be constructed.; filename (str)  File name to read.; prefix (str)  Name under which array was saved for NumPy. Return type:; Union[Matrix, Vector]. np_write(filename=None, prefix=''); Writes the irrepped matrix to a NumPy uncompressed file using numpy.savez().; Can return the",MatchSource.WIKI,psi4manual/master/api/psi4.core.Matrix.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.Matrix.html
https://psicode.org/psi4manual/master/api/psi4.core.Matrix.html:11380,Performance,Load,Load,11380,"int, n: int) -> float. Returns a single element of a matrix in subblock h, row m, col n. get(self: psi4.core.Matrix, m: int, n: int) -> float. Returns a single element of a matrix, row m, col n. get_block(self: psi4.core.Matrix, rows: psi4.core.Slice, cols: psi4.core.Slice)  psi4.core.Matrix; Get a matrix block. hermitivitize(self: psi4.core.Matrix)  None; Average off-diagonal element in-place. hermitize(self: psi4.core.Matrix)  None; Makes a real matrix symmetric by averaging the matrix and its transpose. identity(self: psi4.core.Matrix)  None; Sets the matrix to the identity. invert(self: psi4.core.Matrix)  None; Computes the inverse of a real symmetric positive definite matrix. load(*args, **kwargs); Overloaded function. load(self: psi4.core.Matrix, filename: str) -> None. Loads a block matrix from an ASCII file (see tests/mints3 for format). load(self: psi4.core.Matrix, psio: psi4.core.IO, fileno: int, tocentry: str, nso: int) -> bool. Load a matrix from a PSIO object from fileno with tocentry of size nso. load(self: psi4.core.Matrix, psio: psi4.core.IO, fileno: int, savetype: psi4.core.SaveType = <SaveType.LowerTriangle: 2>) -> None. Load a matrix from a PSIO object from fileno and with toc position of the name of the matrix. load_mpqc(self: psi4.core.Matrix, filename: str)  None; Loads a matrix from an ASCII file in MPQC format. nirrep(self: psi4.core.Matrix)  int; Returns the number of irreps. classmethod np_read(prefix=''); Reads the data from a NumPy compressed or uncompressed file using numpy.load(). Parameters:. self  Pointer to which class to be constructed.; filename (str)  File name to read.; prefix (str)  Name under which array was saved for NumPy. Return type:; Union[Matrix, Vector]. np_write(filename=None, prefix=''); Writes the irrepped matrix to a NumPy uncompressed file using numpy.savez().; Can return the packed data for saving many matrices into the same file. Parameters:. self (Union[Matrix, Vector])  Instance to be serial",MatchSource.WIKI,psi4manual/master/api/psi4.core.Matrix.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.Matrix.html
https://psicode.org/psi4manual/master/api/psi4.core.Matrix.html:11452,Performance,load,load,11452,"ent of a matrix in subblock h, row m, col n. get(self: psi4.core.Matrix, m: int, n: int) -> float. Returns a single element of a matrix, row m, col n. get_block(self: psi4.core.Matrix, rows: psi4.core.Slice, cols: psi4.core.Slice)  psi4.core.Matrix; Get a matrix block. hermitivitize(self: psi4.core.Matrix)  None; Average off-diagonal element in-place. hermitize(self: psi4.core.Matrix)  None; Makes a real matrix symmetric by averaging the matrix and its transpose. identity(self: psi4.core.Matrix)  None; Sets the matrix to the identity. invert(self: psi4.core.Matrix)  None; Computes the inverse of a real symmetric positive definite matrix. load(*args, **kwargs); Overloaded function. load(self: psi4.core.Matrix, filename: str) -> None. Loads a block matrix from an ASCII file (see tests/mints3 for format). load(self: psi4.core.Matrix, psio: psi4.core.IO, fileno: int, tocentry: str, nso: int) -> bool. Load a matrix from a PSIO object from fileno with tocentry of size nso. load(self: psi4.core.Matrix, psio: psi4.core.IO, fileno: int, savetype: psi4.core.SaveType = <SaveType.LowerTriangle: 2>) -> None. Load a matrix from a PSIO object from fileno and with toc position of the name of the matrix. load_mpqc(self: psi4.core.Matrix, filename: str)  None; Loads a matrix from an ASCII file in MPQC format. nirrep(self: psi4.core.Matrix)  int; Returns the number of irreps. classmethod np_read(prefix=''); Reads the data from a NumPy compressed or uncompressed file using numpy.load(). Parameters:. self  Pointer to which class to be constructed.; filename (str)  File name to read.; prefix (str)  Name under which array was saved for NumPy. Return type:; Union[Matrix, Vector]. np_write(filename=None, prefix=''); Writes the irrepped matrix to a NumPy uncompressed file using numpy.savez().; Can return the packed data for saving many matrices into the same file. Parameters:. self (Union[Matrix, Vector])  Instance to be serialized.; filename (Optional[str])  File name w",MatchSource.WIKI,psi4manual/master/api/psi4.core.Matrix.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.Matrix.html
https://psicode.org/psi4manual/master/api/psi4.core.Matrix.html:11583,Performance,Load,Load,11583,"4.core.Matrix, rows: psi4.core.Slice, cols: psi4.core.Slice)  psi4.core.Matrix; Get a matrix block. hermitivitize(self: psi4.core.Matrix)  None; Average off-diagonal element in-place. hermitize(self: psi4.core.Matrix)  None; Makes a real matrix symmetric by averaging the matrix and its transpose. identity(self: psi4.core.Matrix)  None; Sets the matrix to the identity. invert(self: psi4.core.Matrix)  None; Computes the inverse of a real symmetric positive definite matrix. load(*args, **kwargs); Overloaded function. load(self: psi4.core.Matrix, filename: str) -> None. Loads a block matrix from an ASCII file (see tests/mints3 for format). load(self: psi4.core.Matrix, psio: psi4.core.IO, fileno: int, tocentry: str, nso: int) -> bool. Load a matrix from a PSIO object from fileno with tocentry of size nso. load(self: psi4.core.Matrix, psio: psi4.core.IO, fileno: int, savetype: psi4.core.SaveType = <SaveType.LowerTriangle: 2>) -> None. Load a matrix from a PSIO object from fileno and with toc position of the name of the matrix. load_mpqc(self: psi4.core.Matrix, filename: str)  None; Loads a matrix from an ASCII file in MPQC format. nirrep(self: psi4.core.Matrix)  int; Returns the number of irreps. classmethod np_read(prefix=''); Reads the data from a NumPy compressed or uncompressed file using numpy.load(). Parameters:. self  Pointer to which class to be constructed.; filename (str)  File name to read.; prefix (str)  Name under which array was saved for NumPy. Return type:; Union[Matrix, Vector]. np_write(filename=None, prefix=''); Writes the irrepped matrix to a NumPy uncompressed file using numpy.savez().; Can return the packed data for saving many matrices into the same file. Parameters:. self (Union[Matrix, Vector])  Instance to be serialized.; filename (Optional[str])  File name where the data will be saved.; prefix (str)  Name of instance prepared for NumPy. Returns:; When filename given, it and dict serialization passed to; numpy.savez(), so .",MatchSource.WIKI,psi4manual/master/api/psi4.core.Matrix.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.Matrix.html
https://psicode.org/psi4manual/master/api/psi4.core.Matrix.html:11735,Performance,Load,Loads,11735,"e(self: psi4.core.Matrix)  None; Average off-diagonal element in-place. hermitize(self: psi4.core.Matrix)  None; Makes a real matrix symmetric by averaging the matrix and its transpose. identity(self: psi4.core.Matrix)  None; Sets the matrix to the identity. invert(self: psi4.core.Matrix)  None; Computes the inverse of a real symmetric positive definite matrix. load(*args, **kwargs); Overloaded function. load(self: psi4.core.Matrix, filename: str) -> None. Loads a block matrix from an ASCII file (see tests/mints3 for format). load(self: psi4.core.Matrix, psio: psi4.core.IO, fileno: int, tocentry: str, nso: int) -> bool. Load a matrix from a PSIO object from fileno with tocentry of size nso. load(self: psi4.core.Matrix, psio: psi4.core.IO, fileno: int, savetype: psi4.core.SaveType = <SaveType.LowerTriangle: 2>) -> None. Load a matrix from a PSIO object from fileno and with toc position of the name of the matrix. load_mpqc(self: psi4.core.Matrix, filename: str)  None; Loads a matrix from an ASCII file in MPQC format. nirrep(self: psi4.core.Matrix)  int; Returns the number of irreps. classmethod np_read(prefix=''); Reads the data from a NumPy compressed or uncompressed file using numpy.load(). Parameters:. self  Pointer to which class to be constructed.; filename (str)  File name to read.; prefix (str)  Name under which array was saved for NumPy. Return type:; Union[Matrix, Vector]. np_write(filename=None, prefix=''); Writes the irrepped matrix to a NumPy uncompressed file using numpy.savez().; Can return the packed data for saving many matrices into the same file. Parameters:. self (Union[Matrix, Vector])  Instance to be serialized.; filename (Optional[str])  File name where the data will be saved.; prefix (str)  Name of instance prepared for NumPy. Returns:; When filename given, it and dict serialization passed to; numpy.savez(), so .npz file saved and None returned.; When filename None, dict serialization returned. Return type:; None or Dict[str,",MatchSource.WIKI,psi4manual/master/api/psi4.core.Matrix.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.Matrix.html
https://psicode.org/psi4manual/master/api/psi4.core.Matrix.html:11959,Performance,load,load,11959,"ix)  None; Sets the matrix to the identity. invert(self: psi4.core.Matrix)  None; Computes the inverse of a real symmetric positive definite matrix. load(*args, **kwargs); Overloaded function. load(self: psi4.core.Matrix, filename: str) -> None. Loads a block matrix from an ASCII file (see tests/mints3 for format). load(self: psi4.core.Matrix, psio: psi4.core.IO, fileno: int, tocentry: str, nso: int) -> bool. Load a matrix from a PSIO object from fileno with tocentry of size nso. load(self: psi4.core.Matrix, psio: psi4.core.IO, fileno: int, savetype: psi4.core.SaveType = <SaveType.LowerTriangle: 2>) -> None. Load a matrix from a PSIO object from fileno and with toc position of the name of the matrix. load_mpqc(self: psi4.core.Matrix, filename: str)  None; Loads a matrix from an ASCII file in MPQC format. nirrep(self: psi4.core.Matrix)  int; Returns the number of irreps. classmethod np_read(prefix=''); Reads the data from a NumPy compressed or uncompressed file using numpy.load(). Parameters:. self  Pointer to which class to be constructed.; filename (str)  File name to read.; prefix (str)  Name under which array was saved for NumPy. Return type:; Union[Matrix, Vector]. np_write(filename=None, prefix=''); Writes the irrepped matrix to a NumPy uncompressed file using numpy.savez().; Can return the packed data for saving many matrices into the same file. Parameters:. self (Union[Matrix, Vector])  Instance to be serialized.; filename (Optional[str])  File name where the data will be saved.; prefix (str)  Name of instance prepared for NumPy. Returns:; When filename given, it and dict serialization passed to; numpy.savez(), so .npz file saved and None returned.; When filename None, dict serialization returned. Return type:; None or Dict[str, Any]. partial_cholesky_factorize(self: psi4.core.Matrix, delta: float = 0.0, throw_if_negative: bool = False)  psi4.core.Matrix; Computes the fully pivoted partial Cholesky factorization of a real symmetric positive ",MatchSource.WIKI,psi4manual/master/api/psi4.core.Matrix.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.Matrix.html
https://psicode.org/psi4manual/master/api/psi4.core.Matrix.html:18773,Performance,load,load,18773,"lf: psi4.core.Matrix)  None; Zero all elements of the matrix. zero_diagonal(self: psi4.core.Matrix)  None; Zero the diagonal of the matrix. zero_lower(self: psi4.core.Matrix)  None; Zero the lower triangle. zero_upper(self: psi4.core.Matrix)  None; Zero the upper triangle. table of contents. Matrix; Matrix; Matrix.name; Matrix.np; Matrix.nph; Matrix.shape; Matrix.absmax(); Matrix.accumulate_product(); Matrix.add(); Matrix.add_and_orthogonalize_row(); Matrix.apply_denominator(); Matrix.array_interface(); Matrix.axpy(); Matrix.back_transform(); Matrix.chain_dot(); Matrix.cholesky_factorize(); Matrix.clone(); Matrix.coldim(); Matrix.cols(); Matrix.copy(); Matrix.copy_lower_to_upper(); Matrix.copy_upper_to_lower(); Matrix.diagonalize(); Matrix.doublet(); Matrix.from_array(); Matrix.from_list(); Matrix.from_serial(); Matrix.gemm(); Matrix.general_invert(); Matrix.get(); Matrix.get_block(); Matrix.hermitivitize(); Matrix.hermitize(); Matrix.identity(); Matrix.invert(); Matrix.load(); Matrix.load_mpqc(); Matrix.nirrep(); Matrix.np_read(); Matrix.np_write(); Matrix.partial_cholesky_factorize(); Matrix.power(); Matrix.print_atom_vector(); Matrix.print_out(); Matrix.pseudoinverse(); Matrix.remove_symmetry(); Matrix.rms(); Matrix.rotate_columns(); Matrix.rowdim(); Matrix.rows(); Matrix.save(); Matrix.scale(); Matrix.scale_column(); Matrix.scale_row(); Matrix.schmidt(); Matrix.set(); Matrix.set_block(); Matrix.subtract(); Matrix.sum_of_squares(); Matrix.symmetrize_gradient(); Matrix.symmetry(); Matrix.to_array(); Matrix.to_serial(); Matrix.trace(); Matrix.transform(); Matrix.transpose(); Matrix.transpose_this(); Matrix.triplet(); Matrix.vector_dot(); Matrix.zero(); Matrix.zero_diagonal(); Matrix.zero_lower(); Matrix.zero_upper(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; Matrix.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM",MatchSource.WIKI,psi4manual/master/api/psi4.core.Matrix.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.Matrix.html
https://psicode.org/psi4manual/master/api/psi4.core.Matrix.html:4796,Security,access,accessor,4796,"ix. rotate_columns(self,h,i,j,theta); Rotates columns i and j in irrep h by angle theta. rowdim(self); Returns the rows per irrep array. rows(self[,h]); Returns the rows in irrep h. save(*args,**kwargs); Overloaded function. scale(self,a); Scales the matrix by the floating point value a. scale_column(self,h,n,a); Scales column n of irrep h by a. scale_row(self,h,m,a); Scales row m of irrep h by a. schmidt(self); Calls the libqt schmidt function. set(*args,**kwargs); Overloaded function. set_block(self,rows,cols,block); Set a matrix block. subtract(self,arg0); Substract a matrix from this matrix. sum_of_squares(self); Returns the sum of the squares of this matrix. symmetrize_gradient(self,mol); Symmetrizes a gradient-like matrix (N,3) using information from a given molecule. symmetry(self); Returns the overall symmetry of the matrix. to_array([copy,dense]); Converts a PSI4 Matrix or Vector to a NumPy array. to_serial(); Converts an object with a .nph accessor to a serialized dictionary. trace(self); Returns the trace of the matrix. transform(*args,**kwargs); Overloaded function. transpose(self); Creates a new matrix that is the transpose of this matrix. transpose_this(self); Transpose the matrix in-place. triplet(A,B,C,transA,transB,transC); Multiply three matrices together. vector_dot(self,rhs); Returns the vector dot product of this with rhs. zero(self); Zero all elements of the matrix. zero_diagonal(self); Zero the diagonal of the matrix. zero_lower(self); Zero the lower triangle. zero_upper(self); Zero the upper triangle. Attributes Documentation. name; The name of the Matrix. Used in printing. np; View with single irrep. nph; View with irreps. shape; Shape of the Psi4 data object. Methods Documentation. absmax(self: psi4.core.Matrix)  float; Returns the absolute maximum value. accumulate_product(self: psi4.core.Matrix, arg0: psi4.core.Matrix, arg1: psi4.core.Matrix)  None; Multiplies two arguments and adds the result to this ma",MatchSource.WIKI,psi4manual/master/api/psi4.core.Matrix.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.Matrix.html
https://psicode.org/psi4manual/master/api/psi4.core.Matrix.html:16718,Security,access,accessor,16718,": psi::Molecule)  None; Symmetrizes a gradient-like matrix (N,3) using information from a given molecule. symmetry(self: psi4.core.Matrix)  int; Returns the overall symmetry of the matrix. to_array(copy=True, dense=False); Converts a PSI4 Matrix or Vector to a NumPy array. Either copies the; data or simply constructs a view. Parameters:. matrix (Union[Matrix, Vector])  Pointers to which Psi4 core class should be used in the construction.; copy (bool)  Copy the data if True, return a view otherwise; dense (bool)  Converts irrepped Psi4 objects to diagonally blocked dense arrays if; True. Returns a list of arrays otherwise. Returns:; Returns a single or list of NumPy arrays depending on options. Return type:; ndarray or List[ndarray]. Notes; This is a generalized function to convert a Psi4 object to a NumPy array; Examples; >>> data = psi4.core.Matrix(3, 3); >>> data.to_array(); [[ 0. 0. 0.]; [ 0. 0. 0.]; [ 0. 0. 0.]]. to_serial(); Converts an object with a .nph accessor to a serialized dictionary. Parameters:; self (Union[Matrix, Vector])  Matrix or Vector instance. Returns:; Serialized dictionary with keys:. shape; data : List[str]; type : {matrix, vector}. Return type:; Dict[str, Any]. trace(self: psi4.core.Matrix)  float; Returns the trace of the matrix. transform(*args, **kwargs); Overloaded function. transform(self: psi4.core.Matrix, transformer: psi4.core.Matrix) -> None. Transform this matrix with transformer. transform(self: psi4.core.Matrix, a: psi4.core.Matrix, transformer: psi4.core.Matrix) -> None. Transform A with transformer. transpose(self: psi4.core.Matrix)  psi4.core.Matrix; Creates a new matrix that is the transpose of this matrix. transpose_this(self: psi4.core.Matrix)  None; Transpose the matrix in-place. static triplet(A, B, C, transA, transB, transC); Multiply three matrices together. Deprecated since version 1.4: Use psi4.core.triplet() instead. vector_dot(self: psi4.core.Matrix, rhs: psi4.core.Matrix)  float; Returns th",MatchSource.WIKI,psi4manual/master/api/psi4.core.Matrix.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.Matrix.html
https://psicode.org/psi4manual/master/api/psi4.core.Matrix.html:11258,Testability,test,tests,11258,"rix)  None; Computes the inverse of any nonsingular matrix using LU factorization. get(*args, **kwargs); Overloaded function. get(self: psi4.core.Matrix, h: int, m: int, n: int) -> float. Returns a single element of a matrix in subblock h, row m, col n. get(self: psi4.core.Matrix, m: int, n: int) -> float. Returns a single element of a matrix, row m, col n. get_block(self: psi4.core.Matrix, rows: psi4.core.Slice, cols: psi4.core.Slice)  psi4.core.Matrix; Get a matrix block. hermitivitize(self: psi4.core.Matrix)  None; Average off-diagonal element in-place. hermitize(self: psi4.core.Matrix)  None; Makes a real matrix symmetric by averaging the matrix and its transpose. identity(self: psi4.core.Matrix)  None; Sets the matrix to the identity. invert(self: psi4.core.Matrix)  None; Computes the inverse of a real symmetric positive definite matrix. load(*args, **kwargs); Overloaded function. load(self: psi4.core.Matrix, filename: str) -> None. Loads a block matrix from an ASCII file (see tests/mints3 for format). load(self: psi4.core.Matrix, psio: psi4.core.IO, fileno: int, tocentry: str, nso: int) -> bool. Load a matrix from a PSIO object from fileno with tocentry of size nso. load(self: psi4.core.Matrix, psio: psi4.core.IO, fileno: int, savetype: psi4.core.SaveType = <SaveType.LowerTriangle: 2>) -> None. Load a matrix from a PSIO object from fileno and with toc position of the name of the matrix. load_mpqc(self: psi4.core.Matrix, filename: str)  None; Loads a matrix from an ASCII file in MPQC format. nirrep(self: psi4.core.Matrix)  int; Returns the number of irreps. classmethod np_read(prefix=''); Reads the data from a NumPy compressed or uncompressed file using numpy.load(). Parameters:. self  Pointer to which class to be constructed.; filename (str)  File name to read.; prefix (str)  Name under which array was saved for NumPy. Return type:; Union[Matrix, Vector]. np_write(filename=None, prefix=''); Writes the irrepped matrix to a NumPy uncompress",MatchSource.WIKI,psi4manual/master/api/psi4.core.Matrix.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.Matrix.html
https://psicode.org/psi4manual/master/api/psi4.core.Matrix.html:16040,Usability,simpl,simply,16040,"ne. Sets every element of a matrix to val. set(self: psi4.core.Matrix, m: int, n: int, val: float) -> None. Sets a single element of a matrix to val at row m, col n. set(self: psi4.core.Matrix, h: int, m: int, n: int, val: float) -> None. Sets a single element of a matrix, subblock h, row m, col n, with value val. set_block(self: psi4.core.Matrix, rows: psi4.core.Slice, cols: psi4.core.Slice, block: psi4.core.Matrix)  None; Set a matrix block. subtract(self: psi4.core.Matrix, arg0: psi4.core.Matrix)  None; Substract a matrix from this matrix. sum_of_squares(self: psi4.core.Matrix)  float; Returns the sum of the squares of this matrix. symmetrize_gradient(self: psi4.core.Matrix, mol: psi::Molecule)  None; Symmetrizes a gradient-like matrix (N,3) using information from a given molecule. symmetry(self: psi4.core.Matrix)  int; Returns the overall symmetry of the matrix. to_array(copy=True, dense=False); Converts a PSI4 Matrix or Vector to a NumPy array. Either copies the; data or simply constructs a view. Parameters:. matrix (Union[Matrix, Vector])  Pointers to which Psi4 core class should be used in the construction.; copy (bool)  Copy the data if True, return a view otherwise; dense (bool)  Converts irrepped Psi4 objects to diagonally blocked dense arrays if; True. Returns a list of arrays otherwise. Returns:; Returns a single or list of NumPy arrays depending on options. Return type:; ndarray or List[ndarray]. Notes; This is a generalized function to convert a Psi4 object to a NumPy array; Examples; >>> data = psi4.core.Matrix(3, 3); >>> data.to_array(); [[ 0. 0. 0.]; [ 0. 0. 0.]; [ 0. 0. 0.]]. to_serial(); Converts an object with a .nph accessor to a serialized dictionary. Parameters:; self (Union[Matrix, Vector])  Matrix or Vector instance. Returns:; Serialized dictionary with keys:. shape; data : List[str]; type : {matrix, vector}. Return type:; Dict[str, Any]. trace(self: psi4.core.Matrix)  float; Returns the trace of the matrix. transform(*a",MatchSource.WIKI,psi4manual/master/api/psi4.core.Matrix.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.Matrix.html
https://psicode.org/psi4manual/master/api/psi4.core.MatrixFactory.html:934,Deployability,update,updated,934,". MatrixFactory. Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; MatrixFactory. MatrixFactory. class psi4.core.MatrixFactory; Bases: pybind11_object; Creates Matrix objects; Methods Summary. create_matrix(*args,**kwargs); Overloaded function. Methods Documentation. create_matrix(*args, **kwargs); Overloaded function. create_matrix(self: psi4.core.MatrixFactory) -> psi4.core.Matrix. Returns a new matrix object with default dimensions. create_matrix(self: psi4.core.MatrixFactory, arg0: str) -> psi4.core.Matrix. Returns a new Matrix object named name with default dimensions. table of contents. MatrixFactory; MatrixFactory; MatrixFactory.create_matrix(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; MatrixFactory.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/api/psi4.core.MatrixFactory.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.MatrixFactory.html
https://psicode.org/psi4manual/master/api/psi4.core.mcscf.html:508,Deployability,update,updated,508,". mcscf. Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; mcscf. mcscf. psi4.core.mcscf(arg0: psi4.core.Wavefunction)  psi4.core.Wavefunction; Runs the MCSCF code, (N.B. restricted to certain active spaces). table of contents. mcscf; mcscf(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; mcscf.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/api/psi4.core.mcscf.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.mcscf.html
https://psicode.org/psi4manual/master/api/psi4.core.MemDFJK.html:602,Deployability,update,updated,602,". MemDFJK. Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; MemDFJK. MemDFJK. class psi4.core.MemDFJK; Bases: JK; docstring; Methods Summary. dfh(self); Return the DFHelper object. Methods Documentation. dfh(self: psi4.core.MemDFJK)  psi4.core.DFHelper; Return the DFHelper object. table of contents. MemDFJK; MemDFJK; MemDFJK.dfh(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; MemDFJK.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/api/psi4.core.MemDFJK.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.MemDFJK.html
https://psicode.org/psi4manual/master/api/psi4.core.MintsHelper.html:22779,Deployability,update,updated,22779,"intsHelper.ao_overlap_half_deriv1(); MintsHelper.ao_potential(); MintsHelper.ao_potential_erf(); MintsHelper.ao_potential_erf_complement(); MintsHelper.ao_pvp(); MintsHelper.ao_quadrupole(); MintsHelper.ao_tei_deriv1(); MintsHelper.ao_tei_deriv2(); MintsHelper.ao_traceless_quadrupole(); MintsHelper.basisset(); MintsHelper.cdsalcs(); MintsHelper.core_hamiltonian_grad(); MintsHelper.dipole_grad(); MintsHelper.electric_field(); MintsHelper.electric_field_value(); MintsHelper.electrostatic_potential_value(); MintsHelper.f12_cgtg(); MintsHelper.factory(); MintsHelper.induction_operator(); MintsHelper.integral(); MintsHelper.integrals(); MintsHelper.integrals_erf(); MintsHelper.integrals_erfc(); MintsHelper.kinetic_grad(); MintsHelper.mo_elec_dip_deriv1(); MintsHelper.mo_erf_eri(); MintsHelper.mo_eri(); MintsHelper.mo_f12(); MintsHelper.mo_f12_double_commutator(); MintsHelper.mo_f12_squared(); MintsHelper.mo_f12g12(); MintsHelper.mo_oei_deriv1(); MintsHelper.mo_oei_deriv2(); MintsHelper.mo_overlap_half_deriv1(); MintsHelper.mo_spin_eri(); MintsHelper.mo_tei_deriv1(); MintsHelper.mo_tei_deriv2(); MintsHelper.mo_transform(); MintsHelper.multipole_grad(); MintsHelper.nbf(); MintsHelper.one_electron_integrals(); MintsHelper.overlap_grad(); MintsHelper.perturb_grad(); MintsHelper.petite_list(); MintsHelper.petite_list1(); MintsHelper.play(); MintsHelper.potential_grad(); MintsHelper.set_basisset(); MintsHelper.set_print(); MintsHelper.so_angular_momentum(); MintsHelper.so_dipole(); MintsHelper.so_dkh(); MintsHelper.so_kinetic(); MintsHelper.so_nabla(); MintsHelper.so_overlap(); MintsHelper.so_potential(); MintsHelper.so_quadrupole(); MintsHelper.so_traceless_quadrupole(); MintsHelper.sobasisset(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; MintsHelper.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/api/psi4.core.MintsHelper.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.MintsHelper.html
https://psicode.org/psi4manual/master/api/psi4.core.MintsHelper.html:2947,Energy Efficiency,charge,charges,2947,",omega,deriv]); AO Erf-attenuated Coulomb potential on a given point. ao_potential_erf_complement(self[,origin,...]); AO Erfc-attenuated Coulomb potential on a given point. ao_pvp(self); AO pvp integrals. ao_quadrupole(self); Vector AO quadrupole integrals. ao_tei_deriv1(self,atom[,omega,factory]); Gradient of AO basis TEI integrals: returns (3 * natoms) matrices. ao_tei_deriv2(self,atom1,atom2); Hessian of AO basis TEI integrals: returns (3 * natoms)^2 matrices. ao_traceless_quadrupole(self); Vector AO traceless quadrupole integrals. basisset(self); Returns the basis set being used. cdsalcs(self,arg0,arg1,arg2); Returns a CdSalcList object. core_hamiltonian_grad(self,arg0); First nuclear derivative T + V + Perturb integrals. dipole_grad(self,arg0); First nuclear derivative dipole integrals. electric_field(self,origin[,deriv]); Vector electric field integrals. electric_field_value(self,arg0,arg1); Electric field expectation value at given sites. electrostatic_potential_value(self,charges,...); Electrostatic potential values at given sites with associated charge, specified as an (n_sites, 4) matrix. f12_cgtg(self[,exponent]); F12 Fitted Slater Correlation Factor. factory(self); Returns the Matrix factory being used. induction_operator(self,arg0,arg1); Induction operator, formed by contracting electric field integrals with dipole moments at given coordinates (needed for EFP and PE). integral(self); Integral factory being used. integrals(self); Molecular integrals. integrals_erf(self[,w]); ERF integrals. integrals_erfc(self[,w]); ERFC integrals. kinetic_grad(self,arg0); First nuclear derivative kinetic integrals. mo_elec_dip_deriv1(self,atom,C1,C2); Gradient of MO basis electric dipole integrals: returns (3 * natoms) matrices. mo_erf_eri(self,omega,C1,C2,C3,C4); MO ERFC Omega Integrals. mo_eri(self,C1,C2,C3,C4); MO ERI Integrals. mo_f12(self,corr,C1,C2,C3,C4); MO F12 Integrals. mo_f12_double_commutator(self,corr,C1,C2,...);",MatchSource.WIKI,psi4manual/master/api/psi4.core.MintsHelper.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.MintsHelper.html
https://psicode.org/psi4manual/master/api/psi4.core.MintsHelper.html:3024,Energy Efficiency,charge,charge,3024,"tial_erf_complement(self[,origin,...]); AO Erfc-attenuated Coulomb potential on a given point. ao_pvp(self); AO pvp integrals. ao_quadrupole(self); Vector AO quadrupole integrals. ao_tei_deriv1(self,atom[,omega,factory]); Gradient of AO basis TEI integrals: returns (3 * natoms) matrices. ao_tei_deriv2(self,atom1,atom2); Hessian of AO basis TEI integrals: returns (3 * natoms)^2 matrices. ao_traceless_quadrupole(self); Vector AO traceless quadrupole integrals. basisset(self); Returns the basis set being used. cdsalcs(self,arg0,arg1,arg2); Returns a CdSalcList object. core_hamiltonian_grad(self,arg0); First nuclear derivative T + V + Perturb integrals. dipole_grad(self,arg0); First nuclear derivative dipole integrals. electric_field(self,origin[,deriv]); Vector electric field integrals. electric_field_value(self,arg0,arg1); Electric field expectation value at given sites. electrostatic_potential_value(self,charges,...); Electrostatic potential values at given sites with associated charge, specified as an (n_sites, 4) matrix. f12_cgtg(self[,exponent]); F12 Fitted Slater Correlation Factor. factory(self); Returns the Matrix factory being used. induction_operator(self,arg0,arg1); Induction operator, formed by contracting electric field integrals with dipole moments at given coordinates (needed for EFP and PE). integral(self); Integral factory being used. integrals(self); Molecular integrals. integrals_erf(self[,w]); ERF integrals. integrals_erfc(self[,w]); ERFC integrals. kinetic_grad(self,arg0); First nuclear derivative kinetic integrals. mo_elec_dip_deriv1(self,atom,C1,C2); Gradient of MO basis electric dipole integrals: returns (3 * natoms) matrices. mo_erf_eri(self,omega,C1,C2,C3,C4); MO ERFC Omega Integrals. mo_eri(self,C1,C2,C3,C4); MO ERI Integrals. mo_f12(self,corr,C1,C2,C3,C4); MO F12 Integrals. mo_f12_double_commutator(self,corr,C1,C2,...); MO F12 double commutator integrals. mo_f12_squared(self,corr,C1,C2,C3,C4);",MatchSource.WIKI,psi4manual/master/api/psi4.core.MintsHelper.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.MintsHelper.html
https://psicode.org/psi4manual/master/api/psi4.core.MintsHelper.html:13399,Energy Efficiency,charge,charges,13399,"2 matrices. ao_traceless_quadrupole(self: psi4.core.MintsHelper)  list[psi4.core.Matrix]; Vector AO traceless quadrupole integrals. basisset(self: psi4.core.MintsHelper)  psi4.core.BasisSet; Returns the basis set being used. cdsalcs(self: psi4.core.MintsHelper, arg0: int, arg1: bool, arg2: bool)  psi4.core.CdSalcList; Returns a CdSalcList object. core_hamiltonian_grad(self: psi4.core.MintsHelper, arg0: psi4.core.Matrix)  psi4.core.Matrix; First nuclear derivative T + V + Perturb integrals. dipole_grad(self: psi4.core.MintsHelper, arg0: psi4.core.Matrix)  psi4.core.Matrix; First nuclear derivative dipole integrals. electric_field(self: psi4.core.MintsHelper, origin: list[float], deriv: int = 0)  list[psi4.core.Matrix]; Vector electric field integrals. electric_field_value(self: psi4.core.MintsHelper, arg0: psi4.core.Matrix, arg1: psi4.core.Matrix)  psi4.core.Matrix; Electric field expectation value at given sites. electrostatic_potential_value(self: psi4.core.MintsHelper, charges: psi4.core.Vector, coords: psi4.core.Matrix, D: psi4.core.Matrix)  psi4.core.Vector; Electrostatic potential values at given sites with associated charge, specified as an (n_sites, 4) matrix. f12_cgtg(self: psi4.core.MintsHelper, exponent: float = 1.0)  list[tuple[float, float]]; F12 Fitted Slater Correlation Factor. factory(self: psi4.core.MintsHelper)  psi4.core.MatrixFactory; Returns the Matrix factory being used. induction_operator(self: psi4.core.MintsHelper, arg0: psi4.core.Matrix, arg1: psi4.core.Matrix)  psi4.core.Matrix; Induction operator, formed by contracting electric field integrals with dipole moments at given coordinates (needed for EFP and PE). integral(self: psi4.core.MintsHelper)  psi4.core.IntegralFactory; Integral factory being used. integrals(self: psi4.core.MintsHelper)  None; Molecular integrals. integrals_erf(self: psi4.core.MintsHelper, w: float = -1.0)  None; ERF integrals. integrals_erfc(self: psi4.core.MintsHelper, w: float = -1.0)  Non",MatchSource.WIKI,psi4manual/master/api/psi4.core.MintsHelper.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.MintsHelper.html
https://psicode.org/psi4manual/master/api/psi4.core.MintsHelper.html:13556,Energy Efficiency,charge,charge,13556,"self: psi4.core.MintsHelper)  psi4.core.BasisSet; Returns the basis set being used. cdsalcs(self: psi4.core.MintsHelper, arg0: int, arg1: bool, arg2: bool)  psi4.core.CdSalcList; Returns a CdSalcList object. core_hamiltonian_grad(self: psi4.core.MintsHelper, arg0: psi4.core.Matrix)  psi4.core.Matrix; First nuclear derivative T + V + Perturb integrals. dipole_grad(self: psi4.core.MintsHelper, arg0: psi4.core.Matrix)  psi4.core.Matrix; First nuclear derivative dipole integrals. electric_field(self: psi4.core.MintsHelper, origin: list[float], deriv: int = 0)  list[psi4.core.Matrix]; Vector electric field integrals. electric_field_value(self: psi4.core.MintsHelper, arg0: psi4.core.Matrix, arg1: psi4.core.Matrix)  psi4.core.Matrix; Electric field expectation value at given sites. electrostatic_potential_value(self: psi4.core.MintsHelper, charges: psi4.core.Vector, coords: psi4.core.Matrix, D: psi4.core.Matrix)  psi4.core.Vector; Electrostatic potential values at given sites with associated charge, specified as an (n_sites, 4) matrix. f12_cgtg(self: psi4.core.MintsHelper, exponent: float = 1.0)  list[tuple[float, float]]; F12 Fitted Slater Correlation Factor. factory(self: psi4.core.MintsHelper)  psi4.core.MatrixFactory; Returns the Matrix factory being used. induction_operator(self: psi4.core.MintsHelper, arg0: psi4.core.Matrix, arg1: psi4.core.Matrix)  psi4.core.Matrix; Induction operator, formed by contracting electric field integrals with dipole moments at given coordinates (needed for EFP and PE). integral(self: psi4.core.MintsHelper)  psi4.core.IntegralFactory; Integral factory being used. integrals(self: psi4.core.MintsHelper)  None; Molecular integrals. integrals_erf(self: psi4.core.MintsHelper, w: float = -1.0)  None; ERF integrals. integrals_erfc(self: psi4.core.MintsHelper, w: float = -1.0)  None; ERFC integrals. kinetic_grad(self: psi4.core.MintsHelper, arg0: psi4.core.Matrix)  psi4.core.Matrix; First nuclear derivative kinetic int",MatchSource.WIKI,psi4manual/master/api/psi4.core.MintsHelper.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.MintsHelper.html
https://psicode.org/psi4manual/master/api/psi4.core.MintsHelper.html:3257,Integrability,contract,contracting,3257,"s: returns (3 * natoms) matrices. ao_tei_deriv2(self,atom1,atom2); Hessian of AO basis TEI integrals: returns (3 * natoms)^2 matrices. ao_traceless_quadrupole(self); Vector AO traceless quadrupole integrals. basisset(self); Returns the basis set being used. cdsalcs(self,arg0,arg1,arg2); Returns a CdSalcList object. core_hamiltonian_grad(self,arg0); First nuclear derivative T + V + Perturb integrals. dipole_grad(self,arg0); First nuclear derivative dipole integrals. electric_field(self,origin[,deriv]); Vector electric field integrals. electric_field_value(self,arg0,arg1); Electric field expectation value at given sites. electrostatic_potential_value(self,charges,...); Electrostatic potential values at given sites with associated charge, specified as an (n_sites, 4) matrix. f12_cgtg(self[,exponent]); F12 Fitted Slater Correlation Factor. factory(self); Returns the Matrix factory being used. induction_operator(self,arg0,arg1); Induction operator, formed by contracting electric field integrals with dipole moments at given coordinates (needed for EFP and PE). integral(self); Integral factory being used. integrals(self); Molecular integrals. integrals_erf(self[,w]); ERF integrals. integrals_erfc(self[,w]); ERFC integrals. kinetic_grad(self,arg0); First nuclear derivative kinetic integrals. mo_elec_dip_deriv1(self,atom,C1,C2); Gradient of MO basis electric dipole integrals: returns (3 * natoms) matrices. mo_erf_eri(self,omega,C1,C2,C3,C4); MO ERFC Omega Integrals. mo_eri(self,C1,C2,C3,C4); MO ERI Integrals. mo_f12(self,corr,C1,C2,C3,C4); MO F12 Integrals. mo_f12_double_commutator(self,corr,C1,C2,...); MO F12 double commutator integrals. mo_f12_squared(self,corr,C1,C2,C3,C4); MO F12 squared integrals. mo_f12g12(self,corr,C1,C2,C3,C4); MO F12G12 integrals. mo_oei_deriv1(self,oei_type,atom,C1,C2); Gradient of MO basis OEI integrals: returns (3 * natoms) matrices. mo_oei_deriv2(self,oei_type,atom1,atom2,...); Hessian of ",MatchSource.WIKI,psi4manual/master/api/psi4.core.MintsHelper.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.MintsHelper.html
https://psicode.org/psi4manual/master/api/psi4.core.MintsHelper.html:13981,Integrability,contract,contracting,13981," dipole integrals. electric_field(self: psi4.core.MintsHelper, origin: list[float], deriv: int = 0)  list[psi4.core.Matrix]; Vector electric field integrals. electric_field_value(self: psi4.core.MintsHelper, arg0: psi4.core.Matrix, arg1: psi4.core.Matrix)  psi4.core.Matrix; Electric field expectation value at given sites. electrostatic_potential_value(self: psi4.core.MintsHelper, charges: psi4.core.Vector, coords: psi4.core.Matrix, D: psi4.core.Matrix)  psi4.core.Vector; Electrostatic potential values at given sites with associated charge, specified as an (n_sites, 4) matrix. f12_cgtg(self: psi4.core.MintsHelper, exponent: float = 1.0)  list[tuple[float, float]]; F12 Fitted Slater Correlation Factor. factory(self: psi4.core.MintsHelper)  psi4.core.MatrixFactory; Returns the Matrix factory being used. induction_operator(self: psi4.core.MintsHelper, arg0: psi4.core.Matrix, arg1: psi4.core.Matrix)  psi4.core.Matrix; Induction operator, formed by contracting electric field integrals with dipole moments at given coordinates (needed for EFP and PE). integral(self: psi4.core.MintsHelper)  psi4.core.IntegralFactory; Integral factory being used. integrals(self: psi4.core.MintsHelper)  None; Molecular integrals. integrals_erf(self: psi4.core.MintsHelper, w: float = -1.0)  None; ERF integrals. integrals_erfc(self: psi4.core.MintsHelper, w: float = -1.0)  None; ERFC integrals. kinetic_grad(self: psi4.core.MintsHelper, arg0: psi4.core.Matrix)  psi4.core.Matrix; First nuclear derivative kinetic integrals. mo_elec_dip_deriv1(self: psi4.core.MintsHelper, atom: int, C1: psi4.core.Matrix, C2: psi4.core.Matrix)  list[psi4.core.Matrix]; Gradient of MO basis electric dipole integrals: returns (3 * natoms) matrices. mo_erf_eri(self: psi4.core.MintsHelper, omega: float, C1: psi4.core.Matrix, C2: psi4.core.Matrix, C3: psi4.core.Matrix, C4: psi4.core.Matrix)  psi4.core.Matrix; MO ERFC Omega Integrals. mo_eri(self: psi4.core.MintsHelper, C1: psi4.core.Matrix, C2: psi",MatchSource.WIKI,psi4manual/master/api/psi4.core.MintsHelper.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.MintsHelper.html
https://psicode.org/psi4manual/master/api/psi4.core.MoldenWriter.html:940,Deployability,update,updated,940,". MoldenWriter. Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; MoldenWriter. MoldenWriter. class psi4.core.MoldenWriter; Bases: pybind11_object; Writes wavefunction information in molden format; Methods Summary. write(self,filename,Ca,Cb,Ea,Eb,OccA,...); Writes wavefunction information in molden format. Methods Documentation. write(self: psi4.core.MoldenWriter, filename: str, Ca: psi4.core.Matrix, Cb: psi4.core.Matrix, Ea: psi4.core.Vector, Eb: psi4.core.Vector, OccA: psi4.core.Vector, OccB: psi4.core.Vector, dovirtual: bool)  None; Writes wavefunction information in molden format. table of contents. MoldenWriter; MoldenWriter; MoldenWriter.write(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; MoldenWriter.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/api/psi4.core.MoldenWriter.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.MoldenWriter.html
https://psicode.org/psi4manual/master/api/psi4.core.MolecularGrid.html:1998,Deployability,update,updated,1998,"dev61; . PSI4. PSI4 API: Linking C++ and Python; MolecularGrid. MolecularGrid. class psi4.core.MolecularGrid; Bases: pybind11_object; docstring; Methods Summary. atomic_blocks(self); Returns a list of blocks. blocks(self); Returns a list of blocks. collocation_size(self); Returns the total collocation size of all blocks. max_functions(self); Returns the maximum number of functions in a block. max_points(self); Returns the maximum number of points in a block. npoints(self); Returns the number of grid points. orientation(self); Returns the orientation of the grid. print(self,arg0,arg1); Prints grid information. Methods Documentation. atomic_blocks(self: psi4.core.MolecularGrid)  list[list[psi4.core.BlockOPoints]]; Returns a list of blocks. blocks(self: psi4.core.MolecularGrid)  list[psi4.core.BlockOPoints]; Returns a list of blocks. collocation_size(self: psi4.core.MolecularGrid)  int; Returns the total collocation size of all blocks. max_functions(self: psi4.core.MolecularGrid)  int; Returns the maximum number of functions in a block. max_points(self: psi4.core.MolecularGrid)  int; Returns the maximum number of points in a block. npoints(self: psi4.core.MolecularGrid)  int; Returns the number of grid points. orientation(self: psi4.core.MolecularGrid)  psi4.core.Matrix; Returns the orientation of the grid. print(self: psi4.core.MolecularGrid, arg0: str, arg1: int)  None; Prints grid information. table of contents. MolecularGrid; MolecularGrid; MolecularGrid.atomic_blocks(); MolecularGrid.blocks(); MolecularGrid.collocation_size(); MolecularGrid.max_functions(); MolecularGrid.max_points(); MolecularGrid.npoints(); MolecularGrid.orientation(); MolecularGrid.print(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.10a1.dev61; . PSI4. PSI4 API: Linking C++ and Python; MolecularGrid.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4manual/master/api/psi4.core.MolecularGrid.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.MolecularGrid.html
https://psicode.org/psi4manual/master/api/psi4.core.Molecule.html:2068,Availability,toler,tolerance,2068,"a given atom arg0. center_of_mass(self); Computes center of mass of molecule (does not translate molecule). charge(self,atom); Gets charge of atom (0-indexed without dummies). clone(self); Returns a new Molecule identical to arg1. com_fixed(self); Gets whether or not center of mass is fixed. comment(self); Gets molecule comment. connectivity(self); Gets molecule connectivity. create_psi4_string_from_molecule(self); Gets a string re-expressing in input format the current state of the molecule.Contains Cartesian geometry info, fragmentation, charges and multiplicities, and any frame restriction. deactivate_all_fragments(self); Sets all fragments in the molecule to be inactive. distance_matrix(self); Returns Matrix of interatom distances. extract_subsets(*args,**kwargs); Overloaded function. fZ(self,arg0); Nuclear charge of atom arg1 (0-indexed including dummies). fcharge(self,atom); Gets charge of atom (0-indexed including dummies). find_highest_point_group(self[,tolerance]); Finds highest possible computational molecular point group. find_point_group(self[,tolerance]); Finds computational molecular point group, user can override this with the symmetry keyword. fix_com(self,arg0); Sets whether to fix the Cartesian position, or to translate to the C.O.M. fix_orientation(self,arg0); Fix the orientation at its current frame. flabel(self,atom); Gets the original label of the atom arg0 as given in the input file (C2, H4)(0-indexed including dummies). fmass(self,atom); Gets mass of atom (0-indexed including dummies). form_symmetry_information(self,arg0); Uses the point group object obtain by calling point_group(). format_molecule_for_mol(); Returns a string of Molecule formatted for mol2. from_arrays([geom,elea,elez,elem,mass,...]); Construct Molecule from unvalidated arrays and variables. from_dict(arg0); Returns a new Molecule constructed from python dictionary. from_schema(molschema[,return_dict,...]); Construct Molecule from non-Psi4 schema. from_string",MatchSource.WIKI,psi4manual/master/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/master/api/psi4.core.Molecule.html:2165,Availability,toler,tolerance,2165,"f,atom); Gets charge of atom (0-indexed without dummies). clone(self); Returns a new Molecule identical to arg1. com_fixed(self); Gets whether or not center of mass is fixed. comment(self); Gets molecule comment. connectivity(self); Gets molecule connectivity. create_psi4_string_from_molecule(self); Gets a string re-expressing in input format the current state of the molecule.Contains Cartesian geometry info, fragmentation, charges and multiplicities, and any frame restriction. deactivate_all_fragments(self); Sets all fragments in the molecule to be inactive. distance_matrix(self); Returns Matrix of interatom distances. extract_subsets(*args,**kwargs); Overloaded function. fZ(self,arg0); Nuclear charge of atom arg1 (0-indexed including dummies). fcharge(self,atom); Gets charge of atom (0-indexed including dummies). find_highest_point_group(self[,tolerance]); Finds highest possible computational molecular point group. find_point_group(self[,tolerance]); Finds computational molecular point group, user can override this with the symmetry keyword. fix_com(self,arg0); Sets whether to fix the Cartesian position, or to translate to the C.O.M. fix_orientation(self,arg0); Fix the orientation at its current frame. flabel(self,atom); Gets the original label of the atom arg0 as given in the input file (C2, H4)(0-indexed including dummies). fmass(self,atom); Gets mass of atom (0-indexed including dummies). form_symmetry_information(self,arg0); Uses the point group object obtain by calling point_group(). format_molecule_for_mol(); Returns a string of Molecule formatted for mol2. from_arrays([geom,elea,elez,elem,mass,...]); Construct Molecule from unvalidated arrays and variables. from_dict(arg0); Returns a new Molecule constructed from python dictionary. from_schema(molschema[,return_dict,...]); Construct Molecule from non-Psi4 schema. from_string(molstr[,dtype,name,fix_com,...]). fsymbol(self,atom); Gets the cleaned up label of atom (C2 => C, H4 = H) (0-in",MatchSource.WIKI,psi4manual/master/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/master/api/psi4.core.Molecule.html:10094,Availability,toler,tolerance,10094,"g0); Sets unit conversion to [a0] for geometry. set_mass(self,atom,mass); Sets mass of atom (0-indexed) to mass (good for isotopic substitutions). set_molecular_charge(self,arg0); Change the overall molecular charge. set_multiplicity(self,arg0); Change the multiplicity (defined as 2S + 1). set_name(self,arg0); Sets molecule name. set_nuclear_charge(self,arg0,arg1); Set the nuclear charge of the given atom arg0 to the value arg1 (primarily for ECP). set_point_group(self,arg0); Sets the molecular point group to the point group object arg0. set_provenance(self,arg0); Sets molecule provenance. set_units(self,arg0); Sets units (Angstrom or Bohr) used to define the geometry. set_variable(self,arg0,arg1); Sets the value arg1 to the variable arg0 in the list of structure variables, then calls update_geometry(). symbol(self,atom); Gets the cleaned up label of atom (C2 => C, H4 = H) (0-indexed without dummies). symmetrize(self,arg0); Finds the highest point Abelian point group within the specified tolerance, and forces the geometry to have that symmetry. symmetry_from_input(self); Returns the symmetry specified in the input. to_arrays([dummy,ghost_as_dummy]); Exports coordinate info into NumPy arrays. to_dict([force_c1,force_units,np_out]); Serializes instance into Molecule dictionary. to_schema(dtype[,units]); Serializes instance into dictionary according to schema dtype. to_string(dtype[,units,atom_format,...]); Format a string representation of QM molecule. translate(self,arg0); Translates molecule by arg0. true_atomic_number(self,atom); Gets atomic number of atom from element (0-indexed without dummies). units(self); Returns units used to define the geometry, i.e. 'Angstrom' or 'Bohr'. update_geometry(self); Reevaluates the geometry with current variable values, orientation directives, etc. x(self,arg0); x position [Bohr] of atom arg0 (0-indexed without dummies). xyz(self,i); Return the Vector3 for atom i (0-indexed without dummies). y(self,arg0);",MatchSource.WIKI,psi4manual/master/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/master/api/psi4.core.Molecule.html:15287,Availability,fault,faulty,15287,"ts of ndarray, optional)  geom, mass, elem info per-fragment.; Only provided if return_arrays is True.; bfs_molecules (list of qcdb.Molecule or psi4.core.Molecule, optional)  List of molecules, each built from one fragment. Center and; orientation of fragments is fixed so orientation info from self is; not lost. Loses chgmult and ghost/dummy info from self and contains; default chgmult.; Only provided if return_molecules is True.; Returned are of same type as self.; bfs_molecule (qcdb.Molecule or psi4.core.Molecule, optional)  Single molecule with same number of real atoms as self with atoms; reordered into adjacent fragments and fragment markers inserted.; Loses ghost/dummy info from self; keeps total charge but not total mult.; Only provided if return_molecule is True.; Returned is of same type as self.; Authors; -; Original code from Michael S. Marshall, linear-scaling algorithm from; Trent M. Parker, revamped by Lori A. Burns. Notes; Relies upon van der Waals radii and so faulty for close (especially hydrogen-bonded) fragments. See` seed_atoms`.; Any existing fragmentation info/chgmult encoded in self is lost. Z(self: psi4.core.Molecule, arg0: int)  float; Nuclear charge of atom arg0 (0-indexed without dummies). activate_all_fragments(self: psi4.core.Molecule)  None; Sets all fragments in the molecule to be active. add_atom(self: psi4.core.Molecule, Z: float, x: float, y: float, z: float, symbol: str, mass: float, charge: float, label: str, A: int)  None; Adds to self Molecule an atom with atomic number Z, Cartesian coordinates in Bohr (x, y, z), atomic symbol, mass, and charge, extended atomic label, and mass number A. atom_at_position(*args, **kwargs); Overloaded function. atom_at_position(self: psi4.core.Molecule, coord: float, tol: float) -> int. Returns the index of the atom inside tol radius around coord. Returns -1 for no atoms, throws an exception if more than one is found. atom_at_position(self: psi4.core.Molecule, coord: Annotated[list[float",MatchSource.WIKI,psi4manual/master/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/master/api/psi4.core.Molecule.html:18861,Availability,toler,tolerance,18861,"ts(self: psi4.core.Molecule, arg0: list[int], arg1: int) -> psi4.core.Molecule. Returns copy of self with arg0 fragments Real and arg1 fragment Ghost. extract_subsets(self: psi4.core.Molecule, arg0: int, arg1: list[int]) -> psi4.core.Molecule. Returns copy of self with arg0 fragment Real and arg1 fragments Ghost. extract_subsets(self: psi4.core.Molecule, arg0: int, arg1: int) -> psi4.core.Molecule. Returns copy of self with arg0 fragment Real and arg1 fragment Ghost. extract_subsets(self: psi4.core.Molecule, arg0: list[int]) -> psi4.core.Molecule. Returns copy of self with arg0 fragments Real. extract_subsets(self: psi4.core.Molecule, arg0: int) -> psi4.core.Molecule. Returns copy of self with arg0 fragment Real. fZ(self: psi4.core.Molecule, arg0: int)  float; Nuclear charge of atom arg1 (0-indexed including dummies). fcharge(self: psi4.core.Molecule, atom: int)  float; Gets charge of atom (0-indexed including dummies). find_highest_point_group(self: psi4.core.Molecule, tolerance: float = 1e-08)  psi4.core.PointGroup; Finds highest possible computational molecular point group. find_point_group(self: psi4.core.Molecule, tolerance: float = 1e-08)  psi4.core.PointGroup; Finds computational molecular point group, user can override this with the symmetry keyword. fix_com(self: psi4.core.Molecule, arg0: bool)  None; Sets whether to fix the Cartesian position, or to translate to the C.O.M. Expert use only; use before molecule finalized by update_geometry. fix_orientation(self: psi4.core.Molecule, arg0: bool)  None; Fix the orientation at its current frame. Expert use only; use before molecule finalized by update_geometry. flabel(self: psi4.core.Molecule, atom: int)  str; Gets the original label of the atom arg0 as given in the input file (C2, H4)(0-indexed including dummies). fmass(self: psi4.core.Molecule, atom: int)  float; Gets mass of atom (0-indexed including dummies). form_symmetry_information(self: psi4.core.Molecule, arg0: float)  None; Uses the po",MatchSource.WIKI,psi4manual/master/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/master/api/psi4.core.Molecule.html:19015,Availability,toler,tolerance,19015,"ract_subsets(self: psi4.core.Molecule, arg0: int, arg1: list[int]) -> psi4.core.Molecule. Returns copy of self with arg0 fragment Real and arg1 fragments Ghost. extract_subsets(self: psi4.core.Molecule, arg0: int, arg1: int) -> psi4.core.Molecule. Returns copy of self with arg0 fragment Real and arg1 fragment Ghost. extract_subsets(self: psi4.core.Molecule, arg0: list[int]) -> psi4.core.Molecule. Returns copy of self with arg0 fragments Real. extract_subsets(self: psi4.core.Molecule, arg0: int) -> psi4.core.Molecule. Returns copy of self with arg0 fragment Real. fZ(self: psi4.core.Molecule, arg0: int)  float; Nuclear charge of atom arg1 (0-indexed including dummies). fcharge(self: psi4.core.Molecule, atom: int)  float; Gets charge of atom (0-indexed including dummies). find_highest_point_group(self: psi4.core.Molecule, tolerance: float = 1e-08)  psi4.core.PointGroup; Finds highest possible computational molecular point group. find_point_group(self: psi4.core.Molecule, tolerance: float = 1e-08)  psi4.core.PointGroup; Finds computational molecular point group, user can override this with the symmetry keyword. fix_com(self: psi4.core.Molecule, arg0: bool)  None; Sets whether to fix the Cartesian position, or to translate to the C.O.M. Expert use only; use before molecule finalized by update_geometry. fix_orientation(self: psi4.core.Molecule, arg0: bool)  None; Fix the orientation at its current frame. Expert use only; use before molecule finalized by update_geometry. flabel(self: psi4.core.Molecule, atom: int)  str; Gets the original label of the atom arg0 as given in the input file (C2, H4)(0-indexed including dummies). fmass(self: psi4.core.Molecule, atom: int)  float; Gets mass of atom (0-indexed including dummies). form_symmetry_information(self: psi4.core.Molecule, arg0: float)  None; Uses the point group object obtain by calling point_group(). format_molecule_for_mol(); Returns a string of Molecule formatted for mol2.; Written by Trent M. Parker",MatchSource.WIKI,psi4manual/master/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/master/api/psi4.core.Molecule.html:20454,Availability,error,error,20454,", or to translate to the C.O.M. Expert use only; use before molecule finalized by update_geometry. fix_orientation(self: psi4.core.Molecule, arg0: bool)  None; Fix the orientation at its current frame. Expert use only; use before molecule finalized by update_geometry. flabel(self: psi4.core.Molecule, atom: int)  str; Gets the original label of the atom arg0 as given in the input file (C2, H4)(0-indexed including dummies). fmass(self: psi4.core.Molecule, atom: int)  float; Gets mass of atom (0-indexed including dummies). form_symmetry_information(self: psi4.core.Molecule, arg0: float)  None; Uses the point group object obtain by calling point_group(). format_molecule_for_mol(); Returns a string of Molecule formatted for mol2.; Written by Trent M. Parker 9 Jun 2014. classmethod from_arrays(geom=None, elea=None, elez=None, elem=None, mass=None, real=None, elbl=None, name=None, units='Angstrom', input_units_to_au=None, fix_com=None, fix_orientation=None, fix_symmetry=None, fragment_separators=None, fragment_charges=None, fragment_multiplicities=None, molecular_charge=None, molecular_multiplicity=None, comment=None, provenance=None, connectivity=None, missing_enabled_return='error', tooclose=0.1, zero_ghost_fragments=False, nonphysical=False, mtol=0.001, verbose=1, return_dict=False); Construct Molecule from unvalidated arrays and variables.; Light wrapper around from_arrays(); that is a full-featured constructor to dictionary representa-; tion of Molecule. This follows one step further to return; Molecule instance.; :param See from_arrays().:. Return type:; psi4.core.Molecule. static from_dict(arg0: dict)  psi4.core.Molecule; Returns a new Molecule constructed from python dictionary. In progress: name and capabilities should not be relied upon. classmethod from_schema(molschema, return_dict=False, nonphysical=False, verbose=1); Construct Molecule from non-Psi4 schema.; Light wrapper around from_arrays(). Parameters:. molschema (Dict)  Dictionary form of Mo",MatchSource.WIKI,psi4manual/master/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.Molecule.html
