id,quality_attribute,keyword,matched_word,match_idx,sentence,source,filename,author,repo,version,wiki,url
https://root.cern/root/html528/TGeoPgonEditor.html:22039,Usability,undo,undoing,22039,"Manager*TGeoGedFrame::fTabMgrtab manager corresponding to ged-editor; TGTextButton*TGeoPconEditor::fUndoUndo-Button; UInt_tTGFrame::fWidthframe width; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; Double_t*TGeoPconEditor::fZiInitial Z positions; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoPgonEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor for polycone editor. ~TGeoPgonEditor(); Destructor. void SetModel(TObject* obj); Connect to a given pcon. void DoApply(); Slot for applying modifications. void DoUndo(); Slot for undoing last operation. void CreateEdges(); Create number entry for Nedges. void DoNedges(); Change number of edges. » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id: TGeoPgonEditor.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2010-09-23 20:09; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html528/TGeoPgonEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoPgonEditor.html
https://root.cern/root/html528/TGeoPhysicalNode.html:3148,Availability,error,error,3148,,MatchSource.WIKI,root/html528/TGeoPhysicalNode.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoPhysicalNode.html
https://root.cern/root/html528/TGeoPhysicalNode.html:3232,Availability,error,error,3232,"al voidTObject::Browse(TBrowser* b); voidcd() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; Int_tGetLevel() const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; TGeoHMatrix*GetMatrix(Int_t level = -1) const; TGeoNode*GetMother(Int_t levup = 1) const; virtual const char*TNamed::GetName() const; TGeoNode*GetNode(Int_t level = -1) const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TGeoHMatrix*GetOriginalMatrix() const; TGeoShape*GetShap",MatchSource.WIKI,root/html528/TGeoPhysicalNode.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoPhysicalNode.html
https://root.cern/root/html528/TGeoPhysicalNode.html:9410,Performance,perform,perform,9410,"Color_tTAttLine::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; TObjArray*fMatricesglobal transformation matrices; TGeoHMatrix*fMatrixOrigoriginal local matrix of the last node in the path; TStringTNamed::fNameobject identifier; TObjArray*fNodesbranch of nodes; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoPhysicalNode(); Default constructor. TGeoPhysicalNode(const char* path); Constructor. TGeoPhysicalNode(const TGeoPhysicalNode& ); copy constructor. TGeoPhysicalNode& operator=(const TGeoPhysicalNode& ); assignment operator. ~TGeoPhysicalNode(); Destructor. void Align(TGeoMatrix* newmat = 0, TGeoShape* newshape = 0, Bool_t check = kFALSE, Double_t ovlp = 0.001); Align a physical node with a new relative matrix/shape.; Example: /TOP_1/A_1/B_1/C_1; node->Align(transl_1, box) will perform:; - change RELATIVE translation of C_1 node (with respect to its; container volume B) to transl_1; - change the shape of the C volume; *NOTE* The operations will affect ONLY the LAST node in the branch. All; volumes/nodes in the branch represented by this physical node are; CLONED so the operation does not affect other possible replicas. void cd() const. void Draw(Option_t* option = """"); Draw this node. TGeoNode * GetMother(Int_t levup = 1) const; Return parent at LEVUP generation. TGeoHMatrix * GetMatrix(Int_t level = -1) const; Return global matrix for node at LEVEL. TGeoNode * GetNode(Int_t level = -1) const; Return node in branch at LEVEL. If not specified, return last leaf. TGeoVolume * GetVolume(Int_t level = -1) const; Return volume associated with node at LEVEL in the branch. TGeoShape * GetShape(Int_t level = -1) const; Return shape associated with volume. void Paint(Option_t* option = """"); Paint this node and its content according to visualization settings. void Print(Option_t* option = """") const; Print info about this node. void Refresh();",MatchSource.WIKI,root/html528/TGeoPhysicalNode.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoPhysicalNode.html
https://root.cern/root/html528/TGeoPhysicalNode.html:683,Safety,detect,detector,683,". TGeoPhysicalNode. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GEOM; » GEOM; » TGeoPhysicalNode. class TGeoPhysicalNode: public TNamed, public TAttLine. TGeoPhysicalNode, TGeoPNEntry. Physical nodes are the actual 'touchable' objects in the geometry, representing; a path of positioned volumes starting with the top node:; path=/TOP/A_1/B_4/C_3 , where A, B, C represent names of volumes.; The number of physical nodes is given by the total number of possible of; branches in the geometry hierarchy. In case of detector geometries and; specially for calorimeters this number can be of the order 1e6-1e9, therefore; it is impossible to create all physical nodes as objects in memory. In TGeo,; physical nodes are represented by the class TGeoPhysicalNode and can be created; on demand for alignment purposes:. TGeoPhysicalNode *pn = new TGeoPhysicalNode(""path_to_object""). Once created, a physical node can be misaligned, meaning that its position; or even shape can be changed:. pn->Align(TGeoMatrix* newmat, TGeoShape* newshape, Bool_t check=kFALSE). The knowledge of the path to the objects that need to be misaligned is; essential since there is no other way of identifying them. One can however; create 'symbolic links' to any complex path to make it more representable; for the object it designates:. TGeoPNEntry *pne = new TGeoPNEntry(""TPC_SECTOR_2"", ""path_to_tpc_sect2"");; pne->SetPhysicalNode(pn). Such a symbolic link hides the complexity of the path to the align object and; replaces it with a more meaningful name. In addition, TGeoPNEntry objects are; faster to search by name and they may optionally store an additional user; matrix. For more details please read the misalignment section in the Users Guide. Function Members (Methods); public:. TGeoPhysicalNode(); TGeoPhysicalNode(const char* path); virtual~TGeoPhy",MatchSource.WIKI,root/html528/TGeoPhysicalNode.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoPhysicalNode.html
https://root.cern/root/html528/TGeoPNEntry.html:2906,Availability,error,error,2906,"(); TGeoPNEntry(const char* unique_name, const char* path); virtual~TGeoPNEntry(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); TGeoHMatrix*GetGlobalOrig() const; virtual const char*TObject::GetIconName() const; const TGeoHMatrix*GetMatrix() const; TGeoHMatrix*GetMatrixOrig() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; const char*GetPath() const; TGeoPhysicalNode*GetPhysicalNode() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; vi",MatchSource.WIKI,root/html528/TGeoPNEntry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoPNEntry.html
https://root.cern/root/html528/TGeoPNEntry.html:2990,Availability,error,error,2990,"oidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); TGeoHMatrix*GetGlobalOrig() const; virtual const char*TObject::GetIconName() const; const TGeoHMatrix*GetMatrix() const; TGeoHMatrix*GetMatrixOrig() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; const char*GetPath() const; TGeoPhysicalNode*GetPhysicalNode() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const",MatchSource.WIKI,root/html528/TGeoPNEntry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoPNEntry.html
https://root.cern/root/html528/TGeoPNEntry.html:651,Safety,detect,detector,651,". TGeoPNEntry. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GEOM; » GEOM; » TGeoPNEntry. class TGeoPNEntry: public TNamed. TGeoPhysicalNode, TGeoPNEntry. Physical nodes are the actual 'touchable' objects in the geometry, representing; a path of positioned volumes starting with the top node:; path=/TOP/A_1/B_4/C_3 , where A, B, C represent names of volumes.; The number of physical nodes is given by the total number of possible of; branches in the geometry hierarchy. In case of detector geometries and; specially for calorimeters this number can be of the order 1e6-1e9, therefore; it is impossible to create all physical nodes as objects in memory. In TGeo,; physical nodes are represented by the class TGeoPhysicalNode and can be created; on demand for alignment purposes:. TGeoPhysicalNode *pn = new TGeoPhysicalNode(""path_to_object""). Once created, a physical node can be misaligned, meaning that its position; or even shape can be changed:. pn->Align(TGeoMatrix* newmat, TGeoShape* newshape, Bool_t check=kFALSE). The knowledge of the path to the objects that need to be misaligned is; essential since there is no other way of identifying them. One can however; create 'symbolic links' to any complex path to make it more representable; for the object it designates:. TGeoPNEntry *pne = new TGeoPNEntry(""TPC_SECTOR_2"", ""path_to_tpc_sect2"");; pne->SetPhysicalNode(pn). Such a symbolic link hides the complexity of the path to the align object and; replaces it with a more meaningful name. In addition, TGeoPNEntry objects are; faster to search by name and they may optionally store an additional user; matrix. For more details please read the misalignment section in the Users Guide. Function Members (Methods); public:. TGeoPNEntry(); TGeoPNEntry(const char* unique_name, const char* path); virtual~TGeoPNEntry(); voidTObje",MatchSource.WIKI,root/html528/TGeoPNEntry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoPNEntry.html
https://root.cern/root/html528/TGeoPolygon.html:2814,Availability,error,error,2814," virtual~TGeoPolygon(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); Double_tArea() const; virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tContains(Double_t* point) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; voidFinishPolygon(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; Int_tGetNvert() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; Double_t*GetX(); Double_t*GetY(); virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char*",MatchSource.WIKI,root/html528/TGeoPolygon.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoPolygon.html
https://root.cern/root/html528/TGeoPolygon.html:2898,Availability,error,error,2898,"al voidTObject::AppendPad(Option_t* option = """"); Double_tArea() const; virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tContains(Double_t* point) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; voidFinishPolygon(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; Int_tGetNvert() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; Double_t*GetX(); Double_t*GetY(); virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; vi",MatchSource.WIKI,root/html528/TGeoPolygon.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoPolygon.html
https://root.cern/root/html528/TGeoRotation.html:6228,Availability,error,error,6228,"dy,dz) translation. Data members:; Double_t fTranslation[3]. Translations can be added/subtracted.; TGeoTranslation t1;; t1->SetTranslation(-5,10,4);; TGeoTranslation *t2 = new TGeoTranslation(4,3,10);; t2->Subtract(&t1);. 2. Rotations - represent a pure rotation. Data members: Double_t fRotationMatrix[3*3].; Rotations can be defined either by Euler angles, either, by GEANT3 angles :; TGeoRotation *r1 = new TGeoRotation();; r1->SetAngles(phi, theta, psi); // all angles in degrees; This represent the composition of : first a rotation about Z axis with; angle phi, then a rotation with theta about the rotated X axis, and; finally a rotation with psi about the new Z axis. r1->SetAngles(th1,phi1, th2,phi2, th3,phi3); This is a rotation defined in GEANT3 style. Theta and phi are the spherical; angles of each axis of the rotated coordinate system with respect to the; initial one. This construction allows definition of malformed rotations,; e.g. not orthogonal. A check is performed and an error message is issued; in this case. Specific utilities : determinant, inverse. 3. Scale transformations - represent a scale shrinking/enlargement. Data; members :Double_t fScale[3]. Not fully implemented yet. 4. Combined transformations - represent a rotation folowed by a translation.; Data members: Double_t fTranslation[3], TGeoRotation *fRotation.; TGeoRotation *rot = new TGeoRotation(""rot"",10,20,30);; TGeoTranslation trans;. TGeoCombiTrans *c1 = new TGeoCombiTrans(trans, rot);; TGeoCombiTrans *c2 = new TGeoCombiTrans(""somename"",10,20,30,rot). 5. TGeoGenTrans - combined transformations including a scale. Not implemented.; 6. TGeoIdentity - a generic singleton matrix representing a identity transformation; NOTE: identified by the global variable gGeoIdentity. Function Members (Methods); public:. TGeoRotation(); TGeoRotation(const TGeoRotation& other); TGeoRotation(const TGeoMatrix& other); TGeoRotation(const char* name); TGeoRotation(const char* name, Double_t phi, Double_t theta, Doubl",MatchSource.WIKI,root/html528/TGeoRotation.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoRotation.html
https://root.cern/root/html528/TGeoRotation.html:8330,Availability,error,error,8330,"hi2, Double_t theta3, Double_t phi3); virtual~TGeoRotation(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Double_tDeterminant() const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); voidFastRotZ(Double_t* sincos); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; voidGetAngles(Double_t& phi, Double_t& theta, Double_t& psi) const; voidGetAngles(Double_t& theta1, Double_t& phi1, Double_t& theta2, Double_t& phi2, Double_t& theta3, Double_t& phi3) const; virtual Int_tTGeoMatrix::GetByteCount() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); voidTGeoMatrix::GetHomogenousMatrix(Double_t* hmat) const; virtual const char*TObject::GetIconName() const; voidGetInverse(Double_t* invmat) const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, ",MatchSource.WIKI,root/html528/TGeoRotation.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoRotation.html
https://root.cern/root/html528/TGeoRotation.html:8414,Availability,error,error,8414,"ethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Double_tDeterminant() const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); voidFastRotZ(Double_t* sincos); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; voidGetAngles(Double_t& phi, Double_t& theta, Double_t& psi) const; voidGetAngles(Double_t& theta1, Double_t& phi1, Double_t& theta2, Double_t& phi2, Double_t& theta3, Double_t& phi3) const; virtual Int_tTGeoMatrix::GetByteCount() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); voidTGeoMatrix::GetHomogenousMatrix(Double_t* hmat) const; virtual const char*TObject::GetIconName() const; voidGetInverse(Double_t* invmat) const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::Ge",MatchSource.WIKI,root/html528/TGeoRotation.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoRotation.html
https://root.cern/root/html528/TGeoRotation.html:3100,Integrability,interface,interface,3100," 0 1/sz 0; 0 0 0 1 0 0 0 1. where: rij are the 3x3 rotation matrix components,; tx, ty, tz are the translation components; sx, sy, sz are arbitrary scale constants on the eacks axis,. The disadvantage in using this approach is that computation for 4x4 matrices; is expensive. Even combining two translation would become a multiplication; of their corresponding matrices, which is quite an undesired effect. On the; other hand, it is not a good idea to store a translation as a block of 16; numbers. We have therefore chosen to implement each basic transformation type; as a class deriving from the same basic abstract class and handling its specific; data and point/vector transformation algorithms. /*. */. The base class TGeoMatrix defines abstract metods for:. - translation, rotation and scale getters. Every derived class stores only; its specific data, e.g. a translation stores an array of 3 doubles and a; rotation an array of 9. However, asking which is the rotation array of a; TGeoTranslation through the base TGeoMatrix interface is a legal operation.; The answer in this case is a pointer to a global constant array representing; an identity rotation.; Double_t *TGeoMatrix::GetTranslation(); Double_t *TGeoMatrix::GetRotation(); Double_t *TGeoMatrix::GetScale(). - MasterToLocal() and LocalToMaster() point and vector transformations :; void TGeoMatrix::MasterToLocal(const Double_t *master, Double_t *local); void TGeoMatrix::LocalToMaster(const Double_t *local, Double_t *master); void TGeoMatrix::MasterToLocalVect(const Double_t *master, Double_t *local); void TGeoMatrix::LocalToMasterVect(const Double_t *local, Double_t *master); These allow correct conversion also for reflections.; - Transformation type getters :; Bool_t TGeoMatrix::IsIdentity(); Bool_t TGeoMatrix::IsTranslation(); Bool_t TGeoMatrix::IsRotation(); Bool_t TGeoMatrix::IsScale(); Bool_t TGeoMatrix::IsCombi() (translation + rotation); Bool_t TGeoMatrix::IsGeneral() (translation + rotation + scale). Combinatio",MatchSource.WIKI,root/html528/TGeoRotation.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoRotation.html
https://root.cern/root/html528/TGeoRotation.html:6234,Integrability,message,message,6234,"dy,dz) translation. Data members:; Double_t fTranslation[3]. Translations can be added/subtracted.; TGeoTranslation t1;; t1->SetTranslation(-5,10,4);; TGeoTranslation *t2 = new TGeoTranslation(4,3,10);; t2->Subtract(&t1);. 2. Rotations - represent a pure rotation. Data members: Double_t fRotationMatrix[3*3].; Rotations can be defined either by Euler angles, either, by GEANT3 angles :; TGeoRotation *r1 = new TGeoRotation();; r1->SetAngles(phi, theta, psi); // all angles in degrees; This represent the composition of : first a rotation about Z axis with; angle phi, then a rotation with theta about the rotated X axis, and; finally a rotation with psi about the new Z axis. r1->SetAngles(th1,phi1, th2,phi2, th3,phi3); This is a rotation defined in GEANT3 style. Theta and phi are the spherical; angles of each axis of the rotated coordinate system with respect to the; initial one. This construction allows definition of malformed rotations,; e.g. not orthogonal. A check is performed and an error message is issued; in this case. Specific utilities : determinant, inverse. 3. Scale transformations - represent a scale shrinking/enlargement. Data; members :Double_t fScale[3]. Not fully implemented yet. 4. Combined transformations - represent a rotation folowed by a translation.; Data members: Double_t fTranslation[3], TGeoRotation *fRotation.; TGeoRotation *rot = new TGeoRotation(""rot"",10,20,30);; TGeoTranslation trans;. TGeoCombiTrans *c1 = new TGeoCombiTrans(trans, rot);; TGeoCombiTrans *c2 = new TGeoCombiTrans(""somename"",10,20,30,rot). 5. TGeoGenTrans - combined transformations including a scale. Not implemented.; 6. TGeoIdentity - a generic singleton matrix representing a identity transformation; NOTE: identified by the global variable gGeoIdentity. Function Members (Methods); public:. TGeoRotation(); TGeoRotation(const TGeoRotation& other); TGeoRotation(const TGeoMatrix& other); TGeoRotation(const char* name); TGeoRotation(const char* name, Double_t phi, Double_t theta, Doubl",MatchSource.WIKI,root/html528/TGeoRotation.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoRotation.html
https://root.cern/root/html528/TGeoRotation.html:6979,Modifiability,variab,variable,6979,"th2,phi2, th3,phi3); This is a rotation defined in GEANT3 style. Theta and phi are the spherical; angles of each axis of the rotated coordinate system with respect to the; initial one. This construction allows definition of malformed rotations,; e.g. not orthogonal. A check is performed and an error message is issued; in this case. Specific utilities : determinant, inverse. 3. Scale transformations - represent a scale shrinking/enlargement. Data; members :Double_t fScale[3]. Not fully implemented yet. 4. Combined transformations - represent a rotation folowed by a translation.; Data members: Double_t fTranslation[3], TGeoRotation *fRotation.; TGeoRotation *rot = new TGeoRotation(""rot"",10,20,30);; TGeoTranslation trans;. TGeoCombiTrans *c1 = new TGeoCombiTrans(trans, rot);; TGeoCombiTrans *c2 = new TGeoCombiTrans(""somename"",10,20,30,rot). 5. TGeoGenTrans - combined transformations including a scale. Not implemented.; 6. TGeoIdentity - a generic singleton matrix representing a identity transformation; NOTE: identified by the global variable gGeoIdentity. Function Members (Methods); public:. TGeoRotation(); TGeoRotation(const TGeoRotation& other); TGeoRotation(const TGeoMatrix& other); TGeoRotation(const char* name); TGeoRotation(const char* name, Double_t phi, Double_t theta, Double_t psi); TGeoRotation(const char* name, Double_t theta1, Double_t phi1, Double_t theta2, Double_t phi2, Double_t theta3, Double_t phi3); virtual~TGeoRotation(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Double_tDeterminant() const; virtual Int_tTObject:",MatchSource.WIKI,root/html528/TGeoRotation.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoRotation.html
https://root.cern/root/html528/TGeoRotation.html:484,Performance,optimiz,optimize,484,". TGeoRotation. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GEOM; » GEOM; » TGeoRotation. class TGeoRotation: public TGeoMatrix. Geometrical transformation package. All geometrical transformations handled by the modeller are provided as a; built-in package. This was designed to minimize memory requirements and; optimize performance of point/vector master-to-local and local-to-master; computation. We need to have in mind that a transformation in TGeo has 2; major use-cases. The first one is for defining the placement of a volume; with respect to its container reference frame. This frame will be called; 'master' and the frame of the positioned volume - 'local'. If T is a; transformation used for positioning volume daughters, then:. MASTER = T * LOCAL. Therefore a local-to-master conversion will be performed by using T, while; a master-to-local by using its inverse. The second use case is the computation; of the global transformation of a given object in the geometry. Since the; geometry is built as 'volumes-inside-volumes', this global transformation; represent the pile-up of all local transformations in the corresponding; branch. The conversion from the global reference frame and the given object; is also called master-to-local, but it is handled by the manager class.; A general homogenous transformation is defined as a 4x4 matrix embeeding; a rotation, a translation and a scale. The advantage of this description; is that each basic transformation can be represented as a homogenous matrix,; composition being performed as simple matrix multiplication.; Rotation: Inverse rotation:; r11 r12 r13 0 r11 r21 r31 0; r21 r22 r23 0 r12 r22 r32 0; r31 r32 r33 0 r13 r23 r33 0; 0 0 0 1 0 0 0 1. Translation: Inverse translation:; 1 0 0 tx 1 0 0 -tx; 0 1 0 ty 0 1 0 -ty; 0 0 1 tz 0 0 1 -tz; 0 0 0 1 0 0 0 1. Scale: I",MatchSource.WIKI,root/html528/TGeoRotation.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoRotation.html
https://root.cern/root/html528/TGeoRotation.html:493,Performance,perform,performance,493,". TGeoRotation. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GEOM; » GEOM; » TGeoRotation. class TGeoRotation: public TGeoMatrix. Geometrical transformation package. All geometrical transformations handled by the modeller are provided as a; built-in package. This was designed to minimize memory requirements and; optimize performance of point/vector master-to-local and local-to-master; computation. We need to have in mind that a transformation in TGeo has 2; major use-cases. The first one is for defining the placement of a volume; with respect to its container reference frame. This frame will be called; 'master' and the frame of the positioned volume - 'local'. If T is a; transformation used for positioning volume daughters, then:. MASTER = T * LOCAL. Therefore a local-to-master conversion will be performed by using T, while; a master-to-local by using its inverse. The second use case is the computation; of the global transformation of a given object in the geometry. Since the; geometry is built as 'volumes-inside-volumes', this global transformation; represent the pile-up of all local transformations in the corresponding; branch. The conversion from the global reference frame and the given object; is also called master-to-local, but it is handled by the manager class.; A general homogenous transformation is defined as a 4x4 matrix embeeding; a rotation, a translation and a scale. The advantage of this description; is that each basic transformation can be represented as a homogenous matrix,; composition being performed as simple matrix multiplication.; Rotation: Inverse rotation:; r11 r12 r13 0 r11 r21 r31 0; r21 r22 r23 0 r12 r22 r32 0; r31 r32 r33 0 r13 r23 r33 0; 0 0 0 1 0 0 0 1. Translation: Inverse translation:; 1 0 0 tx 1 0 0 -tx; 0 1 0 ty 0 1 0 -ty; 0 0 1 tz 0 0 1 -tz; 0 0 0 1 0 0 0 1. Scale: I",MatchSource.WIKI,root/html528/TGeoRotation.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoRotation.html
https://root.cern/root/html528/TGeoRotation.html:978,Performance,perform,performed,978,". TGeoRotation. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GEOM; » GEOM; » TGeoRotation. class TGeoRotation: public TGeoMatrix. Geometrical transformation package. All geometrical transformations handled by the modeller are provided as a; built-in package. This was designed to minimize memory requirements and; optimize performance of point/vector master-to-local and local-to-master; computation. We need to have in mind that a transformation in TGeo has 2; major use-cases. The first one is for defining the placement of a volume; with respect to its container reference frame. This frame will be called; 'master' and the frame of the positioned volume - 'local'. If T is a; transformation used for positioning volume daughters, then:. MASTER = T * LOCAL. Therefore a local-to-master conversion will be performed by using T, while; a master-to-local by using its inverse. The second use case is the computation; of the global transformation of a given object in the geometry. Since the; geometry is built as 'volumes-inside-volumes', this global transformation; represent the pile-up of all local transformations in the corresponding; branch. The conversion from the global reference frame and the given object; is also called master-to-local, but it is handled by the manager class.; A general homogenous transformation is defined as a 4x4 matrix embeeding; a rotation, a translation and a scale. The advantage of this description; is that each basic transformation can be represented as a homogenous matrix,; composition being performed as simple matrix multiplication.; Rotation: Inverse rotation:; r11 r12 r13 0 r11 r21 r31 0; r21 r22 r23 0 r12 r22 r32 0; r31 r32 r33 0 r13 r23 r33 0; 0 0 0 1 0 0 0 1. Translation: Inverse translation:; 1 0 0 tx 1 0 0 -tx; 0 1 0 ty 0 1 0 -ty; 0 0 1 tz 0 0 1 -tz; 0 0 0 1 0 0 0 1. Scale: I",MatchSource.WIKI,root/html528/TGeoRotation.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoRotation.html
https://root.cern/root/html528/TGeoRotation.html:1704,Performance,perform,performed,1704,"one is for defining the placement of a volume; with respect to its container reference frame. This frame will be called; 'master' and the frame of the positioned volume - 'local'. If T is a; transformation used for positioning volume daughters, then:. MASTER = T * LOCAL. Therefore a local-to-master conversion will be performed by using T, while; a master-to-local by using its inverse. The second use case is the computation; of the global transformation of a given object in the geometry. Since the; geometry is built as 'volumes-inside-volumes', this global transformation; represent the pile-up of all local transformations in the corresponding; branch. The conversion from the global reference frame and the given object; is also called master-to-local, but it is handled by the manager class.; A general homogenous transformation is defined as a 4x4 matrix embeeding; a rotation, a translation and a scale. The advantage of this description; is that each basic transformation can be represented as a homogenous matrix,; composition being performed as simple matrix multiplication.; Rotation: Inverse rotation:; r11 r12 r13 0 r11 r21 r31 0; r21 r22 r23 0 r12 r22 r32 0; r31 r32 r33 0 r13 r23 r33 0; 0 0 0 1 0 0 0 1. Translation: Inverse translation:; 1 0 0 tx 1 0 0 -tx; 0 1 0 ty 0 1 0 -ty; 0 0 1 tz 0 0 1 -tz; 0 0 0 1 0 0 0 1. Scale: Inverse scale:; sx 0 0 0 1/sx 0 0 0; 0 sy 0 0 0 1/sy 0 0; 0 0 sz 0 0 0 1/sz 0; 0 0 0 1 0 0 0 1. where: rij are the 3x3 rotation matrix components,; tx, ty, tz are the translation components; sx, sy, sz are arbitrary scale constants on the eacks axis,. The disadvantage in using this approach is that computation for 4x4 matrices; is expensive. Even combining two translation would become a multiplication; of their corresponding matrices, which is quite an undesired effect. On the; other hand, it is not a good idea to store a translation as a block of 16; numbers. We have therefore chosen to implement each basic transformation type; as a class deriving fr",MatchSource.WIKI,root/html528/TGeoRotation.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoRotation.html
https://root.cern/root/html528/TGeoRotation.html:6211,Performance,perform,performed,6211,"dy,dz) translation. Data members:; Double_t fTranslation[3]. Translations can be added/subtracted.; TGeoTranslation t1;; t1->SetTranslation(-5,10,4);; TGeoTranslation *t2 = new TGeoTranslation(4,3,10);; t2->Subtract(&t1);. 2. Rotations - represent a pure rotation. Data members: Double_t fRotationMatrix[3*3].; Rotations can be defined either by Euler angles, either, by GEANT3 angles :; TGeoRotation *r1 = new TGeoRotation();; r1->SetAngles(phi, theta, psi); // all angles in degrees; This represent the composition of : first a rotation about Z axis with; angle phi, then a rotation with theta about the rotated X axis, and; finally a rotation with psi about the new Z axis. r1->SetAngles(th1,phi1, th2,phi2, th3,phi3); This is a rotation defined in GEANT3 style. Theta and phi are the spherical; angles of each axis of the rotated coordinate system with respect to the; initial one. This construction allows definition of malformed rotations,; e.g. not orthogonal. A check is performed and an error message is issued; in this case. Specific utilities : determinant, inverse. 3. Scale transformations - represent a scale shrinking/enlargement. Data; members :Double_t fScale[3]. Not fully implemented yet. 4. Combined transformations - represent a rotation folowed by a translation.; Data members: Double_t fTranslation[3], TGeoRotation *fRotation.; TGeoRotation *rot = new TGeoRotation(""rot"",10,20,30);; TGeoTranslation trans;. TGeoCombiTrans *c1 = new TGeoCombiTrans(trans, rot);; TGeoCombiTrans *c2 = new TGeoCombiTrans(""somename"",10,20,30,rot). 5. TGeoGenTrans - combined transformations including a scale. Not implemented.; 6. TGeoIdentity - a generic singleton matrix representing a identity transformation; NOTE: identified by the global variable gGeoIdentity. Function Members (Methods); public:. TGeoRotation(); TGeoRotation(const TGeoRotation& other); TGeoRotation(const TGeoMatrix& other); TGeoRotation(const char* name); TGeoRotation(const char* name, Double_t phi, Double_t theta, Doubl",MatchSource.WIKI,root/html528/TGeoRotation.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoRotation.html
https://root.cern/root/html528/TGeoRotation.html:18640,Performance,perform,performes,18640,"ply by a reflection respect to ZX. void ReflectZ(Bool_t leftside, Bool_t rotonly = kFALSE); Multiply by a reflection respect to XY. void SavePrimitive(ostream& out, Option_t* option = """"); Save a primitive as a C++ statement(s) on output stream ""out"". void SetRotation(const TGeoMatrix& other); Copy rotation elements from other rotation matrix. void SetAngles(Double_t phi, Double_t theta, Double_t psi); Set matrix elements according to Euler angles. void SetAngles(Double_t theta1, Double_t phi1, Double_t theta2, Double_t phi2, Double_t theta3, Double_t phi3); Set matrix elements in the GEANT3 way. void GetAngles(Double_t& theta1, Double_t& phi1, Double_t& theta2, Double_t& phi2, Double_t& theta3, Double_t& phi3) const; Retreive rotation angles. void GetAngles(Double_t& phi, Double_t& theta, Double_t& psi) const; Retreive Euler angles. Double_t Determinant() const; computes determinant of the rotation matrix. void CheckMatrix(); performes an orthogonality check and finds if the matrix is a reflection; Warning(""CheckMatrix"", ""orthogonality check not performed yet"");. void GetInverse(Double_t* invmat) const; Get the inverse rotation matrix (which is simply the transpose). void MultiplyBy(TGeoRotation* rot, Bool_t after = kTRUE); Multiply this rotation with the one specified by ROT.; - after=TRUE (default): THIS*ROT; - after=FALSE : ROT*THIS. TGeoMatrix& operator=(const TGeoMatrix& matrix); Preventing warnings with -Weffc++ in GCC since the behaviour of operator * was chosen so by design. const Double_t * GetTranslation() const. const Double_t * GetRotationMatrix() const. const Double_t * GetScale() const. void LocalToMasterVect(const Double_t* local, Double_t* master) const. void LocalToMasterBomb(const Double_t* local, Double_t* master) const. void MasterToLocalVect(const Double_t* master, Double_t* local) const. void MasterToLocalBomb(const Double_t* master, Double_t* local) const. TGeoTranslation& operator=(const TGeoMatrix& matrix). virtual ~TGeoRotation(); {}. void",MatchSource.WIKI,root/html528/TGeoRotation.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoRotation.html
https://root.cern/root/html528/TGeoRotation.html:18762,Performance,perform,performed,18762,"ply by a reflection respect to ZX. void ReflectZ(Bool_t leftside, Bool_t rotonly = kFALSE); Multiply by a reflection respect to XY. void SavePrimitive(ostream& out, Option_t* option = """"); Save a primitive as a C++ statement(s) on output stream ""out"". void SetRotation(const TGeoMatrix& other); Copy rotation elements from other rotation matrix. void SetAngles(Double_t phi, Double_t theta, Double_t psi); Set matrix elements according to Euler angles. void SetAngles(Double_t theta1, Double_t phi1, Double_t theta2, Double_t phi2, Double_t theta3, Double_t phi3); Set matrix elements in the GEANT3 way. void GetAngles(Double_t& theta1, Double_t& phi1, Double_t& theta2, Double_t& phi2, Double_t& theta3, Double_t& phi3) const; Retreive rotation angles. void GetAngles(Double_t& phi, Double_t& theta, Double_t& psi) const; Retreive Euler angles. Double_t Determinant() const; computes determinant of the rotation matrix. void CheckMatrix(); performes an orthogonality check and finds if the matrix is a reflection; Warning(""CheckMatrix"", ""orthogonality check not performed yet"");. void GetInverse(Double_t* invmat) const; Get the inverse rotation matrix (which is simply the transpose). void MultiplyBy(TGeoRotation* rot, Bool_t after = kTRUE); Multiply this rotation with the one specified by ROT.; - after=TRUE (default): THIS*ROT; - after=FALSE : ROT*THIS. TGeoMatrix& operator=(const TGeoMatrix& matrix); Preventing warnings with -Weffc++ in GCC since the behaviour of operator * was chosen so by design. const Double_t * GetTranslation() const. const Double_t * GetRotationMatrix() const. const Double_t * GetScale() const. void LocalToMasterVect(const Double_t* local, Double_t* master) const. void LocalToMasterBomb(const Double_t* local, Double_t* master) const. void MasterToLocalVect(const Double_t* master, Double_t* local) const. void MasterToLocalBomb(const Double_t* master, Double_t* local) const. TGeoTranslation& operator=(const TGeoMatrix& matrix). virtual ~TGeoRotation(); {}. void",MatchSource.WIKI,root/html528/TGeoRotation.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoRotation.html
https://root.cern/root/html528/TGeoRotation.html:16296,Testability,test,test,16296,"& other); Copy ctor. TGeoRotation(const TGeoMatrix& other); Copy ctor. TGeoRotation(const char* name); Named rotation constructor. TGeoRotation(const char* name, Double_t phi, Double_t theta, Double_t psi); Default rotation constructor with Euler angles. Phi is the rotation angle about; Z axis and is done first, theta is the rotation about new Y and is done; second, psi is the rotation angle about new Z and is done third. All angles are in; degrees. TGeoRotation(const char* name, Double_t theta1, Double_t phi1, Double_t theta2, Double_t phi2, Double_t theta3, Double_t phi3); Rotation constructor a la GEANT3. Angles theta(i), phi(i) are the polar and azimuthal; angles of the (i) axis of the rotated system with respect to the initial non-rotated; system.; Example : the identity matrix (no rotation) is composed by; theta1=90, phi1=0, theta2=90, phi2=90, theta3=0, phi3=0; SetBit(kGeoRotation);. TGeoMatrix& Inverse() const; Return a temporary inverse of this. Bool_t IsValid() const; Perform orthogonality test for rotation. void Clear(Option_t* option = """"); reset data members. void FastRotZ(Double_t* sincos); Perform a rotation about Z having the sine/cosine of the rotation angle. Double_t GetPhiRotation(Bool_t fixX = kFALSE) const; --- Returns rotation angle about Z axis in degrees. If the rotation is a pure; rotation about Z, fixX parameter does not matter, otherwise its meaning is:; - fixX = true : result is the phi angle of the projection of the rotated X axis in the un-rotated XY; - fixX = false : result is the phi angle of the projection of the rotated Y axis - 90 degrees. void LocalToMaster(const Double_t* local, Double_t* master) const; convert a point by multiplying its column vector (x, y, z, 1) to matrix inverse. void MasterToLocal(const Double_t* master, Double_t* local) const; convert a point by multiplying its column vector (x, y, z, 1) to matrix. TGeoMatrix * MakeClone() const; Make a clone of this matrix. void RotateX(Double_t angle); Rotate about X axis o",MatchSource.WIKI,root/html528/TGeoRotation.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoRotation.html
https://root.cern/root/html528/TGeoRotation.html:1717,Usability,simpl,simple,1717,"one is for defining the placement of a volume; with respect to its container reference frame. This frame will be called; 'master' and the frame of the positioned volume - 'local'. If T is a; transformation used for positioning volume daughters, then:. MASTER = T * LOCAL. Therefore a local-to-master conversion will be performed by using T, while; a master-to-local by using its inverse. The second use case is the computation; of the global transformation of a given object in the geometry. Since the; geometry is built as 'volumes-inside-volumes', this global transformation; represent the pile-up of all local transformations in the corresponding; branch. The conversion from the global reference frame and the given object; is also called master-to-local, but it is handled by the manager class.; A general homogenous transformation is defined as a 4x4 matrix embeeding; a rotation, a translation and a scale. The advantage of this description; is that each basic transformation can be represented as a homogenous matrix,; composition being performed as simple matrix multiplication.; Rotation: Inverse rotation:; r11 r12 r13 0 r11 r21 r31 0; r21 r22 r23 0 r12 r22 r32 0; r31 r32 r33 0 r13 r23 r33 0; 0 0 0 1 0 0 0 1. Translation: Inverse translation:; 1 0 0 tx 1 0 0 -tx; 0 1 0 ty 0 1 0 -ty; 0 0 1 tz 0 0 1 -tz; 0 0 0 1 0 0 0 1. Scale: Inverse scale:; sx 0 0 0 1/sx 0 0 0; 0 sy 0 0 0 1/sy 0 0; 0 0 sz 0 0 0 1/sz 0; 0 0 0 1 0 0 0 1. where: rij are the 3x3 rotation matrix components,; tx, ty, tz are the translation components; sx, sy, sz are arbitrary scale constants on the eacks axis,. The disadvantage in using this approach is that computation for 4x4 matrices; is expensive. Even combining two translation would become a multiplication; of their corresponding matrices, which is quite an undesired effect. On the; other hand, it is not a good idea to store a translation as a block of 16; numbers. We have therefore chosen to implement each basic transformation type; as a class deriving fr",MatchSource.WIKI,root/html528/TGeoRotation.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoRotation.html
https://root.cern/root/html528/TGeoRotation.html:18863,Usability,simpl,simply,18863,"oid SavePrimitive(ostream& out, Option_t* option = """"); Save a primitive as a C++ statement(s) on output stream ""out"". void SetRotation(const TGeoMatrix& other); Copy rotation elements from other rotation matrix. void SetAngles(Double_t phi, Double_t theta, Double_t psi); Set matrix elements according to Euler angles. void SetAngles(Double_t theta1, Double_t phi1, Double_t theta2, Double_t phi2, Double_t theta3, Double_t phi3); Set matrix elements in the GEANT3 way. void GetAngles(Double_t& theta1, Double_t& phi1, Double_t& theta2, Double_t& phi2, Double_t& theta3, Double_t& phi3) const; Retreive rotation angles. void GetAngles(Double_t& phi, Double_t& theta, Double_t& psi) const; Retreive Euler angles. Double_t Determinant() const; computes determinant of the rotation matrix. void CheckMatrix(); performes an orthogonality check and finds if the matrix is a reflection; Warning(""CheckMatrix"", ""orthogonality check not performed yet"");. void GetInverse(Double_t* invmat) const; Get the inverse rotation matrix (which is simply the transpose). void MultiplyBy(TGeoRotation* rot, Bool_t after = kTRUE); Multiply this rotation with the one specified by ROT.; - after=TRUE (default): THIS*ROT; - after=FALSE : ROT*THIS. TGeoMatrix& operator=(const TGeoMatrix& matrix); Preventing warnings with -Weffc++ in GCC since the behaviour of operator * was chosen so by design. const Double_t * GetTranslation() const. const Double_t * GetRotationMatrix() const. const Double_t * GetScale() const. void LocalToMasterVect(const Double_t* local, Double_t* master) const. void LocalToMasterBomb(const Double_t* local, Double_t* master) const. void MasterToLocalVect(const Double_t* master, Double_t* local) const. void MasterToLocalBomb(const Double_t* master, Double_t* local) const. TGeoTranslation& operator=(const TGeoMatrix& matrix). virtual ~TGeoRotation(); {}. void SetMatrix(const Double_t* rot); {memcpy(&fRotationMatrix[0], rot, 9*sizeof(Double_t));CheckMatrix();}. » Author: Andrei Gheata 25/10",MatchSource.WIKI,root/html528/TGeoRotation.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoRotation.html
https://root.cern/root/html528/TGeoRotationEditor.html:4676,Availability,error,error,4676,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const;",MatchSource.WIKI,root/html528/TGeoRotationEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoRotationEditor.html
https://root.cern/root/html528/TGeoRotationEditor.html:4760,Availability,error,error,4760,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType() c",MatchSource.WIKI,root/html528/TGeoRotationEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoRotationEditor.html
https://root.cern/root/html528/TGeoRotationEditor.html:17719,Availability,mask,mask,17719,,MatchSource.WIKI,root/html528/TGeoRotationEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoRotationEditor.html
https://root.cern/root/html528/TGeoRotationEditor.html:21908,Usability,undo,undoing,21908,"const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoRotationEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor for rotation editor. ~TGeoRotationEditor(); Destructor. void ConnectSignals2Slots(); Connect signals to slots. void SetModel(TObject* obj); Connect to the selected rotation. void DoName(); Slot for name. void DoRotPhi(); Slot for phi (Euler X convention). void DoRotTheta(); Slot for theta (Euler X convention). void DoRotPsi(); Slot for psi (Euler X convention). void DoRotAngle(); Slot for additional rotation about one axis. Bool_t DoParameters(); Slot for checking parameters. void DoApply(); Slot for applying modifications. void DoCancel(); Slot for cancelling last un-applied operations. void DoModified(); Slot for notifying changes. void DoUndo(); Slot for undoing last changes. » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id: TGeoMatrixEditor.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2010-09-23 20:09; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html528/TGeoRotationEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoRotationEditor.html
https://root.cern/root/html528/TGeoScale.html:6219,Availability,error,error,6219,"dy,dz) translation. Data members:; Double_t fTranslation[3]. Translations can be added/subtracted.; TGeoTranslation t1;; t1->SetTranslation(-5,10,4);; TGeoTranslation *t2 = new TGeoTranslation(4,3,10);; t2->Subtract(&t1);. 2. Rotations - represent a pure rotation. Data members: Double_t fRotationMatrix[3*3].; Rotations can be defined either by Euler angles, either, by GEANT3 angles :; TGeoRotation *r1 = new TGeoRotation();; r1->SetAngles(phi, theta, psi); // all angles in degrees; This represent the composition of : first a rotation about Z axis with; angle phi, then a rotation with theta about the rotated X axis, and; finally a rotation with psi about the new Z axis. r1->SetAngles(th1,phi1, th2,phi2, th3,phi3); This is a rotation defined in GEANT3 style. Theta and phi are the spherical; angles of each axis of the rotated coordinate system with respect to the; initial one. This construction allows definition of malformed rotations,; e.g. not orthogonal. A check is performed and an error message is issued; in this case. Specific utilities : determinant, inverse. 3. Scale transformations - represent a scale shrinking/enlargement. Data; members :Double_t fScale[3]. Not fully implemented yet. 4. Combined transformations - represent a rotation folowed by a translation.; Data members: Double_t fTranslation[3], TGeoRotation *fRotation.; TGeoRotation *rot = new TGeoRotation(""rot"",10,20,30);; TGeoTranslation trans;. TGeoCombiTrans *c1 = new TGeoCombiTrans(trans, rot);; TGeoCombiTrans *c2 = new TGeoCombiTrans(""somename"",10,20,30,rot). 5. TGeoGenTrans - combined transformations including a scale. Not implemented.; 6. TGeoIdentity - a generic singleton matrix representing a identity transformation; NOTE: identified by the global variable gGeoIdentity. Function Members (Methods); public:. TGeoScale(); TGeoScale(const TGeoScale& other); TGeoScale(Double_t sx, Double_t sy, Double_t sz); TGeoScale(const char* name, Double_t sx, Double_t sy, Double_t sz); virtual~TGeoScale(); voidTOb",MatchSource.WIKI,root/html528/TGeoScale.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoScale.html
https://root.cern/root/html528/TGeoScale.html:8131,Availability,error,error,8131,"ale(const char* name, Double_t sx, Double_t sy, Double_t sz); virtual~TGeoScale(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Int_tTGeoMatrix::GetByteCount() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); voidTGeoMatrix::GetHomogenousMatrix(Double_t* hmat) const; virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; char*TGeoMatrix::GetPointerName() const; virtual const Double_t*GetRotationMatrix() const; virtual const Double_t*GetScale() const; virtual const char*TNamed::Get",MatchSource.WIKI,root/html528/TGeoScale.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoScale.html
https://root.cern/root/html528/TGeoScale.html:8215,Availability,error,error,8215,"oidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Int_tTGeoMatrix::GetByteCount() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); voidTGeoMatrix::GetHomogenousMatrix(Double_t* hmat) const; virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; char*TGeoMatrix::GetPointerName() const; virtual const Double_t*GetRotationMatrix() const; virtual const Double_t*GetScale() const; virtual const char*TNamed::GetTitle() const; virtual const Double_t*GetTranslation() const; virtual UInt_tTObject:",MatchSource.WIKI,root/html528/TGeoScale.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoScale.html
https://root.cern/root/html528/TGeoScale.html:3091,Integrability,interface,interface,3091," 0 1/sz 0; 0 0 0 1 0 0 0 1. where: rij are the 3x3 rotation matrix components,; tx, ty, tz are the translation components; sx, sy, sz are arbitrary scale constants on the eacks axis,. The disadvantage in using this approach is that computation for 4x4 matrices; is expensive. Even combining two translation would become a multiplication; of their corresponding matrices, which is quite an undesired effect. On the; other hand, it is not a good idea to store a translation as a block of 16; numbers. We have therefore chosen to implement each basic transformation type; as a class deriving from the same basic abstract class and handling its specific; data and point/vector transformation algorithms. /*. */. The base class TGeoMatrix defines abstract metods for:. - translation, rotation and scale getters. Every derived class stores only; its specific data, e.g. a translation stores an array of 3 doubles and a; rotation an array of 9. However, asking which is the rotation array of a; TGeoTranslation through the base TGeoMatrix interface is a legal operation.; The answer in this case is a pointer to a global constant array representing; an identity rotation.; Double_t *TGeoMatrix::GetTranslation(); Double_t *TGeoMatrix::GetRotation(); Double_t *TGeoMatrix::GetScale(). - MasterToLocal() and LocalToMaster() point and vector transformations :; void TGeoMatrix::MasterToLocal(const Double_t *master, Double_t *local); void TGeoMatrix::LocalToMaster(const Double_t *local, Double_t *master); void TGeoMatrix::MasterToLocalVect(const Double_t *master, Double_t *local); void TGeoMatrix::LocalToMasterVect(const Double_t *local, Double_t *master); These allow correct conversion also for reflections.; - Transformation type getters :; Bool_t TGeoMatrix::IsIdentity(); Bool_t TGeoMatrix::IsTranslation(); Bool_t TGeoMatrix::IsRotation(); Bool_t TGeoMatrix::IsScale(); Bool_t TGeoMatrix::IsCombi() (translation + rotation); Bool_t TGeoMatrix::IsGeneral() (translation + rotation + scale). Combinatio",MatchSource.WIKI,root/html528/TGeoScale.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoScale.html
https://root.cern/root/html528/TGeoScale.html:6225,Integrability,message,message,6225,"dy,dz) translation. Data members:; Double_t fTranslation[3]. Translations can be added/subtracted.; TGeoTranslation t1;; t1->SetTranslation(-5,10,4);; TGeoTranslation *t2 = new TGeoTranslation(4,3,10);; t2->Subtract(&t1);. 2. Rotations - represent a pure rotation. Data members: Double_t fRotationMatrix[3*3].; Rotations can be defined either by Euler angles, either, by GEANT3 angles :; TGeoRotation *r1 = new TGeoRotation();; r1->SetAngles(phi, theta, psi); // all angles in degrees; This represent the composition of : first a rotation about Z axis with; angle phi, then a rotation with theta about the rotated X axis, and; finally a rotation with psi about the new Z axis. r1->SetAngles(th1,phi1, th2,phi2, th3,phi3); This is a rotation defined in GEANT3 style. Theta and phi are the spherical; angles of each axis of the rotated coordinate system with respect to the; initial one. This construction allows definition of malformed rotations,; e.g. not orthogonal. A check is performed and an error message is issued; in this case. Specific utilities : determinant, inverse. 3. Scale transformations - represent a scale shrinking/enlargement. Data; members :Double_t fScale[3]. Not fully implemented yet. 4. Combined transformations - represent a rotation folowed by a translation.; Data members: Double_t fTranslation[3], TGeoRotation *fRotation.; TGeoRotation *rot = new TGeoRotation(""rot"",10,20,30);; TGeoTranslation trans;. TGeoCombiTrans *c1 = new TGeoCombiTrans(trans, rot);; TGeoCombiTrans *c2 = new TGeoCombiTrans(""somename"",10,20,30,rot). 5. TGeoGenTrans - combined transformations including a scale. Not implemented.; 6. TGeoIdentity - a generic singleton matrix representing a identity transformation; NOTE: identified by the global variable gGeoIdentity. Function Members (Methods); public:. TGeoScale(); TGeoScale(const TGeoScale& other); TGeoScale(Double_t sx, Double_t sy, Double_t sz); TGeoScale(const char* name, Double_t sx, Double_t sy, Double_t sz); virtual~TGeoScale(); voidTOb",MatchSource.WIKI,root/html528/TGeoScale.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoScale.html
https://root.cern/root/html528/TGeoScale.html:6970,Modifiability,variab,variable,6970,"th2,phi2, th3,phi3); This is a rotation defined in GEANT3 style. Theta and phi are the spherical; angles of each axis of the rotated coordinate system with respect to the; initial one. This construction allows definition of malformed rotations,; e.g. not orthogonal. A check is performed and an error message is issued; in this case. Specific utilities : determinant, inverse. 3. Scale transformations - represent a scale shrinking/enlargement. Data; members :Double_t fScale[3]. Not fully implemented yet. 4. Combined transformations - represent a rotation folowed by a translation.; Data members: Double_t fTranslation[3], TGeoRotation *fRotation.; TGeoRotation *rot = new TGeoRotation(""rot"",10,20,30);; TGeoTranslation trans;. TGeoCombiTrans *c1 = new TGeoCombiTrans(trans, rot);; TGeoCombiTrans *c2 = new TGeoCombiTrans(""somename"",10,20,30,rot). 5. TGeoGenTrans - combined transformations including a scale. Not implemented.; 6. TGeoIdentity - a generic singleton matrix representing a identity transformation; NOTE: identified by the global variable gGeoIdentity. Function Members (Methods); public:. TGeoScale(); TGeoScale(const TGeoScale& other); TGeoScale(Double_t sx, Double_t sy, Double_t sz); TGeoScale(const char* name, Double_t sx, Double_t sy, Double_t sz); virtual~TGeoScale(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option =",MatchSource.WIKI,root/html528/TGeoScale.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoScale.html
https://root.cern/root/html528/TGeoScale.html:475,Performance,optimiz,optimize,475,". TGeoScale. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GEOM; » GEOM; » TGeoScale. class TGeoScale: public TGeoMatrix. Geometrical transformation package. All geometrical transformations handled by the modeller are provided as a; built-in package. This was designed to minimize memory requirements and; optimize performance of point/vector master-to-local and local-to-master; computation. We need to have in mind that a transformation in TGeo has 2; major use-cases. The first one is for defining the placement of a volume; with respect to its container reference frame. This frame will be called; 'master' and the frame of the positioned volume - 'local'. If T is a; transformation used for positioning volume daughters, then:. MASTER = T * LOCAL. Therefore a local-to-master conversion will be performed by using T, while; a master-to-local by using its inverse. The second use case is the computation; of the global transformation of a given object in the geometry. Since the; geometry is built as 'volumes-inside-volumes', this global transformation; represent the pile-up of all local transformations in the corresponding; branch. The conversion from the global reference frame and the given object; is also called master-to-local, but it is handled by the manager class.; A general homogenous transformation is defined as a 4x4 matrix embeeding; a rotation, a translation and a scale. The advantage of this description; is that each basic transformation can be represented as a homogenous matrix,; composition being performed as simple matrix multiplication.; Rotation: Inverse rotation:; r11 r12 r13 0 r11 r21 r31 0; r21 r22 r23 0 r12 r22 r32 0; r31 r32 r33 0 r13 r23 r33 0; 0 0 0 1 0 0 0 1. Translation: Inverse translation:; 1 0 0 tx 1 0 0 -tx; 0 1 0 ty 0 1 0 -ty; 0 0 1 tz 0 0 1 -tz; 0 0 0 1 0 0 0 1. Scale: Inverse sc",MatchSource.WIKI,root/html528/TGeoScale.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoScale.html
https://root.cern/root/html528/TGeoScale.html:484,Performance,perform,performance,484,". TGeoScale. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GEOM; » GEOM; » TGeoScale. class TGeoScale: public TGeoMatrix. Geometrical transformation package. All geometrical transformations handled by the modeller are provided as a; built-in package. This was designed to minimize memory requirements and; optimize performance of point/vector master-to-local and local-to-master; computation. We need to have in mind that a transformation in TGeo has 2; major use-cases. The first one is for defining the placement of a volume; with respect to its container reference frame. This frame will be called; 'master' and the frame of the positioned volume - 'local'. If T is a; transformation used for positioning volume daughters, then:. MASTER = T * LOCAL. Therefore a local-to-master conversion will be performed by using T, while; a master-to-local by using its inverse. The second use case is the computation; of the global transformation of a given object in the geometry. Since the; geometry is built as 'volumes-inside-volumes', this global transformation; represent the pile-up of all local transformations in the corresponding; branch. The conversion from the global reference frame and the given object; is also called master-to-local, but it is handled by the manager class.; A general homogenous transformation is defined as a 4x4 matrix embeeding; a rotation, a translation and a scale. The advantage of this description; is that each basic transformation can be represented as a homogenous matrix,; composition being performed as simple matrix multiplication.; Rotation: Inverse rotation:; r11 r12 r13 0 r11 r21 r31 0; r21 r22 r23 0 r12 r22 r32 0; r31 r32 r33 0 r13 r23 r33 0; 0 0 0 1 0 0 0 1. Translation: Inverse translation:; 1 0 0 tx 1 0 0 -tx; 0 1 0 ty 0 1 0 -ty; 0 0 1 tz 0 0 1 -tz; 0 0 0 1 0 0 0 1. Scale: Inverse sc",MatchSource.WIKI,root/html528/TGeoScale.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoScale.html
https://root.cern/root/html528/TGeoScale.html:969,Performance,perform,performed,969,". TGeoScale. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GEOM; » GEOM; » TGeoScale. class TGeoScale: public TGeoMatrix. Geometrical transformation package. All geometrical transformations handled by the modeller are provided as a; built-in package. This was designed to minimize memory requirements and; optimize performance of point/vector master-to-local and local-to-master; computation. We need to have in mind that a transformation in TGeo has 2; major use-cases. The first one is for defining the placement of a volume; with respect to its container reference frame. This frame will be called; 'master' and the frame of the positioned volume - 'local'. If T is a; transformation used for positioning volume daughters, then:. MASTER = T * LOCAL. Therefore a local-to-master conversion will be performed by using T, while; a master-to-local by using its inverse. The second use case is the computation; of the global transformation of a given object in the geometry. Since the; geometry is built as 'volumes-inside-volumes', this global transformation; represent the pile-up of all local transformations in the corresponding; branch. The conversion from the global reference frame and the given object; is also called master-to-local, but it is handled by the manager class.; A general homogenous transformation is defined as a 4x4 matrix embeeding; a rotation, a translation and a scale. The advantage of this description; is that each basic transformation can be represented as a homogenous matrix,; composition being performed as simple matrix multiplication.; Rotation: Inverse rotation:; r11 r12 r13 0 r11 r21 r31 0; r21 r22 r23 0 r12 r22 r32 0; r31 r32 r33 0 r13 r23 r33 0; 0 0 0 1 0 0 0 1. Translation: Inverse translation:; 1 0 0 tx 1 0 0 -tx; 0 1 0 ty 0 1 0 -ty; 0 0 1 tz 0 0 1 -tz; 0 0 0 1 0 0 0 1. Scale: Inverse sc",MatchSource.WIKI,root/html528/TGeoScale.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoScale.html
https://root.cern/root/html528/TGeoScale.html:1695,Performance,perform,performed,1695,"one is for defining the placement of a volume; with respect to its container reference frame. This frame will be called; 'master' and the frame of the positioned volume - 'local'. If T is a; transformation used for positioning volume daughters, then:. MASTER = T * LOCAL. Therefore a local-to-master conversion will be performed by using T, while; a master-to-local by using its inverse. The second use case is the computation; of the global transformation of a given object in the geometry. Since the; geometry is built as 'volumes-inside-volumes', this global transformation; represent the pile-up of all local transformations in the corresponding; branch. The conversion from the global reference frame and the given object; is also called master-to-local, but it is handled by the manager class.; A general homogenous transformation is defined as a 4x4 matrix embeeding; a rotation, a translation and a scale. The advantage of this description; is that each basic transformation can be represented as a homogenous matrix,; composition being performed as simple matrix multiplication.; Rotation: Inverse rotation:; r11 r12 r13 0 r11 r21 r31 0; r21 r22 r23 0 r12 r22 r32 0; r31 r32 r33 0 r13 r23 r33 0; 0 0 0 1 0 0 0 1. Translation: Inverse translation:; 1 0 0 tx 1 0 0 -tx; 0 1 0 ty 0 1 0 -ty; 0 0 1 tz 0 0 1 -tz; 0 0 0 1 0 0 0 1. Scale: Inverse scale:; sx 0 0 0 1/sx 0 0 0; 0 sy 0 0 0 1/sy 0 0; 0 0 sz 0 0 0 1/sz 0; 0 0 0 1 0 0 0 1. where: rij are the 3x3 rotation matrix components,; tx, ty, tz are the translation components; sx, sy, sz are arbitrary scale constants on the eacks axis,. The disadvantage in using this approach is that computation for 4x4 matrices; is expensive. Even combining two translation would become a multiplication; of their corresponding matrices, which is quite an undesired effect. On the; other hand, it is not a good idea to store a translation as a block of 16; numbers. We have therefore chosen to implement each basic transformation type; as a class deriving fr",MatchSource.WIKI,root/html528/TGeoScale.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoScale.html
https://root.cern/root/html528/TGeoScale.html:6202,Performance,perform,performed,6202,"dy,dz) translation. Data members:; Double_t fTranslation[3]. Translations can be added/subtracted.; TGeoTranslation t1;; t1->SetTranslation(-5,10,4);; TGeoTranslation *t2 = new TGeoTranslation(4,3,10);; t2->Subtract(&t1);. 2. Rotations - represent a pure rotation. Data members: Double_t fRotationMatrix[3*3].; Rotations can be defined either by Euler angles, either, by GEANT3 angles :; TGeoRotation *r1 = new TGeoRotation();; r1->SetAngles(phi, theta, psi); // all angles in degrees; This represent the composition of : first a rotation about Z axis with; angle phi, then a rotation with theta about the rotated X axis, and; finally a rotation with psi about the new Z axis. r1->SetAngles(th1,phi1, th2,phi2, th3,phi3); This is a rotation defined in GEANT3 style. Theta and phi are the spherical; angles of each axis of the rotated coordinate system with respect to the; initial one. This construction allows definition of malformed rotations,; e.g. not orthogonal. A check is performed and an error message is issued; in this case. Specific utilities : determinant, inverse. 3. Scale transformations - represent a scale shrinking/enlargement. Data; members :Double_t fScale[3]. Not fully implemented yet. 4. Combined transformations - represent a rotation folowed by a translation.; Data members: Double_t fTranslation[3], TGeoRotation *fRotation.; TGeoRotation *rot = new TGeoRotation(""rot"",10,20,30);; TGeoTranslation trans;. TGeoCombiTrans *c1 = new TGeoCombiTrans(trans, rot);; TGeoCombiTrans *c2 = new TGeoCombiTrans(""somename"",10,20,30,rot). 5. TGeoGenTrans - combined transformations including a scale. Not implemented.; 6. TGeoIdentity - a generic singleton matrix representing a identity transformation; NOTE: identified by the global variable gGeoIdentity. Function Members (Methods); public:. TGeoScale(); TGeoScale(const TGeoScale& other); TGeoScale(Double_t sx, Double_t sy, Double_t sz); TGeoScale(const char* name, Double_t sx, Double_t sy, Double_t sz); virtual~TGeoScale(); voidTOb",MatchSource.WIKI,root/html528/TGeoScale.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoScale.html
https://root.cern/root/html528/TGeoScale.html:15153,Performance,perform,perform,15153,"; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTNamed::fNameobject identifier; Double_tfScale[3]scale (x, y, z); TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoScale(); default constructor. TGeoScale(const TGeoScale& other); Copy constructor. TGeoScale(Double_t sx, Double_t sy, Double_t sz); default constructor. TGeoScale(const char* name, Double_t sx, Double_t sy, Double_t sz); default constructor. ~TGeoScale(); destructor. TGeoMatrix& Inverse() const; Return a temporary inverse of this. void SetScale(Double_t sx, Double_t sy, Double_t sz); scale setter. void LocalToMaster(const Double_t* local, Double_t* master) const; Convert a local point to the master frame. Double_t LocalToMaster(Double_t dist, const Double_t* dir = 0) const; Convert the local distance along unit vector DIR to master frame. If DIR; is not specified perform a conversion such as the returned distance is the; the minimum for all possible directions. TGeoMatrix * MakeClone() const; Make a clone of this matrix. void MasterToLocal(const Double_t* master, Double_t* local) const; Convert a global point to local frame. Double_t MasterToLocal(Double_t dist, const Double_t* dir = 0) const; Convert the distance along unit vector DIR to local frame. If DIR; is not specified perform a conversion such as the returned distance is the; the minimum for all possible directions. TGeoMatrix& operator=(const TGeoScale& ); Preventing warnings with -Weffc++ in GCC since the behaviour of operator * was chosen so by design. const Double_t * GetTranslation() const. const Double_t * GetRotationMatrix() const. const Double_t * GetScale() const. void LocalToMasterVect(const Double_t* local, Double_t* master) const. void MasterToLocalVect(const Double_t* master, Double_t* local) const. void ReflectX(Bool_t , Bool_t ). void ReflectY(Bool_t , Bool_t ). void ReflectZ(Bool_t , Bool_t ). » Author: And",MatchSource.WIKI,root/html528/TGeoScale.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoScale.html
https://root.cern/root/html528/TGeoScale.html:15574,Performance,perform,perform,15574,"er); Copy constructor. TGeoScale(Double_t sx, Double_t sy, Double_t sz); default constructor. TGeoScale(const char* name, Double_t sx, Double_t sy, Double_t sz); default constructor. ~TGeoScale(); destructor. TGeoMatrix& Inverse() const; Return a temporary inverse of this. void SetScale(Double_t sx, Double_t sy, Double_t sz); scale setter. void LocalToMaster(const Double_t* local, Double_t* master) const; Convert a local point to the master frame. Double_t LocalToMaster(Double_t dist, const Double_t* dir = 0) const; Convert the local distance along unit vector DIR to master frame. If DIR; is not specified perform a conversion such as the returned distance is the; the minimum for all possible directions. TGeoMatrix * MakeClone() const; Make a clone of this matrix. void MasterToLocal(const Double_t* master, Double_t* local) const; Convert a global point to local frame. Double_t MasterToLocal(Double_t dist, const Double_t* dir = 0) const; Convert the distance along unit vector DIR to local frame. If DIR; is not specified perform a conversion such as the returned distance is the; the minimum for all possible directions. TGeoMatrix& operator=(const TGeoScale& ); Preventing warnings with -Weffc++ in GCC since the behaviour of operator * was chosen so by design. const Double_t * GetTranslation() const. const Double_t * GetRotationMatrix() const. const Double_t * GetScale() const. void LocalToMasterVect(const Double_t* local, Double_t* master) const. void MasterToLocalVect(const Double_t* master, Double_t* local) const. void ReflectX(Bool_t , Bool_t ). void ReflectY(Bool_t , Bool_t ). void ReflectZ(Bool_t , Bool_t ). » Author: Andrei Gheata 25/10/01 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/geom:$Id: TGeoMatrix.h 34744 2010-08-07 06:16:36Z brun $ » Last generated: 2010-11-08 19:55; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html528/TGeoScale.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoScale.html
https://root.cern/root/html528/TGeoScale.html:1708,Usability,simpl,simple,1708,"one is for defining the placement of a volume; with respect to its container reference frame. This frame will be called; 'master' and the frame of the positioned volume - 'local'. If T is a; transformation used for positioning volume daughters, then:. MASTER = T * LOCAL. Therefore a local-to-master conversion will be performed by using T, while; a master-to-local by using its inverse. The second use case is the computation; of the global transformation of a given object in the geometry. Since the; geometry is built as 'volumes-inside-volumes', this global transformation; represent the pile-up of all local transformations in the corresponding; branch. The conversion from the global reference frame and the given object; is also called master-to-local, but it is handled by the manager class.; A general homogenous transformation is defined as a 4x4 matrix embeeding; a rotation, a translation and a scale. The advantage of this description; is that each basic transformation can be represented as a homogenous matrix,; composition being performed as simple matrix multiplication.; Rotation: Inverse rotation:; r11 r12 r13 0 r11 r21 r31 0; r21 r22 r23 0 r12 r22 r32 0; r31 r32 r33 0 r13 r23 r33 0; 0 0 0 1 0 0 0 1. Translation: Inverse translation:; 1 0 0 tx 1 0 0 -tx; 0 1 0 ty 0 1 0 -ty; 0 0 1 tz 0 0 1 -tz; 0 0 0 1 0 0 0 1. Scale: Inverse scale:; sx 0 0 0 1/sx 0 0 0; 0 sy 0 0 0 1/sy 0 0; 0 0 sz 0 0 0 1/sz 0; 0 0 0 1 0 0 0 1. where: rij are the 3x3 rotation matrix components,; tx, ty, tz are the translation components; sx, sy, sz are arbitrary scale constants on the eacks axis,. The disadvantage in using this approach is that computation for 4x4 matrices; is expensive. Even combining two translation would become a multiplication; of their corresponding matrices, which is quite an undesired effect. On the; other hand, it is not a good idea to store a translation as a block of 16; numbers. We have therefore chosen to implement each basic transformation type; as a class deriving fr",MatchSource.WIKI,root/html528/TGeoScale.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoScale.html
https://root.cern/root/html528/TGeoScaledShape.html:2617,Availability,error,error,2617,"ive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const char*TGeoBBox::GetAxisName(Int_t iaxis) const; virtual Double_tTGeoBBox::GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; virtual voidTGeoBBox::GetBoundingCylinder(Double_t* param) const; virtual const TBuffer3D&GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; virtual Int_tTGeoBBox::GetByteCount() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_tTGeoBBox::GetDX() const; virtual Double_tTGeoBBox::GetDY() const; virtual Double_tTGeoBBox::GetDZ() const; virtual Double_tTGeoBBox::GetFacetArea(In",MatchSource.WIKI,root/html528/TGeoScaledShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoScaledShape.html
https://root.cern/root/html528/TGeoScaledShape.html:2701,Availability,error,error,2701,"ir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const char*TGeoBBox::GetAxisName(Int_t iaxis) const; virtual Double_tTGeoBBox::GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; virtual voidTGeoBBox::GetBoundingCylinder(Double_t* param) const; virtual const TBuffer3D&GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; virtual Int_tTGeoBBox::GetByteCount() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_tTGeoBBox::GetDX() const; virtual Double_tTGeoBBox::GetDY() const; virtual Double_tTGeoBBox::GetDZ() const; virtual Double_tTGeoBBox::GetFacetArea(Int_t index = 0) const; virtual Int_tTGeoBBox::GetFittingBox(const TGeoBBox* parambox,",MatchSource.WIKI,root/html528/TGeoScaledShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoScaledShape.html
https://root.cern/root/html528/TGeoScaledShape.html:1768,Safety,safe,safe,1768,"ping(const TGeoBBox* box1, const TGeoMatrix* mat1, const TGeoBBox* box2, const TGeoMatrix* mat2); static Double_tTGeoShape::Big(); virtual voidTObject::Browse(TBrowser* b); virtual Double_tCapacity() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); virtual Bool_tContains(Double_t* point) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(Double_t* point, Double_t* dir) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px,",MatchSource.WIKI,root/html528/TGeoScaledShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoScaledShape.html
https://root.cern/root/html528/TGeoScaledShape.html:1909,Safety,safe,safe,1909,"idTObject::Browse(TBrowser* b); virtual Double_tCapacity() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); virtual Bool_tContains(Double_t* point) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(Double_t* point, Double_t* dir) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual ",MatchSource.WIKI,root/html528/TGeoScaledShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoScaledShape.html
https://root.cern/root/html528/TGeoScaledShape.html:12037,Safety,safe,safe,12037,"r to an existing shape; UInt_tTGeoShape::fShapeBitsshape bits; Int_tTGeoShape::fShapeIdshape id; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoScaledShape(); Default constructor. TGeoScaledShape(const char* name, TGeoShape* shape, TGeoScale* scale); Constructor. TGeoScaledShape(TGeoShape* shape, TGeoScale* scale); Constructor. ~TGeoScaledShape(); destructor. Double_t Capacity() const; Computes capacity of this shape [length^3]. void ComputeBBox(); Compute bounding box of the scaled shape. void ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. Bool_t Contains(Double_t* point) const; Test if point is inside the scaled shape. Int_t DistancetoPrimitive(Int_t px, Int_t py); compute closest distance from point px,py to each vertex. Should not be called. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the scaled shape. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from outside point to surface of the scaled shape. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); Cannot divide assemblies. const TBuffer3D & GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; Fills a static 3D buffer and returns a reference. TGeoShape * GetMakeRuntimeShape(TGeoShape* mother, TGeoMatrix* mat) const; in case shape has some negative parameters, these has to be computed; in order to fit the mother. void GetMeshNumbers(Int_t& nvert, Int_t& nsegs, Int_t& npols) const; Returns numbers of vertices, segments and polygons composing the shape mesh. void InspectShape() const; print shape parameters. Bool_t IsReflected() const; Check if the scale transformat",MatchSource.WIKI,root/html528/TGeoScaledShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoScaledShape.html
https://root.cern/root/html528/TGeoScaledShape.html:12238,Safety,safe,safe,12238,"nction documentation; TGeoScaledShape(); Default constructor. TGeoScaledShape(const char* name, TGeoShape* shape, TGeoScale* scale); Constructor. TGeoScaledShape(TGeoShape* shape, TGeoScale* scale); Constructor. ~TGeoScaledShape(); destructor. Double_t Capacity() const; Computes capacity of this shape [length^3]. void ComputeBBox(); Compute bounding box of the scaled shape. void ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. Bool_t Contains(Double_t* point) const; Test if point is inside the scaled shape. Int_t DistancetoPrimitive(Int_t px, Int_t py); compute closest distance from point px,py to each vertex. Should not be called. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the scaled shape. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from outside point to surface of the scaled shape. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); Cannot divide assemblies. const TBuffer3D & GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; Fills a static 3D buffer and returns a reference. TGeoShape * GetMakeRuntimeShape(TGeoShape* mother, TGeoMatrix* mat) const; in case shape has some negative parameters, these has to be computed; in order to fit the mother. void GetMeshNumbers(Int_t& nvert, Int_t& nsegs, Int_t& npols) const; Returns numbers of vertices, segments and polygons composing the shape mesh. void InspectShape() const; print shape parameters. Bool_t IsReflected() const; Check if the scale transformation is a reflection. TBuffer3D * MakeBuffer3D() const; Creates a TBuffer3D describing *this* shape.; Coordinates are in local reference frame. TGeoShape * MakeScaledShape(const char* name, TGeoShape* s",MatchSource.WIKI,root/html528/TGeoScaledShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoScaledShape.html
https://root.cern/root/html528/TGeoShape.html:6651,Availability,avail,available,6651,"outwards or inwards; shape respectively. Normal components are statically stored by shape class,; so it has to be copied after retreival in a different array. Dividing shapes. Shapes can generally be divided along a given axis. Supported axis are; X, Y, Z, Rxy, Phi, Rxyz. A given shape cannot be divided however on any axis.; The general rule is that that divisions are possible on whatever axis that; produces still known shapes as slices. The division of shapes should not be; performed by TGeoShape::Divide() calls, but rather by TGeoVolume::Divide().; The algorithm for dividing a specific shape is known by the shape object, but; is always invoked in a generic way from the volume level. Details on how to; do that can be found in TGeoVolume class. One can see how all division options; are interpreted and which is their result inside specific shape classes. /*. */. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TGeoShape(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); static Double_tBig(); virtual voidTObject::Browse(TBrowser* b); virtual Double_tCapacity() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tComputeEpsMch(); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); virtual Bool_tContains(Double_t* point) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tCouldBeCrossed(Double_t* point, Double_t* dir) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Doub",MatchSource.WIKI,root/html528/TGeoShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoShape.html
https://root.cern/root/html528/TGeoShape.html:8500,Availability,error,error,8500,"U ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tDistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidDraw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tEpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const char*GetAxisName(Int_t iaxis) const; virtual Double_tGetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; virtual voidGetBoundingCylinder(Double_t* param) const; virtual const TBuffer3D&GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; virtual Int_tGetByteCount() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Int_tGetFittingBox(const TGeoBBox* parambox, TGeoMatrix* mat, Double_t& dx, Double_t& dy, Double_t& dz) const; virtual const char*TObject::GetIconName() const; Int_tGetId() const; virtual TGeoShape*GetMakeRu",MatchSource.WIKI,root/html528/TGeoShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoShape.html
https://root.cern/root/html528/TGeoShape.html:8584,Availability,error,error,8584,"side(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tDistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidDraw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tEpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const char*GetAxisName(Int_t iaxis) const; virtual Double_tGetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; virtual voidGetBoundingCylinder(Double_t* param) const; virtual const TBuffer3D&GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; virtual Int_tGetByteCount() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Int_tGetFittingBox(const TGeoBBox* parambox, TGeoMatrix* mat, Double_t& dx, Double_t& dy, Double_t& dz) const; virtual const char*TObject::GetIconName() const; Int_tGetId() const; virtual TGeoShape*GetMakeRuntimeShape(TGeoShape* mother, TGeoMatrix* mat) const; virtual voidGetMeshNumbers(Int",MatchSource.WIKI,root/html528/TGeoShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoShape.html
https://root.cern/root/html528/TGeoShape.html:15680,Availability,error,error,15680,"(); voidSetOnBoundary(Bool_t); voidTransformPoints(Double_t* points, UInt_t NbPoints) const. Data Members; public:. enum EShapeType { kBitMask32; kGeoNoShape; kGeoBad; kGeoRSeg; kGeoPhiSeg; kGeoThetaSeg; kGeoVisX; kGeoVisY; kGeoVisZ; kGeoRunTimeShape; kGeoInvalidShape; kGeoTorus; kGeoBox; kGeoPara; kGeoSph; kGeoTube; kGeoTubeSeg; kGeoCone; kGeoConeSeg; kGeoPcon; kGeoPgon; kGeoArb8; kGeoEltu; kGeoTrap; kGeoCtub; kGeoTrd1; kGeoTrd2; kGeoComb; kGeoClosedShape; kGeoXtru; kGeoParaboloid; kGeoHalfSpace; kGeoHype; kGeoSavePrimitive; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTNamed::fNameobject identifier; UInt_tfShapeBitsshape bits; Int_tfShapeIdshape id; TStringTNamed::fTitleobject title. private:. static Double_tfgEpsMchMachine round-off error; static TGeoMatrix*fgTransformcurrent transformation matrix that applies to shape. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~TGeoShape(); Destructor. Double_t ComputeEpsMch(); Compute machine round-off double precision error as the smallest number that; if added to 1.0 is different than 1.0. Double_t EpsMch(); static function returning the machine round-off error. const char * GetName() const; Get the shape name. Int_t ShapeDistancetoPrimitive(Int_t numpoints, Int_t px, Int_t py) const; Returns distance to shape primitive mesh. Bool_t IsCloseToPhi(Double_t epsil, Double_t* point, Double_t c1, Double_t s1, Double_t c2, Double_t s2); True if point is closer than epsil to one of the phi planes defined by c1,s1 or c2,s2. Bool_t IsInPhiRange(Double_t* point, Double_t phi1, Double_t phi2); Static method to check if a point is in the phi range (phi1, phi2) [degrees]. Bool_t IsCrossingSemiplane(Double_t* point, Double_t* dir, Double_t cphi, Double_t sphi, Doubl",MatchSource.WIKI,root/html528/TGeoShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoShape.html
https://root.cern/root/html528/TGeoShape.html:15955,Availability,error,error,15955,"TimeShape; kGeoInvalidShape; kGeoTorus; kGeoBox; kGeoPara; kGeoSph; kGeoTube; kGeoTubeSeg; kGeoCone; kGeoConeSeg; kGeoPcon; kGeoPgon; kGeoArb8; kGeoEltu; kGeoTrap; kGeoCtub; kGeoTrd1; kGeoTrd2; kGeoComb; kGeoClosedShape; kGeoXtru; kGeoParaboloid; kGeoHalfSpace; kGeoHype; kGeoSavePrimitive; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTNamed::fNameobject identifier; UInt_tfShapeBitsshape bits; Int_tfShapeIdshape id; TStringTNamed::fTitleobject title. private:. static Double_tfgEpsMchMachine round-off error; static TGeoMatrix*fgTransformcurrent transformation matrix that applies to shape. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~TGeoShape(); Destructor. Double_t ComputeEpsMch(); Compute machine round-off double precision error as the smallest number that; if added to 1.0 is different than 1.0. Double_t EpsMch(); static function returning the machine round-off error. const char * GetName() const; Get the shape name. Int_t ShapeDistancetoPrimitive(Int_t numpoints, Int_t px, Int_t py) const; Returns distance to shape primitive mesh. Bool_t IsCloseToPhi(Double_t epsil, Double_t* point, Double_t c1, Double_t s1, Double_t c2, Double_t s2); True if point is closer than epsil to one of the phi planes defined by c1,s1 or c2,s2. Bool_t IsInPhiRange(Double_t* point, Double_t phi1, Double_t phi2); Static method to check if a point is in the phi range (phi1, phi2) [degrees]. Bool_t IsCrossingSemiplane(Double_t* point, Double_t* dir, Double_t cphi, Double_t sphi, Double_t& snext, Double_t& rxy); Compute distance from POINT to semiplane defined by PHI angle along DIR. Computes; also radius at crossing point. This might be negative in case the crossing is; on the other side of the semiplane. Bool_t IsSameWit",MatchSource.WIKI,root/html528/TGeoShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoShape.html
https://root.cern/root/html528/TGeoShape.html:16096,Availability,error,error,16096,"n; kGeoPgon; kGeoArb8; kGeoEltu; kGeoTrap; kGeoCtub; kGeoTrd1; kGeoTrd2; kGeoComb; kGeoClosedShape; kGeoXtru; kGeoParaboloid; kGeoHalfSpace; kGeoHype; kGeoSavePrimitive; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTNamed::fNameobject identifier; UInt_tfShapeBitsshape bits; Int_tfShapeIdshape id; TStringTNamed::fTitleobject title. private:. static Double_tfgEpsMchMachine round-off error; static TGeoMatrix*fgTransformcurrent transformation matrix that applies to shape. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~TGeoShape(); Destructor. Double_t ComputeEpsMch(); Compute machine round-off double precision error as the smallest number that; if added to 1.0 is different than 1.0. Double_t EpsMch(); static function returning the machine round-off error. const char * GetName() const; Get the shape name. Int_t ShapeDistancetoPrimitive(Int_t numpoints, Int_t px, Int_t py) const; Returns distance to shape primitive mesh. Bool_t IsCloseToPhi(Double_t epsil, Double_t* point, Double_t c1, Double_t s1, Double_t c2, Double_t s2); True if point is closer than epsil to one of the phi planes defined by c1,s1 or c2,s2. Bool_t IsInPhiRange(Double_t* point, Double_t phi1, Double_t phi2); Static method to check if a point is in the phi range (phi1, phi2) [degrees]. Bool_t IsCrossingSemiplane(Double_t* point, Double_t* dir, Double_t cphi, Double_t sphi, Double_t& snext, Double_t& rxy); Compute distance from POINT to semiplane defined by PHI angle along DIR. Computes; also radius at crossing point. This might be negative in case the crossing is; on the other side of the semiplane. Bool_t IsSameWithinTolerance(Double_t a, Double_t b); Check if two numbers differ with less than a tolerance. Bool_t IsSegCrossing(Doubl",MatchSource.WIKI,root/html528/TGeoShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoShape.html
https://root.cern/root/html528/TGeoShape.html:17028,Availability,toler,tolerance,17028," that; if added to 1.0 is different than 1.0. Double_t EpsMch(); static function returning the machine round-off error. const char * GetName() const; Get the shape name. Int_t ShapeDistancetoPrimitive(Int_t numpoints, Int_t px, Int_t py) const; Returns distance to shape primitive mesh. Bool_t IsCloseToPhi(Double_t epsil, Double_t* point, Double_t c1, Double_t s1, Double_t c2, Double_t s2); True if point is closer than epsil to one of the phi planes defined by c1,s1 or c2,s2. Bool_t IsInPhiRange(Double_t* point, Double_t phi1, Double_t phi2); Static method to check if a point is in the phi range (phi1, phi2) [degrees]. Bool_t IsCrossingSemiplane(Double_t* point, Double_t* dir, Double_t cphi, Double_t sphi, Double_t& snext, Double_t& rxy); Compute distance from POINT to semiplane defined by PHI angle along DIR. Computes; also radius at crossing point. This might be negative in case the crossing is; on the other side of the semiplane. Bool_t IsSameWithinTolerance(Double_t a, Double_t b); Check if two numbers differ with less than a tolerance. Bool_t IsSegCrossing(Double_t x1, Double_t y1, Double_t x2, Double_t y2, Double_t x3, Double_t y3, Double_t x4, Double_t y4); Check if segments (A,B) and (C,D) are crossing,; where: A(x1,y1), B(x2,y2), C(x3,y3), D(x4,y4). Double_t DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); compute distance from point (inside phi) to both phi planes. Return minimum. void NormalPhi(Double_t* point, Double_t* dir, Double_t* norm, Double_t c1, Double_t s1, Double_t c2, Double_t s2); Static method to compute normal to phi planes. Double_t SafetyPhi(Double_t* point, Bool_t in, Double_t phi1, Double_t phi2); Static method to compute safety w.r.t a phi corner defined by cosines/sines; of the angles phi1, phi2. void SetShapeBit(UInt_t f, Bool_t set); Equivalent of TObject::SetBit. TGeoMatrix * GetTransform(); Returns current transformation matrix that applie",MatchSource.WIKI,root/html528/TGeoShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoShape.html
https://root.cern/root/html528/TGeoShape.html:6123,Performance,perform,performed,6123,"uble_t *point[3], Bool_t inside). - compute maximum shift of a point in any direction that does not change its; INSIDE/OUTSIDE state (does not cross shape boundaries). The state of the point; have to be properly supplied. E) Double_t *Normal(Double_t *point[3], Double_t *dir[3], Bool_t inside). - returns director cosines of normal to the crossed shape surface from a; given point towards a direction. One has to specify if the point is inside; or outside shape. According to this, the normal will be outwards or inwards; shape respectively. Normal components are statically stored by shape class,; so it has to be copied after retreival in a different array. Dividing shapes. Shapes can generally be divided along a given axis. Supported axis are; X, Y, Z, Rxy, Phi, Rxyz. A given shape cannot be divided however on any axis.; The general rule is that that divisions are possible on whatever axis that; produces still known shapes as slices. The division of shapes should not be; performed by TGeoShape::Divide() calls, but rather by TGeoVolume::Divide().; The algorithm for dividing a specific shape is known by the shape object, but; is always invoked in a generic way from the volume level. Details on how to; do that can be found in TGeoVolume class. One can see how all division options; are interpreted and which is their result inside specific shape classes. /*. */. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TGeoShape(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); static Double_tBig(); virtual voidTObject::Browse(TBrowser* b); virtual Double_tCapacity() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* ",MatchSource.WIKI,root/html528/TGeoShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoShape.html
https://root.cern/root/html528/TGeoShape.html:941,Safety,safe,safe,941,". TGeoShape. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GEOM; » GEOM; » TGeoShape. class TGeoShape: public TNamed. TGeoShape - Base abstract class for all shapes. Shapes are geometrical objects that provide the basic modelling; functionality. They provide the definition of the LOCAL frame of coordinates,; with respect to which they are defined. Any implementation of a shape deriving; from the base TGeoShape class has to provide methods for :; - finding out if a point defined in their local frame is or not contained; inside;; - computing the distance from a local point to getting outside/entering the; shape, given a known direction;; - computing the maximum distance in any direction from a local point that; does NOT result in a boundary crossing of the shape (safe distance);; - computing the cosines of the normal vector to the crossed shape surface,; given a starting local point and an ongoing direction.; All the features above are globally managed by the modeller in order to; provide navigation functionality. In addition to those, shapes have also to; implement additional specific abstract methods :; - computation of the minimal box bounding the shape, given that this box have; to be aligned with the local coordinates;; - algorithms for dividing the shape along a given axis and producing resulting; divisions volumes. The modeler currently provides a set of 16 basic shapes, which we will call; primitives. It also provides a special class allowing the creation of shapes; made as a result of boolean operations between primitives. These are called; composite shapes and the composition operation can be recursive (composition; of composites). This allows the creation of a quite large number of different; shape topologies and combinations. Shapes are named objects and register themselves to the manager cl",MatchSource.WIKI,root/html528/TGeoShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoShape.html
https://root.cern/root/html528/TGeoShape.html:4062,Safety,safe,safe,4062,"s). Sometimes it is much easier to create a volume having a given shape in one; step, since shapes are not direcly linked in the geometrical tree but volumes; are :. TGeoVolume *vol_box = gGeoManager->MakeBox(""BOX_VOL"", ""mat1"", halfX, halfY, halfZ);; TGeoVolume *vol_tub = gGeoManager->MakeTube(""TUB_VOL"", ""mat2"", rmin, rmax, halfZ);; ... (see MakeXXX() utilities in TGeoManager class). Shape queries. Note that global queries related to a geometry are handled by the manager class.; However, shape-related queries might be sometimes usefull. A) Bool_t TGeoShape::Contains(Double_t *point[3]); - this method returns true if POINT is actually inside the shape. The point; has to be defined in the local shape reference. For instance, for a box having; DX, DY and DZ half-lengths a point will be considered inside if :; | -DX <= point[0] <= DX; | -DY <= point[1] <= DY; | -DZ <= point[2] <= DZ. B) Double_t TGeoShape::DistFromInside(Double_t *point[3], Double_t *dir[3],; Int_t iact, Double_t step, Double_t *safe); - computes the distance to exiting a shape from a given point INSIDE, along; a given direction. The direction is given by its director cosines with respect; to the local shape coordinate system. This method provides additional; information according the value of IACT input parameter :; IACT = 0 => compute only safe distance and fill it at the location; given by SAFE; IACT = 1 => a proposed STEP is supplied. The safe distance is computed; first. If this is bigger than STEP than the proposed step; is approved and returned by the method since it does not; cross the shape boundaries. Otherwise, the distance to; exiting the shape is computed and returned.; IACT = 2 => compute both safe distance and distance to exiting, ignoring; the proposed step.; IACT > 2 => compute only the distance to exiting, ignoring anything else. C) Double_t TGeoShape::DistFromOutside(Double_t *point[3], Double_t *dir[3],; Int_t iact, Double_t step, Double_t *safe); - computes the distance to entering a",MatchSource.WIKI,root/html528/TGeoShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoShape.html
https://root.cern/root/html528/TGeoShape.html:4381,Safety,safe,safe,4381,"in, rmax, halfZ);; ... (see MakeXXX() utilities in TGeoManager class). Shape queries. Note that global queries related to a geometry are handled by the manager class.; However, shape-related queries might be sometimes usefull. A) Bool_t TGeoShape::Contains(Double_t *point[3]); - this method returns true if POINT is actually inside the shape. The point; has to be defined in the local shape reference. For instance, for a box having; DX, DY and DZ half-lengths a point will be considered inside if :; | -DX <= point[0] <= DX; | -DY <= point[1] <= DY; | -DZ <= point[2] <= DZ. B) Double_t TGeoShape::DistFromInside(Double_t *point[3], Double_t *dir[3],; Int_t iact, Double_t step, Double_t *safe); - computes the distance to exiting a shape from a given point INSIDE, along; a given direction. The direction is given by its director cosines with respect; to the local shape coordinate system. This method provides additional; information according the value of IACT input parameter :; IACT = 0 => compute only safe distance and fill it at the location; given by SAFE; IACT = 1 => a proposed STEP is supplied. The safe distance is computed; first. If this is bigger than STEP than the proposed step; is approved and returned by the method since it does not; cross the shape boundaries. Otherwise, the distance to; exiting the shape is computed and returned.; IACT = 2 => compute both safe distance and distance to exiting, ignoring; the proposed step.; IACT > 2 => compute only the distance to exiting, ignoring anything else. C) Double_t TGeoShape::DistFromOutside(Double_t *point[3], Double_t *dir[3],; Int_t iact, Double_t step, Double_t *safe); - computes the distance to entering a shape from a given point OUTSIDE. Acts; in the same way as B). D) Double_t Safety(Double_t *point[3], Bool_t inside). - compute maximum shift of a point in any direction that does not change its; INSIDE/OUTSIDE state (does not cross shape boundaries). The state of the point; have to be properly supplied. E) Doubl",MatchSource.WIKI,root/html528/TGeoShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoShape.html
https://root.cern/root/html528/TGeoShape.html:4484,Safety,safe,safe,4484,"metry are handled by the manager class.; However, shape-related queries might be sometimes usefull. A) Bool_t TGeoShape::Contains(Double_t *point[3]); - this method returns true if POINT is actually inside the shape. The point; has to be defined in the local shape reference. For instance, for a box having; DX, DY and DZ half-lengths a point will be considered inside if :; | -DX <= point[0] <= DX; | -DY <= point[1] <= DY; | -DZ <= point[2] <= DZ. B) Double_t TGeoShape::DistFromInside(Double_t *point[3], Double_t *dir[3],; Int_t iact, Double_t step, Double_t *safe); - computes the distance to exiting a shape from a given point INSIDE, along; a given direction. The direction is given by its director cosines with respect; to the local shape coordinate system. This method provides additional; information according the value of IACT input parameter :; IACT = 0 => compute only safe distance and fill it at the location; given by SAFE; IACT = 1 => a proposed STEP is supplied. The safe distance is computed; first. If this is bigger than STEP than the proposed step; is approved and returned by the method since it does not; cross the shape boundaries. Otherwise, the distance to; exiting the shape is computed and returned.; IACT = 2 => compute both safe distance and distance to exiting, ignoring; the proposed step.; IACT > 2 => compute only the distance to exiting, ignoring anything else. C) Double_t TGeoShape::DistFromOutside(Double_t *point[3], Double_t *dir[3],; Int_t iact, Double_t step, Double_t *safe); - computes the distance to entering a shape from a given point OUTSIDE. Acts; in the same way as B). D) Double_t Safety(Double_t *point[3], Bool_t inside). - compute maximum shift of a point in any direction that does not change its; INSIDE/OUTSIDE state (does not cross shape boundaries). The state of the point; have to be properly supplied. E) Double_t *Normal(Double_t *point[3], Double_t *dir[3], Bool_t inside). - returns director cosines of normal to the crossed shape sur",MatchSource.WIKI,root/html528/TGeoShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoShape.html
https://root.cern/root/html528/TGeoShape.html:4754,Safety,safe,safe,4754,"For instance, for a box having; DX, DY and DZ half-lengths a point will be considered inside if :; | -DX <= point[0] <= DX; | -DY <= point[1] <= DY; | -DZ <= point[2] <= DZ. B) Double_t TGeoShape::DistFromInside(Double_t *point[3], Double_t *dir[3],; Int_t iact, Double_t step, Double_t *safe); - computes the distance to exiting a shape from a given point INSIDE, along; a given direction. The direction is given by its director cosines with respect; to the local shape coordinate system. This method provides additional; information according the value of IACT input parameter :; IACT = 0 => compute only safe distance and fill it at the location; given by SAFE; IACT = 1 => a proposed STEP is supplied. The safe distance is computed; first. If this is bigger than STEP than the proposed step; is approved and returned by the method since it does not; cross the shape boundaries. Otherwise, the distance to; exiting the shape is computed and returned.; IACT = 2 => compute both safe distance and distance to exiting, ignoring; the proposed step.; IACT > 2 => compute only the distance to exiting, ignoring anything else. C) Double_t TGeoShape::DistFromOutside(Double_t *point[3], Double_t *dir[3],; Int_t iact, Double_t step, Double_t *safe); - computes the distance to entering a shape from a given point OUTSIDE. Acts; in the same way as B). D) Double_t Safety(Double_t *point[3], Bool_t inside). - compute maximum shift of a point in any direction that does not change its; INSIDE/OUTSIDE state (does not cross shape boundaries). The state of the point; have to be properly supplied. E) Double_t *Normal(Double_t *point[3], Double_t *dir[3], Bool_t inside). - returns director cosines of normal to the crossed shape surface from a; given point towards a direction. One has to specify if the point is inside; or outside shape. According to this, the normal will be outwards or inwards; shape respectively. Normal components are statically stored by shape class,; so it has to be copied after retr",MatchSource.WIKI,root/html528/TGeoShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoShape.html
https://root.cern/root/html528/TGeoShape.html:5012,Safety,safe,safe,5012,"t *point[3], Double_t *dir[3],; Int_t iact, Double_t step, Double_t *safe); - computes the distance to exiting a shape from a given point INSIDE, along; a given direction. The direction is given by its director cosines with respect; to the local shape coordinate system. This method provides additional; information according the value of IACT input parameter :; IACT = 0 => compute only safe distance and fill it at the location; given by SAFE; IACT = 1 => a proposed STEP is supplied. The safe distance is computed; first. If this is bigger than STEP than the proposed step; is approved and returned by the method since it does not; cross the shape boundaries. Otherwise, the distance to; exiting the shape is computed and returned.; IACT = 2 => compute both safe distance and distance to exiting, ignoring; the proposed step.; IACT > 2 => compute only the distance to exiting, ignoring anything else. C) Double_t TGeoShape::DistFromOutside(Double_t *point[3], Double_t *dir[3],; Int_t iact, Double_t step, Double_t *safe); - computes the distance to entering a shape from a given point OUTSIDE. Acts; in the same way as B). D) Double_t Safety(Double_t *point[3], Bool_t inside). - compute maximum shift of a point in any direction that does not change its; INSIDE/OUTSIDE state (does not cross shape boundaries). The state of the point; have to be properly supplied. E) Double_t *Normal(Double_t *point[3], Double_t *dir[3], Bool_t inside). - returns director cosines of normal to the crossed shape surface from a; given point towards a direction. One has to specify if the point is inside; or outside shape. According to this, the normal will be outwards or inwards; shape respectively. Normal components are statically stored by shape class,; so it has to be copied after retreival in a different array. Dividing shapes. Shapes can generally be divided along a given axis. Supported axis are; X, Y, Z, Rxy, Phi, Rxyz. A given shape cannot be divided however on any axis.; The general rule is tha",MatchSource.WIKI,root/html528/TGeoShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoShape.html
https://root.cern/root/html528/TGeoShape.html:7684,Safety,safe,safe,7684,"irtual~TGeoShape(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); static Double_tBig(); virtual voidTObject::Browse(TBrowser* b); virtual Double_tCapacity() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tComputeEpsMch(); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); virtual Bool_tContains(Double_t* point) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tCouldBeCrossed(Double_t* point, Double_t* dir) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tDistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidDraw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tEpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const",MatchSource.WIKI,root/html528/TGeoShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoShape.html
https://root.cern/root/html528/TGeoShape.html:7825,Safety,safe,safe,7825,"le_tBig(); virtual voidTObject::Browse(TBrowser* b); virtual Double_tCapacity() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tComputeEpsMch(); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); virtual Bool_tContains(Double_t* point) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tCouldBeCrossed(Double_t* point, Double_t* dir) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tDistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidDraw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tEpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name",MatchSource.WIKI,root/html528/TGeoShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoShape.html
https://root.cern/root/html528/TGeoShape.html:17756,Safety,safe,safety,17756,"snext, Double_t& rxy); Compute distance from POINT to semiplane defined by PHI angle along DIR. Computes; also radius at crossing point. This might be negative in case the crossing is; on the other side of the semiplane. Bool_t IsSameWithinTolerance(Double_t a, Double_t b); Check if two numbers differ with less than a tolerance. Bool_t IsSegCrossing(Double_t x1, Double_t y1, Double_t x2, Double_t y2, Double_t x3, Double_t y3, Double_t x4, Double_t y4); Check if segments (A,B) and (C,D) are crossing,; where: A(x1,y1), B(x2,y2), C(x3,y3), D(x4,y4). Double_t DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); compute distance from point (inside phi) to both phi planes. Return minimum. void NormalPhi(Double_t* point, Double_t* dir, Double_t* norm, Double_t c1, Double_t s1, Double_t c2, Double_t s2); Static method to compute normal to phi planes. Double_t SafetyPhi(Double_t* point, Bool_t in, Double_t phi1, Double_t phi2); Static method to compute safety w.r.t a phi corner defined by cosines/sines; of the angles phi1, phi2. void SetShapeBit(UInt_t f, Bool_t set); Equivalent of TObject::SetBit. TGeoMatrix * GetTransform(); Returns current transformation matrix that applies to shape. void SetTransform(TGeoMatrix* matrix); Set current transformation matrix that applies to shape. void TransformPoints(Double_t* points, UInt_t NbPoints) const; Tranform a set of points (LocalToMaster). void FillBuffer3D(TBuffer3D& buffer, Int_t reqSections, Bool_t localFrame) const; Fill the supplied buffer, with sections in desired frame; See TBuffer3D.h for explanation of sections, frame etc. Int_t GetBasicColor() const; Get the basic color (0-7). const TBuffer3D & GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; Stub implementation to avoid forcing implementation at this stage. const char * GetPointerName() const; Provide a pointer name containing uid. void ExecuteEvent(Int_t event, Int_t px, In",MatchSource.WIKI,root/html528/TGeoShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoShape.html
https://root.cern/root/html528/TGeoShape.html:18546,Safety,avoid,avoid,18546,"nt, Double_t* dir, Double_t* norm, Double_t c1, Double_t s1, Double_t c2, Double_t s2); Static method to compute normal to phi planes. Double_t SafetyPhi(Double_t* point, Bool_t in, Double_t phi1, Double_t phi2); Static method to compute safety w.r.t a phi corner defined by cosines/sines; of the angles phi1, phi2. void SetShapeBit(UInt_t f, Bool_t set); Equivalent of TObject::SetBit. TGeoMatrix * GetTransform(); Returns current transformation matrix that applies to shape. void SetTransform(TGeoMatrix* matrix); Set current transformation matrix that applies to shape. void TransformPoints(Double_t* points, UInt_t NbPoints) const; Tranform a set of points (LocalToMaster). void FillBuffer3D(TBuffer3D& buffer, Int_t reqSections, Bool_t localFrame) const; Fill the supplied buffer, with sections in desired frame; See TBuffer3D.h for explanation of sections, frame etc. Int_t GetBasicColor() const; Get the basic color (0-7). const TBuffer3D & GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; Stub implementation to avoid forcing implementation at this stage. const char * GetPointerName() const; Provide a pointer name containing uid. void ExecuteEvent(Int_t event, Int_t px, Int_t py); Execute mouse actions on this shape. void Draw(Option_t* option = """"); Draw this shape. void Paint(Option_t* option = """"); Paint this shape. void SetOnBoundary(Bool_t ); {;}. Double_t Big(); methods. {return 1.E30;}. Double_t Tolerance(); {return 1.E-10;}. Double_t Capacity() const. void ComputeBBox(). void ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm). Bool_t Contains(Double_t* point) const. Bool_t CouldBeCrossed(Double_t* point, Double_t* dir) const. Int_t DistancetoPrimitive(Int_t px, Int_t py). Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step). const char * GetAxisName(Int_",MatchSource.WIKI,root/html528/TGeoShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoShape.html
https://root.cern/root/html528/TGeoShape.html:19354,Safety,safe,safe,19354," with sections in desired frame; See TBuffer3D.h for explanation of sections, frame etc. Int_t GetBasicColor() const; Get the basic color (0-7). const TBuffer3D & GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; Stub implementation to avoid forcing implementation at this stage. const char * GetPointerName() const; Provide a pointer name containing uid. void ExecuteEvent(Int_t event, Int_t px, Int_t py); Execute mouse actions on this shape. void Draw(Option_t* option = """"); Draw this shape. void Paint(Option_t* option = """"); Paint this shape. void SetOnBoundary(Bool_t ); {;}. Double_t Big(); methods. {return 1.E30;}. Double_t Tolerance(); {return 1.E-10;}. Double_t Capacity() const. void ComputeBBox(). void ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm). Bool_t Contains(Double_t* point) const. Bool_t CouldBeCrossed(Double_t* point, Double_t* dir) const. Int_t DistancetoPrimitive(Int_t px, Int_t py). Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step). const char * GetAxisName(Int_t iaxis) const. Double_t GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const. void GetBoundingCylinder(Double_t* param) const. Int_t GetByteCount() const. Bool_t GetPointsOnSegments(Int_t npoints, Double_t* array) const. Int_t GetFittingBox(const TGeoBBox* parambox, TGeoMatrix* mat, Double_t& dx, Double_t& dy, Double_t& dz) const. Int_t GetId() const; {return fShapeId;}. TGeoShape * GetMakeRuntimeShape(TGeoShape* mother, TGeoMatrix* mat) const. void GetMeshNumbers(Int_t& , Int_t& , Int_t& ) const; {;}. Int_t GetNmeshVertices() const; {return 0;}. Bool_t IsAssembly() const; {return kFALSE;}. Bool_t IsComposite() const; {return kFALSE;}. Bool_t IsCylType() const. Bool_t IsReflected() const; {return kFALSE;}. Bool_t IsRunTimeShape() const; {return TestShapeBit(kGeoRunT",MatchSource.WIKI,root/html528/TGeoShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoShape.html
https://root.cern/root/html528/TGeoShape.html:2325,Security,access,accessible,2325,"; - computation of the minimal box bounding the shape, given that this box have; to be aligned with the local coordinates;; - algorithms for dividing the shape along a given axis and producing resulting; divisions volumes. The modeler currently provides a set of 16 basic shapes, which we will call; primitives. It also provides a special class allowing the creation of shapes; made as a result of boolean operations between primitives. These are called; composite shapes and the composition operation can be recursive (composition; of composites). This allows the creation of a quite large number of different; shape topologies and combinations. Shapes are named objects and register themselves to the manager class at; creation time. This is responsible for their final deletion. Shapes; can be created without name if their retreival by name is no needed. Generally; shapes are objects that are usefull only at geometry creation stage. The pointer; to a shape is in fact needed only when referring to a given volume and it is; always accessible at that level. A shape may be referenced by several volumes,; therefore its deletion is not possible once volumes were defined based on it. Creating shapes. Shape objects embeed only the minimum set of parameters that are fully; describing a valid physical shape. For instance, a tube is represented by; its half length, the minimum radius and the maximum radius. Shapes are used; togeather with media in order to create volumes, which in their turn; are the main components of the geometrical tree. A specific shape can be created; stand-alone :. TGeoBBox *box = new TGeoBBox(""s_box"", halfX, halfY, halfZ); // named; TGeoTube *tub = new TGeoTube(rmin, rmax, halfZ); // no name; ... (see each specific shape constructors). Sometimes it is much easier to create a volume having a given shape in one; step, since shapes are not direcly linked in the geometrical tree but volumes; are :. TGeoVolume *vol_box = gGeoManager->MakeBox(""BOX_VOL"", ""mat1"", halfX",MatchSource.WIKI,root/html528/TGeoShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoShape.html
https://root.cern/root/html528/TGeoShapeAssembly.html:2565,Availability,error,error,2565,"ive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const char*TGeoBBox::GetAxisName(Int_t iaxis) const; virtual Double_tTGeoBBox::GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; virtual voidTGeoBBox::GetBoundingCylinder(Double_t* param) const; virtual const TBuffer3D&TGeoBBox::GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; virtual Int_tTGeoBBox::GetByteCount() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_tTGeoBBox::GetDX() const; virtual Double_tTGeoBBox::GetDY() const; virtual Double_tTGeoBBox::GetDZ() const; virtual Double_tTGeoBBox::GetFa",MatchSource.WIKI,root/html528/TGeoShapeAssembly.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoShapeAssembly.html
https://root.cern/root/html528/TGeoShapeAssembly.html:2649,Availability,error,error,2649,"ir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const char*TGeoBBox::GetAxisName(Int_t iaxis) const; virtual Double_tTGeoBBox::GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; virtual voidTGeoBBox::GetBoundingCylinder(Double_t* param) const; virtual const TBuffer3D&TGeoBBox::GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; virtual Int_tTGeoBBox::GetByteCount() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_tTGeoBBox::GetDX() const; virtual Double_tTGeoBBox::GetDY() const; virtual Double_tTGeoBBox::GetDZ() const; virtual Double_tTGeoBBox::GetFacetArea(Int_t index = 0) const; virtual Int_tTGeoBBox::GetFittingBox(const TGeoBBox*",MatchSource.WIKI,root/html528/TGeoShapeAssembly.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoShapeAssembly.html
https://root.cern/root/html528/TGeoShapeAssembly.html:1716,Safety,safe,safe,1716," TGeoBBox* box1, const TGeoMatrix* mat1, const TGeoBBox* box2, const TGeoMatrix* mat2); static Double_tTGeoShape::Big(); virtual voidTObject::Browse(TBrowser* b); virtual Double_tTGeoBBox::Capacity() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); virtual Bool_tContains(Double_t* point) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(Double_t* point, Double_t* dir) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px,",MatchSource.WIKI,root/html528/TGeoShapeAssembly.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoShapeAssembly.html
https://root.cern/root/html528/TGeoShapeAssembly.html:1857,Safety,safe,safe,1857,":Browse(TBrowser* b); virtual Double_tTGeoBBox::Capacity() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); virtual Bool_tContains(Double_t* point) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(Double_t* point, Double_t* dir) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual ",MatchSource.WIKI,root/html528/TGeoShapeAssembly.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoShapeAssembly.html
https://root.cern/root/html528/TGeoShapeAssembly.html:11939,Safety,safe,safe,11939," origin; UInt_tTGeoShape::fShapeBitsshape bits; Int_tTGeoShape::fShapeIdshape id; TStringTNamed::fTitleobject title; TGeoVolumeAssembly*fVolumeassembly volume. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoShapeAssembly(); Default constructor. TGeoShapeAssembly(TGeoVolumeAssembly* vol); Constructor specifying hyperboloid parameters. ~TGeoShapeAssembly(); destructor. void ComputeBBox(); Compute bounding box of the assembly. void RecomputeBoxLast(); Recompute bounding box of the assembly after adding a node. void ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. Should not be called. Bool_t Contains(Double_t* point) const; Test if point is inside the assembly. Int_t DistancetoPrimitive(Int_t px, Int_t py); compute closest distance from point px,py to each vertex. Should not be called. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the hyperboloid. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from outside point to surface of the hyperboloid.; fVolume->SetNextNodeIndex(-1);. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); Cannot divide assemblies. TGeoShape * GetMakeRuntimeShape(TGeoShape* mother, TGeoMatrix* mat) const; in case shape has some negative parameters, these has to be computed; in order to fit the mother. void InspectShape() const; print shape parameters. void SetSegsAndPols(TBuffer3D& buff) const; Fill TBuffer3D structure for segments and polygons. Double_t Safety(Double_t* point, Bool_t in = kTRUE) const; computes the closest distance from given point to this shape, according; to option. The matching point on the shape is stored in spoint. void S",MatchSource.WIKI,root/html528/TGeoShapeAssembly.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoShapeAssembly.html
https://root.cern/root/html528/TGeoShapeAssembly.html:12139,Safety,safe,safe,12139,"bers; Includes; Libraries. Function documentation; TGeoShapeAssembly(); Default constructor. TGeoShapeAssembly(TGeoVolumeAssembly* vol); Constructor specifying hyperboloid parameters. ~TGeoShapeAssembly(); destructor. void ComputeBBox(); Compute bounding box of the assembly. void RecomputeBoxLast(); Recompute bounding box of the assembly after adding a node. void ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. Should not be called. Bool_t Contains(Double_t* point) const; Test if point is inside the assembly. Int_t DistancetoPrimitive(Int_t px, Int_t py); compute closest distance from point px,py to each vertex. Should not be called. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the hyperboloid. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from outside point to surface of the hyperboloid.; fVolume->SetNextNodeIndex(-1);. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); Cannot divide assemblies. TGeoShape * GetMakeRuntimeShape(TGeoShape* mother, TGeoMatrix* mat) const; in case shape has some negative parameters, these has to be computed; in order to fit the mother. void InspectShape() const; print shape parameters. void SetSegsAndPols(TBuffer3D& buff) const; Fill TBuffer3D structure for segments and polygons. Double_t Safety(Double_t* point, Bool_t in = kTRUE) const; computes the closest distance from given point to this shape, according; to option. The matching point on the shape is stored in spoint. void SavePrimitive(ostream& out, Option_t* option = """"); Save a primitive as a C++ statement(s) on output stream ""out"". void SetPoints(Double_t* points) const; No mesh for assemblies. void SetPoints(Float_t",MatchSource.WIKI,root/html528/TGeoShapeAssembly.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoShapeAssembly.html
https://root.cern/root/html528/TGeoShapeDialog.html:5127,Availability,error,error,5127,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); TList*TGMainFrame::GetBindList() const; static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; voidTGMainFrame::GetClassHints(const char*& className, const char*& resourceName) const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBa",MatchSource.WIKI,root/html528/TGeoShapeDialog.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoShapeDialog.html
https://root.cern/root/html528/TGeoShapeDialog.html:5211,Availability,error,error,5211,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); TList*TGMainFrame::GetBindList() const; static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; voidTGMainFrame::GetClassHints(const char*& className, const char*& resourceName) const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UIn",MatchSource.WIKI,root/html528/TGeoShapeDialog.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoShapeDialog.html
https://root.cern/root/html528/TGeoShapeDialog.html:19638,Availability,mask,mask,19638,,MatchSource.WIKI,root/html528/TGeoShapeDialog.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoShapeDialog.html
https://root.cern/root/html528/TGeoSphere.html:3072,Availability,error,error,3072,"Shape::Big(), Double_t* safe = 0) const; virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); Double_tDistToSphere(Double_t* point, Double_t* dir, Double_t rsph, Bool_t check = kTRUE, Bool_t firstcross = kTRUE) const; virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const char*GetAxisName(Int_t iaxis) const; virtual Double_tGetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; virtual voidGetBoundingCylinder(Double_t* param) const; virtual const TBuffer3D&GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; virtual Int_tGetByteCount() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_tTGeoBBox::GetDX() const; virtual Double_tTGeoBBox::GetDY() const; virtual Double_tTGeoBBox::GetDZ() const; virtual Double_tTGeoBBox::GetFacetArea(Int_t index = 0) const; virtual Int_tTGeoB",MatchSource.WIKI,root/html528/TGeoSphere.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoSphere.html
https://root.cern/root/html528/TGeoSphere.html:3156,Availability,error,error,3156,"oint, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); Double_tDistToSphere(Double_t* point, Double_t* dir, Double_t rsph, Bool_t check = kTRUE, Bool_t firstcross = kTRUE) const; virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const char*GetAxisName(Int_t iaxis) const; virtual Double_tGetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; virtual voidGetBoundingCylinder(Double_t* param) const; virtual const TBuffer3D&GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; virtual Int_tGetByteCount() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_tTGeoBBox::GetDX() const; virtual Double_tTGeoBBox::GetDY() const; virtual Double_tTGeoBBox::GetDZ() const; virtual Double_tTGeoBBox::GetFacetArea(Int_t index = 0) const; virtual Int_tTGeoBBox::GetFittingBox(const TGeoBBox* parambox, TGeoMatrix* mat, Double_t& dx, Double_t",MatchSource.WIKI,root/html528/TGeoSphere.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoSphere.html
https://root.cern/root/html528/TGeoSphere.html:13140,Availability,toler,tolerance,13140,"Members; Includes; Libraries. Function documentation; TGeoSphere(); Default constructor. TGeoSphere(Double_t rmin, Double_t rmax, Double_t theta1 = 0, Double_t theta2 = 180, Double_t phi1 = 0, Double_t phi2 = 360); Default constructor specifying minimum and maximum radius. TGeoSphere(const char* name, Double_t rmin, Double_t rmax, Double_t theta1 = 0, Double_t theta2 = 180, Double_t phi1 = 0, Double_t phi2 = 360); Default constructor specifying minimum and maximum radius. TGeoSphere(Double_t* param, Int_t nparam = 6); Default constructor specifying minimum and maximum radius; param[0] = Rmin; param[1] = Rmax. ~TGeoSphere(); destructor. Double_t Capacity() const; Computes capacity of the shape in [length^3]. void ComputeBBox(); compute bounding box of the sphere; Double_t xmin, xmax, ymin, ymax, zmin, zmax;. void ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. Int_t IsOnBoundary(Double_t* point) const; Check if a point in local sphere coordinates is close to a boundary within; shape tolerance. Return values:; 0 - not close to boundary; 1 - close to Rmin boundary; 2 - close to Rmax boundary; 3,4 - close to phi1/phi2 boundary; 5,6 - close to theta1/theta2 boundary. Bool_t IsPointInside(Double_t* point, Bool_t checkR = kTRUE, Bool_t checkTh = kTRUE, Bool_t checkPh = kTRUE) const; Check if a point is inside radius/theta/phi ranges for the spherical sector. Bool_t Contains(Double_t* point) const; test if point is inside this sphere; check Rmin<=R<=Rmax. Int_t DistancetoPrimitive(Int_t px, Int_t py); compute closest distance from point px,py to each corner. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from outside point to surface of the sphere; Check if the bounding box is crossed within the requested distance. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape:",MatchSource.WIKI,root/html528/TGeoSphere.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoSphere.html
https://root.cern/root/html528/TGeoSphere.html:2099,Safety,safe,safe,2099,"ping(const TGeoBBox* box1, const TGeoMatrix* mat1, const TGeoBBox* box2, const TGeoMatrix* mat2); static Double_tTGeoShape::Big(); virtual voidTObject::Browse(TBrowser* b); virtual Double_tCapacity() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); virtual Bool_tContains(Double_t* point) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(Double_t* point, Double_t* dir) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); Double_tDistToSphere(Double_t* point, Double_t* dir, Double_t rsph, Bool_t check = kTRUE, Bool_t firstcross = kTRUE) const; virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObjec",MatchSource.WIKI,root/html528/TGeoSphere.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoSphere.html
https://root.cern/root/html528/TGeoSphere.html:2240,Safety,safe,safe,2240,"idTObject::Browse(TBrowser* b); virtual Double_tCapacity() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); virtual Bool_tContains(Double_t* point) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(Double_t* point, Double_t* dir) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); Double_tDistToSphere(Double_t* point, Double_t* dir, Double_t rsph, Bool_t check = kTRUE, Bool_t firstcross = kTRUE) const; virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtu",MatchSource.WIKI,root/html528/TGeoSphere.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoSphere.html
https://root.cern/root/html528/TGeoSphere.html:13837,Safety,safe,safe,13837,"re; Double_t xmin, xmax, ymin, ymax, zmin, zmax;. void ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. Int_t IsOnBoundary(Double_t* point) const; Check if a point in local sphere coordinates is close to a boundary within; shape tolerance. Return values:; 0 - not close to boundary; 1 - close to Rmin boundary; 2 - close to Rmax boundary; 3,4 - close to phi1/phi2 boundary; 5,6 - close to theta1/theta2 boundary. Bool_t IsPointInside(Double_t* point, Bool_t checkR = kTRUE, Bool_t checkTh = kTRUE, Bool_t checkPh = kTRUE) const; Check if a point is inside radius/theta/phi ranges for the spherical sector. Bool_t Contains(Double_t* point) const; test if point is inside this sphere; check Rmin<=R<=Rmax. Int_t DistancetoPrimitive(Int_t px, Int_t py); compute closest distance from point px,py to each corner. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from outside point to surface of the sphere; Check if the bounding box is crossed within the requested distance. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from inside point to surface of the sphere. Double_t DistToSphere(Double_t* point, Double_t* dir, Double_t rsph, Bool_t check = kTRUE, Bool_t firstcross = kTRUE) const; compute distance to sphere of radius rsph. Direction has to be a unit vector. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); Divide all range of iaxis in range/step cells. const char * GetAxisName(Int_t iaxis) const; Returns name of axis IAXIS. Double_t GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; Get range of shape for a given axis. void GetBoundingCylinder(Double_t* param) const; --- Fill vector param[4] with the bounding cylinder parameters. The order;",MatchSource.WIKI,root/html528/TGeoSphere.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoSphere.html
https://root.cern/root/html528/TGeoSphere.html:14100,Safety,safe,safe,14100,"cal sphere coordinates is close to a boundary within; shape tolerance. Return values:; 0 - not close to boundary; 1 - close to Rmin boundary; 2 - close to Rmax boundary; 3,4 - close to phi1/phi2 boundary; 5,6 - close to theta1/theta2 boundary. Bool_t IsPointInside(Double_t* point, Bool_t checkR = kTRUE, Bool_t checkTh = kTRUE, Bool_t checkPh = kTRUE) const; Check if a point is inside radius/theta/phi ranges for the spherical sector. Bool_t Contains(Double_t* point) const; test if point is inside this sphere; check Rmin<=R<=Rmax. Int_t DistancetoPrimitive(Int_t px, Int_t py); compute closest distance from point px,py to each corner. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from outside point to surface of the sphere; Check if the bounding box is crossed within the requested distance. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from inside point to surface of the sphere. Double_t DistToSphere(Double_t* point, Double_t* dir, Double_t rsph, Bool_t check = kTRUE, Bool_t firstcross = kTRUE) const; compute distance to sphere of radius rsph. Direction has to be a unit vector. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); Divide all range of iaxis in range/step cells. const char * GetAxisName(Int_t iaxis) const; Returns name of axis IAXIS. Double_t GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; Get range of shape for a given axis. void GetBoundingCylinder(Double_t* param) const; --- Fill vector param[4] with the bounding cylinder parameters. The order; is the following : Rmin, Rmax, Phi1, Phi2. void InspectShape() const; print shape parameters. TBuffer3D * MakeBuffer3D() const; Creates a TBuffer3D describing *this* shape.; Coordinates are in local reference frame. void SetSegs",MatchSource.WIKI,root/html528/TGeoSphere.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoSphere.html
https://root.cern/root/html528/TGeoSphere.html:13557,Testability,test,test,13557,"here(Double_t* param, Int_t nparam = 6); Default constructor specifying minimum and maximum radius; param[0] = Rmin; param[1] = Rmax. ~TGeoSphere(); destructor. Double_t Capacity() const; Computes capacity of the shape in [length^3]. void ComputeBBox(); compute bounding box of the sphere; Double_t xmin, xmax, ymin, ymax, zmin, zmax;. void ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. Int_t IsOnBoundary(Double_t* point) const; Check if a point in local sphere coordinates is close to a boundary within; shape tolerance. Return values:; 0 - not close to boundary; 1 - close to Rmin boundary; 2 - close to Rmax boundary; 3,4 - close to phi1/phi2 boundary; 5,6 - close to theta1/theta2 boundary. Bool_t IsPointInside(Double_t* point, Bool_t checkR = kTRUE, Bool_t checkTh = kTRUE, Bool_t checkPh = kTRUE) const; Check if a point is inside radius/theta/phi ranges for the spherical sector. Bool_t Contains(Double_t* point) const; test if point is inside this sphere; check Rmin<=R<=Rmax. Int_t DistancetoPrimitive(Int_t px, Int_t py); compute closest distance from point px,py to each corner. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from outside point to surface of the sphere; Check if the bounding box is crossed within the requested distance. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from inside point to surface of the sphere. Double_t DistToSphere(Double_t* point, Double_t* dir, Double_t rsph, Bool_t check = kTRUE, Bool_t firstcross = kTRUE) const; compute distance to sphere of radius rsph. Direction has to be a unit vector. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); Divide all range of iaxis in range/step cells. const char * GetAxi",MatchSource.WIKI,root/html528/TGeoSphere.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoSphere.html
https://root.cern/root/html528/TGeoSphereEditor.html:4679,Availability,error,error,4679,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const;",MatchSource.WIKI,root/html528/TGeoSphereEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoSphereEditor.html
https://root.cern/root/html528/TGeoSphereEditor.html:4763,Availability,error,error,4763,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType() c",MatchSource.WIKI,root/html528/TGeoSphereEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoSphereEditor.html
https://root.cern/root/html528/TGeoSphereEditor.html:17902,Availability,mask,mask,17902,,MatchSource.WIKI,root/html528/TGeoSphereEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoSphereEditor.html
https://root.cern/root/html528/TGeoSphereEditor.html:21590,Usability,undo,undoing,21590,"ame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoSphereEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor for sphere editor. ~TGeoSphereEditor(); Destructor. void ConnectSignals2Slots(); Connect signals to slots. void SetModel(TObject* obj); Connect to a given sphere. Bool_t IsDelayed() const; Check if shape drawing is delayed. void DoName(); Slot for name. void DoApply(); Slot for applying modifications. void DoModified(); Slot for signaling modifications. void DoUndo(); Slot for undoing last operation. void DoRmin(); Slot for Rmin. void DoRmax(); Slot for Rmax. void DoPhi1(); Slot for phi1. void DoPhi2(); Slot for phi2. void DoPhi(); Slot for phi slider. void DoTheta1(); Slot for theta1. void DoTheta2(); Slot for theta2. void DoTheta(); Slot for theta slider. » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id: TGeoSphereEditor.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2010-09-23 20:09; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html528/TGeoSphereEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoSphereEditor.html
https://root.cern/root/html528/TGeoSubtraction.html:2879,Availability,error,error,2879,"uble_t& dy, Double_t& dz, Double_t* origin); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); virtual Bool_tContains(Double_t* point) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistanceToPrimitive(Int_t px, Int_t py); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TGeoBoolNode::EGeoBoolTypeGetBooleanOperator() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; TGeoMatrix*TGeoBoolNode::GetLeftMatrix() const; TGeoShape*TGeoBoolNode::GetLeftShape() const; virtual const char*TObject::GetName() const; virtual Int_tGetNpoints(); virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TGeoMatrix*TGeoBoolNode::GetRightMatrix() const; TGeoShape*TGeoBoolNode::GetRightShape() const; virtual const char*TObject::GetTitl",MatchSource.WIKI,root/html528/TGeoSubtraction.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoSubtraction.html
https://root.cern/root/html528/TGeoSubtraction.html:2963,Availability,error,error,2963,"nt, Double_t* dir, Double_t* norm); virtual Bool_tContains(Double_t* point) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistanceToPrimitive(Int_t px, Int_t py); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TGeoBoolNode::EGeoBoolTypeGetBooleanOperator() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; TGeoMatrix*TGeoBoolNode::GetLeftMatrix() const; TGeoShape*TGeoBoolNode::GetLeftShape() const; virtual const char*TObject::GetName() const; virtual Int_tGetNpoints(); virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TGeoMatrix*TGeoBoolNode::GetRightMatrix() const; TGeoShape*TGeoBoolNode::GetRightShape() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::Handle",MatchSource.WIKI,root/html528/TGeoSubtraction.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoSubtraction.html
https://root.cern/root/html528/TGeoSubtraction.html:2381,Safety,safe,safe,2381,"TGeoMatrix* lmat = 0, TGeoMatrix* rmat = 0); virtual~TGeoSubtraction(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidComputeBBox(Double_t& dx, Double_t& dy, Double_t& dz, Double_t* origin); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); virtual Bool_tContains(Double_t* point) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistanceToPrimitive(Int_t px, Int_t py); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TGeoBoolNode::EGeoBoolTypeGetBooleanOperator() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnl",MatchSource.WIKI,root/html528/TGeoSubtraction.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoSubtraction.html
https://root.cern/root/html528/TGeoSubtraction.html:2507,Safety,safe,safe,2507," virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidComputeBBox(Double_t& dx, Double_t& dy, Double_t& dz, Double_t* origin); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); virtual Bool_tContains(Double_t* point) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistanceToPrimitive(Int_t px, Int_t py); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TGeoBoolNode::EGeoBoolTypeGetBooleanOperator() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; TGeoMatrix*TGeoBoolNode::GetLeftMatrix() const; TGeoShape*TGeoBoolNode::",MatchSource.WIKI,root/html528/TGeoSubtraction.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoSubtraction.html
https://root.cern/root/html528/TGeoSubtraction.html:8738,Safety,safe,safe,8738,"cludes; Libraries. Function documentation; void Paint(Option_t* option); Paint method. TGeoSubtraction(); Default constructor. TGeoSubtraction(const char* expr1, const char* expr2); Constructor. TGeoSubtraction(TGeoShape* left, TGeoShape* right, TGeoMatrix* lmat = 0, TGeoMatrix* rmat = 0); Constructor providing pointers to components. ~TGeoSubtraction(); Destructor; --- deletion of components handled by TGeoManager class. void ComputeBBox(Double_t& dx, Double_t& dy, Double_t& dz, Double_t* origin); Compute bounding box corresponding to a subtraction of two shapes. void ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); Normal computation in POINT. The orientation is chosen so that DIR.dot.NORM>0. Bool_t Contains(Double_t* point) const; Find if a subtraction of two shapes contains a given point. Int_t DistanceToPrimitive(Int_t px, Int_t py); Compute minimum distance to shape vertices. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; Compute distance from a given point inside to the shape boundary. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; Compute distance from a given point outside to the shape. Int_t GetNpoints(); Returns number of vertices for the composite shape described by this subtraction. Double_t Safety(Double_t* point, Bool_t in = kTRUE) const; Compute safety distance for a union node;. void SavePrimitive(ostream& out, Option_t* option = """"); Save a primitive as a C++ statement(s) on output stream ""out"". void Sizeof3D() const; Register 3D size of this shape. EGeoBoolType GetBooleanOperator() const. » Author: Andrei Gheata 30/05/02 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: :$Id: TGeoBoolNode.h 32690 2010-03-21 08:47:56Z brun $ » Last generated: 2010-12-10 11:10; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT i",MatchSource.WIKI,root/html528/TGeoSubtraction.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoSubtraction.html
https://root.cern/root/html528/TGeoSubtraction.html:8923,Safety,safe,safe,8923,"d Paint(Option_t* option); Paint method. TGeoSubtraction(); Default constructor. TGeoSubtraction(const char* expr1, const char* expr2); Constructor. TGeoSubtraction(TGeoShape* left, TGeoShape* right, TGeoMatrix* lmat = 0, TGeoMatrix* rmat = 0); Constructor providing pointers to components. ~TGeoSubtraction(); Destructor; --- deletion of components handled by TGeoManager class. void ComputeBBox(Double_t& dx, Double_t& dy, Double_t& dz, Double_t* origin); Compute bounding box corresponding to a subtraction of two shapes. void ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); Normal computation in POINT. The orientation is chosen so that DIR.dot.NORM>0. Bool_t Contains(Double_t* point) const; Find if a subtraction of two shapes contains a given point. Int_t DistanceToPrimitive(Int_t px, Int_t py); Compute minimum distance to shape vertices. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; Compute distance from a given point inside to the shape boundary. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; Compute distance from a given point outside to the shape. Int_t GetNpoints(); Returns number of vertices for the composite shape described by this subtraction. Double_t Safety(Double_t* point, Bool_t in = kTRUE) const; Compute safety distance for a union node;. void SavePrimitive(ostream& out, Option_t* option = """"); Save a primitive as a C++ statement(s) on output stream ""out"". void Sizeof3D() const; Register 3D size of this shape. EGeoBoolType GetBooleanOperator() const. » Author: Andrei Gheata 30/05/02 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: :$Id: TGeoBoolNode.h 32690 2010-03-21 08:47:56Z brun $ » Last generated: 2010-12-10 11:10; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html528/TGeoSubtraction.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoSubtraction.html
https://root.cern/root/html528/TGeoSubtraction.html:9167,Safety,safe,safety,9167,"d Paint(Option_t* option); Paint method. TGeoSubtraction(); Default constructor. TGeoSubtraction(const char* expr1, const char* expr2); Constructor. TGeoSubtraction(TGeoShape* left, TGeoShape* right, TGeoMatrix* lmat = 0, TGeoMatrix* rmat = 0); Constructor providing pointers to components. ~TGeoSubtraction(); Destructor; --- deletion of components handled by TGeoManager class. void ComputeBBox(Double_t& dx, Double_t& dy, Double_t& dz, Double_t* origin); Compute bounding box corresponding to a subtraction of two shapes. void ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); Normal computation in POINT. The orientation is chosen so that DIR.dot.NORM>0. Bool_t Contains(Double_t* point) const; Find if a subtraction of two shapes contains a given point. Int_t DistanceToPrimitive(Int_t px, Int_t py); Compute minimum distance to shape vertices. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; Compute distance from a given point inside to the shape boundary. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; Compute distance from a given point outside to the shape. Int_t GetNpoints(); Returns number of vertices for the composite shape described by this subtraction. Double_t Safety(Double_t* point, Bool_t in = kTRUE) const; Compute safety distance for a union node;. void SavePrimitive(ostream& out, Option_t* option = """"); Save a primitive as a C++ statement(s) on output stream ""out"". void Sizeof3D() const; Register 3D size of this shape. EGeoBoolType GetBooleanOperator() const. » Author: Andrei Gheata 30/05/02 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: :$Id: TGeoBoolNode.h 32690 2010-03-21 08:47:56Z brun $ » Last generated: 2010-12-10 11:10; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html528/TGeoSubtraction.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoSubtraction.html
https://root.cern/root/html528/TGeoTabManager.html:1943,Availability,error,error,1943,"Editor* ged); virtual~TGeoTabManager(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; static voidCleanup(TGCompositeFrame* frame); virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; static TGeoTabManager*GetMakeTabManager(TGedEditor* ged); voidGetMaterialEditor(TGeoMaterial* material); voidGetMatrixEditor(TGeoMatrix* matrix); voidGetMediumEditor(TGeoMedium* medium); virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TVirtualPad*GetPad() const; voidGetShapeEditor(TGeoShape* shape); TGTab*GetTab() const; Int_tGetTabIndex() const; virtual const",MatchSource.WIKI,root/html528/TGeoTabManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoTabManager.html
https://root.cern/root/html528/TGeoTabManager.html:2027,Availability,error,error,2027,"od) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; static voidCleanup(TGCompositeFrame* frame); virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; static TGeoTabManager*GetMakeTabManager(TGedEditor* ged); voidGetMaterialEditor(TGeoMaterial* material); voidGetMatrixEditor(TGeoMatrix* matrix); voidGetMediumEditor(TGeoMedium* medium); virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TVirtualPad*GetPad() const; voidGetShapeEditor(TGeoShape* shape); TGTab*GetTab() const; Int_tGetTabIndex() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; TGeoVol",MatchSource.WIKI,root/html528/TGeoTabManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoTabManager.html
https://root.cern/root/html528/TGeoTorus.html:2962,Availability,error,error,2962,"ive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const char*GetAxisName(Int_t iaxis) const; virtual Double_tGetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; virtual voidGetBoundingCylinder(Double_t* param) const; virtual const TBuffer3D&GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; virtual Int_tGetByteCount() const; Double_tGetDphi() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_tTGeoBBox::GetDX() const; virtual Double_tTGeoBBox::GetDY() const; virtual Double_tTGeoBBox::GetDZ() const; virtual Double_tTGeoBBox::GetFacetArea(Int_t index = 0) ",MatchSource.WIKI,root/html528/TGeoTorus.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoTorus.html
https://root.cern/root/html528/TGeoTorus.html:3046,Availability,error,error,3046,"ir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const char*GetAxisName(Int_t iaxis) const; virtual Double_tGetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; virtual voidGetBoundingCylinder(Double_t* param) const; virtual const TBuffer3D&GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; virtual Int_tGetByteCount() const; Double_tGetDphi() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_tTGeoBBox::GetDX() const; virtual Double_tTGeoBBox::GetDY() const; virtual Double_tTGeoBBox::GetDZ() const; virtual Double_tTGeoBBox::GetFacetArea(Int_t index = 0) const; virtual Int_tTGeoBBox::GetFittingBox(const TGeoBBox* parambox, TGeoMatrix* ma",MatchSource.WIKI,root/html528/TGeoTorus.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoTorus.html
https://root.cern/root/html528/TGeoTorus.html:2113,Safety,safe,safe,2113,"Capacity() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); virtual Bool_tContains(Double_t* point) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(Double_t* point, Double_t* dir) const; Double_tDaxis(Double_t* pt, Double_t* dir, Double_t t) const; Double_tDDaxis(Double_t* pt, Double_t* dir, Double_t t) const; Double_tDDDaxis(Double_t* pt, Double_t* dir, Double_t t) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px,",MatchSource.WIKI,root/html528/TGeoTorus.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoTorus.html
https://root.cern/root/html528/TGeoTorus.html:2254,Safety,safe,safe,2254,"tual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); virtual Bool_tContains(Double_t* point) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(Double_t* point, Double_t* dir) const; Double_tDaxis(Double_t* pt, Double_t* dir, Double_t t) const; Double_tDDaxis(Double_t* pt, Double_t* dir, Double_t t) const; Double_tDDDaxis(Double_t* pt, Double_t* dir, Double_t t) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual ",MatchSource.WIKI,root/html528/TGeoTorus.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoTorus.html
https://root.cern/root/html528/TGeoTorus.html:13199,Safety,safe,safe,13199,"aram[1] = Rmin; param[2] = Rmax; param[3] = Phi1; param[4] = Dphi. Double_t Capacity() const; Computes capacity of the shape in [length^3]. void ComputeBBox(); Compute bounding box of the torus. void ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. Bool_t Contains(Double_t* point) const; Test if point is inside the torus.; check phi range. Int_t DistancetoPrimitive(Int_t px, Int_t py); Compute closest distance from point px,py to each vertex. Double_t Daxis(Double_t* pt, Double_t* dir, Double_t t) const; Computes distance to axis of the torus from point pt + t*dir;. Double_t DDaxis(Double_t* pt, Double_t* dir, Double_t t) const; Computes derivative w.r.t. t of the distance to axis of the torus from point pt + t*dir;. Double_t DDDaxis(Double_t* pt, Double_t* dir, Double_t t) const; Second derivative of distance to torus axis w.r.t t. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the torus. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from outside point to surface of the torus. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); --- Divide this torus shape belonging to volume ""voldiv"" into ndiv volumes; called divname, from start position with the given step. const char * GetAxisName(Int_t iaxis) const; Returns name of axis IAXIS. Double_t GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; Get range of shape for a given axis. void GetBoundingCylinder(Double_t* param) const; --- Fill vector param[4] with the bounding cylinder parameters. The order; is the following : Rmin, Rmax, Phi1, Phi2, dZ. TGeoShape * GetMakeRuntimeShape(TGeoShape* mother, TGeoMatrix* mat) const; Create a shape fitting the mo",MatchSource.WIKI,root/html528/TGeoTorus.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoTorus.html
https://root.cern/root/html528/TGeoTorus.html:13393,Safety,safe,safe,13393," void ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. Bool_t Contains(Double_t* point) const; Test if point is inside the torus.; check phi range. Int_t DistancetoPrimitive(Int_t px, Int_t py); Compute closest distance from point px,py to each vertex. Double_t Daxis(Double_t* pt, Double_t* dir, Double_t t) const; Computes distance to axis of the torus from point pt + t*dir;. Double_t DDaxis(Double_t* pt, Double_t* dir, Double_t t) const; Computes derivative w.r.t. t of the distance to axis of the torus from point pt + t*dir;. Double_t DDDaxis(Double_t* pt, Double_t* dir, Double_t t) const; Second derivative of distance to torus axis w.r.t t. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the torus. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from outside point to surface of the torus. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); --- Divide this torus shape belonging to volume ""voldiv"" into ndiv volumes; called divname, from start position with the given step. const char * GetAxisName(Int_t iaxis) const; Returns name of axis IAXIS. Double_t GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; Get range of shape for a given axis. void GetBoundingCylinder(Double_t* param) const; --- Fill vector param[4] with the bounding cylinder parameters. The order; is the following : Rmin, Rmax, Phi1, Phi2, dZ. TGeoShape * GetMakeRuntimeShape(TGeoShape* mother, TGeoMatrix* mat) const; Create a shape fitting the mother. void InspectShape() const; print shape parameters. TBuffer3D * MakeBuffer3D() const; Creates a TBuffer3D describing *this* shape.; Coordinates are in local reference frame. void SetSegsAnd",MatchSource.WIKI,root/html528/TGeoTorus.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoTorus.html
https://root.cern/root/html528/TGeoTorusEditor.html:4608,Availability,error,error,4608,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const;",MatchSource.WIKI,root/html528/TGeoTorusEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoTorusEditor.html
https://root.cern/root/html528/TGeoTorusEditor.html:4692,Availability,error,error,4692,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType() c",MatchSource.WIKI,root/html528/TGeoTorusEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoTorusEditor.html
https://root.cern/root/html528/TGeoTorusEditor.html:17809,Availability,mask,mask,17809,,MatchSource.WIKI,root/html528/TGeoTorusEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoTorusEditor.html
https://root.cern/root/html528/TGeoTorusEditor.html:21315,Usability,undo,undoing,21315,"osition; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoTorusEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor for torus editor. ~TGeoTorusEditor(); Destructor. void ConnectSignals2Slots(); Connect signals to slots. void SetModel(TObject* obj); Connect to the selected object. Bool_t IsDelayed() const; Check if shape drawing is delayed. void DoName(); Slot for name. void DoApply(); Slot for applying current settings. void DoModified(); Slot for notifying modifications. void DoUndo(); Slot for undoing last operation. void DoR(); Slot for R. void DoRmin(); Slot for Rmin. void DoRmax(); Slot for Rmax. void DoPhi1(); Slot for phi. void DoDphi(); Slot for Dphi. » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id: TGeoTorusEditor.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2010-09-23 20:09; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html528/TGeoTorusEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoTorusEditor.html
https://root.cern/root/html528/TGeoTrack.html:2037,Availability,error,error,2037,"Double_t nframes = 200, Option_t* option = ""/*"")MENU ; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TVirtualGeoTrack*TVirtualGeoTrack::FindTrackWithId(Int_t id) const; TVirtualGeoTrack*TVirtualGeoTrack::GetDaughter(Int_t index) const; virtual Int_tTVirtualGeoTrack::GetDaughterId(Int_t index) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); const Double_t*TVirtualGeoTrack::GetFirstPoint() const; virtual const char*TObject::GetIconName() const; Int_tTVirtualGeoTrack::GetId() const; const Double_t*TVirtualGeoTrack::GetLastPoint() const; Int_tTVirtualGeoTrack::GetLastPoint(Double_t& x, Double_t& y, Double_t& z, Double_t& t) const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tT",MatchSource.WIKI,root/html528/TGeoTrack.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoTrack.html
https://root.cern/root/html528/TGeoTrack.html:2121,Availability,error,error,2121,"d(Option_t* option = """"); virtual voidBrowse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TVirtualGeoTrack*TVirtualGeoTrack::FindTrackWithId(Int_t id) const; TVirtualGeoTrack*TVirtualGeoTrack::GetDaughter(Int_t index) const; virtual Int_tTVirtualGeoTrack::GetDaughterId(Int_t index) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); const Double_t*TVirtualGeoTrack::GetFirstPoint() const; virtual const char*TObject::GetIconName() const; Int_tTVirtualGeoTrack::GetId() const; const Double_t*TVirtualGeoTrack::GetLastPoint() const; Int_tTVirtualGeoTrack::GetLastPoint(Double_t& x, Double_t& y, Double_t& z, Double_t& t) const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; virtua",MatchSource.WIKI,root/html528/TGeoTrack.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoTrack.html
https://root.cern/root/html528/TGeoTransientPanel.html:4885,Availability,error,error,4885,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); TList*TGMainFrame::GetBindList() const; static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; voidTGMainFrame::GetClassHints(const char*& className, const char*& resourceName) const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBa",MatchSource.WIKI,root/html528/TGeoTransientPanel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoTransientPanel.html
https://root.cern/root/html528/TGeoTransientPanel.html:4969,Availability,error,error,4969,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); TList*TGMainFrame::GetBindList() const; static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; voidTGMainFrame::GetClassHints(const char*& className, const char*& resourceName) const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UIn",MatchSource.WIKI,root/html528/TGeoTransientPanel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoTransientPanel.html
https://root.cern/root/html528/TGeoTransientPanel.html:19085,Availability,mask,mask,19085,,MatchSource.WIKI,root/html528/TGeoTransientPanel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoTransientPanel.html
https://root.cern/root/html528/TGeoTranslation.html:6237,Availability,error,error,6237,"dy,dz) translation. Data members:; Double_t fTranslation[3]. Translations can be added/subtracted.; TGeoTranslation t1;; t1->SetTranslation(-5,10,4);; TGeoTranslation *t2 = new TGeoTranslation(4,3,10);; t2->Subtract(&t1);. 2. Rotations - represent a pure rotation. Data members: Double_t fRotationMatrix[3*3].; Rotations can be defined either by Euler angles, either, by GEANT3 angles :; TGeoRotation *r1 = new TGeoRotation();; r1->SetAngles(phi, theta, psi); // all angles in degrees; This represent the composition of : first a rotation about Z axis with; angle phi, then a rotation with theta about the rotated X axis, and; finally a rotation with psi about the new Z axis. r1->SetAngles(th1,phi1, th2,phi2, th3,phi3); This is a rotation defined in GEANT3 style. Theta and phi are the spherical; angles of each axis of the rotated coordinate system with respect to the; initial one. This construction allows definition of malformed rotations,; e.g. not orthogonal. A check is performed and an error message is issued; in this case. Specific utilities : determinant, inverse. 3. Scale transformations - represent a scale shrinking/enlargement. Data; members :Double_t fScale[3]. Not fully implemented yet. 4. Combined transformations - represent a rotation folowed by a translation.; Data members: Double_t fTranslation[3], TGeoRotation *fRotation.; TGeoRotation *rot = new TGeoRotation(""rot"",10,20,30);; TGeoTranslation trans;. TGeoCombiTrans *c1 = new TGeoCombiTrans(trans, rot);; TGeoCombiTrans *c2 = new TGeoCombiTrans(""somename"",10,20,30,rot). 5. TGeoGenTrans - combined transformations including a scale. Not implemented.; 6. TGeoIdentity - a generic singleton matrix representing a identity transformation; NOTE: identified by the global variable gGeoIdentity. Function Members (Methods); public:. TGeoTranslation(); TGeoTranslation(const TGeoTranslation& other); TGeoTranslation(const TGeoMatrix& other); TGeoTranslation(Double_t dx, Double_t dy, Double_t dz); TGeoTranslation(const char* na",MatchSource.WIKI,root/html528/TGeoTranslation.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoTranslation.html
https://root.cern/root/html528/TGeoTranslation.html:8266,Availability,error,error,8266,"y, Double_t dz); virtual~TGeoTranslation(); voidTObject::AbstractMethod(const char* method) const; voidAdd(const TGeoTranslation* other); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Int_tTGeoMatrix::GetByteCount() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); voidTGeoMatrix::GetHomogenousMatrix(Double_t* hmat) const; virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; char*TGeoMatrix::GetPointerName() const; virtual const Double_t*GetRotationMatrix() const; virtual const Double_t*GetScale() const; virtual const char*TNamed::Get",MatchSource.WIKI,root/html528/TGeoTranslation.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoTranslation.html
https://root.cern/root/html528/TGeoTranslation.html:8350,Availability,error,error,8350,"method) const; voidAdd(const TGeoTranslation* other); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Int_tTGeoMatrix::GetByteCount() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); voidTGeoMatrix::GetHomogenousMatrix(Double_t* hmat) const; virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; char*TGeoMatrix::GetPointerName() const; virtual const Double_t*GetRotationMatrix() const; virtual const Double_t*GetScale() const; virtual const char*TNamed::GetTitle() const; virtual const Double_t*GetTranslation() const; virtual UInt_tTObject:",MatchSource.WIKI,root/html528/TGeoTranslation.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoTranslation.html
https://root.cern/root/html528/TGeoTranslation.html:3109,Integrability,interface,interface,3109," 0 1/sz 0; 0 0 0 1 0 0 0 1. where: rij are the 3x3 rotation matrix components,; tx, ty, tz are the translation components; sx, sy, sz are arbitrary scale constants on the eacks axis,. The disadvantage in using this approach is that computation for 4x4 matrices; is expensive. Even combining two translation would become a multiplication; of their corresponding matrices, which is quite an undesired effect. On the; other hand, it is not a good idea to store a translation as a block of 16; numbers. We have therefore chosen to implement each basic transformation type; as a class deriving from the same basic abstract class and handling its specific; data and point/vector transformation algorithms. /*. */. The base class TGeoMatrix defines abstract metods for:. - translation, rotation and scale getters. Every derived class stores only; its specific data, e.g. a translation stores an array of 3 doubles and a; rotation an array of 9. However, asking which is the rotation array of a; TGeoTranslation through the base TGeoMatrix interface is a legal operation.; The answer in this case is a pointer to a global constant array representing; an identity rotation.; Double_t *TGeoMatrix::GetTranslation(); Double_t *TGeoMatrix::GetRotation(); Double_t *TGeoMatrix::GetScale(). - MasterToLocal() and LocalToMaster() point and vector transformations :; void TGeoMatrix::MasterToLocal(const Double_t *master, Double_t *local); void TGeoMatrix::LocalToMaster(const Double_t *local, Double_t *master); void TGeoMatrix::MasterToLocalVect(const Double_t *master, Double_t *local); void TGeoMatrix::LocalToMasterVect(const Double_t *local, Double_t *master); These allow correct conversion also for reflections.; - Transformation type getters :; Bool_t TGeoMatrix::IsIdentity(); Bool_t TGeoMatrix::IsTranslation(); Bool_t TGeoMatrix::IsRotation(); Bool_t TGeoMatrix::IsScale(); Bool_t TGeoMatrix::IsCombi() (translation + rotation); Bool_t TGeoMatrix::IsGeneral() (translation + rotation + scale). Combinatio",MatchSource.WIKI,root/html528/TGeoTranslation.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoTranslation.html
https://root.cern/root/html528/TGeoTranslation.html:6243,Integrability,message,message,6243,"dy,dz) translation. Data members:; Double_t fTranslation[3]. Translations can be added/subtracted.; TGeoTranslation t1;; t1->SetTranslation(-5,10,4);; TGeoTranslation *t2 = new TGeoTranslation(4,3,10);; t2->Subtract(&t1);. 2. Rotations - represent a pure rotation. Data members: Double_t fRotationMatrix[3*3].; Rotations can be defined either by Euler angles, either, by GEANT3 angles :; TGeoRotation *r1 = new TGeoRotation();; r1->SetAngles(phi, theta, psi); // all angles in degrees; This represent the composition of : first a rotation about Z axis with; angle phi, then a rotation with theta about the rotated X axis, and; finally a rotation with psi about the new Z axis. r1->SetAngles(th1,phi1, th2,phi2, th3,phi3); This is a rotation defined in GEANT3 style. Theta and phi are the spherical; angles of each axis of the rotated coordinate system with respect to the; initial one. This construction allows definition of malformed rotations,; e.g. not orthogonal. A check is performed and an error message is issued; in this case. Specific utilities : determinant, inverse. 3. Scale transformations - represent a scale shrinking/enlargement. Data; members :Double_t fScale[3]. Not fully implemented yet. 4. Combined transformations - represent a rotation folowed by a translation.; Data members: Double_t fTranslation[3], TGeoRotation *fRotation.; TGeoRotation *rot = new TGeoRotation(""rot"",10,20,30);; TGeoTranslation trans;. TGeoCombiTrans *c1 = new TGeoCombiTrans(trans, rot);; TGeoCombiTrans *c2 = new TGeoCombiTrans(""somename"",10,20,30,rot). 5. TGeoGenTrans - combined transformations including a scale. Not implemented.; 6. TGeoIdentity - a generic singleton matrix representing a identity transformation; NOTE: identified by the global variable gGeoIdentity. Function Members (Methods); public:. TGeoTranslation(); TGeoTranslation(const TGeoTranslation& other); TGeoTranslation(const TGeoMatrix& other); TGeoTranslation(Double_t dx, Double_t dy, Double_t dz); TGeoTranslation(const char* na",MatchSource.WIKI,root/html528/TGeoTranslation.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoTranslation.html
https://root.cern/root/html528/TGeoTranslation.html:6988,Modifiability,variab,variable,6988,"th2,phi2, th3,phi3); This is a rotation defined in GEANT3 style. Theta and phi are the spherical; angles of each axis of the rotated coordinate system with respect to the; initial one. This construction allows definition of malformed rotations,; e.g. not orthogonal. A check is performed and an error message is issued; in this case. Specific utilities : determinant, inverse. 3. Scale transformations - represent a scale shrinking/enlargement. Data; members :Double_t fScale[3]. Not fully implemented yet. 4. Combined transformations - represent a rotation folowed by a translation.; Data members: Double_t fTranslation[3], TGeoRotation *fRotation.; TGeoRotation *rot = new TGeoRotation(""rot"",10,20,30);; TGeoTranslation trans;. TGeoCombiTrans *c1 = new TGeoCombiTrans(trans, rot);; TGeoCombiTrans *c2 = new TGeoCombiTrans(""somename"",10,20,30,rot). 5. TGeoGenTrans - combined transformations including a scale. Not implemented.; 6. TGeoIdentity - a generic singleton matrix representing a identity transformation; NOTE: identified by the global variable gGeoIdentity. Function Members (Methods); public:. TGeoTranslation(); TGeoTranslation(const TGeoTranslation& other); TGeoTranslation(const TGeoMatrix& other); TGeoTranslation(Double_t dx, Double_t dy, Double_t dz); TGeoTranslation(const char* name, Double_t dx, Double_t dy, Double_t dz); virtual~TGeoTranslation(); voidTObject::AbstractMethod(const char* method) const; voidAdd(const TGeoTranslation* other); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Optio",MatchSource.WIKI,root/html528/TGeoTranslation.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoTranslation.html
https://root.cern/root/html528/TGeoTranslation.html:493,Performance,optimiz,optimize,493,". TGeoTranslation. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GEOM; » GEOM; » TGeoTranslation. class TGeoTranslation: public TGeoMatrix. Geometrical transformation package. All geometrical transformations handled by the modeller are provided as a; built-in package. This was designed to minimize memory requirements and; optimize performance of point/vector master-to-local and local-to-master; computation. We need to have in mind that a transformation in TGeo has 2; major use-cases. The first one is for defining the placement of a volume; with respect to its container reference frame. This frame will be called; 'master' and the frame of the positioned volume - 'local'. If T is a; transformation used for positioning volume daughters, then:. MASTER = T * LOCAL. Therefore a local-to-master conversion will be performed by using T, while; a master-to-local by using its inverse. The second use case is the computation; of the global transformation of a given object in the geometry. Since the; geometry is built as 'volumes-inside-volumes', this global transformation; represent the pile-up of all local transformations in the corresponding; branch. The conversion from the global reference frame and the given object; is also called master-to-local, but it is handled by the manager class.; A general homogenous transformation is defined as a 4x4 matrix embeeding; a rotation, a translation and a scale. The advantage of this description; is that each basic transformation can be represented as a homogenous matrix,; composition being performed as simple matrix multiplication.; Rotation: Inverse rotation:; r11 r12 r13 0 r11 r21 r31 0; r21 r22 r23 0 r12 r22 r32 0; r31 r32 r33 0 r13 r23 r33 0; 0 0 0 1 0 0 0 1. Translation: Inverse translation:; 1 0 0 tx 1 0 0 -tx; 0 1 0 ty 0 1 0 -ty; 0 0 1 tz 0 0 1 -tz; 0 0 0 1 0 0 0 1.",MatchSource.WIKI,root/html528/TGeoTranslation.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoTranslation.html
https://root.cern/root/html528/TGeoTranslation.html:502,Performance,perform,performance,502,". TGeoTranslation. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GEOM; » GEOM; » TGeoTranslation. class TGeoTranslation: public TGeoMatrix. Geometrical transformation package. All geometrical transformations handled by the modeller are provided as a; built-in package. This was designed to minimize memory requirements and; optimize performance of point/vector master-to-local and local-to-master; computation. We need to have in mind that a transformation in TGeo has 2; major use-cases. The first one is for defining the placement of a volume; with respect to its container reference frame. This frame will be called; 'master' and the frame of the positioned volume - 'local'. If T is a; transformation used for positioning volume daughters, then:. MASTER = T * LOCAL. Therefore a local-to-master conversion will be performed by using T, while; a master-to-local by using its inverse. The second use case is the computation; of the global transformation of a given object in the geometry. Since the; geometry is built as 'volumes-inside-volumes', this global transformation; represent the pile-up of all local transformations in the corresponding; branch. The conversion from the global reference frame and the given object; is also called master-to-local, but it is handled by the manager class.; A general homogenous transformation is defined as a 4x4 matrix embeeding; a rotation, a translation and a scale. The advantage of this description; is that each basic transformation can be represented as a homogenous matrix,; composition being performed as simple matrix multiplication.; Rotation: Inverse rotation:; r11 r12 r13 0 r11 r21 r31 0; r21 r22 r23 0 r12 r22 r32 0; r31 r32 r33 0 r13 r23 r33 0; 0 0 0 1 0 0 0 1. Translation: Inverse translation:; 1 0 0 tx 1 0 0 -tx; 0 1 0 ty 0 1 0 -ty; 0 0 1 tz 0 0 1 -tz; 0 0 0 1 0 0 0 1.",MatchSource.WIKI,root/html528/TGeoTranslation.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoTranslation.html
https://root.cern/root/html528/TGeoTranslation.html:987,Performance,perform,performed,987,". TGeoTranslation. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GEOM; » GEOM; » TGeoTranslation. class TGeoTranslation: public TGeoMatrix. Geometrical transformation package. All geometrical transformations handled by the modeller are provided as a; built-in package. This was designed to minimize memory requirements and; optimize performance of point/vector master-to-local and local-to-master; computation. We need to have in mind that a transformation in TGeo has 2; major use-cases. The first one is for defining the placement of a volume; with respect to its container reference frame. This frame will be called; 'master' and the frame of the positioned volume - 'local'. If T is a; transformation used for positioning volume daughters, then:. MASTER = T * LOCAL. Therefore a local-to-master conversion will be performed by using T, while; a master-to-local by using its inverse. The second use case is the computation; of the global transformation of a given object in the geometry. Since the; geometry is built as 'volumes-inside-volumes', this global transformation; represent the pile-up of all local transformations in the corresponding; branch. The conversion from the global reference frame and the given object; is also called master-to-local, but it is handled by the manager class.; A general homogenous transformation is defined as a 4x4 matrix embeeding; a rotation, a translation and a scale. The advantage of this description; is that each basic transformation can be represented as a homogenous matrix,; composition being performed as simple matrix multiplication.; Rotation: Inverse rotation:; r11 r12 r13 0 r11 r21 r31 0; r21 r22 r23 0 r12 r22 r32 0; r31 r32 r33 0 r13 r23 r33 0; 0 0 0 1 0 0 0 1. Translation: Inverse translation:; 1 0 0 tx 1 0 0 -tx; 0 1 0 ty 0 1 0 -ty; 0 0 1 tz 0 0 1 -tz; 0 0 0 1 0 0 0 1.",MatchSource.WIKI,root/html528/TGeoTranslation.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoTranslation.html
https://root.cern/root/html528/TGeoTranslation.html:1713,Performance,perform,performed,1713,"one is for defining the placement of a volume; with respect to its container reference frame. This frame will be called; 'master' and the frame of the positioned volume - 'local'. If T is a; transformation used for positioning volume daughters, then:. MASTER = T * LOCAL. Therefore a local-to-master conversion will be performed by using T, while; a master-to-local by using its inverse. The second use case is the computation; of the global transformation of a given object in the geometry. Since the; geometry is built as 'volumes-inside-volumes', this global transformation; represent the pile-up of all local transformations in the corresponding; branch. The conversion from the global reference frame and the given object; is also called master-to-local, but it is handled by the manager class.; A general homogenous transformation is defined as a 4x4 matrix embeeding; a rotation, a translation and a scale. The advantage of this description; is that each basic transformation can be represented as a homogenous matrix,; composition being performed as simple matrix multiplication.; Rotation: Inverse rotation:; r11 r12 r13 0 r11 r21 r31 0; r21 r22 r23 0 r12 r22 r32 0; r31 r32 r33 0 r13 r23 r33 0; 0 0 0 1 0 0 0 1. Translation: Inverse translation:; 1 0 0 tx 1 0 0 -tx; 0 1 0 ty 0 1 0 -ty; 0 0 1 tz 0 0 1 -tz; 0 0 0 1 0 0 0 1. Scale: Inverse scale:; sx 0 0 0 1/sx 0 0 0; 0 sy 0 0 0 1/sy 0 0; 0 0 sz 0 0 0 1/sz 0; 0 0 0 1 0 0 0 1. where: rij are the 3x3 rotation matrix components,; tx, ty, tz are the translation components; sx, sy, sz are arbitrary scale constants on the eacks axis,. The disadvantage in using this approach is that computation for 4x4 matrices; is expensive. Even combining two translation would become a multiplication; of their corresponding matrices, which is quite an undesired effect. On the; other hand, it is not a good idea to store a translation as a block of 16; numbers. We have therefore chosen to implement each basic transformation type; as a class deriving fr",MatchSource.WIKI,root/html528/TGeoTranslation.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoTranslation.html
https://root.cern/root/html528/TGeoTranslation.html:6220,Performance,perform,performed,6220,"dy,dz) translation. Data members:; Double_t fTranslation[3]. Translations can be added/subtracted.; TGeoTranslation t1;; t1->SetTranslation(-5,10,4);; TGeoTranslation *t2 = new TGeoTranslation(4,3,10);; t2->Subtract(&t1);. 2. Rotations - represent a pure rotation. Data members: Double_t fRotationMatrix[3*3].; Rotations can be defined either by Euler angles, either, by GEANT3 angles :; TGeoRotation *r1 = new TGeoRotation();; r1->SetAngles(phi, theta, psi); // all angles in degrees; This represent the composition of : first a rotation about Z axis with; angle phi, then a rotation with theta about the rotated X axis, and; finally a rotation with psi about the new Z axis. r1->SetAngles(th1,phi1, th2,phi2, th3,phi3); This is a rotation defined in GEANT3 style. Theta and phi are the spherical; angles of each axis of the rotated coordinate system with respect to the; initial one. This construction allows definition of malformed rotations,; e.g. not orthogonal. A check is performed and an error message is issued; in this case. Specific utilities : determinant, inverse. 3. Scale transformations - represent a scale shrinking/enlargement. Data; members :Double_t fScale[3]. Not fully implemented yet. 4. Combined transformations - represent a rotation folowed by a translation.; Data members: Double_t fTranslation[3], TGeoRotation *fRotation.; TGeoRotation *rot = new TGeoRotation(""rot"",10,20,30);; TGeoTranslation trans;. TGeoCombiTrans *c1 = new TGeoCombiTrans(trans, rot);; TGeoCombiTrans *c2 = new TGeoCombiTrans(""somename"",10,20,30,rot). 5. TGeoGenTrans - combined transformations including a scale. Not implemented.; 6. TGeoIdentity - a generic singleton matrix representing a identity transformation; NOTE: identified by the global variable gGeoIdentity. Function Members (Methods); public:. TGeoTranslation(); TGeoTranslation(const TGeoTranslation& other); TGeoTranslation(const TGeoMatrix& other); TGeoTranslation(Double_t dx, Double_t dy, Double_t dz); TGeoTranslation(const char* na",MatchSource.WIKI,root/html528/TGeoTranslation.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoTranslation.html
https://root.cern/root/html528/TGeoTranslation.html:1726,Usability,simpl,simple,1726,"one is for defining the placement of a volume; with respect to its container reference frame. This frame will be called; 'master' and the frame of the positioned volume - 'local'. If T is a; transformation used for positioning volume daughters, then:. MASTER = T * LOCAL. Therefore a local-to-master conversion will be performed by using T, while; a master-to-local by using its inverse. The second use case is the computation; of the global transformation of a given object in the geometry. Since the; geometry is built as 'volumes-inside-volumes', this global transformation; represent the pile-up of all local transformations in the corresponding; branch. The conversion from the global reference frame and the given object; is also called master-to-local, but it is handled by the manager class.; A general homogenous transformation is defined as a 4x4 matrix embeeding; a rotation, a translation and a scale. The advantage of this description; is that each basic transformation can be represented as a homogenous matrix,; composition being performed as simple matrix multiplication.; Rotation: Inverse rotation:; r11 r12 r13 0 r11 r21 r31 0; r21 r22 r23 0 r12 r22 r32 0; r31 r32 r33 0 r13 r23 r33 0; 0 0 0 1 0 0 0 1. Translation: Inverse translation:; 1 0 0 tx 1 0 0 -tx; 0 1 0 ty 0 1 0 -ty; 0 0 1 tz 0 0 1 -tz; 0 0 0 1 0 0 0 1. Scale: Inverse scale:; sx 0 0 0 1/sx 0 0 0; 0 sy 0 0 0 1/sy 0 0; 0 0 sz 0 0 0 1/sz 0; 0 0 0 1 0 0 0 1. where: rij are the 3x3 rotation matrix components,; tx, ty, tz are the translation components; sx, sy, sz are arbitrary scale constants on the eacks axis,. The disadvantage in using this approach is that computation for 4x4 matrices; is expensive. Even combining two translation would become a multiplication; of their corresponding matrices, which is quite an undesired effect. On the; other hand, it is not a good idea to store a translation as a block of 16; numbers. We have therefore chosen to implement each basic transformation type; as a class deriving fr",MatchSource.WIKI,root/html528/TGeoTranslation.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoTranslation.html
https://root.cern/root/html528/TGeoTranslationEditor.html:4723,Availability,error,error,4723,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const;",MatchSource.WIKI,root/html528/TGeoTranslationEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoTranslationEditor.html
https://root.cern/root/html528/TGeoTranslationEditor.html:4807,Availability,error,error,4807,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType() c",MatchSource.WIKI,root/html528/TGeoTranslationEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoTranslationEditor.html
https://root.cern/root/html528/TGeoTranslationEditor.html:17709,Availability,mask,mask,17709,,MatchSource.WIKI,root/html528/TGeoTranslationEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoTranslationEditor.html
https://root.cern/root/html528/TGeoTranslationEditor.html:21285,Usability,undo,undoing,21285,"e y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoTranslationEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor for translation editor. ~TGeoTranslationEditor(); Destructor. void ConnectSignals2Slots(); Connect signals to slots. void SetModel(TObject* obj); Connect to the new matrix. void DoName(); Slot for name. Bool_t DoParameters(); Slot for checking parameters. void DoApply(); Slot for applying changes. void DoCancel(); Slot for cancelling last modifications non-applied. void DoModified(); Slot for notifying changes. void DoUndo(); Slot for undoing last operation. void DoDx(); Slot for dx. void DoDy(); Slot for dx. void DoDz(); Slot for dx. » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id: TGeoMatrixEditor.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2010-09-23 20:09; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html528/TGeoTranslationEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoTranslationEditor.html
https://root.cern/root/html528/TGeoTrap.html:3864,Availability,error,error,3864,"_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); Double_tTGeoArb8::DistToPlane(Double_t* point, Double_t* dir, Int_t ipl, Bool_t in) const; virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tGetAlpha1() const; Double_tGetAlpha2() const; virtual const char*TGeoBBox::GetAxisName(Int_t iaxis) const; virtual Double_tTGeoArb8::GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; Double_tGetBl1() const; Double_tGetBl2() const; virtual voidTGeoArb8::GetBoundingCylinder(Double_t* param) const; virtual const TBuffer3D&TGeoBBox::GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; virtual Int_tTGeoArb8::GetByteCount() const; Double_tTGeoArb8::GetClosestEdge(Double_t* point, Double_t* vert, Int_t& isegment) const; virtual Option_t*TObject::GetDrawOption() const;",MatchSource.WIKI,root/html528/TGeoTrap.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoTrap.html
https://root.cern/root/html528/TGeoTrap.html:3948,Availability,error,error,3948,"uble_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); Double_tTGeoArb8::DistToPlane(Double_t* point, Double_t* dir, Int_t ipl, Bool_t in) const; virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tGetAlpha1() const; Double_tGetAlpha2() const; virtual const char*TGeoBBox::GetAxisName(Int_t iaxis) const; virtual Double_tTGeoArb8::GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; Double_tGetBl1() const; Double_tGetBl2() const; virtual voidTGeoArb8::GetBoundingCylinder(Double_t* param) const; virtual const TBuffer3D&TGeoBBox::GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; virtual Int_tTGeoArb8::GetByteCount() const; Double_tTGeoArb8::GetClosestEdge(Double_t* point, Double_t* vert, Int_t& isegment) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_tTGeoBBox::GetDX() const; virtu",MatchSource.WIKI,root/html528/TGeoTrap.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoTrap.html
https://root.cern/root/html528/TGeoTrap.html:2924,Safety,safe,safe,2924,"GeoMatrix* mat2); static Double_tTGeoShape::Big(); virtual voidTObject::Browse(TBrowser* b); virtual Double_tTGeoArb8::Capacity() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTGeoArb8::ComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidTGeoArb8::ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); voidTGeoArb8::ComputeTwist(); virtual Bool_tTGeoArb8::Contains(Double_t* point) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(Double_t* point, Double_t* dir) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTGeoBBox::DistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); Double_tTGeoArb8::DistToPlane(Double_t* point, Double_t* dir, Int_t ipl, Bool_t in) const; virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjA",MatchSource.WIKI,root/html528/TGeoTrap.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoTrap.html
https://root.cern/root/html528/TGeoTrap.html:3065,Safety,safe,safe,3065,"ic TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTGeoArb8::ComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidTGeoArb8::ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); voidTGeoArb8::ComputeTwist(); virtual Bool_tTGeoArb8::Contains(Double_t* point) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(Double_t* point, Double_t* dir) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTGeoBBox::DistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); Double_tTGeoArb8::DistToPlane(Double_t* point, Double_t* dir, Int_t ipl, Bool_t in) const; virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char*",MatchSource.WIKI,root/html528/TGeoTrap.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoTrap.html
https://root.cern/root/html528/TGeoTrap.html:14612,Safety,safe,safe,14612,"le; TStringTNamed::fTitleobject title; Double_tfTl1half length in x at low z and y high edge; Double_tfTl2half length in x at high z and y high edge; Double_t*TGeoArb8::fTwist! [4] tangents of twist angles ; Double_tTGeoArb8::fXY[8][2]list of vertices. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoTrap(); Default ctor. TGeoTrap(Double_t dz, Double_t theta, Double_t phi); Constructor providing just a range in Z, theta and phi. TGeoTrap(Double_t dz, Double_t theta, Double_t phi, Double_t h1, Double_t bl1, Double_t tl1, Double_t alpha1, Double_t h2, Double_t bl2, Double_t tl2, Double_t alpha2); Normal constructor. TGeoTrap(const char* name, Double_t dz, Double_t theta, Double_t phi, Double_t h1, Double_t bl1, Double_t tl1, Double_t alpha1, Double_t h2, Double_t bl2, Double_t tl2, Double_t alpha2); Constructor with name. ~TGeoTrap(); destructor. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the trapezoid. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from outside point to surface of the trapezoid. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); --- Divide this trapezoid shape belonging to volume ""voldiv"" into ndiv volumes; called divname, from start position with the given step. Only Z divisions; are supported. For Z divisions just return the pointer to the volume to be; divided. In case a wrong division axis is supplied, returns pointer to; volume that was divided. TGeoShape * GetMakeRuntimeShape(TGeoShape* mother, TGeoMatrix* mat) const; In case shape has some negative parameters, these have to be computed; in order to fit the mother. Double_t Safety(Double_t* point, Bool_t in = kTRUE) const; Computes the closest di",MatchSource.WIKI,root/html528/TGeoTrap.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoTrap.html
https://root.cern/root/html528/TGeoTrap.html:14810,Safety,safe,safe,14810," angles ; Double_tTGeoArb8::fXY[8][2]list of vertices. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoTrap(); Default ctor. TGeoTrap(Double_t dz, Double_t theta, Double_t phi); Constructor providing just a range in Z, theta and phi. TGeoTrap(Double_t dz, Double_t theta, Double_t phi, Double_t h1, Double_t bl1, Double_t tl1, Double_t alpha1, Double_t h2, Double_t bl2, Double_t tl2, Double_t alpha2); Normal constructor. TGeoTrap(const char* name, Double_t dz, Double_t theta, Double_t phi, Double_t h1, Double_t bl1, Double_t tl1, Double_t alpha1, Double_t h2, Double_t bl2, Double_t tl2, Double_t alpha2); Constructor with name. ~TGeoTrap(); destructor. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the trapezoid. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from outside point to surface of the trapezoid. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); --- Divide this trapezoid shape belonging to volume ""voldiv"" into ndiv volumes; called divname, from start position with the given step. Only Z divisions; are supported. For Z divisions just return the pointer to the volume to be; divided. In case a wrong division axis is supplied, returns pointer to; volume that was divided. TGeoShape * GetMakeRuntimeShape(TGeoShape* mother, TGeoMatrix* mat) const; In case shape has some negative parameters, these have to be computed; in order to fit the mother. Double_t Safety(Double_t* point, Bool_t in = kTRUE) const; Computes the closest distance from given point to this shape. void SavePrimitive(ostream& out, Option_t* option = """"); Save a primitive as a C++ statement(s) on output stream ""out"". void SetDimensions(Double_t* param); Se",MatchSource.WIKI,root/html528/TGeoTrap.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoTrap.html
https://root.cern/root/html528/TGeoTrapEditor.html:4671,Availability,error,error,4671,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const;",MatchSource.WIKI,root/html528/TGeoTrapEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoTrapEditor.html
https://root.cern/root/html528/TGeoTrapEditor.html:4755,Availability,error,error,4755,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType() c",MatchSource.WIKI,root/html528/TGeoTrapEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoTrapEditor.html
https://root.cern/root/html528/TGeoTrapEditor.html:18296,Availability,mask,mask,18296,"nges; Bool_tTGedFrame::fAvoidSignalflag for executing slots; TGCompositeFrame*fBFrameFrame containing Apply/Undo; Pixel_tTGFrame::fBackgroundframe background color; Double_tfBl1iInitial half length in x at low z and y low edge; Int_tTGFrame::fBorderWidthframe border width; TGClient*TGObject::fClientConnection to display server; TGCompositeFrame*fDFrameFrame containing Delayed draw; Int_tTGFrame::fDNDStateEDNDFlags; TGCheckButton*fDelayedCheck button for delayed draw; Double_tfDziInitial Dz; TGNumberEntry*fEAlpha1Number entry for Alpha1; TGNumberEntry*fEBl1Number entry for Bl1; TGNumberEntry*fEDzNumber entry for DZ; TGNumberEntry*fEH1Number entry for H1 ; TGNumberEntry*fEPhiNumber entry for Theta ; TGNumberEntry*fESc1Number entry for lower scale; TGNumberEntry*fESc2Number entry for upper scale; TGNumberEntry*fEThetaNumber entry for Theta ; TGNumberEntry*fETl1Number entry for Tl1; UInt_tTGWindow::fEditDisabledflags used for ""guibuilding""; UInt_tTGFrame::fEventMaskcurrenty active event mask; TList*TGedFrame::fExtraTabsaddtional tabs in ged editor; TGFrameElement*TGFrame::fFEpointer to frame element; TGedEditor*TGedFrame::fGedEditormanager of this frame; Double_tfH1iInitial half length in y at low z; UInt_tTGFrame::fHeightframe height; Handle_tTGObject::fIdX11/Win32 Window identifier; Bool_tTGedFrame::fInitinit flag for setting signals/slots; Bool_tfIsModifiedFlag that volume was modified; Bool_tfIsShapeEditableFlag that the shape can be changed; Bool_tTGCompositeFrame::fLayoutBrokenno layout manager is used; TGLayoutManager*TGCompositeFrame::fLayoutManagerlayout manager; TList*TGCompositeFrame::fListcontainer of frame elements; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Bool_tTGCompositeFrame::fMapSubwindowskTRUE - map subwindows; UInt_tTGFrame::fMaxHeightmaximal frame height; UInt_tTGFrame::fMaxWidthmaximal frame width; UInt_tTGFrame::fMinHeightminimal frame height; UInt_tTGF",MatchSource.WIKI,root/html528/TGeoTrapEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoTrapEditor.html
https://root.cern/root/html528/TGeoTrapEditor.html:21872,Usability,undo,undoing,21872,"GC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoTrapEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor for para editor. ~TGeoTrapEditor(); Destructor. void ConnectSignals2Slots(); Connect signals to slots. void SetModel(TObject* obj); Connect to the selected object. Bool_t IsDelayed() const; Check if shape drawing is delayed. void DoName(); Slot for name. void DoApply(); Slot for applying current settings. void DoModified(); Slot for notifying modifications. void DoUndo(); Slot for undoing last operation. void DoH1(); Slot for H1. void DoBl1(); Slot for Bl1. void DoTl1(); Slot for Tl1. void DoDz(); Slot for Z. void DoSc1(); Slot for H2. void DoSc2(); Slot for H2. void DoAlpha1(); Slot for alpha1. void DoTheta(); Slot for theta. void DoPhi(); Slot for phi. » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id: TGeoTrapEditor.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2010-09-23 20:09; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html528/TGeoTrapEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoTrapEditor.html
https://root.cern/root/html528/TGeoTrd1.html:2748,Availability,error,error,2748,"ive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const char*TGeoBBox::GetAxisName(Int_t iaxis) const; virtual Double_tGetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; virtual voidGetBoundingCylinder(Double_t* param) const; virtual const TBuffer3D&TGeoBBox::GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; virtual Int_tGetByteCount() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_tTGeoBBox::GetDX() const; Double_tGetDx1() const; Double_tGetDx2() const; Double_tGetDy() const; virtual Double_tTGeoBBox::GetDY() const; Double_tGetDz() const; virtual ",MatchSource.WIKI,root/html528/TGeoTrd1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoTrd1.html
https://root.cern/root/html528/TGeoTrd1.html:2832,Availability,error,error,2832,"ir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const char*TGeoBBox::GetAxisName(Int_t iaxis) const; virtual Double_tGetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; virtual voidGetBoundingCylinder(Double_t* param) const; virtual const TBuffer3D&TGeoBBox::GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; virtual Int_tGetByteCount() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_tTGeoBBox::GetDX() const; Double_tGetDx1() const; Double_tGetDx2() const; Double_tGetDy() const; virtual Double_tTGeoBBox::GetDY() const; Double_tGetDz() const; virtual Double_tTGeoBBox::GetDZ() const; virtual Double_tTGeoBBox::GetFacetArea(Int_t index ",MatchSource.WIKI,root/html528/TGeoTrd1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoTrd1.html
https://root.cern/root/html528/TGeoTrd1.html:1899,Safety,safe,safe,1899," TGeoBBox* box1, const TGeoMatrix* mat1, const TGeoBBox* box2, const TGeoMatrix* mat2); static Double_tTGeoShape::Big(); virtual voidTObject::Browse(TBrowser* b); virtual Double_tCapacity() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); virtual Bool_tContains(Double_t* point) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(Double_t* point, Double_t* dir) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTGeoBBox::DistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px,",MatchSource.WIKI,root/html528/TGeoTrd1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoTrd1.html
https://root.cern/root/html528/TGeoTrd1.html:2040,Safety,safe,safe,2040,":Browse(TBrowser* b); virtual Double_tCapacity() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); virtual Bool_tContains(Double_t* point) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(Double_t* point, Double_t* dir) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTGeoBBox::DistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual ",MatchSource.WIKI,root/html528/TGeoTrd1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoTrd1.html
https://root.cern/root/html528/TGeoTrd1.html:12360,Safety,safe,safe,12360,"gin[3]box origin; UInt_tTGeoShape::fShapeBitsshape bits; Int_tTGeoShape::fShapeIdshape id; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoTrd1(); dummy ctor. TGeoTrd1(Double_t dx1, Double_t dx2, Double_t dy, Double_t dz); constructor. TGeoTrd1(const char* name, Double_t dx1, Double_t dx2, Double_t dy, Double_t dz); constructor. TGeoTrd1(Double_t* params); ctor with an array of parameters; param[0] = dx1; param[1] = dx2; param[2] = dy; param[3] = dz. ~TGeoTrd1(); destructor. Double_t Capacity() const; Computes capacity of the shape in [length^3]. void ComputeBBox(); compute bounding box for a trd1. void ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. Bool_t Contains(Double_t* point) const; test if point is inside this shape; check Z range. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the trd1; Boundary safe algorithm. void GetVisibleCorner(Double_t* point, Double_t* vertex, Double_t* normals) const; get the most visible corner from outside point and the normals. void GetOppositeCorner(Double_t* point, Int_t inorm, Double_t* vertex, Double_t* normals) const; get the opposite corner of the intersected face. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from outside point to surface of the trd1; Boundary safe algorithm. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); --- Divide this trd1 shape belonging to volume ""voldiv"" into ndiv volumes; called divname, from start position with the given step. Returns pointer; to created division cell volume in case of Y divisions. For Z divisions just; return the pointer to the volume t",MatchSource.WIKI,root/html528/TGeoTrd1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoTrd1.html
https://root.cern/root/html528/TGeoTrd1.html:12445,Safety,safe,safe,12445,"gin[3]box origin; UInt_tTGeoShape::fShapeBitsshape bits; Int_tTGeoShape::fShapeIdshape id; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoTrd1(); dummy ctor. TGeoTrd1(Double_t dx1, Double_t dx2, Double_t dy, Double_t dz); constructor. TGeoTrd1(const char* name, Double_t dx1, Double_t dx2, Double_t dy, Double_t dz); constructor. TGeoTrd1(Double_t* params); ctor with an array of parameters; param[0] = dx1; param[1] = dx2; param[2] = dy; param[3] = dz. ~TGeoTrd1(); destructor. Double_t Capacity() const; Computes capacity of the shape in [length^3]. void ComputeBBox(); compute bounding box for a trd1. void ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. Bool_t Contains(Double_t* point) const; test if point is inside this shape; check Z range. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the trd1; Boundary safe algorithm. void GetVisibleCorner(Double_t* point, Double_t* vertex, Double_t* normals) const; get the most visible corner from outside point and the normals. void GetOppositeCorner(Double_t* point, Int_t inorm, Double_t* vertex, Double_t* normals) const; get the opposite corner of the intersected face. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from outside point to surface of the trd1; Boundary safe algorithm. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); --- Divide this trd1 shape belonging to volume ""voldiv"" into ndiv volumes; called divname, from start position with the given step. Returns pointer; to created division cell volume in case of Y divisions. For Z divisions just; return the pointer to the volume t",MatchSource.WIKI,root/html528/TGeoTrd1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoTrd1.html
https://root.cern/root/html528/TGeoTrd1.html:12871,Safety,safe,safe,12871,"m[2] = dy; param[3] = dz. ~TGeoTrd1(); destructor. Double_t Capacity() const; Computes capacity of the shape in [length^3]. void ComputeBBox(); compute bounding box for a trd1. void ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. Bool_t Contains(Double_t* point) const; test if point is inside this shape; check Z range. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the trd1; Boundary safe algorithm. void GetVisibleCorner(Double_t* point, Double_t* vertex, Double_t* normals) const; get the most visible corner from outside point and the normals. void GetOppositeCorner(Double_t* point, Int_t inorm, Double_t* vertex, Double_t* normals) const; get the opposite corner of the intersected face. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from outside point to surface of the trd1; Boundary safe algorithm. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); --- Divide this trd1 shape belonging to volume ""voldiv"" into ndiv volumes; called divname, from start position with the given step. Returns pointer; to created division cell volume in case of Y divisions. For Z divisions just; return the pointer to the volume to be divided. In case a wrong; division axis is supplied, returns pointer to volume that was divided. Double_t GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; Get range of shape for a given axis. void GetBoundingCylinder(Double_t* param) const; --- Fill vector param[4] with the bounding cylinder parameters. The order; is the following : Rmin, Rmax, Phi1, Phi2. Int_t GetFittingBox(const TGeoBBox* parambox, TGeoMatrix* mat, Double_t& dx, Double_t& dy, Double_t& dz) const; Fills real parameters",MatchSource.WIKI,root/html528/TGeoTrd1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoTrd1.html
https://root.cern/root/html528/TGeoTrd1.html:12957,Safety,safe,safe,12957,"m[2] = dy; param[3] = dz. ~TGeoTrd1(); destructor. Double_t Capacity() const; Computes capacity of the shape in [length^3]. void ComputeBBox(); compute bounding box for a trd1. void ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. Bool_t Contains(Double_t* point) const; test if point is inside this shape; check Z range. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the trd1; Boundary safe algorithm. void GetVisibleCorner(Double_t* point, Double_t* vertex, Double_t* normals) const; get the most visible corner from outside point and the normals. void GetOppositeCorner(Double_t* point, Int_t inorm, Double_t* vertex, Double_t* normals) const; get the opposite corner of the intersected face. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from outside point to surface of the trd1; Boundary safe algorithm. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); --- Divide this trd1 shape belonging to volume ""voldiv"" into ndiv volumes; called divname, from start position with the given step. Returns pointer; to created division cell volume in case of Y divisions. For Z divisions just; return the pointer to the volume to be divided. In case a wrong; division axis is supplied, returns pointer to volume that was divided. Double_t GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; Get range of shape for a given axis. void GetBoundingCylinder(Double_t* param) const; --- Fill vector param[4] with the bounding cylinder parameters. The order; is the following : Rmin, Rmax, Phi1, Phi2. Int_t GetFittingBox(const TGeoBBox* parambox, TGeoMatrix* mat, Double_t& dx, Double_t& dy, Double_t& dz) const; Fills real parameters",MatchSource.WIKI,root/html528/TGeoTrd1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoTrd1.html
https://root.cern/root/html528/TGeoTrd1.html:12193,Testability,test,test,12193,"th in X at higher Z surface (+dz); Double_tfDyhalf length in Y; Double_tfDzhalf length in Z; TStringTNamed::fNameobject identifier; Double_tTGeoBBox::fOrigin[3]box origin; UInt_tTGeoShape::fShapeBitsshape bits; Int_tTGeoShape::fShapeIdshape id; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoTrd1(); dummy ctor. TGeoTrd1(Double_t dx1, Double_t dx2, Double_t dy, Double_t dz); constructor. TGeoTrd1(const char* name, Double_t dx1, Double_t dx2, Double_t dy, Double_t dz); constructor. TGeoTrd1(Double_t* params); ctor with an array of parameters; param[0] = dx1; param[1] = dx2; param[2] = dy; param[3] = dz. ~TGeoTrd1(); destructor. Double_t Capacity() const; Computes capacity of the shape in [length^3]. void ComputeBBox(); compute bounding box for a trd1. void ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. Bool_t Contains(Double_t* point) const; test if point is inside this shape; check Z range. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the trd1; Boundary safe algorithm. void GetVisibleCorner(Double_t* point, Double_t* vertex, Double_t* normals) const; get the most visible corner from outside point and the normals. void GetOppositeCorner(Double_t* point, Int_t inorm, Double_t* vertex, Double_t* normals) const; get the opposite corner of the intersected face. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from outside point to surface of the trd1; Boundary safe algorithm. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); --- Divide this trd1 shape belonging to volume ""voldiv"" into ndiv volumes; called divname, from start posit",MatchSource.WIKI,root/html528/TGeoTrd1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoTrd1.html
https://root.cern/root/html528/TGeoTrd1Editor.html:4585,Availability,error,error,4585,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const;",MatchSource.WIKI,root/html528/TGeoTrd1Editor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoTrd1Editor.html
https://root.cern/root/html528/TGeoTrd1Editor.html:4669,Availability,error,error,4669,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType() c",MatchSource.WIKI,root/html528/TGeoTrd1Editor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoTrd1Editor.html
https://root.cern/root/html528/TGeoTrd1Editor.html:17803,Availability,mask,mask,17803,,MatchSource.WIKI,root/html528/TGeoTrd1Editor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoTrd1Editor.html
https://root.cern/root/html528/TGeoTrd1Editor.html:21166,Usability,undo,undoing,21166," position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoTrd1Editor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor for trd1 editor. ~TGeoTrd1Editor(); Destructor. void ConnectSignals2Slots(); Connect signals to slots. void SetModel(TObject* obj); Connect to the selected object. Bool_t IsDelayed() const; Check if shape drawing is delayed. void DoName(); Perform name change. void DoApply(); Slot for applying modifications. void DoModified(); Slot for signaling modifications. void DoUndo(); Slot for undoing last operation. void DoDx1(); Slot for dx1. void DoDx2(); Slot for dx2. void DoDy(); Slot for dy. void DoDz(); Slot for dz. » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id: TGeoTrd1Editor.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2010-09-23 20:09; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html528/TGeoTrd1Editor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoTrd1Editor.html
https://root.cern/root/html528/TGeoTrd2.html:2789,Availability,error,error,2789,"ive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const char*TGeoBBox::GetAxisName(Int_t iaxis) const; virtual Double_tGetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; virtual voidGetBoundingCylinder(Double_t* param) const; virtual const TBuffer3D&TGeoBBox::GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; virtual Int_tGetByteCount() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_tTGeoBBox::GetDX() const; Double_tGetDx1() const; Double_tGetDx2() const; virtual Double_tTGeoBBox::GetDY() const; Double_tGetDy1() const; Double_tGetDy2() const; Double",MatchSource.WIKI,root/html528/TGeoTrd2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoTrd2.html
https://root.cern/root/html528/TGeoTrd2.html:2873,Availability,error,error,2873,"ir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const char*TGeoBBox::GetAxisName(Int_t iaxis) const; virtual Double_tGetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; virtual voidGetBoundingCylinder(Double_t* param) const; virtual const TBuffer3D&TGeoBBox::GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; virtual Int_tGetByteCount() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_tTGeoBBox::GetDX() const; Double_tGetDx1() const; Double_tGetDx2() const; virtual Double_tTGeoBBox::GetDY() const; Double_tGetDy1() const; Double_tGetDy2() const; Double_tGetDz() const; virtual Double_tTGeoBBox::GetDZ() const; virtual Double_tTGeoBBox::",MatchSource.WIKI,root/html528/TGeoTrd2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoTrd2.html
https://root.cern/root/html528/TGeoTrd2.html:1940,Safety,safe,safe,1940," TGeoBBox* box1, const TGeoMatrix* mat1, const TGeoBBox* box2, const TGeoMatrix* mat2); static Double_tTGeoShape::Big(); virtual voidTObject::Browse(TBrowser* b); virtual Double_tCapacity() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); virtual Bool_tContains(Double_t* point) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(Double_t* point, Double_t* dir) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTGeoBBox::DistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px,",MatchSource.WIKI,root/html528/TGeoTrd2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoTrd2.html
https://root.cern/root/html528/TGeoTrd2.html:2081,Safety,safe,safe,2081,":Browse(TBrowser* b); virtual Double_tCapacity() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); virtual Bool_tContains(Double_t* point) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(Double_t* point, Double_t* dir) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTGeoBBox::DistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual ",MatchSource.WIKI,root/html528/TGeoTrd2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoTrd2.html
https://root.cern/root/html528/TGeoTrd2.html:12555,Safety,safe,safe,12555,"ape bits; Int_tTGeoShape::fShapeIdshape id; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoTrd2(); dummy ctor. TGeoTrd2(Double_t dx1, Double_t dx2, Double_t dy1, Double_t dy2, Double_t dz); constructor. TGeoTrd2(const char* name, Double_t dx1, Double_t dx2, Double_t dy1, Double_t dy2, Double_t dz); constructor. TGeoTrd2(Double_t* params); ctor with an array of parameters; param[0] = dx1; param[1] = dx2; param[2] = dy1; param[3] = dy2; param[4] = dz. ~TGeoTrd2(); destructor. Double_t Capacity() const; Computes capacity of the shape in [length^3]. void ComputeBBox(); compute bounding box for a trd2. void ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. Bool_t Contains(Double_t* point) const; test if point is inside this shape; check Z range. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the trd2; Boundary safe algorithm. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from outside point to surface of the trd2; Boundary safe algorithm. Double_t GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; Get range of shape for a given axis. void GetVisibleCorner(Double_t* point, Double_t* vertex, Double_t* normals) const; get the most visible corner from outside point and the normals. void GetOppositeCorner(Double_t* point, Int_t inorm, Double_t* vertex, Double_t* normals) const; get the opposite corner of the intersected face. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); --- Divide this trd2 shape belonging to volume ""voldiv"" into ndiv volumes; called divname, from start position with the given step. Only Z divisions; ar",MatchSource.WIKI,root/html528/TGeoTrd2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoTrd2.html
https://root.cern/root/html528/TGeoTrd2.html:12640,Safety,safe,safe,12640,"ape bits; Int_tTGeoShape::fShapeIdshape id; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoTrd2(); dummy ctor. TGeoTrd2(Double_t dx1, Double_t dx2, Double_t dy1, Double_t dy2, Double_t dz); constructor. TGeoTrd2(const char* name, Double_t dx1, Double_t dx2, Double_t dy1, Double_t dy2, Double_t dz); constructor. TGeoTrd2(Double_t* params); ctor with an array of parameters; param[0] = dx1; param[1] = dx2; param[2] = dy1; param[3] = dy2; param[4] = dz. ~TGeoTrd2(); destructor. Double_t Capacity() const; Computes capacity of the shape in [length^3]. void ComputeBBox(); compute bounding box for a trd2. void ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. Bool_t Contains(Double_t* point) const; test if point is inside this shape; check Z range. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the trd2; Boundary safe algorithm. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from outside point to surface of the trd2; Boundary safe algorithm. Double_t GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; Get range of shape for a given axis. void GetVisibleCorner(Double_t* point, Double_t* vertex, Double_t* normals) const; get the most visible corner from outside point and the normals. void GetOppositeCorner(Double_t* point, Int_t inorm, Double_t* vertex, Double_t* normals) const; get the opposite corner of the intersected face. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); --- Divide this trd2 shape belonging to volume ""voldiv"" into ndiv volumes; called divname, from start position with the given step. Only Z divisions; ar",MatchSource.WIKI,root/html528/TGeoTrd2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoTrd2.html
https://root.cern/root/html528/TGeoTrd2.html:12773,Safety,safe,safe,12773,"ouble_t dx2, Double_t dy1, Double_t dy2, Double_t dz); constructor. TGeoTrd2(const char* name, Double_t dx1, Double_t dx2, Double_t dy1, Double_t dy2, Double_t dz); constructor. TGeoTrd2(Double_t* params); ctor with an array of parameters; param[0] = dx1; param[1] = dx2; param[2] = dy1; param[3] = dy2; param[4] = dz. ~TGeoTrd2(); destructor. Double_t Capacity() const; Computes capacity of the shape in [length^3]. void ComputeBBox(); compute bounding box for a trd2. void ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. Bool_t Contains(Double_t* point) const; test if point is inside this shape; check Z range. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the trd2; Boundary safe algorithm. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from outside point to surface of the trd2; Boundary safe algorithm. Double_t GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; Get range of shape for a given axis. void GetVisibleCorner(Double_t* point, Double_t* vertex, Double_t* normals) const; get the most visible corner from outside point and the normals. void GetOppositeCorner(Double_t* point, Int_t inorm, Double_t* vertex, Double_t* normals) const; get the opposite corner of the intersected face. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); --- Divide this trd2 shape belonging to volume ""voldiv"" into ndiv volumes; called divname, from start position with the given step. Only Z divisions; are supported. For Z divisions just return the pointer to the volume to be; divided. In case a wrong division axis is supplied, returns pointer to; volume that was divided. void GetBoundingCylinder(Double_t* param) const",MatchSource.WIKI,root/html528/TGeoTrd2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoTrd2.html
https://root.cern/root/html528/TGeoTrd2.html:12859,Safety,safe,safe,12859,"ouble_t dx2, Double_t dy1, Double_t dy2, Double_t dz); constructor. TGeoTrd2(const char* name, Double_t dx1, Double_t dx2, Double_t dy1, Double_t dy2, Double_t dz); constructor. TGeoTrd2(Double_t* params); ctor with an array of parameters; param[0] = dx1; param[1] = dx2; param[2] = dy1; param[3] = dy2; param[4] = dz. ~TGeoTrd2(); destructor. Double_t Capacity() const; Computes capacity of the shape in [length^3]. void ComputeBBox(); compute bounding box for a trd2. void ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. Bool_t Contains(Double_t* point) const; test if point is inside this shape; check Z range. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the trd2; Boundary safe algorithm. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from outside point to surface of the trd2; Boundary safe algorithm. Double_t GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; Get range of shape for a given axis. void GetVisibleCorner(Double_t* point, Double_t* vertex, Double_t* normals) const; get the most visible corner from outside point and the normals. void GetOppositeCorner(Double_t* point, Int_t inorm, Double_t* vertex, Double_t* normals) const; get the opposite corner of the intersected face. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); --- Divide this trd2 shape belonging to volume ""voldiv"" into ndiv volumes; called divname, from start position with the given step. Only Z divisions; are supported. For Z divisions just return the pointer to the volume to be; divided. In case a wrong division axis is supplied, returns pointer to; volume that was divided. void GetBoundingCylinder(Double_t* param) const",MatchSource.WIKI,root/html528/TGeoTrd2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoTrd2.html
https://root.cern/root/html528/TGeoTrd2.html:12388,Testability,test,test,12388,"Z surface (+dz); Double_tfDzhalf length in Z; TStringTNamed::fNameobject identifier; Double_tTGeoBBox::fOrigin[3]box origin; UInt_tTGeoShape::fShapeBitsshape bits; Int_tTGeoShape::fShapeIdshape id; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoTrd2(); dummy ctor. TGeoTrd2(Double_t dx1, Double_t dx2, Double_t dy1, Double_t dy2, Double_t dz); constructor. TGeoTrd2(const char* name, Double_t dx1, Double_t dx2, Double_t dy1, Double_t dy2, Double_t dz); constructor. TGeoTrd2(Double_t* params); ctor with an array of parameters; param[0] = dx1; param[1] = dx2; param[2] = dy1; param[3] = dy2; param[4] = dz. ~TGeoTrd2(); destructor. Double_t Capacity() const; Computes capacity of the shape in [length^3]. void ComputeBBox(); compute bounding box for a trd2. void ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. Bool_t Contains(Double_t* point) const; test if point is inside this shape; check Z range. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the trd2; Boundary safe algorithm. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from outside point to surface of the trd2; Boundary safe algorithm. Double_t GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; Get range of shape for a given axis. void GetVisibleCorner(Double_t* point, Double_t* vertex, Double_t* normals) const; get the most visible corner from outside point and the normals. void GetOppositeCorner(Double_t* point, Int_t inorm, Double_t* vertex, Double_t* normals) const; get the opposite corner of the intersected face. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step)",MatchSource.WIKI,root/html528/TGeoTrd2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoTrd2.html
https://root.cern/root/html528/TGeoTrd2Editor.html:4599,Availability,error,error,4599,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const;",MatchSource.WIKI,root/html528/TGeoTrd2Editor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoTrd2Editor.html
https://root.cern/root/html528/TGeoTrd2Editor.html:4683,Availability,error,error,4683,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType() c",MatchSource.WIKI,root/html528/TGeoTrd2Editor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoTrd2Editor.html
https://root.cern/root/html528/TGeoTrd2Editor.html:17888,Availability,mask,mask,17888,,MatchSource.WIKI,root/html528/TGeoTrd2Editor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoTrd2Editor.html
https://root.cern/root/html528/TGeoTrd2Editor.html:21251,Usability,undo,undoing,21251,"me y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoTrd2Editor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor for trd2 editor. ~TGeoTrd2Editor(); Destructor. void ConnectSignals2Slots(); Connect signals to slots. void SetModel(TObject* obj); Connect to the selected object. Bool_t IsDelayed() const; Check if shape drawing is delayed. void DoName(); Perform name change. void DoApply(); Slot for applying modifications. void DoModified(); Slot for signaling modifications. void DoUndo(); Slot for undoing last operation. void DoDx1(); Slot for dx1. void DoDx2(); Slot for dx2. void DoDy1(); Slot for dy1. void DoDy2(); Slot for dy2. void DoDz(); Slot for dz. » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id: TGeoTrd2Editor.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2010-09-23 20:09; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html528/TGeoTrd2Editor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoTrd2Editor.html
https://root.cern/root/html528/TGeoTreeDialog.html:1033,Availability,avail,available,1033,"inks:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GEOM; » GEOMBUILDER; » TGeoTreeDialog. class TGeoTreeDialog: public TGTransientFrame. TGeoTabManager - manager for all editor tabs. TGeoTreeDialog - Base class for dialog frames for selecting objects; with a tree hierarchy. Specific implementations are:; TGeoVolumeDialog - Special tree dialog class for selecting volumes.; TGeoShapeDialog - Special tree dialog class for selecting shapes.; TGeoMediumDialog - Special tree dialog class for selecting media.; TGeoMaterialDialog - Special tree dialog class for selecting materials.; TGeoMatrixDialog - Special tree dialog class for selecting matrices.; TGeoTransientPanel - Special transient tab holding TGeo editors. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TGeoTreeDialog(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual Bool_tTGMainFrame::BindKey(const TGWindow* w, Int_t keycode, Int_t modifier) const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGTransientFrame::CenterOnParent(Bool_t croot = kTRUE, TGTransientFrame::EPlacement pos = kCenter); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidTGCompositeFrame::ChangeSubframesBackground(Pixel_t back); st",MatchSource.WIKI,root/html528/TGeoTreeDialog.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoTreeDialog.html
https://root.cern/root/html528/TGeoTreeDialog.html:5156,Availability,error,error,5156,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); TList*TGMainFrame::GetBindList() const; static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; voidTGMainFrame::GetClassHints(const char*& className, const char*& resourceName) const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBa",MatchSource.WIKI,root/html528/TGeoTreeDialog.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoTreeDialog.html
https://root.cern/root/html528/TGeoTreeDialog.html:5240,Availability,error,error,5240,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); TList*TGMainFrame::GetBindList() const; static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; voidTGMainFrame::GetClassHints(const char*& className, const char*& resourceName) const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UIn",MatchSource.WIKI,root/html528/TGeoTreeDialog.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoTreeDialog.html
https://root.cern/root/html528/TGeoTreeDialog.html:19603,Availability,mask,mask,19603,,MatchSource.WIKI,root/html528/TGeoTreeDialog.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoTreeDialog.html
https://root.cern/root/html528/TGeoTube.html:3636,Availability,error,error,3636,"* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tDistFromOutsideS(Double_t* point, Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz); static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); static voidDistToTube(Double_t rsq, Double_t nsq, Double_t rdotn, Double_t radius, Double_t& b, Double_t& delta); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const char*GetAxisName(Int_t iaxis) const; virtual Double_tGetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; virtual voidGetBoundingCylinder(Double_t* param) const; virtual const TBuffer3D&GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; virtual Int_tGetByteCount() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_tTGeoBBox::GetDX() const; virtual Double_tTGeoBBox::GetDY() const; virtual Double_tGetDz() const; virtual Double_tTGeoBBox::GetDZ() const; virtual Double_tTGeoBBox::GetFacetArea(Int_t index",MatchSource.WIKI,root/html528/TGeoTube.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoTube.html
https://root.cern/root/html528/TGeoTube.html:3720,Availability,error,error,3720,"static Double_tDistFromOutsideS(Double_t* point, Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz); static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); static voidDistToTube(Double_t rsq, Double_t nsq, Double_t rdotn, Double_t radius, Double_t& b, Double_t& delta); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const char*GetAxisName(Int_t iaxis) const; virtual Double_tGetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; virtual voidGetBoundingCylinder(Double_t* param) const; virtual const TBuffer3D&GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; virtual Int_tGetByteCount() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_tTGeoBBox::GetDX() const; virtual Double_tTGeoBBox::GetDY() const; virtual Double_tGetDz() const; virtual Double_tTGeoBBox::GetDZ() const; virtual Double_tTGeoBBox::GetFacetArea(Int_t index = 0) const; virtual Int_tTGeoBBox::GetFittingBox(const TGeoBBox* parambox, TGeoMatr",MatchSource.WIKI,root/html528/TGeoTube.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoTube.html
https://root.cern/root/html528/TGeoTube.html:2458,Safety,safe,safe,2458,"e_tCapacity() const; static Double_tCapacity(Double_t rmin, Double_t rmax, Double_t dz); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); static voidComputeNormalS(Double_t* point, Double_t* dir, Double_t* norm, Double_t rmin, Double_t rmax, Double_t dz); virtual Bool_tContains(Double_t* point) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(Double_t* point, Double_t* dir) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tDistFromInsideS(Double_t* point, Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz); virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tDistFromOutsideS(Double_t* point, Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz); static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); static voidDistToTube(Double_t rsq, Double_t nsq, Double_t rdotn, Double_t radius, Double_t& b, Double_t& delta); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Doub",MatchSource.WIKI,root/html528/TGeoTube.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoTube.html
https://root.cern/root/html528/TGeoTube.html:2706,Safety,safe,safe,2706,"r* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); static voidComputeNormalS(Double_t* point, Double_t* dir, Double_t* norm, Double_t rmin, Double_t rmax, Double_t dz); virtual Bool_tContains(Double_t* point) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(Double_t* point, Double_t* dir) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tDistFromInsideS(Double_t* point, Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz); virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tDistFromOutsideS(Double_t* point, Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz); static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); static voidDistToTube(Double_t rsq, Double_t nsq, Double_t rdotn, Double_t radius, Double_t& b, Double_t& delta); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* para",MatchSource.WIKI,root/html528/TGeoTube.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoTube.html
https://root.cern/root/html528/TGeoTube.html:13591,Safety,safe,safe,13591,"ault constructor specifying minimum and maximum radius. TGeoTube(Double_t* params); Default constructor specifying minimum and maximum radius; param[0] = Rmin; param[1] = Rmax; param[2] = dz. ~TGeoTube(); destructor. Double_t Capacity() const; Computes capacity of the shape in [length^3]. Double_t Capacity(Double_t rmin, Double_t rmax, Double_t dz); Computes capacity of the shape in [length^3]. void ComputeBBox(); compute bounding box of the tube. void ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. void ComputeNormalS(Double_t* point, Double_t* dir, Double_t* norm, Double_t rmin, Double_t rmax, Double_t dz); Compute normal to closest surface from POINT. Bool_t Contains(Double_t* point) const; test if point is inside this tube. Int_t DistancetoPrimitive(Int_t px, Int_t py); compute closest distance from point px,py to each corner. Double_t DistFromInsideS(Double_t* point, Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz); Compute distance from inside point to surface of the tube (static); Boundary safe algorithm.; compute distance to surface; Do Z. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the tube; Boundary safe algorithm. Double_t DistFromOutsideS(Double_t* point, Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz); Static method to compute distance from outside point to a tube with given parameters; Boundary safe algorithm.; check Z planes. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from outside point to surface of the tube and safe distance; Boundary safe algorithm.; fist localize point w.r.t tube. void DistToTube(Double_t rsq, Double_t nsq, Double_t rdotn, Double_t radius, Double_t& b, Double_t& delta); Static method computing the distance to a",MatchSource.WIKI,root/html528/TGeoTube.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoTube.html
https://root.cern/root/html528/TGeoTube.html:13759,Safety,safe,safe,13759,"t; Computes capacity of the shape in [length^3]. Double_t Capacity(Double_t rmin, Double_t rmax, Double_t dz); Computes capacity of the shape in [length^3]. void ComputeBBox(); compute bounding box of the tube. void ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. void ComputeNormalS(Double_t* point, Double_t* dir, Double_t* norm, Double_t rmin, Double_t rmax, Double_t dz); Compute normal to closest surface from POINT. Bool_t Contains(Double_t* point) const; test if point is inside this tube. Int_t DistancetoPrimitive(Int_t px, Int_t py); compute closest distance from point px,py to each corner. Double_t DistFromInsideS(Double_t* point, Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz); Compute distance from inside point to surface of the tube (static); Boundary safe algorithm.; compute distance to surface; Do Z. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the tube; Boundary safe algorithm. Double_t DistFromOutsideS(Double_t* point, Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz); Static method to compute distance from outside point to a tube with given parameters; Boundary safe algorithm.; check Z planes. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from outside point to surface of the tube and safe distance; Boundary safe algorithm.; fist localize point w.r.t tube. void DistToTube(Double_t rsq, Double_t nsq, Double_t rdotn, Double_t radius, Double_t& b, Double_t& delta); Static method computing the distance to a tube with given radius, starting from; POINT along DIR director cosines. The distance is computed as :; RSQ = point[0]*point[0]+point[1]*point[1]; NSQ = dir[0]*dir[0]+dir[1]*dir[1] ---> should NOT be 0 !!!; RDOTN = point[0]*dir[0]+point[1]*d",MatchSource.WIKI,root/html528/TGeoTube.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoTube.html
https://root.cern/root/html528/TGeoTube.html:13844,Safety,safe,safe,13844,"t; Computes capacity of the shape in [length^3]. Double_t Capacity(Double_t rmin, Double_t rmax, Double_t dz); Computes capacity of the shape in [length^3]. void ComputeBBox(); compute bounding box of the tube. void ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. void ComputeNormalS(Double_t* point, Double_t* dir, Double_t* norm, Double_t rmin, Double_t rmax, Double_t dz); Compute normal to closest surface from POINT. Bool_t Contains(Double_t* point) const; test if point is inside this tube. Int_t DistancetoPrimitive(Int_t px, Int_t py); compute closest distance from point px,py to each corner. Double_t DistFromInsideS(Double_t* point, Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz); Compute distance from inside point to surface of the tube (static); Boundary safe algorithm.; compute distance to surface; Do Z. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the tube; Boundary safe algorithm. Double_t DistFromOutsideS(Double_t* point, Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz); Static method to compute distance from outside point to a tube with given parameters; Boundary safe algorithm.; check Z planes. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from outside point to surface of the tube and safe distance; Boundary safe algorithm.; fist localize point w.r.t tube. void DistToTube(Double_t rsq, Double_t nsq, Double_t rdotn, Double_t radius, Double_t& b, Double_t& delta); Static method computing the distance to a tube with given radius, starting from; POINT along DIR director cosines. The distance is computed as :; RSQ = point[0]*point[0]+point[1]*point[1]; NSQ = dir[0]*dir[0]+dir[1]*dir[1] ---> should NOT be 0 !!!; RDOTN = point[0]*dir[0]+point[1]*d",MatchSource.WIKI,root/html528/TGeoTube.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoTube.html
https://root.cern/root/html528/TGeoTube.html:14057,Safety,safe,safe,14057," ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. void ComputeNormalS(Double_t* point, Double_t* dir, Double_t* norm, Double_t rmin, Double_t rmax, Double_t dz); Compute normal to closest surface from POINT. Bool_t Contains(Double_t* point) const; test if point is inside this tube. Int_t DistancetoPrimitive(Int_t px, Int_t py); compute closest distance from point px,py to each corner. Double_t DistFromInsideS(Double_t* point, Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz); Compute distance from inside point to surface of the tube (static); Boundary safe algorithm.; compute distance to surface; Do Z. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the tube; Boundary safe algorithm. Double_t DistFromOutsideS(Double_t* point, Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz); Static method to compute distance from outside point to a tube with given parameters; Boundary safe algorithm.; check Z planes. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from outside point to surface of the tube and safe distance; Boundary safe algorithm.; fist localize point w.r.t tube. void DistToTube(Double_t rsq, Double_t nsq, Double_t rdotn, Double_t radius, Double_t& b, Double_t& delta); Static method computing the distance to a tube with given radius, starting from; POINT along DIR director cosines. The distance is computed as :; RSQ = point[0]*point[0]+point[1]*point[1]; NSQ = dir[0]*dir[0]+dir[1]*dir[1] ---> should NOT be 0 !!!; RDOTN = point[0]*dir[0]+point[1]*dir[1]; The distance can be computed as :; D = -B +/- DELTA; where DELTA.GT.0 and D.GT.0. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); --- Divi",MatchSource.WIKI,root/html528/TGeoTube.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoTube.html
https://root.cern/root/html528/TGeoTube.html:14207,Safety,safe,safe,14207,"osest surface from POINT. Bool_t Contains(Double_t* point) const; test if point is inside this tube. Int_t DistancetoPrimitive(Int_t px, Int_t py); compute closest distance from point px,py to each corner. Double_t DistFromInsideS(Double_t* point, Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz); Compute distance from inside point to surface of the tube (static); Boundary safe algorithm.; compute distance to surface; Do Z. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the tube; Boundary safe algorithm. Double_t DistFromOutsideS(Double_t* point, Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz); Static method to compute distance from outside point to a tube with given parameters; Boundary safe algorithm.; check Z planes. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from outside point to surface of the tube and safe distance; Boundary safe algorithm.; fist localize point w.r.t tube. void DistToTube(Double_t rsq, Double_t nsq, Double_t rdotn, Double_t radius, Double_t& b, Double_t& delta); Static method computing the distance to a tube with given radius, starting from; POINT along DIR director cosines. The distance is computed as :; RSQ = point[0]*point[0]+point[1]*point[1]; NSQ = dir[0]*dir[0]+dir[1]*dir[1] ---> should NOT be 0 !!!; RDOTN = point[0]*dir[0]+point[1]*dir[1]; The distance can be computed as :; D = -B +/- DELTA; where DELTA.GT.0 and D.GT.0. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); --- Divide this tube shape belonging to volume ""voldiv"" into ndiv volumes; called divname, from start position with the given step. Returns pointer; to created division cell volume in case of Z divisions. For radial division; creates all volumes with",MatchSource.WIKI,root/html528/TGeoTube.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoTube.html
https://root.cern/root/html528/TGeoTube.html:14287,Safety,safe,safe,14287,"osest surface from POINT. Bool_t Contains(Double_t* point) const; test if point is inside this tube. Int_t DistancetoPrimitive(Int_t px, Int_t py); compute closest distance from point px,py to each corner. Double_t DistFromInsideS(Double_t* point, Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz); Compute distance from inside point to surface of the tube (static); Boundary safe algorithm.; compute distance to surface; Do Z. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the tube; Boundary safe algorithm. Double_t DistFromOutsideS(Double_t* point, Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz); Static method to compute distance from outside point to a tube with given parameters; Boundary safe algorithm.; check Z planes. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from outside point to surface of the tube and safe distance; Boundary safe algorithm.; fist localize point w.r.t tube. void DistToTube(Double_t rsq, Double_t nsq, Double_t rdotn, Double_t radius, Double_t& b, Double_t& delta); Static method computing the distance to a tube with given radius, starting from; POINT along DIR director cosines. The distance is computed as :; RSQ = point[0]*point[0]+point[1]*point[1]; NSQ = dir[0]*dir[0]+dir[1]*dir[1] ---> should NOT be 0 !!!; RDOTN = point[0]*dir[0]+point[1]*dir[1]; The distance can be computed as :; D = -B +/- DELTA; where DELTA.GT.0 and D.GT.0. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); --- Divide this tube shape belonging to volume ""voldiv"" into ndiv volumes; called divname, from start position with the given step. Returns pointer; to created division cell volume in case of Z divisions. For radial division; creates all volumes with",MatchSource.WIKI,root/html528/TGeoTube.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoTube.html
https://root.cern/root/html528/TGeoTube.html:14311,Safety,safe,safe,14311,"osest surface from POINT. Bool_t Contains(Double_t* point) const; test if point is inside this tube. Int_t DistancetoPrimitive(Int_t px, Int_t py); compute closest distance from point px,py to each corner. Double_t DistFromInsideS(Double_t* point, Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz); Compute distance from inside point to surface of the tube (static); Boundary safe algorithm.; compute distance to surface; Do Z. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the tube; Boundary safe algorithm. Double_t DistFromOutsideS(Double_t* point, Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz); Static method to compute distance from outside point to a tube with given parameters; Boundary safe algorithm.; check Z planes. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from outside point to surface of the tube and safe distance; Boundary safe algorithm.; fist localize point w.r.t tube. void DistToTube(Double_t rsq, Double_t nsq, Double_t rdotn, Double_t radius, Double_t& b, Double_t& delta); Static method computing the distance to a tube with given radius, starting from; POINT along DIR director cosines. The distance is computed as :; RSQ = point[0]*point[0]+point[1]*point[1]; NSQ = dir[0]*dir[0]+dir[1]*dir[1] ---> should NOT be 0 !!!; RDOTN = point[0]*dir[0]+point[1]*dir[1]; The distance can be computed as :; D = -B +/- DELTA; where DELTA.GT.0 and D.GT.0. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); --- Divide this tube shape belonging to volume ""voldiv"" into ndiv volumes; called divname, from start position with the given step. Returns pointer; to created division cell volume in case of Z divisions. For radial division; creates all volumes with",MatchSource.WIKI,root/html528/TGeoTube.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoTube.html
https://root.cern/root/html528/TGeoTube.html:13273,Testability,test,test,13273,"ction documentation; TGeoTube(); Default constructor. TGeoTube(Double_t rmin, Double_t rmax, Double_t dz); Default constructor specifying minimum and maximum radius. TGeoTube(const char* name, Double_t rmin, Double_t rmax, Double_t dz); Default constructor specifying minimum and maximum radius. TGeoTube(Double_t* params); Default constructor specifying minimum and maximum radius; param[0] = Rmin; param[1] = Rmax; param[2] = dz. ~TGeoTube(); destructor. Double_t Capacity() const; Computes capacity of the shape in [length^3]. Double_t Capacity(Double_t rmin, Double_t rmax, Double_t dz); Computes capacity of the shape in [length^3]. void ComputeBBox(); compute bounding box of the tube. void ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. void ComputeNormalS(Double_t* point, Double_t* dir, Double_t* norm, Double_t rmin, Double_t rmax, Double_t dz); Compute normal to closest surface from POINT. Bool_t Contains(Double_t* point) const; test if point is inside this tube. Int_t DistancetoPrimitive(Int_t px, Int_t py); compute closest distance from point px,py to each corner. Double_t DistFromInsideS(Double_t* point, Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz); Compute distance from inside point to surface of the tube (static); Boundary safe algorithm.; compute distance to surface; Do Z. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the tube; Boundary safe algorithm. Double_t DistFromOutsideS(Double_t* point, Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz); Static method to compute distance from outside point to a tube with given parameters; Boundary safe algorithm.; check Z planes. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from outside point to surface",MatchSource.WIKI,root/html528/TGeoTube.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoTube.html
https://root.cern/root/html528/TGeoTubeEditor.html:4591,Availability,error,error,4591,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const;",MatchSource.WIKI,root/html528/TGeoTubeEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoTubeEditor.html
https://root.cern/root/html528/TGeoTubeEditor.html:4675,Availability,error,error,4675,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType() c",MatchSource.WIKI,root/html528/TGeoTubeEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoTubeEditor.html
https://root.cern/root/html528/TGeoTubeEditor.html:17809,Availability,mask,mask,17809,,MatchSource.WIKI,root/html528/TGeoTubeEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoTubeEditor.html
https://root.cern/root/html528/TGeoTubeEditor.html:21244,Usability,undo,undoing,21244,"nt_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoTubeEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor for tube editor. ~TGeoTubeEditor(); Destructor. void ConnectSignals2Slots(); Connect signals to slots. void SetModel(TObject* obj); Connect to the selected object. Bool_t IsDelayed() const; Check if shape drawing is delayed. void DoName(); Perform name change. void DoApply(); Slot for applying modifications. void DoModified(); Slot for signaling modifications. void DoUndo(); Slot for undoing last operation. void DoRmin(); Slot for rmin. void DoRmax(); Slot for rmax. void DoDz(); Slot for dz. » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id: TGeoTubeEditor.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2010-09-23 20:10; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html528/TGeoTubeEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoTubeEditor.html
https://root.cern/root/html528/TGeoTubeSeg.html:4004,Availability,error,error,4004,"FromOutsideS(Double_t* point, Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz, Double_t c1, Double_t s1, Double_t c2, Double_t s2, Double_t cm, Double_t sm, Double_t cdfi); static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); static voidTGeoTube::DistToTube(Double_t rsq, Double_t nsq, Double_t rdotn, Double_t radius, Double_t& b, Double_t& delta); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const char*TGeoTube::GetAxisName(Int_t iaxis) const; virtual Double_tGetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; virtual voidGetBoundingCylinder(Double_t* param) const; virtual const TBuffer3D&GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; virtual Int_tGetByteCount() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_tTGeoBBox::GetDX() const; virtual Double_tTGeoBBox::GetDY() const; virtual Double_tTGeoTube::GetDz() const; virtual Double_tTGeoBBox::GetDZ() const; virtual Double_tTGeoBBox::GetF",MatchSource.WIKI,root/html528/TGeoTubeSeg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoTubeSeg.html
https://root.cern/root/html528/TGeoTubeSeg.html:4088,Availability,error,error,4088,"dz, Double_t c1, Double_t s1, Double_t c2, Double_t s2, Double_t cm, Double_t sm, Double_t cdfi); static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); static voidTGeoTube::DistToTube(Double_t rsq, Double_t nsq, Double_t rdotn, Double_t radius, Double_t& b, Double_t& delta); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const char*TGeoTube::GetAxisName(Int_t iaxis) const; virtual Double_tGetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; virtual voidGetBoundingCylinder(Double_t* param) const; virtual const TBuffer3D&GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; virtual Int_tGetByteCount() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_tTGeoBBox::GetDX() const; virtual Double_tTGeoBBox::GetDY() const; virtual Double_tTGeoTube::GetDz() const; virtual Double_tTGeoBBox::GetDZ() const; virtual Double_tTGeoBBox::GetFacetArea(Int_t index = 0) const; virtual Int_tTGeoBBox::GetFittingBox(const TGeoBBox",MatchSource.WIKI,root/html528/TGeoTubeSeg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoTubeSeg.html
https://root.cern/root/html528/TGeoTubeSeg.html:2630,Safety,safe,safe,2630,"t dz, Double_t phi1, Double_t phi2); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); static voidComputeNormalS(Double_t* point, Double_t* dir, Double_t* norm, Double_t rmin, Double_t rmax, Double_t dz, Double_t c1, Double_t s1, Double_t c2, Double_t s2); virtual Bool_tContains(Double_t* point) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(Double_t* point, Double_t* dir) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tDistFromInsideS(Double_t* point, Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz, Double_t c1, Double_t s1, Double_t c2, Double_t s2, Double_t cm, Double_t sm, Double_t cdfi); virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tDistFromOutsideS(Double_t* point, Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz, Double_t c1, Double_t s1, Double_t c2, Double_t s2, Double_t cm, Double_t sm, Double_t cdfi); static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); static voidTGeoTube::DistToTube(Double_t rsq, Double_t nsq, Double_t rdotn, Double_t radius, Double_t& b, Double_t& delta); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw",MatchSource.WIKI,root/html528/TGeoTubeSeg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoTubeSeg.html
https://root.cern/root/html528/TGeoTubeSeg.html:2971,Safety,safe,safe,2971,"h(); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); static voidComputeNormalS(Double_t* point, Double_t* dir, Double_t* norm, Double_t rmin, Double_t rmax, Double_t dz, Double_t c1, Double_t s1, Double_t c2, Double_t s2); virtual Bool_tContains(Double_t* point) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(Double_t* point, Double_t* dir) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tDistFromInsideS(Double_t* point, Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz, Double_t c1, Double_t s1, Double_t c2, Double_t s2, Double_t cm, Double_t sm, Double_t cdfi); virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tDistFromOutsideS(Double_t* point, Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz, Double_t c1, Double_t s1, Double_t c2, Double_t s2, Double_t cm, Double_t sm, Double_t cdfi); static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); static voidTGeoTube::DistToTube(Double_t rsq, Double_t nsq, Double_t rdotn, Double_t radius, Double_t& b, Double_t& delta); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* metho",MatchSource.WIKI,root/html528/TGeoTubeSeg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoTubeSeg.html
https://root.cern/root/html528/TGeoTubeSeg.html:14653,Safety,safe,safe,14653,"~TGeoTubeSeg(); destructor. Double_t Capacity() const; Computes capacity of the shape in [length^3]. Double_t Capacity(Double_t rmin, Double_t rmax, Double_t dz, Double_t phi1, Double_t phi2); Computes capacity of the shape in [length^3]. void ComputeBBox(); compute bounding box of the tube segment. void ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. void ComputeNormalS(Double_t* point, Double_t* dir, Double_t* norm, Double_t rmin, Double_t rmax, Double_t dz, Double_t c1, Double_t s1, Double_t c2, Double_t s2); Compute normal to closest surface from POINT. Bool_t Contains(Double_t* point) const; test if point is inside this tube segment; first check if point is inside the tube. Int_t DistancetoPrimitive(Int_t px, Int_t py); compute closest distance from point px,py to each corner. Double_t DistFromInsideS(Double_t* point, Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz, Double_t c1, Double_t s1, Double_t c2, Double_t s2, Double_t cm, Double_t sm, Double_t cdfi); Compute distance from inside point to surface of the tube segment (static); Boundary safe algorithm.; Do Z. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the tube segment; Boundary safe algorithm. Double_t DistFromOutsideS(Double_t* point, Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz, Double_t c1, Double_t s1, Double_t c2, Double_t s2, Double_t cm, Double_t sm, Double_t cdfi); Static method to compute distance to arbitrary tube segment from outside point; Boundary safe algorithm. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from outside point to surface of the tube segment; fist localize point w.r.t tube. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, ",MatchSource.WIKI,root/html528/TGeoTubeSeg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoTubeSeg.html
https://root.cern/root/html528/TGeoTubeSeg.html:14792,Safety,safe,safe,14792,"bounding box of the tube segment. void ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. void ComputeNormalS(Double_t* point, Double_t* dir, Double_t* norm, Double_t rmin, Double_t rmax, Double_t dz, Double_t c1, Double_t s1, Double_t c2, Double_t s2); Compute normal to closest surface from POINT. Bool_t Contains(Double_t* point) const; test if point is inside this tube segment; first check if point is inside the tube. Int_t DistancetoPrimitive(Int_t px, Int_t py); compute closest distance from point px,py to each corner. Double_t DistFromInsideS(Double_t* point, Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz, Double_t c1, Double_t s1, Double_t c2, Double_t s2, Double_t cm, Double_t sm, Double_t cdfi); Compute distance from inside point to surface of the tube segment (static); Boundary safe algorithm.; Do Z. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the tube segment; Boundary safe algorithm. Double_t DistFromOutsideS(Double_t* point, Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz, Double_t c1, Double_t s1, Double_t c2, Double_t s2, Double_t cm, Double_t sm, Double_t cdfi); Static method to compute distance to arbitrary tube segment from outside point; Boundary safe algorithm. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from outside point to surface of the tube segment; fist localize point w.r.t tube. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); --- Divide this tube segment shape belonging to volume ""voldiv"" into ndiv volumes; called divname, from start position with the given step. Returns pointer; to created division cell volume in case of Z divisions. For radialdivision; cr",MatchSource.WIKI,root/html528/TGeoTubeSeg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoTubeSeg.html
https://root.cern/root/html528/TGeoTubeSeg.html:14885,Safety,safe,safe,14885,"bounding box of the tube segment. void ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. void ComputeNormalS(Double_t* point, Double_t* dir, Double_t* norm, Double_t rmin, Double_t rmax, Double_t dz, Double_t c1, Double_t s1, Double_t c2, Double_t s2); Compute normal to closest surface from POINT. Bool_t Contains(Double_t* point) const; test if point is inside this tube segment; first check if point is inside the tube. Int_t DistancetoPrimitive(Int_t px, Int_t py); compute closest distance from point px,py to each corner. Double_t DistFromInsideS(Double_t* point, Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz, Double_t c1, Double_t s1, Double_t c2, Double_t s2, Double_t cm, Double_t sm, Double_t cdfi); Compute distance from inside point to surface of the tube segment (static); Boundary safe algorithm.; Do Z. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the tube segment; Boundary safe algorithm. Double_t DistFromOutsideS(Double_t* point, Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz, Double_t c1, Double_t s1, Double_t c2, Double_t s2, Double_t cm, Double_t sm, Double_t cdfi); Static method to compute distance to arbitrary tube segment from outside point; Boundary safe algorithm. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from outside point to surface of the tube segment; fist localize point w.r.t tube. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); --- Divide this tube segment shape belonging to volume ""voldiv"" into ndiv volumes; called divname, from start position with the given step. Returns pointer; to created division cell volume in case of Z divisions. For radialdivision; cr",MatchSource.WIKI,root/html528/TGeoTubeSeg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoTubeSeg.html
https://root.cern/root/html528/TGeoTubeSeg.html:15185,Safety,safe,safe,15185,"le_t c1, Double_t s1, Double_t c2, Double_t s2); Compute normal to closest surface from POINT. Bool_t Contains(Double_t* point) const; test if point is inside this tube segment; first check if point is inside the tube. Int_t DistancetoPrimitive(Int_t px, Int_t py); compute closest distance from point px,py to each corner. Double_t DistFromInsideS(Double_t* point, Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz, Double_t c1, Double_t s1, Double_t c2, Double_t s2, Double_t cm, Double_t sm, Double_t cdfi); Compute distance from inside point to surface of the tube segment (static); Boundary safe algorithm.; Do Z. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the tube segment; Boundary safe algorithm. Double_t DistFromOutsideS(Double_t* point, Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz, Double_t c1, Double_t s1, Double_t c2, Double_t s2, Double_t cm, Double_t sm, Double_t cdfi); Static method to compute distance to arbitrary tube segment from outside point; Boundary safe algorithm. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from outside point to surface of the tube segment; fist localize point w.r.t tube. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); --- Divide this tube segment shape belonging to volume ""voldiv"" into ndiv volumes; called divname, from start position with the given step. Returns pointer; to created division cell volume in case of Z divisions. For radialdivision; creates all volumes with different shapes and returns pointer to volume that; was divided. In case a wrong division axis is supplied, returns pointer to; volume that was divided. Double_t GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; Get range of ",MatchSource.WIKI,root/html528/TGeoTubeSeg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoTubeSeg.html
https://root.cern/root/html528/TGeoTubeSeg.html:15318,Safety,safe,safe,15318,"y); compute closest distance from point px,py to each corner. Double_t DistFromInsideS(Double_t* point, Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz, Double_t c1, Double_t s1, Double_t c2, Double_t s2, Double_t cm, Double_t sm, Double_t cdfi); Compute distance from inside point to surface of the tube segment (static); Boundary safe algorithm.; Do Z. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the tube segment; Boundary safe algorithm. Double_t DistFromOutsideS(Double_t* point, Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz, Double_t c1, Double_t s1, Double_t c2, Double_t s2, Double_t cm, Double_t sm, Double_t cdfi); Static method to compute distance to arbitrary tube segment from outside point; Boundary safe algorithm. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from outside point to surface of the tube segment; fist localize point w.r.t tube. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); --- Divide this tube segment shape belonging to volume ""voldiv"" into ndiv volumes; called divname, from start position with the given step. Returns pointer; to created division cell volume in case of Z divisions. For radialdivision; creates all volumes with different shapes and returns pointer to volume that; was divided. In case a wrong division axis is supplied, returns pointer to; volume that was divided. Double_t GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; Get range of shape for a given axis. void GetBoundingCylinder(Double_t* param) const; --- Fill vector param[4] with the bounding cylinder parameters. The order; is the following : Rmin, Rmax, Phi1, Phi2. TGeoShape * GetMakeRuntimeShape(TGeoShape* mother, TGeoMatrix* mat) cons",MatchSource.WIKI,root/html528/TGeoTubeSeg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoTubeSeg.html
https://root.cern/root/html528/TGeoTubeSeg.html:14185,Testability,test,test,14185,"* name, Double_t rmin, Double_t rmax, Double_t dz, Double_t phi1, Double_t phi2); Default constructor specifying minimum and maximum radius. TGeoTubeSeg(Double_t* params); Default constructor specifying minimum and maximum radius; param[0] = Rmin; param[1] = Rmax; param[2] = dz; param[3] = phi1; param[4] = phi2. ~TGeoTubeSeg(); destructor. Double_t Capacity() const; Computes capacity of the shape in [length^3]. Double_t Capacity(Double_t rmin, Double_t rmax, Double_t dz, Double_t phi1, Double_t phi2); Computes capacity of the shape in [length^3]. void ComputeBBox(); compute bounding box of the tube segment. void ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. void ComputeNormalS(Double_t* point, Double_t* dir, Double_t* norm, Double_t rmin, Double_t rmax, Double_t dz, Double_t c1, Double_t s1, Double_t c2, Double_t s2); Compute normal to closest surface from POINT. Bool_t Contains(Double_t* point) const; test if point is inside this tube segment; first check if point is inside the tube. Int_t DistancetoPrimitive(Int_t px, Int_t py); compute closest distance from point px,py to each corner. Double_t DistFromInsideS(Double_t* point, Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz, Double_t c1, Double_t s1, Double_t c2, Double_t s2, Double_t cm, Double_t sm, Double_t cdfi); Compute distance from inside point to surface of the tube segment (static); Boundary safe algorithm.; Do Z. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the tube segment; Boundary safe algorithm. Double_t DistFromOutsideS(Double_t* point, Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz, Double_t c1, Double_t s1, Double_t c2, Double_t s2, Double_t cm, Double_t sm, Double_t cdfi); Static method to compute distance to arbitrary tube segment from outside point; Boundary safe algorithm. Doubl",MatchSource.WIKI,root/html528/TGeoTubeSeg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoTubeSeg.html
https://root.cern/root/html528/TGeoTubeSegEditor.html:4732,Availability,error,error,4732,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const;",MatchSource.WIKI,root/html528/TGeoTubeSegEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoTubeSegEditor.html
https://root.cern/root/html528/TGeoTubeSegEditor.html:4816,Availability,error,error,4816,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType() c",MatchSource.WIKI,root/html528/TGeoTubeSegEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoTubeSegEditor.html
https://root.cern/root/html528/TGeoTubeSegEditor.html:18181,Availability,mask,mask,18181,,MatchSource.WIKI,root/html528/TGeoTubeSegEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoTubeSegEditor.html
https://root.cern/root/html528/TGeoTubeSegEditor.html:21819,Usability,undo,undoing,21819,"bMgrtab manager corresponding to ged-editor; TGTextButton*TGeoTubeEditor::fUndoUndo-Button; UInt_tTGFrame::fWidthframe width; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoTubeSegEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor for tube segment editor. ~TGeoTubeSegEditor(); Destructor. void ConnectSignals2Slots(); Connect signals to slots. void SetModel(TObject* obj); Connect to the selected object. void DoPhi1(); Slot for phi1. void DoPhi2(); Slot for phi2. void DoPhi(); Slot for phi slider. void DoApply(); Slot for applying modifications. void DoUndo(); Slot for undoing last operation. » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id: TGeoTubeEditor.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2010-09-23 20:10; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html528/TGeoTubeSegEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoTubeSegEditor.html
https://root.cern/root/html528/TGeoUniformMagField.html:1457,Availability,error,error,1457,"ormMagField(Double_t Bx, Double_t By, Double_t Bz); virtual~TGeoUniformMagField(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidField(const Double_t*, Double_t* B); virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); const Double_t*GetFieldValue() const; virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virt",MatchSource.WIKI,root/html528/TGeoUniformMagField.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoUniformMagField.html
https://root.cern/root/html528/TGeoUniformMagField.html:1541,Availability,error,error,1541,"oidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidField(const Double_t*, Double_t* B); virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); const Double_t*GetFieldValue() const; virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tT",MatchSource.WIKI,root/html528/TGeoUniformMagField.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoUniformMagField.html
https://root.cern/root/html528/TGeoUnion.html:2837,Availability,error,error,2837,"uble_t& dy, Double_t& dz, Double_t* origin); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); virtual Bool_tContains(Double_t* point) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistanceToPrimitive(Int_t px, Int_t py); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TGeoBoolNode::EGeoBoolTypeGetBooleanOperator() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; TGeoMatrix*TGeoBoolNode::GetLeftMatrix() const; TGeoShape*TGeoBoolNode::GetLeftShape() const; virtual const char*TObject::GetName() const; virtual Int_tGetNpoints(); virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TGeoMatrix*TGeoBoolNode::GetRightMatrix() const; TGeoShape*TGeoBoolNode::GetRightShape() const; virtual const char*TObject::GetTitl",MatchSource.WIKI,root/html528/TGeoUnion.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoUnion.html
https://root.cern/root/html528/TGeoUnion.html:2921,Availability,error,error,2921,"nt, Double_t* dir, Double_t* norm); virtual Bool_tContains(Double_t* point) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistanceToPrimitive(Int_t px, Int_t py); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TGeoBoolNode::EGeoBoolTypeGetBooleanOperator() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; TGeoMatrix*TGeoBoolNode::GetLeftMatrix() const; TGeoShape*TGeoBoolNode::GetLeftShape() const; virtual const char*TObject::GetName() const; virtual Int_tGetNpoints(); virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TGeoMatrix*TGeoBoolNode::GetRightMatrix() const; TGeoShape*TGeoBoolNode::GetRightShape() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::Handle",MatchSource.WIKI,root/html528/TGeoUnion.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoUnion.html
https://root.cern/root/html528/TGeoUnion.html:2339,Safety,safe,safe,2339,"ight, TGeoMatrix* lmat = 0, TGeoMatrix* rmat = 0); virtual~TGeoUnion(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidComputeBBox(Double_t& dx, Double_t& dy, Double_t& dz, Double_t* origin); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); virtual Bool_tContains(Double_t* point) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistanceToPrimitive(Int_t px, Int_t py); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TGeoBoolNode::EGeoBoolTypeGetBooleanOperator() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnl",MatchSource.WIKI,root/html528/TGeoUnion.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoUnion.html
https://root.cern/root/html528/TGeoUnion.html:2465,Safety,safe,safe,2465," virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidComputeBBox(Double_t& dx, Double_t& dy, Double_t& dz, Double_t* origin); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); virtual Bool_tContains(Double_t* point) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistanceToPrimitive(Int_t px, Int_t py); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TGeoBoolNode::EGeoBoolTypeGetBooleanOperator() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; TGeoMatrix*TGeoBoolNode::GetLeftMatrix() const; TGeoShape*TGeoBoolNode::",MatchSource.WIKI,root/html528/TGeoUnion.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoUnion.html
https://root.cern/root/html528/TGeoUnion.html:8660,Safety,safe,safe,8660,"Inheritance; Inherited Members; Includes; Libraries. Function documentation; void Paint(Option_t* option); Paint method. TGeoUnion(); Default constructor. TGeoUnion(const char* expr1, const char* expr2); Constructor. TGeoUnion(TGeoShape* left, TGeoShape* right, TGeoMatrix* lmat = 0, TGeoMatrix* rmat = 0); Constructor providing pointers to components. ~TGeoUnion(); Destructor; --- deletion of components handled by TGeoManager class. void ComputeBBox(Double_t& dx, Double_t& dy, Double_t& dz, Double_t* origin); Compute bounding box corresponding to a union of two shapes. Bool_t Contains(Double_t* point) const; Find if a union of two shapes contains a given point. void ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); Normal computation in POINT. The orientation is chosen so that DIR.dot.NORM>0. Int_t DistanceToPrimitive(Int_t px, Int_t py); Compute minimum distance to shape vertices. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; Computes distance from a given point inside the shape to its boundary. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; Compute distance from a given outside point to the shape. Int_t GetNpoints(); Returns number of vertices for the composite shape described by this union. Double_t Safety(Double_t* point, Bool_t in = kTRUE) const; Compute safety distance for a union node;. void SavePrimitive(ostream& out, Option_t* option = """"); Save a primitive as a C++ statement(s) on output stream ""out"". void Sizeof3D() const; Register 3D size of this shape. EGeoBoolType GetBooleanOperator() const. » Author: Andrei Gheata 30/05/02 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: :$Id: TGeoBoolNode.h 32690 2010-03-21 08:47:56Z brun $ » Last generated: 2010-12-10 11:10; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in ge",MatchSource.WIKI,root/html528/TGeoUnion.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoUnion.html
https://root.cern/root/html528/TGeoUnion.html:8850,Safety,safe,safe,8850,"ibraries. Function documentation; void Paint(Option_t* option); Paint method. TGeoUnion(); Default constructor. TGeoUnion(const char* expr1, const char* expr2); Constructor. TGeoUnion(TGeoShape* left, TGeoShape* right, TGeoMatrix* lmat = 0, TGeoMatrix* rmat = 0); Constructor providing pointers to components. ~TGeoUnion(); Destructor; --- deletion of components handled by TGeoManager class. void ComputeBBox(Double_t& dx, Double_t& dy, Double_t& dz, Double_t* origin); Compute bounding box corresponding to a union of two shapes. Bool_t Contains(Double_t* point) const; Find if a union of two shapes contains a given point. void ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); Normal computation in POINT. The orientation is chosen so that DIR.dot.NORM>0. Int_t DistanceToPrimitive(Int_t px, Int_t py); Compute minimum distance to shape vertices. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; Computes distance from a given point inside the shape to its boundary. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; Compute distance from a given outside point to the shape. Int_t GetNpoints(); Returns number of vertices for the composite shape described by this union. Double_t Safety(Double_t* point, Bool_t in = kTRUE) const; Compute safety distance for a union node;. void SavePrimitive(ostream& out, Option_t* option = """"); Save a primitive as a C++ statement(s) on output stream ""out"". void Sizeof3D() const; Register 3D size of this shape. EGeoBoolType GetBooleanOperator() const. » Author: Andrei Gheata 30/05/02 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: :$Id: TGeoBoolNode.h 32690 2010-03-21 08:47:56Z brun $ » Last generated: 2010-12-10 11:10; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html528/TGeoUnion.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoUnion.html
https://root.cern/root/html528/TGeoUnion.html:9088,Safety,safe,safety,9088,"ibraries. Function documentation; void Paint(Option_t* option); Paint method. TGeoUnion(); Default constructor. TGeoUnion(const char* expr1, const char* expr2); Constructor. TGeoUnion(TGeoShape* left, TGeoShape* right, TGeoMatrix* lmat = 0, TGeoMatrix* rmat = 0); Constructor providing pointers to components. ~TGeoUnion(); Destructor; --- deletion of components handled by TGeoManager class. void ComputeBBox(Double_t& dx, Double_t& dy, Double_t& dz, Double_t* origin); Compute bounding box corresponding to a union of two shapes. Bool_t Contains(Double_t* point) const; Find if a union of two shapes contains a given point. void ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); Normal computation in POINT. The orientation is chosen so that DIR.dot.NORM>0. Int_t DistanceToPrimitive(Int_t px, Int_t py); Compute minimum distance to shape vertices. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; Computes distance from a given point inside the shape to its boundary. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; Compute distance from a given outside point to the shape. Int_t GetNpoints(); Returns number of vertices for the composite shape described by this union. Double_t Safety(Double_t* point, Bool_t in = kTRUE) const; Compute safety distance for a union node;. void SavePrimitive(ostream& out, Option_t* option = """"); Save a primitive as a C++ statement(s) on output stream ""out"". void Sizeof3D() const; Register 3D size of this shape. EGeoBoolType GetBooleanOperator() const. » Author: Andrei Gheata 30/05/02 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: :$Id: TGeoBoolNode.h 32690 2010-03-21 08:47:56Z brun $ » Last generated: 2010-12-10 11:10; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html528/TGeoUnion.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoUnion.html
https://root.cern/root/html528/TGeoVolume.html:10450,Availability,error,error,10450,"l TGeoVolume*CloneVolume() const; virtual Int_tTNamed::Compare(const TObject* obj) const; Bool_tContains(Double_t* point) const; virtual voidTNamed::Copy(TObject& named) const; Int_tCountNodes(Int_t nlevels = 1000, Int_t option = 0); virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual TGeoVolume*Divide(const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step, Int_t numed = 0, Option_t* option = """"); virtual voidDraw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidDrawOnly(Option_t* option = """")MENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); Int_tExport(const char* filename, const char* name = """", Option_t* option = """"); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); Bool_tFindMatrixOfDaughterVolume(TGeoVolume* vol) const; TGeoNode*FindNode(const char* name) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; voidFindOverlaps() const; virtual Int_tGetByteCount() const; virtual Int_tGetCurrentNodeIndex() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); TObject*GetField() const; virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; TGeoPatternFinder*GetFinder() const; TGeoManager*GetGeoManager() const; virtual const char*GetIconName() const; I",MatchSource.WIKI,root/html528/TGeoVolume.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoVolume.html
https://root.cern/root/html528/TGeoVolume.html:10534,Availability,error,error,10534,"onst; Bool_tContains(Double_t* point) const; virtual voidTNamed::Copy(TObject& named) const; Int_tCountNodes(Int_t nlevels = 1000, Int_t option = 0); virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual TGeoVolume*Divide(const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step, Int_t numed = 0, Option_t* option = """"); virtual voidDraw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidDrawOnly(Option_t* option = """")MENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); Int_tExport(const char* filename, const char* name = """", Option_t* option = """"); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); Bool_tFindMatrixOfDaughterVolume(TGeoVolume* vol) const; TGeoNode*FindNode(const char* name) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; voidFindOverlaps() const; virtual Int_tGetByteCount() const; virtual Int_tGetCurrentNodeIndex() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); TObject*GetField() const; virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; TGeoPatternFinder*GetFinder() const; TGeoManager*GetGeoManager() const; virtual const char*GetIconName() const; Int_tGetIndex(const TGeoNode* node) const; virtual Color_tTAttLine::GetLineColor() co",MatchSource.WIKI,root/html528/TGeoVolume.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoVolume.html
https://root.cern/root/html528/TGeoVolume.html:23070,Availability,down,down,23070,"f this volume. Track each ray until exiting geometry, then; shoot backwards from exiting point and compare boundary crossing points. void CheckOverlaps(Double_t ovlp = 0.1, Option_t* option = """") const; Overlap checking tool. Check for illegal overlaps within a limit OVLP.; Use option=""s[number]"" to force overlap checking by sampling volume with; [number] points.; Ex: myVol->CheckOverlaps(0.01, ""s10000000""); // shoot 10000000 points; myVol->CheckOverlaps(0.01, ""s""); // shoot the default value of 1e6 points. void CleanAll(); Clean data of the volume. void ClearShape(); Clear the shape of this volume from the list held by the current manager. void CheckShapes(); check for negative parameters in shapes.; THIS METHOD LEAVES SOME GARBAGE NODES -> memory leak, to be fixed; printf(""---Checking daughters of volume %s\n"", GetName());. Int_t CountNodes(Int_t nlevels = 1000, Int_t option = 0); Count total number of subnodes starting from this volume, nlevels down; option = 0 (default) - count only once per volume; option = 1 - count every time; option = 2 - count volumes on visible branches; option = 3 - return maximum level counted already with option = 0. Bool_t IsAllInvisible() const; Return TRUE if volume and all daughters are invisible. void InvisibleAll(Bool_t flag = kTRUE); Make volume and each of it daughters (in)visible. Bool_t IsFolder() const; Return TRUE if volume contains nodes; return (GetNdaughters()?kTRUE:kFALSE);. Bool_t IsStyleDefault() const; check if the visibility and attributes are the default ones. Bool_t IsTopVolume() const; True if this is the top volume of the geometry. Bool_t IsRaytracing() const; Check if the painter is currently ray-tracing the content of this volume. void InspectMaterial() const; Inspect the material for this volume. TGeoVolume * Import(const char* filename, const char* name = """", Option_t* option = """"); Import a volume from a file. Int_t Export(const char* filename, const char* name = """", Option_t* option = """"); Export this volume",MatchSource.WIKI,root/html528/TGeoVolume.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoVolume.html
https://root.cern/root/html528/TGeoVolume.html:26529,Energy Efficiency,efficient,efficient,26529,"will have medium number NUMED.; If NUMED=0 they will get the medium number of the divided volume (this). If NDIV<=0,; all range of IAXIS will be divided and the resulting number of divisions will be centered on; IAXIS. If STEP<=0, the real STEP will be computed as the full range of IAXIS divided by NDIV.; Options (case insensitive):; N - divide all range in NDIV cells (same effect as STEP<=0) (GSDVN in G3); NX - divide range starting with START in NDIV cells (GSDVN2 in G3); S - divide all range with given STEP. NDIV is computed and divisions will be centered; in full range (same effect as NDIV<=0) (GSDVS, GSDVT in G3); SX - same as DVS, but from START position. (GSDVS2, GSDVT2 in G3). Int_t DistancetoPrimitive(Int_t px, Int_t py); compute the closest distance of approach from point px,py to this volume. void Draw(Option_t* option = """"); draw top volume according to option. void DrawOnly(Option_t* option = """"); draw only this volume. Bool_t OptimizeVoxels(); Perform an exensive sampling to find which type of voxelization is; most efficient. void Paint(Option_t* option = """"); paint volume. void PrintVoxels() const; Print the voxels for this volume. void ReplayCreation(const TGeoVolume* other); Recreate the content of the other volume without pointer copying. Voxels are; ignored and supposed to be created in a later step via Voxelize. void PrintNodes() const; print nodes. TH2F * LegoPlot(Int_t ntheta = 20, Double_t themin = 0., Double_t themax = 180., Int_t nphi = 60, Double_t phimin = 0., Double_t phimax = 360., Double_t rmin = 0., Double_t rmax = 9999999, Option_t* option = """"); Generate a lego plot fot the top volume, according to option. void RegisterYourself(Option_t* option = """"); Register the volume and all materials/media/matrices/shapes to the manager. void RandomPoints(Int_t npoints = 1000000, Option_t* option = """"); Draw random points in the bounding box of this volume. void RandomRays(Int_t nrays = 10000, Double_t startx = 0, Double_t starty = 0, Double_t st",MatchSource.WIKI,root/html528/TGeoVolume.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoVolume.html
https://root.cern/root/html528/TGeoVolume.html:1913,Modifiability,inherit,inherits,1913,"rent name may represent a; an unique volume object, but may also represent more general a family (class); of volume objects having the same shape type and medium, but possibly; different shape parameters. It is the user's task to provide different names; for different volume families in order to avoid ambiguities at tracking time.; A generic family rather than a single volume is created only in two cases :; when a generic shape is provided to the volume constructor or when a division; operation is applied. Each volume in the geometry stores an unique; ID corresponding to its family. In order to ease-up their creation, the manager; class is providing an API that allows making a shape and a volume in a single step. Volumes are objects that can be visualized, therefore having visibility,; colour, line and fill attributes that can be defined or modified any time after; the volume creation. It is advisable however to define these properties just; after the first creation of a volume namespace, since in case of volume families; any new member created by the modeler inherits these properties. In order to provide navigation features, volumes have to be able to find; the proper container of any point defined in the local reference frame. This; can be the volume itself, one of its positioned daughter volumes or none if; the point is actually outside. On the other hand, volumes have to provide also; other navigation methods such as finding the distances to its shape boundaries; or which daughter will be crossed first. The implementation of these features; is done at shape level, but the local mother-daughters management is handled; by volumes that builds additional optimisation structures upon geometry closure.; In order to have navigation features properly working one has to follow the; general rules for building a valid geometry (see TGeoManager class). Now let's make a simple volume representing a copper wire. We suppose that; a medium is already created (see TGeoMedium cla",MatchSource.WIKI,root/html528/TGeoVolume.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoVolume.html
https://root.cern/root/html528/TGeoVolume.html:27601,Performance,perform,perform,27601,"aint volume. void PrintVoxels() const; Print the voxels for this volume. void ReplayCreation(const TGeoVolume* other); Recreate the content of the other volume without pointer copying. Voxels are; ignored and supposed to be created in a later step via Voxelize. void PrintNodes() const; print nodes. TH2F * LegoPlot(Int_t ntheta = 20, Double_t themin = 0., Double_t themax = 180., Int_t nphi = 60, Double_t phimin = 0., Double_t phimax = 360., Double_t rmin = 0., Double_t rmax = 9999999, Option_t* option = """"); Generate a lego plot fot the top volume, according to option. void RegisterYourself(Option_t* option = """"); Register the volume and all materials/media/matrices/shapes to the manager. void RandomPoints(Int_t npoints = 1000000, Option_t* option = """"); Draw random points in the bounding box of this volume. void RandomRays(Int_t nrays = 10000, Double_t startx = 0, Double_t starty = 0, Double_t startz = 0); Random raytracing method. void Raytrace(Bool_t flag = kTRUE); Draw this volume with current settings and perform raytracing in the pad. void SaveAs(const char* filename, Option_t* option = """") const; Save geometry having this as top volume as a C++ macro. void SavePrimitive(ostream& out, Option_t* option = """"); Save a primitive as a C++ statement(s) on output stream ""out"". void UnmarkSaved(); Reset SavePrimitive bits. void ExecuteEvent(Int_t event, Int_t px, Int_t py); Execute mouse actions on this volume. TGeoNode * FindNode(const char* name) const; search a daughter inside the list of nodes. Int_t GetNodeIndex(const TGeoNode* node, Int_t* check_list, Int_t ncheck) const; Get the index of a daugther within check_list by providing the node pointer. Int_t GetIndex(const TGeoNode* node) const; get index number for a given daughter. char * GetObjectInfo(Int_t px, Int_t py) const; Get volume info for the browser. Bool_t GetOptimalVoxels() const; --- Returns true if cylindrical voxelization is optimal. char * GetPointerName() const; Provide a pointer name containing ui",MatchSource.WIKI,root/html528/TGeoVolume.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoVolume.html
https://root.cern/root/html528/TGeoVolume.html:28627,Performance,optimiz,optimization,28627,"acing in the pad. void SaveAs(const char* filename, Option_t* option = """") const; Save geometry having this as top volume as a C++ macro. void SavePrimitive(ostream& out, Option_t* option = """"); Save a primitive as a C++ statement(s) on output stream ""out"". void UnmarkSaved(); Reset SavePrimitive bits. void ExecuteEvent(Int_t event, Int_t px, Int_t py); Execute mouse actions on this volume. TGeoNode * FindNode(const char* name) const; search a daughter inside the list of nodes. Int_t GetNodeIndex(const TGeoNode* node, Int_t* check_list, Int_t ncheck) const; Get the index of a daugther within check_list by providing the node pointer. Int_t GetIndex(const TGeoNode* node) const; get index number for a given daughter. char * GetObjectInfo(Int_t px, Int_t py) const; Get volume info for the browser. Bool_t GetOptimalVoxels() const; --- Returns true if cylindrical voxelization is optimal. char * GetPointerName() const; Provide a pointer name containing uid. TGeoVoxelFinder * GetVoxels() const; Getter for optimization structure. void GrabFocus(); Move perspective view focus to this volume. TGeoVolume * CloneVolume() const; Clone this volume.; build a volume with same name, shape and medium. void CloneNodesAndConnect(TGeoVolume* newmother) const; Clone the array of nodes. void MakeCopyNodes(const TGeoVolume* other); make a new list of nodes and copy all nodes of other volume inside. TGeoVolume * MakeCopyVolume(TGeoShape* newshape); make a copy of this volume; build a volume with same name, shape and medium. TGeoVolume * MakeReflectedVolume(const char* newname = """") const; Make a copy of this volume which is reflected with respect to XY plane. void SetAsTopVolume(); Set this volume as the TOP one (the whole geometry starts from here). void SetCurrentPoint(Double_t x, Double_t y, Double_t z); Set the current tracking point. void SetShape(const TGeoShape* shape); set the shape associated with this volume. void SortNodes(); sort nodes by decreasing volume of the bounding box. ON",MatchSource.WIKI,root/html528/TGeoVolume.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoVolume.html
https://root.cern/root/html528/TGeoVolume.html:1134,Safety,avoid,avoid,1134,"urce file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GEOM; » GEOM; » TGeoVolume. class TGeoVolume: public TNamed, public TGeoAtt, public TAttLine, public TAttFill, public TAtt3D. TGeoVolume - the base class representing solids. Volumes are the basic objects used in building the geometrical hierarchy.; They represent unpositioned objects but store all information about the; placement of the other volumes they may contain. Therefore a volume can; be replicated several times in the geometry. In order to create a volume, one; has to put togeather a shape and a medium which are already defined. Volumes; have to be named by users at creation time. Every different name may represent a; an unique volume object, but may also represent more general a family (class); of volume objects having the same shape type and medium, but possibly; different shape parameters. It is the user's task to provide different names; for different volume families in order to avoid ambiguities at tracking time.; A generic family rather than a single volume is created only in two cases :; when a generic shape is provided to the volume constructor or when a division; operation is applied. Each volume in the geometry stores an unique; ID corresponding to its family. In order to ease-up their creation, the manager; class is providing an API that allows making a shape and a volume in a single step. Volumes are objects that can be visualized, therefore having visibility,; colour, line and fill attributes that can be defined or modified any time after; the volume creation. It is advisable however to define these properties just; after the first creation of a volume namespace, since in case of volume families; any new member created by the modeler inherits these properties. In order to provide navigation features, volumes have to be able to find; the proper container of any point defined in the local reference frame. This; can be the vo",MatchSource.WIKI,root/html528/TGeoVolume.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoVolume.html
https://root.cern/root/html528/TGeoVolume.html:2731,Usability,simpl,simple,2731,"advisable however to define these properties just; after the first creation of a volume namespace, since in case of volume families; any new member created by the modeler inherits these properties. In order to provide navigation features, volumes have to be able to find; the proper container of any point defined in the local reference frame. This; can be the volume itself, one of its positioned daughter volumes or none if; the point is actually outside. On the other hand, volumes have to provide also; other navigation methods such as finding the distances to its shape boundaries; or which daughter will be crossed first. The implementation of these features; is done at shape level, but the local mother-daughters management is handled; by volumes that builds additional optimisation structures upon geometry closure.; In order to have navigation features properly working one has to follow the; general rules for building a valid geometry (see TGeoManager class). Now let's make a simple volume representing a copper wire. We suppose that; a medium is already created (see TGeoMedium class on how to create media).; We will create a TUBE shape for our wire, having Rmin=0cm, Rmax=0.01cm; and a half-length dZ=1cm :. TGeoTube *tube = new TGeoTube(""wire_tube"", 0, 0.01, 1);. One may ommit the name for the shape if no retreiving by name is further needed; during geometry building. The same shape can be shared by different volumes; having different names and materials. Now let's make the volume for our wire.; The prototype for volumes constructor looks like :. TGeoVolume::TGeoVolume(const char *name, TGeoShape *shape, TGeoMedium *med). Since TGeoTube derives brom the base shape class, we can provide it to the volume; constructor :. TGeoVolume *wire_co = new TGeoVolume(""WIRE_CO"", tube, ptrCOPPER);. Do not bother to delete neither the media, shapes or volumes that you have; created since all will be automatically cleaned on exit by the manager class.; If we would have taken a look insi",MatchSource.WIKI,root/html528/TGeoVolume.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoVolume.html
https://root.cern/root/html528/TGeoVolume.html:4346,Usability,learn,learned,4346,"ed). Since TGeoTube derives brom the base shape class, we can provide it to the volume; constructor :. TGeoVolume *wire_co = new TGeoVolume(""WIRE_CO"", tube, ptrCOPPER);. Do not bother to delete neither the media, shapes or volumes that you have; created since all will be automatically cleaned on exit by the manager class.; If we would have taken a look inside TGeoManager::MakeTube() method, we would; have been able to create our wire with a single line :. TGeoVolume *wire_co = gGeoManager->MakeTube(""WIRE_CO"", ptrCOPPER, 0, 0.01, 1);. The same applies for all primitive shapes, for which there can be found; corresponding MakeSHAPE() methods. Their usage is much more convenient unless; a shape has to be shared between more volumes. Let's make now an aluminium wire; having the same shape, supposing that we have created the copper wire with the; line above :. TGeoVolume *wire_al = new TGeoVolume(""WIRE_AL"", wire_co->GetShape(), ptrAL);. Now that we have learned how to create elementary volumes, let's see how we; can create a geometrical hierarchy. Positioning volumes. When creating a volume one does not specify if this will contain or not other; volumes. Adding daughters to a volume implies creating those and adding them; one by one to the list of daughters. Since the volume has to know the position; of all its daughters, we will have to supply at the same time a geometrical; transformation with respect to its local reference frame for each of them.; The objects referencing a volume and a transformation are called NODES and; their creation is fully handled by the modeler. They represent the link; elements in the hierarchy of volumes. Nodes are unique and distinct geometrical; objects ONLY from their container point of view. Since volumes can be replicated; in the geometry, the same node may be found on different branches. /*. */. An important observation is that volume objects are owned by the TGeoManager; class. This stores a list of all volumes in the geometry, that is c",MatchSource.WIKI,root/html528/TGeoVolume.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoVolume.html
https://root.cern/root/html528/TGeoVolume.html:5847,Usability,simpl,simplicity,5847,"its local reference frame for each of them.; The objects referencing a volume and a transformation are called NODES and; their creation is fully handled by the modeler. They represent the link; elements in the hierarchy of volumes. Nodes are unique and distinct geometrical; objects ONLY from their container point of view. Since volumes can be replicated; in the geometry, the same node may be found on different branches. /*. */. An important observation is that volume objects are owned by the TGeoManager; class. This stores a list of all volumes in the geometry, that is cleaned; upon destruction. Let's consider positioning now our wire in the middle of a gas chamber. We; need first to define the gas chamber :. TGeoVolume *chamber = gGeoManager->MakeTube(""CHAMBER"", ptrGAS, 0, 1, 1);. Now we can put the wire inside :. chamber->AddNode(wire_co, 1);. If we inspect now the chamber volume in a browser, we will notice that it has; one daughter. Of course the gas has some container also, but let's keep it like; that for the sake of simplicity. The full prototype of AddNode() is :. TGeoVolume::AddNode(TGeoVolume *daughter, Int_t usernumber,; TGeoMatrix *matrix=gGeoIdentity). Since we did not supplied the third argument, the wire will be positioned with; an identity transformation inside the chamber. One will notice that the inner; radii of the wire and chamber are both zero - therefore, aren't the two volumes; overlapping ? The answer is no, the modeler is even relaying on the fact that; any daughter is fully contained by its mother. On the other hand, neither of; the nodes positioned inside a volume should overlap with each other. We will; see that there are allowed some exceptions to those rules. Overlapping volumes. Positioning volumes that does not overlap their neighbours nor extrude; their container is sometimes quite strong contrain. Some parts of the geometry; might overlap naturally, e.g. two crossing tubes. The modeller supports such; cases only if the overlapping n",MatchSource.WIKI,root/html528/TGeoVolume.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoVolume.html
https://root.cern/root/html528/TGeoVolume.html:16364,Usability,clear,clear,16364,"_t startz = 0)MENU ; voidRaytrace(Bool_t flag = kTRUE)TOGGLE GETTER ; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidRegisterYourself(Option_t* option = """"); voidRemoveNode(TGeoNode* node); TGeoNode*ReplaceNode(TGeoNode* nodeorig, TGeoShape* newshape = 0, TGeoMatrix* newpos = 0, TGeoMedium* newmed = 0); voidReplayCreation(const TGeoVolume* other); voidTGeoAtt::ResetAttBit(UInt_t f); virtual voidTAttFill::ResetAttFill(Option_t* option = """"); virtual voidTAttLine::ResetAttLine(Option_t* option = """"); voidTObject::ResetBit(UInt_t f); virtual voidSaveAs(const char* filename, Option_t* option = """") constMENU ; virtual voidTAttFill::SaveFillAttributes(ostream& out, const char* name, Int_t coldef = 1, Int_t stydef = 1001); virtual voidTAttLine::SaveLineAttributes(ostream& out, const char* name, Int_t coldef = 1, Int_t stydef = 1, Int_t widdef = 1); virtual voidSavePrimitive(ostream& out, Option_t* option = """"); voidSelectVolume(Bool_t clear = kFALSE); voidSetActiveDaughters(Bool_t flag = kTRUE); voidSetActivity(Bool_t flag = kTRUE); voidSetAdded(); voidSetAsTopVolume()TOGGLE GETTER ; voidTGeoAtt::SetAttBit(UInt_t f); voidTGeoAtt::SetAttBit(UInt_t f, Bool_t set); voidSetAttVisibility(Bool_t vis); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidSetCurrentPoint(Double_t x, Double_t y, Double_t z); voidSetCylVoxels(Bool_t flag = kTRUE); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidSetField(TObject* field); virtual voidTAttFill::SetFillAttributes()MENU ; virtual voidTAttFill::SetFillColor(Color_t fcolor); virtual voidTAttFill::SetFillStyle(Style_t fstyle); voidSetFinder(TGeoPatternFinder* finder); voidSetInvisible(); virtual voidTAttLine::SetLineAttributes()MENU ; virtual voidSetLineColor(Color_t lcolor); virtual voidSetLineStyle(Style_t lstyle); virtual voidSetLineWidth(Width_t lwidth); virtual voidSetMedium(TGeoMedium* medium)",MatchSource.WIKI,root/html528/TGeoVolume.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoVolume.html
https://root.cern/root/html528/TGeoVolume.html:30655,Usability,clear,clear,30655,"ion nodes. void Streamer(TBuffer& b); Stream an object of class TGeoVolume. void SetOption(const char* option); Set the current options (none implemented). void SetLineColor(Color_t lcolor); Set the line color. void SetLineStyle(Style_t lstyle); Set the line style. void SetLineWidth(Width_t lwidth); Set the line width. TGeoNode * GetNode(const char* name) const; get the pointer to a daughter node. Int_t GetByteCount() const; get the total size in bytes for this volume. void FindOverlaps() const; loop all nodes marked as overlaps and find overlaping brothers. void RemoveNode(TGeoNode* node); Remove an existing daughter. TGeoNode * ReplaceNode(TGeoNode* nodeorig, TGeoShape* newshape = 0, TGeoMatrix* newpos = 0, TGeoMedium* newmed = 0); Replace an existing daughter with a new volume having the same name but; possibly a new shape, position or medium. Not allowed for positioned assemblies.; For division cells, the new shape/matrix are ignored. void SelectVolume(Bool_t clear = kFALSE); Select this volume as matching an arbitrary criteria. The volume is added to; a static list and the flag TGeoVolume::kVolumeSelected is set. All flags need; to be reset at the end by calling the method with CLEAR=true. This will also clear; the list. void SetVisibility(Bool_t vis = kTRUE); set visibility of this volume. void SetVisContainers(Bool_t flag = kTRUE); Set visibility for containers. void SetVisLeaves(Bool_t flag = kTRUE); Set visibility for leaves. void SetVisOnly(Bool_t flag = kTRUE); Set visibility for leaves. Bool_t Valid() const; Check if the shape of this volume is valid. Bool_t FindMatrixOfDaughterVolume(TGeoVolume* vol) const; Find a daughter node having VOL as volume and fill TGeoManager::fHMatrix; with its global matrix. void VisibleDaughters(Bool_t vis = kTRUE); set visibility for daughters. void Voxelize(Option_t* option); build the voxels for this volume. Double_t Weight(Double_t precision = 0.01, Option_t* option = ""va""); Estimate the weight of a volume (in kg) with ",MatchSource.WIKI,root/html528/TGeoVolume.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoVolume.html
https://root.cern/root/html528/TGeoVolume.html:30906,Usability,clear,clear,30906,"Style_t lstyle); Set the line style. void SetLineWidth(Width_t lwidth); Set the line width. TGeoNode * GetNode(const char* name) const; get the pointer to a daughter node. Int_t GetByteCount() const; get the total size in bytes for this volume. void FindOverlaps() const; loop all nodes marked as overlaps and find overlaping brothers. void RemoveNode(TGeoNode* node); Remove an existing daughter. TGeoNode * ReplaceNode(TGeoNode* nodeorig, TGeoShape* newshape = 0, TGeoMatrix* newpos = 0, TGeoMedium* newmed = 0); Replace an existing daughter with a new volume having the same name but; possibly a new shape, position or medium. Not allowed for positioned assemblies.; For division cells, the new shape/matrix are ignored. void SelectVolume(Bool_t clear = kFALSE); Select this volume as matching an arbitrary criteria. The volume is added to; a static list and the flag TGeoVolume::kVolumeSelected is set. All flags need; to be reset at the end by calling the method with CLEAR=true. This will also clear; the list. void SetVisibility(Bool_t vis = kTRUE); set visibility of this volume. void SetVisContainers(Bool_t flag = kTRUE); Set visibility for containers. void SetVisLeaves(Bool_t flag = kTRUE); Set visibility for leaves. void SetVisOnly(Bool_t flag = kTRUE); Set visibility for leaves. Bool_t Valid() const; Check if the shape of this volume is valid. Bool_t FindMatrixOfDaughterVolume(TGeoVolume* vol) const; Find a daughter node having VOL as volume and fill TGeoManager::fHMatrix; with its global matrix. void VisibleDaughters(Bool_t vis = kTRUE); set visibility for daughters. void Voxelize(Option_t* option); build the voxels for this volume. Double_t Weight(Double_t precision = 0.01, Option_t* option = ""va""); Estimate the weight of a volume (in kg) with SIGMA(M)/M better than PRECISION.; Option can contain : v - verbose, a - analytical (default). Double_t WeightA() const; Analytical computation of the weight. Int_t GetNdaughters() const; {if (!fNodes) return 0; return (fNodes->G",MatchSource.WIKI,root/html528/TGeoVolume.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoVolume.html
https://root.cern/root/html528/TGeoVolumeAssembly.html:10587,Availability,error,error,10587,"t; virtual Int_tTNamed::Compare(const TObject* obj) const; Bool_tTGeoVolume::Contains(Double_t* point) const; virtual voidTNamed::Copy(TObject& named) const; Int_tTGeoVolume::CountNodes(Int_t nlevels = 1000, Int_t option = 0); virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTGeoVolume::DistancetoPrimitive(Int_t px, Int_t py); virtual TGeoVolume*Divide(const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step, Int_t numed = 0, Option_t* option = """"); virtual voidTGeoVolume::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidDrawOnly(Option_t*); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoVolume::ExecuteEvent(Int_t event, Int_t px, Int_t py); Int_tTGeoVolume::Export(const char* filename, const char* name = """", Option_t* option = """"); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); Bool_tTGeoVolume::FindMatrixOfDaughterVolume(TGeoVolume* vol) const; TGeoNode*TGeoVolume::FindNode(const char* name) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; voidTGeoVolume::FindOverlaps() const; virtual Int_tTGeoVolume::GetByteCount() const; virtual Int_tGetCurrentNodeIndex() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); TObject*TGeoVolume::GetField() const; virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; TGeoPatternFinder*TGeoVolume:",MatchSource.WIKI,root/html528/TGeoVolumeAssembly.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoVolumeAssembly.html
https://root.cern/root/html528/TGeoVolumeAssembly.html:10671,Availability,error,error,10671,"s(Double_t* point) const; virtual voidTNamed::Copy(TObject& named) const; Int_tTGeoVolume::CountNodes(Int_t nlevels = 1000, Int_t option = 0); virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTGeoVolume::DistancetoPrimitive(Int_t px, Int_t py); virtual TGeoVolume*Divide(const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step, Int_t numed = 0, Option_t* option = """"); virtual voidTGeoVolume::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidDrawOnly(Option_t*); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoVolume::ExecuteEvent(Int_t event, Int_t px, Int_t py); Int_tTGeoVolume::Export(const char* filename, const char* name = """", Option_t* option = """"); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); Bool_tTGeoVolume::FindMatrixOfDaughterVolume(TGeoVolume* vol) const; TGeoNode*TGeoVolume::FindNode(const char* name) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; voidTGeoVolume::FindOverlaps() const; virtual Int_tTGeoVolume::GetByteCount() const; virtual Int_tGetCurrentNodeIndex() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); TObject*TGeoVolume::GetField() const; virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; TGeoPatternFinder*TGeoVolume::GetFinder() const; TGeoManager*TGeoVolume::GetGeoManager() const; virtual const cha",MatchSource.WIKI,root/html528/TGeoVolumeAssembly.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoVolumeAssembly.html
https://root.cern/root/html528/TGeoVolumeAssembly.html:1876,Modifiability,inherit,inherits,1876,"rent name may represent a; an unique volume object, but may also represent more general a family (class); of volume objects having the same shape type and medium, but possibly; different shape parameters. It is the user's task to provide different names; for different volume families in order to avoid ambiguities at tracking time.; A generic family rather than a single volume is created only in two cases :; when a generic shape is provided to the volume constructor or when a division; operation is applied. Each volume in the geometry stores an unique; ID corresponding to its family. In order to ease-up their creation, the manager; class is providing an API that allows making a shape and a volume in a single step. Volumes are objects that can be visualized, therefore having visibility,; colour, line and fill attributes that can be defined or modified any time after; the volume creation. It is advisable however to define these properties just; after the first creation of a volume namespace, since in case of volume families; any new member created by the modeler inherits these properties. In order to provide navigation features, volumes have to be able to find; the proper container of any point defined in the local reference frame. This; can be the volume itself, one of its positioned daughter volumes or none if; the point is actually outside. On the other hand, volumes have to provide also; other navigation methods such as finding the distances to its shape boundaries; or which daughter will be crossed first. The implementation of these features; is done at shape level, but the local mother-daughters management is handled; by volumes that builds additional optimisation structures upon geometry closure.; In order to have navigation features properly working one has to follow the; general rules for building a valid geometry (see TGeoManager class). Now let's make a simple volume representing a copper wire. We suppose that; a medium is already created (see TGeoMedium cla",MatchSource.WIKI,root/html528/TGeoVolumeAssembly.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoVolumeAssembly.html
https://root.cern/root/html528/TGeoVolumeAssembly.html:1097,Safety,avoid,avoid,1097,"s Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GEOM; » GEOM; » TGeoVolumeAssembly. class TGeoVolumeAssembly: public TGeoVolume. TGeoVolume - the base class representing solids. Volumes are the basic objects used in building the geometrical hierarchy.; They represent unpositioned objects but store all information about the; placement of the other volumes they may contain. Therefore a volume can; be replicated several times in the geometry. In order to create a volume, one; has to put togeather a shape and a medium which are already defined. Volumes; have to be named by users at creation time. Every different name may represent a; an unique volume object, but may also represent more general a family (class); of volume objects having the same shape type and medium, but possibly; different shape parameters. It is the user's task to provide different names; for different volume families in order to avoid ambiguities at tracking time.; A generic family rather than a single volume is created only in two cases :; when a generic shape is provided to the volume constructor or when a division; operation is applied. Each volume in the geometry stores an unique; ID corresponding to its family. In order to ease-up their creation, the manager; class is providing an API that allows making a shape and a volume in a single step. Volumes are objects that can be visualized, therefore having visibility,; colour, line and fill attributes that can be defined or modified any time after; the volume creation. It is advisable however to define these properties just; after the first creation of a volume namespace, since in case of volume families; any new member created by the modeler inherits these properties. In order to provide navigation features, volumes have to be able to find; the proper container of any point defined in the local reference frame. This; can be the vo",MatchSource.WIKI,root/html528/TGeoVolumeAssembly.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoVolumeAssembly.html
https://root.cern/root/html528/TGeoVolumeAssembly.html:2694,Usability,simpl,simple,2694,"advisable however to define these properties just; after the first creation of a volume namespace, since in case of volume families; any new member created by the modeler inherits these properties. In order to provide navigation features, volumes have to be able to find; the proper container of any point defined in the local reference frame. This; can be the volume itself, one of its positioned daughter volumes or none if; the point is actually outside. On the other hand, volumes have to provide also; other navigation methods such as finding the distances to its shape boundaries; or which daughter will be crossed first. The implementation of these features; is done at shape level, but the local mother-daughters management is handled; by volumes that builds additional optimisation structures upon geometry closure.; In order to have navigation features properly working one has to follow the; general rules for building a valid geometry (see TGeoManager class). Now let's make a simple volume representing a copper wire. We suppose that; a medium is already created (see TGeoMedium class on how to create media).; We will create a TUBE shape for our wire, having Rmin=0cm, Rmax=0.01cm; and a half-length dZ=1cm :. TGeoTube *tube = new TGeoTube(""wire_tube"", 0, 0.01, 1);. One may ommit the name for the shape if no retreiving by name is further needed; during geometry building. The same shape can be shared by different volumes; having different names and materials. Now let's make the volume for our wire.; The prototype for volumes constructor looks like :. TGeoVolume::TGeoVolume(const char *name, TGeoShape *shape, TGeoMedium *med). Since TGeoTube derives brom the base shape class, we can provide it to the volume; constructor :. TGeoVolume *wire_co = new TGeoVolume(""WIRE_CO"", tube, ptrCOPPER);. Do not bother to delete neither the media, shapes or volumes that you have; created since all will be automatically cleaned on exit by the manager class.; If we would have taken a look insi",MatchSource.WIKI,root/html528/TGeoVolumeAssembly.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoVolumeAssembly.html
https://root.cern/root/html528/TGeoVolumeAssembly.html:4309,Usability,learn,learned,4309,"ed). Since TGeoTube derives brom the base shape class, we can provide it to the volume; constructor :. TGeoVolume *wire_co = new TGeoVolume(""WIRE_CO"", tube, ptrCOPPER);. Do not bother to delete neither the media, shapes or volumes that you have; created since all will be automatically cleaned on exit by the manager class.; If we would have taken a look inside TGeoManager::MakeTube() method, we would; have been able to create our wire with a single line :. TGeoVolume *wire_co = gGeoManager->MakeTube(""WIRE_CO"", ptrCOPPER, 0, 0.01, 1);. The same applies for all primitive shapes, for which there can be found; corresponding MakeSHAPE() methods. Their usage is much more convenient unless; a shape has to be shared between more volumes. Let's make now an aluminium wire; having the same shape, supposing that we have created the copper wire with the; line above :. TGeoVolume *wire_al = new TGeoVolume(""WIRE_AL"", wire_co->GetShape(), ptrAL);. Now that we have learned how to create elementary volumes, let's see how we; can create a geometrical hierarchy. Positioning volumes. When creating a volume one does not specify if this will contain or not other; volumes. Adding daughters to a volume implies creating those and adding them; one by one to the list of daughters. Since the volume has to know the position; of all its daughters, we will have to supply at the same time a geometrical; transformation with respect to its local reference frame for each of them.; The objects referencing a volume and a transformation are called NODES and; their creation is fully handled by the modeler. They represent the link; elements in the hierarchy of volumes. Nodes are unique and distinct geometrical; objects ONLY from their container point of view. Since volumes can be replicated; in the geometry, the same node may be found on different branches. /*. */. An important observation is that volume objects are owned by the TGeoManager; class. This stores a list of all volumes in the geometry, that is c",MatchSource.WIKI,root/html528/TGeoVolumeAssembly.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoVolumeAssembly.html
https://root.cern/root/html528/TGeoVolumeAssembly.html:5810,Usability,simpl,simplicity,5810,"its local reference frame for each of them.; The objects referencing a volume and a transformation are called NODES and; their creation is fully handled by the modeler. They represent the link; elements in the hierarchy of volumes. Nodes are unique and distinct geometrical; objects ONLY from their container point of view. Since volumes can be replicated; in the geometry, the same node may be found on different branches. /*. */. An important observation is that volume objects are owned by the TGeoManager; class. This stores a list of all volumes in the geometry, that is cleaned; upon destruction. Let's consider positioning now our wire in the middle of a gas chamber. We; need first to define the gas chamber :. TGeoVolume *chamber = gGeoManager->MakeTube(""CHAMBER"", ptrGAS, 0, 1, 1);. Now we can put the wire inside :. chamber->AddNode(wire_co, 1);. If we inspect now the chamber volume in a browser, we will notice that it has; one daughter. Of course the gas has some container also, but let's keep it like; that for the sake of simplicity. The full prototype of AddNode() is :. TGeoVolume::AddNode(TGeoVolume *daughter, Int_t usernumber,; TGeoMatrix *matrix=gGeoIdentity). Since we did not supplied the third argument, the wire will be positioned with; an identity transformation inside the chamber. One will notice that the inner; radii of the wire and chamber are both zero - therefore, aren't the two volumes; overlapping ? The answer is no, the modeler is even relaying on the fact that; any daughter is fully contained by its mother. On the other hand, neither of; the nodes positioned inside a volume should overlap with each other. We will; see that there are allowed some exceptions to those rules. Overlapping volumes. Positioning volumes that does not overlap their neighbours nor extrude; their container is sometimes quite strong contrain. Some parts of the geometry; might overlap naturally, e.g. two crossing tubes. The modeller supports such; cases only if the overlapping n",MatchSource.WIKI,root/html528/TGeoVolumeAssembly.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoVolumeAssembly.html
https://root.cern/root/html528/TGeoVolumeAssembly.html:17408,Usability,clear,clear,17408,"Object::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTGeoVolume::RegisterYourself(Option_t* option = """"); voidTGeoVolume::RemoveNode(TGeoNode* node); TGeoNode*TGeoVolume::ReplaceNode(TGeoNode* nodeorig, TGeoShape* newshape = 0, TGeoMatrix* newpos = 0, TGeoMedium* newmed = 0); voidTGeoVolume::ReplayCreation(const TGeoVolume* other); voidTGeoAtt::ResetAttBit(UInt_t f); virtual voidTAttFill::ResetAttFill(Option_t* option = """"); virtual voidTAttLine::ResetAttLine(Option_t* option = """"); voidTObject::ResetBit(UInt_t f); virtual voidTGeoVolume::SaveAs(const char* filename, Option_t* option = """") constMENU ; virtual voidTAttFill::SaveFillAttributes(ostream& out, const char* name, Int_t coldef = 1, Int_t stydef = 1001); virtual voidTAttLine::SaveLineAttributes(ostream& out, const char* name, Int_t coldef = 1, Int_t stydef = 1, Int_t widdef = 1); virtual voidTGeoVolume::SavePrimitive(ostream& out, Option_t* option = """"); voidTGeoVolume::SelectVolume(Bool_t clear = kFALSE); voidTGeoVolume::SetActiveDaughters(Bool_t flag = kTRUE); voidTGeoVolume::SetActivity(Bool_t flag = kTRUE); voidTGeoVolume::SetAdded(); voidTGeoVolume::SetAsTopVolume()TOGGLE GETTER ; voidTGeoAtt::SetAttBit(UInt_t f); voidTGeoAtt::SetAttBit(UInt_t f, Bool_t set); voidTGeoVolume::SetAttVisibility(Bool_t vis); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidSetCurrentNodeIndex(Int_t index); voidTGeoVolume::SetCurrentPoint(Double_t x, Double_t y, Double_t z); voidTGeoVolume::SetCylVoxels(Bool_t flag = kTRUE); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTGeoVolume::SetField(TObject* field); virtual voidTAttFill::SetFillAttributes()MENU ; virtual voidTAttFill::SetFillColor(Color_t fcolor); virtual voidTAttFill::SetFillStyle(Style_t fstyle); voidTGeoVolume::SetFinder(TGeoPatternFinder* finder); voidTGeoVolume::SetInvisible(); virtual voidTAttLine::SetLineAttributes()MENU ; virtual v",MatchSource.WIKI,root/html528/TGeoVolumeAssembly.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoVolumeAssembly.html
https://root.cern/root/html528/TGeoVolumeDialog.html:5132,Availability,error,error,5132,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); TList*TGMainFrame::GetBindList() const; static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; voidTGMainFrame::GetClassHints(const char*& className, const char*& resourceName) const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBa",MatchSource.WIKI,root/html528/TGeoVolumeDialog.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoVolumeDialog.html
https://root.cern/root/html528/TGeoVolumeDialog.html:5216,Availability,error,error,5216,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); TList*TGMainFrame::GetBindList() const; static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; voidTGMainFrame::GetClassHints(const char*& className, const char*& resourceName) const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UIn",MatchSource.WIKI,root/html528/TGeoVolumeDialog.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoVolumeDialog.html
https://root.cern/root/html528/TGeoVolumeDialog.html:19643,Availability,mask,mask,19643,,MatchSource.WIKI,root/html528/TGeoVolumeDialog.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoVolumeDialog.html
https://root.cern/root/html528/TGeoVolumeEditor.html:1335,Availability,down,down,1335,"ditor. Editor for geometry volumes and assemblies of volumes. Besides the volume; name and line attributes, a TGeoVolume has the following editable categories; splitted vertically by a shutter:; - Properties: one can edit the shape and medium components from here. It is; also possible to change the existing ones.; - Daughters: the main category allowing defining, editing, removing or; positioning daughter volumes inside the current edited volume. To add a; daughter, one needs to select first a volume and a matrix. Currently no check; is performed if the daughter volume creates an extrusion (illegal for tracking).; To remove or change the position of an existing daughter, one should simply; select the desired daughter from the combo box with the existing ones, then; simply click the appropriate button.; - Visualization: One can set the visibility of the volume and of its daughters,; set the visibility depth and the view type. Selecting ""All"" will draw the; volume and all visible daughters down to the selected level starting from the; edited volume. Selecting ""Leaves"" will draw just the deepest daughters within; the selected visibility level, without displaying the containers, while ""Only""; will just draw the edited volume.; - Division: The category becomes active only if there are no daughters of the; edited volume added by normal positioning (e.g. from <Daughters> category). The; minimum allowed starting value for the selected division axis is automatically; selected, while the dslicing step is set to 0 - meaning that only the number; of slices matter. Function Members (Methods); public:. TGeoVolumeEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); virtual~TGeoVolumeEditor(); voidTObject::AbstractMethod(const char* method) const; virtual Bool_tTGedFrame::AcceptModel(TObject*); virtual voidTGFrame::Activate(Bool_t); virtual voidActivateBaseClassEditors(TClass* cl); virtual void",MatchSource.WIKI,root/html528/TGeoVolumeEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoVolumeEditor.html
https://root.cern/root/html528/TGeoVolumeEditor.html:6488,Availability,error,error,6488,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const;",MatchSource.WIKI,root/html528/TGeoVolumeEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoVolumeEditor.html
https://root.cern/root/html528/TGeoVolumeEditor.html:6572,Availability,error,error,6572,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType() c",MatchSource.WIKI,root/html528/TGeoVolumeEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoVolumeEditor.html
https://root.cern/root/html528/TGeoVolumeEditor.html:20464,Availability,mask,mask,20464,,MatchSource.WIKI,root/html528/TGeoVolumeEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoVolumeEditor.html
https://root.cern/root/html528/TGeoVolumeEditor.html:875,Performance,perform,performed,875,". TGeoVolumeEditor. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GEOM; » GEOMBUILDER; » TGeoVolumeEditor. class TGeoVolumeEditor: public TGeoGedFrame. TGeoVolumeEditor. Editor for geometry volumes and assemblies of volumes. Besides the volume; name and line attributes, a TGeoVolume has the following editable categories; splitted vertically by a shutter:; - Properties: one can edit the shape and medium components from here. It is; also possible to change the existing ones.; - Daughters: the main category allowing defining, editing, removing or; positioning daughter volumes inside the current edited volume. To add a; daughter, one needs to select first a volume and a matrix. Currently no check; is performed if the daughter volume creates an extrusion (illegal for tracking).; To remove or change the position of an existing daughter, one should simply; select the desired daughter from the combo box with the existing ones, then; simply click the appropriate button.; - Visualization: One can set the visibility of the volume and of its daughters,; set the visibility depth and the view type. Selecting ""All"" will draw the; volume and all visible daughters down to the selected level starting from the; edited volume. Selecting ""Leaves"" will draw just the deepest daughters within; the selected visibility level, without displaying the containers, while ""Only""; will just draw the edited volume.; - Division: The category becomes active only if there are no daughters of the; edited volume added by normal positioning (e.g. from <Daughters> category). The; minimum allowed starting value for the selected division axis is automatically; selected, while the dslicing step is set to 0 - meaning that only the number; of slices matter. Function Members (Methods); public:. TGeoVolumeEditor(const TGWindow* p = 0, Int_t width =",MatchSource.WIKI,root/html528/TGeoVolumeEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoVolumeEditor.html
https://root.cern/root/html528/TGeoVolumeEditor.html:1023,Usability,simpl,simply,1023," Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GEOM; » GEOMBUILDER; » TGeoVolumeEditor. class TGeoVolumeEditor: public TGeoGedFrame. TGeoVolumeEditor. Editor for geometry volumes and assemblies of volumes. Besides the volume; name and line attributes, a TGeoVolume has the following editable categories; splitted vertically by a shutter:; - Properties: one can edit the shape and medium components from here. It is; also possible to change the existing ones.; - Daughters: the main category allowing defining, editing, removing or; positioning daughter volumes inside the current edited volume. To add a; daughter, one needs to select first a volume and a matrix. Currently no check; is performed if the daughter volume creates an extrusion (illegal for tracking).; To remove or change the position of an existing daughter, one should simply; select the desired daughter from the combo box with the existing ones, then; simply click the appropriate button.; - Visualization: One can set the visibility of the volume and of its daughters,; set the visibility depth and the view type. Selecting ""All"" will draw the; volume and all visible daughters down to the selected level starting from the; edited volume. Selecting ""Leaves"" will draw just the deepest daughters within; the selected visibility level, without displaying the containers, while ""Only""; will just draw the edited volume.; - Division: The category becomes active only if there are no daughters of the; edited volume added by normal positioning (e.g. from <Daughters> category). The; minimum allowed starting value for the selected division axis is automatically; selected, while the dslicing step is set to 0 - meaning that only the number; of slices matter. Function Members (Methods); public:. TGeoVolumeEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChil",MatchSource.WIKI,root/html528/TGeoVolumeEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoVolumeEditor.html
https://root.cern/root/html528/TGeoVolumeEditor.html:1108,Usability,simpl,simply,1108," Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GEOM; » GEOMBUILDER; » TGeoVolumeEditor. class TGeoVolumeEditor: public TGeoGedFrame. TGeoVolumeEditor. Editor for geometry volumes and assemblies of volumes. Besides the volume; name and line attributes, a TGeoVolume has the following editable categories; splitted vertically by a shutter:; - Properties: one can edit the shape and medium components from here. It is; also possible to change the existing ones.; - Daughters: the main category allowing defining, editing, removing or; positioning daughter volumes inside the current edited volume. To add a; daughter, one needs to select first a volume and a matrix. Currently no check; is performed if the daughter volume creates an extrusion (illegal for tracking).; To remove or change the position of an existing daughter, one should simply; select the desired daughter from the combo box with the existing ones, then; simply click the appropriate button.; - Visualization: One can set the visibility of the volume and of its daughters,; set the visibility depth and the view type. Selecting ""All"" will draw the; volume and all visible daughters down to the selected level starting from the; edited volume. Selecting ""Leaves"" will draw just the deepest daughters within; the selected visibility level, without displaying the containers, while ""Only""; will just draw the edited volume.; - Division: The category becomes active only if there are no daughters of the; edited volume added by normal positioning (e.g. from <Daughters> category). The; minimum allowed starting value for the selected division axis is automatically; selected, while the dslicing step is set to 0 - meaning that only the number; of slices matter. Function Members (Methods); public:. TGeoVolumeEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChil",MatchSource.WIKI,root/html528/TGeoVolumeEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoVolumeEditor.html
https://root.cern/root/html528/TGeoVolumeMulti.html:10617,Availability,error,error,10617,"re(const TObject* obj) const; Bool_tTGeoVolume::Contains(Double_t* point) const; virtual voidTNamed::Copy(TObject& named) const; Int_tTGeoVolume::CountNodes(Int_t nlevels = 1000, Int_t option = 0); virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTGeoVolume::DistancetoPrimitive(Int_t px, Int_t py); virtual TGeoVolume*Divide(const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step, Int_t numed = 0, Option_t* option = """"); virtual voidTGeoVolume::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTGeoVolume::DrawOnly(Option_t* option = """")MENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoVolume::ExecuteEvent(Int_t event, Int_t px, Int_t py); Int_tTGeoVolume::Export(const char* filename, const char* name = """", Option_t* option = """"); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); Bool_tTGeoVolume::FindMatrixOfDaughterVolume(TGeoVolume* vol) const; TGeoNode*TGeoVolume::FindNode(const char* name) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; voidTGeoVolume::FindOverlaps() const; Int_tGetAxis() const; virtual Int_tTGeoVolume::GetByteCount() const; virtual Int_tTGeoVolume::GetCurrentNodeIndex() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); TObject*TGeoVolume::GetField() const; virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() co",MatchSource.WIKI,root/html528/TGeoVolumeMulti.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoVolumeMulti.html
https://root.cern/root/html528/TGeoVolumeMulti.html:10701,Availability,error,error,10701,"tual voidTNamed::Copy(TObject& named) const; Int_tTGeoVolume::CountNodes(Int_t nlevels = 1000, Int_t option = 0); virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTGeoVolume::DistancetoPrimitive(Int_t px, Int_t py); virtual TGeoVolume*Divide(const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step, Int_t numed = 0, Option_t* option = """"); virtual voidTGeoVolume::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTGeoVolume::DrawOnly(Option_t* option = """")MENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoVolume::ExecuteEvent(Int_t event, Int_t px, Int_t py); Int_tTGeoVolume::Export(const char* filename, const char* name = """", Option_t* option = """"); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); Bool_tTGeoVolume::FindMatrixOfDaughterVolume(TGeoVolume* vol) const; TGeoNode*TGeoVolume::FindNode(const char* name) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; voidTGeoVolume::FindOverlaps() const; Int_tGetAxis() const; virtual Int_tTGeoVolume::GetByteCount() const; virtual Int_tTGeoVolume::GetCurrentNodeIndex() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); TObject*TGeoVolume::GetField() const; virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; TGeoPatternFinder*TGeoVolume::GetFinder() const; TGeoManager*TGeoVolume::GetGeo",MatchSource.WIKI,root/html528/TGeoVolumeMulti.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoVolumeMulti.html
https://root.cern/root/html528/TGeoVolumeMulti.html:1867,Modifiability,inherit,inherits,1867,"rent name may represent a; an unique volume object, but may also represent more general a family (class); of volume objects having the same shape type and medium, but possibly; different shape parameters. It is the user's task to provide different names; for different volume families in order to avoid ambiguities at tracking time.; A generic family rather than a single volume is created only in two cases :; when a generic shape is provided to the volume constructor or when a division; operation is applied. Each volume in the geometry stores an unique; ID corresponding to its family. In order to ease-up their creation, the manager; class is providing an API that allows making a shape and a volume in a single step. Volumes are objects that can be visualized, therefore having visibility,; colour, line and fill attributes that can be defined or modified any time after; the volume creation. It is advisable however to define these properties just; after the first creation of a volume namespace, since in case of volume families; any new member created by the modeler inherits these properties. In order to provide navigation features, volumes have to be able to find; the proper container of any point defined in the local reference frame. This; can be the volume itself, one of its positioned daughter volumes or none if; the point is actually outside. On the other hand, volumes have to provide also; other navigation methods such as finding the distances to its shape boundaries; or which daughter will be crossed first. The implementation of these features; is done at shape level, but the local mother-daughters management is handled; by volumes that builds additional optimisation structures upon geometry closure.; In order to have navigation features properly working one has to follow the; general rules for building a valid geometry (see TGeoManager class). Now let's make a simple volume representing a copper wire. We suppose that; a medium is already created (see TGeoMedium cla",MatchSource.WIKI,root/html528/TGeoVolumeMulti.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoVolumeMulti.html
https://root.cern/root/html528/TGeoVolumeMulti.html:1088,Safety,avoid,avoid,1088,"; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GEOM; » GEOM; » TGeoVolumeMulti. class TGeoVolumeMulti: public TGeoVolume. TGeoVolume - the base class representing solids. Volumes are the basic objects used in building the geometrical hierarchy.; They represent unpositioned objects but store all information about the; placement of the other volumes they may contain. Therefore a volume can; be replicated several times in the geometry. In order to create a volume, one; has to put togeather a shape and a medium which are already defined. Volumes; have to be named by users at creation time. Every different name may represent a; an unique volume object, but may also represent more general a family (class); of volume objects having the same shape type and medium, but possibly; different shape parameters. It is the user's task to provide different names; for different volume families in order to avoid ambiguities at tracking time.; A generic family rather than a single volume is created only in two cases :; when a generic shape is provided to the volume constructor or when a division; operation is applied. Each volume in the geometry stores an unique; ID corresponding to its family. In order to ease-up their creation, the manager; class is providing an API that allows making a shape and a volume in a single step. Volumes are objects that can be visualized, therefore having visibility,; colour, line and fill attributes that can be defined or modified any time after; the volume creation. It is advisable however to define these properties just; after the first creation of a volume namespace, since in case of volume families; any new member created by the modeler inherits these properties. In order to provide navigation features, volumes have to be able to find; the proper container of any point defined in the local reference frame. This; can be the vo",MatchSource.WIKI,root/html528/TGeoVolumeMulti.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoVolumeMulti.html
https://root.cern/root/html528/TGeoVolumeMulti.html:2685,Usability,simpl,simple,2685,"advisable however to define these properties just; after the first creation of a volume namespace, since in case of volume families; any new member created by the modeler inherits these properties. In order to provide navigation features, volumes have to be able to find; the proper container of any point defined in the local reference frame. This; can be the volume itself, one of its positioned daughter volumes or none if; the point is actually outside. On the other hand, volumes have to provide also; other navigation methods such as finding the distances to its shape boundaries; or which daughter will be crossed first. The implementation of these features; is done at shape level, but the local mother-daughters management is handled; by volumes that builds additional optimisation structures upon geometry closure.; In order to have navigation features properly working one has to follow the; general rules for building a valid geometry (see TGeoManager class). Now let's make a simple volume representing a copper wire. We suppose that; a medium is already created (see TGeoMedium class on how to create media).; We will create a TUBE shape for our wire, having Rmin=0cm, Rmax=0.01cm; and a half-length dZ=1cm :. TGeoTube *tube = new TGeoTube(""wire_tube"", 0, 0.01, 1);. One may ommit the name for the shape if no retreiving by name is further needed; during geometry building. The same shape can be shared by different volumes; having different names and materials. Now let's make the volume for our wire.; The prototype for volumes constructor looks like :. TGeoVolume::TGeoVolume(const char *name, TGeoShape *shape, TGeoMedium *med). Since TGeoTube derives brom the base shape class, we can provide it to the volume; constructor :. TGeoVolume *wire_co = new TGeoVolume(""WIRE_CO"", tube, ptrCOPPER);. Do not bother to delete neither the media, shapes or volumes that you have; created since all will be automatically cleaned on exit by the manager class.; If we would have taken a look insi",MatchSource.WIKI,root/html528/TGeoVolumeMulti.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoVolumeMulti.html
https://root.cern/root/html528/TGeoVolumeMulti.html:4300,Usability,learn,learned,4300,"ed). Since TGeoTube derives brom the base shape class, we can provide it to the volume; constructor :. TGeoVolume *wire_co = new TGeoVolume(""WIRE_CO"", tube, ptrCOPPER);. Do not bother to delete neither the media, shapes or volumes that you have; created since all will be automatically cleaned on exit by the manager class.; If we would have taken a look inside TGeoManager::MakeTube() method, we would; have been able to create our wire with a single line :. TGeoVolume *wire_co = gGeoManager->MakeTube(""WIRE_CO"", ptrCOPPER, 0, 0.01, 1);. The same applies for all primitive shapes, for which there can be found; corresponding MakeSHAPE() methods. Their usage is much more convenient unless; a shape has to be shared between more volumes. Let's make now an aluminium wire; having the same shape, supposing that we have created the copper wire with the; line above :. TGeoVolume *wire_al = new TGeoVolume(""WIRE_AL"", wire_co->GetShape(), ptrAL);. Now that we have learned how to create elementary volumes, let's see how we; can create a geometrical hierarchy. Positioning volumes. When creating a volume one does not specify if this will contain or not other; volumes. Adding daughters to a volume implies creating those and adding them; one by one to the list of daughters. Since the volume has to know the position; of all its daughters, we will have to supply at the same time a geometrical; transformation with respect to its local reference frame for each of them.; The objects referencing a volume and a transformation are called NODES and; their creation is fully handled by the modeler. They represent the link; elements in the hierarchy of volumes. Nodes are unique and distinct geometrical; objects ONLY from their container point of view. Since volumes can be replicated; in the geometry, the same node may be found on different branches. /*. */. An important observation is that volume objects are owned by the TGeoManager; class. This stores a list of all volumes in the geometry, that is c",MatchSource.WIKI,root/html528/TGeoVolumeMulti.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoVolumeMulti.html
https://root.cern/root/html528/TGeoVolumeMulti.html:5801,Usability,simpl,simplicity,5801,"its local reference frame for each of them.; The objects referencing a volume and a transformation are called NODES and; their creation is fully handled by the modeler. They represent the link; elements in the hierarchy of volumes. Nodes are unique and distinct geometrical; objects ONLY from their container point of view. Since volumes can be replicated; in the geometry, the same node may be found on different branches. /*. */. An important observation is that volume objects are owned by the TGeoManager; class. This stores a list of all volumes in the geometry, that is cleaned; upon destruction. Let's consider positioning now our wire in the middle of a gas chamber. We; need first to define the gas chamber :. TGeoVolume *chamber = gGeoManager->MakeTube(""CHAMBER"", ptrGAS, 0, 1, 1);. Now we can put the wire inside :. chamber->AddNode(wire_co, 1);. If we inspect now the chamber volume in a browser, we will notice that it has; one daughter. Of course the gas has some container also, but let's keep it like; that for the sake of simplicity. The full prototype of AddNode() is :. TGeoVolume::AddNode(TGeoVolume *daughter, Int_t usernumber,; TGeoMatrix *matrix=gGeoIdentity). Since we did not supplied the third argument, the wire will be positioned with; an identity transformation inside the chamber. One will notice that the inner; radii of the wire and chamber are both zero - therefore, aren't the two volumes; overlapping ? The answer is no, the modeler is even relaying on the fact that; any daughter is fully contained by its mother. On the other hand, neither of; the nodes positioned inside a volume should overlap with each other. We will; see that there are allowed some exceptions to those rules. Overlapping volumes. Positioning volumes that does not overlap their neighbours nor extrude; their container is sometimes quite strong contrain. Some parts of the geometry; might overlap naturally, e.g. two crossing tubes. The modeller supports such; cases only if the overlapping n",MatchSource.WIKI,root/html528/TGeoVolumeMulti.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoVolumeMulti.html
https://root.cern/root/html528/TGeoVolumeMulti.html:17586,Usability,clear,clear,17586,"Object::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTGeoVolume::RegisterYourself(Option_t* option = """"); voidTGeoVolume::RemoveNode(TGeoNode* node); TGeoNode*TGeoVolume::ReplaceNode(TGeoNode* nodeorig, TGeoShape* newshape = 0, TGeoMatrix* newpos = 0, TGeoMedium* newmed = 0); voidTGeoVolume::ReplayCreation(const TGeoVolume* other); voidTGeoAtt::ResetAttBit(UInt_t f); virtual voidTAttFill::ResetAttFill(Option_t* option = """"); virtual voidTAttLine::ResetAttLine(Option_t* option = """"); voidTObject::ResetBit(UInt_t f); virtual voidTGeoVolume::SaveAs(const char* filename, Option_t* option = """") constMENU ; virtual voidTAttFill::SaveFillAttributes(ostream& out, const char* name, Int_t coldef = 1, Int_t stydef = 1001); virtual voidTAttLine::SaveLineAttributes(ostream& out, const char* name, Int_t coldef = 1, Int_t stydef = 1, Int_t widdef = 1); virtual voidTGeoVolume::SavePrimitive(ostream& out, Option_t* option = """"); voidTGeoVolume::SelectVolume(Bool_t clear = kFALSE); voidTGeoVolume::SetActiveDaughters(Bool_t flag = kTRUE); voidTGeoVolume::SetActivity(Bool_t flag = kTRUE); voidTGeoVolume::SetAdded(); voidTGeoVolume::SetAsTopVolume()TOGGLE GETTER ; voidTGeoAtt::SetAttBit(UInt_t f); voidTGeoAtt::SetAttBit(UInt_t f, Bool_t set); voidTGeoVolume::SetAttVisibility(Bool_t vis); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTGeoVolume::SetCurrentPoint(Double_t x, Double_t y, Double_t z); voidTGeoVolume::SetCylVoxels(Bool_t flag = kTRUE); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTGeoVolume::SetField(TObject* field); virtual voidTAttFill::SetFillAttributes()MENU ; virtual voidTAttFill::SetFillColor(Color_t fcolor); virtual voidTAttFill::SetFillStyle(Style_t fstyle); voidTGeoVolume::SetFinder(TGeoPatternFinder* finder); voidTGeoVolume::SetInvisible(); virtual voidTAttLine::SetLineAttributes()MENU ; virtual voidSetLineColor(Color_t lcolor); virtu",MatchSource.WIKI,root/html528/TGeoVolumeMulti.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoVolumeMulti.html
https://root.cern/root/html528/TGeoVoxelFinder.html:1522,Availability,error,error,1522,"onst; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidCreateCheckList(); voidDaughterToMother(Int_t id, Double_t* local, Double_t* master) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual Double_tEfficiency(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidFindOverlaps(Int_t inode) const; Double_t*GetBoxes() const; Int_t*GetCheckList(Int_t& nelem) const; virtual Int_t*GetCheckList(Double_t* point, Int_t& nelem); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual Int_t*GetNextCandidates(Double_t* point, Int_t& ncheck); virtual Int_t*GetNextVoxel(Double_t* point, Double_t* dir, Int_t& ncheck); virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; vir",MatchSource.WIKI,root/html528/TGeoVoxelFinder.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoVoxelFinder.html
https://root.cern/root/html528/TGeoVoxelFinder.html:1606,Availability,error,error,1606,"owse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidCreateCheckList(); voidDaughterToMother(Int_t id, Double_t* local, Double_t* master) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual Double_tEfficiency(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidFindOverlaps(Int_t inode) const; Double_t*GetBoxes() const; Int_t*GetCheckList(Int_t& nelem) const; virtual Int_t*GetCheckList(Double_t* point, Int_t& nelem); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual Int_t*GetNextCandidates(Double_t* point, Int_t& ncheck); virtual Int_t*GetNextVoxel(Double_t* point, Double_t* dir, Int_t& ncheck); virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() cons",MatchSource.WIKI,root/html528/TGeoVoxelFinder.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoVoxelFinder.html
https://root.cern/root/html528/TGeoXtru.html:4124,Availability,error,error,4124,"px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*TGeoBBox::Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const char*TGeoBBox::GetAxisName(Int_t iaxis) const; virtual Double_tTGeoBBox::GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; virtual voidTGeoBBox::GetBoundingCylinder(Double_t* param) const; virtual const TBuffer3D&GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; virtual Int_tTGeoBBox::GetByteCount() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_tTGeoBBox::GetDX() const; virtual Double_tTGeoBBox::GetDY() const; virtual Double_tTGeoBBox::GetDZ() const; virtual Double_tTGeoBBox::GetFacetArea(In",MatchSource.WIKI,root/html528/TGeoXtru.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoXtru.html
https://root.cern/root/html528/TGeoXtru.html:4208,Availability,error,error,4208,"iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*TGeoBBox::Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const char*TGeoBBox::GetAxisName(Int_t iaxis) const; virtual Double_tTGeoBBox::GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; virtual voidTGeoBBox::GetBoundingCylinder(Double_t* param) const; virtual const TBuffer3D&GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; virtual Int_tTGeoBBox::GetByteCount() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_tTGeoBBox::GetDX() const; virtual Double_tTGeoBBox::GetDY() const; virtual Double_tTGeoBBox::GetDZ() const; virtual Double_tTGeoBBox::GetFacetArea(Int_t index = 0) const; virtual Int_tTGeoBBox::GetFittingBox(const TGeoBBox* parambox,",MatchSource.WIKI,root/html528/TGeoXtru.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoXtru.html
https://root.cern/root/html528/TGeoXtru.html:3265,Safety,safe,safe,3265,,MatchSource.WIKI,root/html528/TGeoXtru.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoXtru.html
https://root.cern/root/html528/TGeoXtru.html:3406,Safety,safe,safe,3406,,MatchSource.WIKI,root/html528/TGeoXtru.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoXtru.html
https://root.cern/root/html528/TGeoXtru.html:15294,Safety,safe,safe,15294,"ition of first plane; param[4] = scale1 // scale factor for first plane. param[4*(nz-1]+1] = zn; param[4*(nz-1)+2] = xn; param[4*(nz-1)+3] = yn; param[4*(nz-1)+4] = scalen. TGeoXtru(const TGeoXtru& ); copy constructor. TGeoXtru& operator=(const TGeoXtru& ); assignment operator. ~TGeoXtru(); destructor. Double_t Capacity() const; Compute capacity [length^3] of this shape. void ComputeBBox(); compute bounding box of the pcon. void ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. Bool_t Contains(Double_t* point) const; test if point is inside this shape; Check Z range. Int_t DistancetoPrimitive(Int_t px, Int_t py); compute closest distance from point px,py to each corner. Double_t DistToPlane(Double_t* point, Double_t* dir, Int_t iz, Int_t ivert, Double_t stepmax, Bool_t in) const; Compute distance to a Xtru lateral surface. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from inside point to surface of the polycone; locate Z segment. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from outside point to surface of the tube; Warning(""DistFromOutside"", ""not implemented"");. Bool_t DefinePolygon(Int_t nvert, const Double_t* xv, const Double_t* yv); Creates the polygon representing the blueprint of any Xtru section.; nvert = number of vertices >2; xv[nvert] = array of X vertex positions; yv[nvert] = array of Y vertex positions; *NOTE* should be called before DefineSection or ctor with 'param'. void DefineSection(Int_t snum, Double_t z, Double_t x0 = 0., Double_t y0 = 0., Double_t scale = 1.); defines z position of a section plane, rmin and rmax at this z. Double_t GetZ(Int_t ipl) const; Return the Z coordinate for segment ipl. void GetPlaneNormal(const Double_t* vert, Double_t* norm) const; Returns normal vector t",MatchSource.WIKI,root/html528/TGeoXtru.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoXtru.html
https://root.cern/root/html528/TGeoXtru.html:15509,Safety,safe,safe,15509," operator=(const TGeoXtru& ); assignment operator. ~TGeoXtru(); destructor. Double_t Capacity() const; Compute capacity [length^3] of this shape. void ComputeBBox(); compute bounding box of the pcon. void ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. Bool_t Contains(Double_t* point) const; test if point is inside this shape; Check Z range. Int_t DistancetoPrimitive(Int_t px, Int_t py); compute closest distance from point px,py to each corner. Double_t DistToPlane(Double_t* point, Double_t* dir, Int_t iz, Int_t ivert, Double_t stepmax, Bool_t in) const; Compute distance to a Xtru lateral surface. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from inside point to surface of the polycone; locate Z segment. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from outside point to surface of the tube; Warning(""DistFromOutside"", ""not implemented"");. Bool_t DefinePolygon(Int_t nvert, const Double_t* xv, const Double_t* yv); Creates the polygon representing the blueprint of any Xtru section.; nvert = number of vertices >2; xv[nvert] = array of X vertex positions; yv[nvert] = array of Y vertex positions; *NOTE* should be called before DefineSection or ctor with 'param'. void DefineSection(Int_t snum, Double_t z, Double_t x0 = 0., Double_t y0 = 0., Double_t scale = 1.); defines z position of a section plane, rmin and rmax at this z. Double_t GetZ(Int_t ipl) const; Return the Z coordinate for segment ipl. void GetPlaneNormal(const Double_t* vert, Double_t* norm) const; Returns normal vector to the planar quadrilateral defined by vector VERT.; The normal points outwards the xtru. void GetPlaneVertices(Int_t iz, Int_t ivert, Double_t* vert) const; Returns (x,y,z) of 3 vertices of the surface defined by Z sections (iz,",MatchSource.WIKI,root/html528/TGeoXtru.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoXtru.html
https://root.cern/root/html528/TGeoXtru.html:17079,Safety,safe,safety,17079,"sition of a section plane, rmin and rmax at this z. Double_t GetZ(Int_t ipl) const; Return the Z coordinate for segment ipl. void GetPlaneNormal(const Double_t* vert, Double_t* norm) const; Returns normal vector to the planar quadrilateral defined by vector VERT.; The normal points outwards the xtru. void GetPlaneVertices(Int_t iz, Int_t ivert, Double_t* vert) const; Returns (x,y,z) of 3 vertices of the surface defined by Z sections (iz, iz+1); and polygon vertices (ivert, ivert+1). No range check. Bool_t IsPointInsidePlane(Double_t* point, Double_t* vert, Double_t* norm) const; Check if the quadrilateral defined by VERT contains a coplanar POINT. void InspectShape() const; Print actual Xtru parameters. TBuffer3D * MakeBuffer3D() const; Creates a TBuffer3D describing *this* shape.; Coordinates are in local reference frame. void SetSegsAndPols(TBuffer3D& buff) const; Fill TBuffer3D structure for segments and polygons. Double_t SafetyToSector(Double_t* point, Int_t iz, Double_t safmin); Compute safety to sector iz, returning also the closest segment index. Double_t Safety(Double_t* point, Bool_t in = kTRUE) const; computes the closest distance from given point to this shape, according; to option. The matching point on the shape is stored in spoint.; ---> localize the Z segment. void SavePrimitive(ostream& out, Option_t* option = """"); Save a primitive as a C++ statement(s) on output stream ""out"". void SetCurrentZ(Double_t z, Int_t iz); Recompute current section vertices for a given Z position within range of section iz. void SetCurrentVertices(Double_t x0, Double_t y0, Double_t scale); Set current vertex coordinates according X0, Y0 and SCALE. void SetDimensions(Double_t* param); param[0] = nz // number of z planes. param[1] = z1 // Z position of first plane; param[2] = x1 // X position of first plane; param[3] = y1 // Y position of first plane; param[4] = scale1 // scale factor for first plane. param[4*(nz-1]+1] = zn; param[4*(nz-1)+2] = xn; param[4*(nz-1)+3] = yn; pa",MatchSource.WIKI,root/html528/TGeoXtru.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoXtru.html
https://root.cern/root/html528/TGeoXtru.html:14866,Testability,test,test,14866,"sitions ; Double_tfZcurrentcurrent Z position. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoXtru(); dummy ctor. TGeoXtru(Int_t nz); Default constructor. TGeoXtru(Double_t* param); Default constructor in GEANT3 style; param[0] = nz // number of z planes. param[1] = z1 // Z position of first plane; param[2] = x1 // X position of first plane; param[3] = y1 // Y position of first plane; param[4] = scale1 // scale factor for first plane. param[4*(nz-1]+1] = zn; param[4*(nz-1)+2] = xn; param[4*(nz-1)+3] = yn; param[4*(nz-1)+4] = scalen. TGeoXtru(const TGeoXtru& ); copy constructor. TGeoXtru& operator=(const TGeoXtru& ); assignment operator. ~TGeoXtru(); destructor. Double_t Capacity() const; Compute capacity [length^3] of this shape. void ComputeBBox(); compute bounding box of the pcon. void ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. Bool_t Contains(Double_t* point) const; test if point is inside this shape; Check Z range. Int_t DistancetoPrimitive(Int_t px, Int_t py); compute closest distance from point px,py to each corner. Double_t DistToPlane(Double_t* point, Double_t* dir, Int_t iz, Int_t ivert, Double_t stepmax, Bool_t in) const; Compute distance to a Xtru lateral surface. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from inside point to surface of the polycone; locate Z segment. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from outside point to surface of the tube; Warning(""DistFromOutside"", ""not implemented"");. Bool_t DefinePolygon(Int_t nvert, const Double_t* xv, const Double_t* yv); Creates the polygon representing the blueprint of any Xtru section.; nvert = number of vertices >2; xv[nvert] = array of X vertex positions; yv[nvert] = array of ",MatchSource.WIKI,root/html528/TGeoXtru.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGeoXtru.html
https://root.cern/root/html528/TGEventHandler.html:3578,Availability,error,error,3578,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; TList*TQObject::GetListOfClassSignals() const; TList*TQObject::GetListOfConnections() const; TList*TQObject::GetListOfSignals() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tHandleButton(Event_t*); virtua",MatchSource.WIKI,root/html528/TGEventHandler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGEventHandler.html
https://root.cern/root/html528/TGEventHandler.html:3662,Availability,error,error,3662,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; TList*TQObject::GetListOfClassSignals() const; TList*TQObject::GetListOfConnections() const; TList*TQObject::GetListOfSignals() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tHandleButton(Event_t*); virtual Bool_tHandleColormapChange(Event_t*); virtual Bool_tHandleConfigureNotify(Event_t*",MatchSource.WIKI,root/html528/TGEventHandler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGEventHandler.html
https://root.cern/root/html528/TGEventHandler.html:10164,Integrability,message,message,10164,"ublic:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; TStringTNamed::fNameobject identifier; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; TStringTNamed::fTitleobject title; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals. private:. Bool_tfIsActivekTRUE if handler is active, kFALSE if not active; TObject*fObject; TGWindow*fWindow. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Bool_t HandleEvent(Event_t* ev); Handle the event. Returns true if the event has been handled,; false otherwise. void SendMessage(const TGWindow* w, Long_t msg, Long_t parm1, Long_t parm2); Send message (i.e. event) to window w. Message is encoded in one long; as message type and up to two long parameters. TGEventHandler(const TGEventHandler& ). TGEventHandler& operator=(const TGEventHandler& ). void * GetSender(); { return this; }. TGEventHandler(const char* name, TGWindow* w, TObject* obj, const char* title = """"); { }. virtual ~TGEventHandler(); { }. void Activate(); { fIsActive = kTRUE; }. void DeActivate(); { fIsActive = kFALSE; }. Bool_t IsActive() const; { return fIsActive; }. Bool_t HandleConfigureNotify(Event_t* ); { return kFALSE; }. Bool_t HandleButton(Event_t* ); { return kFALSE; }. Bool_t HandleDoubleClick(Event_t* ); { return kFALSE; }. Bool_t HandleCrossing(Event_t* ); { return kFALSE; }. Bool_t HandleMotion(Event_t* ); { return kFALSE; }. Bool_t HandleKey(Event_t* ); { return kFALSE; }. Bool_t HandleFocusChange(Event_t* ); { return kFALSE; }. Bool_t HandleSelection(Event_t* ); { return kFALSE; }. Bool_t HandleSelectionRequest(",MatchSource.WIKI,root/html528/TGEventHandler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGEventHandler.html
https://root.cern/root/html528/TGEventHandler.html:10233,Integrability,message,message,10233,"Pick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; TStringTNamed::fNameobject identifier; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; TStringTNamed::fTitleobject title; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals. private:. Bool_tfIsActivekTRUE if handler is active, kFALSE if not active; TObject*fObject; TGWindow*fWindow. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Bool_t HandleEvent(Event_t* ev); Handle the event. Returns true if the event has been handled,; false otherwise. void SendMessage(const TGWindow* w, Long_t msg, Long_t parm1, Long_t parm2); Send message (i.e. event) to window w. Message is encoded in one long; as message type and up to two long parameters. TGEventHandler(const TGEventHandler& ). TGEventHandler& operator=(const TGEventHandler& ). void * GetSender(); { return this; }. TGEventHandler(const char* name, TGWindow* w, TObject* obj, const char* title = """"); { }. virtual ~TGEventHandler(); { }. void Activate(); { fIsActive = kTRUE; }. void DeActivate(); { fIsActive = kFALSE; }. Bool_t IsActive() const; { return fIsActive; }. Bool_t HandleConfigureNotify(Event_t* ); { return kFALSE; }. Bool_t HandleButton(Event_t* ); { return kFALSE; }. Bool_t HandleDoubleClick(Event_t* ); { return kFALSE; }. Bool_t HandleCrossing(Event_t* ); { return kFALSE; }. Bool_t HandleMotion(Event_t* ); { return kFALSE; }. Bool_t HandleKey(Event_t* ); { return kFALSE; }. Bool_t HandleFocusChange(Event_t* ); { return kFALSE; }. Bool_t HandleSelection(Event_t* ); { return kFALSE; }. Bool_t HandleSelectionRequest(Event_t* ); { return kFALSE; }. Bool_t HandleSelectionClear(Event_t* ); { return kFALSE; }. Bool_t HandleColo",MatchSource.WIKI,root/html528/TGEventHandler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGEventHandler.html
https://root.cern/root/html528/TGFileBrowser.html:5329,Availability,error,error,5329,"char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual Long_tTBrowserImp::ExecPlugin(const char*, const char*, const char*, Int_t, Int_t); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTBrowserImp::ExecuteDefaultAction(TObject*); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; char*FormatFileInfo(const char* fname, Long64_t size, Long_t modtime); TStringFullPathName(TGListTreeItem* item); virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); TList*TGMainFrame::GetBindList() const; static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; virtual TBrowser*TBrowserImp::GetBrowser() const; voidTGMainFrame::GetClassHints(const char*& className, const char*& resourceName) const; TGClie",MatchSource.WIKI,root/html528/TGFileBrowser.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGFileBrowser.html
https://root.cern/root/html528/TGFileBrowser.html:5413,Availability,error,error,5413," voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual Long_tTBrowserImp::ExecPlugin(const char*, const char*, const char*, Int_t, Int_t); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTBrowserImp::ExecuteDefaultAction(TObject*); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; char*FormatFileInfo(const char* fname, Long64_t size, Long_t modtime); TStringFullPathName(TGListTreeItem* item); virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); TList*TGMainFrame::GetBindList() const; static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; virtual TBrowser*TBrowserImp::GetBrowser() const; voidTGMainFrame::GetClassHints(const char*& className, const char*& resourceName) const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTG",MatchSource.WIKI,root/html528/TGFileBrowser.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGFileBrowser.html
https://root.cern/root/html528/TGFileBrowser.html:20887,Availability,mask,mask,20887,"ckgroundframe background color; TList*TGMainFrame::fBindListlist with key bindings; Int_tTGFrame::fBorderWidthframe border width; TGHorizontalFrame*fBotFrameBottom horizontal frame; TBrowser*TBrowserImp::fBrowserTBrowser associated with this implementation; const TGPicture*fCachedPicCached picture; TStringfCachedPicNameCached picture name; TGCanvas*fCanvasCanvas for the list tree; TStringTGMainFrame::fClassNameWM class name; TGClient*TGObject::fClientConnection to display server; Long_tfCntCounters for keys inside a Root file; TContextMenu*fContextMenupointer to context menu; TGListTreeItem*fCurrentDirCurrent (list tree) directory; Int_tTGFrame::fDNDStateEDNDFlags; Atom_t*TGMainFrame::fDNDTypeListhandles DND types; Bool_tfDblClickkTRUE if user double-clicked on a list tree item; TSystemDirectory*fDirActual (selected) system directory; TGComboBox*fDrawOptionDraw options combobox; UInt_tTGWindow::fEditDisabledflags used for ""guibuilding""; UInt_tTGFrame::fEventMaskcurrenty active event mask; TGFrameElement*TGFrame::fFEpointer to frame element; TSystemFile*fFileActual (selected) system file; const TGPicture*fFileIconSystem files icon; TGComboBox*fFileTypeFile type combobox; TRegexp*fFilterRegular expression used to filter files; Int_tfGroupSizetotal number of items when icon box switched to ""global view"" mode; Bool_tfGroupedkTRUE if Root file content (keys) is grouped; UInt_tTGFrame::fHeightframe height; TStringTGMainFrame::fIconNameicon name; TStringTGMainFrame::fIconPixmapicon pixmap name; Handle_tTGObject::fIdX11/Win32 Window identifier; Bool_tTGCompositeFrame::fLayoutBrokenno layout manager is used; TGLayoutManager*TGCompositeFrame::fLayoutManagerlayout manager; TList*TGCompositeFrame::fListcontainer of frame elements; TGListTreeItem*fListLevelCurrent list tree level; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; TGListTree*fListTreeMain list tree; UInt_tTGMainFrame::fMWMFuncs",MatchSource.WIKI,root/html528/TGFileBrowser.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGFileBrowser.html
https://root.cern/root/html528/TGFileBrowser.html:379,Modifiability,plug-in,plug-in,379,". TGFileBrowser. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGFileBrowser. class TGFileBrowser: public TGMainFrame, public TBrowserImp. TGFileBrowser. System file browser, used as TRootBrowser plug-in.; This class is the real core of the ROOT browser. Function Members (Methods); public:. TGFileBrowser(const TGWindow* p, TBrowser* b = 0, UInt_t w = 200, UInt_t h = 400); virtual~TGFileBrowser(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidAdd(TObject* obj, const char* name = 0, Int_t check = -1); virtual voidTBrowserImp::AddCheckBox(TObject*, Bool_t = kFALSE); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidAddFSDirectory(const char* entry, const char* path = 0, Option_t* opt = """"); voidTGFrame::AddInput(UInt_t emask); voidAddKey(TGListTreeItem* itm, TObject* obj, const char* name = 0); voidAddRemoteFile(TObject* obj); virtual voidTObject::AppendPad(Option_t* option = """"); voidApplyFilter(Int_t id); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual Bool_tTGMainFrame::BindKey(const TGWindow* w, Int_t keycode, Int_t modifier) const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidBrowseObj(TObject* obj); TBrowser*TBrowserImp::Browser() const; virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidTGCompositeFrame::ChangeSubframesBackground(Pixel_t back); voidChdir(TGListTreeItem* item); voidChecked(TObject* obj, Bool_t check); virtual voidTBrowserImp::CheckObjectItem(TObject*, Bool_t = kFALSE); voidCheckRemote(TGListTreeItem* it",MatchSource.WIKI,root/html528/TGFileBrowser.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGFileBrowser.html
https://root.cern/root/html528/TGFileContainer.html:5402,Availability,error,error,5402,"le_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTGContainer::End(Bool_t select = kFALSE); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGContainer::FindFrame(Int_t x, Int_t y, Bool_t exclude = kTRUE); virtual TGFrame*TGContainer::FindFrameByName(const char* name); virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual void*TGContainer::FindItem(const TString& name, Bool_t direction = kTRUE, Bool_t caseSensitive = kTRUE, Bool_t subString = kFALSE); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGCanvas*TGContainer::GetCanvas() const; TGClient*TGObject::Get",MatchSource.WIKI,root/html528/TGFileContainer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGFileContainer.html
https://root.cern/root/html528/TGFileContainer.html:5486,Availability,error,error,5486,"t(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTGContainer::End(Bool_t select = kFALSE); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGContainer::FindFrame(Int_t x, Int_t y, Bool_t exclude = kTRUE); virtual TGFrame*TGContainer::FindFrameByName(const char* name); virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual void*TGContainer::FindItem(const TString& name, Bool_t direction = kTRUE, Bool_t caseSensitive = kTRUE, Bool_t subString = kFALSE); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGCanvas*TGContainer::GetCanvas() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaul",MatchSource.WIKI,root/html528/TGFileContainer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGFileContainer.html
https://root.cern/root/html528/TGFileContainer.html:12532,Availability,mask,mask,12532,") const; voidTObject::InvertBit(UInt_t f); virtual voidTGContainer::InvertSelection()SIGNAL ; virtual TClass*IsA() const; virtual Bool_tTGFrame::IsActive() const; Bool_tTGCompositeFrame::IsArranged(TGFrame* f) const; Bool_tTGCompositeFrame::IsArranged(TGFrameElement* ptr) const; virtual Bool_tTGCompositeFrame::IsComposite() const; Bool_tTGFrame::IsDNDSource() const; Bool_tTGFrame::IsDNDTarget() const; virtual Bool_tTGCompositeFrame::IsEditable() const; virtual Bool_tTGObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; virtual Bool_tTGCompositeFrame::IsLayoutBroken() const; virtual Bool_tTGWindow::IsMapped(); virtual Bool_tTGCompositeFrame::IsMapSubwindows() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTGCompositeFrame::IsVisible(TGFrame* f) const; Bool_tTGCompositeFrame::IsVisible(TGFrameElement* ptr) const; Bool_tTObject::IsZombie() const; virtual voidTGContainer::KeyPressed(TGFrame*, UInt_t keysym, UInt_t mask)SIGNAL ; virtual voidTGContainer::Layout(); virtual voidTGLVContainer::LineDown(Bool_t select = kFALSE); virtual voidTGLVContainer::LineLeft(Bool_t select = kFALSE); virtual voidTGLVContainer::LineRight(Bool_t select = kFALSE); virtual voidTGLVContainer::LineUp(Bool_t select = kFALSE); static voidTQObject::LoadRQ_OBJECT(); virtual voidTGWindow::LowerWindow(); virtual voidTQObject::LowPriority(const char* signal_name, const char* slot_name = 0); virtual voidTObject::ls(Option_t* option = """") const; virtual voidTGFrame::MapRaised(); virtual voidTGCompositeFrame::MapSubwindows(); virtual voidTGFrame::MapWindow(); voidTObject::MayNotUse(const char* method) const; virtual voidTQObject::Message(const char* msg)SIGNAL ; virtual voidTGFrame::Move(Int_t x, Int_t y); virtual voidTGFrame::MoveResize(Int_t x, Int_t y, UInt_t w = 0, UInt_t h = 0); virtual Int_tTGCompositeFrame::MustCleanup() const; virtual Bool_tTObject::Notify(); virtual Int_tTQObject::NumberOfConnections() const; virtual Int_tT",MatchSource.WIKI,root/html528/TGFileContainer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGFileContainer.html
https://root.cern/root/html528/TGFileContainer.html:22251,Availability,mask,mask,22251,,MatchSource.WIKI,root/html528/TGFileContainer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGFileContainer.html
https://root.cern/root/html528/TGFileContainer.html:23912,Integrability,message,messages,23912,ner::fLastActiveEllast active item; Bool_tTGContainer::fLastCasecase sensetivity of last search; Bool_tTGContainer::fLastDirdirection of last search; TStringTGContainer::fLastNamethe name of object of last search; Bool_tTGContainer::fLastSubstringsubstring search option of last search; Bool_tTGCompositeFrame::fLayoutBrokenno layout manager is used; TGLayoutManager*TGCompositeFrame::fLayoutManagerlayout manager; TList*TGCompositeFrame::fListcontainer of frame elements; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; TGListView*TGLVContainer::fListViewlistview which contains this container; Bool_tTGCompositeFrame::fMapSubwindowskTRUE - map subwindows; UInt_tTGFrame::fMaxHeightmaximal frame height; UInt_tTGFrame::fMaxWidthmaximal frame width; UInt_tTGFrame::fMinHeightminimal frame height; UInt_tTGFrame::fMinWidthminimal frame width; const TGWindow*TGContainer::fMsgWindowwindow handling container messages; ULong_tfMtimedirectory modification time; Bool_tTGLVContainer::fMultiSelecttrue = multiple file selection; Int_tTGCompositeFrame::fMustCleanupcleanup mode (see EFrameCleanup); TStringTGWindow::fNamename of the window used in SavePrimitive(); Bool_tTGWindow::fNeedRedrawkTRUE if window needs to be redrawn; Bool_tTGContainer::fOnMouseOverkTRUE when mouse pointer is over entry; UInt_tTGFrame::fOptionsframe options; const TGWindow*TGWindow::fParentParent window; TViewUpdateTimer*fRefreshrefresh timer; TTimer*TGContainer::fScrollTimerautoscroll timer; Bool_tTGContainer::fScrollingkTRUE - when scrolling is ON; Int_tTGContainer::fSelectednumber of selected items; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; const TGPicture*fSlink_sbig symbolic link icon; const TGPicture*fSlink_tsmall symbolic link icon; EFSSortModefSortTypesorting mode of contents; Int_tTGContainer::fTotaltotal items; EListViewModeTGLVContainer::fViewModelist view viewing mode; TGViewPort*TGConta,MatchSource.WIKI,root/html528/TGFileContainer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGFileContainer.html
https://root.cern/root/html528/TGFileDialog.html:5108,Availability,error,error,5108,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); TList*TGMainFrame::GetBindList() const; static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; voidTGMainFrame::GetClassHints(const char*& className, const char*& resourceName) const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBa",MatchSource.WIKI,root/html528/TGFileDialog.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGFileDialog.html
https://root.cern/root/html528/TGFileDialog.html:5192,Availability,error,error,5192,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); TList*TGMainFrame::GetBindList() const; static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; voidTGMainFrame::GetClassHints(const char*& className, const char*& resourceName) const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UIn",MatchSource.WIKI,root/html528/TGFileDialog.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGFileDialog.html
https://root.cern/root/html528/TGFileDialog.html:19537,Availability,mask,mask,19537,,MatchSource.WIKI,root/html528/TGFileDialog.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGFileDialog.html
https://root.cern/root/html528/TGFileDialog.html:23503,Integrability,message,messages,23503,"ition; Int_tTGMainFrame::fWMYWM y position; UInt_tTGFrame::fWidthframe width; TStringTGMainFrame::fWindowNamewindow name; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGFileDialog(const TGWindow* p = 0, const TGWindow* main = 0, EFileDialogMode dlg_type = kFDOpen, TGFileInfo* file_info = 0); Create a file selection dialog. Depending on the dlg_type it can be; used for opening or saving a file. ~TGFileDialog(); Delete file dialog. void CloseWindow(); Close file dialog. Bool_t ProcessMessage(Long_t msg, Long_t parm1, Long_t parm2); Process messages generated by the user input in the file dialog. TGFileInfo& operator=(const TGFileDialog& ). TGFileDialog(const TGFileDialog& ). » Author: Fons Rademakers 20/01/98 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id: TGFileDialog.h 23115 2008-04-10 13:35:37Z rdm $ » Last generated: 2010-09-23 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html528/TGFileDialog.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGFileDialog.html
https://root.cern/root/html528/TGFileItem.html:4540,Availability,error,error,4540,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGLVEntry::GetDefaultSize() const; virtual UInt_tTGFrame::GetDefaultWidth() const; virtual TDNDData*GetDNDdata(Atom_t); virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFra",MatchSource.WIKI,root/html528/TGFileItem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGFileItem.html
https://root.cern/root/html528/TGFileItem.html:4624,Availability,error,error,4624,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGLVEntry::GetDefaultSize() const; virtual UInt_tTGFrame::GetDefaultWidth() const; virtual TDNDData*GetDNDdata(Atom_t); virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType() const; virtual Option_t*TObject::GetDrawOption() const; virtual In",MatchSource.WIKI,root/html528/TGFileItem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGFileItem.html
https://root.cern/root/html528/TGFileItem.html:17281,Availability,mask,mask,17281,,MatchSource.WIKI,root/html528/TGFileItem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGFileItem.html
https://root.cern/root/html528/TGFont.html:1918,Availability,error,error,1918,"ject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; TGTextLayout*ComputeTextLayout(const char* string, Int_t numChars, Int_t wrapLength, Int_t justify, Int_t flags, UInt_t* width, UInt_t* height) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); voidDrawChars(Drawable_t dst, GContext_t gc, const char* source, Int_t numChars, Int_t x, Int_t y) const; voidDrawCharsExp(Drawable_t dst, GContext_t gc, const char* source, Int_t numChars, Int_t x, Int_t y) const; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); FontAttributes_tGetFontAttributes() const; FontH_tGetFontHandle() const; voidGetFontMetrics(FontMetrics_t* m) const; FontStruct_tGetFontStruct() const; virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::Hand",MatchSource.WIKI,root/html528/TGFont.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGFont.html
https://root.cern/root/html528/TGFont.html:2002,Availability,error,error,2002,"st TObject* obj) const; TGTextLayout*ComputeTextLayout(const char* string, Int_t numChars, Int_t wrapLength, Int_t justify, Int_t flags, UInt_t* width, UInt_t* height) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); voidDrawChars(Drawable_t dst, GContext_t gc, const char* source, Int_t numChars, Int_t x, Int_t y) const; voidDrawCharsExp(Drawable_t dst, GContext_t gc, const char* source, Int_t numChars, Int_t x, Int_t y) const; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); FontAttributes_tGetFontAttributes() const; FontH_tGetFontHandle() const; voidGetFontMetrics(FontMetrics_t* m) const; FontStruct_tGetFontStruct() const; virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::In",MatchSource.WIKI,root/html528/TGFont.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGFont.html
https://root.cern/root/html528/TGFont.html:1102,Integrability,wrap,wrapLength,1102," virtual~TGFont(); voidTObject::AbstractMethod(const char* method) const; voidTRefCnt::AddReference(); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; TGTextLayout*ComputeTextLayout(const char* string, Int_t numChars, Int_t wrapLength, Int_t justify, Int_t flags, UInt_t* width, UInt_t* height) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); voidDrawChars(Drawable_t dst, GContext_t gc, const char* source, Int_t numChars, Int_t x, Int_t y) const; voidDrawCharsExp(Drawable_t dst, GContext_t gc, const char* source, Int_t numChars, Int_t x, Int_t y) const; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t*",MatchSource.WIKI,root/html528/TGFont.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGFont.html
https://root.cern/root/html528/TGFont.html:10033,Integrability,wrap,wrapper,10033," the characters. The return value is the number of characters from source that fit into; the span that extends from 0 to maxLength. *length is filled with the; x-coordinate of the right edge of the last character that did fit. source -- Characters to be displayed. Need not be '\0' terminated.; numChars -- Maximum number of characters to consider from source string.; maxLength -- If > 0, maxLength specifies the longest permissible line; length; don't consider any character that would cross this; x-position. If <= 0, then line length is unbounded and the; flags argument is ignored.; flags -- Various flag bits OR-ed together:; TEXT_PARTIAL_OK means include the last char which only; partially fit on this line.; TEXT_WHOLE_WORDS means stop on a word boundary, if possible.; TEXT_AT_LEAST_ONE means return at least one character even; if no characters fit.; *length -- Filled with x-location just after the terminating character. Int_t TextWidth(const char* string, Int_t numChars = -1) const; A wrapper function for the more complicated interface of MeasureChars.; Computes how much space the given simple string needs. The return value is the width (in pixels) of the given string. string -- String whose width will be computed.; numChars -- Number of characters to consider from string, or < 0 for; strlen(). Int_t XTextWidth(const char* string, Int_t numChars = -1) const; Return text widht in pixels. void UnderlineChars(Drawable_t dst, GContext_t gc, const char* string, Int_t x, Int_t y, Int_t firstChar, Int_t lastChar) const; This procedure draws an underline for a given range of characters in a; given string. It doesn't draw the characters (which are assumed to have; been displayed previously); it just draws the underline. This procedure; would mainly be used to quickly underline a few characters without having; to construct an underlined font. To produce properly underlined text, the; appropriate underlined font should be constructed and used. dst -- Window or pixmap in which t",MatchSource.WIKI,root/html528/TGFont.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGFont.html
https://root.cern/root/html528/TGFont.html:10075,Integrability,interface,interface,10075," the characters. The return value is the number of characters from source that fit into; the span that extends from 0 to maxLength. *length is filled with the; x-coordinate of the right edge of the last character that did fit. source -- Characters to be displayed. Need not be '\0' terminated.; numChars -- Maximum number of characters to consider from source string.; maxLength -- If > 0, maxLength specifies the longest permissible line; length; don't consider any character that would cross this; x-position. If <= 0, then line length is unbounded and the; flags argument is ignored.; flags -- Various flag bits OR-ed together:; TEXT_PARTIAL_OK means include the last char which only; partially fit on this line.; TEXT_WHOLE_WORDS means stop on a word boundary, if possible.; TEXT_AT_LEAST_ONE means return at least one character even; if no characters fit.; *length -- Filled with x-location just after the terminating character. Int_t TextWidth(const char* string, Int_t numChars = -1) const; A wrapper function for the more complicated interface of MeasureChars.; Computes how much space the given simple string needs. The return value is the width (in pixels) of the given string. string -- String whose width will be computed.; numChars -- Number of characters to consider from string, or < 0 for; strlen(). Int_t XTextWidth(const char* string, Int_t numChars = -1) const; Return text widht in pixels. void UnderlineChars(Drawable_t dst, GContext_t gc, const char* string, Int_t x, Int_t y, Int_t firstChar, Int_t lastChar) const; This procedure draws an underline for a given range of characters in a; given string. It doesn't draw the characters (which are assumed to have; been displayed previously); it just draws the underline. This procedure; would mainly be used to quickly underline a few characters without having; to construct an underlined font. To produce properly underlined text, the; appropriate underlined font should be constructed and used. dst -- Window or pixmap in which t",MatchSource.WIKI,root/html528/TGFont.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGFont.html
https://root.cern/root/html528/TGFont.html:11398,Integrability,wrap,wrapLength,11398,"d UnderlineChars(Drawable_t dst, GContext_t gc, const char* string, Int_t x, Int_t y, Int_t firstChar, Int_t lastChar) const; This procedure draws an underline for a given range of characters in a; given string. It doesn't draw the characters (which are assumed to have; been displayed previously); it just draws the underline. This procedure; would mainly be used to quickly underline a few characters without having; to construct an underlined font. To produce properly underlined text, the; appropriate underlined font should be constructed and used. dst -- Window or pixmap in which to draw.; gc -- Graphics context for actually drawing line.; string -- String containing characters to be underlined or overstruck.; x, y -- Coordinates at which first character of string is drawn.; firstChar -- Index of first character.; lastChar -- Index of one after the last character. TGTextLayout * ComputeTextLayout(const char* string, Int_t numChars, Int_t wrapLength, Int_t justify, Int_t flags, UInt_t* width, UInt_t* height) const; Computes the amount of screen space needed to display a multi-line,; justified string of text. Records all the measurements that were done; to determine to size and positioning of the individual lines of text;; this information can be used by the TGTextLayout::DrawText() procedure; to display the text quickly (without remeasuring it). This procedure is useful for simple widgets that want to display; single-font, multi-line text and want TGFont to handle the details. The return value is a TGTextLayout token that holds the measurement; information for the given string. The token is only valid for the given; string. If the string is freed, the token is no longer valid and must; also be deleted. The dimensions of the screen area needed to display the text are stored; in *width and *height. string -- String whose dimensions are to be computed.; numChars -- Number of characters to consider from string, or < 0 for; strlen().; wrapLength -- Longest permissible lin",MatchSource.WIKI,root/html528/TGFont.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGFont.html
https://root.cern/root/html528/TGFont.html:12409,Integrability,wrap,wrapLength,12409,", UInt_t* width, UInt_t* height) const; Computes the amount of screen space needed to display a multi-line,; justified string of text. Records all the measurements that were done; to determine to size and positioning of the individual lines of text;; this information can be used by the TGTextLayout::DrawText() procedure; to display the text quickly (without remeasuring it). This procedure is useful for simple widgets that want to display; single-font, multi-line text and want TGFont to handle the details. The return value is a TGTextLayout token that holds the measurement; information for the given string. The token is only valid for the given; string. If the string is freed, the token is no longer valid and must; also be deleted. The dimensions of the screen area needed to display the text are stored; in *width and *height. string -- String whose dimensions are to be computed.; numChars -- Number of characters to consider from string, or < 0 for; strlen().; wrapLength -- Longest permissible line length, in pixels. <= 0 means no; automatic wrapping: just let lines get as long as needed.; justify -- How to justify lines.; flags -- Flag bits OR-ed together. kTextIgnoreTabs means that tab; characters should not be expanded. kTextIgnoreNewlines; means that newline characters should not cause a line break.; width -- Filled with width of string.; height -- Filled with height of string. LayoutChunk_t * NewChunk(TGTextLayout* layout, int* maxPtr, const char* start, int numChars, int curX, int newX, int y) const; Helper function for ComputeTextLayout(). Encapsulates a measured set of; characters in a chunk that can be quickly drawn. Returns a pointer to the new chunk in the text layout. The text layout is; reallocated to hold more chunks as necessary. Currently, ComputeTextLayout() stores contiguous ranges of ""normal""; characters in a chunk, along with individual tab and newline chars in; their own chunks. All characters in the text layout are accounted for. void DrawCharsExp",MatchSource.WIKI,root/html528/TGFont.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGFont.html
https://root.cern/root/html528/TGFont.html:12492,Integrability,wrap,wrapping,12492,"een space needed to display a multi-line,; justified string of text. Records all the measurements that were done; to determine to size and positioning of the individual lines of text;; this information can be used by the TGTextLayout::DrawText() procedure; to display the text quickly (without remeasuring it). This procedure is useful for simple widgets that want to display; single-font, multi-line text and want TGFont to handle the details. The return value is a TGTextLayout token that holds the measurement; information for the given string. The token is only valid for the given; string. If the string is freed, the token is no longer valid and must; also be deleted. The dimensions of the screen area needed to display the text are stored; in *width and *height. string -- String whose dimensions are to be computed.; numChars -- Number of characters to consider from string, or < 0 for; strlen().; wrapLength -- Longest permissible line length, in pixels. <= 0 means no; automatic wrapping: just let lines get as long as needed.; justify -- How to justify lines.; flags -- Flag bits OR-ed together. kTextIgnoreTabs means that tab; characters should not be expanded. kTextIgnoreNewlines; means that newline characters should not cause a line break.; width -- Filled with width of string.; height -- Filled with height of string. LayoutChunk_t * NewChunk(TGTextLayout* layout, int* maxPtr, const char* start, int numChars, int curX, int newX, int y) const; Helper function for ComputeTextLayout(). Encapsulates a measured set of; characters in a chunk that can be quickly drawn. Returns a pointer to the new chunk in the text layout. The text layout is; reallocated to hold more chunks as necessary. Currently, ComputeTextLayout() stores contiguous ranges of ""normal""; characters in a chunk, along with individual tab and newline chars in; their own chunks. All characters in the text layout are accounted for. void DrawCharsExp(Drawable_t dst, GContext_t gc, const char* source, Int_t numChars",MatchSource.WIKI,root/html528/TGFont.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGFont.html
https://root.cern/root/html528/TGFont.html:9136,Modifiability,extend,extends,9136,"If the font does not exist on the printer, the print job will fail at; print time. Given a ""reasonable"" Postscript printer, the following; TGFont font families should print correctly:. Avant Garde, Arial, Bookman, Courier, Courier New, Geneva,; Helvetica, Monaco, New Century Schoolbook, New York,; Palatino, Symbol, Times, Times New Roman, Zapf Chancery,; and Zapf Dingbats. Any other TGFont font families may not print correctly because the; computed Postscript font name may be incorrect. dst -- Pointer to an initialized TString object to which the name of the; Postscript font that corresponds to the font will be appended. Int_t MeasureChars(const char* source, Int_t numChars, Int_t maxLength, Int_t flags, Int_t* length) const; Determine the number of characters from the string that will fit in the; given horizontal span. The measurement is done under the assumption that; DrawChars() will be used to actually display the characters. The return value is the number of characters from source that fit into; the span that extends from 0 to maxLength. *length is filled with the; x-coordinate of the right edge of the last character that did fit. source -- Characters to be displayed. Need not be '\0' terminated.; numChars -- Maximum number of characters to consider from source string.; maxLength -- If > 0, maxLength specifies the longest permissible line; length; don't consider any character that would cross this; x-position. If <= 0, then line length is unbounded and the; flags argument is ignored.; flags -- Various flag bits OR-ed together:; TEXT_PARTIAL_OK means include the last char which only; partially fit on this line.; TEXT_WHOLE_WORDS means stop on a word boundary, if possible.; TEXT_AT_LEAST_ONE means return at least one character even; if no characters fit.; *length -- Filled with x-location just after the terminating character. Int_t TextWidth(const char* string, Int_t numChars = -1) const; A wrapper function for the more complicated interface of MeasureChars.; Comp",MatchSource.WIKI,root/html528/TGFont.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGFont.html
https://root.cern/root/html528/TGFont.html:14336,Safety,sanity check,sanity check,14336,"f ""normal""; characters in a chunk, along with individual tab and newline chars in; their own chunks. All characters in the text layout are accounted for. void DrawCharsExp(Drawable_t dst, GContext_t gc, const char* source, Int_t numChars, Int_t x, Int_t y) const; Draw a string of characters on the screen. DrawCharsExp() expands; control characters that occur in the string to \X or \xXX sequences.; DrawChars() just draws the strings. dst -- Window or pixmap in which to draw.; gc -- Graphics context for drawing characters.; source -- Characters to be displayed. Need not be'\0' terminated.; For DrawChars(), all meta-characters (tabs, control; characters, and newlines) should be stripped out of the; string that is passed to this function. If they are not; stripped out, they will be displayed as regular printing; characters.; numChars -- Number of characters in string.; x, y -- Coordinates at which to place origin of string when drawing. void DrawChars(Drawable_t dst, GContext_t gc, const char* source, Int_t numChars, Int_t x, Int_t y) const; Perform a quick sanity check to ensure we won't overflow the X; coordinate space. void SavePrimitive(ostream& out, Option_t* = """"); Save the used font as a C++ statement(s) on output stream out. FontAttributes_t& operator=(const TGFont& font). TGFont(const char* name); (used for simulating a native underlined or strikeout font). TGFont(const TGFont& font). FontH_t GetFontHandle() const; { return fFontH; }. FontStruct_t GetFontStruct() const; { return fFontStruct; }. FontAttributes_t GetFontAttributes() const; { return fFA; }. Int_t TextHeight() const; { return fFM.fLinespace; }. » Author: Fons Rademakers 20/5/2003 » Copyright (C) 1995-2003, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id: TGFont.h 23115 2008-04-10 13:35:37Z rdm $ » Last generated: 2010-09-23 20:06; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html528/TGFont.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGFont.html
https://root.cern/root/html528/TGFont.html:10137,Usability,simpl,simple,10137,"n that extends from 0 to maxLength. *length is filled with the; x-coordinate of the right edge of the last character that did fit. source -- Characters to be displayed. Need not be '\0' terminated.; numChars -- Maximum number of characters to consider from source string.; maxLength -- If > 0, maxLength specifies the longest permissible line; length; don't consider any character that would cross this; x-position. If <= 0, then line length is unbounded and the; flags argument is ignored.; flags -- Various flag bits OR-ed together:; TEXT_PARTIAL_OK means include the last char which only; partially fit on this line.; TEXT_WHOLE_WORDS means stop on a word boundary, if possible.; TEXT_AT_LEAST_ONE means return at least one character even; if no characters fit.; *length -- Filled with x-location just after the terminating character. Int_t TextWidth(const char* string, Int_t numChars = -1) const; A wrapper function for the more complicated interface of MeasureChars.; Computes how much space the given simple string needs. The return value is the width (in pixels) of the given string. string -- String whose width will be computed.; numChars -- Number of characters to consider from string, or < 0 for; strlen(). Int_t XTextWidth(const char* string, Int_t numChars = -1) const; Return text widht in pixels. void UnderlineChars(Drawable_t dst, GContext_t gc, const char* string, Int_t x, Int_t y, Int_t firstChar, Int_t lastChar) const; This procedure draws an underline for a given range of characters in a; given string. It doesn't draw the characters (which are assumed to have; been displayed previously); it just draws the underline. This procedure; would mainly be used to quickly underline a few characters without having; to construct an underlined font. To produce properly underlined text, the; appropriate underlined font should be constructed and used. dst -- Window or pixmap in which to draw.; gc -- Graphics context for actually drawing line.; string -- String containing charact",MatchSource.WIKI,root/html528/TGFont.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGFont.html
https://root.cern/root/html528/TGFont.html:11842,Usability,simpl,simple,11842,"n underlined font. To produce properly underlined text, the; appropriate underlined font should be constructed and used. dst -- Window or pixmap in which to draw.; gc -- Graphics context for actually drawing line.; string -- String containing characters to be underlined or overstruck.; x, y -- Coordinates at which first character of string is drawn.; firstChar -- Index of first character.; lastChar -- Index of one after the last character. TGTextLayout * ComputeTextLayout(const char* string, Int_t numChars, Int_t wrapLength, Int_t justify, Int_t flags, UInt_t* width, UInt_t* height) const; Computes the amount of screen space needed to display a multi-line,; justified string of text. Records all the measurements that were done; to determine to size and positioning of the individual lines of text;; this information can be used by the TGTextLayout::DrawText() procedure; to display the text quickly (without remeasuring it). This procedure is useful for simple widgets that want to display; single-font, multi-line text and want TGFont to handle the details. The return value is a TGTextLayout token that holds the measurement; information for the given string. The token is only valid for the given; string. If the string is freed, the token is no longer valid and must; also be deleted. The dimensions of the screen area needed to display the text are stored; in *width and *height. string -- String whose dimensions are to be computed.; numChars -- Number of characters to consider from string, or < 0 for; strlen().; wrapLength -- Longest permissible line length, in pixels. <= 0 means no; automatic wrapping: just let lines get as long as needed.; justify -- How to justify lines.; flags -- Flag bits OR-ed together. kTextIgnoreTabs means that tab; characters should not be expanded. kTextIgnoreNewlines; means that newline characters should not cause a line break.; width -- Filled with width of string.; height -- Filled with height of string. LayoutChunk_t * NewChunk(TGTextLayout* l",MatchSource.WIKI,root/html528/TGFont.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGFont.html
https://root.cern/root/html528/TGFontDialog.html:379,Availability,avail,available,379,". TGFontDialog. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGFontDialog. class TGFontDialog: public TGTransientFrame. TGFontDialog. Font selection dialog, allowing to select one in the list of available fonts; in the system. Function Members (Methods); public:. TGFontDialog(const TGWindow* parent = 0, const TGWindow* t = 0, TGFontDialog::FontProp_t* fontProp = 0, const TString& sample = """", char** fontList = 0, Bool_t wait = kTRUE); virtual~TGFontDialog(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidAlignSelected(Int_t a)SIGNAL ; virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual Bool_tTGMainFrame::BindKey(const TGWindow* w, Int_t keycode, Int_t modifier) const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGTransientFrame::CenterOnParent(Bool_t croot = kTRUE, TGTransientFrame::EPlacement pos = kCenter); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidTGCompositeFrame::ChangeSubframesBackground(Pixel_t back); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTGCompositeFrame::Cleanup(); virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual voidColorSelected(Pixel_t c)SIGNAL ; virtual Int_tTObject::Compare(const TObject* obj) c",MatchSource.WIKI,root/html528/TGFontDialog.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGFontDialog.html
https://root.cern/root/html528/TGFontDialog.html:4678,Availability,error,error,4678,"gnal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidEnableAlign(Bool_t on = kTRUE); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidFontSelected(char* font)SIGNAL ; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); TList*TGMainFrame::GetBindList() const; static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; voidTGMainFrame::GetClassHints(const char*& className, const char*& resourceName) const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const",MatchSource.WIKI,root/html528/TGFontDialog.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGFontDialog.html
https://root.cern/root/html528/TGFontDialog.html:4762,Availability,error,error,4762,"bject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidEnableAlign(Bool_t on = kTRUE); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidFontSelected(char* font)SIGNAL ; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); TList*TGMainFrame::GetBindList() const; static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; voidTGMainFrame::GetClassHints(const char*& className, const char*& resourceName) const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompos",MatchSource.WIKI,root/html528/TGFontDialog.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGFontDialog.html
https://root.cern/root/html528/TGFontDialog.html:19242,Availability,mask,mask,19242,,MatchSource.WIKI,root/html528/TGFontDialog.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGFontDialog.html
https://root.cern/root/html528/TGFontPool.html:1553,Availability,error,error,1553," TGFontPool(TGClient* client); virtual~TGFontPool(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; TGFont*FindFont(FontStruct_t font) const; TGFont*FindFontByHandle(FontH_t font) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const;",MatchSource.WIKI,root/html528/TGFontPool.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGFontPool.html
https://root.cern/root/html528/TGFontPool.html:1637,Availability,error,error,1637," voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; TGFont*FindFont(FontStruct_t font) const; TGFont*FindFontByHandle(FontH_t font) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; voidFreeAttributeInfo(char** info); voidFreeFont(const TGFont* font); voidFreeFontFamilies(char** f); char**GetAttributeInfo(const FontAttributes_t* fa); TGClient*TGObject::GetClient() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); TGFont*GetFont(const TGFont* font); TGFont*GetFont(FontStruct_t font); TGFont*GetFont(const char* font, Bool_t fixedDefault = kTRUE); TGFont*GetFont(const char* family, Int_t ptsize, Int_t weight, Int_t slant); char**GetFontFamilies(); virtual const char*TObject::GetIconName() const; Handle_tTGObject::GetId() const; virtual const char*TObject::GetName() cons",MatchSource.WIKI,root/html528/TGFontPool.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGFontPool.html
https://root.cern/root/html528/TGFontPool.html:7104,Availability,error,error,7104,"ontPool& fp). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TGClient*TGObject::fClientConnection to display server; Handle_tTGObject::fIdX11/Win32 Window identifier. private:. THashTable*fListTGFont objects pool; THashTable*fNamedTableMap a name to a set of attributes for a font; THashTable*fUidTableHash table for some used string values like family names, etc. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGFontPool(TGClient* client); Create a font pool. ~TGFontPool(); Cleanup font pool. TGFont * GetFont(const char* font, Bool_t fixedDefault = kTRUE); Get the specified font.; The font can be one of the following forms:; XLFD (see X documentation); ""Family [size [style] [style ...]]""; Returns 0 if error or no font can be found.; If fixedDefault is false the ""fixed"" font will not be substituted; as fallback when the asked for font does not exist. TGFont * GetFont(const TGFont* font); Use font, i.e. increases ref count of specified font. Returns 0; if font is not found. TGFont * GetFont(FontStruct_t font); Use font, i.e. increases ref count of specified font. TGFont * GetFont(const char* family, Int_t ptsize, Int_t weight, Int_t slant); Returns font specified bay family, pixel/point size, weight and slant; negative value of ptsize means size in pixels; positive value of ptsize means size in points. For example:; TGFont *font = fpool->GetFont(""helvetica"", -9, kFontWeightNormal, kFontSlantRoman);; font->Print();. void FreeFont(const TGFont* font); Free font. If ref count is 0 delete font. TGFont * FindFont(FontStruct_t font) const; Find font based on its font struct. Returns 0 if font is not found. TGFont * FindFontByHandle(FontH_t font) const; Find font based on its font handle. Returns ",MatchSource.WIKI,root/html528/TGFontPool.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGFontPool.html
https://root.cern/root/html528/TGFontPool.html:11338,Availability,avail,available,11338,"he table; if strKey was not equal to any of the string keys in the table. const char * FindStateString(const FontStateMap_t* map, int numKey); Given a lookup table, map a number to a string in the table. If numKey was equal to the numeric key of one of the elements in the; table, returns the string key of that element. Returns NULL if numKey; was not equal to any of the numeric keys in the table. Bool_t FieldSpecified(const char* field); Helper function for ParseXLFD(). Determines if a field in the XLFD was; set to a non-null, non-don't-care value. The return value is kFALSE if the field in the XLFD was not set and; should be ignored, kTRUE otherwise. field -- The field of the XLFD to check. Strictly speaking, only when; the string is ""*"" does it mean don't-care. However, an; unspecified or question mark is also interpreted as don't-care. const char * NameOfFont(TGFont* font); Given a font, return a textual string identifying it. char ** GetFontFamilies(); Return information about the font families that are available on the; current display. An array of strings is returned holding a list of all the available font; families. The array is terminated with a NULL pointer. void FreeFontFamilies(char** f); Delete an array of families allocated GetFontFamilies() method. TGFont * GetFontFromAttributes(FontAttributes_t* fa, TGFont* fontPtr); Given a desired set of attributes for a font, find a font with the; closest matching attributes and create a new TGFont object.; The return value is a pointer to a TGFont object that represents the; font with the desired attributes. If a font with the desired attributes; could not be constructed, some other font will be substituted; automatically. Every call to this procedure returns a new TGFont object, even if the; specified attributes have already been seen before. TGFont * GetNativeFont(const char* name, Bool_t fixedDefault = kTRUE); The return value is a pointer to an TGFont object that represents the; native font. If a native font ",MatchSource.WIKI,root/html528/TGFontPool.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGFontPool.html
https://root.cern/root/html528/TGFontPool.html:11431,Availability,avail,available,11431,"ing(const FontStateMap_t* map, int numKey); Given a lookup table, map a number to a string in the table. If numKey was equal to the numeric key of one of the elements in the; table, returns the string key of that element. Returns NULL if numKey; was not equal to any of the numeric keys in the table. Bool_t FieldSpecified(const char* field); Helper function for ParseXLFD(). Determines if a field in the XLFD was; set to a non-null, non-don't-care value. The return value is kFALSE if the field in the XLFD was not set and; should be ignored, kTRUE otherwise. field -- The field of the XLFD to check. Strictly speaking, only when; the string is ""*"" does it mean don't-care. However, an; unspecified or question mark is also interpreted as don't-care. const char * NameOfFont(TGFont* font); Given a font, return a textual string identifying it. char ** GetFontFamilies(); Return information about the font families that are available on the; current display. An array of strings is returned holding a list of all the available font; families. The array is terminated with a NULL pointer. void FreeFontFamilies(char** f); Delete an array of families allocated GetFontFamilies() method. TGFont * GetFontFromAttributes(FontAttributes_t* fa, TGFont* fontPtr); Given a desired set of attributes for a font, find a font with the; closest matching attributes and create a new TGFont object.; The return value is a pointer to a TGFont object that represents the; font with the desired attributes. If a font with the desired attributes; could not be constructed, some other font will be substituted; automatically. Every call to this procedure returns a new TGFont object, even if the; specified attributes have already been seen before. TGFont * GetNativeFont(const char* name, Bool_t fixedDefault = kTRUE); The return value is a pointer to an TGFont object that represents the; native font. If a native font by the given name could not be found,; the return value is NULL. Every call to this procedure retur",MatchSource.WIKI,root/html528/TGFontPool.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGFontPool.html
https://root.cern/root/html528/TGFontPool.html:12886,Deployability,release,released,12886,"ntFamilies(char** f); Delete an array of families allocated GetFontFamilies() method. TGFont * GetFontFromAttributes(FontAttributes_t* fa, TGFont* fontPtr); Given a desired set of attributes for a font, find a font with the; closest matching attributes and create a new TGFont object.; The return value is a pointer to a TGFont object that represents the; font with the desired attributes. If a font with the desired attributes; could not be constructed, some other font will be substituted; automatically. Every call to this procedure returns a new TGFont object, even if the; specified attributes have already been seen before. TGFont * GetNativeFont(const char* name, Bool_t fixedDefault = kTRUE); The return value is a pointer to an TGFont object that represents the; native font. If a native font by the given name could not be found,; the return value is NULL. Every call to this procedure returns a new TGFont object, even if the; name has already been seen before. The caller should call FreeFont; when the font is no longer needed. TGFont * MakeFont(TGFont* font, FontStruct_t fontStruct, const char* fontName); Helper for GetNativeFont() and GetFontFromAttributes(). Creates and; intializes a new TGFont object. font -- If non-NULL, store the information in this existing TGFont; object, rather than creating a new one; the existing; contents of the font will be released. If NULL, a new; TGFont object is created.; fontStruct -- information about font.; fontName -- The string passed to TVirtualX::LoadQueryFont() to construct the; fontStruct. FontAttributes_t& operator=(const TGFontPool& fp). TGFontPool(const TGFontPool& fp). » Author: Fons Rademakers 20/5/2003 » Copyright (C) 1995-2003, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id: TGFont.h 23115 2008-04-10 13:35:37Z rdm $ » Last generated: 2010-09-23 20:06; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html528/TGFontPool.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGFontPool.html
https://root.cern/root/html528/TGFontPool.html:11563,Energy Efficiency,allocate,allocated,11563,"eric key of one of the elements in the; table, returns the string key of that element. Returns NULL if numKey; was not equal to any of the numeric keys in the table. Bool_t FieldSpecified(const char* field); Helper function for ParseXLFD(). Determines if a field in the XLFD was; set to a non-null, non-don't-care value. The return value is kFALSE if the field in the XLFD was not set and; should be ignored, kTRUE otherwise. field -- The field of the XLFD to check. Strictly speaking, only when; the string is ""*"" does it mean don't-care. However, an; unspecified or question mark is also interpreted as don't-care. const char * NameOfFont(TGFont* font); Given a font, return a textual string identifying it. char ** GetFontFamilies(); Return information about the font families that are available on the; current display. An array of strings is returned holding a list of all the available font; families. The array is terminated with a NULL pointer. void FreeFontFamilies(char** f); Delete an array of families allocated GetFontFamilies() method. TGFont * GetFontFromAttributes(FontAttributes_t* fa, TGFont* fontPtr); Given a desired set of attributes for a font, find a font with the; closest matching attributes and create a new TGFont object.; The return value is a pointer to a TGFont object that represents the; font with the desired attributes. If a font with the desired attributes; could not be constructed, some other font will be substituted; automatically. Every call to this procedure returns a new TGFont object, even if the; specified attributes have already been seen before. TGFont * GetNativeFont(const char* name, Bool_t fixedDefault = kTRUE); The return value is a pointer to an TGFont object that represents the; native font. If a native font by the given name could not be found,; the return value is NULL. Every call to this procedure returns a new TGFont object, even if the; name has already been seen before. The caller should call FreeFont; when the font is no longer need",MatchSource.WIKI,root/html528/TGFontPool.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGFontPool.html
https://root.cern/root/html528/TGFontTypeComboBox.html:378,Availability,down,down,378,". TGFontTypeComboBox. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGFontTypeComboBox. class TGFontTypeComboBox: public TGComboBox. TGComboBox, TGComboBoxPopup. A combobox (also known as a drop down listbox) allows the selection; of one item out of a list of items. The selected item is visible in; a little window. To view the list of possible items one has to click; on a button on the right of the little window. This will drop down; a listbox. After selecting an item from the listbox the box will; disappear and the newly selected item will be shown in the little; window. The TGComboBox is user callable. The TGComboBoxPopup is a service; class of the combobox. Selecting an item in the combobox will generate the event:; kC_COMMAND, kCM_COMBOBOX, combobox id, item id. Function Members (Methods); public:. TGFontTypeComboBox(const TGWindow* p = 0, Int_t id = -1, UInt_t options = kHorizontalFrame|kSunkenFrame|kDoubleBorder, Pixel_t bask = GetWhitePixel()); virtual~TGFontTypeComboBox(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidTGComboBox::AddEntry(TGString* s, Int_t id); virtual voidTGComboBox::AddEntry(const char* s, Int_t id); virtual voidTGComboBox::AddEntry(TGLBEntry* lbe, TGLayoutHints* lhints); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual voidTGWidget::Associate(const TGWindow* w); static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* me",MatchSource.WIKI,root/html528/TGFontTypeComboBox.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGFontTypeComboBox.html
https://root.cern/root/html528/TGFontTypeComboBox.html:615,Availability,down,down,615,". TGFontTypeComboBox. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGFontTypeComboBox. class TGFontTypeComboBox: public TGComboBox. TGComboBox, TGComboBoxPopup. A combobox (also known as a drop down listbox) allows the selection; of one item out of a list of items. The selected item is visible in; a little window. To view the list of possible items one has to click; on a button on the right of the little window. This will drop down; a listbox. After selecting an item from the listbox the box will; disappear and the newly selected item will be shown in the little; window. The TGComboBox is user callable. The TGComboBoxPopup is a service; class of the combobox. Selecting an item in the combobox will generate the event:; kC_COMMAND, kCM_COMBOBOX, combobox id, item id. Function Members (Methods); public:. TGFontTypeComboBox(const TGWindow* p = 0, Int_t id = -1, UInt_t options = kHorizontalFrame|kSunkenFrame|kDoubleBorder, Pixel_t bask = GetWhitePixel()); virtual~TGFontTypeComboBox(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidTGComboBox::AddEntry(TGString* s, Int_t id); virtual voidTGComboBox::AddEntry(const char* s, Int_t id); virtual voidTGComboBox::AddEntry(TGLBEntry* lbe, TGLayoutHints* lhints); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual voidTGWidget::Associate(const TGWindow* w); static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* me",MatchSource.WIKI,root/html528/TGFontTypeComboBox.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGFontTypeComboBox.html
https://root.cern/root/html528/TGFontTypeComboBox.html:5150,Availability,error,error,5150," voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTGComboBox::EnableTextInput(Bool_t on)TOGGLE GETTER ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGLBEntry*TGComboBox::FindEntry(const char* s) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; const char*TGWidget::GetCommand() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDime",MatchSource.WIKI,root/html528/TGFontTypeComboBox.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGFontTypeComboBox.html
https://root.cern/root/html528/TGFontTypeComboBox.html:5234,Availability,error,error,5234,"* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTGComboBox::EnableTextInput(Bool_t on)TOGGLE GETTER ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGLBEntry*TGComboBox::FindEntry(const char* s) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; const char*TGWidget::GetCommand() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGComboBox::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultW",MatchSource.WIKI,root/html528/TGFontTypeComboBox.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGFontTypeComboBox.html
https://root.cern/root/html528/TGFontTypeComboBox.html:19170,Availability,down,down,19170,,MatchSource.WIKI,root/html528/TGFontTypeComboBox.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGFontTypeComboBox.html
https://root.cern/root/html528/TGFontTypeComboBox.html:19325,Availability,mask,mask,19325,,MatchSource.WIKI,root/html528/TGFontTypeComboBox.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGFontTypeComboBox.html
https://root.cern/root/html528/TGFrame.html:5010,Availability,error,error,5010,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tGetBackground() const; static const TGGC&GetBckgndGC(); static const TGGC&GetBlackGC(); static Pixel_tGetBlackPixel(); Int_tGetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tGetDefaultFrameBackground(); virtual UInt_tGetDefaultHeight() const; static Pixel_tGetDefaultSelectedBackground(); virtual TGDimensionGetDefaultSize() const; virtual UInt_tGetDefaultWidth() const; virtual TDNDData*GetDNDData(Atom_t); virtual Int_tGetDragType() const; virtual Option_t*TObject::GetDrawOption() const; virtual Int_tGetDropType() const; static Long_tTObject::GetDtorOnly(); vi",MatchSource.WIKI,root/html528/TGFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGFrame.html
https://root.cern/root/html528/TGFrame.html:5094,Availability,error,error,5094,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tGetBackground() const; static const TGGC&GetBckgndGC(); static const TGGC&GetBlackGC(); static Pixel_tGetBlackPixel(); Int_tGetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tGetDefaultFrameBackground(); virtual UInt_tGetDefaultHeight() const; static Pixel_tGetDefaultSelectedBackground(); virtual TGDimensionGetDefaultSize() const; virtual UInt_tGetDefaultWidth() const; virtual TDNDData*GetDNDData(Atom_t); virtual Int_tGetDragType() const; virtual Option_t*TObject::GetDrawOption() const; virtual Int_tGetDropType() const; static Long_tTObject::GetDtorOnly(); virtual UInt_tTGWindow::GetEditDisabled() const; UInt_tGetEventMask() const; virtual P",MatchSource.WIKI,root/html528/TGFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGFrame.html
https://root.cern/root/html528/TGFrame.html:15040,Availability,mask,mask,15040,"ed; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Pixel_tfBackgroundframe background color; Int_tfBorderWidthframe border width; TGClient*TGObject::fClientConnection to display server; Int_tfDNDStateEDNDFlags; UInt_tTGWindow::fEditDisabledflags used for ""guibuilding""; UInt_tfEventMaskcurrenty active event mask; TGFrameElement*fFEpointer to frame element; UInt_tfHeightframe height; Handle_tTGObject::fIdX11/Win32 Window identifier; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; UInt_tfMaxHeightmaximal frame height; UInt_tfMaxWidthmaximal frame width; UInt_tfMinHeightminimal frame height; UInt_tfMinWidthminimal frame width; TStringTGWindow::fNamename of the window used in SavePrimitive(); Bool_tTGWindow::fNeedRedrawkTRUE if window needs to be redrawn; UInt_tfOptionsframe options; const TGWindow*TGWindow::fParentParent window; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; UInt_tfWidthframe width; Int_tfXframe x position; Int_tfYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*fgBckgndGC; static const TGGC*fgBlackGC; static Pixel_tfgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tfgDbw; static Int_tfgDbx; static Int_tfgDby; static Pixel_tfgDefaultFrameBackground; static Pixel_tfgDefaultSelectedBackground; static const TGGC*fgHilightGC; static Bool_tfgInit; static UInt_tfgLastButton; static Time_tfgLastClick; static const TGGC*fgShadowGC; static UInt_tfgUserColor; static const TGGC*fgWhiteGC; static Pixel_tfgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGFrame(const TGWindow* p = 0, UInt_t w = 1, UInt_t h = 1, UInt_t options = 0, Pixel_t back =",MatchSource.WIKI,root/html528/TGFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGFrame.html
https://root.cern/root/html528/TGFrame.html:23708,Deployability,update,update,23708,"Bool_t = kTRUE); {}. Bool_t IsLayoutBroken() const; { return kFALSE; }. void SetCleanup(Int_t = kLocalCleanup); { /* backward compatebility */ }. UInt_t GetWidth() const; { return fWidth; }. UInt_t GetHeight() const; { return fHeight; }. UInt_t GetMinWidth() const; { return fMinWidth; }. UInt_t GetMinHeight() const; { return fMinHeight; }. UInt_t GetMaxWidth() const; { return fMaxWidth; }. UInt_t GetMaxHeight() const; { return fMaxHeight; }. TGDimension GetSize() const; { return TGDimension(fWidth, fHeight); }. Int_t GetX() const; { return fX; }. Int_t GetY() const; { return fY; }. Int_t GetBorderWidth() const; { return fBorderWidth; }. TGFrameElement * GetFrameElement() const; { return fFE; }. void SetFrameElement(TGFrameElement* fe); { fFE = fe; }. Bool_t Contains(Int_t x, Int_t y) const; { return ((x >= 0) && (x < (Int_t)fWidth) && (y >= 0) && (y < (Int_t)fHeight)); }. TGFrame * GetFrameFromPoint(Int_t x, Int_t y); { return (Contains(x, y) ? this : 0); }. void SetX(Int_t x); Modifiers (without graphic update). { fX = x; }. void SetY(Int_t y); { fY = y; }. void SetWidth(UInt_t w); { fWidth = w; }. void SetHeight(UInt_t h); { fHeight = h; }. void SetMinWidth(UInt_t w); { fMinWidth = w; }. void SetMinHeight(UInt_t h); { fMinHeight = h; }. void SetMaxWidth(UInt_t w); { fMaxWidth = w; }. void SetMaxHeight(UInt_t h); { fMaxHeight = h; }. void SetSize(const TGDimension& s); { fWidth = s.fWidth; fHeight = s.fHeight; }. void Delete(Option_t* = """"); dummy to remove from context menu. { }. TObject * DrawClone(Option_t* = """") const; { return 0; }. void DrawClass() const; { }. void Dump() const; { }. void Inspect() const; { }. void SetDrawOption(Option_t* = """"); { }. void SetDNDSource(Bool_t onoff); drag and drop... { if (onoff) fDNDState |= kIsDNDSource; else fDNDState &= ~kIsDNDSource; }. void SetDNDTarget(Bool_t onoff); { if (onoff) fDNDState |= kIsDNDTarget; else fDNDState &= ~kIsDNDTarget; }. Bool_t IsDNDSource() const; { return fDNDState & kIsDNDSource; }. Bool_t IsDNDT",MatchSource.WIKI,root/html528/TGFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGFrame.html
https://root.cern/root/html528/TGFrame.html:18734,Integrability,message,message,18734," the events the frame should handle. void RemoveInput(UInt_t emask); Remove events specified in emask from the events the frame should handle. void Draw3dRectangle(UInt_t type, Int_t x, Int_t y, UInt_t w, UInt_t h); Draw 3D rectangle on the frame border. void DrawBorder(); Draw frame border. void DoRedraw(); Redraw the frame. Bool_t HandleConfigureNotify(Event_t* event); This event is generated when the frame is resized. Bool_t HandleEvent(Event_t* event); Handle all frame events. Events are dispatched to the specific; event handlers. TGDimension GetDefaultSize() const; std::cout << fWidth << ""x"" << fHeight << std::endl;. void Move(Int_t x, Int_t y); Move frame. void Resize(UInt_t w = 0, UInt_t h = 0); Resize the frame.; If w=0 && h=0 - Resize to deafult size. void Resize(TGDimension size); Resize the frame. void MoveResize(Int_t x, Int_t y, UInt_t w = 0, UInt_t h = 0); Move and/or resize the frame.; If w=0 && h=0 - Resize to deafult size. void SendMessage(const TGWindow* w, Long_t msg, Long_t parm1, Long_t parm2); Send message (i.e. event) to window w. Message is encoded in one long; as message type and up to two long parameters. Bool_t HandleClientMessage(Event_t* event); Handle a client message. Client messages are the ones sent via; TGFrame::SendMessage (typically by widgets). ULong_t GetDefaultFrameBackground(); Get default frame background. ULong_t GetDefaultSelectedBackground(); Get default selected frame background. ULong_t GetWhitePixel(); Get white pixel value. ULong_t GetBlackPixel(); Get black pixel value. const TGGC & GetBlackGC(); Get black graphics context. const TGGC & GetWhiteGC(); Get white graphics context. const TGGC & GetHilightGC(); Get highlight color graphics context. const TGGC & GetShadowGC(); Get shadow color graphics context. const TGGC & GetBckgndGC(); Get background color graphics context. Time_t GetLastClick(); Get time of last mouse click. void Print(Option_t* option = """") const; Print window id. void SetDragType(Int_t type); SetDragT",MatchSource.WIKI,root/html528/TGFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGFrame.html
https://root.cern/root/html528/TGFrame.html:18803,Integrability,message,message,18803,"he events the frame should handle. void Draw3dRectangle(UInt_t type, Int_t x, Int_t y, UInt_t w, UInt_t h); Draw 3D rectangle on the frame border. void DrawBorder(); Draw frame border. void DoRedraw(); Redraw the frame. Bool_t HandleConfigureNotify(Event_t* event); This event is generated when the frame is resized. Bool_t HandleEvent(Event_t* event); Handle all frame events. Events are dispatched to the specific; event handlers. TGDimension GetDefaultSize() const; std::cout << fWidth << ""x"" << fHeight << std::endl;. void Move(Int_t x, Int_t y); Move frame. void Resize(UInt_t w = 0, UInt_t h = 0); Resize the frame.; If w=0 && h=0 - Resize to deafult size. void Resize(TGDimension size); Resize the frame. void MoveResize(Int_t x, Int_t y, UInt_t w = 0, UInt_t h = 0); Move and/or resize the frame.; If w=0 && h=0 - Resize to deafult size. void SendMessage(const TGWindow* w, Long_t msg, Long_t parm1, Long_t parm2); Send message (i.e. event) to window w. Message is encoded in one long; as message type and up to two long parameters. Bool_t HandleClientMessage(Event_t* event); Handle a client message. Client messages are the ones sent via; TGFrame::SendMessage (typically by widgets). ULong_t GetDefaultFrameBackground(); Get default frame background. ULong_t GetDefaultSelectedBackground(); Get default selected frame background. ULong_t GetWhitePixel(); Get white pixel value. ULong_t GetBlackPixel(); Get black pixel value. const TGGC & GetBlackGC(); Get black graphics context. const TGGC & GetWhiteGC(); Get white graphics context. const TGGC & GetHilightGC(); Get highlight color graphics context. const TGGC & GetShadowGC(); Get shadow color graphics context. const TGGC & GetBckgndGC(); Get background color graphics context. Time_t GetLastClick(); Get time of last mouse click. void Print(Option_t* option = """") const; Print window id. void SetDragType(Int_t type); SetDragType. void SetDropType(Int_t type); SetDropType. Int_t GetDragType() const; Returns drag source type.; If fram",MatchSource.WIKI,root/html528/TGFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGFrame.html
https://root.cern/root/html528/TGFrame.html:18907,Integrability,message,message,18907," x, Int_t y, UInt_t w, UInt_t h); Draw 3D rectangle on the frame border. void DrawBorder(); Draw frame border. void DoRedraw(); Redraw the frame. Bool_t HandleConfigureNotify(Event_t* event); This event is generated when the frame is resized. Bool_t HandleEvent(Event_t* event); Handle all frame events. Events are dispatched to the specific; event handlers. TGDimension GetDefaultSize() const; std::cout << fWidth << ""x"" << fHeight << std::endl;. void Move(Int_t x, Int_t y); Move frame. void Resize(UInt_t w = 0, UInt_t h = 0); Resize the frame.; If w=0 && h=0 - Resize to deafult size. void Resize(TGDimension size); Resize the frame. void MoveResize(Int_t x, Int_t y, UInt_t w = 0, UInt_t h = 0); Move and/or resize the frame.; If w=0 && h=0 - Resize to deafult size. void SendMessage(const TGWindow* w, Long_t msg, Long_t parm1, Long_t parm2); Send message (i.e. event) to window w. Message is encoded in one long; as message type and up to two long parameters. Bool_t HandleClientMessage(Event_t* event); Handle a client message. Client messages are the ones sent via; TGFrame::SendMessage (typically by widgets). ULong_t GetDefaultFrameBackground(); Get default frame background. ULong_t GetDefaultSelectedBackground(); Get default selected frame background. ULong_t GetWhitePixel(); Get white pixel value. ULong_t GetBlackPixel(); Get black pixel value. const TGGC & GetBlackGC(); Get black graphics context. const TGGC & GetWhiteGC(); Get white graphics context. const TGGC & GetHilightGC(); Get highlight color graphics context. const TGGC & GetShadowGC(); Get shadow color graphics context. const TGGC & GetBckgndGC(); Get background color graphics context. Time_t GetLastClick(); Get time of last mouse click. void Print(Option_t* option = """") const; Print window id. void SetDragType(Int_t type); SetDragType. void SetDropType(Int_t type); SetDropType. Int_t GetDragType() const; Returns drag source type.; If frame is not ""draggable"" - return zero. Int_t GetDropType() const; Returns dro",MatchSource.WIKI,root/html528/TGFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGFrame.html
https://root.cern/root/html528/TGFrame.html:18923,Integrability,message,messages,18923," DrawBorder(); Draw frame border. void DoRedraw(); Redraw the frame. Bool_t HandleConfigureNotify(Event_t* event); This event is generated when the frame is resized. Bool_t HandleEvent(Event_t* event); Handle all frame events. Events are dispatched to the specific; event handlers. TGDimension GetDefaultSize() const; std::cout << fWidth << ""x"" << fHeight << std::endl;. void Move(Int_t x, Int_t y); Move frame. void Resize(UInt_t w = 0, UInt_t h = 0); Resize the frame.; If w=0 && h=0 - Resize to deafult size. void Resize(TGDimension size); Resize the frame. void MoveResize(Int_t x, Int_t y, UInt_t w = 0, UInt_t h = 0); Move and/or resize the frame.; If w=0 && h=0 - Resize to deafult size. void SendMessage(const TGWindow* w, Long_t msg, Long_t parm1, Long_t parm2); Send message (i.e. event) to window w. Message is encoded in one long; as message type and up to two long parameters. Bool_t HandleClientMessage(Event_t* event); Handle a client message. Client messages are the ones sent via; TGFrame::SendMessage (typically by widgets). ULong_t GetDefaultFrameBackground(); Get default frame background. ULong_t GetDefaultSelectedBackground(); Get default selected frame background. ULong_t GetWhitePixel(); Get white pixel value. ULong_t GetBlackPixel(); Get black pixel value. const TGGC & GetBlackGC(); Get black graphics context. const TGGC & GetWhiteGC(); Get white graphics context. const TGGC & GetHilightGC(); Get highlight color graphics context. const TGGC & GetShadowGC(); Get shadow color graphics context. const TGGC & GetBckgndGC(); Get background color graphics context. Time_t GetLastClick(); Get time of last mouse click. void Print(Option_t* option = """") const; Print window id. void SetDragType(Int_t type); SetDragType. void SetDropType(Int_t type); SetDropType. Int_t GetDragType() const; Returns drag source type.; If frame is not ""draggable"" - return zero. Int_t GetDropType() const; Returns drop target type.; If frame cannot accept drop - return zero. void StartGuiBuil",MatchSource.WIKI,root/html528/TGFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGFrame.html
https://root.cern/root/html528/TGFrame.html:1355,Testability,log,logically,1355,"rame,; TGMainFrame, TGTransientFrame and TGGroupFrame. The frame classes describe the different ""dressed"" GUI windows. The TGFrame class is a subclasses of TGWindow, and is used as base; class for some simple widgets (buttons, labels, etc.).; It provides:; - position & dimension fields; - an 'options' attribute (see constant above); - a generic event handler; - a generic layout mechanism; - a generic border. The TGCompositeFrame class is the base class for composite widgets; (menu bars, list boxes, etc.).; It provides:; - a layout manager; - a frame container (TList *). The TGVerticalFrame and TGHorizontalFrame are composite frame that; layout their children in vertical or horizontal way. The TGMainFrame class defines top level windows that interact with; the system Window Manager. The TGTransientFrame class defines transient windows that typically; are used for dialogs windows. The TGGroupFrame is a composite frame with a border and a title.; It is typically used to group a number of logically related widgets; visually together. /*. */. Function Members (Methods); public:. TGFrame(TGClient* c, Window_t id, const TGWindow* parent = 0); TGFrame(const TGWindow* p = 0, UInt_t w = 1, UInt_t h = 1, UInt_t options = 0, Pixel_t back = GetDefaultFrameBackground()); virtual~TGFrame(); voidTObject::AbstractMethod(const char* method) const; virtual voidActivate(Bool_t); voidAddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidChangeOptions(UInt_t options); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = ",MatchSource.WIKI,root/html528/TGFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGFrame.html
https://root.cern/root/html528/TGFrame.html:557,Usability,simpl,simple,557,". TGFrame. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGFrame. class TGFrame: public TGWindow, public TQObject. TGFrame, TGCompositeFrame, TGVerticalFrame, TGHorizontalFrame,; TGMainFrame, TGTransientFrame and TGGroupFrame. The frame classes describe the different ""dressed"" GUI windows. The TGFrame class is a subclasses of TGWindow, and is used as base; class for some simple widgets (buttons, labels, etc.).; It provides:; - position & dimension fields; - an 'options' attribute (see constant above); - a generic event handler; - a generic layout mechanism; - a generic border. The TGCompositeFrame class is the base class for composite widgets; (menu bars, list boxes, etc.).; It provides:; - a layout manager; - a frame container (TList *). The TGVerticalFrame and TGHorizontalFrame are composite frame that; layout their children in vertical or horizontal way. The TGMainFrame class defines top level windows that interact with; the system Window Manager. The TGTransientFrame class defines transient windows that typically; are used for dialogs windows. The TGGroupFrame is a composite frame with a border and a title.; It is typically used to group a number of logically related widgets; visually together. /*. */. Function Members (Methods); public:. TGFrame(TGClient* c, Window_t id, const TGWindow* parent = 0); TGFrame(const TGWindow* p = 0, UInt_t w = 1, UInt_t h = 1, UInt_t options = 0, Pixel_t back = GetDefaultFrameBackground()); virtual~TGFrame(); voidTObject::AbstractMethod(const char* method) const; virtual voidActivate(Bool_t); voidAddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); v",MatchSource.WIKI,root/html528/TGFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGFrame.html
https://root.cern/root/html528/TGFrameElement.html:1430,Availability,error,error,1430,"meElement(); TGFrameElement(TGFrame* f, TGLayoutHints* l); virtual~TGFrameElement(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) con",MatchSource.WIKI,root/html528/TGFrameElement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGFrameElement.html
https://root.cern/root/html528/TGFrameElement.html:1514,Availability,error,error,1514," voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject",MatchSource.WIKI,root/html528/TGFrameElement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGFrameElement.html
https://root.cern/root/html528/TGFrameElementPack.html:1345,Availability,error,error,1345,"k(TGFrame* frame, TGLayoutHints* lh = 0, Float_t weight = 1); ~TGFrameElementPack(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) con",MatchSource.WIKI,root/html528/TGFrameElementPack.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGFrameElementPack.html
https://root.cern/root/html528/TGFrameElementPack.html:1429,Availability,error,error,1429," voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject",MatchSource.WIKI,root/html528/TGFrameElementPack.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGFrameElementPack.html
https://root.cern/root/html528/TGFrameElementPack.html:5265,Performance,cache,cached,5265,"Members(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). private:. TGFrameElementPack(const TGFrameElementPack&); TGFrameElementPack&operator=(const TGFrameElementPack&). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. public:. TGFrame*TGFrameElement::fFrameframe used in layout; TGLayoutHints*TGFrameElement::fLayoutlayout hints used in layout; TGFrameElementPack*fSplitFE! cached varaible for optimisation; Int_tTGFrameElement::fStateEFrameState defined in TGFrame.h; Float_tfWeightrelative weight. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGFrameElementPack(const TGFrameElementPack& ). TGFrameElementPack& operator=(const TGFrameElementPack& ). TGFrameElementPack(TGFrame* frame, TGLayoutHints* lh = 0, Float_t weight = 1); { }. » Author: Matevz Tadel 2007 » Copyright (C) 1995-2007, Rene Brun and Fons Rademakers. *; » Last changed: root/eve:$Id: TGPack.h 29129 2009-06-22 09:39:20Z brun $ » Last generated: 2010-09-23 20:06; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html528/TGFrameElementPack.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGFrameElementPack.html
https://root.cern/root/html528/TGFSComboBox.html:4605,Availability,error,error,4605," voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTGComboBox::EnableTextInput(Bool_t on)TOGGLE GETTER ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGLBEntry*TGComboBox::FindEntry(const char* s) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; const char*TGWidget::GetCommand() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDime",MatchSource.WIKI,root/html528/TGFSComboBox.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGFSComboBox.html
https://root.cern/root/html528/TGFSComboBox.html:4689,Availability,error,error,4689,"* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTGComboBox::EnableTextInput(Bool_t on)TOGGLE GETTER ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGLBEntry*TGComboBox::FindEntry(const char* s) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; const char*TGWidget::GetCommand() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGComboBox::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultW",MatchSource.WIKI,root/html528/TGFSComboBox.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGFSComboBox.html
https://root.cern/root/html528/TGFSComboBox.html:18651,Availability,down,down,18651,,MatchSource.WIKI,root/html528/TGFSComboBox.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGFSComboBox.html
https://root.cern/root/html528/TGFSComboBox.html:18806,Availability,mask,mask,18806,,MatchSource.WIKI,root/html528/TGFSComboBox.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGFSComboBox.html
https://root.cern/root/html528/TGGC.html:1462,Availability,error,error,1462,"es_t* values = 0); TGGC(const TGGC& g); virtual~TGGC(); voidTObject::AbstractMethod(const char* method) const; voidTRefCnt::AddReference(); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int_tGetArcMode() const; const GCValues_t*GetAttributes() const; Pixel_tGetBackground() const; Int_tGetCapStyle() const; Pixmap_tGetClipMask() const; Int_tGetClipXOrigin() const; Int_tGetClipYOrigin() const; const char*GetDashes() const; Int_tGetDashLen() const; Int_tGetDashOffset() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Int_tGetFillRule() const; Int_tGetFillStyle() const; FontH_tGetFont() const; Pixel_tGetForeground() const; EGraphicsFunctionGetFunction() const; GContext_tGetGC() const; Bool_tGetGraphicsExposures() const; virtual const char*TObject::GetIconName() const; Int_tGetJ",MatchSource.WIKI,root/html528/TGGC.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGGC.html
https://root.cern/root/html528/TGGC.html:1546,Availability,error,error,1546,"const char* method) const; voidTRefCnt::AddReference(); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int_tGetArcMode() const; const GCValues_t*GetAttributes() const; Pixel_tGetBackground() const; Int_tGetCapStyle() const; Pixmap_tGetClipMask() const; Int_tGetClipXOrigin() const; Int_tGetClipYOrigin() const; const char*GetDashes() const; Int_tGetDashLen() const; Int_tGetDashOffset() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Int_tGetFillRule() const; Int_tGetFillStyle() const; FontH_tGetFont() const; Pixel_tGetForeground() const; EGraphicsFunctionGetFunction() const; GContext_tGetGC() const; Bool_tGetGraphicsExposures() const; virtual const char*TObject::GetIconName() const; Int_tGetJoinStyle() const; Int_tGetLineStyle() const; Int_tGetLineWidth() const; Mask_tGetMas",MatchSource.WIKI,root/html528/TGGC.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGGC.html
https://root.cern/root/html528/TGGC.html:7030,Availability,mask,mask,7030,"st; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. TGGC(GCValues_t* values, Bool_t calledByGCPool); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; TStringGetMaskString() const; voidTObject::MakeZombie(); voidUpdateValues(GCValues_t* v). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };; enum TRefCnt::EReferenceFlag { kStaticInit; };. protected:. GContext_tfContextgraphics context handle; UInt_tTRefCnt::fRefs(1 less than) number of references; GCValues_tfValuesgraphics context values + mask. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGGC(GCValues_t* values, Bool_t calledByGCPool); Create a graphics context (only called via TGGCPool::GetGC()). TGGC(GCValues_t* values = 0); Create a graphics context, registers GC in GCPool. TGGC(const TGGC& g); Copy a graphics context. ~TGGC(); Delete graphics context. TGGC & operator=(const TGGC& rhs); Graphics context assignment operator. GContext_t operator()() const; Not inline due to a bug in g++ 2.96 20000731 (Red Hat Linux 7.0). void UpdateValues(GCValues_t* v); Update values + mask. void SetAttributes(GCValues_t* values); Set attributes as specified in the values structure. void SetFunction(EGraphicsFunction v); Set graphics context drawing function. void SetPlaneMask(ULong_t v); Set plane mask. void SetForeground(Pixel_t v); Set foreground color. void SetBackground(Pixel_t v); Set background color. void SetLine",MatchSource.WIKI,root/html528/TGGC.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGGC.html
https://root.cern/root/html528/TGGC.html:7620,Availability,mask,mask,7620,"its { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };; enum TRefCnt::EReferenceFlag { kStaticInit; };. protected:. GContext_tfContextgraphics context handle; UInt_tTRefCnt::fRefs(1 less than) number of references; GCValues_tfValuesgraphics context values + mask. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGGC(GCValues_t* values, Bool_t calledByGCPool); Create a graphics context (only called via TGGCPool::GetGC()). TGGC(GCValues_t* values = 0); Create a graphics context, registers GC in GCPool. TGGC(const TGGC& g); Copy a graphics context. ~TGGC(); Delete graphics context. TGGC & operator=(const TGGC& rhs); Graphics context assignment operator. GContext_t operator()() const; Not inline due to a bug in g++ 2.96 20000731 (Red Hat Linux 7.0). void UpdateValues(GCValues_t* v); Update values + mask. void SetAttributes(GCValues_t* values); Set attributes as specified in the values structure. void SetFunction(EGraphicsFunction v); Set graphics context drawing function. void SetPlaneMask(ULong_t v); Set plane mask. void SetForeground(Pixel_t v); Set foreground color. void SetBackground(Pixel_t v); Set background color. void SetLineWidth(Int_t v); Set line width. void SetLineStyle(Int_t v); Set line style (kLineSolid, kLineOnOffDash, kLineDoubleDash). void SetCapStyle(Int_t v); Set cap style (kCapNotLast, kCapButt, kCapRound, kCapProjecting). void SetJoinStyle(Int_t v); Set line join style (kJoinMiter, kJoinRound, kJoinBevel). void SetFillStyle(Int_t v); Set fill style (kFillSolid, kFillTiled, kFillStippled,; kFillOpaeueStippled). void SetFillRule(Int_t v); Set fill rule (kEvenOddRule, kWindingRule). void SetTile(Pixmap_t v); Set tile pixmap for tiling operations. void SetStipple(Pixmap_t v); Set 1 plane pixmap for stippling. void SetTileStipXOrigin(Int_t ",MatchSource.WIKI,root/html528/TGGC.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGGC.html
https://root.cern/root/html528/TGGC.html:7837,Availability,mask,mask,7837,"ete; };; enum TRefCnt::EReferenceFlag { kStaticInit; };. protected:. GContext_tfContextgraphics context handle; UInt_tTRefCnt::fRefs(1 less than) number of references; GCValues_tfValuesgraphics context values + mask. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGGC(GCValues_t* values, Bool_t calledByGCPool); Create a graphics context (only called via TGGCPool::GetGC()). TGGC(GCValues_t* values = 0); Create a graphics context, registers GC in GCPool. TGGC(const TGGC& g); Copy a graphics context. ~TGGC(); Delete graphics context. TGGC & operator=(const TGGC& rhs); Graphics context assignment operator. GContext_t operator()() const; Not inline due to a bug in g++ 2.96 20000731 (Red Hat Linux 7.0). void UpdateValues(GCValues_t* v); Update values + mask. void SetAttributes(GCValues_t* values); Set attributes as specified in the values structure. void SetFunction(EGraphicsFunction v); Set graphics context drawing function. void SetPlaneMask(ULong_t v); Set plane mask. void SetForeground(Pixel_t v); Set foreground color. void SetBackground(Pixel_t v); Set background color. void SetLineWidth(Int_t v); Set line width. void SetLineStyle(Int_t v); Set line style (kLineSolid, kLineOnOffDash, kLineDoubleDash). void SetCapStyle(Int_t v); Set cap style (kCapNotLast, kCapButt, kCapRound, kCapProjecting). void SetJoinStyle(Int_t v); Set line join style (kJoinMiter, kJoinRound, kJoinBevel). void SetFillStyle(Int_t v); Set fill style (kFillSolid, kFillTiled, kFillStippled,; kFillOpaeueStippled). void SetFillRule(Int_t v); Set fill rule (kEvenOddRule, kWindingRule). void SetTile(Pixmap_t v); Set tile pixmap for tiling operations. void SetStipple(Pixmap_t v); Set 1 plane pixmap for stippling. void SetTileStipXOrigin(Int_t v); X offset for tile or stipple operations. void SetTileStipYOrigin(Int_t v); Y offset for tile or stipple operations. void SetFont(FontH_t v); Set font. void SetSubwindowMode(Int_t v); Set sub window mode (kClipByChildre",MatchSource.WIKI,root/html528/TGGC.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGGC.html
https://root.cern/root/html528/TGGC.html:9419,Availability,mask,mask,9419,"ule, kWindingRule). void SetTile(Pixmap_t v); Set tile pixmap for tiling operations. void SetStipple(Pixmap_t v); Set 1 plane pixmap for stippling. void SetTileStipXOrigin(Int_t v); X offset for tile or stipple operations. void SetTileStipYOrigin(Int_t v); Y offset for tile or stipple operations. void SetFont(FontH_t v); Set font. void SetSubwindowMode(Int_t v); Set sub window mode (kClipByChildren, kIncludeInferiors). void SetGraphicsExposures(Bool_t v); True if graphics exposure should be generated. void SetClipXOrigin(Int_t v); X origin for clipping. void SetClipYOrigin(Int_t v); Y origin for clipping. void SetClipMask(Pixmap_t v); Bitmap for clipping. void SetDashOffset(Int_t v); Patterned/dashed line offset. void SetDashList(const char* v, Int_t len); Set dash pattern. First use SetDashOffset() if not 0. void SetArcMode(Int_t v); Set arc mode (kArcChord, kArcPieSlice). void Print(Option_t* option = """") const; Print graphics contexts info. TString GetMaskString() const; Returns GC mask as a string - used in SavePrimitive(). void SavePrimitive(ostream& out, Option_t* option = """"); Save graphics context info as a C++ statement(s) on output stream out. GContext_t GetGC() const; { return fContext; }. const GCValues_t * GetAttributes() const; { return &fValues; }. Mask_t GetMask() const; { return fValues.fMask; }. EGraphicsFunction GetFunction() const; { return fValues.fFunction; }. ULong_t GetPlaneMask() const; { return fValues.fPlaneMask; }. Pixel_t GetForeground() const; { return fValues.fForeground; }. Pixel_t GetBackground() const; { return fValues.fBackground; }. Int_t GetLineWidth() const; { return fValues.fLineWidth; }. Int_t GetLineStyle() const; { return fValues.fLineStyle; }. Pixmap_t GetTile() const; { return fValues.fTile; }. Pixmap_t GetStipple() const; { return fValues.fStipple; }. Int_t GetTileStipXOrigin() const; { return fValues.fTsXOrigin; }. Int_t GetTileStipYOrigin() const; { return fValues.fTsYOrigin; }. Int_t GetSubwindowMode() const; { return ",MatchSource.WIKI,root/html528/TGGC.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGGC.html
https://root.cern/root/html528/TGGCPool.html:1411,Availability,error,error,1411," TGGCPool(TGClient* client); virtual~TGGCPool(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; TGGC*FindGC(const TGGC* gc); TGGC*FindGC(GContext_t gc); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; voidFreeGC(const TGGC* gc); voidFreeGC(GContext_t gc); TGClient*TGObject::GetClient() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtor",MatchSource.WIKI,root/html528/TGGCPool.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGGCPool.html
https://root.cern/root/html528/TGGCPool.html:1495,Availability,error,error,1495," voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; TGGC*FindGC(const TGGC* gc); TGGC*FindGC(GContext_t gc); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; voidFreeGC(const TGGC* gc); voidFreeGC(GContext_t gc); TGClient*TGObject::GetClient() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); TGGC*GetGC(GContext_t gct); TGGC*GetGC(GCValues_t* values, Bool_t rw = kFALSE); virtual const char*TObject::GetIconName() const; Handle_tTGObject::GetId() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* ti",MatchSource.WIKI,root/html528/TGGCPool.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGGCPool.html
https://root.cern/root/html528/TGGCPool.html:6856,Availability,mask,masks,6856,"ndle_tTGObject::fIdX11/Win32 Window identifier. private:. THashTable*fListhash table of graphics contexts in pool. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGGCPool(TGClient* client); Create graphics context pool. ~TGGCPool(); Delete graphics context pool. void ForceFreeGC(const TGGC* gc); Force remove graphics context from list. Is only called via ~TGGC(). void FreeGC(const TGGC* gc); Delete graphics context if it is not used anymore. void FreeGC(GContext_t gc); Delete graphics context if it is not used anymore. TGGC * FindGC(const TGGC* gc); Find graphics context. Returns 0 in case gc is not found. TGGC * FindGC(GContext_t gc); Find graphics context based on its GContext_t handle. Returns 0; in case gc is not found. TGGC * GetGC(GContext_t gct); returns graphics context based on its GContext_t handle. TGGC * GetGC(GCValues_t* values, Bool_t rw = kFALSE); Get the best matching graphics context depending on values.; If rw is false only a readonly, not modifiable graphics context; is returned. If rw is true a new modifiable graphics context is; returned. Int_t MatchGC(const TGGC* gc, GCValues_t* values); Try to find matching graphics context. On success returns the amount; of matching bits (which may be zero if masks have no common bits),; -1 on failure (when there are common bits but not a single match). void UpdateGC(TGGC* gc, GCValues_t* values); Update graphics context with the values spcified in values->fMask. void Print(Option_t* option = """") const; List all graphics contexts in the pool. TGGC & operator=(const TGGCPool& gp). TGGCPool(const TGGCPool& gp); { }. » Author: Fons Rademakers 20/9/2000 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id: TGGC.h 23115 2008-04-10 13:35:37Z rdm $ » Last generated: 2010-09-23 20:06; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html528/TGGCPool.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGGCPool.html
https://root.cern/root/html528/TGGCPool.html:6891,Availability,failure,failure,6891,"ndle_tTGObject::fIdX11/Win32 Window identifier. private:. THashTable*fListhash table of graphics contexts in pool. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGGCPool(TGClient* client); Create graphics context pool. ~TGGCPool(); Delete graphics context pool. void ForceFreeGC(const TGGC* gc); Force remove graphics context from list. Is only called via ~TGGC(). void FreeGC(const TGGC* gc); Delete graphics context if it is not used anymore. void FreeGC(GContext_t gc); Delete graphics context if it is not used anymore. TGGC * FindGC(const TGGC* gc); Find graphics context. Returns 0 in case gc is not found. TGGC * FindGC(GContext_t gc); Find graphics context based on its GContext_t handle. Returns 0; in case gc is not found. TGGC * GetGC(GContext_t gct); returns graphics context based on its GContext_t handle. TGGC * GetGC(GCValues_t* values, Bool_t rw = kFALSE); Get the best matching graphics context depending on values.; If rw is false only a readonly, not modifiable graphics context; is returned. If rw is true a new modifiable graphics context is; returned. Int_t MatchGC(const TGGC* gc, GCValues_t* values); Try to find matching graphics context. On success returns the amount; of matching bits (which may be zero if masks have no common bits),; -1 on failure (when there are common bits but not a single match). void UpdateGC(TGGC* gc, GCValues_t* values); Update graphics context with the values spcified in values->fMask. void Print(Option_t* option = """") const; List all graphics contexts in the pool. TGGC & operator=(const TGGCPool& gp). TGGCPool(const TGGCPool& gp); { }. » Author: Fons Rademakers 20/9/2000 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id: TGGC.h 23115 2008-04-10 13:35:37Z rdm $ » Last generated: 2010-09-23 20:06; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html528/TGGCPool.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGGCPool.html
https://root.cern/root/html528/TGGCPool.html:6534,Integrability,depend,depending,6534,"ete; };. protected:. TGClient*TGObject::fClientConnection to display server; Handle_tTGObject::fIdX11/Win32 Window identifier. private:. THashTable*fListhash table of graphics contexts in pool. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGGCPool(TGClient* client); Create graphics context pool. ~TGGCPool(); Delete graphics context pool. void ForceFreeGC(const TGGC* gc); Force remove graphics context from list. Is only called via ~TGGC(). void FreeGC(const TGGC* gc); Delete graphics context if it is not used anymore. void FreeGC(GContext_t gc); Delete graphics context if it is not used anymore. TGGC * FindGC(const TGGC* gc); Find graphics context. Returns 0 in case gc is not found. TGGC * FindGC(GContext_t gc); Find graphics context based on its GContext_t handle. Returns 0; in case gc is not found. TGGC * GetGC(GContext_t gct); returns graphics context based on its GContext_t handle. TGGC * GetGC(GCValues_t* values, Bool_t rw = kFALSE); Get the best matching graphics context depending on values.; If rw is false only a readonly, not modifiable graphics context; is returned. If rw is true a new modifiable graphics context is; returned. Int_t MatchGC(const TGGC* gc, GCValues_t* values); Try to find matching graphics context. On success returns the amount; of matching bits (which may be zero if masks have no common bits),; -1 on failure (when there are common bits but not a single match). void UpdateGC(TGGC* gc, GCValues_t* values); Update graphics context with the values spcified in values->fMask. void Print(Option_t* option = """") const; List all graphics contexts in the pool. TGGC & operator=(const TGGCPool& gp). TGGCPool(const TGGCPool& gp); { }. » Author: Fons Rademakers 20/9/2000 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id: TGGC.h 23115 2008-04-10 13:35:37Z rdm $ » Last generated: 2010-09-23 20:06; This page has been automatically generated. For comments or suggestions rega",MatchSource.WIKI,root/html528/TGGCPool.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGGCPool.html
https://root.cern/root/html528/TGGotoDialog.html:463,Availability,avail,available,463,". TGGotoDialog. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGGotoDialog. class TGGotoDialog: public TGTransientFrame. TGTextEditDialogs. This file defines several dialogs that are used by the TGTextEdit; widget via its associated context popup menu.; The following dialogs are available: TGSearchDialog, TGGotoDialog; and TGPrintDialog. Function Members (Methods); public:. TGGotoDialog(const TGWindow* p = 0, const TGWindow* main = 0, UInt_t w = 1, UInt_t h = 1, Long_t* ret_code = 0, UInt_t options = kVerticalFrame); virtual~TGGotoDialog(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual Bool_tTGMainFrame::BindKey(const TGWindow* w, Int_t keycode, Int_t modifier) const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGTransientFrame::CenterOnParent(Bool_t croot = kTRUE, TGTransientFrame::EPlacement pos = kCenter); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidTGCompositeFrame::ChangeSubframesBackground(Pixel_t back); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTGCompositeFrame::Cleanup(); virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidCloseWindow(); voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare",MatchSource.WIKI,root/html528/TGGotoDialog.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGGotoDialog.html
https://root.cern/root/html528/TGGotoDialog.html:4656,Availability,error,error,4656,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); TList*TGMainFrame::GetBindList() const; static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; voidTGMainFrame::GetClassHints(const char*& className, const char*& resourceName) const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBa",MatchSource.WIKI,root/html528/TGGotoDialog.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGGotoDialog.html
https://root.cern/root/html528/TGGotoDialog.html:4740,Availability,error,error,4740,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); TList*TGMainFrame::GetBindList() const; static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; voidTGMainFrame::GetClassHints(const char*& className, const char*& resourceName) const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UIn",MatchSource.WIKI,root/html528/TGGotoDialog.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGGotoDialog.html
https://root.cern/root/html528/TGGotoDialog.html:18946,Availability,mask,mask,18946,,MatchSource.WIKI,root/html528/TGGotoDialog.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGGotoDialog.html
https://root.cern/root/html528/TGGotoDialog.html:22804,Integrability,message,messages,22804,"WindowNamewindow name; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGGotoDialog(const TGWindow* p = 0, const TGWindow* main = 0, UInt_t w = 1, UInt_t h = 1, Long_t* ret_code = 0, UInt_t options = kVerticalFrame); Create a dialog to GoTo a specific line number. Returns -1 in; ret_code in case no valid line number was given or in case; cancel was pressed. If on input *ret_code is > 0 then this value; will be used as default value. ~TGGotoDialog(); Clean up goto dialog. void CloseWindow(); Close the dialog. On close the dialog will be deleted and cannot be; re-used. Bool_t ProcessMessage(Long_t msg, Long_t parm1, Long_t parm2); Process goto dialog widget messages. » Author: Fons Rademakers 10/7/2000 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id: TGTextEditDialogs.h 25499 2008-09-22 19:54:46Z bellenot $ » Last generated: 2010-09-23 20:06; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html528/TGGotoDialog.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGGotoDialog.html
https://root.cern/root/html528/TGGroupFrame.html:5552,Availability,error,error,5552,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static FontStruct_tGetDefaultFontStruct(); static Pixel_tTGFrame::GetDefaultFrameBackground(); static const TGGC&GetDefaultGC(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionGetDefaultSize() cons",MatchSource.WIKI,root/html528/TGGroupFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGGroupFrame.html
https://root.cern/root/html528/TGGroupFrame.html:5636,Availability,error,error,5636,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static FontStruct_tGetDefaultFontStruct(); static Pixel_tTGFrame::GetDefaultFrameBackground(); static const TGGC&GetDefaultGC(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionGetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame",MatchSource.WIKI,root/html528/TGGroupFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGGroupFrame.html
https://root.cern/root/html528/TGGroupFrame.html:18419,Availability,mask,mask,18419,,MatchSource.WIKI,root/html528/TGGroupFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGGroupFrame.html
https://root.cern/root/html528/TGGroupFrame.html:1361,Testability,log,logically,1361,"rame,; TGMainFrame, TGTransientFrame and TGGroupFrame. The frame classes describe the different ""dressed"" GUI windows. The TGFrame class is a subclasses of TGWindow, and is used as base; class for some simple widgets (buttons, labels, etc.).; It provides:; - position & dimension fields; - an 'options' attribute (see constant above); - a generic event handler; - a generic layout mechanism; - a generic border. The TGCompositeFrame class is the base class for composite widgets; (menu bars, list boxes, etc.).; It provides:; - a layout manager; - a frame container (TList *). The TGVerticalFrame and TGHorizontalFrame are composite frame that; layout their children in vertical or horizontal way. The TGMainFrame class defines top level windows that interact with; the system Window Manager. The TGTransientFrame class defines transient windows that typically; are used for dialogs windows. The TGGroupFrame is a composite frame with a border and a title.; It is typically used to group a number of logically related widgets; visually together. /*. */. Function Members (Methods); public:. TGGroupFrame(const TGWindow* p, TGString* title, UInt_t options = kVerticalFrame, GContext_t norm = GetDefaultGC()(), FontStruct_t font = GetDefaultFontStruct(), Pixel_t back = GetDefaultFrameBackground()); TGGroupFrame(const TGWindow* p = 0, const char* title = 0, UInt_t options = kVerticalFrame, GContext_t norm = GetDefaultGC()(), FontStruct_t font = GetDefaultFontStruct(), Pixel_t back = GetDefaultFrameBackground()); virtual~TGGroupFrame(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::B",MatchSource.WIKI,root/html528/TGGroupFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGGroupFrame.html
https://root.cern/root/html528/TGGroupFrame.html:563,Usability,simpl,simple,563,". TGGroupFrame. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGGroupFrame. class TGGroupFrame: public TGCompositeFrame. TGFrame, TGCompositeFrame, TGVerticalFrame, TGHorizontalFrame,; TGMainFrame, TGTransientFrame and TGGroupFrame. The frame classes describe the different ""dressed"" GUI windows. The TGFrame class is a subclasses of TGWindow, and is used as base; class for some simple widgets (buttons, labels, etc.).; It provides:; - position & dimension fields; - an 'options' attribute (see constant above); - a generic event handler; - a generic layout mechanism; - a generic border. The TGCompositeFrame class is the base class for composite widgets; (menu bars, list boxes, etc.).; It provides:; - a layout manager; - a frame container (TList *). The TGVerticalFrame and TGHorizontalFrame are composite frame that; layout their children in vertical or horizontal way. The TGMainFrame class defines top level windows that interact with; the system Window Manager. The TGTransientFrame class defines transient windows that typically; are used for dialogs windows. The TGGroupFrame is a composite frame with a border and a title.; It is typically used to group a number of logically related widgets; visually together. /*. */. Function Members (Methods); public:. TGGroupFrame(const TGWindow* p, TGString* title, UInt_t options = kVerticalFrame, GContext_t norm = GetDefaultGC()(), FontStruct_t font = GetDefaultFontStruct(), Pixel_t back = GetDefaultFrameBackground()); TGGroupFrame(const TGWindow* p = 0, const char* title = 0, UInt_t options = kVerticalFrame, GContext_t norm = GetDefaultGC()(), FontStruct_t font = GetDefaultFontStruct(), Pixel_t back = GetDefaultFrameBackground()); virtual~TGGroupFrame(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual",MatchSource.WIKI,root/html528/TGGroupFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGGroupFrame.html
https://root.cern/root/html528/TGHButtonGroup.html:2051,Availability,down,down,2051," ways of using a button group:. The button group is a parent widget of a number of buttons,; i.e. the button group is the parent argument in the button; constructor. The buttons are assigned identifiers 1, 2, 3 etc.; in the order they are created or you can specify button id in ; the button constructor. A TGButtonGroup can display a frame and; a title because it inherits from TGGroupFrame. Example:. vertical frame without border and title; TGVButtonGroup *bg = new TGVButtonGroup(main_frame);. create text button with id=1; TGTextButton *button1 = new TGTextButton(bg,""some text"");. create another text button with id=2; TGTextButton *button2 = new TGTextButton(bg,""another text"");. map all buttons; bg->Show();. NOTE: there is no need to call AddFrame() since the buttons are; automatically added with a default layout hint to their parent,; i.e. the buttongroup. To override the default layout hints use the; SetLayoutHints() method. ButtonGroup Signals:. Pressed(Int_t id) --> is emitted when a button in the group is; pressed down. The id argument is the; button's identifier.; Released(Int_t id) --> is emitted when a button in the group is; released. The id argument is the button's; identifier.; Clicked(Int_t id) --> is emitted when a button in the group is; clicked. The id argument is the button's; identifier. The TGHButtonGroup widget organizes TGButton widgets in a group; with one horizontal row. TGHButtonGroup is a convenience class that; offers a thin layer on top of TGButtonGroup. It inherits from; TGButtonGroup. The TGVButtonGroup widget organizes TGButton widgets in a group; with one vertical column. TGVButtonGroup is a convenience class that; offers a thin layer on top of TGButtonGroup. It inherits from; TGButtonGroup. Function Members (Methods); public:. TGHButtonGroup(const TGWindow* parent, const TString& title = """", GContext_t norm = GetDefaultGC()(), FontStruct_t font = GetDefaultFontStruct(), Pixel_t back = GetDefaultFrameBackground()); virtual~TGHButtonGroup",MatchSource.WIKI,root/html528/TGHButtonGroup.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGHButtonGroup.html
https://root.cern/root/html528/TGHButtonGroup.html:6874,Availability,error,error,6874,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGButton*TGButtonGroup::Find(Int_t id) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; virtual TGButton*TGButtonGroup::GetButton(Int_t id) const; TGClient*TGObject::GetClient() const; Int_tTGButtonGroup::GetCount() const; static Int_tTGWindow::GetCounter(); static FontStruct_tTGGroupFrame::GetDefaultFontStruct(); static Pixel_tTGFrame::GetDefaultFrameBackground(); static const TGGC&TGGr",MatchSource.WIKI,root/html528/TGHButtonGroup.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGHButtonGroup.html
https://root.cern/root/html528/TGHButtonGroup.html:6958,Availability,error,error,6958,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGButton*TGButtonGroup::Find(Int_t id) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; virtual TGButton*TGButtonGroup::GetButton(Int_t id) const; TGClient*TGObject::GetClient() const; Int_tTGButtonGroup::GetCount() const; static Int_tTGWindow::GetCounter(); static FontStruct_tTGGroupFrame::GetDefaultFontStruct(); static Pixel_tTGFrame::GetDefaultFrameBackground(); static const TGGC&TGGroupFrame::GetDefaultGC(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; ",MatchSource.WIKI,root/html528/TGHButtonGroup.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGHButtonGroup.html
https://root.cern/root/html528/TGHButtonGroup.html:16245,Availability,down,down,16245,"GGroupFrame::Rename(const char* title)MENU ; virtual voidTGFrame::ReparentWindow(const TGWindow* p, Int_t x = 0, Int_t y = 0); virtual voidTGWindow::RequestFocus(); voidTObject::ResetBit(UInt_t f); virtual voidTGFrame::Resize(TGDimension size); virtual voidTGFrame::Resize(UInt_t w = 0, UInt_t h = 0); virtual voidTGObject::SaveAs(const char* filename = """", Option_t* option = """") const; virtual voidSavePrimitive(ostream& out, Option_t* option = """"); virtual voidTGCompositeFrame::SavePrimitiveSubframes(ostream& out, Option_t* option = """"); voidTGFrame::SaveUserColor(ostream& out, Option_t*); virtual voidTGFrame::SendMessage(const TGWindow* w, Long_t msg, Long_t parm1, Long_t parm2); virtual voidTGFrame::SetBackgroundColor(Pixel_t back); virtual voidTGWindow::SetBackgroundPixmap(Pixmap_t pixmap); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTGButtonGroup::SetBorderDrawn(Bool_t enable = kTRUE); virtual voidTGButtonGroup::SetButton(Int_t id, Bool_t down = kTRUE); virtual voidTGCompositeFrame::SetCleanup(Int_t mode = kLocalCleanup); voidTGFrame::SetDNDSource(Bool_t onoff); voidTGFrame::SetDNDTarget(Bool_t onoff); virtual voidTGFrame::SetDragType(Int_t type); virtual voidTGFrame::SetDrawOption(Option_t* = """"); virtual voidTGFrame::SetDropType(Int_t type); static voidTObject::SetDtorOnly(void* obj); virtual voidTGCompositeFrame::SetEditable(Bool_t on = kTRUE); virtual voidTGCompositeFrame::SetEditDisabled(UInt_t on = 1); virtual voidTGButtonGroup::SetExclusive(Bool_t flag = kTRUE); virtual voidTGFrame::SetForegroundColor(Pixel_t); voidTGFrame::SetFrameElement(TGFrameElement* fe); virtual voidTGFrame::SetHeight(UInt_t h); virtual voidTGCompositeFrame::SetLayoutBroken(Bool_t on = kTRUE); virtual voidTGButtonGroup::SetLayoutHints(TGLayoutHints* l, TGButton* button = 0); virtual voidTGCompositeFrame::SetLayoutManager(TGLayoutManager* l); virtual voidTGCompositeFrame::SetMapSubwindows(Bool_t on); virtual voidTGFrame::SetMaxHeight(UInt_t h);",MatchSource.WIKI,root/html528/TGHButtonGroup.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGHButtonGroup.html
https://root.cern/root/html528/TGHButtonGroup.html:21141,Availability,mask,mask,21141,,MatchSource.WIKI,root/html528/TGHButtonGroup.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGHButtonGroup.html
https://root.cern/root/html528/TGHButtonGroup.html:802,Deployability,toggle,toggle,802,". TGHButtonGroup. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGHButtonGroup. class TGHButtonGroup: public TGButtonGroup. The TGButtonGroup widget organizes TGButton widgets in a group. A button group widget makes it easier to deal with groups of buttons.; A button in a button group is associated with a unique identifier.; The button group emits a Clicked() signal with this identifier when; the button is clicked. Thus, a button group is an ideal solution; when you have several similar buttons and want to connect all their; Clicked() signals, for example, to one slot. An exclusive button group switches off all toggle buttons except; the one that was clicked. A button group is by default non-exclusive.; All radio buttons that are inserted, will be mutually exclusive even; if the button group is non-exclusive. There are two ways of using a button group:. The button group is a parent widget of a number of buttons,; i.e. the button group is the parent argument in the button; constructor. The buttons are assigned identifiers 1, 2, 3 etc.; in the order they are created or you can specify button id in ; the button constructor. A TGButtonGroup can display a frame and; a title because it inherits from TGGroupFrame. Example:. vertical frame without border and title; TGVButtonGroup *bg = new TGVButtonGroup(main_frame);. create text button with id=1; TGTextButton *button1 = new TGTextButton(bg,""some text"");. create another text button with id=2; TGTextButton *button2 = new TGTextButton(bg,""another text"");. map all buttons; bg->Show();. NOTE: there is no need to call AddFrame() since the buttons are; automatically added with a default layout hint to their parent,; i.e. the buttongroup. To override the default layout hints use the; SetLayoutHints() method. ButtonGroup Signals:. Pressed(Int_t id) --> ",MatchSource.WIKI,root/html528/TGHButtonGroup.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGHButtonGroup.html
https://root.cern/root/html528/TGHButtonGroup.html:2168,Deployability,release,released,2168,"parent argument in the button; constructor. The buttons are assigned identifiers 1, 2, 3 etc.; in the order they are created or you can specify button id in ; the button constructor. A TGButtonGroup can display a frame and; a title because it inherits from TGGroupFrame. Example:. vertical frame without border and title; TGVButtonGroup *bg = new TGVButtonGroup(main_frame);. create text button with id=1; TGTextButton *button1 = new TGTextButton(bg,""some text"");. create another text button with id=2; TGTextButton *button2 = new TGTextButton(bg,""another text"");. map all buttons; bg->Show();. NOTE: there is no need to call AddFrame() since the buttons are; automatically added with a default layout hint to their parent,; i.e. the buttongroup. To override the default layout hints use the; SetLayoutHints() method. ButtonGroup Signals:. Pressed(Int_t id) --> is emitted when a button in the group is; pressed down. The id argument is the; button's identifier.; Released(Int_t id) --> is emitted when a button in the group is; released. The id argument is the button's; identifier.; Clicked(Int_t id) --> is emitted when a button in the group is; clicked. The id argument is the button's; identifier. The TGHButtonGroup widget organizes TGButton widgets in a group; with one horizontal row. TGHButtonGroup is a convenience class that; offers a thin layer on top of TGButtonGroup. It inherits from; TGButtonGroup. The TGVButtonGroup widget organizes TGButton widgets in a group; with one vertical column. TGVButtonGroup is a convenience class that; offers a thin layer on top of TGButtonGroup. It inherits from; TGButtonGroup. Function Members (Methods); public:. TGHButtonGroup(const TGWindow* parent, const TString& title = """", GContext_t norm = GetDefaultGC()(), FontStruct_t font = GetDefaultFontStruct(), Pixel_t back = GetDefaultFrameBackground()); virtual~TGHButtonGroup(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidTGCompositeF",MatchSource.WIKI,root/html528/TGHButtonGroup.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGHButtonGroup.html
https://root.cern/root/html528/TGHButtonGroup.html:1382,Modifiability,inherit,inherits,1382,"roup. A button group widget makes it easier to deal with groups of buttons.; A button in a button group is associated with a unique identifier.; The button group emits a Clicked() signal with this identifier when; the button is clicked. Thus, a button group is an ideal solution; when you have several similar buttons and want to connect all their; Clicked() signals, for example, to one slot. An exclusive button group switches off all toggle buttons except; the one that was clicked. A button group is by default non-exclusive.; All radio buttons that are inserted, will be mutually exclusive even; if the button group is non-exclusive. There are two ways of using a button group:. The button group is a parent widget of a number of buttons,; i.e. the button group is the parent argument in the button; constructor. The buttons are assigned identifiers 1, 2, 3 etc.; in the order they are created or you can specify button id in ; the button constructor. A TGButtonGroup can display a frame and; a title because it inherits from TGGroupFrame. Example:. vertical frame without border and title; TGVButtonGroup *bg = new TGVButtonGroup(main_frame);. create text button with id=1; TGTextButton *button1 = new TGTextButton(bg,""some text"");. create another text button with id=2; TGTextButton *button2 = new TGTextButton(bg,""another text"");. map all buttons; bg->Show();. NOTE: there is no need to call AddFrame() since the buttons are; automatically added with a default layout hint to their parent,; i.e. the buttongroup. To override the default layout hints use the; SetLayoutHints() method. ButtonGroup Signals:. Pressed(Int_t id) --> is emitted when a button in the group is; pressed down. The id argument is the; button's identifier.; Released(Int_t id) --> is emitted when a button in the group is; released. The id argument is the button's; identifier.; Clicked(Int_t id) --> is emitted when a button in the group is; clicked. The id argument is the button's; identifier. The TGHButtonGroup widg",MatchSource.WIKI,root/html528/TGHButtonGroup.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGHButtonGroup.html
https://root.cern/root/html528/TGHButtonGroup.html:2524,Modifiability,inherit,inherits,2524,"th id=1; TGTextButton *button1 = new TGTextButton(bg,""some text"");. create another text button with id=2; TGTextButton *button2 = new TGTextButton(bg,""another text"");. map all buttons; bg->Show();. NOTE: there is no need to call AddFrame() since the buttons are; automatically added with a default layout hint to their parent,; i.e. the buttongroup. To override the default layout hints use the; SetLayoutHints() method. ButtonGroup Signals:. Pressed(Int_t id) --> is emitted when a button in the group is; pressed down. The id argument is the; button's identifier.; Released(Int_t id) --> is emitted when a button in the group is; released. The id argument is the button's; identifier.; Clicked(Int_t id) --> is emitted when a button in the group is; clicked. The id argument is the button's; identifier. The TGHButtonGroup widget organizes TGButton widgets in a group; with one horizontal row. TGHButtonGroup is a convenience class that; offers a thin layer on top of TGButtonGroup. It inherits from; TGButtonGroup. The TGVButtonGroup widget organizes TGButton widgets in a group; with one vertical column. TGVButtonGroup is a convenience class that; offers a thin layer on top of TGButtonGroup. It inherits from; TGButtonGroup. Function Members (Methods); public:. TGHButtonGroup(const TGWindow* parent, const TString& title = """", GContext_t norm = GetDefaultGC()(), FontStruct_t font = GetDefaultFontStruct(), Pixel_t back = GetDefaultFrameBackground()); virtual~TGHButtonGroup(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGButtonGroup::ButtonC",MatchSource.WIKI,root/html528/TGHButtonGroup.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGHButtonGroup.html
https://root.cern/root/html528/TGHButtonGroup.html:2737,Modifiability,inherit,inherits,2737,"no need to call AddFrame() since the buttons are; automatically added with a default layout hint to their parent,; i.e. the buttongroup. To override the default layout hints use the; SetLayoutHints() method. ButtonGroup Signals:. Pressed(Int_t id) --> is emitted when a button in the group is; pressed down. The id argument is the; button's identifier.; Released(Int_t id) --> is emitted when a button in the group is; released. The id argument is the button's; identifier.; Clicked(Int_t id) --> is emitted when a button in the group is; clicked. The id argument is the button's; identifier. The TGHButtonGroup widget organizes TGButton widgets in a group; with one horizontal row. TGHButtonGroup is a convenience class that; offers a thin layer on top of TGButtonGroup. It inherits from; TGButtonGroup. The TGVButtonGroup widget organizes TGButton widgets in a group; with one vertical column. TGVButtonGroup is a convenience class that; offers a thin layer on top of TGButtonGroup. It inherits from; TGButtonGroup. Function Members (Methods); public:. TGHButtonGroup(const TGWindow* parent, const TString& title = """", GContext_t norm = GetDefaultGC()(), FontStruct_t font = GetDefaultFontStruct(), Pixel_t back = GetDefaultFrameBackground()); virtual~TGHButtonGroup(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGButtonGroup::ButtonClicked(); virtual voidTGButtonGroup::ButtonPressed(); virtual voidTGButtonGroup::ButtonReleased(); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; v",MatchSource.WIKI,root/html528/TGHButtonGroup.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGHButtonGroup.html
https://root.cern/root/html528/TGHeaderFrame.html:5275,Availability,error,error,5275,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const;",MatchSource.WIKI,root/html528/TGHeaderFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGHeaderFrame.html
https://root.cern/root/html528/TGHeaderFrame.html:5359,Availability,error,error,5359,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType() c",MatchSource.WIKI,root/html528/TGHeaderFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGHeaderFrame.html
https://root.cern/root/html528/TGHeaderFrame.html:17697,Availability,mask,mask,17697,,MatchSource.WIKI,root/html528/TGHeaderFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGHeaderFrame.html
https://root.cern/root/html528/TGHeaderFrame.html:1365,Testability,log,logically,1365,"rame,; TGMainFrame, TGTransientFrame and TGGroupFrame. The frame classes describe the different ""dressed"" GUI windows. The TGFrame class is a subclasses of TGWindow, and is used as base; class for some simple widgets (buttons, labels, etc.).; It provides:; - position & dimension fields; - an 'options' attribute (see constant above); - a generic event handler; - a generic layout mechanism; - a generic border. The TGCompositeFrame class is the base class for composite widgets; (menu bars, list boxes, etc.).; It provides:; - a layout manager; - a frame container (TList *). The TGVerticalFrame and TGHorizontalFrame are composite frame that; layout their children in vertical or horizontal way. The TGMainFrame class defines top level windows that interact with; the system Window Manager. The TGTransientFrame class defines transient windows that typically; are used for dialogs windows. The TGGroupFrame is a composite frame with a border and a title.; It is typically used to group a number of logically related widgets; visually together. /*. */. Function Members (Methods); public:. TGHeaderFrame(const TGWindow* p = 0, UInt_t w = 1, UInt_t h = 1, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); ~TGHeaderFrame(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidTGCompositeFrame::ChangeSubframesBackground(Pixel_t back); static TClass*Class(); vi",MatchSource.WIKI,root/html528/TGHeaderFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGHeaderFrame.html
https://root.cern/root/html528/TGHeaderFrame.html:567,Usability,simpl,simple,567,". TGHeaderFrame. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGHeaderFrame. class TGHeaderFrame: public TGHorizontalFrame. TGFrame, TGCompositeFrame, TGVerticalFrame, TGHorizontalFrame,; TGMainFrame, TGTransientFrame and TGGroupFrame. The frame classes describe the different ""dressed"" GUI windows. The TGFrame class is a subclasses of TGWindow, and is used as base; class for some simple widgets (buttons, labels, etc.).; It provides:; - position & dimension fields; - an 'options' attribute (see constant above); - a generic event handler; - a generic layout mechanism; - a generic border. The TGCompositeFrame class is the base class for composite widgets; (menu bars, list boxes, etc.).; It provides:; - a layout manager; - a frame container (TList *). The TGVerticalFrame and TGHorizontalFrame are composite frame that; layout their children in vertical or horizontal way. The TGMainFrame class defines top level windows that interact with; the system Window Manager. The TGTransientFrame class defines transient windows that typically; are used for dialogs windows. The TGGroupFrame is a composite frame with a border and a title.; It is typically used to group a number of logically related widgets; visually together. /*. */. Function Members (Methods); public:. TGHeaderFrame(const TGWindow* p = 0, UInt_t w = 1, UInt_t h = 1, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); ~TGHeaderFrame(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignal",MatchSource.WIKI,root/html528/TGHeaderFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGHeaderFrame.html
https://root.cern/root/html528/TGHorizontal3DLine.html:4180,Availability,error,error,4180,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGFrame::GetDefaultSize() const; virtual UInt_tTGFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType() const; virtual Option",MatchSource.WIKI,root/html528/TGHorizontal3DLine.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGHorizontal3DLine.html
https://root.cern/root/html528/TGHorizontal3DLine.html:4264,Availability,error,error,4264,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGFrame::GetDefaultSize() const; virtual UInt_tTGFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType() const; virtual Option_t*TObject::GetDrawOption() const; virtual Int_tTGFrame::GetDropType() const; static",MatchSource.WIKI,root/html528/TGHorizontal3DLine.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGHorizontal3DLine.html
https://root.cern/root/html528/TGHorizontal3DLine.html:15191,Availability,mask,mask,15191,"ngleKey; kOverwrite; kWriteDelete; };. protected:. Pixel_tTGFrame::fBackgroundframe background color; Int_tTGFrame::fBorderWidthframe border width; TGClient*TGObject::fClientConnection to display server; Int_tTGFrame::fDNDStateEDNDFlags; UInt_tTGWindow::fEditDisabledflags used for ""guibuilding""; UInt_tTGFrame::fEventMaskcurrenty active event mask; TGFrameElement*TGFrame::fFEpointer to frame element; UInt_tTGFrame::fHeightframe height; Handle_tTGObject::fIdX11/Win32 Window identifier; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; UInt_tTGFrame::fMaxHeightmaximal frame height; UInt_tTGFrame::fMaxWidthmaximal frame width; UInt_tTGFrame::fMinHeightminimal frame height; UInt_tTGFrame::fMinWidthminimal frame width; TStringTGWindow::fNamename of the window used in SavePrimitive(); Bool_tTGWindow::fNeedRedrawkTRUE if window needs to be redrawn; UInt_tTGFrame::fOptionsframe options; const TGWindow*TGWindow::fParentParent window; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; UInt_tTGFrame::fWidthframe width; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Inc",MatchSource.WIKI,root/html528/TGHorizontal3DLine.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGHorizontal3DLine.html
https://root.cern/root/html528/TGHorizontalFrame.html:5294,Availability,error,error,5294,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const;",MatchSource.WIKI,root/html528/TGHorizontalFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGHorizontalFrame.html
https://root.cern/root/html528/TGHorizontalFrame.html:5378,Availability,error,error,5378,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType() c",MatchSource.WIKI,root/html528/TGHorizontalFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGHorizontalFrame.html
https://root.cern/root/html528/TGHorizontalFrame.html:17536,Availability,mask,mask,17536,,MatchSource.WIKI,root/html528/TGHorizontalFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGHorizontalFrame.html
https://root.cern/root/html528/TGHorizontalFrame.html:1376,Testability,log,logically,1376,"rame,; TGMainFrame, TGTransientFrame and TGGroupFrame. The frame classes describe the different ""dressed"" GUI windows. The TGFrame class is a subclasses of TGWindow, and is used as base; class for some simple widgets (buttons, labels, etc.).; It provides:; - position & dimension fields; - an 'options' attribute (see constant above); - a generic event handler; - a generic layout mechanism; - a generic border. The TGCompositeFrame class is the base class for composite widgets; (menu bars, list boxes, etc.).; It provides:; - a layout manager; - a frame container (TList *). The TGVerticalFrame and TGHorizontalFrame are composite frame that; layout their children in vertical or horizontal way. The TGMainFrame class defines top level windows that interact with; the system Window Manager. The TGTransientFrame class defines transient windows that typically; are used for dialogs windows. The TGGroupFrame is a composite frame with a border and a title.; It is typically used to group a number of logically related widgets; visually together. /*. */. Function Members (Methods); public:. TGHorizontalFrame(const TGWindow* p = 0, UInt_t w = 1, UInt_t h = 1, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); ~TGHorizontalFrame(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidTGCompositeFrame::ChangeSubframesBackground(Pixel_t back); static TClass*Cla",MatchSource.WIKI,root/html528/TGHorizontalFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGHorizontalFrame.html
https://root.cern/root/html528/TGHorizontalFrame.html:578,Usability,simpl,simple,578,". TGHorizontalFrame. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGHorizontalFrame. class TGHorizontalFrame: public TGCompositeFrame. TGFrame, TGCompositeFrame, TGVerticalFrame, TGHorizontalFrame,; TGMainFrame, TGTransientFrame and TGGroupFrame. The frame classes describe the different ""dressed"" GUI windows. The TGFrame class is a subclasses of TGWindow, and is used as base; class for some simple widgets (buttons, labels, etc.).; It provides:; - position & dimension fields; - an 'options' attribute (see constant above); - a generic event handler; - a generic layout mechanism; - a generic border. The TGCompositeFrame class is the base class for composite widgets; (menu bars, list boxes, etc.).; It provides:; - a layout manager; - a frame container (TList *). The TGVerticalFrame and TGHorizontalFrame are composite frame that; layout their children in vertical or horizontal way. The TGMainFrame class defines top level windows that interact with; the system Window Manager. The TGTransientFrame class defines transient windows that typically; are used for dialogs windows. The TGGroupFrame is a composite frame with a border and a title.; It is typically used to group a number of logically related widgets; visually together. /*. */. Function Members (Methods); public:. TGHorizontalFrame(const TGWindow* p = 0, UInt_t w = 1, UInt_t h = 1, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); ~TGHorizontalFrame(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObj",MatchSource.WIKI,root/html528/TGHorizontalFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGHorizontalFrame.html
https://root.cern/root/html528/TGHorizontalLayout.html:804,Availability,down,downward,804,". TGHorizontalLayout. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGHorizontalLayout. class TGHorizontalLayout: public TGVerticalLayout. A number of different layout classes (TGLayoutManager,; TGVerticalLayout, TGHorizontalLayout, TGLayoutHints, etc.). Concerning the TGMatrixLayout class:. It arranges frames in a matrix-like way.; This manager provides :; - a column number (0 means unlimited); - a row number (0 means unlimited); - horizontal & vertical separators. Notes : If both column and row are fixed values, any remaining; frames outside the count won't be managed.; Unlimited rows means the frame can expand downward; (the default behaviour in most UI).; Both unlimited rows and columns is undefined (read: will; crash the algorithm ;-).; With fixed dimensions, frames are always arranged in rows.; That is: 1st frame is at position (0,0), next one is at; row(0), column(1) and so on...; When specifying one dimension as unlimited (i.e. row=0 or; column=0) the frames are arranged according to the direction; of the fixed dimension. This layout manager does not make; use of TGLayoutHints. Function Members (Methods); public:. TGHorizontalLayout(TGCompositeFrame* main); TGHorizontalLayout(const TGHorizontalLayout&); ~TGHorizontalLayout(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual",MatchSource.WIKI,root/html528/TGHorizontalLayout.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGHorizontalLayout.html
https://root.cern/root/html528/TGHorizontalLayout.html:2349,Availability,error,error,2349,"eFrame* main); TGHorizontalLayout(const TGHorizontalLayout&); ~TGHorizontalLayout(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TGDimensionGetDefaultSize() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObje",MatchSource.WIKI,root/html528/TGHorizontalLayout.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGHorizontalLayout.html
https://root.cern/root/html528/TGHorizontalLayout.html:2433,Availability,error,error,2433," voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TGDimensionGetDefaultSize() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(c",MatchSource.WIKI,root/html528/TGHorizontalLayout.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGHorizontalLayout.html
https://root.cern/root/html528/TGHotString.html:328,Integrability,wrap,wraps,328,". TGHotString. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGHotString. class TGHotString: public TGString. TGString and TGHotString. TGString wraps a TString and adds some graphics routines like; drawing, size of string on screen depending on font, etc.; TGHotString is a string with a ""hot"" character unerlined. Function Members (Methods); public:. TGHotString(const char* s); TGHotString(const TGHotString&); ~TGHotString(); TString&TString::Append(const char* cs); TString&TString::Append(const TString& s); TString&TString::Append(const char* cs, Ssiz_t n); TString&TString::Append(const TString& s, Ssiz_t n); TString&TString::Append(char c, Ssiz_t rep = 1); Double_tTString::Atof() const; Int_tTString::Atoi() const; Long64_tTString::Atoll() const; Bool_tTString::BeginsWith(const char* s, TString::ECaseCompare cmp = kExact) const; Bool_tTString::BeginsWith(const TString& pat, TString::ECaseCompare cmp = kExact) const; Ssiz_tTString::Capacity() const; Ssiz_tTString::Capacity(Ssiz_t n); TString&TString::Chop(); static TClass*Class(); voidTString::Clear(); intTString::CompareTo(const char* cs, TString::ECaseCompare cmp = kExact) const; intTString::CompareTo(const TString& st, TString::ECaseCompare cmp = kExact) const; Bool_tTString::Contains(const TRegexp& pat) const; Bool_tTString::Contains(TPRegexp& pat) const; Bool_tTString::Contains(const char* s, TString::ECaseCompare cmp = kExact) const; Bool_tTString::Contains(const TString& pat, TString::ECaseCompare cmp = kExact) const; TStringTString::Copy() const; Int_tTString::CountChar(Int_t c) const; const char*TString::Data() const; virtual voidDraw(Drawable_t id, GContext_t gc, Int_t x, Int_t y); virtual voidDrawWrapped(Drawable_t id, GContext_t gc, Int_t x, Int_t y, UInt_t w, FontStruct_t font); Bool_tTString::EndsWith(const char* pat, TStri",MatchSource.WIKI,root/html528/TGHotString.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGHotString.html
https://root.cern/root/html528/TGHotString.html:367,Integrability,rout,routines,367,". TGHotString. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGHotString. class TGHotString: public TGString. TGString and TGHotString. TGString wraps a TString and adds some graphics routines like; drawing, size of string on screen depending on font, etc.; TGHotString is a string with a ""hot"" character unerlined. Function Members (Methods); public:. TGHotString(const char* s); TGHotString(const TGHotString&); ~TGHotString(); TString&TString::Append(const char* cs); TString&TString::Append(const TString& s); TString&TString::Append(const char* cs, Ssiz_t n); TString&TString::Append(const TString& s, Ssiz_t n); TString&TString::Append(char c, Ssiz_t rep = 1); Double_tTString::Atof() const; Int_tTString::Atoi() const; Long64_tTString::Atoll() const; Bool_tTString::BeginsWith(const char* s, TString::ECaseCompare cmp = kExact) const; Bool_tTString::BeginsWith(const TString& pat, TString::ECaseCompare cmp = kExact) const; Ssiz_tTString::Capacity() const; Ssiz_tTString::Capacity(Ssiz_t n); TString&TString::Chop(); static TClass*Class(); voidTString::Clear(); intTString::CompareTo(const char* cs, TString::ECaseCompare cmp = kExact) const; intTString::CompareTo(const TString& st, TString::ECaseCompare cmp = kExact) const; Bool_tTString::Contains(const TRegexp& pat) const; Bool_tTString::Contains(TPRegexp& pat) const; Bool_tTString::Contains(const char* s, TString::ECaseCompare cmp = kExact) const; Bool_tTString::Contains(const TString& pat, TString::ECaseCompare cmp = kExact) const; TStringTString::Copy() const; Int_tTString::CountChar(Int_t c) const; const char*TString::Data() const; virtual voidDraw(Drawable_t id, GContext_t gc, Int_t x, Int_t y); virtual voidDrawWrapped(Drawable_t id, GContext_t gc, Int_t x, Int_t y, UInt_t w, FontStruct_t font); Bool_tTString::EndsWith(const char* pat, TStri",MatchSource.WIKI,root/html528/TGHotString.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGHotString.html
https://root.cern/root/html528/TGHotString.html:416,Integrability,depend,depending,416,". TGHotString. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGHotString. class TGHotString: public TGString. TGString and TGHotString. TGString wraps a TString and adds some graphics routines like; drawing, size of string on screen depending on font, etc.; TGHotString is a string with a ""hot"" character unerlined. Function Members (Methods); public:. TGHotString(const char* s); TGHotString(const TGHotString&); ~TGHotString(); TString&TString::Append(const char* cs); TString&TString::Append(const TString& s); TString&TString::Append(const char* cs, Ssiz_t n); TString&TString::Append(const TString& s, Ssiz_t n); TString&TString::Append(char c, Ssiz_t rep = 1); Double_tTString::Atof() const; Int_tTString::Atoi() const; Long64_tTString::Atoll() const; Bool_tTString::BeginsWith(const char* s, TString::ECaseCompare cmp = kExact) const; Bool_tTString::BeginsWith(const TString& pat, TString::ECaseCompare cmp = kExact) const; Ssiz_tTString::Capacity() const; Ssiz_tTString::Capacity(Ssiz_t n); TString&TString::Chop(); static TClass*Class(); voidTString::Clear(); intTString::CompareTo(const char* cs, TString::ECaseCompare cmp = kExact) const; intTString::CompareTo(const TString& st, TString::ECaseCompare cmp = kExact) const; Bool_tTString::Contains(const TRegexp& pat) const; Bool_tTString::Contains(TPRegexp& pat) const; Bool_tTString::Contains(const char* s, TString::ECaseCompare cmp = kExact) const; Bool_tTString::Contains(const TString& pat, TString::ECaseCompare cmp = kExact) const; TStringTString::Copy() const; Int_tTString::CountChar(Int_t c) const; const char*TString::Data() const; virtual voidDraw(Drawable_t id, GContext_t gc, Int_t x, Int_t y); virtual voidDrawWrapped(Drawable_t id, GContext_t gc, Int_t x, Int_t y, UInt_t w, FontStruct_t font); Bool_tTString::EndsWith(const char* pat, TStri",MatchSource.WIKI,root/html528/TGHotString.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGHotString.html
https://root.cern/root/html528/TGHotString.html:8526,Integrability,wrap,wrap,8526,"e(const TString& delim) const; Bool_tTString::Tokenize(TString& tok, Ssiz_t& from, const char* delim = "" "") const; voidTString::ToLower(); voidTString::ToUpper(); static voidTString::WriteString(TBuffer& b, const TString* a). protected:. static Ssiz_tTString::AdjustCapacity(Ssiz_t nc); voidTString::AssertElement(Ssiz_t nc) const; voidTString::Clobber(Ssiz_t nc); voidTString::Cow(); voidTString::Cow(Ssiz_t nc); voidDrawHotChar(Drawable_t id, GContext_t gc, Int_t x, Int_t y); voidTString::InitChar(char c); TStringRef*TString::Pref() const. Data Members; public:. enum TString::EStripType { kLeading; kTrailing; kBoth; };; enum TString::ECaseCompare { kExact; kIgnoreCase; };. protected:. char*TString::fDataref. counted data (TStringRef is in front); charfHotCharhot character; Int_tfHotPosposition of hot character; GContext_tfLastGCcontext used during last drawing; Int_tfOff1variable used during drawing (cache); Int_tfOff2variable used during drawing (cache). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGHotString(const char* s); Create a hot string. void Draw(Drawable_t id, GContext_t gc, Int_t x, Int_t y); Draw a hot string and underline the hot character. void DrawWrapped(Drawable_t id, GContext_t gc, Int_t x, Int_t y, UInt_t w, FontStruct_t font); Draw a hot string in a column with width w. If string is longer than; w wrap it to next line. void DrawHotChar(Drawable_t id, GContext_t gc, Int_t x, Int_t y); Draw the underline under the hot character. TGHotString(const char* s). Int_t GetHotChar() const; { return fHotChar; }. Int_t GetHotPos() const; { return fHotPos; }. » Author: Fons Rademakers 05/01/98 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id: TGString.h 23115 2008-04-10 13:35:37Z rdm $ » Last generated: 2010-09-23 20:06; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html528/TGHotString.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGHotString.html
https://root.cern/root/html528/TGHotString.html:8053,Performance,cache,cache,8053,"ing, char c = ' ') const; TSubStringTString::SubString(const char* pat, Ssiz_t start = 0, TString::ECaseCompare cmp = kExact) const; TObjArray*TString::Tokenize(const TString& delim) const; Bool_tTString::Tokenize(TString& tok, Ssiz_t& from, const char* delim = "" "") const; voidTString::ToLower(); voidTString::ToUpper(); static voidTString::WriteString(TBuffer& b, const TString* a). protected:. static Ssiz_tTString::AdjustCapacity(Ssiz_t nc); voidTString::AssertElement(Ssiz_t nc) const; voidTString::Clobber(Ssiz_t nc); voidTString::Cow(); voidTString::Cow(Ssiz_t nc); voidDrawHotChar(Drawable_t id, GContext_t gc, Int_t x, Int_t y); voidTString::InitChar(char c); TStringRef*TString::Pref() const. Data Members; public:. enum TString::EStripType { kLeading; kTrailing; kBoth; };; enum TString::ECaseCompare { kExact; kIgnoreCase; };. protected:. char*TString::fDataref. counted data (TStringRef is in front); charfHotCharhot character; Int_tfHotPosposition of hot character; GContext_tfLastGCcontext used during last drawing; Int_tfOff1variable used during drawing (cache); Int_tfOff2variable used during drawing (cache). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGHotString(const char* s); Create a hot string. void Draw(Drawable_t id, GContext_t gc, Int_t x, Int_t y); Draw a hot string and underline the hot character. void DrawWrapped(Drawable_t id, GContext_t gc, Int_t x, Int_t y, UInt_t w, FontStruct_t font); Draw a hot string in a column with width w. If string is longer than; w wrap it to next line. void DrawHotChar(Drawable_t id, GContext_t gc, Int_t x, Int_t y); Draw the underline under the hot character. TGHotString(const char* s). Int_t GetHotChar() const; { return fHotChar; }. Int_t GetHotPos() const; { return fHotPos; }. » Author: Fons Rademakers 05/01/98 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id: TGString.h 23115 2008-04-10 13:35:37Z rdm $ » Last generated: 2010-09-23 20:",MatchSource.WIKI,root/html528/TGHotString.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGHotString.html
https://root.cern/root/html528/TGHotString.html:8101,Performance,cache,cache,8101,"ing, char c = ' ') const; TSubStringTString::SubString(const char* pat, Ssiz_t start = 0, TString::ECaseCompare cmp = kExact) const; TObjArray*TString::Tokenize(const TString& delim) const; Bool_tTString::Tokenize(TString& tok, Ssiz_t& from, const char* delim = "" "") const; voidTString::ToLower(); voidTString::ToUpper(); static voidTString::WriteString(TBuffer& b, const TString* a). protected:. static Ssiz_tTString::AdjustCapacity(Ssiz_t nc); voidTString::AssertElement(Ssiz_t nc) const; voidTString::Clobber(Ssiz_t nc); voidTString::Cow(); voidTString::Cow(Ssiz_t nc); voidDrawHotChar(Drawable_t id, GContext_t gc, Int_t x, Int_t y); voidTString::InitChar(char c); TStringRef*TString::Pref() const. Data Members; public:. enum TString::EStripType { kLeading; kTrailing; kBoth; };; enum TString::ECaseCompare { kExact; kIgnoreCase; };. protected:. char*TString::fDataref. counted data (TStringRef is in front); charfHotCharhot character; Int_tfHotPosposition of hot character; GContext_tfLastGCcontext used during last drawing; Int_tfOff1variable used during drawing (cache); Int_tfOff2variable used during drawing (cache). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGHotString(const char* s); Create a hot string. void Draw(Drawable_t id, GContext_t gc, Int_t x, Int_t y); Draw a hot string and underline the hot character. void DrawWrapped(Drawable_t id, GContext_t gc, Int_t x, Int_t y, UInt_t w, FontStruct_t font); Draw a hot string in a column with width w. If string is longer than; w wrap it to next line. void DrawHotChar(Drawable_t id, GContext_t gc, Int_t x, Int_t y); Draw the underline under the hot character. TGHotString(const char* s). Int_t GetHotChar() const; { return fHotChar; }. Int_t GetHotPos() const; { return fHotPos; }. » Author: Fons Rademakers 05/01/98 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id: TGString.h 23115 2008-04-10 13:35:37Z rdm $ » Last generated: 2010-09-23 20:",MatchSource.WIKI,root/html528/TGHotString.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGHotString.html
https://root.cern/root/html528/TGHProgressBar.html:4549,Availability,error,error,4549," signal, void* receiver = 0, const char* slot = 0); virtual voidTQObject::Disconnected(const char*); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTGFrame::DrawBorder(); virtual voidTGFrame::DrawClass() const; virtual TObject*TGFrame::DrawClone(Option_t* = """") const; virtual voidTGFrame::DrawCopy(Handle_t, Int_t, Int_t); virtual voidTGFrame::Dump() const; voidTQObject::Emit(const char* signal); voidTQObject::Emit(const char* signal, Long_t* paramArr); voidTQObject::Emit(const char* signal, const char* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidTGProgressBar::Format(const char* format = ""%.",MatchSource.WIKI,root/html528/TGHProgressBar.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGHProgressBar.html
https://root.cern/root/html528/TGHProgressBar.html:4633,Availability,error,error,4633," signal, void* receiver = 0, const char* slot = 0); virtual voidTQObject::Disconnected(const char*); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTGFrame::DrawBorder(); virtual voidTGFrame::DrawClass() const; virtual TObject*TGFrame::DrawClone(Option_t* = """") const; virtual voidTGFrame::DrawCopy(Handle_t, Int_t, Int_t); virtual voidTGFrame::Dump() const; voidTQObject::Emit(const char* signal); voidTQObject::Emit(const char* signal, Long_t* paramArr); voidTQObject::Emit(const char* signal, const char* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidTGProgressBar::Format(const char* format = ""%.",MatchSource.WIKI,root/html528/TGHProgressBar.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGHProgressBar.html
https://root.cern/root/html528/TGHProgressBar.html:17565,Availability,mask,mask,17565,,MatchSource.WIKI,root/html528/TGHProgressBar.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGHProgressBar.html
https://root.cern/root/html528/TGHProgressBar.html:392,Usability,progress bar,progress bars,392,". TGHProgressBar. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGHProgressBar. class TGHProgressBar: public TGProgressBar. TGProgressBar, TGHProgressBar and TGVProgressBar. The classes in this file implement progress bars. Progress bars can; be used to show progress of tasks taking more then a few seconds.; TGProgressBar is an abstract base class, use either TGHProgressBar; or TGVProgressBar. TGHProgressBar can in addition show the position; as text in the bar. Function Members (Methods); public:. TGHProgressBar(const TGWindow* p, TGProgressBar::EBarType type, UInt_t w); TGHProgressBar(const TGWindow* p = 0, UInt_t w = 4, UInt_t h = kProgressBarTextWidth, Pixel_t back = GetWhitePixel(), Pixel_t barcolor = GetDefaultSelectedBackground(), GContext_t norm = GetDefaultGC()(), FontStruct_t font = GetDefaultFontStruct(), UInt_t options = kDoubleBorder|kSunkenFrame); virtual~TGHProgressBar(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGFrame::ChangeOptions(UInt_t options); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, c",MatchSource.WIKI,root/html528/TGHProgressBar.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGHProgressBar.html
https://root.cern/root/html528/TGHProgressBar.html:18897,Usability,progress bar,progress bar,18897,"on not in percent; UInt_tTGFrame::fHeightframe height; Handle_tTGObject::fIdX11/Win32 Window identifier; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Float_tTGProgressBar::fMaxlogical maximum value (default 100); UInt_tTGFrame::fMaxHeightmaximal frame height; UInt_tTGFrame::fMaxWidthmaximal frame width; Float_tTGProgressBar::fMinlogical minimum value (default 0); UInt_tTGFrame::fMinHeightminimal frame height; UInt_tTGFrame::fMinWidthminimal frame width; TStringTGWindow::fNamename of the window used in SavePrimitive(); Bool_tTGWindow::fNeedRedrawkTRUE if window needs to be redrawn; GContext_tTGProgressBar::fNormGCtext drawing graphics context; UInt_tTGFrame::fOptionsframe options; const TGWindow*TGWindow::fParentParent window; Bool_tTGProgressBar::fPercentshow position in percent (default true); Float_tTGProgressBar::fPoslogical position [fMin,fMax]; Int_tTGProgressBar::fPosPixposition of progress bar in pixel coordinates; Bool_tTGProgressBar::fShowPosshow position value (default false); Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; UInt_tTGFrame::fWidthframe width; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static const TGFont*TGProgressBar::fgDefaultFont; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGGC*TGProgressBar::fgDefaultGC; static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; s",MatchSource.WIKI,root/html528/TGHProgressBar.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGHProgressBar.html
https://root.cern/root/html528/TGHProgressBar.html:20410,Usability,progress bar,progress bar,20410,"atic const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static const TGFont*TGProgressBar::fgDefaultFont; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGGC*TGProgressBar::fgDefaultGC; static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGHProgressBar(const TGWindow* p = 0, UInt_t w = 4, UInt_t h = kProgressBarTextWidth, Pixel_t back = GetWhitePixel(), Pixel_t barcolor = GetDefaultSelectedBackground(), GContext_t norm = GetDefaultGC()(), FontStruct_t font = GetDefaultFontStruct(), UInt_t options = kDoubleBorder|kSunkenFrame); Horizontal progress bar constructor. TGHProgressBar(const TGWindow* p, TGProgressBar::EBarType type, UInt_t w); Simple constructor allow you to create either a standard progress; bar, or a more fancy progress bar (fancy means: double sized border,; white background and a bit wider to allow for text to be printed; in the bar. void ShowPosition(Bool_t set = kTRUE, Bool_t percent = kTRUE, const char* format = ""%.2f""); Show postion text, either in percent or formatted according format. void DoRedraw(); Draw horizontal progress bar. void SavePrimitive(ostream& out, Option_t* option = """"); Save a horizontal progress bar as a C++ statement(s) on output stream out. virtual ~TGHProgressBar(); { }. TGDimension GetDefaultSize() const; { return TGDimension(fWidth, fBarWidth); }. » Author: Fons Rademakers 10/10/2000 » Copyright (C) 1995-2000, Rene Brun and Fo",MatchSource.WIKI,root/html528/TGHProgressBar.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGHProgressBar.html
https://root.cern/root/html528/TGHProgressBar.html:20599,Usability,progress bar,progress bar,20599,"TGFont*TGProgressBar::fgDefaultFont; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGGC*TGProgressBar::fgDefaultGC; static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGHProgressBar(const TGWindow* p = 0, UInt_t w = 4, UInt_t h = kProgressBarTextWidth, Pixel_t back = GetWhitePixel(), Pixel_t barcolor = GetDefaultSelectedBackground(), GContext_t norm = GetDefaultGC()(), FontStruct_t font = GetDefaultFontStruct(), UInt_t options = kDoubleBorder|kSunkenFrame); Horizontal progress bar constructor. TGHProgressBar(const TGWindow* p, TGProgressBar::EBarType type, UInt_t w); Simple constructor allow you to create either a standard progress; bar, or a more fancy progress bar (fancy means: double sized border,; white background and a bit wider to allow for text to be printed; in the bar. void ShowPosition(Bool_t set = kTRUE, Bool_t percent = kTRUE, const char* format = ""%.2f""); Show postion text, either in percent or formatted according format. void DoRedraw(); Draw horizontal progress bar. void SavePrimitive(ostream& out, Option_t* option = """"); Save a horizontal progress bar as a C++ statement(s) on output stream out. virtual ~TGHProgressBar(); { }. TGDimension GetDefaultSize() const; { return TGDimension(fWidth, fBarWidth); }. » Author: Fons Rademakers 10/10/2000 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id: TGProgressBar.h 23115 2008-04-10 13:35:37Z rdm $ » Last generated: 2010-09-23 20:06; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html528/TGHProgressBar.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGHProgressBar.html
https://root.cern/root/html528/TGHProgressBar.html:20919,Usability,progress bar,progress bar,20919,"TGFont*TGProgressBar::fgDefaultFont; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGGC*TGProgressBar::fgDefaultGC; static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGHProgressBar(const TGWindow* p = 0, UInt_t w = 4, UInt_t h = kProgressBarTextWidth, Pixel_t back = GetWhitePixel(), Pixel_t barcolor = GetDefaultSelectedBackground(), GContext_t norm = GetDefaultGC()(), FontStruct_t font = GetDefaultFontStruct(), UInt_t options = kDoubleBorder|kSunkenFrame); Horizontal progress bar constructor. TGHProgressBar(const TGWindow* p, TGProgressBar::EBarType type, UInt_t w); Simple constructor allow you to create either a standard progress; bar, or a more fancy progress bar (fancy means: double sized border,; white background and a bit wider to allow for text to be printed; in the bar. void ShowPosition(Bool_t set = kTRUE, Bool_t percent = kTRUE, const char* format = ""%.2f""); Show postion text, either in percent or formatted according format. void DoRedraw(); Draw horizontal progress bar. void SavePrimitive(ostream& out, Option_t* option = """"); Save a horizontal progress bar as a C++ statement(s) on output stream out. virtual ~TGHProgressBar(); { }. TGDimension GetDefaultSize() const; { return TGDimension(fWidth, fBarWidth); }. » Author: Fons Rademakers 10/10/2000 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id: TGProgressBar.h 23115 2008-04-10 13:35:37Z rdm $ » Last generated: 2010-09-23 20:06; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html528/TGHProgressBar.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGHProgressBar.html
https://root.cern/root/html528/TGHProgressBar.html:21008,Usability,progress bar,progress bar,21008,"TGFont*TGProgressBar::fgDefaultFont; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGGC*TGProgressBar::fgDefaultGC; static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGHProgressBar(const TGWindow* p = 0, UInt_t w = 4, UInt_t h = kProgressBarTextWidth, Pixel_t back = GetWhitePixel(), Pixel_t barcolor = GetDefaultSelectedBackground(), GContext_t norm = GetDefaultGC()(), FontStruct_t font = GetDefaultFontStruct(), UInt_t options = kDoubleBorder|kSunkenFrame); Horizontal progress bar constructor. TGHProgressBar(const TGWindow* p, TGProgressBar::EBarType type, UInt_t w); Simple constructor allow you to create either a standard progress; bar, or a more fancy progress bar (fancy means: double sized border,; white background and a bit wider to allow for text to be printed; in the bar. void ShowPosition(Bool_t set = kTRUE, Bool_t percent = kTRUE, const char* format = ""%.2f""); Show postion text, either in percent or formatted according format. void DoRedraw(); Draw horizontal progress bar. void SavePrimitive(ostream& out, Option_t* option = """"); Save a horizontal progress bar as a C++ statement(s) on output stream out. virtual ~TGHProgressBar(); { }. TGDimension GetDefaultSize() const; { return TGDimension(fWidth, fBarWidth); }. » Author: Fons Rademakers 10/10/2000 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id: TGProgressBar.h 23115 2008-04-10 13:35:37Z rdm $ » Last generated: 2010-09-23 20:06; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html528/TGHProgressBar.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGHProgressBar.html
https://root.cern/root/html528/TGHScrollBar.html:4620,Availability,error,error,4620,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static Pixmap_tTGScrollBar::GetBckgndPixmap(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; const char*TGWidget::GetCommand() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionGetDefaultSize() const; virtual UInt_tTGFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame",MatchSource.WIKI,root/html528/TGHScrollBar.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGHScrollBar.html
https://root.cern/root/html528/TGHScrollBar.html:4704,Availability,error,error,4704,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static Pixmap_tTGScrollBar::GetBckgndPixmap(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; const char*TGWidget::GetCommand() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionGetDefaultSize() const; virtual UInt_tTGFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType() const; virtual Option_t*TO",MatchSource.WIKI,root/html528/TGHScrollBar.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGHScrollBar.html
https://root.cern/root/html528/TGHScrollBar.html:17022,Availability,mask,mask,17022,,MatchSource.WIKI,root/html528/TGHScrollBar.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGHScrollBar.html
https://root.cern/root/html528/TGHScrollBar.html:18675,Availability,down,down,18675,width; const TGWindow*TGWidget::fMsgWindowwindow which handles widget events; TStringTGWindow::fNamename of the window used in SavePrimitive(); Bool_tTGWindow::fNeedRedrawkTRUE if window needs to be redrawn; UInt_tTGFrame::fOptionsframe options; const TGWindow*TGWindow::fParentParent window; Int_tTGScrollBar::fPoslogical current position; Int_tTGScrollBar::fPsizelogical page size of scrollbar; Int_tTGScrollBar::fRangelogical upper range of scrollbar; TTimer*TGScrollBar::fRepeatrepeat rate timer (when mouse stays pressed); Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; TGScrollBarElement*TGScrollBar::fSliderslider; Int_tTGScrollBar::fSliderRangelogical slider range; Int_tTGScrollBar::fSliderSizelogical slider size; Int_tTGScrollBar::fSmallIncSmall Increment in the sliding algorithm; Window_tTGScrollBar::fSubwsub window in which mouse is pressed; TGScrollBarElement*TGScrollBar::fTailtail button of scrollbar; const TGPicture*TGScrollBar::fTailPicpicture in tail (down or right arrow); Int_tTGWidget::fWidgetFlagswidget status flags (OR of EWidgetStatus); Int_tTGWidget::fWidgetIdthe widget id (used for event processing); UInt_tTGFrame::fWidthframe width; Int_tTGFrame::fXframe x position; Int_tTGScrollBar::fX0; Int_tTGScrollBar::fXp; Int_tTGFrame::fYframe y position; Int_tTGScrollBar::fY0current slider position in pixels; Int_tTGScrollBar::fYpprevious slider position in pixels; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static Pixmap_tTGScrollBar::fgBckgndPixmap; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static ,MatchSource.WIKI,root/html528/TGHScrollBar.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGHScrollBar.html
https://root.cern/root/html528/TGHScrollBar.html:652,Integrability,message,messages,652,". TGHScrollBar. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGHScrollBar. class TGHScrollBar: public TGScrollBar. TGScrollBar and TGScrollBarElement. The classes in this file implement scrollbars. Scrollbars can be; either placed horizontal or vertical. A scrollbar contains three; TGScrollBarElements: The ""head"", ""tail"" and ""slider"". The head and; tail are fixed at either end and have the typical arrows in them. The TGHScrollBar will generate the following event messages:; kC_HSCROLL, kSB_SLIDERPOS, position, 0; kC_HSCROLL, kSB_SLIDERTRACK, position, 0. The TGVScrollBar will generate the following event messages:; kC_VSCROLL, kSB_SLIDERPOS, position, 0; kC_VSCROLL, kSB_SLIDERTRACK, position, 0. Function Members (Methods); public:. TGHScrollBar(const TGWindow* p = 0, UInt_t w = 4, UInt_t h = 2, UInt_t options = kHorizontalFrame, Pixel_t back = GetDefaultFrameBackground()); virtual~TGHScrollBar(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual voidTGWidget::Associate(const TGWindow* w); static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGScrollBar::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGFrame::ChangeOptions(UInt_t options); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const",MatchSource.WIKI,root/html528/TGHScrollBar.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGHScrollBar.html
https://root.cern/root/html528/TGHScrollBar.html:796,Integrability,message,messages,796,". TGHScrollBar. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGHScrollBar. class TGHScrollBar: public TGScrollBar. TGScrollBar and TGScrollBarElement. The classes in this file implement scrollbars. Scrollbars can be; either placed horizontal or vertical. A scrollbar contains three; TGScrollBarElements: The ""head"", ""tail"" and ""slider"". The head and; tail are fixed at either end and have the typical arrows in them. The TGHScrollBar will generate the following event messages:; kC_HSCROLL, kSB_SLIDERPOS, position, 0; kC_HSCROLL, kSB_SLIDERTRACK, position, 0. The TGVScrollBar will generate the following event messages:; kC_VSCROLL, kSB_SLIDERPOS, position, 0; kC_VSCROLL, kSB_SLIDERTRACK, position, 0. Function Members (Methods); public:. TGHScrollBar(const TGWindow* p = 0, UInt_t w = 4, UInt_t h = 2, UInt_t options = kHorizontalFrame, Pixel_t back = GetDefaultFrameBackground()); virtual~TGHScrollBar(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual voidTGWidget::Associate(const TGWindow* w); static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGScrollBar::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGFrame::ChangeOptions(UInt_t options); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const",MatchSource.WIKI,root/html528/TGHScrollBar.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGHScrollBar.html
https://root.cern/root/html528/TGHScrollBar.html:20565,Testability,log,logical,20565,"map_tTGScrollBar::fgBckgndPixmap; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static Int_tTGScrollBar::fgScrollBarWidth; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGHScrollBar(const TGWindow* p = 0, UInt_t w = 4, UInt_t h = 2, UInt_t options = kHorizontalFrame, Pixel_t back = GetDefaultFrameBackground()); Create a horizontal scrollbar widget. void Layout(); Layout and move horizontal scrollbar components. Bool_t HandleButton(Event_t* event); Handle a mouse button event in a horizontal scrolbar. Bool_t HandleMotion(Event_t* event); Handle mouse motion event in a horizontal scrollbar. void SetRange(Int_t range, Int_t page_size); Set range of horizontal scrollbar. void SetPosition(Int_t pos); Set logical slider position of horizontal scrollbar. void SavePrimitive(ostream& out, Option_t* option = """"); Save an horizontal scrollbar as a C++ statement(s) on output stream out. virtual ~TGHScrollBar(); { }. TGDimension GetDefaultSize() const; { return TGDimension(fWidth, GetScrollBarWidth()); }. » Author: Fons Rademakers 10/01/98 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id: TGScrollBar.h 23115 2008-04-10 13:35:37Z rdm $ » Last generated: 2010-09-23 20:06; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html528/TGHScrollBar.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGHScrollBar.html
https://root.cern/root/html528/TGHSlider.html:4921,Availability,error,error,4921,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; const char*TGWidget::GetCommand() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionGetDefaultSize() const; virtual UInt_tTGFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::Get",MatchSource.WIKI,root/html528/TGHSlider.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGHSlider.html
https://root.cern/root/html528/TGHSlider.html:5005,Availability,error,error,5005,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; const char*TGWidget::GetCommand() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionGetDefaultSize() const; virtual UInt_tTGFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType() const; virtual Option_t*TObject::GetDrawOption() const; virtual Int_tTGFr",MatchSource.WIKI,root/html528/TGHSlider.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGHSlider.html
https://root.cern/root/html528/TGHSlider.html:17035,Availability,mask,mask,17035,,MatchSource.WIKI,root/html528/TGHSlider.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGHSlider.html
https://root.cern/root/html528/TGHSplitter.html:4264,Availability,error,error,4264,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Bool_tGetAbove() const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGFrame::GetDefaultSize() const; virtual UInt_tTGFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType",MatchSource.WIKI,root/html528/TGHSplitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGHSplitter.html
https://root.cern/root/html528/TGHSplitter.html:4348,Availability,error,error,4348,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Bool_tGetAbove() const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGFrame::GetDefaultSize() const; virtual UInt_tTGFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType() const; virtual Option_t*TObject::GetDrawOption() const; virtual Int_tTGFrame::Get",MatchSource.WIKI,root/html528/TGHSplitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGHSplitter.html
https://root.cern/root/html528/TGHSplitter.html:15669,Availability,mask,mask,15669,,MatchSource.WIKI,root/html528/TGHSplitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGHSplitter.html
https://root.cern/root/html528/TGHtml.html:4594,Availability,error,error,4594,"al, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidEncodeText(TGString* str, const char* z); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; TGHtmlElement*FindEndNest(TGHtmlElement* sp, int en, TGHtmlElement* lp); virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual intFormAction(TGHtmlForm*, int); virtual intFormCreate(TGHtmlForm*, const char*, const char*); virtual Pixel_tTGFrame::GetBackground() const; const char*GetBaseUri() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGViewFrame*TGView::GetCanvas() const; TGClient*TGObject::GetClient() const; const char*TGWidget::GetCommand() const; static Int_tTGWindow::GetCounte",MatchSource.WIKI,root/html528/TGHtml.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGHtml.html
https://root.cern/root/html528/TGHtml.html:4678,Availability,error,error,4678,"ect::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidEncodeText(TGString* str, const char* z); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; TGHtmlElement*FindEndNest(TGHtmlElement* sp, int en, TGHtmlElement* lp); virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual intFormAction(TGHtmlForm*, int); virtual intFormCreate(TGHtmlForm*, const char*, const char*); virtual Pixel_tTGFrame::GetBackground() const; const char*GetBaseUri() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGViewFrame*TGView::GetCanvas() const; TGClient*TGObject::GetClient() const; const char*TGWidget::GetCommand() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFr",MatchSource.WIKI,root/html528/TGHtml.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGHtml.html
https://root.cern/root/html528/TGHtml.html:24534,Availability,mask,mask,24534,"...</A>; TGHtmlAnchor*fAnchorStartMost recent <a href=...>; ColorStruct_t*fApColor[32]Information about all colors; Pixel_tTGFrame::fBackgroundframe background color; ColorStruct_t*fBgColorBackground color of the HTML document; TImage*fBgImageBackground image; Int_tTGFrame::fBorderWidthframe border width; TGViewFrame*TGView::fCanvasframe containing the text; TGClient*TGObject::fClientConnection to display server; Atom_tTGView::fClipboardclipboard property; Long_tfColorUsedbit N is 1 if color N is in use. Only; TStringTGWidget::fCommandcommand to be executed; Cursor_tfCursorCurrent cursor for window, or None.; Int_tTGFrame::fDNDStateEDNDFlags; intfDirtyBottomBottom right corner of region to redraw; intfDirtyLeft; intfDirtyRight; intfDirtyTopTop left corner of region to redraw. These; UInt_tTGWindow::fEditDisabledflags used for ""guibuilding""; UInt_tTGFrame::fEventMaskcurrenty active event mask; intfExitingTrue if the widget is being destroyed; intfExportSelectionTrue if the selection is automatically; TGRectangleTGView::fExposedRegionexposed area ; SHtmlExtensions_t*fExtsPointer to user extension data; TGFrameElement*TGFrame::fFEpointer to frame element; ColorStruct_t*fFgColorColor of normal text. apColor[0]; TGHtmlBlock*fFirstBlockList of all TGHtmlBlock tokens; TGHtmlInput*fFirstInputFirst <INPUT> element; intfFlagsVarious flags; see below for definitions.; charfFontValid[9]If bit N%8 of work N/8 of this field is 0; TGHtmlInput*fFormElemLastMost recent <input>, <textarea> or <select>; TGHtmlInput*fFormElemStartMost recent <textarea> or <select>; intfFormPaddingAmount to pad form elements by; TGHtmlForm*fFormStartMost recent <form>; intfGcNextToFree; intfHasFramesTRUE if we can do frames for this page; intfHasScriptTRUE if we can do scripts for this page; UInt_tTGFrame::fHeightframe height; ColorStruct_t*fHighlightBgColorPtrColor for drawing traversal highlight; ColorStruct_t*fHighlightColorPtrColor for drawing traversal highlight.; intfHighlightWidthWidth in pixels ",MatchSource.WIKI,root/html528/TGHtml.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGHtml.html
https://root.cern/root/html528/TGHtml.html:32411,Availability,avail,available,32411,"fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGHtml(const TGWindow* p, int w, int h, int id = -1); HTML Widget constructor. ~TGHtml(); HTML widget destructor. void UpdateBackgroundStart(); Start background update. void FreeColor(ColorStruct_t* color); Free system color. ColorStruct_t * AllocColor(const char* name); Allocate system color by name. ColorStruct_t * AllocColorByValue(ColorStruct_t* color); Allocate system color by value. void Clear(Option_t* = """"); Erase all HTML from this widget and clear the screen. This is; typically done before loading a new document. int ParseText(char* text, const char* index = 0); Appends (or insert at the specified position) the given HTML text to the; end of any HTML text that may have been inserted by prior calls to this; command. Then it runs the tokenizer, parser and layout engine as far as; possible with the text that is available. The display is updated; appropriately. void SetTableRelief(int relief); Sets relief mode of html table. void SetRuleRelief(int relief); Sets relief mode of html rule. void UnderlineLinks(int onoff); Set/reset html links underline. void SetBaseUri(const char* uri); Sets base URI. int GotoAnchor(const char* name); Go to anchor position. const char * GetUid(const char* string); Given a string, this procedure returns a unique identifier for the; string. This procedure returns a pointer to a new char string corresponding to; the ""string"" argument. The new string has a value identical to string; (strcmp will return 0), but it's guaranteed that any other calls to this; procedure with a string equal to ""string"" will return exactly the same; result (i.e. can compare pointer *values* directly, without having to; call strcmp on what they point to). void ComputeVirtualSize(); Computes virtual size of html area. void ClearGcCache(); Clear the ca",MatchSource.WIKI,root/html528/TGHtml.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGHtml.html
https://root.cern/root/html528/TGHtml.html:26107,Deployability,update,update,26107,">, <textarea> or <select>; TGHtmlInput*fFormElemStartMost recent <textarea> or <select>; intfFormPaddingAmount to pad form elements by; TGHtmlForm*fFormStartMost recent <form>; intfGcNextToFree; intfHasFramesTRUE if we can do frames for this page; intfHasScriptTRUE if we can do scripts for this page; UInt_tTGFrame::fHeightframe height; ColorStruct_t*fHighlightBgColorPtrColor for drawing traversal highlight; ColorStruct_t*fHighlightColorPtrColor for drawing traversal highlight.; intfHighlightWidthWidth in pixels of highlight to draw; TGHScrollBar*TGView::fHsbhorizontal scrollbar; intfIColThe column in which zText[nComplete]; intfIDark[32]Dark 3D shadow of color K is iDark[K]; intfILight[32]Light 3D shadow of color K is iLight[K]; intfIPlaintextIf not zero, this is the token type that; Handle_tTGObject::fIdX11/Win32 Window identifier; intfIdind; TGIdleHandler*fIdle; TGHtmlImage*fImageListA list of all images; intfInDtStyle flags associated with <DT>...</DT>; intfInParsePrevent update if parsing; intfInTdTrue if within <td>..</td> or <th>..</th>; intfInTrTrue if within <tr>..</tr>; TGHtmlListStart*fInnerListThe inner most <OL> or <UL>; intfInputIdxUnique input index; SHtmlIndex_tfInsThe insertion cursor position; intfInsIndexIndex in pInsBlock of the cursor; intfInsOffTimeHow long it is off (milliseconds); intfInsOnTimeHow long the cursor states one (millisec); intfInsStatusIs it visible?; TTimer*fInsTimerTimer used to flash the insertion cursor; TGHtmlBlock*fLastBlockLast TGHtmlBlock in the list; intfLastGCIndex of recently used GC; TGHtmlInput*fLastInputLast <INPUT> element; TGHtmlElement*fLastSizedLast HTML element that has been sized; const char*fLastUriUsed in HandleMotion; Bool_tTGCompositeFrame::fLayoutBrokenno layout manager is used; TGHtmlLayoutContextfLayoutContext; TGLayoutManager*TGCompositeFrame::fLayoutManagerlayout manager; TList*TGCompositeFrame::fListcontainer of frame elements; TList*TQObject::fListOfConnections! list of connections to this object; TLi",MatchSource.WIKI,root/html528/TGHtml.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGHtml.html
https://root.cern/root/html528/TGHtml.html:31742,Deployability,update,update,31742," all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGHtml(const TGWindow* p, int w, int h, int id = -1); HTML Widget constructor. ~TGHtml(); HTML widget destructor. void UpdateBackgroundStart(); Start background update. void FreeColor(ColorStruct_t* color); Free system color. ColorStruct_t * AllocColor(const char* name); Allocate system color by name. ColorStruct_t * AllocColorByValue(ColorStruct_t* color); Allocate system color by value. void Clear(Option_t* = """"); Erase all HTML from this widget and clear the screen. This is; typically done before loading a new document. int ParseText(char* text, const char* index = 0); Appends (or insert at the specified position) the given HTML text to the; end of any HTML text that may have been inserted by prior calls to this; command. Then it runs the tokenizer, parser and layout engine as far as; possible with the text that is available. The display is updated; appropriately. void SetTableRelief(int relief); Sets relief mode of html table. void SetRuleRelief(int relief); Sets relief mode of html rule. void UnderlineLinks(int onoff); Set/reset html links underline. void SetBaseUri(const char* uri); Sets base URI. int GotoAnchor(const",MatchSource.WIKI,root/html528/TGHtml.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGHtml.html
https://root.cern/root/html528/TGHtml.html:32437,Deployability,update,updated,32437,"::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGHtml(const TGWindow* p, int w, int h, int id = -1); HTML Widget constructor. ~TGHtml(); HTML widget destructor. void UpdateBackgroundStart(); Start background update. void FreeColor(ColorStruct_t* color); Free system color. ColorStruct_t * AllocColor(const char* name); Allocate system color by name. ColorStruct_t * AllocColorByValue(ColorStruct_t* color); Allocate system color by value. void Clear(Option_t* = """"); Erase all HTML from this widget and clear the screen. This is; typically done before loading a new document. int ParseText(char* text, const char* index = 0); Appends (or insert at the specified position) the given HTML text to the; end of any HTML text that may have been inserted by prior calls to this; command. Then it runs the tokenizer, parser and layout engine as far as; possible with the text that is available. The display is updated; appropriately. void SetTableRelief(int relief); Sets relief mode of html table. void SetRuleRelief(int relief); Sets relief mode of html rule. void UnderlineLinks(int onoff); Set/reset html links underline. void SetBaseUri(const char* uri); Sets base URI. int GotoAnchor(const char* name); Go to anchor position. const char * GetUid(const char* string); Given a string, this procedure returns a unique identifier for the; string. This procedure returns a pointer to a new char string corresponding to; the ""string"" argument. The new string has a value identical to string; (strcmp will return 0), but it's guaranteed that any other calls to this; procedure with a string equal to ""string"" will return exactly the same; result (i.e. can compare pointer *values* directly, without having to; call strcmp on what they point to). void ComputeVirtualSize(); Computes virtual size of html area. void ClearGcCache(); Clear the cache of GCs. void ResetLayoutContext(); Reset the main layout context in t",MatchSource.WIKI,root/html528/TGHtml.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGHtml.html
https://root.cern/root/html528/TGHtml.html:38282,Deployability,update,update,38282,"iate color for the dark part of a 3D shadow. int IsLightColor(ColorStruct_t* p); Check to see if the given color is too light to be easily distinguished; from white. int GetLightShadowColor(int iBgColor); Given that the background color is iBgColor, figure out an; appropriate color for the bright part of the 3D shadow. int GetColorByValue(ColorStruct_t* pRef); Find a color integer for the color whose color components; are given by pRef. const char * GetHref(int x, int y, const char** target = 0); This routine searchs for a hyperlink beneath the coordinates x,y; and returns a pointer to the HREF for that hyperlink. The text; is held in one of the markup argv[] fields of the <a> markup. int ElementCoords(TGHtmlElement* p, int i, int pct, int* coords); Return coordinates of item. TGHtmlElement * AttrElem(const char* name, char* value); Returns html element matching attribute name and value. void UpdateSelection(int forceUpdate); Given the selection end-points in fSelBegin and fSelEnd, recompute; pSelBeginBlock and fPSelEndBlock, then call UpdateSelectionDisplay(); to update the display. This routine should be called whenever the selection changes or; whenever the set of TGHtmlBlock structures change. void UpdateSelectionDisplay(); The fPSelStartBlock and fPSelEndBlock values have been changed.; This routine's job is to loop over all TGHtmlBlocks and either; set or clear the HTML_Selected bits in the .fFlags field; as appropriate. For every TGHtmlBlock where the bit changes,; mark that block for redrawing. void LostSelection(); Clear selection. int SelectionSet(const char* startIx, const char* endIx); Set selection. void UpdateInsert(); Recompute the position of the insertion cursor based on the; position in fIns. int SetInsert(const char* insIx); Set the position of the insertion cursor. void SavePrimitive(ostream& out, Option_t* = """"); Save a html widget as a C++ statement(s) on output stream out. Bool_t ProcessMessage(Long_t , Long_t , Long_t ). int GetTableRelief() ",MatchSource.WIKI,root/html528/TGHtml.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGHtml.html
https://root.cern/root/html528/TGHtml.html:27843,Energy Efficiency,allocate,allocated,27843,"ithin <td>..</td> or <th>..</th>; intfInTrTrue if within <tr>..</tr>; TGHtmlListStart*fInnerListThe inner most <OL> or <UL>; intfInputIdxUnique input index; SHtmlIndex_tfInsThe insertion cursor position; intfInsIndexIndex in pInsBlock of the cursor; intfInsOffTimeHow long it is off (milliseconds); intfInsOnTimeHow long the cursor states one (millisec); intfInsStatusIs it visible?; TTimer*fInsTimerTimer used to flash the insertion cursor; TGHtmlBlock*fLastBlockLast TGHtmlBlock in the list; intfLastGCIndex of recently used GC; TGHtmlInput*fLastInputLast <INPUT> element; TGHtmlElement*fLastSizedLast HTML element that has been sized; const char*fLastUriUsed in HandleMotion; Bool_tTGCompositeFrame::fLayoutBrokenno layout manager is used; TGHtmlLayoutContextfLayoutContext; TGLayoutManager*TGCompositeFrame::fLayoutManagerlayout manager; TList*TGCompositeFrame::fListcontainer of frame elements; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; TGHtmlElement*fLoEndPtrHow far AddStyle has gone to; TGHtmlForm*fLoFormStartFor AddStyle; Bool_tTGCompositeFrame::fMapSubwindowskTRUE - map subwindows; TGInsetsfMarginsdocument margins (separation between the; UInt_tTGFrame::fMaxHeightmaximal frame height; UInt_tTGFrame::fMaxWidthmaximal frame width; intfMaxX; intfMaxYMaximum extent of any ""paint"" that appears; UInt_tTGFrame::fMinHeightminimal frame height; UInt_tTGFrame::fMinWidthminimal frame width; TGLongPositionTGView::fMousePosposition of mouse; const TGWindow*TGWidget::fMsgWindowwindow which handles widget events; Int_tTGCompositeFrame::fMustCleanupcleanup mode (see EFrameCleanup); intfNAllocSpace allocated for zText; intfNCompleteHow much of zText has actually been; intfNFormThe number of <FORM> elements; intfNInputThe number of <INPUT> elements; intfNTextNumber of characters in zText; intfNTokenNumber of HTML tokens on the list.; TStringTGWindow::fNamename of the window used in SavePrimitiv",MatchSource.WIKI,root/html528/TGHtml.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGHtml.html
https://root.cern/root/html528/TGHtml.html:34150,Energy Efficiency,schedul,schedule,34150,"me; result (i.e. can compare pointer *values* directly, without having to; call strcmp on what they point to). void ComputeVirtualSize(); Computes virtual size of html area. void ClearGcCache(); Clear the cache of GCs. void ResetLayoutContext(); Reset the main layout context in the main widget. This happens; before we redo the layout, or just before deleting the widget. void Redraw(); This routine is invoked in order to redraw all or part of the HTML; widget. This might happen because the display has changed, or in; response to an expose event. In all cases, though, this routine; is called by an idle handler. void ScheduleRedraw(); Make sure that a call to the Redraw() routine has been queued. Bool_t HandleIdleEvent(TGIdleHandler* i); Handles idle event. void RedrawArea(int left, int top, int right, int bottom); If any part of the screen needs to be redrawn, then call this routine; with the values of a box (in window coordinates) that needs to be; redrawn. This routine will schedule an idle handler to do the redraw. The box coordinates are relative to the clipping window (fCanvas). void DrawRegion(Int_t x, Int_t y, UInt_t w, UInt_t h); Draw region defined by [x,y] [w,h]. Bool_t ItemLayout(); Layout html widget. void RedrawBlock(TGHtmlBlock* p); Redraw the TGHtmlBlock given. void RedrawEverything(); Call this routine to force the entire widget to be redrawn. void RedrawText(int y); Call this routine to cause all of the rendered HTML at the; virtual canvas coordinate of Y and beyond to be redrawn. void HClear(); Erase all data from the HTML widget. Bring it back to an empty screen. Bool_t HandleTimer(TTimer* timer); Handle timer event. void FlashCursor(); Flash the insertion cursor. GContext_t GetGC(int color, int font); Return a GC from the cache. As many as N_CACHE_GCs are kept valid; at any one time. They are replaced using an LRU algorithm. A value of FONT_Any (-1) for the font means ""don't care"". GContext_t GetAnyGC(); Retrieve any valid GC. The font and color don",MatchSource.WIKI,root/html528/TGHtml.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGHtml.html
https://root.cern/root/html528/TGHtml.html:36443,Energy Efficiency,allocate,allocated,36443,"k. The text; is held in one of the markup argv[] fields of the <a> markup. Bool_t HandleHtmlInput(TGHtmlInput* pr, Event_t* event); Handle html input (button, checkbox, ...) event. Bool_t HandleRadioButton(TGHtmlInput* p); Handle radio button event. void ButtonClicked(const char* name, const char* val); Emit ButtonClicked() signal. void CheckToggled(const char* name, Bool_t on, const char* val); Emit CheckToggled() signal. void RadioChanged(const char* name, const char* val); Emit RadioChanged() signal. void InputSelected(const char* name, const char* val); Emit Selected() signal. void SubmitClicked(const char* val); Emit SubmitClicked() signal. Bool_t HandleButton(Event_t* event); Handle mouse button event. Bool_t HandleMotion(Event_t* event); handle mouse motion events. TGFont * GetFont(int iFont); The rendering and layout routines should call this routine in order to; get a font structure. The iFont parameter specifies which of the N_FONT; fonts should be obtained. The font is allocated if necessary. int InArea(TGHtmlMapArea* p, int left, int top, int x, int y); Only support rect and circles for now. TGHtmlElement * GetMap(const char* name); Returns html map element. float ColorDistance(ColorStruct_t* pA, ColorStruct_t* pB); Compute the squared distance between two colors. int GetColorByName(const char* zColor); This routine returns an index between 0 and N_COLOR-1 which indicates; which ColorStruct_t structure in the fApColor[] array should be used to describe; the color specified by the given name. int IsDarkColor(ColorStruct_t* p); Check to see if the given color is too dark to be easily distinguished; from black. int GetDarkShadowColor(int iBgColor); Given that the background color is iBgColor, figure out an; appropriate color for the dark part of a 3D shadow. int IsLightColor(ColorStruct_t* p); Check to see if the given color is too light to be easily distinguished; from white. int GetLightShadowColor(int iBgColor); Given that the background color is iBgColo",MatchSource.WIKI,root/html528/TGHtml.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGHtml.html
https://root.cern/root/html528/TGHtml.html:33554,Integrability,rout,routine,33554,"html rule. void UnderlineLinks(int onoff); Set/reset html links underline. void SetBaseUri(const char* uri); Sets base URI. int GotoAnchor(const char* name); Go to anchor position. const char * GetUid(const char* string); Given a string, this procedure returns a unique identifier for the; string. This procedure returns a pointer to a new char string corresponding to; the ""string"" argument. The new string has a value identical to string; (strcmp will return 0), but it's guaranteed that any other calls to this; procedure with a string equal to ""string"" will return exactly the same; result (i.e. can compare pointer *values* directly, without having to; call strcmp on what they point to). void ComputeVirtualSize(); Computes virtual size of html area. void ClearGcCache(); Clear the cache of GCs. void ResetLayoutContext(); Reset the main layout context in the main widget. This happens; before we redo the layout, or just before deleting the widget. void Redraw(); This routine is invoked in order to redraw all or part of the HTML; widget. This might happen because the display has changed, or in; response to an expose event. In all cases, though, this routine; is called by an idle handler. void ScheduleRedraw(); Make sure that a call to the Redraw() routine has been queued. Bool_t HandleIdleEvent(TGIdleHandler* i); Handles idle event. void RedrawArea(int left, int top, int right, int bottom); If any part of the screen needs to be redrawn, then call this routine; with the values of a box (in window coordinates) that needs to be; redrawn. This routine will schedule an idle handler to do the redraw. The box coordinates are relative to the clipping window (fCanvas). void DrawRegion(Int_t x, Int_t y, UInt_t w, UInt_t h); Draw region defined by [x,y] [w,h]. Bool_t ItemLayout(); Layout html widget. void RedrawBlock(TGHtmlBlock* p); Redraw the TGHtmlBlock given. void RedrawEverything(); Call this routine to force the entire widget to be redrawn. void RedrawText(int y); Call this rout",MatchSource.WIKI,root/html528/TGHtml.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGHtml.html
https://root.cern/root/html528/TGHtml.html:33739,Integrability,rout,routine,33739,"chor position. const char * GetUid(const char* string); Given a string, this procedure returns a unique identifier for the; string. This procedure returns a pointer to a new char string corresponding to; the ""string"" argument. The new string has a value identical to string; (strcmp will return 0), but it's guaranteed that any other calls to this; procedure with a string equal to ""string"" will return exactly the same; result (i.e. can compare pointer *values* directly, without having to; call strcmp on what they point to). void ComputeVirtualSize(); Computes virtual size of html area. void ClearGcCache(); Clear the cache of GCs. void ResetLayoutContext(); Reset the main layout context in the main widget. This happens; before we redo the layout, or just before deleting the widget. void Redraw(); This routine is invoked in order to redraw all or part of the HTML; widget. This might happen because the display has changed, or in; response to an expose event. In all cases, though, this routine; is called by an idle handler. void ScheduleRedraw(); Make sure that a call to the Redraw() routine has been queued. Bool_t HandleIdleEvent(TGIdleHandler* i); Handles idle event. void RedrawArea(int left, int top, int right, int bottom); If any part of the screen needs to be redrawn, then call this routine; with the values of a box (in window coordinates) that needs to be; redrawn. This routine will schedule an idle handler to do the redraw. The box coordinates are relative to the clipping window (fCanvas). void DrawRegion(Int_t x, Int_t y, UInt_t w, UInt_t h); Draw region defined by [x,y] [w,h]. Bool_t ItemLayout(); Layout html widget. void RedrawBlock(TGHtmlBlock* p); Redraw the TGHtmlBlock given. void RedrawEverything(); Call this routine to force the entire widget to be redrawn. void RedrawText(int y); Call this routine to cause all of the rendered HTML at the; virtual canvas coordinate of Y and beyond to be redrawn. void HClear(); Erase all data from the HTML widget. Bring it b",MatchSource.WIKI,root/html528/TGHtml.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGHtml.html
https://root.cern/root/html528/TGHtml.html:33839,Integrability,rout,routine,33839," procedure returns a unique identifier for the; string. This procedure returns a pointer to a new char string corresponding to; the ""string"" argument. The new string has a value identical to string; (strcmp will return 0), but it's guaranteed that any other calls to this; procedure with a string equal to ""string"" will return exactly the same; result (i.e. can compare pointer *values* directly, without having to; call strcmp on what they point to). void ComputeVirtualSize(); Computes virtual size of html area. void ClearGcCache(); Clear the cache of GCs. void ResetLayoutContext(); Reset the main layout context in the main widget. This happens; before we redo the layout, or just before deleting the widget. void Redraw(); This routine is invoked in order to redraw all or part of the HTML; widget. This might happen because the display has changed, or in; response to an expose event. In all cases, though, this routine; is called by an idle handler. void ScheduleRedraw(); Make sure that a call to the Redraw() routine has been queued. Bool_t HandleIdleEvent(TGIdleHandler* i); Handles idle event. void RedrawArea(int left, int top, int right, int bottom); If any part of the screen needs to be redrawn, then call this routine; with the values of a box (in window coordinates) that needs to be; redrawn. This routine will schedule an idle handler to do the redraw. The box coordinates are relative to the clipping window (fCanvas). void DrawRegion(Int_t x, Int_t y, UInt_t w, UInt_t h); Draw region defined by [x,y] [w,h]. Bool_t ItemLayout(); Layout html widget. void RedrawBlock(TGHtmlBlock* p); Redraw the TGHtmlBlock given. void RedrawEverything(); Call this routine to force the entire widget to be redrawn. void RedrawText(int y); Call this routine to cause all of the rendered HTML at the; virtual canvas coordinate of Y and beyond to be redrawn. void HClear(); Erase all data from the HTML widget. Bring it back to an empty screen. Bool_t HandleTimer(TTimer* timer); Handle timer even",MatchSource.WIKI,root/html528/TGHtml.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGHtml.html
https://root.cern/root/html528/TGHtml.html:34047,Integrability,rout,routine,34047,"ill return 0), but it's guaranteed that any other calls to this; procedure with a string equal to ""string"" will return exactly the same; result (i.e. can compare pointer *values* directly, without having to; call strcmp on what they point to). void ComputeVirtualSize(); Computes virtual size of html area. void ClearGcCache(); Clear the cache of GCs. void ResetLayoutContext(); Reset the main layout context in the main widget. This happens; before we redo the layout, or just before deleting the widget. void Redraw(); This routine is invoked in order to redraw all or part of the HTML; widget. This might happen because the display has changed, or in; response to an expose event. In all cases, though, this routine; is called by an idle handler. void ScheduleRedraw(); Make sure that a call to the Redraw() routine has been queued. Bool_t HandleIdleEvent(TGIdleHandler* i); Handles idle event. void RedrawArea(int left, int top, int right, int bottom); If any part of the screen needs to be redrawn, then call this routine; with the values of a box (in window coordinates) that needs to be; redrawn. This routine will schedule an idle handler to do the redraw. The box coordinates are relative to the clipping window (fCanvas). void DrawRegion(Int_t x, Int_t y, UInt_t w, UInt_t h); Draw region defined by [x,y] [w,h]. Bool_t ItemLayout(); Layout html widget. void RedrawBlock(TGHtmlBlock* p); Redraw the TGHtmlBlock given. void RedrawEverything(); Call this routine to force the entire widget to be redrawn. void RedrawText(int y); Call this routine to cause all of the rendered HTML at the; virtual canvas coordinate of Y and beyond to be redrawn. void HClear(); Erase all data from the HTML widget. Bring it back to an empty screen. Bool_t HandleTimer(TTimer* timer); Handle timer event. void FlashCursor(); Flash the insertion cursor. GContext_t GetGC(int color, int font); Return a GC from the cache. As many as N_CACHE_GCs are kept valid; at any one time. They are replaced using an LRU alg",MatchSource.WIKI,root/html528/TGHtml.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGHtml.html
https://root.cern/root/html528/TGHtml.html:34137,Integrability,rout,routine,34137,"me; result (i.e. can compare pointer *values* directly, without having to; call strcmp on what they point to). void ComputeVirtualSize(); Computes virtual size of html area. void ClearGcCache(); Clear the cache of GCs. void ResetLayoutContext(); Reset the main layout context in the main widget. This happens; before we redo the layout, or just before deleting the widget. void Redraw(); This routine is invoked in order to redraw all or part of the HTML; widget. This might happen because the display has changed, or in; response to an expose event. In all cases, though, this routine; is called by an idle handler. void ScheduleRedraw(); Make sure that a call to the Redraw() routine has been queued. Bool_t HandleIdleEvent(TGIdleHandler* i); Handles idle event. void RedrawArea(int left, int top, int right, int bottom); If any part of the screen needs to be redrawn, then call this routine; with the values of a box (in window coordinates) that needs to be; redrawn. This routine will schedule an idle handler to do the redraw. The box coordinates are relative to the clipping window (fCanvas). void DrawRegion(Int_t x, Int_t y, UInt_t w, UInt_t h); Draw region defined by [x,y] [w,h]. Bool_t ItemLayout(); Layout html widget. void RedrawBlock(TGHtmlBlock* p); Redraw the TGHtmlBlock given. void RedrawEverything(); Call this routine to force the entire widget to be redrawn. void RedrawText(int y); Call this routine to cause all of the rendered HTML at the; virtual canvas coordinate of Y and beyond to be redrawn. void HClear(); Erase all data from the HTML widget. Bring it back to an empty screen. Bool_t HandleTimer(TTimer* timer); Handle timer event. void FlashCursor(); Flash the insertion cursor. GContext_t GetGC(int color, int font); Return a GC from the cache. As many as N_CACHE_GCs are kept valid; at any one time. They are replaced using an LRU algorithm. A value of FONT_Any (-1) for the font means ""don't care"". GContext_t GetAnyGC(); Retrieve any valid GC. The font and color don",MatchSource.WIKI,root/html528/TGHtml.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGHtml.html
https://root.cern/root/html528/TGHtml.html:34491,Integrability,rout,routine,34491," or just before deleting the widget. void Redraw(); This routine is invoked in order to redraw all or part of the HTML; widget. This might happen because the display has changed, or in; response to an expose event. In all cases, though, this routine; is called by an idle handler. void ScheduleRedraw(); Make sure that a call to the Redraw() routine has been queued. Bool_t HandleIdleEvent(TGIdleHandler* i); Handles idle event. void RedrawArea(int left, int top, int right, int bottom); If any part of the screen needs to be redrawn, then call this routine; with the values of a box (in window coordinates) that needs to be; redrawn. This routine will schedule an idle handler to do the redraw. The box coordinates are relative to the clipping window (fCanvas). void DrawRegion(Int_t x, Int_t y, UInt_t w, UInt_t h); Draw region defined by [x,y] [w,h]. Bool_t ItemLayout(); Layout html widget. void RedrawBlock(TGHtmlBlock* p); Redraw the TGHtmlBlock given. void RedrawEverything(); Call this routine to force the entire widget to be redrawn. void RedrawText(int y); Call this routine to cause all of the rendered HTML at the; virtual canvas coordinate of Y and beyond to be redrawn. void HClear(); Erase all data from the HTML widget. Bring it back to an empty screen. Bool_t HandleTimer(TTimer* timer); Handle timer event. void FlashCursor(); Flash the insertion cursor. GContext_t GetGC(int color, int font); Return a GC from the cache. As many as N_CACHE_GCs are kept valid; at any one time. They are replaced using an LRU algorithm. A value of FONT_Any (-1) for the font means ""don't care"". GContext_t GetAnyGC(); Retrieve any valid GC. The font and color don't matter since the; GC will only be used for copying. Bool_t HandleFocusChange(Event_t* event); Handle focus change event. TGHtmlInput * GetInputElement(int x, int y); This routine searchs for a hyperlink beneath the coordinates x,y; and returns a pointer to the HREF for that hyperlink. The text; is held in one of the markup argv[] f",MatchSource.WIKI,root/html528/TGHtml.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGHtml.html
https://root.cern/root/html528/TGHtml.html:34575,Integrability,rout,routine,34575," HTML; widget. This might happen because the display has changed, or in; response to an expose event. In all cases, though, this routine; is called by an idle handler. void ScheduleRedraw(); Make sure that a call to the Redraw() routine has been queued. Bool_t HandleIdleEvent(TGIdleHandler* i); Handles idle event. void RedrawArea(int left, int top, int right, int bottom); If any part of the screen needs to be redrawn, then call this routine; with the values of a box (in window coordinates) that needs to be; redrawn. This routine will schedule an idle handler to do the redraw. The box coordinates are relative to the clipping window (fCanvas). void DrawRegion(Int_t x, Int_t y, UInt_t w, UInt_t h); Draw region defined by [x,y] [w,h]. Bool_t ItemLayout(); Layout html widget. void RedrawBlock(TGHtmlBlock* p); Redraw the TGHtmlBlock given. void RedrawEverything(); Call this routine to force the entire widget to be redrawn. void RedrawText(int y); Call this routine to cause all of the rendered HTML at the; virtual canvas coordinate of Y and beyond to be redrawn. void HClear(); Erase all data from the HTML widget. Bring it back to an empty screen. Bool_t HandleTimer(TTimer* timer); Handle timer event. void FlashCursor(); Flash the insertion cursor. GContext_t GetGC(int color, int font); Return a GC from the cache. As many as N_CACHE_GCs are kept valid; at any one time. They are replaced using an LRU algorithm. A value of FONT_Any (-1) for the font means ""don't care"". GContext_t GetAnyGC(); Retrieve any valid GC. The font and color don't matter since the; GC will only be used for copying. Bool_t HandleFocusChange(Event_t* event); Handle focus change event. TGHtmlInput * GetInputElement(int x, int y); This routine searchs for a hyperlink beneath the coordinates x,y; and returns a pointer to the HREF for that hyperlink. The text; is held in one of the markup argv[] fields of the <a> markup. Bool_t HandleHtmlInput(TGHtmlInput* pr, Event_t* event); Handle html input (button, chec",MatchSource.WIKI,root/html528/TGHtml.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGHtml.html
https://root.cern/root/html528/TGHtml.html:35336,Integrability,rout,routine,35336,"t(); Layout html widget. void RedrawBlock(TGHtmlBlock* p); Redraw the TGHtmlBlock given. void RedrawEverything(); Call this routine to force the entire widget to be redrawn. void RedrawText(int y); Call this routine to cause all of the rendered HTML at the; virtual canvas coordinate of Y and beyond to be redrawn. void HClear(); Erase all data from the HTML widget. Bring it back to an empty screen. Bool_t HandleTimer(TTimer* timer); Handle timer event. void FlashCursor(); Flash the insertion cursor. GContext_t GetGC(int color, int font); Return a GC from the cache. As many as N_CACHE_GCs are kept valid; at any one time. They are replaced using an LRU algorithm. A value of FONT_Any (-1) for the font means ""don't care"". GContext_t GetAnyGC(); Retrieve any valid GC. The font and color don't matter since the; GC will only be used for copying. Bool_t HandleFocusChange(Event_t* event); Handle focus change event. TGHtmlInput * GetInputElement(int x, int y); This routine searchs for a hyperlink beneath the coordinates x,y; and returns a pointer to the HREF for that hyperlink. The text; is held in one of the markup argv[] fields of the <a> markup. Bool_t HandleHtmlInput(TGHtmlInput* pr, Event_t* event); Handle html input (button, checkbox, ...) event. Bool_t HandleRadioButton(TGHtmlInput* p); Handle radio button event. void ButtonClicked(const char* name, const char* val); Emit ButtonClicked() signal. void CheckToggled(const char* name, Bool_t on, const char* val); Emit CheckToggled() signal. void RadioChanged(const char* name, const char* val); Emit RadioChanged() signal. void InputSelected(const char* name, const char* val); Emit Selected() signal. void SubmitClicked(const char* val); Emit SubmitClicked() signal. Bool_t HandleButton(Event_t* event); Handle mouse button event. Bool_t HandleMotion(Event_t* event); handle mouse motion events. TGFont * GetFont(int iFont); The rendering and layout routines should call this routine in order to; get a font structure. The iFont para",MatchSource.WIKI,root/html528/TGHtml.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGHtml.html
https://root.cern/root/html528/TGHtml.html:36285,Integrability,rout,routines,36285,"lInput * GetInputElement(int x, int y); This routine searchs for a hyperlink beneath the coordinates x,y; and returns a pointer to the HREF for that hyperlink. The text; is held in one of the markup argv[] fields of the <a> markup. Bool_t HandleHtmlInput(TGHtmlInput* pr, Event_t* event); Handle html input (button, checkbox, ...) event. Bool_t HandleRadioButton(TGHtmlInput* p); Handle radio button event. void ButtonClicked(const char* name, const char* val); Emit ButtonClicked() signal. void CheckToggled(const char* name, Bool_t on, const char* val); Emit CheckToggled() signal. void RadioChanged(const char* name, const char* val); Emit RadioChanged() signal. void InputSelected(const char* name, const char* val); Emit Selected() signal. void SubmitClicked(const char* val); Emit SubmitClicked() signal. Bool_t HandleButton(Event_t* event); Handle mouse button event. Bool_t HandleMotion(Event_t* event); handle mouse motion events. TGFont * GetFont(int iFont); The rendering and layout routines should call this routine in order to; get a font structure. The iFont parameter specifies which of the N_FONT; fonts should be obtained. The font is allocated if necessary. int InArea(TGHtmlMapArea* p, int left, int top, int x, int y); Only support rect and circles for now. TGHtmlElement * GetMap(const char* name); Returns html map element. float ColorDistance(ColorStruct_t* pA, ColorStruct_t* pB); Compute the squared distance between two colors. int GetColorByName(const char* zColor); This routine returns an index between 0 and N_COLOR-1 which indicates; which ColorStruct_t structure in the fApColor[] array should be used to describe; the color specified by the given name. int IsDarkColor(ColorStruct_t* p); Check to see if the given color is too dark to be easily distinguished; from black. int GetDarkShadowColor(int iBgColor); Given that the background color is iBgColor, figure out an; appropriate color for the dark part of a 3D shadow. int IsLightColor(ColorStruct_t* p); Check to s",MatchSource.WIKI,root/html528/TGHtml.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGHtml.html
https://root.cern/root/html528/TGHtml.html:36311,Integrability,rout,routine,36311,"lInput * GetInputElement(int x, int y); This routine searchs for a hyperlink beneath the coordinates x,y; and returns a pointer to the HREF for that hyperlink. The text; is held in one of the markup argv[] fields of the <a> markup. Bool_t HandleHtmlInput(TGHtmlInput* pr, Event_t* event); Handle html input (button, checkbox, ...) event. Bool_t HandleRadioButton(TGHtmlInput* p); Handle radio button event. void ButtonClicked(const char* name, const char* val); Emit ButtonClicked() signal. void CheckToggled(const char* name, Bool_t on, const char* val); Emit CheckToggled() signal. void RadioChanged(const char* name, const char* val); Emit RadioChanged() signal. void InputSelected(const char* name, const char* val); Emit Selected() signal. void SubmitClicked(const char* val); Emit SubmitClicked() signal. Bool_t HandleButton(Event_t* event); Handle mouse button event. Bool_t HandleMotion(Event_t* event); handle mouse motion events. TGFont * GetFont(int iFont); The rendering and layout routines should call this routine in order to; get a font structure. The iFont parameter specifies which of the N_FONT; fonts should be obtained. The font is allocated if necessary. int InArea(TGHtmlMapArea* p, int left, int top, int x, int y); Only support rect and circles for now. TGHtmlElement * GetMap(const char* name); Returns html map element. float ColorDistance(ColorStruct_t* pA, ColorStruct_t* pB); Compute the squared distance between two colors. int GetColorByName(const char* zColor); This routine returns an index between 0 and N_COLOR-1 which indicates; which ColorStruct_t structure in the fApColor[] array should be used to describe; the color specified by the given name. int IsDarkColor(ColorStruct_t* p); Check to see if the given color is too dark to be easily distinguished; from black. int GetDarkShadowColor(int iBgColor); Given that the background color is iBgColor, figure out an; appropriate color for the dark part of a 3D shadow. int IsLightColor(ColorStruct_t* p); Check to s",MatchSource.WIKI,root/html528/TGHtml.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGHtml.html
https://root.cern/root/html528/TGHtml.html:36790,Integrability,rout,routine,36790,"gled() signal. void RadioChanged(const char* name, const char* val); Emit RadioChanged() signal. void InputSelected(const char* name, const char* val); Emit Selected() signal. void SubmitClicked(const char* val); Emit SubmitClicked() signal. Bool_t HandleButton(Event_t* event); Handle mouse button event. Bool_t HandleMotion(Event_t* event); handle mouse motion events. TGFont * GetFont(int iFont); The rendering and layout routines should call this routine in order to; get a font structure. The iFont parameter specifies which of the N_FONT; fonts should be obtained. The font is allocated if necessary. int InArea(TGHtmlMapArea* p, int left, int top, int x, int y); Only support rect and circles for now. TGHtmlElement * GetMap(const char* name); Returns html map element. float ColorDistance(ColorStruct_t* pA, ColorStruct_t* pB); Compute the squared distance between two colors. int GetColorByName(const char* zColor); This routine returns an index between 0 and N_COLOR-1 which indicates; which ColorStruct_t structure in the fApColor[] array should be used to describe; the color specified by the given name. int IsDarkColor(ColorStruct_t* p); Check to see if the given color is too dark to be easily distinguished; from black. int GetDarkShadowColor(int iBgColor); Given that the background color is iBgColor, figure out an; appropriate color for the dark part of a 3D shadow. int IsLightColor(ColorStruct_t* p); Check to see if the given color is too light to be easily distinguished; from white. int GetLightShadowColor(int iBgColor); Given that the background color is iBgColor, figure out an; appropriate color for the bright part of the 3D shadow. int GetColorByValue(ColorStruct_t* pRef); Find a color integer for the color whose color components; are given by pRef. const char * GetHref(int x, int y, const char** target = 0); This routine searchs for a hyperlink beneath the coordinates x,y; and returns a pointer to the HREF for that hyperlink. The text; is held in one of the marku",MatchSource.WIKI,root/html528/TGHtml.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGHtml.html
https://root.cern/root/html528/TGHtml.html:37708,Integrability,rout,routine,37708,"n two colors. int GetColorByName(const char* zColor); This routine returns an index between 0 and N_COLOR-1 which indicates; which ColorStruct_t structure in the fApColor[] array should be used to describe; the color specified by the given name. int IsDarkColor(ColorStruct_t* p); Check to see if the given color is too dark to be easily distinguished; from black. int GetDarkShadowColor(int iBgColor); Given that the background color is iBgColor, figure out an; appropriate color for the dark part of a 3D shadow. int IsLightColor(ColorStruct_t* p); Check to see if the given color is too light to be easily distinguished; from white. int GetLightShadowColor(int iBgColor); Given that the background color is iBgColor, figure out an; appropriate color for the bright part of the 3D shadow. int GetColorByValue(ColorStruct_t* pRef); Find a color integer for the color whose color components; are given by pRef. const char * GetHref(int x, int y, const char** target = 0); This routine searchs for a hyperlink beneath the coordinates x,y; and returns a pointer to the HREF for that hyperlink. The text; is held in one of the markup argv[] fields of the <a> markup. int ElementCoords(TGHtmlElement* p, int i, int pct, int* coords); Return coordinates of item. TGHtmlElement * AttrElem(const char* name, char* value); Returns html element matching attribute name and value. void UpdateSelection(int forceUpdate); Given the selection end-points in fSelBegin and fSelEnd, recompute; pSelBeginBlock and fPSelEndBlock, then call UpdateSelectionDisplay(); to update the display. This routine should be called whenever the selection changes or; whenever the set of TGHtmlBlock structures change. void UpdateSelectionDisplay(); The fPSelStartBlock and fPSelEndBlock values have been changed.; This routine's job is to loop over all TGHtmlBlocks and either; set or clear the HTML_Selected bits in the .fFlags field; as appropriate. For every TGHtmlBlock where the bit changes,; mark that block for redrawing. voi",MatchSource.WIKI,root/html528/TGHtml.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGHtml.html
https://root.cern/root/html528/TGHtml.html:38307,Integrability,rout,routine,38307," white. int GetLightShadowColor(int iBgColor); Given that the background color is iBgColor, figure out an; appropriate color for the bright part of the 3D shadow. int GetColorByValue(ColorStruct_t* pRef); Find a color integer for the color whose color components; are given by pRef. const char * GetHref(int x, int y, const char** target = 0); This routine searchs for a hyperlink beneath the coordinates x,y; and returns a pointer to the HREF for that hyperlink. The text; is held in one of the markup argv[] fields of the <a> markup. int ElementCoords(TGHtmlElement* p, int i, int pct, int* coords); Return coordinates of item. TGHtmlElement * AttrElem(const char* name, char* value); Returns html element matching attribute name and value. void UpdateSelection(int forceUpdate); Given the selection end-points in fSelBegin and fSelEnd, recompute; pSelBeginBlock and fPSelEndBlock, then call UpdateSelectionDisplay(); to update the display. This routine should be called whenever the selection changes or; whenever the set of TGHtmlBlock structures change. void UpdateSelectionDisplay(); The fPSelStartBlock and fPSelEndBlock values have been changed.; This routine's job is to loop over all TGHtmlBlocks and either; set or clear the HTML_Selected bits in the .fFlags field; as appropriate. For every TGHtmlBlock where the bit changes,; mark that block for redrawing. void LostSelection(); Clear selection. int SelectionSet(const char* startIx, const char* endIx); Set selection. void UpdateInsert(); Recompute the position of the insertion cursor based on the; position in fIns. int SetInsert(const char* insIx); Set the position of the insertion cursor. void SavePrimitive(ostream& out, Option_t* = """"); Save a html widget as a C++ statement(s) on output stream out. Bool_t ProcessMessage(Long_t , Long_t , Long_t ). int GetTableRelief() const; { return fTableRelief; }. int GetRuleRelief() const; { return fRuleRelief; }. int GetRulePadding() const; { return fRulePadding; }. const char * GetBas",MatchSource.WIKI,root/html528/TGHtml.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGHtml.html
https://root.cern/root/html528/TGHtml.html:38519,Integrability,rout,routine,38519,"d a color integer for the color whose color components; are given by pRef. const char * GetHref(int x, int y, const char** target = 0); This routine searchs for a hyperlink beneath the coordinates x,y; and returns a pointer to the HREF for that hyperlink. The text; is held in one of the markup argv[] fields of the <a> markup. int ElementCoords(TGHtmlElement* p, int i, int pct, int* coords); Return coordinates of item. TGHtmlElement * AttrElem(const char* name, char* value); Returns html element matching attribute name and value. void UpdateSelection(int forceUpdate); Given the selection end-points in fSelBegin and fSelEnd, recompute; pSelBeginBlock and fPSelEndBlock, then call UpdateSelectionDisplay(); to update the display. This routine should be called whenever the selection changes or; whenever the set of TGHtmlBlock structures change. void UpdateSelectionDisplay(); The fPSelStartBlock and fPSelEndBlock values have been changed.; This routine's job is to loop over all TGHtmlBlocks and either; set or clear the HTML_Selected bits in the .fFlags field; as appropriate. For every TGHtmlBlock where the bit changes,; mark that block for redrawing. void LostSelection(); Clear selection. int SelectionSet(const char* startIx, const char* endIx); Set selection. void UpdateInsert(); Recompute the position of the insertion cursor based on the; position in fIns. int SetInsert(const char* insIx); Set the position of the insertion cursor. void SavePrimitive(ostream& out, Option_t* = """"); Save a html widget as a C++ statement(s) on output stream out. Bool_t ProcessMessage(Long_t , Long_t , Long_t ). int GetTableRelief() const; { return fTableRelief; }. int GetRuleRelief() const; { return fRuleRelief; }. int GetRulePadding() const; { return fRulePadding; }. const char * GetBaseUri() const; { return fZBase; }. char * ResolveUri(const char* uri); User function to resolve URIs. TImage * LoadImage(const char* uri, int w = 0, int h = 0); User function to get an image from a URL. int Is",MatchSource.WIKI,root/html528/TGHtml.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGHtml.html
https://root.cern/root/html528/TGHtml.html:23519,Performance,cache,cache,23519,"p); const char*TypeToName(int type); voidUnlinkAndFreeBlock(TGHtmlBlock* pBlock); voidUnmapControls(); virtual voidUpdateBackgroundStart(); voidUpdateInsert(); virtual voidTGView::UpdateRegion(Int_t x, Int_t y, UInt_t w, UInt_t h); voidUpdateSelection(int forceUpdate); voidUpdateSelectionDisplay(). Data Members; public:. enum TGView::[unnamed] { kNoHSB; kNoVSB; kHorizontal; kVertical; };; enum TGFrame::[unnamed] { kDeleteWindowCalled; };; enum TGWindow::EEditMode { kEditEnable; kEditDisable; kEditDisableEvents; kEditDisableGrab; kEditDisableLayout; kEditDisableResize; kEditDisableHeight; kEditDisableWidth; kEditDisableBtnEnable; kEditDisableKeyEnable; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TGFont*fAFont[71]Information about all screen fonts; GcCache_tfAGcCache[32]A cache of GCs for general use; intfAddEndTagsTRUE if we add /LI etc.; intfAnchorFlagsStyle flags associated with <A>...</A>; TGHtmlAnchor*fAnchorStartMost recent <a href=...>; ColorStruct_t*fApColor[32]Information about all colors; Pixel_tTGFrame::fBackgroundframe background color; ColorStruct_t*fBgColorBackground color of the HTML document; TImage*fBgImageBackground image; Int_tTGFrame::fBorderWidthframe border width; TGViewFrame*TGView::fCanvasframe containing the text; TGClient*TGObject::fClientConnection to display server; Atom_tTGView::fClipboardclipboard property; Long_tfColorUsedbit N is 1 if color N is in use. Only; TStringTGWidget::fCommandcommand to be executed; Cursor_tfCursorCurrent cursor for window, or None.; Int_tTGFrame::fDNDStateEDNDFlags; intfDirtyBottomBottom right corner of region to redraw; intfDirtyLeft; intfDirtyRight; intfDirtyTopTop left corner of region to redraw. These; UInt_tTGWindow::fEditDisabledflags used for ""guibuilding""; UInt_tTGFrame::fEventMaskcu",MatchSource.WIKI,root/html528/TGHtml.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGHtml.html
https://root.cern/root/html528/TGHtml.html:32086,Performance,load,loading,32086,"*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGHtml(const TGWindow* p, int w, int h, int id = -1); HTML Widget constructor. ~TGHtml(); HTML widget destructor. void UpdateBackgroundStart(); Start background update. void FreeColor(ColorStruct_t* color); Free system color. ColorStruct_t * AllocColor(const char* name); Allocate system color by name. ColorStruct_t * AllocColorByValue(ColorStruct_t* color); Allocate system color by value. void Clear(Option_t* = """"); Erase all HTML from this widget and clear the screen. This is; typically done before loading a new document. int ParseText(char* text, const char* index = 0); Appends (or insert at the specified position) the given HTML text to the; end of any HTML text that may have been inserted by prior calls to this; command. Then it runs the tokenizer, parser and layout engine as far as; possible with the text that is available. The display is updated; appropriately. void SetTableRelief(int relief); Sets relief mode of html table. void SetRuleRelief(int relief); Sets relief mode of html rule. void UnderlineLinks(int onoff); Set/reset html links underline. void SetBaseUri(const char* uri); Sets base URI. int GotoAnchor(const char* name); Go to anchor position. const char * GetUid(const char* string); Given a string, this procedure returns a unique identifier for the; string. This procedure returns a pointer to a new char string corresponding to; the ""string"" argument. The new string has a value identical to string; (strcmp will return 0), but it's guaranteed that any other call",MatchSource.WIKI,root/html528/TGHtml.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGHtml.html
https://root.cern/root/html528/TGHtml.html:33366,Performance,cache,cache,33366,"ayout engine as far as; possible with the text that is available. The display is updated; appropriately. void SetTableRelief(int relief); Sets relief mode of html table. void SetRuleRelief(int relief); Sets relief mode of html rule. void UnderlineLinks(int onoff); Set/reset html links underline. void SetBaseUri(const char* uri); Sets base URI. int GotoAnchor(const char* name); Go to anchor position. const char * GetUid(const char* string); Given a string, this procedure returns a unique identifier for the; string. This procedure returns a pointer to a new char string corresponding to; the ""string"" argument. The new string has a value identical to string; (strcmp will return 0), but it's guaranteed that any other calls to this; procedure with a string equal to ""string"" will return exactly the same; result (i.e. can compare pointer *values* directly, without having to; call strcmp on what they point to). void ComputeVirtualSize(); Computes virtual size of html area. void ClearGcCache(); Clear the cache of GCs. void ResetLayoutContext(); Reset the main layout context in the main widget. This happens; before we redo the layout, or just before deleting the widget. void Redraw(); This routine is invoked in order to redraw all or part of the HTML; widget. This might happen because the display has changed, or in; response to an expose event. In all cases, though, this routine; is called by an idle handler. void ScheduleRedraw(); Make sure that a call to the Redraw() routine has been queued. Bool_t HandleIdleEvent(TGIdleHandler* i); Handles idle event. void RedrawArea(int left, int top, int right, int bottom); If any part of the screen needs to be redrawn, then call this routine; with the values of a box (in window coordinates) that needs to be; redrawn. This routine will schedule an idle handler to do the redraw. The box coordinates are relative to the clipping window (fCanvas). void DrawRegion(Int_t x, Int_t y, UInt_t w, UInt_t h); Draw region defined by [x,y] [w,h]. Bool_t",MatchSource.WIKI,root/html528/TGHtml.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGHtml.html
https://root.cern/root/html528/TGHtml.html:33856,Performance,queue,queued,33856," procedure returns a unique identifier for the; string. This procedure returns a pointer to a new char string corresponding to; the ""string"" argument. The new string has a value identical to string; (strcmp will return 0), but it's guaranteed that any other calls to this; procedure with a string equal to ""string"" will return exactly the same; result (i.e. can compare pointer *values* directly, without having to; call strcmp on what they point to). void ComputeVirtualSize(); Computes virtual size of html area. void ClearGcCache(); Clear the cache of GCs. void ResetLayoutContext(); Reset the main layout context in the main widget. This happens; before we redo the layout, or just before deleting the widget. void Redraw(); This routine is invoked in order to redraw all or part of the HTML; widget. This might happen because the display has changed, or in; response to an expose event. In all cases, though, this routine; is called by an idle handler. void ScheduleRedraw(); Make sure that a call to the Redraw() routine has been queued. Bool_t HandleIdleEvent(TGIdleHandler* i); Handles idle event. void RedrawArea(int left, int top, int right, int bottom); If any part of the screen needs to be redrawn, then call this routine; with the values of a box (in window coordinates) that needs to be; redrawn. This routine will schedule an idle handler to do the redraw. The box coordinates are relative to the clipping window (fCanvas). void DrawRegion(Int_t x, Int_t y, UInt_t w, UInt_t h); Draw region defined by [x,y] [w,h]. Bool_t ItemLayout(); Layout html widget. void RedrawBlock(TGHtmlBlock* p); Redraw the TGHtmlBlock given. void RedrawEverything(); Call this routine to force the entire widget to be redrawn. void RedrawText(int y); Call this routine to cause all of the rendered HTML at the; virtual canvas coordinate of Y and beyond to be redrawn. void HClear(); Erase all data from the HTML widget. Bring it back to an empty screen. Bool_t HandleTimer(TTimer* timer); Handle timer even",MatchSource.WIKI,root/html528/TGHtml.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGHtml.html
https://root.cern/root/html528/TGHtml.html:34931,Performance,cache,cache,34931,"); Handles idle event. void RedrawArea(int left, int top, int right, int bottom); If any part of the screen needs to be redrawn, then call this routine; with the values of a box (in window coordinates) that needs to be; redrawn. This routine will schedule an idle handler to do the redraw. The box coordinates are relative to the clipping window (fCanvas). void DrawRegion(Int_t x, Int_t y, UInt_t w, UInt_t h); Draw region defined by [x,y] [w,h]. Bool_t ItemLayout(); Layout html widget. void RedrawBlock(TGHtmlBlock* p); Redraw the TGHtmlBlock given. void RedrawEverything(); Call this routine to force the entire widget to be redrawn. void RedrawText(int y); Call this routine to cause all of the rendered HTML at the; virtual canvas coordinate of Y and beyond to be redrawn. void HClear(); Erase all data from the HTML widget. Bring it back to an empty screen. Bool_t HandleTimer(TTimer* timer); Handle timer event. void FlashCursor(); Flash the insertion cursor. GContext_t GetGC(int color, int font); Return a GC from the cache. As many as N_CACHE_GCs are kept valid; at any one time. They are replaced using an LRU algorithm. A value of FONT_Any (-1) for the font means ""don't care"". GContext_t GetAnyGC(); Retrieve any valid GC. The font and color don't matter since the; GC will only be used for copying. Bool_t HandleFocusChange(Event_t* event); Handle focus change event. TGHtmlInput * GetInputElement(int x, int y); This routine searchs for a hyperlink beneath the coordinates x,y; and returns a pointer to the HREF for that hyperlink. The text; is held in one of the markup argv[] fields of the <a> markup. Bool_t HandleHtmlInput(TGHtmlInput* pr, Event_t* event); Handle html input (button, checkbox, ...) event. Bool_t HandleRadioButton(TGHtmlInput* p); Handle radio button event. void ButtonClicked(const char* name, const char* val); Emit ButtonClicked() signal. void CheckToggled(const char* name, Bool_t on, const char* val); Emit CheckToggled() signal. void RadioChanged(const char*",MatchSource.WIKI,root/html528/TGHtml.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGHtml.html
https://root.cern/root/html528/TGHtml.html:33698,Security,expose,expose,33698,"i(const char* uri); Sets base URI. int GotoAnchor(const char* name); Go to anchor position. const char * GetUid(const char* string); Given a string, this procedure returns a unique identifier for the; string. This procedure returns a pointer to a new char string corresponding to; the ""string"" argument. The new string has a value identical to string; (strcmp will return 0), but it's guaranteed that any other calls to this; procedure with a string equal to ""string"" will return exactly the same; result (i.e. can compare pointer *values* directly, without having to; call strcmp on what they point to). void ComputeVirtualSize(); Computes virtual size of html area. void ClearGcCache(); Clear the cache of GCs. void ResetLayoutContext(); Reset the main layout context in the main widget. This happens; before we redo the layout, or just before deleting the widget. void Redraw(); This routine is invoked in order to redraw all or part of the HTML; widget. This might happen because the display has changed, or in; response to an expose event. In all cases, though, this routine; is called by an idle handler. void ScheduleRedraw(); Make sure that a call to the Redraw() routine has been queued. Bool_t HandleIdleEvent(TGIdleHandler* i); Handles idle event. void RedrawArea(int left, int top, int right, int bottom); If any part of the screen needs to be redrawn, then call this routine; with the values of a box (in window coordinates) that needs to be; redrawn. This routine will schedule an idle handler to do the redraw. The box coordinates are relative to the clipping window (fCanvas). void DrawRegion(Int_t x, Int_t y, UInt_t w, UInt_t h); Draw region defined by [x,y] [w,h]. Bool_t ItemLayout(); Layout html widget. void RedrawBlock(TGHtmlBlock* p); Redraw the TGHtmlBlock given. void RedrawEverything(); Call this routine to force the entire widget to be redrawn. void RedrawText(int y); Call this routine to cause all of the rendered HTML at the; virtual canvas coordinate of Y and beyond t",MatchSource.WIKI,root/html528/TGHtml.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGHtml.html
https://root.cern/root/html528/TGHtml.html:32037,Usability,clear,clear,32037,"tatic Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGHtml(const TGWindow* p, int w, int h, int id = -1); HTML Widget constructor. ~TGHtml(); HTML widget destructor. void UpdateBackgroundStart(); Start background update. void FreeColor(ColorStruct_t* color); Free system color. ColorStruct_t * AllocColor(const char* name); Allocate system color by name. ColorStruct_t * AllocColorByValue(ColorStruct_t* color); Allocate system color by value. void Clear(Option_t* = """"); Erase all HTML from this widget and clear the screen. This is; typically done before loading a new document. int ParseText(char* text, const char* index = 0); Appends (or insert at the specified position) the given HTML text to the; end of any HTML text that may have been inserted by prior calls to this; command. Then it runs the tokenizer, parser and layout engine as far as; possible with the text that is available. The display is updated; appropriately. void SetTableRelief(int relief); Sets relief mode of html table. void SetRuleRelief(int relief); Sets relief mode of html rule. void UnderlineLinks(int onoff); Set/reset html links underline. void SetBaseUri(const char* uri); Sets base URI. int GotoAnchor(const char* name); Go to anchor position. const char * GetUid(const char* string); Given a string, this procedure returns a unique identifier for the; string. This procedure returns a pointer to a new char string corresponding to; the ""string"" argument. The new string has a value identical to st",MatchSource.WIKI,root/html528/TGHtml.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGHtml.html
https://root.cern/root/html528/TGHtml.html:38585,Usability,clear,clear,38585,"d a color integer for the color whose color components; are given by pRef. const char * GetHref(int x, int y, const char** target = 0); This routine searchs for a hyperlink beneath the coordinates x,y; and returns a pointer to the HREF for that hyperlink. The text; is held in one of the markup argv[] fields of the <a> markup. int ElementCoords(TGHtmlElement* p, int i, int pct, int* coords); Return coordinates of item. TGHtmlElement * AttrElem(const char* name, char* value); Returns html element matching attribute name and value. void UpdateSelection(int forceUpdate); Given the selection end-points in fSelBegin and fSelEnd, recompute; pSelBeginBlock and fPSelEndBlock, then call UpdateSelectionDisplay(); to update the display. This routine should be called whenever the selection changes or; whenever the set of TGHtmlBlock structures change. void UpdateSelectionDisplay(); The fPSelStartBlock and fPSelEndBlock values have been changed.; This routine's job is to loop over all TGHtmlBlocks and either; set or clear the HTML_Selected bits in the .fFlags field; as appropriate. For every TGHtmlBlock where the bit changes,; mark that block for redrawing. void LostSelection(); Clear selection. int SelectionSet(const char* startIx, const char* endIx); Set selection. void UpdateInsert(); Recompute the position of the insertion cursor based on the; position in fIns. int SetInsert(const char* insIx); Set the position of the insertion cursor. void SavePrimitive(ostream& out, Option_t* = """"); Save a html widget as a C++ statement(s) on output stream out. Bool_t ProcessMessage(Long_t , Long_t , Long_t ). int GetTableRelief() const; { return fTableRelief; }. int GetRuleRelief() const; { return fRuleRelief; }. int GetRulePadding() const; { return fRulePadding; }. const char * GetBaseUri() const; { return fZBase; }. char * ResolveUri(const char* uri); User function to resolve URIs. TImage * LoadImage(const char* uri, int w = 0, int h = 0); User function to get an image from a URL. int Is",MatchSource.WIKI,root/html528/TGHtml.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGHtml.html
https://root.cern/root/html528/TGHtmlBrowser.html:4417,Availability,error,error,4417,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; voidForward(); virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); TList*TGMainFrame::GetBindList() const; static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; voidTGMainFrame::GetClassHints(const char*& className, const char*& resourceName) const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDe",MatchSource.WIKI,root/html528/TGHtmlBrowser.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGHtmlBrowser.html
https://root.cern/root/html528/TGHtmlBrowser.html:4501,Availability,error,error,4501,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; voidForward(); virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); TList*TGMainFrame::GetBindList() const; static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; voidTGMainFrame::GetClassHints(const char*& className, const char*& resourceName) const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() con",MatchSource.WIKI,root/html528/TGHtmlBrowser.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGHtmlBrowser.html
https://root.cern/root/html528/TGHtmlBrowser.html:18666,Availability,mask,mask,18666,,MatchSource.WIKI,root/html528/TGHtmlBrowser.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGHtmlBrowser.html
https://root.cern/root/html528/TGHtmlBrowser.html:328,Usability,simpl,simple,328,". TGHtmlBrowser. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUIHTML; » TGHtmlBrowser. class TGHtmlBrowser: public TGMainFrame. TGHtmlBrowser. A very simple HTML browser. Function Members (Methods); public:. TGHtmlBrowser(const char* filename = 0, const TGWindow* p = 0, UInt_t w = 900, UInt_t h = 600); virtual~TGHtmlBrowser(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; voidBack(); virtual Bool_tTGMainFrame::BindKey(const TGWindow* w, Int_t keycode, Int_t modifier) const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidTGCompositeFrame::ChangeSubframesBackground(Pixel_t back); Bool_tCheckAnchors(const char*); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTGCompositeFrame::Cleanup(); virtual voidTObject::Clear(Option_t* = """"); voidClicked(char* uri)SIGNAL ; virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidTGMainFrame::CloseWindow()SIGNAL ; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* r",MatchSource.WIKI,root/html528/TGHtmlBrowser.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGHtmlBrowser.html
https://root.cern/root/html528/TGIcon.html:4070,Availability,error,error,4070,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionGetDefaultSize() const; virtual UInt_tTGFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType() const; virtual Option_t*TObjec",MatchSource.WIKI,root/html528/TGIcon.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGIcon.html
https://root.cern/root/html528/TGIcon.html:4154,Availability,error,error,4154,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionGetDefaultSize() const; virtual UInt_tTGFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType() const; virtual Option_t*TObject::GetDrawOption() const; virtual Int_tTGFrame::GetDropType() const; static Long_tTO",MatchSource.WIKI,root/html528/TGIcon.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGIcon.html
https://root.cern/root/html528/TGIcon.html:15302,Availability,mask,mask,15302,"ected:. Pixel_tTGFrame::fBackgroundframe background color; Int_tTGFrame::fBorderWidthframe border width; TGClient*TGObject::fClientConnection to display server; Int_tTGFrame::fDNDStateEDNDFlags; UInt_tTGWindow::fEditDisabledflags used for ""guibuilding""; UInt_tTGFrame::fEventMaskcurrenty active event mask; TGFrameElement*TGFrame::fFEpointer to frame element; UInt_tTGFrame::fHeightframe height; Handle_tTGObject::fIdX11/Win32 Window identifier; TImage*fImageimage; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; UInt_tTGFrame::fMaxHeightmaximal frame height; UInt_tTGFrame::fMaxWidthmaximal frame width; UInt_tTGFrame::fMinHeightminimal frame height; UInt_tTGFrame::fMinWidthminimal frame width; TStringTGWindow::fNamename of the window used in SavePrimitive(); Bool_tTGWindow::fNeedRedrawkTRUE if window needs to be redrawn; UInt_tTGFrame::fOptionsframe options; const TGWindow*TGWindow::fParentParent window; TStringfPathdirectory of image; const TGPicture*fPicicon picture; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; UInt_tTGFrame::fWidthframe width; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class ",MatchSource.WIKI,root/html528/TGIcon.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGIcon.html
https://root.cern/root/html528/TGIconLBEntry.html:4658,Availability,error,error,4658,"st char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); Int_tTGLBEntry::EntryId() const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static FontStruct_tTGTextLBEntry::GetDefaultFontStruct(); static Pixel_tTGFrame::GetDefaultFrameBackground(); static const TGGC&TGTextLBEntry::GetDefaultGC(); virtual UInt_tTGFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionGetDefaultSize() const; virtual UInt_tTGFrame::GetDefaultWidth() const; virtu",MatchSource.WIKI,root/html528/TGIconLBEntry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGIconLBEntry.html
https://root.cern/root/html528/TGIconLBEntry.html:4742,Availability,error,error,4742,"m); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); Int_tTGLBEntry::EntryId() const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static FontStruct_tTGTextLBEntry::GetDefaultFontStruct(); static Pixel_tTGFrame::GetDefaultFrameBackground(); static const TGGC&TGTextLBEntry::GetDefaultGC(); virtual UInt_tTGFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionGetDefaultSize() const; virtual UInt_tTGFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType() const; ",MatchSource.WIKI,root/html528/TGIconLBEntry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGIconLBEntry.html
https://root.cern/root/html528/TGIconLBEntry.html:16366,Availability,mask,mask,16366,,MatchSource.WIKI,root/html528/TGIconLBEntry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGIconLBEntry.html
https://root.cern/root/html528/TGIconLBEntry.html:421,Usability,simpl,simple,421,". TGIconLBEntry. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file. viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGIconLBEntry. class TGIconLBEntry: public TGTextLBEntry. TGListBox, TGLBContainer, TGLBEntry and TGTextLBEntry. A listbox is a box, possibly with scrollbar, containing entries.; Currently entries are simple text strings (TGTextLBEntry).; A TGListBox looks a lot like a TGCanvas. It has a TGViewPort; containing a TGLBContainer which contains the entries and it also; has a vertical scrollbar which becomes visible if there are more; items than fit in the visible part of the container. The TGListBox is user callable. The other classes are service; classes of the listbox. Selecting an item in the listbox will generate the event:; kC_COMMAND, kCM_LISTBOX, listbox id, item id. Function Members (Methods); public:. TGIconLBEntry(const TGWindow* p = 0, Int_t id = -1, const char* str = 0, const TGPicture* pic = 0, UInt_t w = 0, Style_t s = 0, UInt_t options = kHorizontalFrame, Pixel_t back = GetWhitePixel()); virtual~TGIconLBEntry(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGLBEntry::Activate(Bool_t a); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGFrame::ChangeOptions(UInt_t options); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Co",MatchSource.WIKI,root/html528/TGIconLBEntry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGIconLBEntry.html
https://root.cern/root/html528/TGIdleHandler.html:1440,Availability,error,error,1440,"eHandler(TGWindow* w); TGIdleHandler(const TGIdleHandler&); virtual~TGIdleHandler(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tHandleEvent(); virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFr",MatchSource.WIKI,root/html528/TGIdleHandler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGIdleHandler.html
https://root.cern/root/html528/TGIdleHandler.html:1524,Availability,error,error,1524," voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tHandleEvent(); virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* c",MatchSource.WIKI,root/html528/TGIdleHandler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGIdleHandler.html
https://root.cern/root/html528/TGImageMap.html:4417,Availability,error,error,4417,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; const char*TGWidget::GetCommand() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); static const TGGC&TGButton::GetDefaultGC(); virtual UInt_tTGFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGFrame::GetDefaultSize() const; virtual UInt_tTGFrame::GetDefaultWidth() const; const TGPicture*TG",MatchSource.WIKI,root/html528/TGImageMap.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGImageMap.html
https://root.cern/root/html528/TGImageMap.html:4501,Availability,error,error,4501,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; const char*TGWidget::GetCommand() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); static const TGGC&TGButton::GetDefaultGC(); virtual UInt_tTGFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGFrame::GetDefaultSize() const; virtual UInt_tTGFrame::GetDefaultWidth() const; const TGPicture*TGPictureButton::GetDisabledPicture() const; virtual TDNDData*TGFrame::GetDNDData(Atom",MatchSource.WIKI,root/html528/TGImageMap.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGImageMap.html
https://root.cern/root/html528/TGImageMap.html:17784,Availability,mask,mask,17784,,MatchSource.WIKI,root/html528/TGImageMap.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGImageMap.html
https://root.cern/root/html528/TGImageMap.html:19239,Availability,down,down,19239,tip text for main region; UInt_tTGFrame::fMaxHeightmaximal frame height; UInt_tTGFrame::fMaxWidthmaximal frame width; UInt_tTGFrame::fMinHeightminimal frame height; UInt_tTGFrame::fMinWidthminimal frame width; const TGWindow*TGWidget::fMsgWindowwindow which handles widget events; TStringTGWindow::fNamename of the window used in SavePrimitive(); TGImageMap::ENavModefNavModenavigation mode; Bool_tTGWindow::fNeedRedrawkTRUE if window needs to be redrawn; GContext_tTGButton::fNormGCgraphics context used for drawing button; UInt_tTGFrame::fOptionsframe options; Bool_tTGPictureButton::fOwnDisabledPickTRUE if disabled picture was autogenerated; const TGWindow*TGWindow::fParentParent window; const TGPicture*TGPictureButton::fPicpicture to be put in button; const TGPicture*TGPictureButton::fPicDpicture shown when button disabled; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; EButtonStateTGButton::fStatebutton state; Bool_tTGButton::fStayDowntrue if button has to stay down; UInt_tTGButton::fTHeightbutton height; UInt_tTGButton::fTWidthbutton width; TGToolTip*TGButton::fTiptool tip associated with button; TList*fTrashcollect all objects that need to be cleaned up; void*TGButton::fUserDatapointer to user data structure; Int_tTGWidget::fWidgetFlagswidget status flags (OR of EWidgetStatus); Int_tTGWidget::fWidgetIdthe widget id (used for event processing); UInt_tTGFrame::fWidthframe width; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static const TGGC*TGButton::fgDefaultGC; static Pixel_tTGFrame::fgDefaultSelectedBackground; static,MatchSource.WIKI,root/html528/TGImageMap.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGImageMap.html
https://root.cern/root/html528/TGImageMap.html:20465,Deployability,release,released,20465,de; Bool_tTGWindow::fNeedRedrawkTRUE if window needs to be redrawn; GContext_tTGButton::fNormGCgraphics context used for drawing button; UInt_tTGFrame::fOptionsframe options; Bool_tTGPictureButton::fOwnDisabledPickTRUE if disabled picture was autogenerated; const TGWindow*TGWindow::fParentParent window; const TGPicture*TGPictureButton::fPicpicture to be put in button; const TGPicture*TGPictureButton::fPicDpicture shown when button disabled; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; EButtonStateTGButton::fStatebutton state; Bool_tTGButton::fStayDowntrue if button has to stay down; UInt_tTGButton::fTHeightbutton height; UInt_tTGButton::fTWidthbutton width; TGToolTip*TGButton::fTiptool tip associated with button; TList*fTrashcollect all objects that need to be cleaned up; void*TGButton::fUserDatapointer to user data structure; Int_tTGWidget::fWidgetFlagswidget status flags (OR of EWidgetStatus); Int_tTGWidget::fWidgetIdthe widget id (used for event processing); UInt_tTGFrame::fWidthframe width; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static const TGGC*TGButton::fgDefaultGC; static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGButton::fgHibckgndGC; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static Window_tTGButton::fgReleaseBtnthe last released button; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel.,MatchSource.WIKI,root/html528/TGImageMap.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGImageMap.html
https://root.cern/root/html528/TGInputDialog.html:4520,Availability,error,error,4520,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); TList*TGMainFrame::GetBindList() const; static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; voidTGMainFrame::GetClassHints(const char*& className, const char*& resourceName) const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBa",MatchSource.WIKI,root/html528/TGInputDialog.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGInputDialog.html
https://root.cern/root/html528/TGInputDialog.html:4604,Availability,error,error,4604,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); TList*TGMainFrame::GetBindList() const; static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; voidTGMainFrame::GetClassHints(const char*& className, const char*& resourceName) const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UIn",MatchSource.WIKI,root/html528/TGInputDialog.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGInputDialog.html
https://root.cern/root/html528/TGInputDialog.html:18761,Availability,mask,mask,18761,,MatchSource.WIKI,root/html528/TGInputDialog.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGInputDialog.html
https://root.cern/root/html528/TGInputDialog.html:22588,Energy Efficiency,allocate,allocated,22588,"kground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. private:. TGTextButton*fCancelcancel button; TGLabel*fLabeltext entry label; TGTextButton*fOkok button; char*fRetStraddress to store return string; TGTextEntry*fTEtext entry widget. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGInputDialog(const TGWindow* p = 0, const TGWindow* main = 0, const char* prompt = 0, const char* defval = 0, char* retstr = 0, UInt_t options = kVerticalFrame); Create simple input dialog. It is important to know that the case where the constructor in; which all the variables are initialized to their default values is; only used for the TBrowser to inspect on the classes. For normal; use the only variable that should be free is options. Variables prompt, defval are the content of the input dialog while; retstr has to be initialized to a char[256]. In case these are not; initialized, they will show default values while retstr will be; automatically allocated by the dialog. However this will make; impossible to retrieve the value entered by the dialog. To see TGInputDialog in use see:; $ROOTSYS/tutorials/testInputDialog.cxx. ~TGInputDialog(); Cleanup dialog. Bool_t ProcessMessage(Long_t msg, Long_t parm1, Long_t ); Handle button and text enter events. TGInputDialog(const TGInputDialog& ). TGInputDialog & operator=(const TGInputDialog& ). » Author: David Gonzalez Maline 19/07/2006 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id: TGInputDialog.h 23115 2008-04-10 13:35:37Z rdm $ » Last generated: 2010-09-23 20:06; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html528/TGInputDialog.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGInputDialog.html
https://root.cern/root/html528/TGInputDialog.html:22199,Modifiability,variab,variables,22199,"ameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. private:. TGTextButton*fCancelcancel button; TGLabel*fLabeltext entry label; TGTextButton*fOkok button; char*fRetStraddress to store return string; TGTextEntry*fTEtext entry widget. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGInputDialog(const TGWindow* p = 0, const TGWindow* main = 0, const char* prompt = 0, const char* defval = 0, char* retstr = 0, UInt_t options = kVerticalFrame); Create simple input dialog. It is important to know that the case where the constructor in; which all the variables are initialized to their default values is; only used for the TBrowser to inspect on the classes. For normal; use the only variable that should be free is options. Variables prompt, defval are the content of the input dialog while; retstr has to be initialized to a char[256]. In case these are not; initialized, they will show default values while retstr will be; automatically allocated by the dialog. However this will make; impossible to retrieve the value entered by the dialog. To see TGInputDialog in use see:; $ROOTSYS/tutorials/testInputDialog.cxx. ~TGInputDialog(); Cleanup dialog. Bool_t ProcessMessage(Long_t msg, Long_t parm1, Long_t ); Handle button and text enter events. TGInputDialog(const TGInputDialog& ). TGInputDialog & operator=(const TGInputDialog& ). » Author: David Gonzalez Maline 19/07/2006 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id: TGInputDialog.h 23115 2008-04-10 13:35:37Z rdm $ » Last generated: 2010-09-23 20:06; This page ",MatchSource.WIKI,root/html528/TGInputDialog.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGInputDialog.html
https://root.cern/root/html528/TGInputDialog.html:22332,Modifiability,variab,variable,22332,"gDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. private:. TGTextButton*fCancelcancel button; TGLabel*fLabeltext entry label; TGTextButton*fOkok button; char*fRetStraddress to store return string; TGTextEntry*fTEtext entry widget. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGInputDialog(const TGWindow* p = 0, const TGWindow* main = 0, const char* prompt = 0, const char* defval = 0, char* retstr = 0, UInt_t options = kVerticalFrame); Create simple input dialog. It is important to know that the case where the constructor in; which all the variables are initialized to their default values is; only used for the TBrowser to inspect on the classes. For normal; use the only variable that should be free is options. Variables prompt, defval are the content of the input dialog while; retstr has to be initialized to a char[256]. In case these are not; initialized, they will show default values while retstr will be; automatically allocated by the dialog. However this will make; impossible to retrieve the value entered by the dialog. To see TGInputDialog in use see:; $ROOTSYS/tutorials/testInputDialog.cxx. ~TGInputDialog(); Cleanup dialog. Bool_t ProcessMessage(Long_t msg, Long_t parm1, Long_t ); Handle button and text enter events. TGInputDialog(const TGInputDialog& ). TGInputDialog & operator=(const TGInputDialog& ). » Author: David Gonzalez Maline 19/07/2006 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id: TGInputDialog.h 23115 2008-04-10 13:35:37Z rdm $ » Last generated: 2010-09-23 20:06; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mai",MatchSource.WIKI,root/html528/TGInputDialog.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGInputDialog.html
https://root.cern/root/html528/TGInputDialog.html:22746,Testability,test,testInputDialog,22746,"kground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. private:. TGTextButton*fCancelcancel button; TGLabel*fLabeltext entry label; TGTextButton*fOkok button; char*fRetStraddress to store return string; TGTextEntry*fTEtext entry widget. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGInputDialog(const TGWindow* p = 0, const TGWindow* main = 0, const char* prompt = 0, const char* defval = 0, char* retstr = 0, UInt_t options = kVerticalFrame); Create simple input dialog. It is important to know that the case where the constructor in; which all the variables are initialized to their default values is; only used for the TBrowser to inspect on the classes. For normal; use the only variable that should be free is options. Variables prompt, defval are the content of the input dialog while; retstr has to be initialized to a char[256]. In case these are not; initialized, they will show default values while retstr will be; automatically allocated by the dialog. However this will make; impossible to retrieve the value entered by the dialog. To see TGInputDialog in use see:; $ROOTSYS/tutorials/testInputDialog.cxx. ~TGInputDialog(); Cleanup dialog. Bool_t ProcessMessage(Long_t msg, Long_t parm1, Long_t ); Handle button and text enter events. TGInputDialog(const TGInputDialog& ). TGInputDialog & operator=(const TGInputDialog& ). » Author: David Gonzalez Maline 19/07/2006 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id: TGInputDialog.h 23115 2008-04-10 13:35:37Z rdm $ » Last generated: 2010-09-23 20:06; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html528/TGInputDialog.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGInputDialog.html
https://root.cern/root/html528/TGInputDialog.html:22100,Usability,simpl,simple,22100,"el; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. private:. TGTextButton*fCancelcancel button; TGLabel*fLabeltext entry label; TGTextButton*fOkok button; char*fRetStraddress to store return string; TGTextEntry*fTEtext entry widget. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGInputDialog(const TGWindow* p = 0, const TGWindow* main = 0, const char* prompt = 0, const char* defval = 0, char* retstr = 0, UInt_t options = kVerticalFrame); Create simple input dialog. It is important to know that the case where the constructor in; which all the variables are initialized to their default values is; only used for the TBrowser to inspect on the classes. For normal; use the only variable that should be free is options. Variables prompt, defval are the content of the input dialog while; retstr has to be initialized to a char[256]. In case these are not; initialized, they will show default values while retstr will be; automatically allocated by the dialog. However this will make; impossible to retrieve the value entered by the dialog. To see TGInputDialog in use see:; $ROOTSYS/tutorials/testInputDialog.cxx. ~TGInputDialog(); Cleanup dialog. Bool_t ProcessMessage(Long_t msg, Long_t parm1, Long_t ); Handle button and text enter events. TGInputDialog(const TGInputDialog& ). TGInputDialog & operator=(const TGInputDialog& ). » Author: David Gonzalez Mali",MatchSource.WIKI,root/html528/TGInputDialog.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGInputDialog.html
https://root.cern/root/html528/TGL5DDataSet.html:1287,Availability,error,error,1287," TGL5DDataSet(TTree* inputData); ~TGL5DDataSet(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() cons",MatchSource.WIKI,root/html528/TGL5DDataSet.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGL5DDataSet.html
https://root.cern/root/html528/TGL5DDataSet.html:1371,Availability,error,error,1371,"aSet(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TGL5DPainter*GetRealPainter() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; const Rgl::Range_t&GetV4Range() const; TAxis*GetXAxis() const; const Rgl::Range_t&GetXRange() const; TAxis*GetYAxis() const; const Rgl::Range_t&GetYRange() const; TAxis*GetZAxis() const; const Rgl::Range_t&GetZRange() const; virtual Bool_tTObje",MatchSource.WIKI,root/html528/TGL5DDataSet.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGL5DDataSet.html
https://root.cern/root/html528/TGL5DDataSet.html:6965,Security,access,access,6965,"g64_tfNPNumber of entries.; auto_ptr<TGLHistPainter>fPainter; const Double_t*fV1V1.; pair<double,double>fV1MinMaxV1 range.; Double_tfV1Rangemax - min.; const Double_t*fV2V2.; pair<double,double>fV2MinMaxV2 range.; Double_tfV2Rangemax - min.; const Double_t*fV3V3.; pair<double,double>fV3MinMaxV3 range.; Double_tfV3Rangemax - min.; const Double_t*fV4V4.; Bool_tfV4IsString; pair<double,double>fV4MinMaxV4 range.; const Double_t*fV5V5.; pair<double,double>fV5MinMaxV5 range.; TAxisfXAxis; TAxisfYAxis; TAxisfZAxis. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGL5DDataSet(TTree* inputData); Constructor. Reads data from TTree,; estimates ranges, creates a painter. Int_t DistancetoPrimitive(Int_t px, Int_t py); Check, if the object is under cursor. void ExecuteEvent(Int_t event, Int_t px, Int_t py); Action. char * GetObjectInfo(Int_t px, Int_t py) const; Info for status bar. void Paint(Option_t* option); Paint. TGL5DPainter * GetRealPainter() const; Get access to painter (for GUI-editor). void SelectPoints(Double_t v4Level, Double_t range); ""Select"" sub-range from source data; - remember indices of ""good"" points. UInt_t SelectedSize() const; Size of selected sub-range. Double_t V1(UInt_t ind) const; V1 from sub-range, converted to unit cube. Double_t V2(UInt_t ind) const; V2 from sub-range, converted to unit cube. Double_t V3(UInt_t ind) const; V3 from sub-range, converted to unit cube. TAxis * GetXAxis() const; X axis for plot. TAxis * GetYAxis() const; Y axis for plot. TAxis * GetZAxis() const; Z axis for plot. const Rgl::Range_t & GetXRange() const; V1 range (X). const Rgl::Range_t & GetYRange() const; V2 range (Y). const Rgl::Range_t & GetZRange() const; V3 range (Z). const Rgl::Range_t & GetV4Range() const; V4 range. Double_t V1ToUnitCube(Double_t v1) const; V1 to unit cube. Double_t V2ToUnitCube(Double_t v2) const; V2 to unit cube. Double_t V3ToUnitCube(Double_t v3) const; V3 to unit cube. TGL5DDataSet(TTree* inputData). » A",MatchSource.WIKI,root/html528/TGL5DDataSet.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGL5DDataSet.html
https://root.cern/root/html528/TGL5DDataSetEditor.html:4777,Availability,error,error,4777,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const;",MatchSource.WIKI,root/html528/TGL5DDataSetEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGL5DDataSetEditor.html
https://root.cern/root/html528/TGL5DDataSetEditor.html:4861,Availability,error,error,4861,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType() c",MatchSource.WIKI,root/html528/TGL5DDataSetEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGL5DDataSetEditor.html
https://root.cern/root/html528/TGL5DDataSetEditor.html:18224,Availability,mask,mask,18224,,MatchSource.WIKI,root/html528/TGL5DDataSetEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGL5DDataSetEditor.html
https://root.cern/root/html528/TGL5DDataSetEditor.html:20735,Energy Efficiency,adapt,adapter,20735,"edflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. private:. TGTextButton*fAddNewIsoBtnButton to add new iso.; TGNumberEntry*fAlpha; TGTextButton*fApplyAlpha; TGTextButton*fApplyPlanes; TGTextButton*fCancelGridBtn""Cancel"" button.; TGL5DDataSet*fDataSetData adapter for TTree.; TGL5DDataSetEditor::TGL5DEditorPrivate*fHidden; TGCheckButton*fHighlightCheckHighlight selected surface.; TGListBox*fIsoListList box to select surface.; TGCheckButton*fLogScale; TGNumberEntry*fNCellsXEntryNumber of cells along X.; TGNumberEntry*fNCellsYEntryNumber of cells along Y.; TGNumberEntry*fNCellsZEntryNumber of cells along Z.; TGNumberEntry*fNewIsoEntrySet the iso-level for new surface.; TGNumberEntry*fNumberOfPlanes; TGTextButton*fOkGridBtn""Apply"" button.; TGL5DPainter*fPainterPainter.; Int_tfSelectedSurface; TGCheckButton*fShowBoxCut; TGCheckButton*fShowCloudShow/hide points for surface.; TGDoubleHSlider*fSlideRange; TGHSlider*fSurfAlphaSliderSlider to control transparency.; TGColorSelect*fSurfColorSelectOpen color dialog.; TGTextButton*fSurfRemoveBtnRemove selected surface.; TGNumberEntryField*fV4MaxEntryRead only widget.; TGNumberEntryField*fV4MinEntryRead only widget.; TGCheckButton*fVisibleCheckShow/hide surface.; TGDoubleHSlider*fXRangeSliderSlid",MatchSource.WIKI,root/html528/TGL5DDataSetEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGL5DDataSetEditor.html
https://root.cern/root/html528/TGL5DDataSetEditor.html:20735,Integrability,adapter,adapter,20735,"edflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. private:. TGTextButton*fAddNewIsoBtnButton to add new iso.; TGNumberEntry*fAlpha; TGTextButton*fApplyAlpha; TGTextButton*fApplyPlanes; TGTextButton*fCancelGridBtn""Cancel"" button.; TGL5DDataSet*fDataSetData adapter for TTree.; TGL5DDataSetEditor::TGL5DEditorPrivate*fHidden; TGCheckButton*fHighlightCheckHighlight selected surface.; TGListBox*fIsoListList box to select surface.; TGCheckButton*fLogScale; TGNumberEntry*fNCellsXEntryNumber of cells along X.; TGNumberEntry*fNCellsYEntryNumber of cells along Y.; TGNumberEntry*fNCellsZEntryNumber of cells along Z.; TGNumberEntry*fNewIsoEntrySet the iso-level for new surface.; TGNumberEntry*fNumberOfPlanes; TGTextButton*fOkGridBtn""Apply"" button.; TGL5DPainter*fPainterPainter.; Int_tfSelectedSurface; TGCheckButton*fShowBoxCut; TGCheckButton*fShowCloudShow/hide points for surface.; TGDoubleHSlider*fSlideRange; TGHSlider*fSurfAlphaSliderSlider to control transparency.; TGColorSelect*fSurfColorSelectOpen color dialog.; TGTextButton*fSurfRemoveBtnRemove selected surface.; TGNumberEntryField*fV4MaxEntryRead only widget.; TGNumberEntryField*fV4MinEntryRead only widget.; TGCheckButton*fVisibleCheckShow/hide surface.; TGDoubleHSlider*fXRangeSliderSlid",MatchSource.WIKI,root/html528/TGL5DDataSetEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGL5DDataSetEditor.html
https://root.cern/root/html528/TGL5DDataSetEditor.html:20735,Modifiability,adapt,adapter,20735,"edflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. private:. TGTextButton*fAddNewIsoBtnButton to add new iso.; TGNumberEntry*fAlpha; TGTextButton*fApplyAlpha; TGTextButton*fApplyPlanes; TGTextButton*fCancelGridBtn""Cancel"" button.; TGL5DDataSet*fDataSetData adapter for TTree.; TGL5DDataSetEditor::TGL5DEditorPrivate*fHidden; TGCheckButton*fHighlightCheckHighlight selected surface.; TGListBox*fIsoListList box to select surface.; TGCheckButton*fLogScale; TGNumberEntry*fNCellsXEntryNumber of cells along X.; TGNumberEntry*fNCellsYEntryNumber of cells along Y.; TGNumberEntry*fNCellsZEntryNumber of cells along Z.; TGNumberEntry*fNewIsoEntrySet the iso-level for new surface.; TGNumberEntry*fNumberOfPlanes; TGTextButton*fOkGridBtn""Apply"" button.; TGL5DPainter*fPainterPainter.; Int_tfSelectedSurface; TGCheckButton*fShowBoxCut; TGCheckButton*fShowCloudShow/hide points for surface.; TGDoubleHSlider*fSlideRange; TGHSlider*fSurfAlphaSliderSlider to control transparency.; TGColorSelect*fSurfColorSelectOpen color dialog.; TGTextButton*fSurfRemoveBtnRemove selected surface.; TGNumberEntryField*fV4MaxEntryRead only widget.; TGNumberEntryField*fV4MinEntryRead only widget.; TGCheckButton*fVisibleCheckShow/hide surface.; TGDoubleHSlider*fXRangeSliderSlid",MatchSource.WIKI,root/html528/TGL5DDataSetEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGL5DDataSetEditor.html
https://root.cern/root/html528/TGL5DDataSetEditor.html:362,Safety,safe,safety,362,". TGL5DDataSetEditor. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGL5DDataSetEditor. class TGL5DDataSetEditor: public TGedFrame. GUI editor for OpenGL 5D Painter.; Exception safety and ROOT's GUI are two; mutually exclusive things. So,; only ROOT's GUI here. Function Members (Methods); public:. TGL5DDataSetEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); virtual~TGL5DDataSetEditor(); voidTObject::AbstractMethod(const char* method) const; virtual Bool_tTGedFrame::AcceptModel(TObject*); virtual voidTGFrame::Activate(Bool_t); virtual voidTGedFrame::ActivateBaseClassEditors(TClass* cl); virtual voidTGedFrame::AddExtraTab(TGedFrame::TGedSubFrame* sf); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); voidAddNewSurface(); voidAlphaChanged(); voidAlphaChanged(Int_t alpha); virtual voidTObject::AppendPad(Option_t* option = """"); voidApplyAlpha(); voidApplyGridParameters(); voidApplyPlanes(); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); voidBoxCutToggled(); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidTGCompositeFrame::ChangeSubframesBackground(Pixel_t back); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTGCompositeFrame::Cleanup(); virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TCla",MatchSource.WIKI,root/html528/TGL5DDataSetEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGL5DDataSetEditor.html
https://root.cern/root/html528/TGLabel.html:4374,Availability,error,error,4374,"t::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidEnable(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int_tGet3DStyle() const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; Int_tGetBottomMargin() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static FontStruct_tGetDefaultFontStruct(); static Pixel_tTGFrame::GetDefaultFrameBackground(); static const TGGC&GetDefaultGC(); virtual UInt_tTGFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionGetDefaultSize() const; virtual UInt_tTGFrame::GetDe",MatchSource.WIKI,root/html528/TGLabel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLabel.html
https://root.cern/root/html528/TGLabel.html:4458,Availability,error,error,4458,"Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidEnable(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int_tGet3DStyle() const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; Int_tGetBottomMargin() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static FontStruct_tGetDefaultFontStruct(); static Pixel_tTGFrame::GetDefaultFrameBackground(); static const TGGC&GetDefaultGC(); virtual UInt_tTGFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionGetDefaultSize() const; virtual UInt_tTGFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFra",MatchSource.WIKI,root/html528/TGLabel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLabel.html
https://root.cern/root/html528/TGLabel.html:16653,Availability,mask,mask,16653," TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Int_tf3DStyle3D style (0 - normal, kRaisedFrame - raised, kSunkenFrame - sunken); Pixel_tTGFrame::fBackgroundframe background color; Int_tTGFrame::fBorderWidthframe border width; TGClient*TGObject::fClientConnection to display server; Int_tTGFrame::fDNDStateEDNDFlags; Bool_tfDisabledif kTRUE label looks disabled (shaded text); UInt_tTGWindow::fEditDisabledflags used for ""guibuilding""; UInt_tTGFrame::fEventMaskcurrenty active event mask; TGFrameElement*TGFrame::fFEpointer to frame element; TGFont*fFontfont to draw label; Bool_tfHasOwnFontkTRUE - font defined locally, kFALSE - globally; UInt_tTGFrame::fHeightframe height; Handle_tTGObject::fIdX11/Win32 Window identifier; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Int_tfMBottommargin bottom; Int_tfMLeftmargin left; Int_tfMRightmargin right; Int_tfMTopmargin top; UInt_tTGFrame::fMaxHeightmaximal frame height; UInt_tTGFrame::fMaxWidthmaximal frame width; UInt_tTGFrame::fMinHeightminimal frame height; UInt_tTGFrame::fMinWidthminimal frame width; TStringTGWindow::fNamename of the window used in SavePrimitive(); Bool_tTGWindow::fNeedRedrawkTRUE if window needs to be redrawn; GContext_tfNormGCgraphics context used for drawing label; UInt_tTGFrame::fOptionsframe options; const TGWindow*TGWindow::fParentParent window; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; Int_tfTFlagstext flags (see TGFont.h ETextLayoutFlags); UInt_tfTHeighttext height; TGTextLayout*fTLayouttext layout ; Int_tfTModetext alignment; UInt_tfTWidthtext width; TGString*fTextlabel text; Bool_tfTextChangedhas text changed; UInt_tTGFrame::fWidthframe width; Int_tfWrapLengthwrap length; ",MatchSource.WIKI,root/html528/TGLabel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLabel.html
https://root.cern/root/html528/TGLAutoRotator.html:1472,Availability,error,error,1472," TGLAutoRotator(TGLViewer* v); virtual~TGLAutoRotator(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tGetADolly() const; Double_tGetATheta() const; TGLCamera*GetCamera() const; virtual Option_t*TObject::GetDrawOption() const; Double_tGetDt() const; static Long_",MatchSource.WIKI,root/html528/TGLAutoRotator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLAutoRotator.html
https://root.cern/root/html528/TGLAutoRotator.html:1556,Availability,error,error,1556," voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tGetADolly() const; Double_tGetATheta() const; TGLCamera*GetCamera() const; virtual Option_t*TObject::GetDrawOption() const; Double_tGetDt() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; Double_tGetWDolly() const; Double_tGetWPhi() const; Double_tGetWTheta() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const ch",MatchSource.WIKI,root/html528/TGLAutoRotator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLAutoRotator.html
https://root.cern/root/html528/TGLAxis.html:4282,Performance,optimiz,optimized,4282,"uble_tfAxisLength; Double_tfGridLength; TString*fLabels; Double_tfLabelsOffset; Double_tfLabelsSize; Int_tfNDiv; Int_tfNDiv1; Int_tfNDiv2; Int_tfNDiv3; Int_tfNTicks1; Int_tfNTicks2; TGLText*fText; Double_tfTickMarksLength; Int_tfTickMarksOrientation; Double_t*fTicks1; Double_t*fTicks2; Double_tfWmax; Double_tfWmin. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLAxis(); Constructor. void Init(); Default initialization. ~TGLAxis(); Destructor. void PaintGLAxis(const Double_t* p1, const Double_t* p2, Double_t wmin, Double_t wmax, Int_t ndiv, Option_t* opt = """"); Paint GL Axis. p1, p2 : Axis position in the 3D space.; wmin, wmax : Minimum and maximum values along the axis. wmin < wmax.; ndiv : Number of axis divisions. It is an integer in the form; ""ttsspp"" where ""tt"" is the number of tertiary divisions,; ""ss"" is the number of secondary divisions and ""pp"" the; number of primary divisions.; opt : Options.; ""N"" - By default the number of divisions is optimized to; get a nice labeling. When option ""N"" is given, the; number of divisions is not optimized. void PaintGLAxisBody(); Paint horizontal axis body at position (0,0,0). void PaintGLAxisTickMarks(); Paint axis tick marks. void PaintGLAxisLabels(); Paint axis labels on the main tick marks. void TicksPositions(Option_t* opt = """"); Compute ticks positions. void TicksPositionsNoOpt(); Compute ticks positions. Linear and not optimized. void TicksPositionsOpt(); Compute ticks positions. Linear and optimized. void DoLabels(); Do labels. void SetLabelsAngles(Double_t a1, Double_t a2, Double_t a3); Set labels' angles. TGLAxis(const TGLAxis& ). TGLAxis& operator=(const TGLAxis& ). void SetTickMarksLength(Double_t length); {fTickMarksLength = length;}. void SetTickMarksOrientation(Int_t tmo); {fTickMarksOrientation = tmo;}. void SetLabelsOffset(Double_t offset); {fLabelsOffset = offset;}. void SetLabelsSize(Double_t size); {fLabelsSize = size;}. void SetGridLength(Double_t grid); {fGr",MatchSource.WIKI,root/html528/TGLAxis.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLAxis.html
https://root.cern/root/html528/TGLAxis.html:4375,Performance,optimiz,optimized,4375,"fset; Double_tfLabelsSize; Int_tfNDiv; Int_tfNDiv1; Int_tfNDiv2; Int_tfNDiv3; Int_tfNTicks1; Int_tfNTicks2; TGLText*fText; Double_tfTickMarksLength; Int_tfTickMarksOrientation; Double_t*fTicks1; Double_t*fTicks2; Double_tfWmax; Double_tfWmin. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLAxis(); Constructor. void Init(); Default initialization. ~TGLAxis(); Destructor. void PaintGLAxis(const Double_t* p1, const Double_t* p2, Double_t wmin, Double_t wmax, Int_t ndiv, Option_t* opt = """"); Paint GL Axis. p1, p2 : Axis position in the 3D space.; wmin, wmax : Minimum and maximum values along the axis. wmin < wmax.; ndiv : Number of axis divisions. It is an integer in the form; ""ttsspp"" where ""tt"" is the number of tertiary divisions,; ""ss"" is the number of secondary divisions and ""pp"" the; number of primary divisions.; opt : Options.; ""N"" - By default the number of divisions is optimized to; get a nice labeling. When option ""N"" is given, the; number of divisions is not optimized. void PaintGLAxisBody(); Paint horizontal axis body at position (0,0,0). void PaintGLAxisTickMarks(); Paint axis tick marks. void PaintGLAxisLabels(); Paint axis labels on the main tick marks. void TicksPositions(Option_t* opt = """"); Compute ticks positions. void TicksPositionsNoOpt(); Compute ticks positions. Linear and not optimized. void TicksPositionsOpt(); Compute ticks positions. Linear and optimized. void DoLabels(); Do labels. void SetLabelsAngles(Double_t a1, Double_t a2, Double_t a3); Set labels' angles. TGLAxis(const TGLAxis& ). TGLAxis& operator=(const TGLAxis& ). void SetTickMarksLength(Double_t length); {fTickMarksLength = length;}. void SetTickMarksOrientation(Int_t tmo); {fTickMarksOrientation = tmo;}. void SetLabelsOffset(Double_t offset); {fLabelsOffset = offset;}. void SetLabelsSize(Double_t size); {fLabelsSize = size;}. void SetGridLength(Double_t grid); {fGridLength = grid;}. » Author: Olivier Couet 17/04/2007 » Copyright (C) 1995-",MatchSource.WIKI,root/html528/TGLAxis.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLAxis.html
https://root.cern/root/html528/TGLAxis.html:4712,Performance,optimiz,optimized,4712,"s. Function documentation; TGLAxis(); Constructor. void Init(); Default initialization. ~TGLAxis(); Destructor. void PaintGLAxis(const Double_t* p1, const Double_t* p2, Double_t wmin, Double_t wmax, Int_t ndiv, Option_t* opt = """"); Paint GL Axis. p1, p2 : Axis position in the 3D space.; wmin, wmax : Minimum and maximum values along the axis. wmin < wmax.; ndiv : Number of axis divisions. It is an integer in the form; ""ttsspp"" where ""tt"" is the number of tertiary divisions,; ""ss"" is the number of secondary divisions and ""pp"" the; number of primary divisions.; opt : Options.; ""N"" - By default the number of divisions is optimized to; get a nice labeling. When option ""N"" is given, the; number of divisions is not optimized. void PaintGLAxisBody(); Paint horizontal axis body at position (0,0,0). void PaintGLAxisTickMarks(); Paint axis tick marks. void PaintGLAxisLabels(); Paint axis labels on the main tick marks. void TicksPositions(Option_t* opt = """"); Compute ticks positions. void TicksPositionsNoOpt(); Compute ticks positions. Linear and not optimized. void TicksPositionsOpt(); Compute ticks positions. Linear and optimized. void DoLabels(); Do labels. void SetLabelsAngles(Double_t a1, Double_t a2, Double_t a3); Set labels' angles. TGLAxis(const TGLAxis& ). TGLAxis& operator=(const TGLAxis& ). void SetTickMarksLength(Double_t length); {fTickMarksLength = length;}. void SetTickMarksOrientation(Int_t tmo); {fTickMarksOrientation = tmo;}. void SetLabelsOffset(Double_t offset); {fLabelsOffset = offset;}. void SetLabelsSize(Double_t size); {fLabelsSize = size;}. void SetGridLength(Double_t grid); {fGridLength = grid;}. » Author: Olivier Couet 17/04/2007 » Copyright (C) 1995-2006, Rene Brun and Fons Rademakers. *; » Last changed: root/gl:$Id: TGLAxis.h 21794 2008-01-21 21:11:46Z matevz $ » Last generated: 2010-09-23 20:06; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html528/TGLAxis.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLAxis.html
https://root.cern/root/html528/TGLAxis.html:4785,Performance,optimiz,optimized,4785,"s. Function documentation; TGLAxis(); Constructor. void Init(); Default initialization. ~TGLAxis(); Destructor. void PaintGLAxis(const Double_t* p1, const Double_t* p2, Double_t wmin, Double_t wmax, Int_t ndiv, Option_t* opt = """"); Paint GL Axis. p1, p2 : Axis position in the 3D space.; wmin, wmax : Minimum and maximum values along the axis. wmin < wmax.; ndiv : Number of axis divisions. It is an integer in the form; ""ttsspp"" where ""tt"" is the number of tertiary divisions,; ""ss"" is the number of secondary divisions and ""pp"" the; number of primary divisions.; opt : Options.; ""N"" - By default the number of divisions is optimized to; get a nice labeling. When option ""N"" is given, the; number of divisions is not optimized. void PaintGLAxisBody(); Paint horizontal axis body at position (0,0,0). void PaintGLAxisTickMarks(); Paint axis tick marks. void PaintGLAxisLabels(); Paint axis labels on the main tick marks. void TicksPositions(Option_t* opt = """"); Compute ticks positions. void TicksPositionsNoOpt(); Compute ticks positions. Linear and not optimized. void TicksPositionsOpt(); Compute ticks positions. Linear and optimized. void DoLabels(); Do labels. void SetLabelsAngles(Double_t a1, Double_t a2, Double_t a3); Set labels' angles. TGLAxis(const TGLAxis& ). TGLAxis& operator=(const TGLAxis& ). void SetTickMarksLength(Double_t length); {fTickMarksLength = length;}. void SetTickMarksOrientation(Int_t tmo); {fTickMarksOrientation = tmo;}. void SetLabelsOffset(Double_t offset); {fLabelsOffset = offset;}. void SetLabelsSize(Double_t size); {fLabelsSize = size;}. void SetGridLength(Double_t grid); {fGridLength = grid;}. » Author: Olivier Couet 17/04/2007 » Copyright (C) 1995-2006, Rene Brun and Fons Rademakers. *; » Last changed: root/gl:$Id: TGLAxis.h 21794 2008-01-21 21:11:46Z matevz $ » Last generated: 2010-09-23 20:06; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html528/TGLAxis.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLAxis.html
https://root.cern/root/html528/TGLAxisPainter.html:3441,Integrability,depend,depends,3441,"tfTitle3DFontSize; Int_tfTitlePixelFontSize; TGLVector3fTitlePos; Bool_tfUseAxisColorsUse colors from axes or from GL-rnr-ctx. private:. Int_tfDecimals; Int_tfExp; TStringfFormat; TGLFontfLabelFont; Int_tfMaxDigits; TGLFontfTitleFont. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLAxisPainter(); Constructor. ~TGLAxisPainter(); Destructor. void SetLabelAlign(TGLFont::ETextAlignH_e , TGLFont::ETextAlignV_e ); Set label align. void LabelsLimits(const char* label, Int_t& first, Int_t& last) const; Find first and last character of a label. void FormAxisValue(Double_t x, TString& s) const; Returns formatted text suitable for display of value. void SetTextFormat(Double_t min, Double_t max, Double_t binWidth); Construct print format from given primary bin width. void RnrText(const TString& txt, const TGLVector3& pos, TGLFont::ETextAlignH_e aH, TGLFont::ETextAlignV_e aV, const TGLFont& font) const; Render text at the given position. Offset depends of text aligment. void SetLabelFont(TGLRnrCtx& rnrCtx, const char* fontName, Int_t pixelSize = 64, Double_t font3DSize = -1); Set label font derived from TAttAxis. void RnrLabels() const; Render label reading prepared list ov value-pos pairs. void SetTitleFont(TGLRnrCtx& rnrCtx, const char* fontName, Int_t pixelSize = 64, Double_t font3DSize = -1); Set title font derived from TAttAxis. void RnrTitle(const TString& title, TGLVector3& pos, TGLFont::ETextAlignH_e aH, TGLFont::ETextAlignV_e aV) const; Draw title at given position. void RnrLines() const; Render axis main line and tickmarks. void PaintAxis(TGLRnrCtx& ctx, TAxis* ax); GL render TAxis. TGLAxisPainter(const TGLAxisPainter& ). TGLAxisPainter& operator=(const TGLAxisPainter& ). Int_t GetTMNDim() const; GetSets. { return fTMNDim; }. void SetTMNDim(Int_t x); { fTMNDim = x; }. TGLVector3& RefDir(); { return fDir; }. TGLVector3& RefTMOff(Int_t i); { return fTMOff[i]; }. TGLFont::EMode GetFontMode() const; { return fFontMode; }. void S",MatchSource.WIKI,root/html528/TGLAxisPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLAxisPainter.html
https://root.cern/root/html528/TGLayoutHints.html:796,Availability,down,downward,796,". TGLayoutHints. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGLayoutHints. class TGLayoutHints: public TObject, public TRefCnt. A number of different layout classes (TGLayoutManager,; TGVerticalLayout, TGHorizontalLayout, TGLayoutHints, etc.). Concerning the TGMatrixLayout class:. It arranges frames in a matrix-like way.; This manager provides :; - a column number (0 means unlimited); - a row number (0 means unlimited); - horizontal & vertical separators. Notes : If both column and row are fixed values, any remaining; frames outside the count won't be managed.; Unlimited rows means the frame can expand downward; (the default behaviour in most UI).; Both unlimited rows and columns is undefined (read: will; crash the algorithm ;-).; With fixed dimensions, frames are always arranged in rows.; That is: 1st frame is at position (0,0), next one is at; row(0), column(1) and so on...; When specifying one dimension as unlimited (i.e. row=0 or; column=0) the frames are arranged according to the direction; of the fixed dimension. This layout manager does not make; use of TGLayoutHints. Function Members (Methods); public:. TGLayoutHints(const TGLayoutHints& lh); TGLayoutHints(ULong_t hints = kLHintsNormal, Int_t padleft = 0, Int_t padright = 0, Int_t padtop = 0, Int_t padbottom = 0); virtual~TGLayoutHints(); voidTObject::AbstractMethod(const char* method) const; voidTRefCnt::AddReference(); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Opt",MatchSource.WIKI,root/html528/TGLayoutHints.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLayoutHints.html
https://root.cern/root/html528/TGLayoutHints.html:2445,Availability,error,error,2445,"top = 0, Int_t padbottom = 0); virtual~TGLayoutHints(); voidTObject::AbstractMethod(const char* method) const; voidTRefCnt::AddReference(); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; ULong_tGetLayoutHints() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Int_tGetPadBottom() const; Int_tGetPadLeft() const; Int_tGetPadRight() const; Int_tGetPadTop() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; vi",MatchSource.WIKI,root/html528/TGLayoutHints.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLayoutHints.html
https://root.cern/root/html528/TGLayoutHints.html:2529,Availability,error,error,2529,"const char* method) const; voidTRefCnt::AddReference(); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; ULong_tGetLayoutHints() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Int_tGetPadBottom() const; Int_tGetPadLeft() const; Int_tGetPadRight() const; Int_tGetPadTop() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_",MatchSource.WIKI,root/html528/TGLayoutHints.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLayoutHints.html
https://root.cern/root/html528/TGLayoutManager.html:786,Availability,down,downward,786,". TGLayoutManager. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGLayoutManager. class TGLayoutManager: public TObject. A number of different layout classes (TGLayoutManager,; TGVerticalLayout, TGHorizontalLayout, TGLayoutHints, etc.). Concerning the TGMatrixLayout class:. It arranges frames in a matrix-like way.; This manager provides :; - a column number (0 means unlimited); - a row number (0 means unlimited); - horizontal & vertical separators. Notes : If both column and row are fixed values, any remaining; frames outside the count won't be managed.; Unlimited rows means the frame can expand downward; (the default behaviour in most UI).; Both unlimited rows and columns is undefined (read: will; crash the algorithm ;-).; With fixed dimensions, frames are always arranged in rows.; That is: 1st frame is at position (0,0), next one is at; row(0), column(1) and so on...; When specifying one dimension as unlimited (i.e. row=0 or; column=0) the frames are arranged according to the direction; of the fixed dimension. This layout manager does not make; use of TGLayoutHints. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. ~TGLayoutManager(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px,",MatchSource.WIKI,root/html528/TGLayoutManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLayoutManager.html
https://root.cern/root/html528/TGLayoutManager.html:1402,Availability,avail,available,1402,"ut, TGLayoutHints, etc.). Concerning the TGMatrixLayout class:. It arranges frames in a matrix-like way.; This manager provides :; - a column number (0 means unlimited); - a row number (0 means unlimited); - horizontal & vertical separators. Notes : If both column and row are fixed values, any remaining; frames outside the count won't be managed.; Unlimited rows means the frame can expand downward; (the default behaviour in most UI).; Both unlimited rows and columns is undefined (read: will; crash the algorithm ;-).; With fixed dimensions, frames are always arranged in rows.; That is: 1st frame is at position (0,0), next one is at; row(0), column(1) and so on...; When specifying one dimension as unlimited (i.e. row=0 or; column=0) the frames are arranged according to the direction; of the fixed dimension. This layout manager does not make; use of TGLayoutHints. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. ~TGLayoutManager(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTOb",MatchSource.WIKI,root/html528/TGLayoutManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLayoutManager.html
https://root.cern/root/html528/TGLayoutManager.html:2368,Availability,error,error,2368," ~TGLayoutManager(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px,",MatchSource.WIKI,root/html528/TGLayoutManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLayoutManager.html
https://root.cern/root/html528/TGLayoutManager.html:2452,Availability,error,error,2452," voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TGDimensionGetDefaultSize() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(c",MatchSource.WIKI,root/html528/TGLayoutManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLayoutManager.html
https://root.cern/root/html528/TGLBContainer.html:5645,Availability,error,error,5645,"le_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTGContainer::End(Bool_t select = kFALSE); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGContainer::FindFrame(Int_t x, Int_t y, Bool_t exclude = kTRUE); virtual TGFrame*TGContainer::FindFrameByName(const char* name); virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual void*TGContainer::FindItem(const TString& name, Bool_t direction = kTRUE, Bool_t caseSensitive = kTRUE, Bool_t subString = kFALSE); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGCanvas*TGContainer::GetCanvas() const; TGClient*TGObject::Get",MatchSource.WIKI,root/html528/TGLBContainer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLBContainer.html
https://root.cern/root/html528/TGLBContainer.html:5729,Availability,error,error,5729,"t(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTGContainer::End(Bool_t select = kFALSE); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGContainer::FindFrame(Int_t x, Int_t y, Bool_t exclude = kTRUE); virtual TGFrame*TGContainer::FindFrameByName(const char* name); virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual void*TGContainer::FindItem(const TString& name, Bool_t direction = kTRUE, Bool_t caseSensitive = kTRUE, Bool_t subString = kFALSE); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGCanvas*TGContainer::GetCanvas() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaul",MatchSource.WIKI,root/html528/TGLBContainer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLBContainer.html
https://root.cern/root/html528/TGLBContainer.html:12489,Availability,mask,mask,12489,") const; voidTObject::InvertBit(UInt_t f); virtual voidTGContainer::InvertSelection()SIGNAL ; virtual TClass*IsA() const; virtual Bool_tTGFrame::IsActive() const; Bool_tTGCompositeFrame::IsArranged(TGFrame* f) const; Bool_tTGCompositeFrame::IsArranged(TGFrameElement* ptr) const; virtual Bool_tTGCompositeFrame::IsComposite() const; Bool_tTGFrame::IsDNDSource() const; Bool_tTGFrame::IsDNDTarget() const; virtual Bool_tTGCompositeFrame::IsEditable() const; virtual Bool_tTGObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; virtual Bool_tTGCompositeFrame::IsLayoutBroken() const; virtual Bool_tTGWindow::IsMapped(); virtual Bool_tTGCompositeFrame::IsMapSubwindows() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTGCompositeFrame::IsVisible(TGFrame* f) const; Bool_tTGCompositeFrame::IsVisible(TGFrameElement* ptr) const; Bool_tTObject::IsZombie() const; virtual voidTGContainer::KeyPressed(TGFrame*, UInt_t keysym, UInt_t mask)SIGNAL ; virtual voidLayout(); virtual voidTGContainer::LineDown(Bool_t select = kFALSE); virtual voidTGContainer::LineLeft(Bool_t select = kFALSE); virtual voidTGContainer::LineRight(Bool_t select = kFALSE); virtual voidTGContainer::LineUp(Bool_t select = kFALSE); static voidTQObject::LoadRQ_OBJECT(); virtual voidTGWindow::LowerWindow(); virtual voidTQObject::LowPriority(const char* signal_name, const char* slot_name = 0); virtual voidTObject::ls(Option_t* option = """") const; virtual voidTGFrame::MapRaised(); virtual voidTGCompositeFrame::MapSubwindows(); virtual voidTGFrame::MapWindow(); voidTObject::MayNotUse(const char* method) const; virtual voidTQObject::Message(const char* msg)SIGNAL ; virtual voidTGFrame::Move(Int_t x, Int_t y); virtual voidTGFrame::MoveResize(Int_t x, Int_t y, UInt_t w = 0, UInt_t h = 0); virtual Int_tTGCompositeFrame::MustCleanup() const; virtual Bool_tTObject::Notify(); virtual Int_tTQObject::NumberOfConnections() const; virtual Int_tTQObject::NumberOfSign",MatchSource.WIKI,root/html528/TGLBContainer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLBContainer.html
https://root.cern/root/html528/TGLBContainer.html:21066,Availability,mask,mask,21066,,MatchSource.WIKI,root/html528/TGLBContainer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLBContainer.html
https://root.cern/root/html528/TGLBContainer.html:25511,Deployability,update,update,25511," Inherited Members; Includes; Libraries. Function documentation; TGLBContainer(const TGWindow* p = 0, UInt_t w = 1, UInt_t h = 1, UInt_t options = kSunkenFrame, Pixel_t back = GetDefaultFrameBackground()); Create a listbox container. ~TGLBContainer(); Delete the listbox container. void Layout(); Layout container. void DoRedraw(); redraw. void AddEntry(TGLBEntry* lbe, TGLayoutHints* lhints); Add listbox entry with hints to container. To show entry call; MapSubwindows() and Layout(). void InsertEntry(TGLBEntry* lbe, TGLayoutHints* lhints, Int_t afterID); Insert listbox entry after specified entry with id afterID. If afterID = -1; then add entry at head of list. To show entry call MapSubwindows() and; Layout(). void AddEntrySort(TGLBEntry* lbe, TGLayoutHints* lhints); Insert listbox entry before the list box entry with a higher id.; To show entry call MapSubwindows() and Layout(). void RemoveEntry(Int_t id); Remove the entry with specified id from the listbox container.; To update the listbox call Layout(). void RemoveEntries(Int_t from_ID, Int_t to_ID); Remove entries from from_ID to to_ID (including).; To update the listbox call Layout(). void RemoveAll(); Remove all entries in this container. TGLBEntry * Select(Int_t id); Select the entry with the specified id.; Returns the selected TGLBEntry. TGLBEntry * Select(Int_t id, Bool_t sel); Select / deselect the entry with the specified id.; Returns the selected TGLBEntry. Int_t GetSelected() const; Returns id of selected entry. In case of no selected entry or; if multi selection is switched on returns -1. Bool_t GetSelection(Int_t id); Returns kTrue if entry id is selected. void GetSelectedEntries(TList* selected); Adds all selected entries (TGLBEntry) of the list box into; the list selected. void SetMultipleSelections(Bool_t multi); Enables and disables multiple selections of entries. TGVScrollBar * GetVScrollbar() const; Return a pointer to vertical scroll bar. void SetVsbPosition(Int_t newPos); Set new vertical scroll",MatchSource.WIKI,root/html528/TGLBContainer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLBContainer.html
https://root.cern/root/html528/TGLBContainer.html:25647,Deployability,update,update,25647," options = kSunkenFrame, Pixel_t back = GetDefaultFrameBackground()); Create a listbox container. ~TGLBContainer(); Delete the listbox container. void Layout(); Layout container. void DoRedraw(); redraw. void AddEntry(TGLBEntry* lbe, TGLayoutHints* lhints); Add listbox entry with hints to container. To show entry call; MapSubwindows() and Layout(). void InsertEntry(TGLBEntry* lbe, TGLayoutHints* lhints, Int_t afterID); Insert listbox entry after specified entry with id afterID. If afterID = -1; then add entry at head of list. To show entry call MapSubwindows() and; Layout(). void AddEntrySort(TGLBEntry* lbe, TGLayoutHints* lhints); Insert listbox entry before the list box entry with a higher id.; To show entry call MapSubwindows() and Layout(). void RemoveEntry(Int_t id); Remove the entry with specified id from the listbox container.; To update the listbox call Layout(). void RemoveEntries(Int_t from_ID, Int_t to_ID); Remove entries from from_ID to to_ID (including).; To update the listbox call Layout(). void RemoveAll(); Remove all entries in this container. TGLBEntry * Select(Int_t id); Select the entry with the specified id.; Returns the selected TGLBEntry. TGLBEntry * Select(Int_t id, Bool_t sel); Select / deselect the entry with the specified id.; Returns the selected TGLBEntry. Int_t GetSelected() const; Returns id of selected entry. In case of no selected entry or; if multi selection is switched on returns -1. Bool_t GetSelection(Int_t id); Returns kTrue if entry id is selected. void GetSelectedEntries(TList* selected); Adds all selected entries (TGLBEntry) of the list box into; the list selected. void SetMultipleSelections(Bool_t multi); Enables and disables multiple selections of entries. TGVScrollBar * GetVScrollbar() const; Return a pointer to vertical scroll bar. void SetVsbPosition(Int_t newPos); Set new vertical scroll bar position. Bool_t HandleButton(Event_t* event); Handle mouse button event in the listbox container. Bool_t HandleDoubleClick(Event_t",MatchSource.WIKI,root/html528/TGLBContainer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLBContainer.html
https://root.cern/root/html528/TGLBContainer.html:22508,Integrability,message,messages,22508,eElement*TGContainer::fLastActiveEllast active item; Bool_tTGContainer::fLastCasecase sensetivity of last search; Bool_tTGContainer::fLastDirdirection of last search; TStringTGContainer::fLastNamethe name of object of last search; Bool_tTGContainer::fLastSubstringsubstring search option of last search; Bool_tTGCompositeFrame::fLayoutBrokenno layout manager is used; TGLayoutManager*TGCompositeFrame::fLayoutManagerlayout manager; TList*TGCompositeFrame::fListcontainer of frame elements; TGListBox*fListBoxlist box which contains this container; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Bool_tTGCompositeFrame::fMapSubwindowskTRUE - map subwindows; UInt_tTGFrame::fMaxHeightmaximal frame height; UInt_tTGFrame::fMaxWidthmaximal frame width; UInt_tTGFrame::fMinHeightminimal frame height; UInt_tTGFrame::fMinWidthminimal frame width; const TGWindow*TGContainer::fMsgWindowwindow handling container messages; Bool_tfMultiSelecttrue if multi selection is switched on; Int_tTGCompositeFrame::fMustCleanupcleanup mode (see EFrameCleanup); TStringTGWindow::fNamename of the window used in SavePrimitive(); Bool_tTGWindow::fNeedRedrawkTRUE if window needs to be redrawn; Bool_tTGContainer::fOnMouseOverkTRUE when mouse pointer is over entry; UInt_tTGFrame::fOptionsframe options; const TGWindow*TGWindow::fParentParent window; TTimer*TGContainer::fScrollTimerautoscroll timer; Bool_tTGContainer::fScrollingkTRUE - when scrolling is ON; Int_tTGContainer::fSelectednumber of selected items; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; Int_tTGContainer::fTotaltotal items; TGViewPort*TGContainer::fViewPortcontainer viewport; UInt_tTGFrame::fWidthframe width; Int_tTGFrame::fXframe x position; Int_tTGContainer::fX0; Int_tTGContainer::fXDND; Int_tTGContainer::fXf; Int_tTGContainer::fXp; Int_tTGFrame::fYframe y position; Int_tTGContainer::fY0corner of rubber band box; Int_tTGContaine,MatchSource.WIKI,root/html528/TGLBContainer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLBContainer.html
https://root.cern/root/html528/TGLBContainer.html:445,Usability,simpl,simple,445,". TGLBContainer. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGLBContainer. class TGLBContainer: public TGContainer. TGListBox, TGLBContainer, TGLBEntry and TGTextLBEntry. A listbox is a box, possibly with scrollbar, containing entries.; Currently entries are simple text strings (TGTextLBEntry).; A TGListBox looks a lot like a TGCanvas. It has a TGViewPort; containing a TGLBContainer which contains the entries and it also; has a vertical scrollbar which becomes visible if there are more; items than fit in the visible part of the container. The TGListBox is user callable. The other classes are service; classes of the listbox. Selecting an item in the listbox will generate the event:; kC_COMMAND, kCM_LISTBOX, listbox id, item id. Function Members (Methods); public:. TGLBContainer(const TGWindow* p = 0, UInt_t w = 1, UInt_t h = 1, UInt_t options = kSunkenFrame, Pixel_t back = GetDefaultFrameBackground()); virtual~TGLBContainer(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidActivateItem(TGFrameElement* el); virtual voidAddEntry(TGLBEntry* lbe, TGLayoutHints* lhints); virtual voidAddEntrySort(TGLBEntry* lbe, TGLayoutHints* lhints); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTGContainer::AdjustPosition(); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual voidAssociate(const TGWindow* w); static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGComposite",MatchSource.WIKI,root/html528/TGLBContainer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLBContainer.html
https://root.cern/root/html528/TGLBEntry.html:4555,Availability,error,error,4555,"t::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); Int_tEntryId() const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGFrame::GetDefaultSize() const; virtual UInt_tTGFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType() const; virtual Option",MatchSource.WIKI,root/html528/TGLBEntry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLBEntry.html
https://root.cern/root/html528/TGLBEntry.html:4639,Availability,error,error,4639,"Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); Int_tEntryId() const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGFrame::GetDefaultSize() const; virtual UInt_tTGFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType() const; virtual Option_t*TObject::GetDrawOption() const; virtual Int_tTGFrame::GetDropType() const; static",MatchSource.WIKI,root/html528/TGLBEntry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLBEntry.html
https://root.cern/root/html528/TGLBEntry.html:15720,Availability,mask,mask,15720,,MatchSource.WIKI,root/html528/TGLBEntry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLBEntry.html
https://root.cern/root/html528/TGLBEntry.html:429,Usability,simpl,simple,429,". TGLBEntry. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGLBEntry. class TGLBEntry: public TGFrame. TGListBox, TGLBContainer, TGLBEntry and TGTextLBEntry. A listbox is a box, possibly with scrollbar, containing entries.; Currently entries are simple text strings (TGTextLBEntry).; A TGListBox looks a lot like a TGCanvas. It has a TGViewPort; containing a TGLBContainer which contains the entries and it also; has a vertical scrollbar which becomes visible if there are more; items than fit in the visible part of the container. The TGListBox is user callable. The other classes are service; classes of the listbox. Selecting an item in the listbox will generate the event:; kC_COMMAND, kCM_LISTBOX, listbox id, item id. Function Members (Methods); public:. TGLBEntry(const TGWindow* p = 0, Int_t id = -1, UInt_t options = kHorizontalFrame, Pixel_t back = GetWhitePixel()); ~TGLBEntry(); voidTObject::AbstractMethod(const char* method) const; virtual voidActivate(Bool_t a); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGFrame::ChangeOptions(UInt_t options); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* recei",MatchSource.WIKI,root/html528/TGLBEntry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLBEntry.html
https://root.cern/root/html528/TGLBoundingBox.html:2773,Performance,cache,cached,2773," other); voidSetAligned(const TGLVertex3& lowVertex, const TGLVertex3& highVertex); voidSetAligned(UInt_t nbPnts, const Double_t* pnts); voidSetEmpty(); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); voidTransform(const TGLMatrix& matrix); voidTranslate(const TGLVector3& offset); const TGLVertex3&Vertex(UInt_t index) const; const TGLVertex3*Vertices() const; Double_tVolume() const; Double_tXMax() const; Double_tXMin() const; Double_tYMax() const; Double_tYMin() const; Double_tZMax() const; Double_tZMin() const. private:. Double_tMax(UInt_t index) const; Double_tMin(UInt_t index) const; voidUpdateCache(); Bool_tValidIndex(UInt_t index) const. Data Members; public:. enum EFace { kFaceLowX; kFaceHighX; kFaceLowY; kFaceHighY; kFaceLowZ; kFaceHighZ; kFaceCount; };. private:. TGLVector3fAxes[3]! box axes in global frame - cached for speed; TGLVector3fAxesNorm[3]! normalised box axes in global frame - cached for speed; Double_tfDiagonal! max box diagonal - cached for speed; TGLVertex3fVertex[8]! the 8 bounding box vertices; Double_tfVolume! box volume - cached for speed. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLBoundingBox(); Construct an empty bounding box. TGLBoundingBox(const TGLVertex3 vertex[8]); Construct a bounding box from provided 8 vertices. TGLBoundingBox(const Double_t vertex[8][3]); Construct a bounding box from provided 8 vertices. TGLBoundingBox(const TGLVertex3& lowVertex, const TGLVertex3& highVertex); Construct an global axis ALIGNED bounding box from provided low/high vertex pair. TGLBoundingBox(const TGLBoundingBox& other); Construct a bounding box as copy of existing one. ~TGLBoundingBox(); Destroy bounding box. void UpdateCache(); Update the internally cached volume and axes vectors - these are retained; for efficiency - many more reads than modifications. void Set(const TGLVertex3 vertex[8]); Set a bounding box from provided 8 ve",MatchSource.WIKI,root/html528/TGLBoundingBox.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLBoundingBox.html
https://root.cern/root/html528/TGLBoundingBox.html:2853,Performance,cache,cached,2853," other); voidSetAligned(const TGLVertex3& lowVertex, const TGLVertex3& highVertex); voidSetAligned(UInt_t nbPnts, const Double_t* pnts); voidSetEmpty(); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); voidTransform(const TGLMatrix& matrix); voidTranslate(const TGLVector3& offset); const TGLVertex3&Vertex(UInt_t index) const; const TGLVertex3*Vertices() const; Double_tVolume() const; Double_tXMax() const; Double_tXMin() const; Double_tYMax() const; Double_tYMin() const; Double_tZMax() const; Double_tZMin() const. private:. Double_tMax(UInt_t index) const; Double_tMin(UInt_t index) const; voidUpdateCache(); Bool_tValidIndex(UInt_t index) const. Data Members; public:. enum EFace { kFaceLowX; kFaceHighX; kFaceLowY; kFaceHighY; kFaceLowZ; kFaceHighZ; kFaceCount; };. private:. TGLVector3fAxes[3]! box axes in global frame - cached for speed; TGLVector3fAxesNorm[3]! normalised box axes in global frame - cached for speed; Double_tfDiagonal! max box diagonal - cached for speed; TGLVertex3fVertex[8]! the 8 bounding box vertices; Double_tfVolume! box volume - cached for speed. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLBoundingBox(); Construct an empty bounding box. TGLBoundingBox(const TGLVertex3 vertex[8]); Construct a bounding box from provided 8 vertices. TGLBoundingBox(const Double_t vertex[8][3]); Construct a bounding box from provided 8 vertices. TGLBoundingBox(const TGLVertex3& lowVertex, const TGLVertex3& highVertex); Construct an global axis ALIGNED bounding box from provided low/high vertex pair. TGLBoundingBox(const TGLBoundingBox& other); Construct a bounding box as copy of existing one. ~TGLBoundingBox(); Destroy bounding box. void UpdateCache(); Update the internally cached volume and axes vectors - these are retained; for efficiency - many more reads than modifications. void Set(const TGLVertex3 vertex[8]); Set a bounding box from provided 8 ve",MatchSource.WIKI,root/html528/TGLBoundingBox.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLBoundingBox.html
https://root.cern/root/html528/TGLBoundingBox.html:2909,Performance,cache,cached,2909," other); voidSetAligned(const TGLVertex3& lowVertex, const TGLVertex3& highVertex); voidSetAligned(UInt_t nbPnts, const Double_t* pnts); voidSetEmpty(); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); voidTransform(const TGLMatrix& matrix); voidTranslate(const TGLVector3& offset); const TGLVertex3&Vertex(UInt_t index) const; const TGLVertex3*Vertices() const; Double_tVolume() const; Double_tXMax() const; Double_tXMin() const; Double_tYMax() const; Double_tYMin() const; Double_tZMax() const; Double_tZMin() const. private:. Double_tMax(UInt_t index) const; Double_tMin(UInt_t index) const; voidUpdateCache(); Bool_tValidIndex(UInt_t index) const. Data Members; public:. enum EFace { kFaceLowX; kFaceHighX; kFaceLowY; kFaceHighY; kFaceLowZ; kFaceHighZ; kFaceCount; };. private:. TGLVector3fAxes[3]! box axes in global frame - cached for speed; TGLVector3fAxesNorm[3]! normalised box axes in global frame - cached for speed; Double_tfDiagonal! max box diagonal - cached for speed; TGLVertex3fVertex[8]! the 8 bounding box vertices; Double_tfVolume! box volume - cached for speed. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLBoundingBox(); Construct an empty bounding box. TGLBoundingBox(const TGLVertex3 vertex[8]); Construct a bounding box from provided 8 vertices. TGLBoundingBox(const Double_t vertex[8][3]); Construct a bounding box from provided 8 vertices. TGLBoundingBox(const TGLVertex3& lowVertex, const TGLVertex3& highVertex); Construct an global axis ALIGNED bounding box from provided low/high vertex pair. TGLBoundingBox(const TGLBoundingBox& other); Construct a bounding box as copy of existing one. ~TGLBoundingBox(); Destroy bounding box. void UpdateCache(); Update the internally cached volume and axes vectors - these are retained; for efficiency - many more reads than modifications. void Set(const TGLVertex3 vertex[8]); Set a bounding box from provided 8 ve",MatchSource.WIKI,root/html528/TGLBoundingBox.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLBoundingBox.html
https://root.cern/root/html528/TGLBoundingBox.html:3008,Performance,cache,cached,3008," other); voidSetAligned(const TGLVertex3& lowVertex, const TGLVertex3& highVertex); voidSetAligned(UInt_t nbPnts, const Double_t* pnts); voidSetEmpty(); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); voidTransform(const TGLMatrix& matrix); voidTranslate(const TGLVector3& offset); const TGLVertex3&Vertex(UInt_t index) const; const TGLVertex3*Vertices() const; Double_tVolume() const; Double_tXMax() const; Double_tXMin() const; Double_tYMax() const; Double_tYMin() const; Double_tZMax() const; Double_tZMin() const. private:. Double_tMax(UInt_t index) const; Double_tMin(UInt_t index) const; voidUpdateCache(); Bool_tValidIndex(UInt_t index) const. Data Members; public:. enum EFace { kFaceLowX; kFaceHighX; kFaceLowY; kFaceHighY; kFaceLowZ; kFaceHighZ; kFaceCount; };. private:. TGLVector3fAxes[3]! box axes in global frame - cached for speed; TGLVector3fAxesNorm[3]! normalised box axes in global frame - cached for speed; Double_tfDiagonal! max box diagonal - cached for speed; TGLVertex3fVertex[8]! the 8 bounding box vertices; Double_tfVolume! box volume - cached for speed. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLBoundingBox(); Construct an empty bounding box. TGLBoundingBox(const TGLVertex3 vertex[8]); Construct a bounding box from provided 8 vertices. TGLBoundingBox(const Double_t vertex[8][3]); Construct a bounding box from provided 8 vertices. TGLBoundingBox(const TGLVertex3& lowVertex, const TGLVertex3& highVertex); Construct an global axis ALIGNED bounding box from provided low/high vertex pair. TGLBoundingBox(const TGLBoundingBox& other); Construct a bounding box as copy of existing one. ~TGLBoundingBox(); Destroy bounding box. void UpdateCache(); Update the internally cached volume and axes vectors - these are retained; for efficiency - many more reads than modifications. void Set(const TGLVertex3 vertex[8]); Set a bounding box from provided 8 ve",MatchSource.WIKI,root/html528/TGLBoundingBox.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLBoundingBox.html
https://root.cern/root/html528/TGLBoundingBox.html:3694,Performance,cache,cached,3694," TGLVector3fAxes[3]! box axes in global frame - cached for speed; TGLVector3fAxesNorm[3]! normalised box axes in global frame - cached for speed; Double_tfDiagonal! max box diagonal - cached for speed; TGLVertex3fVertex[8]! the 8 bounding box vertices; Double_tfVolume! box volume - cached for speed. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLBoundingBox(); Construct an empty bounding box. TGLBoundingBox(const TGLVertex3 vertex[8]); Construct a bounding box from provided 8 vertices. TGLBoundingBox(const Double_t vertex[8][3]); Construct a bounding box from provided 8 vertices. TGLBoundingBox(const TGLVertex3& lowVertex, const TGLVertex3& highVertex); Construct an global axis ALIGNED bounding box from provided low/high vertex pair. TGLBoundingBox(const TGLBoundingBox& other); Construct a bounding box as copy of existing one. ~TGLBoundingBox(); Destroy bounding box. void UpdateCache(); Update the internally cached volume and axes vectors - these are retained; for efficiency - many more reads than modifications. void Set(const TGLVertex3 vertex[8]); Set a bounding box from provided 8 vertices. void Set(const Double_t vertex[8][3]); Set a bounding box from provided 8 vertices. void Set(const TGLBoundingBox& other); Set a bounding box from vertices of other. void SetEmpty(); Set bounding box empty - all vertices at (0,0,0). void SetAligned(const TGLVertex3& lowVertex, const TGLVertex3& highVertex); Set ALIGNED box from two low/high vertices. Box axes are aligned with; global frame axes that vertices are specified in. void SetAligned(UInt_t nbPnts, const Double_t* pnts); Set ALIGNED box from one or more points. Box axes are aligned with; global frame axes that points are specified in. void MergeAligned(const TGLBoundingBox& other); Expand current bbox so that it includes other's bbox.; This make the bbox axis-aligned. void ExpandAligned(const TGLVertex3& point); Expand current bbox so that it includes the point.; This make",MatchSource.WIKI,root/html528/TGLBoundingBox.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLBoundingBox.html
https://root.cern/root/html528/TGLBoundingBox.html:506,Testability,test,tests,506,". TGLBoundingBox. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLBoundingBox. class TGLBoundingBox. TGLBoundingBox. Concrete class describing an orientated (free) or axis aligned box; of 8 verticies. Supports methods for setting aligned or orientated; boxes, find volume, axes, extents, centers, face planes etc.; Also tests for overlap testing of planes and other bounding boxes,; with fast sphere approximation. Function Members (Methods); public:. TGLBoundingBox(); TGLBoundingBox(const TGLVertex3* vertex); TGLBoundingBox(const Double_t** vertex); TGLBoundingBox(const TGLBoundingBox& other); TGLBoundingBox(const TGLVertex3& lowVertex, const TGLVertex3& highVertex); virtual~TGLBoundingBox(); const TGLVector3&Axis(UInt_t i, Bool_t normalised = kTRUE) const; TGLVertex3Center() const; static TClass*Class(); Double_tDiagonal() const; voidDraw(Bool_t solid = kFALSE) const; voidDump() const; voidExpandAligned(const TGLVertex3& point); TGLVector3Extents() const; const vector<UInt_t>&FaceVertices(TGLBoundingBox::EFace face) const; TGLPlaneGetNearPlane() const; virtual TClass*IsA() const; Bool_tIsEmpty() const; TGLVertex3MaxAAVertex() const; voidMergeAligned(const TGLBoundingBox& other); TGLVertex3MinAAVertex() const; Int_tNumVertices() const; TGLBoundingBox&operator=(const TGLBoundingBox& other); const TGLVertex3&operator[](UInt_t index) const; EOverlapOverlap(const TGLPlane& plane) const; EOverlapOverlap(const TGLBoundingBox& box) const; voidPlaneSet(TGLPlaneSet_t& planeSet) const; voidScale(Double_t factor); voidScale(Double_t xFactor, Double_t yFactor, Double_t zFactor); voidSet(const TGLVertex3* vertex); voidSet(const Double_t** vertex); voidSet(const TGLBoundingBox& other); voidSetAligned(const TGLVertex3& lowVertex, const TGLVertex3& highVertex); voidSetAligned(UInt_t nbPnts, const Double",MatchSource.WIKI,root/html528/TGLBoundingBox.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLBoundingBox.html
https://root.cern/root/html528/TGLBoundingBox.html:524,Testability,test,testing,524,". TGLBoundingBox. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLBoundingBox. class TGLBoundingBox. TGLBoundingBox. Concrete class describing an orientated (free) or axis aligned box; of 8 verticies. Supports methods for setting aligned or orientated; boxes, find volume, axes, extents, centers, face planes etc.; Also tests for overlap testing of planes and other bounding boxes,; with fast sphere approximation. Function Members (Methods); public:. TGLBoundingBox(); TGLBoundingBox(const TGLVertex3* vertex); TGLBoundingBox(const Double_t** vertex); TGLBoundingBox(const TGLBoundingBox& other); TGLBoundingBox(const TGLVertex3& lowVertex, const TGLVertex3& highVertex); virtual~TGLBoundingBox(); const TGLVector3&Axis(UInt_t i, Bool_t normalised = kTRUE) const; TGLVertex3Center() const; static TClass*Class(); Double_tDiagonal() const; voidDraw(Bool_t solid = kFALSE) const; voidDump() const; voidExpandAligned(const TGLVertex3& point); TGLVector3Extents() const; const vector<UInt_t>&FaceVertices(TGLBoundingBox::EFace face) const; TGLPlaneGetNearPlane() const; virtual TClass*IsA() const; Bool_tIsEmpty() const; TGLVertex3MaxAAVertex() const; voidMergeAligned(const TGLBoundingBox& other); TGLVertex3MinAAVertex() const; Int_tNumVertices() const; TGLBoundingBox&operator=(const TGLBoundingBox& other); const TGLVertex3&operator[](UInt_t index) const; EOverlapOverlap(const TGLPlane& plane) const; EOverlapOverlap(const TGLBoundingBox& box) const; voidPlaneSet(TGLPlaneSet_t& planeSet) const; voidScale(Double_t factor); voidScale(Double_t xFactor, Double_t yFactor, Double_t zFactor); voidSet(const TGLVertex3* vertex); voidSet(const Double_t** vertex); voidSet(const TGLBoundingBox& other); voidSetAligned(const TGLVertex3& lowVertex, const TGLVertex3& highVertex); voidSetAligned(UInt_t nbPnts, const Double",MatchSource.WIKI,root/html528/TGLBoundingBox.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLBoundingBox.html
https://root.cern/root/html528/TGLBoxPainter.html:342,Modifiability,variab,variable-sized,342,". TGLBoxPainter. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLBoxPainter. class TGLBoxPainter: public TGLPlotPainter. Paints TH3 histograms by rendering variable-sized bozes matching the; bin contents. Function Members (Methods); public:. TGLBoxPainter(TH1* hist, TGLPlotCamera* camera, TGLPlotCoordinates* coord); ~TGLBoxPainter(); virtual voidAddOption(const TString& stringOption); static TClass*Class(); Bool_tTGLPlotPainter::CutAxisSelected() const; virtual char*GetPlotInfo(Int_t px, Int_t py); virtual Bool_tInitGeometry(); voidTGLPlotPainter::InvalidateSelection(); virtual TClass*IsA() const; virtual voidTGLPlotPainter::Paint(); virtual voidPan(Int_t px, Int_t py); virtual Bool_tTGLPlotPainter::PlotSelected(Int_t px, Int_t py); virtual voidProcessEvent(Int_t event, Int_t px, Int_t py); const TGLPlotBox&TGLPlotPainter::RefBackBox() const; virtual voidTGLPlotPainter::SetFrameColor(const TColor* frameColor); voidTGLPlotPainter::SetPadColor(const TColor* color); virtual voidShowMembers(TMemberInspector& insp); virtual voidStartPan(Int_t px, Int_t py); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). protected:. virtual voidTGLPlotPainter::ClearBuffers() const; voidTGLPlotPainter::DrawSections() const; const TColor*TGLPlotPainter::GetPadColor() const; voidTGLPlotPainter::MoveSection(Int_t px, Int_t py); voidTGLPlotPainter::PrintPlot() const; voidTGLPlotPainter::RestoreModelviewMatrix() const; voidTGLPlotPainter::RestoreProjectionMatrix() const; voidTGLPlotPainter::SaveModelviewMatrix() const; voidTGLPlotPainter::SaveProjectionMatrix() const. private:. TGLBoxPainter(const TGLBoxPainter&); virtual voidDeInitGL() const; voidDrawPalette() const; virtual voidDrawPaletteAxis() const; virtual voidDrawPlot() const; virtual voidDrawSectionXOY() const; virtual voidDrawSection",MatchSource.WIKI,root/html528/TGLBoxPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLBoxPainter.html
https://root.cern/root/html528/TGLBoxPainter.html:4140,Modifiability,variab,variables,4140,"ainter::fXOZSectionPos; TAxis*TGLPlotPainter::fYAxis; Double_tTGLPlotPainter::fYOZSectionPos; TAxis*TGLPlotPainter::fZAxis; vector<Double_t>TGLPlotPainter::fZLevels. private:. pair<double,double>fMinMaxVal; TStringfPlotInfo; TGLQuadricfQuadric; TGLBoxPainter::EBoxTypefType; TGLTH3SlicefXOYSlice; TGLTH3SlicefXOZSlice; TGLTH3SlicefYOZSlice. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLBoxPainter(TH1* hist, TGLPlotCamera* camera, TGLPlotCoordinates* coord); Normal constructor. char * GetPlotInfo(Int_t px, Int_t py); Show box info (i, j, k, binContent). Bool_t InitGeometry(); Set ranges, find min and max bin content. void StartPan(Int_t px, Int_t py); User clicks right mouse button (in a pad). void Pan(Int_t px, Int_t py); User's moving mouse cursor, with middle mouse button pressed (for pad).; Calculate 3d shift related to 2d mouse movement. void AddOption(const TString& stringOption); Box1 == spheres. void ProcessEvent(Int_t event, Int_t px, Int_t py); Remove sections. void InitGL() const; Initialize some gl state variables. void DeInitGL() const; Return back some gl state variables. void DrawPlot() const; Draw set of boxes (spheres). void SetPlotColor() const; Set boxes color. void DrawSectionXOZ() const; Draw XOZ parallel section. void DrawSectionYOZ() const; Draw YOZ parallel section. void DrawSectionXOY() const; Draw XOY parallel section. Bool_t HasSections() const; Check, if any section exists. void DrawPalette() const; Draw. Palette.; Originally, fCamera was never null.; It can be a null now because of gl-viewer. void DrawPaletteAxis() const; Draw. Palette. Axis. TGLBoxPainter(const TGLBoxPainter& ). » Author: Timur Pocheptsov 31/08/2006 » Copyright (C) 1995-2006, Rene Brun and Fons Rademakers. *; » Last changed: root/gl:$Id$ » Last generated: 2010-10-27 15:36; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html528/TGLBoxPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLBoxPainter.html
https://root.cern/root/html528/TGLBoxPainter.html:4200,Modifiability,variab,variables,4200,"ainter::fXOZSectionPos; TAxis*TGLPlotPainter::fYAxis; Double_tTGLPlotPainter::fYOZSectionPos; TAxis*TGLPlotPainter::fZAxis; vector<Double_t>TGLPlotPainter::fZLevels. private:. pair<double,double>fMinMaxVal; TStringfPlotInfo; TGLQuadricfQuadric; TGLBoxPainter::EBoxTypefType; TGLTH3SlicefXOYSlice; TGLTH3SlicefXOZSlice; TGLTH3SlicefYOZSlice. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLBoxPainter(TH1* hist, TGLPlotCamera* camera, TGLPlotCoordinates* coord); Normal constructor. char * GetPlotInfo(Int_t px, Int_t py); Show box info (i, j, k, binContent). Bool_t InitGeometry(); Set ranges, find min and max bin content. void StartPan(Int_t px, Int_t py); User clicks right mouse button (in a pad). void Pan(Int_t px, Int_t py); User's moving mouse cursor, with middle mouse button pressed (for pad).; Calculate 3d shift related to 2d mouse movement. void AddOption(const TString& stringOption); Box1 == spheres. void ProcessEvent(Int_t event, Int_t px, Int_t py); Remove sections. void InitGL() const; Initialize some gl state variables. void DeInitGL() const; Return back some gl state variables. void DrawPlot() const; Draw set of boxes (spheres). void SetPlotColor() const; Set boxes color. void DrawSectionXOZ() const; Draw XOZ parallel section. void DrawSectionYOZ() const; Draw YOZ parallel section. void DrawSectionXOY() const; Draw XOY parallel section. Bool_t HasSections() const; Check, if any section exists. void DrawPalette() const; Draw. Palette.; Originally, fCamera was never null.; It can be a null now because of gl-viewer. void DrawPaletteAxis() const; Draw. Palette. Axis. TGLBoxPainter(const TGLBoxPainter& ). » Author: Timur Pocheptsov 31/08/2006 » Copyright (C) 1995-2006, Rene Brun and Fons Rademakers. *; » Last changed: root/gl:$Id$ » Last generated: 2010-10-27 15:36; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html528/TGLBoxPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLBoxPainter.html
https://root.cern/root/html528/TGLCamera.html:1043,Availability,avail,available,1043,"epage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLCamera. class TGLCamera. TGLCamera. Abstract base camera class - concrete classes for orthographic and; persepctive cameras derive from it. This class maintains values for; the current:; i) Viewport; ii) Projection, modelview and clip matricies - extracted from GL; iii) The 6 frustum planes; iv) Expanded frustum interest box. It provides methods for various projection, overlap and intersection; tests for viewport and world locations, against the true frustum and; expanded interest box, and for extracting eye position and direction. It also defines the pure virtual manipulation interface methods the; concrete ortho and prespective classes must implement. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TGLCamera(); Bool_tAdjustAndClampVal(Double_t& val, Double_t min, Double_t max, Int_t screenShift, Int_t screenShiftRange, Bool_t mod1, Bool_t mod2) const; Double_tAdjustDelta(Double_t screenShift, Double_t deltaFactor, Bool_t mod1, Bool_t mod2) const; virtual voidApply(const TGLBoundingBox& sceneBox, const TGLRect* pickRect = 0) const; static TClass*Class(); virtual voidConfigure(Double_t zoom, Double_t dolly, Double_t* center, Double_t hRotate, Double_t vRotate); virtual Bool_tDolly(Int_t delta, Bool_t mod1, Bool_t mod2); voidDrawDebugAids() const; TGLVector3EyeDirection() const; TGLVertex3EyePoint() const; TGLVertex3FrustumCenter() const; EOverlapFrustumOverlap(const TGLBoundingBox& box) const; const TGLPlane&FrustumPlane(TGLCamera::EFrustumPlane plane) const; const TGLMatrix&GetCamBase() const; const TGLMatrix&GetCamTrans() const; Double_t*GetCenterVec(); Bool_tGetExternalCenter(); Double_tGetFarClip() const; Double_t*GetFixDefCenter",MatchSource.WIKI,root/html528/TGLCamera.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLCamera.html
https://root.cern/root/html528/TGLCamera.html:14130,Deployability,configurat,configuration,14130,"er last modifcation, before using. TGLVector3 ViewportDeltaToWorld(const TGLVertex3& worldRef, Double_t viewportXDelta, Double_t viewportYDelta, TGLMatrix* modviewMat = 0) const; Apply a 2D viewport delta (shift) to the projection of worldRef onto viewport,; returning the resultant world vector which equates to it. Useful for making; 3D world objects track mouse moves. Camera must have valid frustum cache - call Apply(). Bool_t OfInterest(const TGLBoundingBox& box, Bool_t ignoreSize) const; Calculate if the an object defined by world frame bounding box; is 'of interest' to the camera. This is defined as box:. i) intersecting completely or partially (kInside/kPartial) with; cameras interest box (fInterestBox); ii) having significant length OR volume ratio compared to this; interest box. If a box is 'of interest' returns kTRUE, kFALSE otherwise. See; TGLCamera::UpdateInterest() for more details of camera interest; box. Note: Length/volume ratios NOT dependent on the projected size; of box at current camera configuration as we do not want; continual changes. This is used when (re) populating the scene; with objects from external client. TODO: Might be more logical to move this test out to client -; and have accessor for fInterestBox instead?. Bool_t UpdateInterest(Bool_t force); Update the internal interest box (fInterestBox) of the camera.; The interest box is an orientated bounding box, calculated as; an expanded container round the frustum. It is used to test if; if object bounding boxes are of interest (should be accepted; into viewer scene) for a camera - see TGLCamera::OfInterest(). The interest box is updated if the frustum is no longer contained; in the existing one, or a new one calculated on the current frustum; differs significantly in volume (camera has been zoomed/dollyed; sizable amount). If the interest box is updated we return kTRUE - kFALSE otherwise. void ResetInterest(); Clear out the existing interest box. Bool_t AdjustAndClampVal(Double_t& val, Doub",MatchSource.WIKI,root/html528/TGLCamera.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLCamera.html
https://root.cern/root/html528/TGLCamera.html:14743,Deployability,update,updated,14743,") having significant length OR volume ratio compared to this; interest box. If a box is 'of interest' returns kTRUE, kFALSE otherwise. See; TGLCamera::UpdateInterest() for more details of camera interest; box. Note: Length/volume ratios NOT dependent on the projected size; of box at current camera configuration as we do not want; continual changes. This is used when (re) populating the scene; with objects from external client. TODO: Might be more logical to move this test out to client -; and have accessor for fInterestBox instead?. Bool_t UpdateInterest(Bool_t force); Update the internal interest box (fInterestBox) of the camera.; The interest box is an orientated bounding box, calculated as; an expanded container round the frustum. It is used to test if; if object bounding boxes are of interest (should be accepted; into viewer scene) for a camera - see TGLCamera::OfInterest(). The interest box is updated if the frustum is no longer contained; in the existing one, or a new one calculated on the current frustum; differs significantly in volume (camera has been zoomed/dollyed; sizable amount). If the interest box is updated we return kTRUE - kFALSE otherwise. void ResetInterest(); Clear out the existing interest box. Bool_t AdjustAndClampVal(Double_t& val, Double_t min, Double_t max, Int_t screenShift, Int_t screenShiftRange, Bool_t mod1, Bool_t mod2) const; Adjust a passed REFERENCE value 'val', based on screenShift delta.; Two modifier flags ('mod1' / 'mod2' ) for sensitivity:. mod1 = kFALSE, mod2 = kFALSE : normal sensitivity (screenShift/screenShiftRange); mod1 = kTRUE, mod2 = kFALSE : 0.1x sensitivity; mod1 = kTRUE, mod2 = kTRUE : 0.01x sensitivity; mod1 = kFALSE, mod2 = kTRUE : 10.0x sensitivity. 'val' is modified and clamped to 'min' / 'max' range.; Return bool kTRUE if val actually changed. Used as common interaction function for adjusting zoom/dolly etc. Double_t AdjustDelta(Double_t screenShift, Double_t deltaFactor, Bool_t mod1, Bool_t mod2) const; Adjust ",MatchSource.WIKI,root/html528/TGLCamera.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLCamera.html
https://root.cern/root/html528/TGLCamera.html:14964,Deployability,update,updated,14964,"LCamera::UpdateInterest() for more details of camera interest; box. Note: Length/volume ratios NOT dependent on the projected size; of box at current camera configuration as we do not want; continual changes. This is used when (re) populating the scene; with objects from external client. TODO: Might be more logical to move this test out to client -; and have accessor for fInterestBox instead?. Bool_t UpdateInterest(Bool_t force); Update the internal interest box (fInterestBox) of the camera.; The interest box is an orientated bounding box, calculated as; an expanded container round the frustum. It is used to test if; if object bounding boxes are of interest (should be accepted; into viewer scene) for a camera - see TGLCamera::OfInterest(). The interest box is updated if the frustum is no longer contained; in the existing one, or a new one calculated on the current frustum; differs significantly in volume (camera has been zoomed/dollyed; sizable amount). If the interest box is updated we return kTRUE - kFALSE otherwise. void ResetInterest(); Clear out the existing interest box. Bool_t AdjustAndClampVal(Double_t& val, Double_t min, Double_t max, Int_t screenShift, Int_t screenShiftRange, Bool_t mod1, Bool_t mod2) const; Adjust a passed REFERENCE value 'val', based on screenShift delta.; Two modifier flags ('mod1' / 'mod2' ) for sensitivity:. mod1 = kFALSE, mod2 = kFALSE : normal sensitivity (screenShift/screenShiftRange); mod1 = kTRUE, mod2 = kFALSE : 0.1x sensitivity; mod1 = kTRUE, mod2 = kTRUE : 0.01x sensitivity; mod1 = kFALSE, mod2 = kTRUE : 10.0x sensitivity. 'val' is modified and clamped to 'min' / 'max' range.; Return bool kTRUE if val actually changed. Used as common interaction function for adjusting zoom/dolly etc. Double_t AdjustDelta(Double_t screenShift, Double_t deltaFactor, Bool_t mod1, Bool_t mod2) const; Adjust a passed screen value and apply modifiers.; See AdjustAndClampVal() for details. void DrawDebugAids() const; Draw out some debugging aids for t",MatchSource.WIKI,root/html528/TGLCamera.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLCamera.html
https://root.cern/root/html528/TGLCamera.html:831,Integrability,interface,interface,831,". TGLCamera. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLCamera. class TGLCamera. TGLCamera. Abstract base camera class - concrete classes for orthographic and; persepctive cameras derive from it. This class maintains values for; the current:; i) Viewport; ii) Projection, modelview and clip matricies - extracted from GL; iii) The 6 frustum planes; iv) Expanded frustum interest box. It provides methods for various projection, overlap and intersection; tests for viewport and world locations, against the true frustum and; expanded interest box, and for extracting eye position and direction. It also defines the pure virtual manipulation interface methods the; concrete ortho and prespective classes must implement. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TGLCamera(); Bool_tAdjustAndClampVal(Double_t& val, Double_t min, Double_t max, Int_t screenShift, Int_t screenShiftRange, Bool_t mod1, Bool_t mod2) const; Double_tAdjustDelta(Double_t screenShift, Double_t deltaFactor, Bool_t mod1, Bool_t mod2) const; virtual voidApply(const TGLBoundingBox& sceneBox, const TGLRect* pickRect = 0) const; static TClass*Class(); virtual voidConfigure(Double_t zoom, Double_t dolly, Double_t* center, Double_t hRotate, Double_t vRotate); virtual Bool_tDolly(Int_t delta, Bool_t mod1, Bool_t mod2); voidDrawDebugAids() const; TGLVector3EyeDirection() const; TGLVertex3EyePoint() const; TGLVertex3FrustumCenter() const; EOverlapFrustumOverlap(const TGLBoundingBox& box) const; const TGLPlane&FrustumPlane(TGLCamera::EFrustumPlane plane) const; const TGLMatrix&GetCamBase() const; const TGLMatrix&GetCamTrans() const; Double_t*GetCenterVec(); Bool_tGetExternalCenter(); Double_tGetFarCli",MatchSource.WIKI,root/html528/TGLCamera.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLCamera.html
https://root.cern/root/html528/TGLCamera.html:14072,Integrability,depend,dependent,14072,"er last modifcation, before using. TGLVector3 ViewportDeltaToWorld(const TGLVertex3& worldRef, Double_t viewportXDelta, Double_t viewportYDelta, TGLMatrix* modviewMat = 0) const; Apply a 2D viewport delta (shift) to the projection of worldRef onto viewport,; returning the resultant world vector which equates to it. Useful for making; 3D world objects track mouse moves. Camera must have valid frustum cache - call Apply(). Bool_t OfInterest(const TGLBoundingBox& box, Bool_t ignoreSize) const; Calculate if the an object defined by world frame bounding box; is 'of interest' to the camera. This is defined as box:. i) intersecting completely or partially (kInside/kPartial) with; cameras interest box (fInterestBox); ii) having significant length OR volume ratio compared to this; interest box. If a box is 'of interest' returns kTRUE, kFALSE otherwise. See; TGLCamera::UpdateInterest() for more details of camera interest; box. Note: Length/volume ratios NOT dependent on the projected size; of box at current camera configuration as we do not want; continual changes. This is used when (re) populating the scene; with objects from external client. TODO: Might be more logical to move this test out to client -; and have accessor for fInterestBox instead?. Bool_t UpdateInterest(Bool_t force); Update the internal interest box (fInterestBox) of the camera.; The interest box is an orientated bounding box, calculated as; an expanded container round the frustum. It is used to test if; if object bounding boxes are of interest (should be accepted; into viewer scene) for a camera - see TGLCamera::OfInterest(). The interest box is updated if the frustum is no longer contained; in the existing one, or a new one calculated on the current frustum; differs significantly in volume (camera has been zoomed/dollyed; sizable amount). If the interest box is updated we return kTRUE - kFALSE otherwise. void ResetInterest(); Clear out the existing interest box. Bool_t AdjustAndClampVal(Double_t& val, Doub",MatchSource.WIKI,root/html528/TGLCamera.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLCamera.html
https://root.cern/root/html528/TGLCamera.html:18194,Integrability,interface,interface,18194,"l_t mod1, Bool_t mod2); Dolly the camera - 'move camera along eye line, retaining lens focal length'.; Arguments are:. 'delta' - mouse viewport delta (pixels) - +ive dolly in, -ive dolly out; 'mod1' / 'mod2' - sensitivity modifiers - see TGLCamera::AdjustAndClampVal(). Returns kTRUE is redraw required (camera change), kFALSE otherwise. const TGLPlane & FrustumPlane(TGLCamera::EFrustumPlane plane) const; Return one of the planes forming the camera frustum. TGLCamera & operator=(const TGLCamera& ). Bool_t IsOrthographic() const; { return kFALSE; }. Bool_t IsPerspective() const; { return kFALSE; }. const TGLMatrix& RefModelViewMatrix() const; { return fModVM; }. Bool_t IsCacheDirty() const; { return fCacheDirty; }. void IncTimeStamp(); { fCacheDirty = kTRUE; ++fTimeStamp; }. UInt_t TimeStamp() const; { return fTimeStamp; }. TGLRect& RefViewport(); { return fViewport; }. const TGLRect& RefViewport() const; { return fViewport; }. void Setup(const TGLBoundingBox& box, Bool_t reset = kTRUE); Camera manipulation interface (GL coord - origin bottom left). void Reset(). Bool_t Zoom(Int_t delta, Bool_t mod1, Bool_t mod2). Bool_t Truck(Double_t xDelta, Double_t yDelta). void Apply(const TGLBoundingBox& sceneBox, const TGLRect* pickRect = 0) const. Bool_t GetExternalCenter(); { return fExternalCenter; }. Double_t* GetCenterVec(); { return fCenter->Arr(); }. void SetFixDefCenter(Bool_t x); { fFixDefCenter = x; }. void SetFixDefCenterVec(Double_t x, Double_t y, Double_t z); { fFDCenter.Set(x, y, z); }. Double_t* GetFixDefCenterVec(); { return fFDCenter.Arr(); }. Double_t GetNearClip() const; { return fNearClip; }. Double_t GetFarClip() const; { return fFarClip; }. const TGLMatrix& GetCamBase() const; { return fCamBase; }. const TGLMatrix& GetCamTrans() const; If you manipulate camera ... also call IncTimeStamp() before redraw. { return fCamTrans; }. TGLMatrix& RefCamBase(); { return fCamBase; }. TGLMatrix& RefCamTrans(); { return fCamTrans; }. TGLMatrix& RefLastNoPickProjM() const",MatchSource.WIKI,root/html528/TGLCamera.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLCamera.html
https://root.cern/root/html528/TGLCamera.html:12529,Modifiability,extend,extended,12529,"near to far camera clip planes; (the minimum and maximum visible depth). See also; TGLVertex3 TGLCamera::ViewportToWorld(const TGLVertex3 & viewportVertex) const; for 3D viewport -> 3D world vertex conversions.; See also OpenGL gluUnProject & glDepth documentation. Camera must have valid frustum cache - call Apply() after last modifcation, before using. std::pair<Bool_t, TGLVertex3> ViewportPlaneIntersection(Double_t viewportX, Double_t viewportY, const TGLPlane& worldPlane) const; Find the intersection of projection of supplied viewport point (a 3D world; line - see ViewportToWorld) with supplied world plane. Returns std::pair; of Bool_t and TGLVertex3. If line intersects std::pair.first (Bool_t) is; kTRUE, and std::pair.second (TGLVertex) contains the intersection vertex.; If line does not intersect (line and plane parallel) std::pair.first; (Bool_t) if kFALSE, and std::pair.second (TGLVertex) is invalid. NOTE: The projection lines is extended for the plane intersection test; hence the intersection vertex can lie outside the near/far clip regions; (not visible). Camera must have valid frustum cache - call Apply() after last modifcation, before using. std::pair<Bool_t, TGLVertex3> ViewportPlaneIntersection(const TPoint& viewport, const TGLPlane& worldPlane) const; Find the intersection of projection of supplied viewport TPoint (a 3D world; line - see ViewportToWorld) with supplied world plane. Returns std::pair; of bool and vertex. If line intersects. Camera must have valid frustum cache - call Apply() after last modifcation, before using. TGLVector3 ViewportDeltaToWorld(const TGLVertex3& worldRef, Double_t viewportXDelta, Double_t viewportYDelta, TGLMatrix* modviewMat = 0) const; Apply a 2D viewport delta (shift) to the projection of worldRef onto viewport,; returning the resultant world vector which equates to it. Useful for making; 3D world objects track mouse moves. Camera must have valid frustum cache - call Apply(). Bool_t OfInterest(const TGLBoundingBox& box",MatchSource.WIKI,root/html528/TGLCamera.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLCamera.html
https://root.cern/root/html528/TGLCamera.html:14130,Modifiability,config,configuration,14130,"er last modifcation, before using. TGLVector3 ViewportDeltaToWorld(const TGLVertex3& worldRef, Double_t viewportXDelta, Double_t viewportYDelta, TGLMatrix* modviewMat = 0) const; Apply a 2D viewport delta (shift) to the projection of worldRef onto viewport,; returning the resultant world vector which equates to it. Useful for making; 3D world objects track mouse moves. Camera must have valid frustum cache - call Apply(). Bool_t OfInterest(const TGLBoundingBox& box, Bool_t ignoreSize) const; Calculate if the an object defined by world frame bounding box; is 'of interest' to the camera. This is defined as box:. i) intersecting completely or partially (kInside/kPartial) with; cameras interest box (fInterestBox); ii) having significant length OR volume ratio compared to this; interest box. If a box is 'of interest' returns kTRUE, kFALSE otherwise. See; TGLCamera::UpdateInterest() for more details of camera interest; box. Note: Length/volume ratios NOT dependent on the projected size; of box at current camera configuration as we do not want; continual changes. This is used when (re) populating the scene; with objects from external client. TODO: Might be more logical to move this test out to client -; and have accessor for fInterestBox instead?. Bool_t UpdateInterest(Bool_t force); Update the internal interest box (fInterestBox) of the camera.; The interest box is an orientated bounding box, calculated as; an expanded container round the frustum. It is used to test if; if object bounding boxes are of interest (should be accepted; into viewer scene) for a camera - see TGLCamera::OfInterest(). The interest box is updated if the frustum is no longer contained; in the existing one, or a new one calculated on the current frustum; differs significantly in volume (camera has been zoomed/dollyed; sizable amount). If the interest box is updated we return kTRUE - kFALSE otherwise. void ResetInterest(); Clear out the existing interest box. Bool_t AdjustAndClampVal(Double_t& val, Doub",MatchSource.WIKI,root/html528/TGLCamera.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLCamera.html
https://root.cern/root/html528/TGLCamera.html:4933,Performance,cache,cached,4933,"atrix* modviewMat = 0) const; virtual Bool_tZoom(Int_t delta, Bool_t mod1, Bool_t mod2). protected:. voidUpdateCache() const. private:. TGLBoundingBoxFrustum(Bool_t asBox = kTRUE) const; TGLCamera&operator=(const TGLCamera&). Data Members; public:. enum EFrustumPlane { kNear; kLeft; kRight; kTop; kBottom; kFar; kPlanesPerFrustum; };. protected:. Bool_tfCacheDirty! cached items dirty?; TGLMatrixfCamBase! tranformation to center and rotation from up to x vector; TGLMatrixfCamTrans! transformation relative to fCamTrans; TGLVector3*fCenter! current camera center; TGLMatrixfClipM! object space clip matrix (cached); TGLVector3fDefCenter! deafult camera center; Double_tfDollyDefault! default distnce from viewing centre; Double_tfDollyDistance! unit distance for camera movement in fwd/bck direction; TGLVector3fExtCenter! external camera center; Bool_tfExternalCenter! use external center insead of scene center; TGLVector3fFDCenter! fixed deafult camera center; Double_tfFarClip! last applied far-clip; Bool_tfFixDefCenter! use fixed default center; TGLPlanefFrustumPlanes[6]! frustum planes (cached); TGLBoundingBoxfInterestBox! the interest box - created in UpdateInterest(); Double_tfLargestSeen! largest box diagonal seen in OfInterest() - used when; TGLMatrixfLastNoPickProjM! no-pick projection matrix (cached); TGLMatrixfModVM! modelView matrix (cached); Double_tfNearClip! last applied near-clip; TGLMatrixfProjM! projection matrix (cached); UInt_tfTimeStamp! timestamp; Float_tfVAxisMinAngle! minimal allowed angle between up and fCamTrans Z vector; TGLRectfViewport! viewport (GL coords - origin bottom left); static UInt_tfgDollyDeltaSens. private:. TGLBoundingBoxfInterestFrustum! frustum basis of current interest box - NOT a true BB! (DEBUG); TGLBoundingBoxfInterestFrustumAsBox! frustum basis (as box) of current interest box (DEBUG); TGLBoundingBoxfPreviousInterestBox! previous interest box (DEBUG); static const Double_tfgInterestBoxExpansion! expansion c.f. aligned current frus",MatchSource.WIKI,root/html528/TGLCamera.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLCamera.html
https://root.cern/root/html528/TGLCamera.html:5175,Performance,cache,cached,5175,"atrix* modviewMat = 0) const; virtual Bool_tZoom(Int_t delta, Bool_t mod1, Bool_t mod2). protected:. voidUpdateCache() const. private:. TGLBoundingBoxFrustum(Bool_t asBox = kTRUE) const; TGLCamera&operator=(const TGLCamera&). Data Members; public:. enum EFrustumPlane { kNear; kLeft; kRight; kTop; kBottom; kFar; kPlanesPerFrustum; };. protected:. Bool_tfCacheDirty! cached items dirty?; TGLMatrixfCamBase! tranformation to center and rotation from up to x vector; TGLMatrixfCamTrans! transformation relative to fCamTrans; TGLVector3*fCenter! current camera center; TGLMatrixfClipM! object space clip matrix (cached); TGLVector3fDefCenter! deafult camera center; Double_tfDollyDefault! default distnce from viewing centre; Double_tfDollyDistance! unit distance for camera movement in fwd/bck direction; TGLVector3fExtCenter! external camera center; Bool_tfExternalCenter! use external center insead of scene center; TGLVector3fFDCenter! fixed deafult camera center; Double_tfFarClip! last applied far-clip; Bool_tfFixDefCenter! use fixed default center; TGLPlanefFrustumPlanes[6]! frustum planes (cached); TGLBoundingBoxfInterestBox! the interest box - created in UpdateInterest(); Double_tfLargestSeen! largest box diagonal seen in OfInterest() - used when; TGLMatrixfLastNoPickProjM! no-pick projection matrix (cached); TGLMatrixfModVM! modelView matrix (cached); Double_tfNearClip! last applied near-clip; TGLMatrixfProjM! projection matrix (cached); UInt_tfTimeStamp! timestamp; Float_tfVAxisMinAngle! minimal allowed angle between up and fCamTrans Z vector; TGLRectfViewport! viewport (GL coords - origin bottom left); static UInt_tfgDollyDeltaSens. private:. TGLBoundingBoxfInterestFrustum! frustum basis of current interest box - NOT a true BB! (DEBUG); TGLBoundingBoxfInterestFrustumAsBox! frustum basis (as box) of current interest box (DEBUG); TGLBoundingBoxfPreviousInterestBox! previous interest box (DEBUG); static const Double_tfgInterestBoxExpansion! expansion c.f. aligned current frus",MatchSource.WIKI,root/html528/TGLCamera.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLCamera.html
https://root.cern/root/html528/TGLCamera.html:5663,Performance,cache,cached,5663,"atrix* modviewMat = 0) const; virtual Bool_tZoom(Int_t delta, Bool_t mod1, Bool_t mod2). protected:. voidUpdateCache() const. private:. TGLBoundingBoxFrustum(Bool_t asBox = kTRUE) const; TGLCamera&operator=(const TGLCamera&). Data Members; public:. enum EFrustumPlane { kNear; kLeft; kRight; kTop; kBottom; kFar; kPlanesPerFrustum; };. protected:. Bool_tfCacheDirty! cached items dirty?; TGLMatrixfCamBase! tranformation to center and rotation from up to x vector; TGLMatrixfCamTrans! transformation relative to fCamTrans; TGLVector3*fCenter! current camera center; TGLMatrixfClipM! object space clip matrix (cached); TGLVector3fDefCenter! deafult camera center; Double_tfDollyDefault! default distnce from viewing centre; Double_tfDollyDistance! unit distance for camera movement in fwd/bck direction; TGLVector3fExtCenter! external camera center; Bool_tfExternalCenter! use external center insead of scene center; TGLVector3fFDCenter! fixed deafult camera center; Double_tfFarClip! last applied far-clip; Bool_tfFixDefCenter! use fixed default center; TGLPlanefFrustumPlanes[6]! frustum planes (cached); TGLBoundingBoxfInterestBox! the interest box - created in UpdateInterest(); Double_tfLargestSeen! largest box diagonal seen in OfInterest() - used when; TGLMatrixfLastNoPickProjM! no-pick projection matrix (cached); TGLMatrixfModVM! modelView matrix (cached); Double_tfNearClip! last applied near-clip; TGLMatrixfProjM! projection matrix (cached); UInt_tfTimeStamp! timestamp; Float_tfVAxisMinAngle! minimal allowed angle between up and fCamTrans Z vector; TGLRectfViewport! viewport (GL coords - origin bottom left); static UInt_tfgDollyDeltaSens. private:. TGLBoundingBoxfInterestFrustum! frustum basis of current interest box - NOT a true BB! (DEBUG); TGLBoundingBoxfInterestFrustumAsBox! frustum basis (as box) of current interest box (DEBUG); TGLBoundingBoxfPreviousInterestBox! previous interest box (DEBUG); static const Double_tfgInterestBoxExpansion! expansion c.f. aligned current frus",MatchSource.WIKI,root/html528/TGLCamera.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLCamera.html
https://root.cern/root/html528/TGLCamera.html:5879,Performance,cache,cached,5879,"atrix* modviewMat = 0) const; virtual Bool_tZoom(Int_t delta, Bool_t mod1, Bool_t mod2). protected:. voidUpdateCache() const. private:. TGLBoundingBoxFrustum(Bool_t asBox = kTRUE) const; TGLCamera&operator=(const TGLCamera&). Data Members; public:. enum EFrustumPlane { kNear; kLeft; kRight; kTop; kBottom; kFar; kPlanesPerFrustum; };. protected:. Bool_tfCacheDirty! cached items dirty?; TGLMatrixfCamBase! tranformation to center and rotation from up to x vector; TGLMatrixfCamTrans! transformation relative to fCamTrans; TGLVector3*fCenter! current camera center; TGLMatrixfClipM! object space clip matrix (cached); TGLVector3fDefCenter! deafult camera center; Double_tfDollyDefault! default distnce from viewing centre; Double_tfDollyDistance! unit distance for camera movement in fwd/bck direction; TGLVector3fExtCenter! external camera center; Bool_tfExternalCenter! use external center insead of scene center; TGLVector3fFDCenter! fixed deafult camera center; Double_tfFarClip! last applied far-clip; Bool_tfFixDefCenter! use fixed default center; TGLPlanefFrustumPlanes[6]! frustum planes (cached); TGLBoundingBoxfInterestBox! the interest box - created in UpdateInterest(); Double_tfLargestSeen! largest box diagonal seen in OfInterest() - used when; TGLMatrixfLastNoPickProjM! no-pick projection matrix (cached); TGLMatrixfModVM! modelView matrix (cached); Double_tfNearClip! last applied near-clip; TGLMatrixfProjM! projection matrix (cached); UInt_tfTimeStamp! timestamp; Float_tfVAxisMinAngle! minimal allowed angle between up and fCamTrans Z vector; TGLRectfViewport! viewport (GL coords - origin bottom left); static UInt_tfgDollyDeltaSens. private:. TGLBoundingBoxfInterestFrustum! frustum basis of current interest box - NOT a true BB! (DEBUG); TGLBoundingBoxfInterestFrustumAsBox! frustum basis (as box) of current interest box (DEBUG); TGLBoundingBoxfPreviousInterestBox! previous interest box (DEBUG); static const Double_tfgInterestBoxExpansion! expansion c.f. aligned current frus",MatchSource.WIKI,root/html528/TGLCamera.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLCamera.html
https://root.cern/root/html528/TGLCamera.html:5923,Performance,cache,cached,5923,"atrix* modviewMat = 0) const; virtual Bool_tZoom(Int_t delta, Bool_t mod1, Bool_t mod2). protected:. voidUpdateCache() const. private:. TGLBoundingBoxFrustum(Bool_t asBox = kTRUE) const; TGLCamera&operator=(const TGLCamera&). Data Members; public:. enum EFrustumPlane { kNear; kLeft; kRight; kTop; kBottom; kFar; kPlanesPerFrustum; };. protected:. Bool_tfCacheDirty! cached items dirty?; TGLMatrixfCamBase! tranformation to center and rotation from up to x vector; TGLMatrixfCamTrans! transformation relative to fCamTrans; TGLVector3*fCenter! current camera center; TGLMatrixfClipM! object space clip matrix (cached); TGLVector3fDefCenter! deafult camera center; Double_tfDollyDefault! default distnce from viewing centre; Double_tfDollyDistance! unit distance for camera movement in fwd/bck direction; TGLVector3fExtCenter! external camera center; Bool_tfExternalCenter! use external center insead of scene center; TGLVector3fFDCenter! fixed deafult camera center; Double_tfFarClip! last applied far-clip; Bool_tfFixDefCenter! use fixed default center; TGLPlanefFrustumPlanes[6]! frustum planes (cached); TGLBoundingBoxfInterestBox! the interest box - created in UpdateInterest(); Double_tfLargestSeen! largest box diagonal seen in OfInterest() - used when; TGLMatrixfLastNoPickProjM! no-pick projection matrix (cached); TGLMatrixfModVM! modelView matrix (cached); Double_tfNearClip! last applied near-clip; TGLMatrixfProjM! projection matrix (cached); UInt_tfTimeStamp! timestamp; Float_tfVAxisMinAngle! minimal allowed angle between up and fCamTrans Z vector; TGLRectfViewport! viewport (GL coords - origin bottom left); static UInt_tfgDollyDeltaSens. private:. TGLBoundingBoxfInterestFrustum! frustum basis of current interest box - NOT a true BB! (DEBUG); TGLBoundingBoxfInterestFrustumAsBox! frustum basis (as box) of current interest box (DEBUG); TGLBoundingBoxfPreviousInterestBox! previous interest box (DEBUG); static const Double_tfgInterestBoxExpansion! expansion c.f. aligned current frus",MatchSource.WIKI,root/html528/TGLCamera.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLCamera.html
https://root.cern/root/html528/TGLCamera.html:6011,Performance,cache,cached,6011,"atrix* modviewMat = 0) const; virtual Bool_tZoom(Int_t delta, Bool_t mod1, Bool_t mod2). protected:. voidUpdateCache() const. private:. TGLBoundingBoxFrustum(Bool_t asBox = kTRUE) const; TGLCamera&operator=(const TGLCamera&). Data Members; public:. enum EFrustumPlane { kNear; kLeft; kRight; kTop; kBottom; kFar; kPlanesPerFrustum; };. protected:. Bool_tfCacheDirty! cached items dirty?; TGLMatrixfCamBase! tranformation to center and rotation from up to x vector; TGLMatrixfCamTrans! transformation relative to fCamTrans; TGLVector3*fCenter! current camera center; TGLMatrixfClipM! object space clip matrix (cached); TGLVector3fDefCenter! deafult camera center; Double_tfDollyDefault! default distnce from viewing centre; Double_tfDollyDistance! unit distance for camera movement in fwd/bck direction; TGLVector3fExtCenter! external camera center; Bool_tfExternalCenter! use external center insead of scene center; TGLVector3fFDCenter! fixed deafult camera center; Double_tfFarClip! last applied far-clip; Bool_tfFixDefCenter! use fixed default center; TGLPlanefFrustumPlanes[6]! frustum planes (cached); TGLBoundingBoxfInterestBox! the interest box - created in UpdateInterest(); Double_tfLargestSeen! largest box diagonal seen in OfInterest() - used when; TGLMatrixfLastNoPickProjM! no-pick projection matrix (cached); TGLMatrixfModVM! modelView matrix (cached); Double_tfNearClip! last applied near-clip; TGLMatrixfProjM! projection matrix (cached); UInt_tfTimeStamp! timestamp; Float_tfVAxisMinAngle! minimal allowed angle between up and fCamTrans Z vector; TGLRectfViewport! viewport (GL coords - origin bottom left); static UInt_tfgDollyDeltaSens. private:. TGLBoundingBoxfInterestFrustum! frustum basis of current interest box - NOT a true BB! (DEBUG); TGLBoundingBoxfInterestFrustumAsBox! frustum basis (as box) of current interest box (DEBUG); TGLBoundingBoxfPreviousInterestBox! previous interest box (DEBUG); static const Double_tfgInterestBoxExpansion! expansion c.f. aligned current frus",MatchSource.WIKI,root/html528/TGLCamera.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLCamera.html
https://root.cern/root/html528/TGLCamera.html:6842,Performance,cache,cached,6842,"trixfLastNoPickProjM! no-pick projection matrix (cached); TGLMatrixfModVM! modelView matrix (cached); Double_tfNearClip! last applied near-clip; TGLMatrixfProjM! projection matrix (cached); UInt_tfTimeStamp! timestamp; Float_tfVAxisMinAngle! minimal allowed angle between up and fCamTrans Z vector; TGLRectfViewport! viewport (GL coords - origin bottom left); static UInt_tfgDollyDeltaSens. private:. TGLBoundingBoxfInterestFrustum! frustum basis of current interest box - NOT a true BB! (DEBUG); TGLBoundingBoxfInterestFrustumAsBox! frustum basis (as box) of current interest box (DEBUG); TGLBoundingBoxfPreviousInterestBox! previous interest box (DEBUG); static const Double_tfgInterestBoxExpansion! expansion c.f. aligned current frustum box. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~TGLCamera(); Base camera destructor. void SetViewport(const TGLRect& viewport); Set viewport extents from passed 'viewport' rect. void UpdateCache() const; Update internally cached frustum values. TGLBoundingBox Frustum(Bool_t asBox = kTRUE) const; Return the the current camera frustum. If asBox == kFALSE return; a true frustum (truncated square based pyramid). If asBox == kTRUE; return a true box, using the far clipping plane intersection projected; back to the near plane. Camera must have valid frustum cache - call Apply() after last modifcation, before using. Note: TGLBoundingBox is not really valid when filled with truncated pyramid; - this is used as a visual debug aid only so ok. TGLVertex3 EyePoint() const; Return the camera eye point (vertex) in world space; Camera must have valid frustum cache - call Apply() after last modifcation, before using. TGLVector3 EyeDirection() const; Extract the camera eye direction (vector), running from EyePoint(); Camera must have valid frustum cache - call Apply() after last modifcation, before using. TGLVertex3 FrustumCenter() const; Find the center of the camera frustum from intersection of planes; This",MatchSource.WIKI,root/html528/TGLCamera.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLCamera.html
https://root.cern/root/html528/TGLCamera.html:7178,Performance,cache,cache,7178,"tatic UInt_tfgDollyDeltaSens. private:. TGLBoundingBoxfInterestFrustum! frustum basis of current interest box - NOT a true BB! (DEBUG); TGLBoundingBoxfInterestFrustumAsBox! frustum basis (as box) of current interest box (DEBUG); TGLBoundingBoxfPreviousInterestBox! previous interest box (DEBUG); static const Double_tfgInterestBoxExpansion! expansion c.f. aligned current frustum box. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~TGLCamera(); Base camera destructor. void SetViewport(const TGLRect& viewport); Set viewport extents from passed 'viewport' rect. void UpdateCache() const; Update internally cached frustum values. TGLBoundingBox Frustum(Bool_t asBox = kTRUE) const; Return the the current camera frustum. If asBox == kFALSE return; a true frustum (truncated square based pyramid). If asBox == kTRUE; return a true box, using the far clipping plane intersection projected; back to the near plane. Camera must have valid frustum cache - call Apply() after last modifcation, before using. Note: TGLBoundingBox is not really valid when filled with truncated pyramid; - this is used as a visual debug aid only so ok. TGLVertex3 EyePoint() const; Return the camera eye point (vertex) in world space; Camera must have valid frustum cache - call Apply() after last modifcation, before using. TGLVector3 EyeDirection() const; Extract the camera eye direction (vector), running from EyePoint(); Camera must have valid frustum cache - call Apply() after last modifcation, before using. TGLVertex3 FrustumCenter() const; Find the center of the camera frustum from intersection of planes; This method will work even with parallel left/right & top/bottom and; infinite eye point of ortho cameras; Camera must have valid frustum cache - call Apply() after last modifcation, before using. EOverlap FrustumOverlap(const TGLBoundingBox& box) const; Calcaulte overlap (kInside, kOutside, kPartial) of box with camera; frustum; Camera must have valid frustum c",MatchSource.WIKI,root/html528/TGLCamera.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLCamera.html
https://root.cern/root/html528/TGLCamera.html:7476,Performance,cache,cache,7476,"estBox! previous interest box (DEBUG); static const Double_tfgInterestBoxExpansion! expansion c.f. aligned current frustum box. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~TGLCamera(); Base camera destructor. void SetViewport(const TGLRect& viewport); Set viewport extents from passed 'viewport' rect. void UpdateCache() const; Update internally cached frustum values. TGLBoundingBox Frustum(Bool_t asBox = kTRUE) const; Return the the current camera frustum. If asBox == kFALSE return; a true frustum (truncated square based pyramid). If asBox == kTRUE; return a true box, using the far clipping plane intersection projected; back to the near plane. Camera must have valid frustum cache - call Apply() after last modifcation, before using. Note: TGLBoundingBox is not really valid when filled with truncated pyramid; - this is used as a visual debug aid only so ok. TGLVertex3 EyePoint() const; Return the camera eye point (vertex) in world space; Camera must have valid frustum cache - call Apply() after last modifcation, before using. TGLVector3 EyeDirection() const; Extract the camera eye direction (vector), running from EyePoint(); Camera must have valid frustum cache - call Apply() after last modifcation, before using. TGLVertex3 FrustumCenter() const; Find the center of the camera frustum from intersection of planes; This method will work even with parallel left/right & top/bottom and; infinite eye point of ortho cameras; Camera must have valid frustum cache - call Apply() after last modifcation, before using. EOverlap FrustumOverlap(const TGLBoundingBox& box) const; Calcaulte overlap (kInside, kOutside, kPartial) of box with camera; frustum; Camera must have valid frustum cache - call Apply() after last modifcation, before using. EOverlap ViewportOverlap(const TGLBoundingBox& box) const; Calculate overlap (kInside, kOutside, kPartial) of box projection onto viewport; (as rect) against the viewport rect.; Camera must have vali",MatchSource.WIKI,root/html528/TGLCamera.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLCamera.html
https://root.cern/root/html528/TGLCamera.html:7667,Performance,cache,cache,7667,"s; Libraries. Function documentation; ~TGLCamera(); Base camera destructor. void SetViewport(const TGLRect& viewport); Set viewport extents from passed 'viewport' rect. void UpdateCache() const; Update internally cached frustum values. TGLBoundingBox Frustum(Bool_t asBox = kTRUE) const; Return the the current camera frustum. If asBox == kFALSE return; a true frustum (truncated square based pyramid). If asBox == kTRUE; return a true box, using the far clipping plane intersection projected; back to the near plane. Camera must have valid frustum cache - call Apply() after last modifcation, before using. Note: TGLBoundingBox is not really valid when filled with truncated pyramid; - this is used as a visual debug aid only so ok. TGLVertex3 EyePoint() const; Return the camera eye point (vertex) in world space; Camera must have valid frustum cache - call Apply() after last modifcation, before using. TGLVector3 EyeDirection() const; Extract the camera eye direction (vector), running from EyePoint(); Camera must have valid frustum cache - call Apply() after last modifcation, before using. TGLVertex3 FrustumCenter() const; Find the center of the camera frustum from intersection of planes; This method will work even with parallel left/right & top/bottom and; infinite eye point of ortho cameras; Camera must have valid frustum cache - call Apply() after last modifcation, before using. EOverlap FrustumOverlap(const TGLBoundingBox& box) const; Calcaulte overlap (kInside, kOutside, kPartial) of box with camera; frustum; Camera must have valid frustum cache - call Apply() after last modifcation, before using. EOverlap ViewportOverlap(const TGLBoundingBox& box) const; Calculate overlap (kInside, kOutside, kPartial) of box projection onto viewport; (as rect) against the viewport rect.; Camera must have valid frustum cache - call Apply() after last modifcation, before using. TGLRect ViewportRect(const TGLBoundingBox& box, TGLBoundingBox::EFace face) const; Calculate viewport rectangle w",MatchSource.WIKI,root/html528/TGLCamera.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLCamera.html
https://root.cern/root/html528/TGLCamera.html:7965,Performance,cache,cache,7965,"ngBox Frustum(Bool_t asBox = kTRUE) const; Return the the current camera frustum. If asBox == kFALSE return; a true frustum (truncated square based pyramid). If asBox == kTRUE; return a true box, using the far clipping plane intersection projected; back to the near plane. Camera must have valid frustum cache - call Apply() after last modifcation, before using. Note: TGLBoundingBox is not really valid when filled with truncated pyramid; - this is used as a visual debug aid only so ok. TGLVertex3 EyePoint() const; Return the camera eye point (vertex) in world space; Camera must have valid frustum cache - call Apply() after last modifcation, before using. TGLVector3 EyeDirection() const; Extract the camera eye direction (vector), running from EyePoint(); Camera must have valid frustum cache - call Apply() after last modifcation, before using. TGLVertex3 FrustumCenter() const; Find the center of the camera frustum from intersection of planes; This method will work even with parallel left/right & top/bottom and; infinite eye point of ortho cameras; Camera must have valid frustum cache - call Apply() after last modifcation, before using. EOverlap FrustumOverlap(const TGLBoundingBox& box) const; Calcaulte overlap (kInside, kOutside, kPartial) of box with camera; frustum; Camera must have valid frustum cache - call Apply() after last modifcation, before using. EOverlap ViewportOverlap(const TGLBoundingBox& box) const; Calculate overlap (kInside, kOutside, kPartial) of box projection onto viewport; (as rect) against the viewport rect.; Camera must have valid frustum cache - call Apply() after last modifcation, before using. TGLRect ViewportRect(const TGLBoundingBox& box, TGLBoundingBox::EFace face) const; Calculate viewport rectangle which just contains projection of single 'face'; of world frame bounding box 'box' onto the viewport. Note use other version; of ViewportRect() if you want whole 'box' contained. TGLRect ViewportRect(const TGLBoundingBox& box, const TGLBoundingB",MatchSource.WIKI,root/html528/TGLCamera.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLCamera.html
https://root.cern/root/html528/TGLCamera.html:8190,Performance,cache,cache,8190,"near plane. Camera must have valid frustum cache - call Apply() after last modifcation, before using. Note: TGLBoundingBox is not really valid when filled with truncated pyramid; - this is used as a visual debug aid only so ok. TGLVertex3 EyePoint() const; Return the camera eye point (vertex) in world space; Camera must have valid frustum cache - call Apply() after last modifcation, before using. TGLVector3 EyeDirection() const; Extract the camera eye direction (vector), running from EyePoint(); Camera must have valid frustum cache - call Apply() after last modifcation, before using. TGLVertex3 FrustumCenter() const; Find the center of the camera frustum from intersection of planes; This method will work even with parallel left/right & top/bottom and; infinite eye point of ortho cameras; Camera must have valid frustum cache - call Apply() after last modifcation, before using. EOverlap FrustumOverlap(const TGLBoundingBox& box) const; Calcaulte overlap (kInside, kOutside, kPartial) of box with camera; frustum; Camera must have valid frustum cache - call Apply() after last modifcation, before using. EOverlap ViewportOverlap(const TGLBoundingBox& box) const; Calculate overlap (kInside, kOutside, kPartial) of box projection onto viewport; (as rect) against the viewport rect.; Camera must have valid frustum cache - call Apply() after last modifcation, before using. TGLRect ViewportRect(const TGLBoundingBox& box, TGLBoundingBox::EFace face) const; Calculate viewport rectangle which just contains projection of single 'face'; of world frame bounding box 'box' onto the viewport. Note use other version; of ViewportRect() if you want whole 'box' contained. TGLRect ViewportRect(const TGLBoundingBox& box, const TGLBoundingBox::EFace* face = 0) const; Calculate viewport rectangle which just contains projection of; world frame bounding box 'box' onto the viewport. If face is; null the rect contains the whole bounding box (8 vertices/6; faces). If face is non-null it indicates a box ",MatchSource.WIKI,root/html528/TGLCamera.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLCamera.html
https://root.cern/root/html528/TGLCamera.html:8458,Performance,cache,cache,8458,"ustum cache - call Apply() after last modifcation, before using. TGLVector3 EyeDirection() const; Extract the camera eye direction (vector), running from EyePoint(); Camera must have valid frustum cache - call Apply() after last modifcation, before using. TGLVertex3 FrustumCenter() const; Find the center of the camera frustum from intersection of planes; This method will work even with parallel left/right & top/bottom and; infinite eye point of ortho cameras; Camera must have valid frustum cache - call Apply() after last modifcation, before using. EOverlap FrustumOverlap(const TGLBoundingBox& box) const; Calcaulte overlap (kInside, kOutside, kPartial) of box with camera; frustum; Camera must have valid frustum cache - call Apply() after last modifcation, before using. EOverlap ViewportOverlap(const TGLBoundingBox& box) const; Calculate overlap (kInside, kOutside, kPartial) of box projection onto viewport; (as rect) against the viewport rect.; Camera must have valid frustum cache - call Apply() after last modifcation, before using. TGLRect ViewportRect(const TGLBoundingBox& box, TGLBoundingBox::EFace face) const; Calculate viewport rectangle which just contains projection of single 'face'; of world frame bounding box 'box' onto the viewport. Note use other version; of ViewportRect() if you want whole 'box' contained. TGLRect ViewportRect(const TGLBoundingBox& box, const TGLBoundingBox::EFace* face = 0) const; Calculate viewport rectangle which just contains projection of; world frame bounding box 'box' onto the viewport. If face is; null the rect contains the whole bounding box (8 vertices/6; faces). If face is non-null it indicates a box face, and the; rect contains the single face (4 vertices). Note use other; version of ViewportRect() if you wish to just pass a static; EFace enum member (e.g. kFaceLowX). Note:; i) Rectangle is NOT clipped by viewport limits - so can result; in rect with corners outside viewport - negative etc; ii) TGLRect provides int (pixel based)",MatchSource.WIKI,root/html528/TGLCamera.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLCamera.html
https://root.cern/root/html528/TGLCamera.html:9540,Performance,cache,cache,9540,"tum cache - call Apply() after last modifcation, before using. TGLRect ViewportRect(const TGLBoundingBox& box, TGLBoundingBox::EFace face) const; Calculate viewport rectangle which just contains projection of single 'face'; of world frame bounding box 'box' onto the viewport. Note use other version; of ViewportRect() if you want whole 'box' contained. TGLRect ViewportRect(const TGLBoundingBox& box, const TGLBoundingBox::EFace* face = 0) const; Calculate viewport rectangle which just contains projection of; world frame bounding box 'box' onto the viewport. If face is; null the rect contains the whole bounding box (8 vertices/6; faces). If face is non-null it indicates a box face, and the; rect contains the single face (4 vertices). Note use other; version of ViewportRect() if you wish to just pass a static; EFace enum member (e.g. kFaceLowX). Note:; i) Rectangle is NOT clipped by viewport limits - so can result; in rect with corners outside viewport - negative etc; ii) TGLRect provides int (pixel based) values - not subpxiel accurate; iii) Camera must have valid frustum cache - call Apply() after last; modifcation, before calling. TGLVertex3 WorldToViewport(const TGLVertex3& worldVertex, TGLMatrix* modviewMat = 0) const; Convert a 3D world vertex to '3D' viewport (screen) one. The X()/Y(); components of the viewport vertex are the horizontal/vertical pixel; positions. The Z() component is the viewport depth value - for a; default depth range this is 0.0 (at near clip plane) to 1.0 (at far; clip plane). See OpenGL gluProject & glDepth documentation. Camera must have valid frustum cache - call Apply() after last modifcation, before using. TGLVector3 WorldDeltaToViewport(const TGLVertex3& worldRef, const TGLVector3& worldDelta) const; Convert a 3D vector worldDelta (shift) about vertex worldRef to a viewport; (screen) '3D' vector. The X()/Y() components of the vector are the horizontal; vertical pixel deltas. The Z() component is the viewport depth delta - for a; defaul",MatchSource.WIKI,root/html528/TGLCamera.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLCamera.html
https://root.cern/root/html528/TGLCamera.html:10059,Performance,cache,cache,10059,"x (8 vertices/6; faces). If face is non-null it indicates a box face, and the; rect contains the single face (4 vertices). Note use other; version of ViewportRect() if you wish to just pass a static; EFace enum member (e.g. kFaceLowX). Note:; i) Rectangle is NOT clipped by viewport limits - so can result; in rect with corners outside viewport - negative etc; ii) TGLRect provides int (pixel based) values - not subpxiel accurate; iii) Camera must have valid frustum cache - call Apply() after last; modifcation, before calling. TGLVertex3 WorldToViewport(const TGLVertex3& worldVertex, TGLMatrix* modviewMat = 0) const; Convert a 3D world vertex to '3D' viewport (screen) one. The X()/Y(); components of the viewport vertex are the horizontal/vertical pixel; positions. The Z() component is the viewport depth value - for a; default depth range this is 0.0 (at near clip plane) to 1.0 (at far; clip plane). See OpenGL gluProject & glDepth documentation. Camera must have valid frustum cache - call Apply() after last modifcation, before using. TGLVector3 WorldDeltaToViewport(const TGLVertex3& worldRef, const TGLVector3& worldDelta) const; Convert a 3D vector worldDelta (shift) about vertex worldRef to a viewport; (screen) '3D' vector. The X()/Y() components of the vector are the horizontal; vertical pixel deltas. The Z() component is the viewport depth delta - for a; default depth range between 0.0 (at near clip plane) to 1.0 (at far clip plane); See OpenGL gluProject & glDepth documentation. Camera must have valid frustum cache - call Apply(). TGLVertex3 ViewportToWorld(const TGLVertex3& viewportVertex, TGLMatrix* modviewMat = 0) const; Convert a '3D' viewport vertex to 3D world one. The X()/Y() components; of viewportVertex are the horizontal/vertical pixel position. TGLLine3 ViewportToWorld(Double_t viewportX, Double_t viewportY) const; Convert a 2D viewport position to 3D world line - the projection of the; viewport point into 3D space. Line runs from near to far camera clip ",MatchSource.WIKI,root/html528/TGLCamera.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLCamera.html
https://root.cern/root/html528/TGLCamera.html:10607,Performance,cache,cache,10607," TGLVertex3 WorldToViewport(const TGLVertex3& worldVertex, TGLMatrix* modviewMat = 0) const; Convert a 3D world vertex to '3D' viewport (screen) one. The X()/Y(); components of the viewport vertex are the horizontal/vertical pixel; positions. The Z() component is the viewport depth value - for a; default depth range this is 0.0 (at near clip plane) to 1.0 (at far; clip plane). See OpenGL gluProject & glDepth documentation. Camera must have valid frustum cache - call Apply() after last modifcation, before using. TGLVector3 WorldDeltaToViewport(const TGLVertex3& worldRef, const TGLVector3& worldDelta) const; Convert a 3D vector worldDelta (shift) about vertex worldRef to a viewport; (screen) '3D' vector. The X()/Y() components of the vector are the horizontal; vertical pixel deltas. The Z() component is the viewport depth delta - for a; default depth range between 0.0 (at near clip plane) to 1.0 (at far clip plane); See OpenGL gluProject & glDepth documentation. Camera must have valid frustum cache - call Apply(). TGLVertex3 ViewportToWorld(const TGLVertex3& viewportVertex, TGLMatrix* modviewMat = 0) const; Convert a '3D' viewport vertex to 3D world one. The X()/Y() components; of viewportVertex are the horizontal/vertical pixel position. TGLLine3 ViewportToWorld(Double_t viewportX, Double_t viewportY) const; Convert a 2D viewport position to 3D world line - the projection of the; viewport point into 3D space. Line runs from near to far camera clip planes; (the minimum and maximum visible depth). See also; TGLVertex3 TGLCamera::ViewportToWorld(const TGLVertex3 & viewportVertex) const; for 3D viewport -> 3D world vertex conversions.; See also OpenGL gluUnProject & glDepth documentation. Camera must have valid frustum cache - call Apply() after last modifcation, before using. TGLLine3 ViewportToWorld(const TPoint& viewport) const; Convert a 2D viewport position to 3D world line - the projection of the; viewport point into 3D space. Line runs from near to far camera clip ",MatchSource.WIKI,root/html528/TGLCamera.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLCamera.html
https://root.cern/root/html528/TGLCamera.html:11345,Performance,cache,cache,11345,"horizontal; vertical pixel deltas. The Z() component is the viewport depth delta - for a; default depth range between 0.0 (at near clip plane) to 1.0 (at far clip plane); See OpenGL gluProject & glDepth documentation. Camera must have valid frustum cache - call Apply(). TGLVertex3 ViewportToWorld(const TGLVertex3& viewportVertex, TGLMatrix* modviewMat = 0) const; Convert a '3D' viewport vertex to 3D world one. The X()/Y() components; of viewportVertex are the horizontal/vertical pixel position. TGLLine3 ViewportToWorld(Double_t viewportX, Double_t viewportY) const; Convert a 2D viewport position to 3D world line - the projection of the; viewport point into 3D space. Line runs from near to far camera clip planes; (the minimum and maximum visible depth). See also; TGLVertex3 TGLCamera::ViewportToWorld(const TGLVertex3 & viewportVertex) const; for 3D viewport -> 3D world vertex conversions.; See also OpenGL gluUnProject & glDepth documentation. Camera must have valid frustum cache - call Apply() after last modifcation, before using. TGLLine3 ViewportToWorld(const TPoint& viewport) const; Convert a 2D viewport position to 3D world line - the projection of the; viewport point into 3D space. Line runs from near to far camera clip planes; (the minimum and maximum visible depth). See also; TGLVertex3 TGLCamera::ViewportToWorld(const TGLVertex3 & viewportVertex) const; for 3D viewport -> 3D world vertex conversions.; See also OpenGL gluUnProject & glDepth documentation. Camera must have valid frustum cache - call Apply() after last modifcation, before using. std::pair<Bool_t, TGLVertex3> ViewportPlaneIntersection(Double_t viewportX, Double_t viewportY, const TGLPlane& worldPlane) const; Find the intersection of projection of supplied viewport point (a 3D world; line - see ViewportToWorld) with supplied world plane. Returns std::pair; of Bool_t and TGLVertex3. If line intersects std::pair.first (Bool_t) is; kTRUE, and std::pair.second (TGLVertex) contains the intersection ver",MatchSource.WIKI,root/html528/TGLCamera.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLCamera.html
https://root.cern/root/html528/TGLCamera.html:11875,Performance,cache,cache,11875,"e_t viewportX, Double_t viewportY) const; Convert a 2D viewport position to 3D world line - the projection of the; viewport point into 3D space. Line runs from near to far camera clip planes; (the minimum and maximum visible depth). See also; TGLVertex3 TGLCamera::ViewportToWorld(const TGLVertex3 & viewportVertex) const; for 3D viewport -> 3D world vertex conversions.; See also OpenGL gluUnProject & glDepth documentation. Camera must have valid frustum cache - call Apply() after last modifcation, before using. TGLLine3 ViewportToWorld(const TPoint& viewport) const; Convert a 2D viewport position to 3D world line - the projection of the; viewport point into 3D space. Line runs from near to far camera clip planes; (the minimum and maximum visible depth). See also; TGLVertex3 TGLCamera::ViewportToWorld(const TGLVertex3 & viewportVertex) const; for 3D viewport -> 3D world vertex conversions.; See also OpenGL gluUnProject & glDepth documentation. Camera must have valid frustum cache - call Apply() after last modifcation, before using. std::pair<Bool_t, TGLVertex3> ViewportPlaneIntersection(Double_t viewportX, Double_t viewportY, const TGLPlane& worldPlane) const; Find the intersection of projection of supplied viewport point (a 3D world; line - see ViewportToWorld) with supplied world plane. Returns std::pair; of Bool_t and TGLVertex3. If line intersects std::pair.first (Bool_t) is; kTRUE, and std::pair.second (TGLVertex) contains the intersection vertex.; If line does not intersect (line and plane parallel) std::pair.first; (Bool_t) if kFALSE, and std::pair.second (TGLVertex) is invalid. NOTE: The projection lines is extended for the plane intersection test; hence the intersection vertex can lie outside the near/far clip regions; (not visible). Camera must have valid frustum cache - call Apply() after last modifcation, before using. std::pair<Bool_t, TGLVertex3> ViewportPlaneIntersection(const TPoint& viewport, const TGLPlane& worldPlane) const; Find the intersection of",MatchSource.WIKI,root/html528/TGLCamera.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLCamera.html
https://root.cern/root/html528/TGLCamera.html:12690,Performance,cache,cache,12690,"t TGLVertex3 & viewportVertex) const; for 3D viewport -> 3D world vertex conversions.; See also OpenGL gluUnProject & glDepth documentation. Camera must have valid frustum cache - call Apply() after last modifcation, before using. std::pair<Bool_t, TGLVertex3> ViewportPlaneIntersection(Double_t viewportX, Double_t viewportY, const TGLPlane& worldPlane) const; Find the intersection of projection of supplied viewport point (a 3D world; line - see ViewportToWorld) with supplied world plane. Returns std::pair; of Bool_t and TGLVertex3. If line intersects std::pair.first (Bool_t) is; kTRUE, and std::pair.second (TGLVertex) contains the intersection vertex.; If line does not intersect (line and plane parallel) std::pair.first; (Bool_t) if kFALSE, and std::pair.second (TGLVertex) is invalid. NOTE: The projection lines is extended for the plane intersection test; hence the intersection vertex can lie outside the near/far clip regions; (not visible). Camera must have valid frustum cache - call Apply() after last modifcation, before using. std::pair<Bool_t, TGLVertex3> ViewportPlaneIntersection(const TPoint& viewport, const TGLPlane& worldPlane) const; Find the intersection of projection of supplied viewport TPoint (a 3D world; line - see ViewportToWorld) with supplied world plane. Returns std::pair; of bool and vertex. If line intersects. Camera must have valid frustum cache - call Apply() after last modifcation, before using. TGLVector3 ViewportDeltaToWorld(const TGLVertex3& worldRef, Double_t viewportXDelta, Double_t viewportYDelta, TGLMatrix* modviewMat = 0) const; Apply a 2D viewport delta (shift) to the projection of worldRef onto viewport,; returning the resultant world vector which equates to it. Useful for making; 3D world objects track mouse moves. Camera must have valid frustum cache - call Apply(). Bool_t OfInterest(const TGLBoundingBox& box, Bool_t ignoreSize) const; Calculate if the an object defined by world frame bounding box; is 'of interest' to the camera. T",MatchSource.WIKI,root/html528/TGLCamera.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLCamera.html
https://root.cern/root/html528/TGLCamera.html:13086,Performance,cache,cache,13086,"n of supplied viewport point (a 3D world; line - see ViewportToWorld) with supplied world plane. Returns std::pair; of Bool_t and TGLVertex3. If line intersects std::pair.first (Bool_t) is; kTRUE, and std::pair.second (TGLVertex) contains the intersection vertex.; If line does not intersect (line and plane parallel) std::pair.first; (Bool_t) if kFALSE, and std::pair.second (TGLVertex) is invalid. NOTE: The projection lines is extended for the plane intersection test; hence the intersection vertex can lie outside the near/far clip regions; (not visible). Camera must have valid frustum cache - call Apply() after last modifcation, before using. std::pair<Bool_t, TGLVertex3> ViewportPlaneIntersection(const TPoint& viewport, const TGLPlane& worldPlane) const; Find the intersection of projection of supplied viewport TPoint (a 3D world; line - see ViewportToWorld) with supplied world plane. Returns std::pair; of bool and vertex. If line intersects. Camera must have valid frustum cache - call Apply() after last modifcation, before using. TGLVector3 ViewportDeltaToWorld(const TGLVertex3& worldRef, Double_t viewportXDelta, Double_t viewportYDelta, TGLMatrix* modviewMat = 0) const; Apply a 2D viewport delta (shift) to the projection of worldRef onto viewport,; returning the resultant world vector which equates to it. Useful for making; 3D world objects track mouse moves. Camera must have valid frustum cache - call Apply(). Bool_t OfInterest(const TGLBoundingBox& box, Bool_t ignoreSize) const; Calculate if the an object defined by world frame bounding box; is 'of interest' to the camera. This is defined as box:. i) intersecting completely or partially (kInside/kPartial) with; cameras interest box (fInterestBox); ii) having significant length OR volume ratio compared to this; interest box. If a box is 'of interest' returns kTRUE, kFALSE otherwise. See; TGLCamera::UpdateInterest() for more details of camera interest; box. Note: Length/volume ratios NOT dependent on the projected ",MatchSource.WIKI,root/html528/TGLCamera.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLCamera.html
https://root.cern/root/html528/TGLCamera.html:13513,Performance,cache,cache,13513,"e projection lines is extended for the plane intersection test; hence the intersection vertex can lie outside the near/far clip regions; (not visible). Camera must have valid frustum cache - call Apply() after last modifcation, before using. std::pair<Bool_t, TGLVertex3> ViewportPlaneIntersection(const TPoint& viewport, const TGLPlane& worldPlane) const; Find the intersection of projection of supplied viewport TPoint (a 3D world; line - see ViewportToWorld) with supplied world plane. Returns std::pair; of bool and vertex. If line intersects. Camera must have valid frustum cache - call Apply() after last modifcation, before using. TGLVector3 ViewportDeltaToWorld(const TGLVertex3& worldRef, Double_t viewportXDelta, Double_t viewportYDelta, TGLMatrix* modviewMat = 0) const; Apply a 2D viewport delta (shift) to the projection of worldRef onto viewport,; returning the resultant world vector which equates to it. Useful for making; 3D world objects track mouse moves. Camera must have valid frustum cache - call Apply(). Bool_t OfInterest(const TGLBoundingBox& box, Bool_t ignoreSize) const; Calculate if the an object defined by world frame bounding box; is 'of interest' to the camera. This is defined as box:. i) intersecting completely or partially (kInside/kPartial) with; cameras interest box (fInterestBox); ii) having significant length OR volume ratio compared to this; interest box. If a box is 'of interest' returns kTRUE, kFALSE otherwise. See; TGLCamera::UpdateInterest() for more details of camera interest; box. Note: Length/volume ratios NOT dependent on the projected size; of box at current camera configuration as we do not want; continual changes. This is used when (re) populating the scene; with objects from external client. TODO: Might be more logical to move this test out to client -; and have accessor for fInterestBox instead?. Bool_t UpdateInterest(Bool_t force); Update the internal interest box (fInterestBox) of the camera.; The interest box is an orientated bou",MatchSource.WIKI,root/html528/TGLCamera.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLCamera.html
https://root.cern/root/html528/TGLCamera.html:14334,Security,access,accessor,14334,"(shift) to the projection of worldRef onto viewport,; returning the resultant world vector which equates to it. Useful for making; 3D world objects track mouse moves. Camera must have valid frustum cache - call Apply(). Bool_t OfInterest(const TGLBoundingBox& box, Bool_t ignoreSize) const; Calculate if the an object defined by world frame bounding box; is 'of interest' to the camera. This is defined as box:. i) intersecting completely or partially (kInside/kPartial) with; cameras interest box (fInterestBox); ii) having significant length OR volume ratio compared to this; interest box. If a box is 'of interest' returns kTRUE, kFALSE otherwise. See; TGLCamera::UpdateInterest() for more details of camera interest; box. Note: Length/volume ratios NOT dependent on the projected size; of box at current camera configuration as we do not want; continual changes. This is used when (re) populating the scene; with objects from external client. TODO: Might be more logical to move this test out to client -; and have accessor for fInterestBox instead?. Bool_t UpdateInterest(Bool_t force); Update the internal interest box (fInterestBox) of the camera.; The interest box is an orientated bounding box, calculated as; an expanded container round the frustum. It is used to test if; if object bounding boxes are of interest (should be accepted; into viewer scene) for a camera - see TGLCamera::OfInterest(). The interest box is updated if the frustum is no longer contained; in the existing one, or a new one calculated on the current frustum; differs significantly in volume (camera has been zoomed/dollyed; sizable amount). If the interest box is updated we return kTRUE - kFALSE otherwise. void ResetInterest(); Clear out the existing interest box. Bool_t AdjustAndClampVal(Double_t& val, Double_t min, Double_t max, Int_t screenShift, Int_t screenShiftRange, Bool_t mod1, Bool_t mod2) const; Adjust a passed REFERENCE value 'val', based on screenShift delta.; Two modifier flags ('mod1' / 'mod2' ",MatchSource.WIKI,root/html528/TGLCamera.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLCamera.html
https://root.cern/root/html528/TGLCamera.html:645,Testability,test,tests,645,". TGLCamera. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLCamera. class TGLCamera. TGLCamera. Abstract base camera class - concrete classes for orthographic and; persepctive cameras derive from it. This class maintains values for; the current:; i) Viewport; ii) Projection, modelview and clip matricies - extracted from GL; iii) The 6 frustum planes; iv) Expanded frustum interest box. It provides methods for various projection, overlap and intersection; tests for viewport and world locations, against the true frustum and; expanded interest box, and for extracting eye position and direction. It also defines the pure virtual manipulation interface methods the; concrete ortho and prespective classes must implement. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TGLCamera(); Bool_tAdjustAndClampVal(Double_t& val, Double_t min, Double_t max, Int_t screenShift, Int_t screenShiftRange, Bool_t mod1, Bool_t mod2) const; Double_tAdjustDelta(Double_t screenShift, Double_t deltaFactor, Bool_t mod1, Bool_t mod2) const; virtual voidApply(const TGLBoundingBox& sceneBox, const TGLRect* pickRect = 0) const; static TClass*Class(); virtual voidConfigure(Double_t zoom, Double_t dolly, Double_t* center, Double_t hRotate, Double_t vRotate); virtual Bool_tDolly(Int_t delta, Bool_t mod1, Bool_t mod2); voidDrawDebugAids() const; TGLVector3EyeDirection() const; TGLVertex3EyePoint() const; TGLVertex3FrustumCenter() const; EOverlapFrustumOverlap(const TGLBoundingBox& box) const; const TGLPlane&FrustumPlane(TGLCamera::EFrustumPlane plane) const; const TGLMatrix&GetCamBase() const; const TGLMatrix&GetCamTrans() const; Double_t*GetCenterVec(); Bool_tGetExternalCenter(); Double_tGetFarCli",MatchSource.WIKI,root/html528/TGLCamera.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLCamera.html
https://root.cern/root/html528/TGLCamera.html:12565,Testability,test,test,12565,"near to far camera clip planes; (the minimum and maximum visible depth). See also; TGLVertex3 TGLCamera::ViewportToWorld(const TGLVertex3 & viewportVertex) const; for 3D viewport -> 3D world vertex conversions.; See also OpenGL gluUnProject & glDepth documentation. Camera must have valid frustum cache - call Apply() after last modifcation, before using. std::pair<Bool_t, TGLVertex3> ViewportPlaneIntersection(Double_t viewportX, Double_t viewportY, const TGLPlane& worldPlane) const; Find the intersection of projection of supplied viewport point (a 3D world; line - see ViewportToWorld) with supplied world plane. Returns std::pair; of Bool_t and TGLVertex3. If line intersects std::pair.first (Bool_t) is; kTRUE, and std::pair.second (TGLVertex) contains the intersection vertex.; If line does not intersect (line and plane parallel) std::pair.first; (Bool_t) if kFALSE, and std::pair.second (TGLVertex) is invalid. NOTE: The projection lines is extended for the plane intersection test; hence the intersection vertex can lie outside the near/far clip regions; (not visible). Camera must have valid frustum cache - call Apply() after last modifcation, before using. std::pair<Bool_t, TGLVertex3> ViewportPlaneIntersection(const TPoint& viewport, const TGLPlane& worldPlane) const; Find the intersection of projection of supplied viewport TPoint (a 3D world; line - see ViewportToWorld) with supplied world plane. Returns std::pair; of bool and vertex. If line intersects. Camera must have valid frustum cache - call Apply() after last modifcation, before using. TGLVector3 ViewportDeltaToWorld(const TGLVertex3& worldRef, Double_t viewportXDelta, Double_t viewportYDelta, TGLMatrix* modviewMat = 0) const; Apply a 2D viewport delta (shift) to the projection of worldRef onto viewport,; returning the resultant world vector which equates to it. Useful for making; 3D world objects track mouse moves. Camera must have valid frustum cache - call Apply(). Bool_t OfInterest(const TGLBoundingBox& box",MatchSource.WIKI,root/html528/TGLCamera.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLCamera.html
https://root.cern/root/html528/TGLCamera.html:14282,Testability,log,logical,14282,"(shift) to the projection of worldRef onto viewport,; returning the resultant world vector which equates to it. Useful for making; 3D world objects track mouse moves. Camera must have valid frustum cache - call Apply(). Bool_t OfInterest(const TGLBoundingBox& box, Bool_t ignoreSize) const; Calculate if the an object defined by world frame bounding box; is 'of interest' to the camera. This is defined as box:. i) intersecting completely or partially (kInside/kPartial) with; cameras interest box (fInterestBox); ii) having significant length OR volume ratio compared to this; interest box. If a box is 'of interest' returns kTRUE, kFALSE otherwise. See; TGLCamera::UpdateInterest() for more details of camera interest; box. Note: Length/volume ratios NOT dependent on the projected size; of box at current camera configuration as we do not want; continual changes. This is used when (re) populating the scene; with objects from external client. TODO: Might be more logical to move this test out to client -; and have accessor for fInterestBox instead?. Bool_t UpdateInterest(Bool_t force); Update the internal interest box (fInterestBox) of the camera.; The interest box is an orientated bounding box, calculated as; an expanded container round the frustum. It is used to test if; if object bounding boxes are of interest (should be accepted; into viewer scene) for a camera - see TGLCamera::OfInterest(). The interest box is updated if the frustum is no longer contained; in the existing one, or a new one calculated on the current frustum; differs significantly in volume (camera has been zoomed/dollyed; sizable amount). If the interest box is updated we return kTRUE - kFALSE otherwise. void ResetInterest(); Clear out the existing interest box. Bool_t AdjustAndClampVal(Double_t& val, Double_t min, Double_t max, Int_t screenShift, Int_t screenShiftRange, Bool_t mod1, Bool_t mod2) const; Adjust a passed REFERENCE value 'val', based on screenShift delta.; Two modifier flags ('mod1' / 'mod2' ",MatchSource.WIKI,root/html528/TGLCamera.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLCamera.html
https://root.cern/root/html528/TGLCamera.html:14303,Testability,test,test,14303,"(shift) to the projection of worldRef onto viewport,; returning the resultant world vector which equates to it. Useful for making; 3D world objects track mouse moves. Camera must have valid frustum cache - call Apply(). Bool_t OfInterest(const TGLBoundingBox& box, Bool_t ignoreSize) const; Calculate if the an object defined by world frame bounding box; is 'of interest' to the camera. This is defined as box:. i) intersecting completely or partially (kInside/kPartial) with; cameras interest box (fInterestBox); ii) having significant length OR volume ratio compared to this; interest box. If a box is 'of interest' returns kTRUE, kFALSE otherwise. See; TGLCamera::UpdateInterest() for more details of camera interest; box. Note: Length/volume ratios NOT dependent on the projected size; of box at current camera configuration as we do not want; continual changes. This is used when (re) populating the scene; with objects from external client. TODO: Might be more logical to move this test out to client -; and have accessor for fInterestBox instead?. Bool_t UpdateInterest(Bool_t force); Update the internal interest box (fInterestBox) of the camera.; The interest box is an orientated bounding box, calculated as; an expanded container round the frustum. It is used to test if; if object bounding boxes are of interest (should be accepted; into viewer scene) for a camera - see TGLCamera::OfInterest(). The interest box is updated if the frustum is no longer contained; in the existing one, or a new one calculated on the current frustum; differs significantly in volume (camera has been zoomed/dollyed; sizable amount). If the interest box is updated we return kTRUE - kFALSE otherwise. void ResetInterest(); Clear out the existing interest box. Bool_t AdjustAndClampVal(Double_t& val, Double_t min, Double_t max, Int_t screenShift, Int_t screenShiftRange, Bool_t mod1, Bool_t mod2) const; Adjust a passed REFERENCE value 'val', based on screenShift delta.; Two modifier flags ('mod1' / 'mod2' ",MatchSource.WIKI,root/html528/TGLCamera.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLCamera.html
https://root.cern/root/html528/TGLCamera.html:14589,Testability,test,test,14589,"d frame bounding box; is 'of interest' to the camera. This is defined as box:. i) intersecting completely or partially (kInside/kPartial) with; cameras interest box (fInterestBox); ii) having significant length OR volume ratio compared to this; interest box. If a box is 'of interest' returns kTRUE, kFALSE otherwise. See; TGLCamera::UpdateInterest() for more details of camera interest; box. Note: Length/volume ratios NOT dependent on the projected size; of box at current camera configuration as we do not want; continual changes. This is used when (re) populating the scene; with objects from external client. TODO: Might be more logical to move this test out to client -; and have accessor for fInterestBox instead?. Bool_t UpdateInterest(Bool_t force); Update the internal interest box (fInterestBox) of the camera.; The interest box is an orientated bounding box, calculated as; an expanded container round the frustum. It is used to test if; if object bounding boxes are of interest (should be accepted; into viewer scene) for a camera - see TGLCamera::OfInterest(). The interest box is updated if the frustum is no longer contained; in the existing one, or a new one calculated on the current frustum; differs significantly in volume (camera has been zoomed/dollyed; sizable amount). If the interest box is updated we return kTRUE - kFALSE otherwise. void ResetInterest(); Clear out the existing interest box. Bool_t AdjustAndClampVal(Double_t& val, Double_t min, Double_t max, Int_t screenShift, Int_t screenShiftRange, Bool_t mod1, Bool_t mod2) const; Adjust a passed REFERENCE value 'val', based on screenShift delta.; Two modifier flags ('mod1' / 'mod2' ) for sensitivity:. mod1 = kFALSE, mod2 = kFALSE : normal sensitivity (screenShift/screenShiftRange); mod1 = kTRUE, mod2 = kFALSE : 0.1x sensitivity; mod1 = kTRUE, mod2 = kTRUE : 0.01x sensitivity; mod1 = kFALSE, mod2 = kTRUE : 10.0x sensitivity. 'val' is modified and clamped to 'min' / 'max' range.; Return bool kTRUE if val actual",MatchSource.WIKI,root/html528/TGLCamera.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLCamera.html
https://root.cern/root/html528/TGLClip.html:669,Availability,avail,available,669,". TGLClip. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLClip. class TGLClip: public TGLPhysicalShape. TGLClip. Abstract clipping shape - derives from TGLPhysicalShape; Adds clip mode (inside/outside) and pure virtual method to; approximate shape as set of planes. This plane set is used to perform; interactive clipping using OpenGL clip planes. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TGLClip(); voidTGLPhysicalShape::AddReference(TGLPShapeRef* ref); const TGLBoundingBox&TGLPhysicalShape::BoundingBox() const; virtual voidTGLPhysicalShape::CalculateShapeLOD(TGLRnrCtx& rnrCtx, Float_t& pixSize, Short_t& shapeLOD) const; static TClass*Class(); const Float_t*TGLPhysicalShape::Color() const; virtual voidDraw(TGLRnrCtx& rnrCtx) const; const TGLLogicalShape*TGLPhysicalShape::GetLogical() const; TGLPhysicalShape::EManipTGLPhysicalShape::GetManip() const; TGLClip::EModeGetMode() const; const TGLPhysicalShape*TGLPhysicalShape::GetNextPhysical() const; TGLVector3TGLPhysicalShape::GetScale() const; UChar_tTGLPhysicalShape::GetSelected() const; TGLVertex3TGLPhysicalShape::GetTranslation() const; UInt_tTGLPhysicalShape::ID() const; voidIncTimeStamp(); voidInvalidate(); voidTGLPhysicalShape::InvokeContextMenu(TContextMenu& menu, UInt_t x, UInt_t y) const; virtual TClass*IsA() const; Bool_tTGLPhysicalShape::IsInvisible() const; Bool_tTGLPhysicalShape::IsModified() const; Bool_tTGLPhysicalShape::IsSelected() const; Bool_tTGLPhysicalShape::IsTransparent() const; Bool_tIsValid() const; virtual voidModified(); virtual voidPlaneSet(TGLPlaneSet_t& set) const; virtual voidTGLPhysicalShape::QuantizeShapeLOD(Short_t shapeLOD, Short_t combiLOD, Short_t& quantLOD) const; voidTG",MatchSource.WIKI,root/html528/TGLClip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLClip.html
https://root.cern/root/html528/TGLClip.html:479,Performance,perform,perform,479,". TGLClip. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLClip. class TGLClip: public TGLPhysicalShape. TGLClip. Abstract clipping shape - derives from TGLPhysicalShape; Adds clip mode (inside/outside) and pure virtual method to; approximate shape as set of planes. This plane set is used to perform; interactive clipping using OpenGL clip planes. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TGLClip(); voidTGLPhysicalShape::AddReference(TGLPShapeRef* ref); const TGLBoundingBox&TGLPhysicalShape::BoundingBox() const; virtual voidTGLPhysicalShape::CalculateShapeLOD(TGLRnrCtx& rnrCtx, Float_t& pixSize, Short_t& shapeLOD) const; static TClass*Class(); const Float_t*TGLPhysicalShape::Color() const; virtual voidDraw(TGLRnrCtx& rnrCtx) const; const TGLLogicalShape*TGLPhysicalShape::GetLogical() const; TGLPhysicalShape::EManipTGLPhysicalShape::GetManip() const; TGLClip::EModeGetMode() const; const TGLPhysicalShape*TGLPhysicalShape::GetNextPhysical() const; TGLVector3TGLPhysicalShape::GetScale() const; UChar_tTGLPhysicalShape::GetSelected() const; TGLVertex3TGLPhysicalShape::GetTranslation() const; UInt_tTGLPhysicalShape::ID() const; voidIncTimeStamp(); voidInvalidate(); voidTGLPhysicalShape::InvokeContextMenu(TContextMenu& menu, UInt_t x, UInt_t y) const; virtual TClass*IsA() const; Bool_tTGLPhysicalShape::IsInvisible() const; Bool_tTGLPhysicalShape::IsModified() const; Bool_tTGLPhysicalShape::IsSelected() const; Bool_tTGLPhysicalShape::IsTransparent() const; Bool_tIsValid() const; virtual voidModified(); virtual voidPlaneSet(TGLPlaneSet_t& set) const; virtual voidTGLPhysicalShape::QuantizeShapeLOD(Short_t shapeLOD, Short_t combiLOD, Short_t& quantLOD) const; voidTG",MatchSource.WIKI,root/html528/TGLClip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLClip.html
https://root.cern/root/html528/TGLClipBox.html:4093,Deployability,update,update,4093,"ctor3& min_point, const TGLVector3& max_point); voidTGLPhysicalShape::SetupGLColors(TGLRnrCtx& rnrCtx, const Float_t* color = 0) const; virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); UInt_tTGLClip::TimeStamp() const; voidTGLPhysicalShape::Translate(const TGLVector3& vect). Data Members; public:. enum TGLClip::EMode { kOutside; kInside; };; enum TGLPhysicalShape::EManip { kTranslateX; kTranslateY; kTranslateZ; kTranslateAll; kScaleX; kScaleY; kScaleZ; kScaleAll; kRotateX; kRotateY; kRotateZ; kRotateAll; kManipAll; };. protected:. TGLClip::EModeTGLClip::fMode; UInt_tTGLClip::fTimeStamp; Bool_tTGLClip::fValid. private:. static const floatfgColor[4]! Fixed color of clip box. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLClipBox(); Construct an (initially) axis aligned clip pbox object, extents; 'halfLengths', centered on 'center' vertex.; Box can be translated, rotated and scaled in all (xyz) local axes. ~TGLClipBox(); Destroy clip box object. void Setup(const TGLBoundingBox& bbox); Setup the clip object for scene encompassed by bbox. void Setup(const TGLVector3& min_point, const TGLVector3& max_point); Setup the clip box with min/max points directly. This only makes sense if you disable auto-update of the; clip-object:; gl_viewer->SetClipAutoUpdate(kFALSE).; After calling this also call gl_viewer->RefreshPadEditor(gl_viewer); and gl_viewer->RequestDraw(). void PlaneSet(TGLPlaneSet_t& set) const; Return set of 6 planes describing faces of the box but invert them; so that they point inside of box. » Author: Richard Maunder 16/09/2005 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/gl:$Id: TGLClip.h 32465 2010-03-04 20:29:52Z matevz $ » Last generated: 2010-09-23 20:06; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html528/TGLClipBox.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLClipBox.html
https://root.cern/root/html528/TGLClipPlane.html:4645,Deployability,update,update,4645,"TGLClip::fMode; UInt_tTGLClip::fTimeStamp; Bool_tTGLClip::fValid. private:. static const floatfgColor[4]! Fixed color of clip plane. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLClipPlane(); Construct a clip plane object, based on supplied 'plane', with; initial manipulation pivot at 'center', with drawn extents (in; local x/y axes) of 'extents'. Plane can have center pivot translated in all directions, and; rotated round center in X/Y axes , the in-plane axes. It cannot; be scaled. Note theorectically a plane is of course infinite - however we; want to draw the object in viewer - so we fake it with a single; GL face (polygon) - extents defines the width/depth of this -; should be several times scene extents - see Setup(). ~TGLClipPlane(); Destroy clip plane object. void Setup(const TGLBoundingBox& bbox); Setup the clip object for scene encompassed by bbox. void Setup(const TGLVector3& point, const TGLVector3& normal); Setup the clipping plane by point and normal.; Length of the normal determines the size of the plane drawn in; GL viewer. The normal points into the direction of visible half-plane. This only makes sense if you disable auto-update of the; clip-object:; gl_viewer->SetClipAutoUpdate(kFALSE).; After calling this also call gl_viewer->RefreshPadEditor(gl_viewer); and gl_viewer->RequestDraw(). void Set(const TGLPlane& plane); Update clip plane object to follow passed 'plane' equation. Center pivot; is shifted to nearest point on new plane. void PlaneSet(TGLPlaneSet_t& set) const; Return set of planes (actually a single one) describing this clip plane. » Author: Richard Maunder 16/09/2005 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/gl:$Id: TGLClip.h 32465 2010-03-04 20:29:52Z matevz $ » Last generated: 2010-09-23 20:06; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html528/TGLClipPlane.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLClipPlane.html
https://root.cern/root/html528/TGLClipSetEditor.html:4469,Availability,error,error,4469,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const;",MatchSource.WIKI,root/html528/TGLClipSetEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLClipSetEditor.html
https://root.cern/root/html528/TGLClipSetEditor.html:4553,Availability,error,error,4553,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType() c",MatchSource.WIKI,root/html528/TGLClipSetEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLClipSetEditor.html
https://root.cern/root/html528/TGLClipSetEditor.html:17253,Availability,mask,mask,17253,,MatchSource.WIKI,root/html528/TGLClipSetEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLClipSetEditor.html
https://root.cern/root/html528/TGLClipSetSubEditor.html:4200,Availability,error,error,4200,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const;",MatchSource.WIKI,root/html528/TGLClipSetSubEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLClipSetSubEditor.html
https://root.cern/root/html528/TGLClipSetSubEditor.html:4284,Availability,error,error,4284,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType() c",MatchSource.WIKI,root/html528/TGLClipSetSubEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLClipSetSubEditor.html
https://root.cern/root/html528/TGLClipSetSubEditor.html:16811,Availability,mask,mask,16811,,MatchSource.WIKI,root/html528/TGLClipSetSubEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLClipSetSubEditor.html
https://root.cern/root/html528/TGLClipSetSubEditor.html:19303,Deployability,update,update,19303,"used for suppression of signals; TGButtonGroup*fTypeButtons; UInt_tTGFrame::fWidthframe width; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLClipSetSubEditor(const TGWindow* p); Constructor. void SetModel(TGLClipSet* m); Set model object. void Changed(); Emit Changed signal. void ClipValueChanged(); One of number entries was changed. void ClipTypeChanged(Int_t ); Clip type radio button changed - update viewer. void UpdateViewerClip(); Change clipping volume. void ResetViewerClip(); Reset transformation of the current clip. TGLClipSetSubEditor(const TGLClipSetSubEditor& ). TGLClipSetSubEditor& operator=(const TGLClipSetSubEditor& ). virtual ~TGLClipSetSubEditor(); {}. » Author: Matevz Tadel, Jun 2007 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/gl:$Id: TGLClipSetEditor.h 32338 2010-02-12 17:11:34Z matevz $ » Last generated: 2010-09-23 20:06; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html528/TGLClipSetSubEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLClipSetSubEditor.html
https://root.cern/root/html528/TGLColor.html:387,Performance,cache,cached,387,". TGLColor. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLColor. class TGLColor. Class encapsulating color information in preferred GL format - an; array of four unsigned bytes.; Color index is also cached for easier interfacing with the; traditional ROOT graphics. Function Members (Methods); public:. TGLColor(); TGLColor(const TGLColor&); TGLColor(Color_t color_index, Char_t transparency = 0); TGLColor(Int_t r, Int_t g, Int_t b, Int_t a = 255); TGLColor(Float_t r, Float_t g, Float_t b, Float_t a = 1); virtual~TGLColor(); UChar_t*Arr(); TStringAsString() const; const UChar_t*CArr() const; static TClass*Class(); UChar_tGetAlpha() const; UChar_tGetBlue() const; Color_tGetColorIndex() const; UChar_tGetGreen() const; UChar_tGetRed() const; Char_tGetTransparency() const; virtual TClass*IsA() const; TGLColor&operator=(const TGLColor& c); voidSetAlpha(Int_t v); voidSetBlue(Int_t v); voidSetColor(Color_t color_index); voidSetColor(Color_t color_index, Char_t transparency); voidSetColor(Int_t r, Int_t g, Int_t b, Int_t a = 255); voidSetColor(Float_t r, Float_t g, Float_t b, Float_t a = 1); voidSetGreen(Int_t v); voidSetRed(Int_t v); voidSetTransparency(Char_t transparency); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Data Members; protected:. Short_tfIndex; UChar_tfRGBA[4]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLColor(); Default constructor. Color is initialized to black. TGLColor(Int_t r, Int_t g, Int_t b, Int_t a = 255); Constructor from Int_t values. TGLColor(Float_t r, Float_t g, Float_t b, Float_t a = 1); Constructor from Float_t values. TGLColor(Color_t color_index, Char_t transparency = 0); Constructor from color-index and transparency. ~TGLColor(); Dectructo",MatchSource.WIKI,root/html528/TGLColor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLColor.html
https://root.cern/root/html528/TGLContextIdentity.html:2461,Energy Efficiency,reduce,reduced,2461,"ient(); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). private:. voidCheckDestroy(). Data Members; protected:. TGLFontManager*fFontManagerFreeType font manager. private:. Int_tfClientCnt; Int_tfCnt; list<TGLContext*>fCtxs; list<pair<unsigned int,int> >fDLTrash; static TGLContextIdentity*fgDefaultIdentity. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLContextIdentity(); Constructor. ~TGLContextIdentity(); Destructor. void AddRef(TGLContext* ctx); Add context ctx to the list of references. void Release(TGLContext* ctx); Remove context ctx from the list of references. void RegisterDLNameRangeToWipe(UInt_t base, Int_t size); Remember dl range for deletion in next MakeCurrent or dtor execution. void DeleteGLResources(); Delete GL resources registered for destruction. TGLContextIdentity* GetCurrent(); Find identitfy of current context. Static. TGLContextIdentity* GetDefaultIdentity(); Get identity of a default Gl context. Static. TGLContext* GetDefaultContextAny(); Get the first GL context with the default identity.; Can return zero, but that's OK, too. Static. TGLFontManager* GetFontManager(); Get the free-type font-manager associated with this context-identity. void CheckDestroy(); Private function called when reference count is reduced. Bool_t IsValid() const; { return fValid; }. TGLContextIdentity(). void AddClientRef(); { ++fClientCnt; }. void ReleaseClient(); { --fClientCnt; CheckDestroy(); }. Int_t GetRefCnt() const; { return fCnt; }. Int_t GetClientRefCnt() const; { return fClientCnt; }. » Author: Timur Pocheptsov, Jun 2007 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/gl:$Id: TGLContext.h 36675 2010-11-15 20:33:58Z matevz $ » Last generated: 2010-11-16 10:59; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html528/TGLContextIdentity.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLContextIdentity.html
https://root.cern/root/html528/TGLCylinder.html:1813,Performance,cache,cached,1813,"ods); public:. TGLCylinder(const TBuffer3DTube& buffer); virtual~TGLCylinder(); voidTGLLogicalShape::AddRef(TGLPhysicalShape* phys) const; virtual Bool_tTGLLogicalShape::AlwaysSecondarySelect() const; const TGLBoundingBox&TGLLogicalShape::BoundingBox() const; static TClass*Class(); voidTGLLogicalShape::DestroyPhysicals(); virtual voidDirectDraw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DLCacheClear(); virtual voidTGLLogicalShape::DLCacheDrop(); virtual voidTGLLogicalShape::DLCachePurge(); virtual UInt_tDLOffset(Short_t lod) const; virtual voidTGLLogicalShape::Draw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DrawHighlight(TGLRnrCtx& rnrCtx, const TGLPhysicalShape* pshp, Int_t lvl = -1) const; TObject*TGLLogicalShape::GetExternal() const; const TGLPhysicalShape*TGLLogicalShape::GetFirstPhysical() const; TGLScene*TGLLogicalShape::GetScene() const; TObject*TGLLogicalShape::ID() const; virtual Bool_tTGLLogicalShape::IgnoreSizeForOfInterest() const; voidTGLLogicalShape::InvokeContextMenu(TContextMenu& menu, UInt_t x, UInt_t y) const; virtual TClass*IsA() const; virtual Bool_tTGLLogicalShape::KeepDuringSmartRefresh() const; virtual voidTGLLogicalShape::ProcessSelection(TGLRnrCtx& rnrCtx, TGLSelectRecord& rec); virtual Short_tQuantizeShapeLOD(Short_t shapeLOD, Short_t combiLOD) const; UInt_tTGLLogicalShape::Ref() const; Bool_tTGLLogicalShape::SetDLCache(Bool_t cached); virtual Bool_tTGLLogicalShape::ShouldDLCache(const TGLRnrCtx& rnrCtx) const; virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); voidTGLLogicalShape::StrongRef(Bool_t strong) const; voidTGLLogicalShape::SubRef(TGLPhysicalShape* phys) const; virtual TGLLogicalShape::ELODAxesSupportedLODAxes() const; virtual Bool_tTGLLogicalShape::SupportsSecondarySelect() const; UInt_tTGLLogicalShape::UnrefFirstPhysical(); virtual voidTGLLogicalShape::UpdateBoundingBox(); voidTGLLogicalShape::UpdateBoundingBoxesOfPhysicals(). protected:. v",MatchSource.WIKI,root/html528/TGLCylinder.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLCylinder.html
https://root.cern/root/html528/TGLCylinder.html:3758,Performance,cache,cached,3758," box.; UInt_tTGLLogicalShape::fDLBase! display-list id base; Bool_tTGLLogicalShape::fDLCache! use display list caching; Int_tTGLLogicalShape::fDLSize! display-list size for different LODs; UShort_tTGLLogicalShape::fDLValid! display-list validity bit-field; TObject*TGLLogicalShape::fExternalObj! Also plays the role of ID.; TGLPhysicalShape*TGLLogicalShape::fFirstPhysical! first replica; Bool_tTGLLogicalShape::fOwnExtObj! External object is a fake; UInt_tTGLLogicalShape::fRef! physical instance ref counting; Bool_tTGLLogicalShape::fRefStrong! Strong ref (delete on 0 ref); not in scene; TGLScene*TGLLogicalShape::fScene! scene where object is stored (can be zero!). private:. Double_tfDz; TGLVector3fHighPlaneNorm; TGLVector3fLowPlaneNorm; Double_tfPhi1; Double_tfPhi2; Double_tfR1; Double_tfR2; Double_tfR3; Double_tfR4; Bool_tfSegMesh. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLCylinder(const TBuffer3DTube& buffer); Copy out relevant parts of buffer - we create and delete mesh; parts on demand in DirectDraw() and they are DL cached. ~TGLCylinder(); destructor. UInt_t DLOffset(Short_t lod) const; Return display-list offset for given LOD.; Calculation based on what is done in virtual QuantizeShapeLOD below. Short_t QuantizeShapeLOD(Short_t shapeLOD, Short_t combiLOD) const; Factor in scene/viewer LOD and quantize. void DirectDraw(TGLRnrCtx& rnrCtx) const; Debug tracing. ELODAxes SupportedLODAxes() const; Cylinders support LOD (tesselation quality) adjustment along; X/Y axes (round the cylinder radius), but not along length (Z). { return ELODAxes(kLODAxesX | kLODAxesY); }. » Author: Timur Pocheptsov 03/08/2004 » Copyright (C) 1995-2006, Rene Brun and Fons Rademakers. *; » Last changed: root/gl:$Id: TGLCylinder.h 26250 2008-11-17 20:56:44Z matevz $ » Last generated: 2010-09-23 20:06; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT",MatchSource.WIKI,root/html528/TGLCylinder.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLCylinder.html
https://root.cern/root/html528/TGLEmbeddedViewer.html:5394,Availability,error,error,5394," char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTGLViewer::EndScene(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGLViewer::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; Bool_tTGLViewerBase::FindClosestOpaqueRecord(TGLSelectRecord& rec, Int_t& recIdx); Bool_tTGLViewerBase::FindClosestOverlayRecord(TGLOvlSelectRecord& rec, Int_t& recIdx); Bool_tTGLViewerBase::FindClosestRecord(TGLSelectRecord& rec, Int_t& recIdx); TGLLogicalShape*TGLViewerBase::FindLogicalInScenes(TObject* id); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TGLAutoRotator*TGLViewer::GetAutoRotator(); TGLCameraOverlay*TGLViewer::GetCameraOverlay() const; Bool_tTGLViewer::GetClipAutoUpdate() const; TGLClipSet*TGLViewer::GetClipSet() const; TGLOverlayElement*TGLViewer::GetCurrentOvlElm() const; static TGLColorSet&TGLViewer::GetDefaultColorSet(); Int_tTGLViewer::GetDev() const; TGLV",MatchSource.WIKI,root/html528/TGLEmbeddedViewer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLEmbeddedViewer.html
https://root.cern/root/html528/TGLEmbeddedViewer.html:5478,Availability,error,error,5478,"; voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTGLViewer::EndScene(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGLViewer::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; Bool_tTGLViewerBase::FindClosestOpaqueRecord(TGLSelectRecord& rec, Int_t& recIdx); Bool_tTGLViewerBase::FindClosestOverlayRecord(TGLOvlSelectRecord& rec, Int_t& recIdx); Bool_tTGLViewerBase::FindClosestRecord(TGLSelectRecord& rec, Int_t& recIdx); TGLLogicalShape*TGLViewerBase::FindLogicalInScenes(TObject* id); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TGLAutoRotator*TGLViewer::GetAutoRotator(); TGLCameraOverlay*TGLViewer::GetCameraOverlay() const; Bool_tTGLViewer::GetClipAutoUpdate() const; TGLClipSet*TGLViewer::GetClipSet() const; TGLOverlayElement*TGLViewer::GetCurrentOvlElm() const; static TGLColorSet&TGLViewer::GetDefaultColorSet(); Int_tTGLViewer::GetDev() const; TGLViewer::EDragActionTGLViewer::GetDragAction() const; Bool_tTGLViewer::GetDrawCameraCe",MatchSource.WIKI,root/html528/TGLEmbeddedViewer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLEmbeddedViewer.html
https://root.cern/root/html528/TGLEmbeddedViewer.html:25178,Availability,error,error,25178,"ed, default color-set; static Bool_tTGLViewer::fgUseDefaultColorSetForNewViewers! name says it all. private:. Int_tfBorder; TGCompositeFrame*fFrame. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLEmbeddedViewer(const TGWindow* parent, TVirtualPad* pad = 0, Int_t border = 2); Constructor.; Argument 'border' specifies how many pixels to pad on each side of the; viewer. This area can be used for highlightning of the active viewer. TGLEmbeddedViewer(const TGWindow* parent, TVirtualPad* pad, TGedEditor* ged, Int_t border = 2); Constructor allowing to also specify an GED editor to use.; Argument 'border' specifies how many pixels to pad on each side of the; viewer. This area can be used for highlightning of the active viewer. ~TGLEmbeddedViewer(); Destroy standalone viewer object. void Init(const TGWindow* parent); Common initialization from all constructors. void CreateFrames(); Internal frames creation. void CreateGLWidget(); Create a GLwidget, it is an error if it is already created.; This is needed for frame-swapping on mac. void DestroyGLWidget(); Destroy the GLwidget, it is an error if it does not exist.; This is needed for frame-swapping on mac. TGLEmbeddedViewer(const TGLEmbeddedViewer& ). TGLEmbeddedViewer& operator=(const TGLEmbeddedViewer& ). const char * GetName() const; { return ""GLViewer""; }. TGCompositeFrame* GetFrame() const; { return fFrame; }. TGLOrthoCamera * GetOrthoXOYCamera(); { return &fOrthoXOYCamera; }. TGLOrthoCamera * GetOrthoXOZCamera(); { return &fOrthoXOZCamera; }. TGLOrthoCamera * GetOrthoZOYCamera(); { return &fOrthoZOYCamera; }. » Author: Bertrand Bellenot 23/01/2008 » Copyright (C) 1995-2008, Rene Brun and Fons Rademakers. *; » Last changed: root/gl:$Id: TGLEmbeddedViewer.h 31330 2009-11-19 17:34:19Z matevz $ » Last generated: 2010-11-16 10:59; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT suppo",MatchSource.WIKI,root/html528/TGLEmbeddedViewer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLEmbeddedViewer.html
https://root.cern/root/html528/TGLEmbeddedViewer.html:25308,Availability,error,error,25308,"efault color-set; static Bool_tTGLViewer::fgUseDefaultColorSetForNewViewers! name says it all. private:. Int_tfBorder; TGCompositeFrame*fFrame. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLEmbeddedViewer(const TGWindow* parent, TVirtualPad* pad = 0, Int_t border = 2); Constructor.; Argument 'border' specifies how many pixels to pad on each side of the; viewer. This area can be used for highlightning of the active viewer. TGLEmbeddedViewer(const TGWindow* parent, TVirtualPad* pad, TGedEditor* ged, Int_t border = 2); Constructor allowing to also specify an GED editor to use.; Argument 'border' specifies how many pixels to pad on each side of the; viewer. This area can be used for highlightning of the active viewer. ~TGLEmbeddedViewer(); Destroy standalone viewer object. void Init(const TGWindow* parent); Common initialization from all constructors. void CreateFrames(); Internal frames creation. void CreateGLWidget(); Create a GLwidget, it is an error if it is already created.; This is needed for frame-swapping on mac. void DestroyGLWidget(); Destroy the GLwidget, it is an error if it does not exist.; This is needed for frame-swapping on mac. TGLEmbeddedViewer(const TGLEmbeddedViewer& ). TGLEmbeddedViewer& operator=(const TGLEmbeddedViewer& ). const char * GetName() const; { return ""GLViewer""; }. TGCompositeFrame* GetFrame() const; { return fFrame; }. TGLOrthoCamera * GetOrthoXOYCamera(); { return &fOrthoXOYCamera; }. TGLOrthoCamera * GetOrthoXOZCamera(); { return &fOrthoXOZCamera; }. TGLOrthoCamera * GetOrthoZOYCamera(); { return &fOrthoZOYCamera; }. » Author: Bertrand Bellenot 23/01/2008 » Copyright (C) 1995-2008, Rene Brun and Fons Rademakers. *; » Last changed: root/gl:$Id: TGLEmbeddedViewer.h 31330 2009-11-19 17:34:19Z matevz $ » Last generated: 2010-11-16 10:59; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html528/TGLEmbeddedViewer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLEmbeddedViewer.html
https://root.cern/root/html528/TGLEmbeddedViewer.html:20837,Deployability,update,update,20837," enum TGLLockable::ELock { kUnlocked; kDrawLock; kSelectLock; kModifyLock; };. protected:. TGLAutoRotator*TGLViewer::fAutoRotator!; Bool_tTGLViewer::fAxesDepthTest! remove guides hidden-lines; Int_tTGLViewer::fAxesType! axes type; TGLCamera*TGLViewerBase::fCameraCamera for rendering.; TGLCameraOverlay*TGLViewer::fCameraOverlay! markup size of viewport in scene units; Bool_tTGLViewerBase::fChangedChange requiring redraw is pending.; TGLClip*TGLViewerBase::fClipViewer clipping-plane.; TGLClipSet*TGLViewer::fClipSet!; TContextMenu*TGLViewer::fContextMenu!; TGLCamera*TGLViewer::fCurrentCamera!; TGLOverlayElement*TGLViewer::fCurrentOvlElm! current overlay element; TGLSelectRecordTGLViewer::fCurrentSelRec! select record in use as selected; TGLColorSetTGLViewer::fDarkColorSet! color-set with dark background; Bool_tTGLViewer::fDebugMode! debug mode (forced rebuild + draw scene/frustum/interest boxes); TGLViewer::EDragActionTGLViewer::fDragAction; Bool_tTGLViewer::fDrawCameraCenter! reference marker on?; TGEventHandler*TGLViewer::fEventHandler! event handler; Float_tTGLViewer::fFader! fade the view (0 - no fade/default, 1 - full fade/no rendering done); TGLContextIdentity*TGLViewer::fGLCtxId!for embedded gl viewer; Int_tTGLViewer::fGLDevice!for embedded gl viewer; TGLWidget*TGLViewer::fGLWidget; TGedEditor*TGLViewer::fGedEditor! GED editor; Bool_tTGLViewer::fIgnoreSizesOnUpdateignore sizes of bounding-boxes on update; Bool_tTGLViewer::fIsPrinting!; Short_tTGLViewerBase::fLODViewer-lod for rendering.; TGLColorSetTGLViewer::fLightColorSet! color-set with light background; TGLLightSet*TGLViewer::fLightSet!; Float_tTGLViewer::fLineScale! width scale for lines; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; TGLLockable::ELockTGLLockable::fLockLock state.; Float_tTGLViewer::fMaxSceneDrawTimeHQ! max time for scene rendering at high LOD (in ms); Float_tTGLViewer::fMaxSceneDrawTimeLQ! max time f",MatchSource.WIKI,root/html528/TGLEmbeddedViewer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLEmbeddedViewer.html
https://root.cern/root/html528/TGLEmbeddedViewer.html:22702,Deployability,update,update,22702,"GLViewer::fMaxSceneDrawTimeLQ! max time for scene rendering at high LOD (in ms); Float_tTGLViewerBase::fOLLineWOptional override of scene outline line-width; TGLOrthoCameraTGLViewer::fOrthoXOYCamera!; TGLOrthoCameraTGLViewer::fOrthoXOZCamera!; TGLOrthoCameraTGLViewer::fOrthoXnOYCamera!; TGLOrthoCameraTGLViewer::fOrthoXnOZCamera!; TGLOrthoCameraTGLViewer::fOrthoZOYCamera!; TGLOrthoCameraTGLViewer::fOrthoZnOYCamera!; TGLBoundingBoxTGLViewerBase::fOverallBoundingBoxAxis-aligned union of scene bboxes.; vector<TGLOverlayElement*>TGLViewerBase::fOverlay; TGLOvlSelectRecordTGLViewer::fOvlSelRec! select record from last overlay select; TGLPShapeObj*TGLViewer::fPShapeWrap; TVirtualPad*TGLViewer::fPad! external pad - remove replace with signal; TGLPerspectiveCameraTGLViewer::fPerspectiveCameraXOY!; TGLPerspectiveCameraTGLViewer::fPerspectiveCameraXOZ!; TGLPerspectiveCameraTGLViewer::fPerspectiveCameraYOZ!; TStringTGLViewer::fPictureFileName! default file-name for SavePicture(); Float_tTGLViewer::fPointScale! size scale for points; TGLViewer::EPushActionTGLViewer::fPushAction; TGLRedrawTimer*TGLViewer::fRedrawTimer! timer for triggering redraws; Bool_tTGLViewer::fReferenceOn! reference marker on?; TGLVertex3TGLViewer::fReferencePos! reference position; Bool_tTGLViewer::fResetCamerasOnNextUpdatereposition camera on next update; Bool_tTGLViewer::fResetCamerasOnUpdatereposition camera on each update; Bool_tTGLViewerBase::fResetSceneInfosOnRenderRequest rebuild of view-specific scene data.; TGLRnrCtx*TGLViewerBase::fRnrCtx; list<TGLSceneInfo*>TGLViewerBase::fScenesRegistered scenes.; TGLSelectRecordTGLViewer::fSecSelRec! select record from last secondary select (should go to context); TGLSelectRecordTGLViewer::fSelRec! select record from last select (should go to context); TGLManipSet*TGLViewer::fSelectedPShapeRef!; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; Bool_tTGLViewer::fSmartRefresh! cache logicals during scene rebuilds, use TAtt3D time-stamp to de",MatchSource.WIKI,root/html528/TGLEmbeddedViewer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLEmbeddedViewer.html
https://root.cern/root/html528/TGLEmbeddedViewer.html:22774,Deployability,update,update,22774,"GLViewer::fMaxSceneDrawTimeLQ! max time for scene rendering at high LOD (in ms); Float_tTGLViewerBase::fOLLineWOptional override of scene outline line-width; TGLOrthoCameraTGLViewer::fOrthoXOYCamera!; TGLOrthoCameraTGLViewer::fOrthoXOZCamera!; TGLOrthoCameraTGLViewer::fOrthoXnOYCamera!; TGLOrthoCameraTGLViewer::fOrthoXnOZCamera!; TGLOrthoCameraTGLViewer::fOrthoZOYCamera!; TGLOrthoCameraTGLViewer::fOrthoZnOYCamera!; TGLBoundingBoxTGLViewerBase::fOverallBoundingBoxAxis-aligned union of scene bboxes.; vector<TGLOverlayElement*>TGLViewerBase::fOverlay; TGLOvlSelectRecordTGLViewer::fOvlSelRec! select record from last overlay select; TGLPShapeObj*TGLViewer::fPShapeWrap; TVirtualPad*TGLViewer::fPad! external pad - remove replace with signal; TGLPerspectiveCameraTGLViewer::fPerspectiveCameraXOY!; TGLPerspectiveCameraTGLViewer::fPerspectiveCameraXOZ!; TGLPerspectiveCameraTGLViewer::fPerspectiveCameraYOZ!; TStringTGLViewer::fPictureFileName! default file-name for SavePicture(); Float_tTGLViewer::fPointScale! size scale for points; TGLViewer::EPushActionTGLViewer::fPushAction; TGLRedrawTimer*TGLViewer::fRedrawTimer! timer for triggering redraws; Bool_tTGLViewer::fReferenceOn! reference marker on?; TGLVertex3TGLViewer::fReferencePos! reference position; Bool_tTGLViewer::fResetCamerasOnNextUpdatereposition camera on next update; Bool_tTGLViewer::fResetCamerasOnUpdatereposition camera on each update; Bool_tTGLViewerBase::fResetSceneInfosOnRenderRequest rebuild of view-specific scene data.; TGLRnrCtx*TGLViewerBase::fRnrCtx; list<TGLSceneInfo*>TGLViewerBase::fScenesRegistered scenes.; TGLSelectRecordTGLViewer::fSecSelRec! select record from last secondary select (should go to context); TGLSelectRecordTGLViewer::fSelRec! select record from last select (should go to context); TGLManipSet*TGLViewer::fSelectedPShapeRef!; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; Bool_tTGLViewer::fSmartRefresh! cache logicals during scene rebuilds, use TAtt3D time-stamp to de",MatchSource.WIKI,root/html528/TGLEmbeddedViewer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLEmbeddedViewer.html
https://root.cern/root/html528/TGLEmbeddedViewer.html:23308,Performance,cache,cache,23308,"r points; TGLViewer::EPushActionTGLViewer::fPushAction; TGLRedrawTimer*TGLViewer::fRedrawTimer! timer for triggering redraws; Bool_tTGLViewer::fReferenceOn! reference marker on?; TGLVertex3TGLViewer::fReferencePos! reference position; Bool_tTGLViewer::fResetCamerasOnNextUpdatereposition camera on next update; Bool_tTGLViewer::fResetCamerasOnUpdatereposition camera on each update; Bool_tTGLViewerBase::fResetSceneInfosOnRenderRequest rebuild of view-specific scene data.; TGLRnrCtx*TGLViewerBase::fRnrCtx; list<TGLSceneInfo*>TGLViewerBase::fScenesRegistered scenes.; TGLSelectRecordTGLViewer::fSecSelRec! select record from last secondary select (should go to context); TGLSelectRecordTGLViewer::fSelRec! select record from last select (should go to context); TGLManipSet*TGLViewer::fSelectedPShapeRef!; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; Bool_tTGLViewer::fSmartRefresh! cache logicals during scene rebuilds, use TAtt3D time-stamp to determine if they are still valid; Bool_tTGLViewer::fSmoothLines! smooth line edge rendering; Bool_tTGLViewer::fSmoothPoints! smooth point edge rendering; Bool_tTGLViewer::fStereo! use stereo rendering; Float_tTGLViewer::fStereoEyeOffsetFac!; Float_tTGLViewer::fStereoFrustumAsymFac!; Float_tTGLViewer::fStereoZeroParallax! position of zero-parallax plane: 0 - near clipping plane, 1 - far clipping plane; Short_tTGLViewerBase::fStyleViewer-style for rendering.; TGLRectTGLViewer::fViewport! viewport - drawn area; vector<TGLSceneInfo*>TGLViewerBase::fVisScenesVisible scenes.; Float_tTGLViewerBase::fWFLineWOptional override of scene wire-frame line-width; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static TGLColorSetTGLViewer::fgDefaultColorSet! a shared, default color-set; static Bool_tTGLViewer::fgUseDefaultColorSetForNewViewers! name says it all. private:. Int_tfBorder; TGCompositeFrame*fFrame. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documen",MatchSource.WIKI,root/html528/TGLEmbeddedViewer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLEmbeddedViewer.html
https://root.cern/root/html528/TGLEmbeddedViewer.html:23314,Testability,log,logicals,23314,"r points; TGLViewer::EPushActionTGLViewer::fPushAction; TGLRedrawTimer*TGLViewer::fRedrawTimer! timer for triggering redraws; Bool_tTGLViewer::fReferenceOn! reference marker on?; TGLVertex3TGLViewer::fReferencePos! reference position; Bool_tTGLViewer::fResetCamerasOnNextUpdatereposition camera on next update; Bool_tTGLViewer::fResetCamerasOnUpdatereposition camera on each update; Bool_tTGLViewerBase::fResetSceneInfosOnRenderRequest rebuild of view-specific scene data.; TGLRnrCtx*TGLViewerBase::fRnrCtx; list<TGLSceneInfo*>TGLViewerBase::fScenesRegistered scenes.; TGLSelectRecordTGLViewer::fSecSelRec! select record from last secondary select (should go to context); TGLSelectRecordTGLViewer::fSelRec! select record from last select (should go to context); TGLManipSet*TGLViewer::fSelectedPShapeRef!; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; Bool_tTGLViewer::fSmartRefresh! cache logicals during scene rebuilds, use TAtt3D time-stamp to determine if they are still valid; Bool_tTGLViewer::fSmoothLines! smooth line edge rendering; Bool_tTGLViewer::fSmoothPoints! smooth point edge rendering; Bool_tTGLViewer::fStereo! use stereo rendering; Float_tTGLViewer::fStereoEyeOffsetFac!; Float_tTGLViewer::fStereoFrustumAsymFac!; Float_tTGLViewer::fStereoZeroParallax! position of zero-parallax plane: 0 - near clipping plane, 1 - far clipping plane; Short_tTGLViewerBase::fStyleViewer-style for rendering.; TGLRectTGLViewer::fViewport! viewport - drawn area; vector<TGLSceneInfo*>TGLViewerBase::fVisScenesVisible scenes.; Float_tTGLViewerBase::fWFLineWOptional override of scene wire-frame line-width; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static TGLColorSetTGLViewer::fgDefaultColorSet! a shared, default color-set; static Bool_tTGLViewer::fgUseDefaultColorSetForNewViewers! name says it all. private:. Int_tfBorder; TGCompositeFrame*fFrame. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documen",MatchSource.WIKI,root/html528/TGLEmbeddedViewer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLEmbeddedViewer.html
https://root.cern/root/html528/TGLEmbeddedViewer.html:19584,Usability,guid,guides,19584,"teFrames(); voidInit(const TGWindow* parent); TGLEmbeddedViewer&operator=(const TGLEmbeddedViewer&). Data Members; public:. enum TGLViewer::ECameraType { kCameraPerspXOZ; kCameraPerspYOZ; kCameraPerspXOY; kCameraOrthoXOY; kCameraOrthoXOZ; kCameraOrthoZOY; kCameraOrthoXnOY; kCameraOrthoXnOZ; kCameraOrthoZnOY; };; enum TGLViewer::ESecSelType { kOnRequest; kOnKeyMod1; };; enum TGLViewer::EPushAction { kPushStd; kPushCamCenter; kPushAnnotate; };; enum TGLViewer::EDragAction { kDragNone; kDragCameraRotate; kDragCameraTruck; kDragCameraDolly; kDragOverlay; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };; enum TGLLockable::ELock { kUnlocked; kDrawLock; kSelectLock; kModifyLock; };. protected:. TGLAutoRotator*TGLViewer::fAutoRotator!; Bool_tTGLViewer::fAxesDepthTest! remove guides hidden-lines; Int_tTGLViewer::fAxesType! axes type; TGLCamera*TGLViewerBase::fCameraCamera for rendering.; TGLCameraOverlay*TGLViewer::fCameraOverlay! markup size of viewport in scene units; Bool_tTGLViewerBase::fChangedChange requiring redraw is pending.; TGLClip*TGLViewerBase::fClipViewer clipping-plane.; TGLClipSet*TGLViewer::fClipSet!; TContextMenu*TGLViewer::fContextMenu!; TGLCamera*TGLViewer::fCurrentCamera!; TGLOverlayElement*TGLViewer::fCurrentOvlElm! current overlay element; TGLSelectRecordTGLViewer::fCurrentSelRec! select record in use as selected; TGLColorSetTGLViewer::fDarkColorSet! color-set with dark background; Bool_tTGLViewer::fDebugMode! debug mode (forced rebuild + draw scene/frustum/interest boxes); TGLViewer::EDragActionTGLViewer::fDragAction; Bool_tTGLViewer::fDrawCameraCenter! reference marker on?; TGEventHandler*TGLViewer::fEventHandler! event handler; Float_tTGLViewer::fFader! fade the view (0 - no fade/default, 1 - full fade/no rendering done); TGLContextIdentity*TGLVi",MatchSource.WIKI,root/html528/TGLEmbeddedViewer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLEmbeddedViewer.html
https://root.cern/root/html528/TGLEventHandler.html:4138,Availability,error,error,4138,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Bool_tGetDoInternalSelection() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; TList*TQObject::GetListOfClassSignals() const; TList*TQObject::GetListOfConnections() const; TList*TQObject::GetListOfSignals() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Int_tGetSecSelType() const; virtual const char*TNamed::GetTitle() const; Int_tGetTooltipPixelTolerance()",MatchSource.WIKI,root/html528/TGLEventHandler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLEventHandler.html
https://root.cern/root/html528/TGLEventHandler.html:4222,Availability,error,error,4222,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Bool_tGetDoInternalSelection() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; TList*TQObject::GetListOfClassSignals() const; TList*TQObject::GetListOfConnections() const; TList*TQObject::GetListOfSignals() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Int_tGetSecSelType() const; virtual const char*TNamed::GetTitle() const; Int_tGetTooltipPixelTolerance() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tHandleButton(Event",MatchSource.WIKI,root/html528/TGLEventHandler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLEventHandler.html
https://root.cern/root/html528/TGLEventHandler.html:13229,Modifiability,config,configure,13229,"void SelectForMouseOver(); Run selection (optionally with on secondary selection) and emit; corresponding MouseOver() signals.; Protected method. void ExecuteEvent(Int_t event, Int_t px, Int_t py); Process event of type 'event' - one of EEventType types,; occuring at window location px, py; This is provided for use when embedding GL viewer into pad. Bool_t HandleEvent(Event_t* event); Handle generic Event_t type 'event' - provided to catch focus changes; and terminate any interaction in viewer. Bool_t HandleFocusChange(Event_t* event); Handle generic Event_t type 'event' - provided to catch focus changes; and terminate any interaction in viewer. Bool_t HandleCrossing(Event_t* event); Handle generic Event_t type 'event' - provided to catch focus changes; and terminate any interaction in viewer. Bool_t HandleButton(Event_t* event); Handle mouse button 'event'. Bool_t HandleDoubleClick(Event_t* event); Handle mouse double click 'event'. Bool_t HandleConfigureNotify(Event_t* event); Handle configure notify 'event' - a window resize/movement. Bool_t HandleExpose(Event_t* event); Handle window expose 'event' - show. Bool_t HandleKey(Event_t* event); Handle keyboard 'event'. Bool_t HandleMotion(Event_t* event); Handle mouse motion 'event'. Bool_t Rotate(Int_t xDelta, Int_t yDelta, Bool_t mod1, Bool_t mod2); Method to handle action TGLViewer::kDragCameraRotate. Bool_t HandleTimer(TTimer* t); If mouse delay timer times out emit signal. void StartMouseTimer(); Start mouse timer in single-shot mode. void StopMouseTimer(); Make sure mouse timers are not running. void ClearMouseOver(); Clear mouse-over state and emit mouse-over signals.; Current overlay element is also told the mouse has left. void Repaint(); Handle window expose 'event' - show. void PopupContextMenu(TGLPhysicalShape* pshp, Event_t* event, Int_t gx, Int_t gy); Popup context menu. void TriggerTooltip(const char* text); Trigger display of tooltip. void RemoveTooltip(); Hide the tooltip. void SetMouseOverSelectDela",MatchSource.WIKI,root/html528/TGLEventHandler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLEventHandler.html
https://root.cern/root/html528/TGLEventHandler.html:13333,Security,expose,expose,13333,"; corresponding MouseOver() signals.; Protected method. void ExecuteEvent(Int_t event, Int_t px, Int_t py); Process event of type 'event' - one of EEventType types,; occuring at window location px, py; This is provided for use when embedding GL viewer into pad. Bool_t HandleEvent(Event_t* event); Handle generic Event_t type 'event' - provided to catch focus changes; and terminate any interaction in viewer. Bool_t HandleFocusChange(Event_t* event); Handle generic Event_t type 'event' - provided to catch focus changes; and terminate any interaction in viewer. Bool_t HandleCrossing(Event_t* event); Handle generic Event_t type 'event' - provided to catch focus changes; and terminate any interaction in viewer. Bool_t HandleButton(Event_t* event); Handle mouse button 'event'. Bool_t HandleDoubleClick(Event_t* event); Handle mouse double click 'event'. Bool_t HandleConfigureNotify(Event_t* event); Handle configure notify 'event' - a window resize/movement. Bool_t HandleExpose(Event_t* event); Handle window expose 'event' - show. Bool_t HandleKey(Event_t* event); Handle keyboard 'event'. Bool_t HandleMotion(Event_t* event); Handle mouse motion 'event'. Bool_t Rotate(Int_t xDelta, Int_t yDelta, Bool_t mod1, Bool_t mod2); Method to handle action TGLViewer::kDragCameraRotate. Bool_t HandleTimer(TTimer* t); If mouse delay timer times out emit signal. void StartMouseTimer(); Start mouse timer in single-shot mode. void StopMouseTimer(); Make sure mouse timers are not running. void ClearMouseOver(); Clear mouse-over state and emit mouse-over signals.; Current overlay element is also told the mouse has left. void Repaint(); Handle window expose 'event' - show. void PopupContextMenu(TGLPhysicalShape* pshp, Event_t* event, Int_t gx, Int_t gy); Popup context menu. void TriggerTooltip(const char* text); Trigger display of tooltip. void RemoveTooltip(); Hide the tooltip. void SetMouseOverSelectDelay(Int_t ms); Set delay of mouse-over probe (highlight). void SetMouseOverTooltipDelay(Int_",MatchSource.WIKI,root/html528/TGLEventHandler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLEventHandler.html
https://root.cern/root/html528/TGLEventHandler.html:13968,Security,expose,expose,13968,"ided to catch focus changes; and terminate any interaction in viewer. Bool_t HandleButton(Event_t* event); Handle mouse button 'event'. Bool_t HandleDoubleClick(Event_t* event); Handle mouse double click 'event'. Bool_t HandleConfigureNotify(Event_t* event); Handle configure notify 'event' - a window resize/movement. Bool_t HandleExpose(Event_t* event); Handle window expose 'event' - show. Bool_t HandleKey(Event_t* event); Handle keyboard 'event'. Bool_t HandleMotion(Event_t* event); Handle mouse motion 'event'. Bool_t Rotate(Int_t xDelta, Int_t yDelta, Bool_t mod1, Bool_t mod2); Method to handle action TGLViewer::kDragCameraRotate. Bool_t HandleTimer(TTimer* t); If mouse delay timer times out emit signal. void StartMouseTimer(); Start mouse timer in single-shot mode. void StopMouseTimer(); Make sure mouse timers are not running. void ClearMouseOver(); Clear mouse-over state and emit mouse-over signals.; Current overlay element is also told the mouse has left. void Repaint(); Handle window expose 'event' - show. void PopupContextMenu(TGLPhysicalShape* pshp, Event_t* event, Int_t gx, Int_t gy); Popup context menu. void TriggerTooltip(const char* text); Trigger display of tooltip. void RemoveTooltip(); Hide the tooltip. void SetMouseOverSelectDelay(Int_t ms); Set delay of mouse-over probe (highlight). void SetMouseOverTooltipDelay(Int_t ms); Set delay of tooltip timer. Int_t ControlValue(Int_t v); { return fViewerCentricControls ? -v : v; }. Int_t GetTooltipPixelTolerance() const; { return fTooltipPixelTolerance; }. void SetTooltipPixelTolerance(Int_t t); { fTooltipPixelTolerance = t; }. Int_t GetSecSelType() const; { return fSecSelType; }. void SetSecSelType(Int_t t); { fSecSelType = t; }. Bool_t GetDoInternalSelection() const; { return fDoInternalSelection; }. void SetDoInternalSelection(Bool_t x); { fDoInternalSelection = x; }. » Author: Bertrand Bellenot 29/01/2008 » Copyright (C) 1995-2008, Rene Brun and Fons Rademakers. *; » Last changed: root/gl:$Id: TGLEventHan",MatchSource.WIKI,root/html528/TGLEventHandler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLEventHandler.html
https://root.cern/root/html528/TGLFaceSet.html:2010,Performance,cache,cached,2010,"ogicalShape::DestroyPhysicals(); virtual voidDirectDraw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DLCacheClear(); virtual voidTGLLogicalShape::DLCacheDrop(); virtual voidTGLLogicalShape::DLCachePurge(); virtual UInt_tTGLLogicalShape::DLOffset(Short_t) const; virtual voidTGLLogicalShape::Draw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DrawHighlight(TGLRnrCtx& rnrCtx, const TGLPhysicalShape* pshp, Int_t lvl = -1) const; voidEnforceTriangles(); static Bool_tGetEnforceTriangles(); TObject*TGLLogicalShape::GetExternal() const; const TGLPhysicalShape*TGLLogicalShape::GetFirstPhysical() const; UInt_tGetNbPols(); vector<Double_t>&GetNormals(); vector<Int_t>&GetPolyDesc(); TGLScene*TGLLogicalShape::GetScene() const; vector<Double_t>&GetVertices(); TObject*TGLLogicalShape::ID() const; virtual Bool_tTGLLogicalShape::IgnoreSizeForOfInterest() const; voidTGLLogicalShape::InvokeContextMenu(TContextMenu& menu, UInt_t x, UInt_t y) const; virtual TClass*IsA() const; virtual Bool_tTGLLogicalShape::KeepDuringSmartRefresh() const; virtual voidTGLLogicalShape::ProcessSelection(TGLRnrCtx& rnrCtx, TGLSelectRecord& rec); virtual Short_tTGLLogicalShape::QuantizeShapeLOD(Short_t shapeLOD, Short_t combiLOD) const; UInt_tTGLLogicalShape::Ref() const; Bool_tTGLLogicalShape::SetDLCache(Bool_t cached); static voidSetEnforceTriangles(Bool_t e); voidSetFromMesh(const RootCsg::TBaseMesh* m); virtual Bool_tTGLLogicalShape::ShouldDLCache(const TGLRnrCtx& rnrCtx) const; virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); voidTGLLogicalShape::StrongRef(Bool_t strong) const; voidTGLLogicalShape::SubRef(TGLPhysicalShape* phys) const; virtual TGLLogicalShape::ELODAxesTGLLogicalShape::SupportedLODAxes() const; virtual Bool_tTGLLogicalShape::SupportsSecondarySelect() const; UInt_tTGLLogicalShape::UnrefFirstPhysical(); virtual voidTGLLogicalShape::UpdateBoundingBox(); voidTGLLogicalShape::UpdateBoundingBoxesOfPhysicals().",MatchSource.WIKI,root/html528/TGLFaceSet.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLFaceSet.html
https://root.cern/root/html528/TGLFaceSet.html:4641,Testability,test,test,4641,"ref counting; Bool_tTGLLogicalShape::fRefStrong! Strong ref (delete on 0 ref); not in scene; TGLScene*TGLLogicalShape::fScene! scene where object is stored (can be zero!). private:. UInt_tfNbPols; vector<Double_t>fNormals; vector<Int_t>fPolyDesc; vector<Double_t>fVertices; static Bool_tfgEnforceTriangles. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLFaceSet(const TBuffer3D& buffer); constructor. void SetFromMesh(const RootCsg::TBaseMesh* m); Should only be done on an empty faceset object. void EnforceTriangles(); Use GLU tesselator to replace all polygons with N > 3 with triangles.; After this call polygon descriptions are changed.; New vertices are not expected -- exception is thrown if this is; requested by the triangulator. Support for adding of new vertices can be; provided. void DirectDraw(TGLRnrCtx& rnrCtx) const; Debug tracing. Int_t CheckPoints(const Int_t* source, Int_t* dest) const; CheckPoints. Bool_t Eq(const Double_t* p1, const Double_t* p2); test equality. void CalculateNormals(); CalculateNormals. Bool_t GetEnforceTriangles(); Get current state of static flag EnforceTriangles. void SetEnforceTriangles(Bool_t e); Set state of static flag EnforceTriangles.; When this is set, all tesselations will be automatically converted into; triangle-only meshes.; This is needed to export TGeo shapes and CSG meshes to external; triangle-mesh libraries that can not handle arbitrary polygons. std::vector<Double_t>& GetVertices(); { return fVertices; }. std::vector<Double_t>& GetNormals(); { return fNormals; }. std::vector<Int_t>& GetPolyDesc(); { return fPolyDesc; }. UInt_t GetNbPols(); { return fNbPols; }. void GLDrawPolys() const. » Author: Timur Pocheptsov 03/08/2004 » Copyright (C) 1995-2006, Rene Brun and Fons Rademakers. *; » Last changed: root/gl:$Id: TGLFaceSet.h 37192 2010-12-02 15:54:26Z matevz $ » Last generated: 2010-12-02 22:33; This page has been automatically generated. For comments or suggestions regardi",MatchSource.WIKI,root/html528/TGLFaceSet.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLFaceSet.html
https://root.cern/root/html528/TGLFBO.html:1681,Energy Efficiency,allocate,allocated,1681,"ublic:. TGLFBO(); virtual~TGLFBO(); voidBind(); voidBindTexture(); static TClass*Class(); voidInit(int w, int h, int ms_samples = 0); virtual TClass*IsA() const; voidRelease(); voidSetAsReadBuffer(); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); voidUnbind(); voidUnbindTexture(). protected:. UInt_tCreateAndAttachColorTexture(); UInt_tCreateAndAttachRenderBuffer(Int_t format, Int_t type); voidInitMultiSample(); voidInitStandard(). private:. TGLFBO(const TGLFBO&); TGLFBO&operator=(const TGLFBO&). Data Members; protected:. UInt_tfColorTexture; UInt_tfDepthBuffer; UInt_tfFrameBuffer; Int_tfH; Float_tfHScale; Bool_tfIsRescaled; UInt_tfMSColorBuffer; Int_tfMSCoverageSamples; UInt_tfMSFrameBuffer; Int_tfMSSamples; Int_tfW; Float_tfWScale; static Bool_tfgMultiSampleNAWarned; static Bool_tfgRescaleToPow2. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLFBO(); Constructor. ~TGLFBO(); Destructor. void Init(int w, int h, int ms_samples = 0); Acquire GL resources for given width, height and number of; multi-sampling samples. void Release(); Release the allocated GL resources. void Bind(); Bind the frame-buffer object. void Unbind(); Unbind the frame-buffer object. void BindTexture(); Bind texture. void UnbindTexture(); Unbind texture. void SetAsReadBuffer(). void InitStandard(). void InitMultiSample(). UInt_t CreateAndAttachRenderBuffer(Int_t format, Int_t type). UInt_t CreateAndAttachColorTexture(); Initialize color-texture and attach it to current FB. TGLFBO(const TGLFBO& ). TGLFBO& operator=(const TGLFBO& ). » Author: Matevz Tadel, Aug 2009 » Copyright (C) 1995-2007, Rene Brun and Fons Rademakers. *; » Last changed: root/gl:$Id: TGLFBO.h 36675 2010-11-15 20:33:58Z matevz $ » Last generated: 2010-11-16 10:59; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html528/TGLFBO.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLFBO.html
https://root.cern/root/html528/TGLFont.html:277,Integrability,wrap,wrapper,277,". TGLFont. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLFont. class TGLFont. TGLFont. A wrapper class for FTFont.; Holds pointer to FTFont object and its description: face size, font file; and class ID. It wraps Render and BBox functions. Function Members (Methods); public:. TGLFont(); TGLFont(const TGLFont& o); TGLFont(Int_t size, Int_t font, TGLFont::EMode mode, FTFont* f = 0, TGLFontManager* mng = 0); virtual~TGLFont(); voidBBox(const char* txt, Float_t& llx, Float_t& lly, Float_t& llz, Float_t& urx, Float_t& ury, Float_t& urz) const; static TClass*Class(); voidCopyAttributes(const TGLFont& o); Float_tGetAscent() const; Float_tGetDepth() const; Float_tGetDescent() const; Int_tGetFile() const; const FTFont*GetFont() const; Float_tGetLineHeight() const; const TGLFontManager*GetManager() const; TGLFont::EModeGetMode() const; Int_tGetSize() const; Int_tGetTrashCount() const; Int_tIncTrashCount() const; virtual TClass*IsA() const; voidMeasureBaseLineParams(Float_t& ascent, Float_t& descent, Float_t& line_height, const char* txt = ""Xj"") const; Bool_toperator<(const TGLFont& o) const; virtual voidPostRender() const; virtual voidPreRender(Bool_t autoLight = kTRUE, Bool_t lightOn = kFALSE) const; voidRender(const TString& txt) const; voidRender(const char* txt, Double_t x, Double_t y, Double_t angle, Double_t mgn) const; voidRender(const TString& txt, Float_t x, Float_t y, Float_t z, TGLFont::ETextAlignH_e alignH, TGLFont::ETextAlignV_e alignV) const; voidSetDepth(Float_t d); voidSetFont(FTFont* f); voidSetManager(TGLFontManager* mng); voidSetTrashCount(Int_t c) const; virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). private:. TGLFont&operator=(const TGLFont& o). Data Members; public:. enum EMode { kUndef; kBitmap; kPixm",MatchSource.WIKI,root/html528/TGLFont.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLFont.html
https://root.cern/root/html528/TGLFont.html:395,Integrability,wrap,wraps,395,". TGLFont. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLFont. class TGLFont. TGLFont. A wrapper class for FTFont.; Holds pointer to FTFont object and its description: face size, font file; and class ID. It wraps Render and BBox functions. Function Members (Methods); public:. TGLFont(); TGLFont(const TGLFont& o); TGLFont(Int_t size, Int_t font, TGLFont::EMode mode, FTFont* f = 0, TGLFontManager* mng = 0); virtual~TGLFont(); voidBBox(const char* txt, Float_t& llx, Float_t& lly, Float_t& llz, Float_t& urx, Float_t& ury, Float_t& urz) const; static TClass*Class(); voidCopyAttributes(const TGLFont& o); Float_tGetAscent() const; Float_tGetDepth() const; Float_tGetDescent() const; Int_tGetFile() const; const FTFont*GetFont() const; Float_tGetLineHeight() const; const TGLFontManager*GetManager() const; TGLFont::EModeGetMode() const; Int_tGetSize() const; Int_tGetTrashCount() const; Int_tIncTrashCount() const; virtual TClass*IsA() const; voidMeasureBaseLineParams(Float_t& ascent, Float_t& descent, Float_t& line_height, const char* txt = ""Xj"") const; Bool_toperator<(const TGLFont& o) const; virtual voidPostRender() const; virtual voidPreRender(Bool_t autoLight = kTRUE, Bool_t lightOn = kFALSE) const; voidRender(const TString& txt) const; voidRender(const char* txt, Double_t x, Double_t y, Double_t angle, Double_t mgn) const; voidRender(const TString& txt, Float_t x, Float_t y, Float_t z, TGLFont::ETextAlignH_e alignH, TGLFont::ETextAlignV_e alignV) const; voidSetDepth(Float_t d); voidSetFont(FTFont* f); voidSetManager(TGLFontManager* mng); voidSetTrashCount(Int_t c) const; virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). private:. TGLFont&operator=(const TGLFont& o). Data Members; public:. enum EMode { kUndef; kBitmap; kPixm",MatchSource.WIKI,root/html528/TGLFont.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLFont.html
https://root.cern/root/html528/TGLFont.html:3491,Usability,simpl,simply,3491,"Function documentation; TGLFont(); Constructor. TGLFont(Int_t size, Int_t font, TGLFont::EMode mode, FTFont* f = 0, TGLFontManager* mng = 0); Constructor. TGLFont(const TGLFont& o); Assignment operator. ~TGLFont(); Destructor. void CopyAttributes(const TGLFont& o); Assignment operator. Float_t GetAscent() const; Get font's ascent. Float_t GetDescent() const; Get font's descent. The returned value is positive. Float_t GetLineHeight() const; Get font's line-height. void MeasureBaseLineParams(Float_t& ascent, Float_t& descent, Float_t& line_height, const char* txt = ""Xj"") const; Measure font's base-line parameters from the passed text.; Note that the measured parameters are not the same as the ones; returned by get-functions - those were set by the font designer. void BBox(const char* txt, Float_t& llx, Float_t& lly, Float_t& llz, Float_t& urx, Float_t& ury, Float_t& urz) const; Get bounding box. void Render(const char* txt, Double_t x, Double_t y, Double_t angle, Double_t mgn) const; mgn is simply ignored, because ROOT's TVirtualX TGX11 are complete mess with; painting attributes. void Render(const TString& txt) const; Render text. void PreRender(Bool_t autoLight = kTRUE, Bool_t lightOn = kFALSE) const; Set-up GL state before FTFont rendering. void PostRender() const; Reset GL state after FTFont rendering. TGLFont& operator=(const TGLFont& o). Int_t GetSize() const; { return fSize;}. Int_t GetFile() const; { return fFile;}. EMode GetMode() const; { return fMode;}. Int_t GetTrashCount() const; { return fTrashCount; }. void SetTrashCount(Int_t c) const; { fTrashCount = c; }. Int_t IncTrashCount() const; { return ++fTrashCount; }. void SetFont(FTFont* f); { fFont =f;}. const FTFont* GetFont() const; { return fFont; }. void SetManager(TGLFontManager* mng); { fManager = mng; }. const TGLFontManager* GetManager() const; { return fManager; }. Float_t GetDepth() const; { return fDepth; }. void SetDepth(Float_t d); { fDepth = d; }. void Render(const char* txt, Double_t x, Doubl",MatchSource.WIKI,root/html528/TGLFont.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLFont.html
https://root.cern/root/html528/TGLFontManager.html:2199,Availability,avail,availabe,2199,"al voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). protected:. static voidInitStatics(). private:. TGLFontManager(const TGLFontManager&); TGLFontManager&operator=(const TGLFontManager&). Data Members; protected:. map<TGLFont,int>fFontMapmap of created fonts; list<const TGLFont*>fFontTrashfonts to purge; static TObjArrayfgFontFileArraymap font-id to ttf-font-file; static vector<int>fgFontSizeArraymap of valid font-size; static Bool_tfgStaticInitDoneglobal initialization flag. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~TGLFontManager(); Destructor. void RegisterFont(Int_t size, Int_t file, TGLFont::EMode mode, TGLFont& out); Provide font with given size, file and FTGL class. void RegisterFont(Int_t size, const char* name, TGLFont::EMode mode, TGLFont& out); Get mapping from ttf id to font names. Table taken from TTF.cxx. void ReleaseFont(TGLFont& font); Release font with given attributes. Returns false if font has; not been found in the managers font set. TObjArray* GetFontFileArray(); Get id to file name map. Int_t GetFontSize(Int_t ds); Get availabe font size. Int_t GetFontSize(Int_t ds, Int_t min, Int_t max); Get availabe font size. const char* GetFontNameFromId(Int_t ); Get font name from TAttAxis font id. void InitStatics(); Create a list of available font files and allowed font sizes. void ClearFontTrash(); Delete FTFFont objects registered for destruction. TGLFont& operator=(const TGLFontManager& ). TGLFontManager(const TGLFontManager& ). TGLFontManager(); {}. FontSizeVec_t* GetFontSizeArray(). » Author: Alja Mrak-Tadel 2008 » Copyright (C) 1995-2007, Rene Brun and Fons Rademakers. *; » Last changed: root/gl:$Id: TGLFontManager.h 30425 2009-09-24 19:45:11Z matevz $ » Last generated: 2010-09-23 20:06; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html528/TGLFontManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLFontManager.html
https://root.cern/root/html528/TGLFontManager.html:2274,Availability,avail,availabe,2274,"al voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). protected:. static voidInitStatics(). private:. TGLFontManager(const TGLFontManager&); TGLFontManager&operator=(const TGLFontManager&). Data Members; protected:. map<TGLFont,int>fFontMapmap of created fonts; list<const TGLFont*>fFontTrashfonts to purge; static TObjArrayfgFontFileArraymap font-id to ttf-font-file; static vector<int>fgFontSizeArraymap of valid font-size; static Bool_tfgStaticInitDoneglobal initialization flag. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~TGLFontManager(); Destructor. void RegisterFont(Int_t size, Int_t file, TGLFont::EMode mode, TGLFont& out); Provide font with given size, file and FTGL class. void RegisterFont(Int_t size, const char* name, TGLFont::EMode mode, TGLFont& out); Get mapping from ttf id to font names. Table taken from TTF.cxx. void ReleaseFont(TGLFont& font); Release font with given attributes. Returns false if font has; not been found in the managers font set. TObjArray* GetFontFileArray(); Get id to file name map. Int_t GetFontSize(Int_t ds); Get availabe font size. Int_t GetFontSize(Int_t ds, Int_t min, Int_t max); Get availabe font size. const char* GetFontNameFromId(Int_t ); Get font name from TAttAxis font id. void InitStatics(); Create a list of available font files and allowed font sizes. void ClearFontTrash(); Delete FTFFont objects registered for destruction. TGLFont& operator=(const TGLFontManager& ). TGLFontManager(const TGLFontManager& ). TGLFontManager(); {}. FontSizeVec_t* GetFontSizeArray(). » Author: Alja Mrak-Tadel 2008 » Copyright (C) 1995-2007, Rene Brun and Fons Rademakers. *; » Last changed: root/gl:$Id: TGLFontManager.h 30425 2009-09-24 19:45:11Z matevz $ » Last generated: 2010-09-23 20:06; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html528/TGLFontManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLFontManager.html
https://root.cern/root/html528/TGLFontManager.html:2407,Availability,avail,available,2407,"al voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). protected:. static voidInitStatics(). private:. TGLFontManager(const TGLFontManager&); TGLFontManager&operator=(const TGLFontManager&). Data Members; protected:. map<TGLFont,int>fFontMapmap of created fonts; list<const TGLFont*>fFontTrashfonts to purge; static TObjArrayfgFontFileArraymap font-id to ttf-font-file; static vector<int>fgFontSizeArraymap of valid font-size; static Bool_tfgStaticInitDoneglobal initialization flag. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~TGLFontManager(); Destructor. void RegisterFont(Int_t size, Int_t file, TGLFont::EMode mode, TGLFont& out); Provide font with given size, file and FTGL class. void RegisterFont(Int_t size, const char* name, TGLFont::EMode mode, TGLFont& out); Get mapping from ttf id to font names. Table taken from TTF.cxx. void ReleaseFont(TGLFont& font); Release font with given attributes. Returns false if font has; not been found in the managers font set. TObjArray* GetFontFileArray(); Get id to file name map. Int_t GetFontSize(Int_t ds); Get availabe font size. Int_t GetFontSize(Int_t ds, Int_t min, Int_t max); Get availabe font size. const char* GetFontNameFromId(Int_t ); Get font name from TAttAxis font id. void InitStatics(); Create a list of available font files and allowed font sizes. void ClearFontTrash(); Delete FTFFont objects registered for destruction. TGLFont& operator=(const TGLFontManager& ). TGLFontManager(const TGLFontManager& ). TGLFontManager(); {}. FontSizeVec_t* GetFontSizeArray(). » Author: Alja Mrak-Tadel 2008 » Copyright (C) 1995-2007, Rene Brun and Fons Rademakers. *; » Last changed: root/gl:$Id: TGLFontManager.h 30425 2009-09-24 19:45:11Z matevz $ » Last generated: 2010-09-23 20:06; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html528/TGLFontManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLFontManager.html
https://root.cern/root/html528/TGLFormat.html:1831,Integrability,depend,depends,1831,"sStereo() const; Bool_toperator!=(const TGLFormat& rhs) const; TGLFormat&operator=(const TGLFormat&); Bool_toperator==(const TGLFormat& rhs) const; voidSetAccumSize(Int_t accum); voidSetDepthSize(Int_t depth); voidSetDoubleBuffered(Bool_t db); voidSetSamples(Int_t samples); voidSetStencilSize(Int_t stencil); voidSetStereo(Bool_t db); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). private:. static Int_tGetDefaultSamples(); static voidInitAvailableSamples(). Data Members; public:. enum EFormatOptions { kNone; kDoubleBuffer; kDepth; kAccum; kStencil; kStereo; kMultiSample; };. private:. Int_tfAccumSize; Int_tfDepthSize; Bool_tfDoubleBuffered; Int_tfSamples; Int_tfStencilSize; Bool_tfStereo; static vector<Int_t>fgAvailableSamples. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLFormat(); Default ctor. Default surface is:; -double buffered; -RGBA; -with depth buffer; -no accumulation buffer; -with stencil; -multi-sampling depends on seeting of ""OpenGL.Framebuffer.Multisample"". TGLFormat(EFormatOptions opt); Define surface using options. ~TGLFormat(); Destructor. Int_t GetDepthSize() const; Get the size of depth buffer. void SetDepthSize(Int_t depth); Set the size of color buffer. Bool_t HasDepth() const; Check, if this surface has depth buffer. Int_t GetStencilSize() const; Get the size of stencil buffer. void SetStencilSize(Int_t stencil); Set the size of stencil buffer. Bool_t HasStencil() const; Check, if this surface has stencil buffer. Int_t GetAccumSize() const; Get the size of accum buffer. void SetAccumSize(Int_t accum); Set the size of accum buffer. Bool_t HasAccumBuffer() const; Check, if this surface has accumulation buffer. Bool_t IsDoubleBuffered() const; Check, if the surface is double buffered. void SetDoubleBuffered(Bool_t db); Set the surface as double/single buffered. Bool_t IsStereo() const; Check, if the surface is stereo buffered. void S",MatchSource.WIKI,root/html528/TGLFormat.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLFormat.html
https://root.cern/root/html528/TGLH2PolyPainter.html:3982,Deployability,update,updates,3982,"tTGLPlotPainter::fBoxCut; TGLPlotCamera*TGLPlotPainter::fCamera; TGLPlotCoordinates*TGLPlotPainter::fCoord; Bool_tTGLPlotPainter::fDrawPalette; Bool_tTGLPlotPainter::fHighColor; TH1*TGLPlotPainter::fHist; TPointTGLPlotPainter::fMousePosition; Double_tTGLPlotPainter::fPadPhi; Double_tTGLPlotPainter::fPadTheta; Int_tTGLPlotPainter::fSelectedPart; TGLSelectionBufferTGLPlotPainter::fSelection; TGLPlotPainter::ESelectionBaseTGLPlotPainter::fSelectionBase; Bool_tTGLPlotPainter::fSelectionPass; Bool_tTGLPlotPainter::fUpdateSelection; TAxis*TGLPlotPainter::fXAxis; Double_tTGLPlotPainter::fXOYSectionPos; Double_tTGLPlotPainter::fXOZSectionPos; TAxis*TGLPlotPainter::fYAxis; Double_tTGLPlotPainter::fYOZSectionPos; TAxis*TGLPlotPainter::fZAxis; vector<Double_t>TGLPlotPainter::fZLevels. private:. vector<Int_t>fBinColors; TStringfBinInfoUsed by GetPlotInfo.; list<Rgl::Pad::Tesselation_t>fCapsCaps for all bins.; vector<Double_t>fPolygonTemporary array for polygon's vertices.; Bool_tfZLogChange in logZ updates only bin heights.; Double_tfZMin. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLH2PolyPainter(TH1* hist, TGLPlotCamera* camera, TGLPlotCoordinates* coord); Ctor. char * GetPlotInfo(Int_t px, Int_t py); Show number of bin and bin contents, if bin is under the cursor. Bool_t InitGeometry(); Tesselate polygons, if not done yet.; All pointers are validated here (and in functions called from here).; If any pointer is invalid - zero, or has unexpected type (dynamic_cast fails) -; InitGeometry will return false and nothing will be painted later.; That's why there are no checks in other functions. void StartPan(Int_t px, Int_t py); User clicks on a lego with middle mouse button (middle for pad). void Pan(Int_t px, Int_t py); Mouse events handler. void AddOption(const TString& stringOption); No additional options. void ProcessEvent(Int_t event, Int_t px, Int_t py); No events. void InitGL() const; Initialize some gl state variables. void D",MatchSource.WIKI,root/html528/TGLH2PolyPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLH2PolyPainter.html
https://root.cern/root/html528/TGLH2PolyPainter.html:4964,Modifiability,variab,variables,4964,"vertices.; Bool_tfZLogChange in logZ updates only bin heights.; Double_tfZMin. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLH2PolyPainter(TH1* hist, TGLPlotCamera* camera, TGLPlotCoordinates* coord); Ctor. char * GetPlotInfo(Int_t px, Int_t py); Show number of bin and bin contents, if bin is under the cursor. Bool_t InitGeometry(); Tesselate polygons, if not done yet.; All pointers are validated here (and in functions called from here).; If any pointer is invalid - zero, or has unexpected type (dynamic_cast fails) -; InitGeometry will return false and nothing will be painted later.; That's why there are no checks in other functions. void StartPan(Int_t px, Int_t py); User clicks on a lego with middle mouse button (middle for pad). void Pan(Int_t px, Int_t py); Mouse events handler. void AddOption(const TString& stringOption); No additional options. void ProcessEvent(Int_t event, Int_t px, Int_t py); No events. void InitGL() const; Initialize some gl state variables. void DeInitGL() const; Return some gl states to original values. void DrawPlot() const; Draw extruded polygons and plot's frame. void DrawExtrusion() const; Extruded part of bins.; GL_QUADS, GL_QUAD_STRIP - have the same time on my laptop, so I use; GL_QUADS and forgot about vertex arrays (can require more memory BTW). void DrawExtrusion(const TGraph* polygon, Double_t zMin, Double_t zMax, Int_t nBin) const; Extrude polygon, described by TGraph. void DrawExtrusion(const TMultiGraph* polygon, Double_t zMin, Double_t zMax, Int_t nBin) const; Multigraph contains a list of graphs, draw them. void DrawCaps() const; Caps on bins. void DrawCap(TGLH2PolyPainter::CIter_t cap, Int_t bin) const; Draw a cap on top of a bin. Bool_t CacheGeometry(); Cache all data for TH2Poly object. Bool_t BuildTesselation(Rgl::Pad::Tesselator& tess, const TGraph* g, Double_t z); Tesselate a polygon described by TGraph. Bool_t BuildTesselation(Rgl::Pad::Tesselator& tess, const TMultiGra",MatchSource.WIKI,root/html528/TGLH2PolyPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLH2PolyPainter.html
https://root.cern/root/html528/TGLH2PolyPainter.html:4383,Security,validat,validated,4383,"BaseTGLPlotPainter::fSelectionBase; Bool_tTGLPlotPainter::fSelectionPass; Bool_tTGLPlotPainter::fUpdateSelection; TAxis*TGLPlotPainter::fXAxis; Double_tTGLPlotPainter::fXOYSectionPos; Double_tTGLPlotPainter::fXOZSectionPos; TAxis*TGLPlotPainter::fYAxis; Double_tTGLPlotPainter::fYOZSectionPos; TAxis*TGLPlotPainter::fZAxis; vector<Double_t>TGLPlotPainter::fZLevels. private:. vector<Int_t>fBinColors; TStringfBinInfoUsed by GetPlotInfo.; list<Rgl::Pad::Tesselation_t>fCapsCaps for all bins.; vector<Double_t>fPolygonTemporary array for polygon's vertices.; Bool_tfZLogChange in logZ updates only bin heights.; Double_tfZMin. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLH2PolyPainter(TH1* hist, TGLPlotCamera* camera, TGLPlotCoordinates* coord); Ctor. char * GetPlotInfo(Int_t px, Int_t py); Show number of bin and bin contents, if bin is under the cursor. Bool_t InitGeometry(); Tesselate polygons, if not done yet.; All pointers are validated here (and in functions called from here).; If any pointer is invalid - zero, or has unexpected type (dynamic_cast fails) -; InitGeometry will return false and nothing will be painted later.; That's why there are no checks in other functions. void StartPan(Int_t px, Int_t py); User clicks on a lego with middle mouse button (middle for pad). void Pan(Int_t px, Int_t py); Mouse events handler. void AddOption(const TString& stringOption); No additional options. void ProcessEvent(Int_t event, Int_t px, Int_t py); No events. void InitGL() const; Initialize some gl state variables. void DeInitGL() const; Return some gl states to original values. void DrawPlot() const; Draw extruded polygons and plot's frame. void DrawExtrusion() const; Extruded part of bins.; GL_QUADS, GL_QUAD_STRIP - have the same time on my laptop, so I use; GL_QUADS and forgot about vertex arrays (can require more memory BTW). void DrawExtrusion(const TGraph* polygon, Double_t zMin, Double_t zMax, Int_t nBin) const; Extrude poly",MatchSource.WIKI,root/html528/TGLH2PolyPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLH2PolyPainter.html
https://root.cern/root/html528/TGLH2PolyPainter.html:3977,Testability,log,logZ,3977,"tTGLPlotPainter::fBoxCut; TGLPlotCamera*TGLPlotPainter::fCamera; TGLPlotCoordinates*TGLPlotPainter::fCoord; Bool_tTGLPlotPainter::fDrawPalette; Bool_tTGLPlotPainter::fHighColor; TH1*TGLPlotPainter::fHist; TPointTGLPlotPainter::fMousePosition; Double_tTGLPlotPainter::fPadPhi; Double_tTGLPlotPainter::fPadTheta; Int_tTGLPlotPainter::fSelectedPart; TGLSelectionBufferTGLPlotPainter::fSelection; TGLPlotPainter::ESelectionBaseTGLPlotPainter::fSelectionBase; Bool_tTGLPlotPainter::fSelectionPass; Bool_tTGLPlotPainter::fUpdateSelection; TAxis*TGLPlotPainter::fXAxis; Double_tTGLPlotPainter::fXOYSectionPos; Double_tTGLPlotPainter::fXOZSectionPos; TAxis*TGLPlotPainter::fYAxis; Double_tTGLPlotPainter::fYOZSectionPos; TAxis*TGLPlotPainter::fZAxis; vector<Double_t>TGLPlotPainter::fZLevels. private:. vector<Int_t>fBinColors; TStringfBinInfoUsed by GetPlotInfo.; list<Rgl::Pad::Tesselation_t>fCapsCaps for all bins.; vector<Double_t>fPolygonTemporary array for polygon's vertices.; Bool_tfZLogChange in logZ updates only bin heights.; Double_tfZMin. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLH2PolyPainter(TH1* hist, TGLPlotCamera* camera, TGLPlotCoordinates* coord); Ctor. char * GetPlotInfo(Int_t px, Int_t py); Show number of bin and bin contents, if bin is under the cursor. Bool_t InitGeometry(); Tesselate polygons, if not done yet.; All pointers are validated here (and in functions called from here).; If any pointer is invalid - zero, or has unexpected type (dynamic_cast fails) -; InitGeometry will return false and nothing will be painted later.; That's why there are no checks in other functions. void StartPan(Int_t px, Int_t py); User clicks on a lego with middle mouse button (middle for pad). void Pan(Int_t px, Int_t py); Mouse events handler. void AddOption(const TString& stringOption); No additional options. void ProcessEvent(Int_t event, Int_t px, Int_t py); No events. void InitGL() const; Initialize some gl state variables. void D",MatchSource.WIKI,root/html528/TGLH2PolyPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLH2PolyPainter.html
https://root.cern/root/html528/TGLHistPainter.html:6497,Availability,error,error,6497,"* data); TGLHistPainter(TGLTH3Composition* comp); ~TGLHistPainter(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidDrawPanel(); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TList*GetContourList(Double_t contour) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TGLPlotPainter*GetRealPainter(); virtual TList*GetStack() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; static TVirtualHistPainter*TVirtua",MatchSource.WIKI,root/html528/TGLHistPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLHistPainter.html
https://root.cern/root/html528/TGLHistPainter.html:6581,Availability,error,error,6581,"stractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidDrawPanel(); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TList*GetContourList(Double_t contour) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TGLPlotPainter*GetRealPainter(); virtual TList*GetStack() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; static TVirtualHistPainter*TVirtualHistPainter::HistPainter(TH1* obj); virtual voidTObject::Info(const char* method, c",MatchSource.WIKI,root/html528/TGLHistPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLHistPainter.html
https://root.cern/root/html528/TGLHistPainter.html:2978,Energy Efficiency,green,green,2978," the same as ""glbox"", but spheres are drawn instead of boxes.; ; TH3 as iso-surface(s) - (TGLIsoPainter); The supported option is:; ; ""GLISO"" : TH3 is drawn using iso-surfaces.; ; TF3 (implicit function) - (TGLTF3Painter); The supported option is:; ; ""GLTF3"" : Draw a TF3.; ; Parametric surfaces - (TGLParametricPlot); $ROOTSYS/tutorials/gl/glparametric.C shows how to create parametric equations and; visualize the surface. Interaction with the plots. General information. All the interactions are implemented via standard methods DistancetoPrimitive and; ExecuteEvent. That's why all the interactions with the OpenGL plots are possible i; only when the mouse cursor is in the plot's area (the plot's area is the part of a the pad; occupied by gl-produced picture). If the mouse cursor is not above gl-picture,; the standard pad interaction is performed.; Selectable parts. Different parts of the plot can be selected:; ; xoz, yoz, xoy back planes:; When such a plane selected, it's highlighted in green if the dynamic slicing; by this plane is supported, and it's highlighted in red, if the dynamic slicing; is not supported.; The plot itself:; On surfaces, the selected surface is outlined in red. (TF3 and ISO are not; outlined). On lego plots, the selected bin is highlihted. The bin number and content are displayed in pad's status; bar. In box plots, the box or sphere is highlighted and the bin info is displayed in pad's status bar.; ; Rotation and zooming. Rotation:; ; When the plot is selected, it can be rotated by pressing and holding the left mouse button and move the cursor.; Zoom/Unzoom:; ; Mouse wheel or 'j', 'J', 'k', 'K' keys.; ; Panning. The selected plot can be moved in a pad's area by; pressing and holding the left mouse button and the shift key. Box cut; Surface, iso, box, TF3 and parametric painters support box cut by pressing the 'c' or; 'C' key when the mouse cursor is in a plot's area. That will display a transparent box,; cutting away part of the surface (or boxes",MatchSource.WIKI,root/html528/TGLHistPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLHistPainter.html
https://root.cern/root/html528/TGLHistPainter.html:4382,Energy Efficiency,green,green,4382,"ar.; ; Rotation and zooming. Rotation:; ; When the plot is selected, it can be rotated by pressing and holding the left mouse button and move the cursor.; Zoom/Unzoom:; ; Mouse wheel or 'j', 'J', 'k', 'K' keys.; ; Panning. The selected plot can be moved in a pad's area by; pressing and holding the left mouse button and the shift key. Box cut; Surface, iso, box, TF3 and parametric painters support box cut by pressing the 'c' or; 'C' key when the mouse cursor is in a plot's area. That will display a transparent box,; cutting away part of the surface (or boxes) in order to show internal part of plot.; This box can be moved inside the plot's area (the full size of the box is equal to the plot's; surrounding box) by selecting one of the box cut axes and pressing the left mouse button to move it.; Plot specific interactions (dynamic slicing etc.); Currently, all gl-plots support some form of slicing.; When back plane is selected (and if it's highlighted in green); you can press and hold left mouse button and shift key; and move this back plane inside plot's area, creating the slice.; During this ""slicing"" plot becomes semi-transparent. To remove all slices (and projected curves for surfaces); - double click with left mouse button in a plot's area.; ; Surface with option ""GLSURF"". The surface profile is displayed on the slicing plane.; The profile projection is drawn on the back plane; by pressing 'p' or 'P' key.; TF3. The contour plot is drawn on the slicing plane.; For TF3 the color scheme can be changed by pressing 's' or 'S'.; Box. The contour plot corresponding to slice plane position is drawn in real time.; Iso. Slicing is similar to ""GLBOX"" option.; Parametric plot. No slicing. Additional keys: 's' or 'S' to change color scheme - about 20 color schemes supported; ('s' for ""scheme""); 'l' or 'L' to increase number of polygons ('l' for ""level"" of details),; 'w' or 'W' to show outlines ('w' for ""wireframe"").; ; . Function Members (Methods); public:. TGLHistPainter(TH1* ",MatchSource.WIKI,root/html528/TGLHistPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLHistPainter.html
https://root.cern/root/html528/TGLHistPainter.html:8919,Integrability,message,message,8919,"IsFolder() const; virtual Bool_tIsInside(Int_t x, Int_t y); virtual Bool_tIsInside(Double_t x, Double_t y); Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; virtual Int_tMakeCuts(char* cutsOpt); voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidPaint(Option_t* option); virtual voidPaintStat(Int_t dostat, TF1* fit); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual voidProcessMessage(const char* message, const TObject* obj); virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(basic_ostream<char,char_traits<char> >& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidSetHistogram(TH1* hist); static voidTObject::SetObjectStat(Bool_t stat); static voidTVirtualHistPainter::SetPainter(const char* painter); virtual voidSetShowProjection(const char* option, Int_t nbins); virtual voidSetStack(TList* stack); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, cons",MatchSource.WIKI,root/html528/TGLHistPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLHistPainter.html
https://root.cern/root/html528/TGLHistPainter.html:13535,Integrability,message,message,13535,"onst; Get contour list.; I do not use this function. Contours are implemented in; a completely different way by gl-painters. char * GetObjectInfo(Int_t px, Int_t py) const; Overrides TObject::GetObjectInfo.; For lego info is: bin numbers (i, j), bin content.; For TF2 info is: x,y,z 3d surface-point for 2d screen-point under cursor; (this can work incorrectly now, because of wrong code in TF2).; For TF3 no info now.; For box info is: bin numbers (i, j, k), bin content. TList * GetStack() const; Get stack. Bool_t IsInside(Int_t x, Int_t y); Returns kTRUE if the cell ix, iy is inside one of the graphical cuts.; I do not use this function anywhere, this is a ""default implementation"". Bool_t IsInside(Double_t x, Double_t y); Returns kTRUE if the cell x, y is inside one of the graphical cuts.; I do not use this function anywhere, this is a ""default implementation"". void PaintStat(Int_t dostat, TF1* fit); Paint statistics.; This does not work on windows. void ProcessMessage(const char* message, const TObject* obj); Process message. void SetHistogram(TH1* hist); Set histogram. void SetStack(TList* stack); Set stack. Int_t MakeCuts(char* cutsOpt); Make cuts. void Paint(Option_t* option); Final-overrider for TObject::Paint. ParsePaintOption(const TString& option) const; In principle, we can have several conflicting options: ""lego surf pol sph"",; but only one will be selected, which one - depends on parsing order in this function. void CreatePainter(const TGLHistPainter::PlotOption_t& parsed, const TString& option); Create painter. void SetShowProjection(const char* option, Int_t nbins); Set show projection. void PadToViewport(Bool_t selectionPass = kFALSE). TGLHistPainter(TH1* hist). TGLPlotPainter * GetRealPainter(); {return fGLPainter.get();}. » Author: Timur Pocheptsov 17/11/2005 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/gl:$Id$ » Last generated: 2010-11-12 15:50; This page has been automatically generated. For comments or suggestions",MatchSource.WIKI,root/html528/TGLHistPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLHistPainter.html
https://root.cern/root/html528/TGLHistPainter.html:13573,Integrability,message,message,13573,"onst; Get contour list.; I do not use this function. Contours are implemented in; a completely different way by gl-painters. char * GetObjectInfo(Int_t px, Int_t py) const; Overrides TObject::GetObjectInfo.; For lego info is: bin numbers (i, j), bin content.; For TF2 info is: x,y,z 3d surface-point for 2d screen-point under cursor; (this can work incorrectly now, because of wrong code in TF2).; For TF3 no info now.; For box info is: bin numbers (i, j, k), bin content. TList * GetStack() const; Get stack. Bool_t IsInside(Int_t x, Int_t y); Returns kTRUE if the cell ix, iy is inside one of the graphical cuts.; I do not use this function anywhere, this is a ""default implementation"". Bool_t IsInside(Double_t x, Double_t y); Returns kTRUE if the cell x, y is inside one of the graphical cuts.; I do not use this function anywhere, this is a ""default implementation"". void PaintStat(Int_t dostat, TF1* fit); Paint statistics.; This does not work on windows. void ProcessMessage(const char* message, const TObject* obj); Process message. void SetHistogram(TH1* hist); Set histogram. void SetStack(TList* stack); Set stack. Int_t MakeCuts(char* cutsOpt); Make cuts. void Paint(Option_t* option); Final-overrider for TObject::Paint. ParsePaintOption(const TString& option) const; In principle, we can have several conflicting options: ""lego surf pol sph"",; but only one will be selected, which one - depends on parsing order in this function. void CreatePainter(const TGLHistPainter::PlotOption_t& parsed, const TString& option); Create painter. void SetShowProjection(const char* option, Int_t nbins); Set show projection. void PadToViewport(Bool_t selectionPass = kFALSE). TGLHistPainter(TH1* hist). TGLPlotPainter * GetRealPainter(); {return fGLPainter.get();}. » Author: Timur Pocheptsov 17/11/2005 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/gl:$Id$ » Last generated: 2010-11-12 15:50; This page has been automatically generated. For comments or suggestions",MatchSource.WIKI,root/html528/TGLHistPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLHistPainter.html
https://root.cern/root/html528/TGLHistPainter.html:13942,Integrability,depend,depends,13942,"ompletely different way by gl-painters. char * GetObjectInfo(Int_t px, Int_t py) const; Overrides TObject::GetObjectInfo.; For lego info is: bin numbers (i, j), bin content.; For TF2 info is: x,y,z 3d surface-point for 2d screen-point under cursor; (this can work incorrectly now, because of wrong code in TF2).; For TF3 no info now.; For box info is: bin numbers (i, j, k), bin content. TList * GetStack() const; Get stack. Bool_t IsInside(Int_t x, Int_t y); Returns kTRUE if the cell ix, iy is inside one of the graphical cuts.; I do not use this function anywhere, this is a ""default implementation"". Bool_t IsInside(Double_t x, Double_t y); Returns kTRUE if the cell x, y is inside one of the graphical cuts.; I do not use this function anywhere, this is a ""default implementation"". void PaintStat(Int_t dostat, TF1* fit); Paint statistics.; This does not work on windows. void ProcessMessage(const char* message, const TObject* obj); Process message. void SetHistogram(TH1* hist); Set histogram. void SetStack(TList* stack); Set stack. Int_t MakeCuts(char* cutsOpt); Make cuts. void Paint(Option_t* option); Final-overrider for TObject::Paint. ParsePaintOption(const TString& option) const; In principle, we can have several conflicting options: ""lego surf pol sph"",; but only one will be selected, which one - depends on parsing order in this function. void CreatePainter(const TGLHistPainter::PlotOption_t& parsed, const TString& option); Create painter. void SetShowProjection(const char* option, Int_t nbins); Set show projection. void PadToViewport(Bool_t selectionPass = kFALSE). TGLHistPainter(TH1* hist). TGLPlotPainter * GetRealPainter(); {return fGLPainter.get();}. » Author: Timur Pocheptsov 17/11/2005 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/gl:$Id$ » Last generated: 2010-11-12 15:50; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html528/TGLHistPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLHistPainter.html
https://root.cern/root/html528/TGLHistPainter.html:2824,Performance,perform,performed,2824,"herical coordinates system.; ; TH3 as boxes (spheres) - (TGLBoxPainter); The supported options are:; ; ""GLBOX"" : TH3 as a set of boxes, size of box is proportional to bin content.; ""GLBOX1"": the same as ""glbox"", but spheres are drawn instead of boxes.; ; TH3 as iso-surface(s) - (TGLIsoPainter); The supported option is:; ; ""GLISO"" : TH3 is drawn using iso-surfaces.; ; TF3 (implicit function) - (TGLTF3Painter); The supported option is:; ; ""GLTF3"" : Draw a TF3.; ; Parametric surfaces - (TGLParametricPlot); $ROOTSYS/tutorials/gl/glparametric.C shows how to create parametric equations and; visualize the surface. Interaction with the plots. General information. All the interactions are implemented via standard methods DistancetoPrimitive and; ExecuteEvent. That's why all the interactions with the OpenGL plots are possible i; only when the mouse cursor is in the plot's area (the plot's area is the part of a the pad; occupied by gl-produced picture). If the mouse cursor is not above gl-picture,; the standard pad interaction is performed.; Selectable parts. Different parts of the plot can be selected:; ; xoz, yoz, xoy back planes:; When such a plane selected, it's highlighted in green if the dynamic slicing; by this plane is supported, and it's highlighted in red, if the dynamic slicing; is not supported.; The plot itself:; On surfaces, the selected surface is outlined in red. (TF3 and ISO are not; outlined). On lego plots, the selected bin is highlihted. The bin number and content are displayed in pad's status; bar. In box plots, the box or sphere is highlighted and the bin info is displayed in pad's status bar.; ; Rotation and zooming. Rotation:; ; When the plot is selected, it can be rotated by pressing and holding the left mouse button and move the cursor.; Zoom/Unzoom:; ; Mouse wheel or 'j', 'J', 'k', 'K' keys.; ; Panning. The selected plot can be moved in a pad's area by; pressing and holding the left mouse button and the shift key. Box cut; Surface, iso, box, TF3 and p",MatchSource.WIKI,root/html528/TGLHistPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLHistPainter.html
https://root.cern/root/html528/TGLHistPainter.html:857,Testability,log,logarithmic,857,". TGLHistPainter. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLHistPainter. class TGLHistPainter: public TVirtualHistPainter. The histogram painter class using OpenGL; Histograms are, by default, drawn via the THistPainter class.; TGLHistPainter allows to paint them using the OpenGL 3D graphics; library. The plotting options provided by TGLHistPainter start with; GL keyword.; General information: plot types and supported options; The following types of plots are provided:. Lego - (TGLLegoPainter); The supported options are:; ; ""GLLEGO"" : Draw a lego plot.; ""GLLEGO2"" : Bins with color levels.; ""GLLEGO3"" : Cylindrical bars.; ; Lego painter in cartesian supports logarithmic scales for X, Y, Z.; In polar only Z axis can be logarithmic, in cylindrical only Y (if you see; what it means).; Surfaces (TF2 and TH2 with ""GLSURF"" options) - (TGLSurfacePainter); The supported options are:; ; ""GLSURF"" : Draw a surface.; ""GLSURF1"" : Surface with color levels; ""GLSURF2"" : The same as ""GLSURF1"" but without polygon outlines.; ""GLSURF3"" : Color level projection on top of plot (works only in cartesian coordinate system).; ""GLSURF4"" : Same as ""GLSURF"" but without polygon outlines.; ; The surface painting in cartesian coordinates supports logarithmic scales along X, Y, Z axis.; In polar coordinates only the Z axis can be logarithmic, in cylindrical coordinates only the Y axis.; Additional options to SURF and LEGO - Coordinate systems:; The supported options are:; ; "" "" : Default, cartesian coordinates system.; ""POL"" : Polar coordinates system.; ""CYL"" : Cylindrical coordinates system.; ""SPH"" : Spherical coordinates system.; ; TH3 as boxes (spheres) - (TGLBoxPainter); The supported options are:; ; ""GLBOX"" : TH3 as a set of boxes, size of box is proportional to bin content.; ""GLBOX1"": the same as ""glbox"", ",MatchSource.WIKI,root/html528/TGLHistPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLHistPainter.html
https://root.cern/root/html528/TGLHistPainter.html:918,Testability,log,logarithmic,918,". TGLHistPainter. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLHistPainter. class TGLHistPainter: public TVirtualHistPainter. The histogram painter class using OpenGL; Histograms are, by default, drawn via the THistPainter class.; TGLHistPainter allows to paint them using the OpenGL 3D graphics; library. The plotting options provided by TGLHistPainter start with; GL keyword.; General information: plot types and supported options; The following types of plots are provided:. Lego - (TGLLegoPainter); The supported options are:; ; ""GLLEGO"" : Draw a lego plot.; ""GLLEGO2"" : Bins with color levels.; ""GLLEGO3"" : Cylindrical bars.; ; Lego painter in cartesian supports logarithmic scales for X, Y, Z.; In polar only Z axis can be logarithmic, in cylindrical only Y (if you see; what it means).; Surfaces (TF2 and TH2 with ""GLSURF"" options) - (TGLSurfacePainter); The supported options are:; ; ""GLSURF"" : Draw a surface.; ""GLSURF1"" : Surface with color levels; ""GLSURF2"" : The same as ""GLSURF1"" but without polygon outlines.; ""GLSURF3"" : Color level projection on top of plot (works only in cartesian coordinate system).; ""GLSURF4"" : Same as ""GLSURF"" but without polygon outlines.; ; The surface painting in cartesian coordinates supports logarithmic scales along X, Y, Z axis.; In polar coordinates only the Z axis can be logarithmic, in cylindrical coordinates only the Y axis.; Additional options to SURF and LEGO - Coordinate systems:; The supported options are:; ; "" "" : Default, cartesian coordinates system.; ""POL"" : Polar coordinates system.; ""CYL"" : Cylindrical coordinates system.; ""SPH"" : Spherical coordinates system.; ; TH3 as boxes (spheres) - (TGLBoxPainter); The supported options are:; ; ""GLBOX"" : TH3 as a set of boxes, size of box is proportional to bin content.; ""GLBOX1"": the same as ""glbox"", ",MatchSource.WIKI,root/html528/TGLHistPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLHistPainter.html
https://root.cern/root/html528/TGLHistPainter.html:1426,Testability,log,logarithmic,1426,"ss.; TGLHistPainter allows to paint them using the OpenGL 3D graphics; library. The plotting options provided by TGLHistPainter start with; GL keyword.; General information: plot types and supported options; The following types of plots are provided:. Lego - (TGLLegoPainter); The supported options are:; ; ""GLLEGO"" : Draw a lego plot.; ""GLLEGO2"" : Bins with color levels.; ""GLLEGO3"" : Cylindrical bars.; ; Lego painter in cartesian supports logarithmic scales for X, Y, Z.; In polar only Z axis can be logarithmic, in cylindrical only Y (if you see; what it means).; Surfaces (TF2 and TH2 with ""GLSURF"" options) - (TGLSurfacePainter); The supported options are:; ; ""GLSURF"" : Draw a surface.; ""GLSURF1"" : Surface with color levels; ""GLSURF2"" : The same as ""GLSURF1"" but without polygon outlines.; ""GLSURF3"" : Color level projection on top of plot (works only in cartesian coordinate system).; ""GLSURF4"" : Same as ""GLSURF"" but without polygon outlines.; ; The surface painting in cartesian coordinates supports logarithmic scales along X, Y, Z axis.; In polar coordinates only the Z axis can be logarithmic, in cylindrical coordinates only the Y axis.; Additional options to SURF and LEGO - Coordinate systems:; The supported options are:; ; "" "" : Default, cartesian coordinates system.; ""POL"" : Polar coordinates system.; ""CYL"" : Cylindrical coordinates system.; ""SPH"" : Spherical coordinates system.; ; TH3 as boxes (spheres) - (TGLBoxPainter); The supported options are:; ; ""GLBOX"" : TH3 as a set of boxes, size of box is proportional to bin content.; ""GLBOX1"": the same as ""glbox"", but spheres are drawn instead of boxes.; ; TH3 as iso-surface(s) - (TGLIsoPainter); The supported option is:; ; ""GLISO"" : TH3 is drawn using iso-surfaces.; ; TF3 (implicit function) - (TGLTF3Painter); The supported option is:; ; ""GLTF3"" : Draw a TF3.; ; Parametric surfaces - (TGLParametricPlot); $ROOTSYS/tutorials/gl/glparametric.C shows how to create parametric equations and; visualize the surface. Interaction ",MatchSource.WIKI,root/html528/TGLHistPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLHistPainter.html
https://root.cern/root/html528/TGLHistPainter.html:1510,Testability,log,logarithmic,1510," provided by TGLHistPainter start with; GL keyword.; General information: plot types and supported options; The following types of plots are provided:. Lego - (TGLLegoPainter); The supported options are:; ; ""GLLEGO"" : Draw a lego plot.; ""GLLEGO2"" : Bins with color levels.; ""GLLEGO3"" : Cylindrical bars.; ; Lego painter in cartesian supports logarithmic scales for X, Y, Z.; In polar only Z axis can be logarithmic, in cylindrical only Y (if you see; what it means).; Surfaces (TF2 and TH2 with ""GLSURF"" options) - (TGLSurfacePainter); The supported options are:; ; ""GLSURF"" : Draw a surface.; ""GLSURF1"" : Surface with color levels; ""GLSURF2"" : The same as ""GLSURF1"" but without polygon outlines.; ""GLSURF3"" : Color level projection on top of plot (works only in cartesian coordinate system).; ""GLSURF4"" : Same as ""GLSURF"" but without polygon outlines.; ; The surface painting in cartesian coordinates supports logarithmic scales along X, Y, Z axis.; In polar coordinates only the Z axis can be logarithmic, in cylindrical coordinates only the Y axis.; Additional options to SURF and LEGO - Coordinate systems:; The supported options are:; ; "" "" : Default, cartesian coordinates system.; ""POL"" : Polar coordinates system.; ""CYL"" : Cylindrical coordinates system.; ""SPH"" : Spherical coordinates system.; ; TH3 as boxes (spheres) - (TGLBoxPainter); The supported options are:; ; ""GLBOX"" : TH3 as a set of boxes, size of box is proportional to bin content.; ""GLBOX1"": the same as ""glbox"", but spheres are drawn instead of boxes.; ; TH3 as iso-surface(s) - (TGLIsoPainter); The supported option is:; ; ""GLISO"" : TH3 is drawn using iso-surfaces.; ; TF3 (implicit function) - (TGLTF3Painter); The supported option is:; ; ""GLTF3"" : Draw a TF3.; ; Parametric surfaces - (TGLParametricPlot); $ROOTSYS/tutorials/gl/glparametric.C shows how to create parametric equations and; visualize the surface. Interaction with the plots. General information. All the interactions are implemented via standard methods Dist",MatchSource.WIKI,root/html528/TGLHistPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLHistPainter.html
https://root.cern/root/html528/TGLineLBEntry.html:4658,Availability,error,error,4658,"st char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); Int_tTGLBEntry::EntryId() const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static FontStruct_tTGTextLBEntry::GetDefaultFontStruct(); static Pixel_tTGFrame::GetDefaultFrameBackground(); static const TGGC&TGTextLBEntry::GetDefaultGC(); virtual UInt_tTGFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionGetDefaultSize() const; virtual UInt_tTGFrame::GetDefaultWidth() const; virtu",MatchSource.WIKI,root/html528/TGLineLBEntry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLineLBEntry.html
https://root.cern/root/html528/TGLineLBEntry.html:4742,Availability,error,error,4742,"m); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); Int_tTGLBEntry::EntryId() const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static FontStruct_tTGTextLBEntry::GetDefaultFontStruct(); static Pixel_tTGFrame::GetDefaultFrameBackground(); static const TGGC&TGTextLBEntry::GetDefaultGC(); virtual UInt_tTGFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionGetDefaultSize() const; virtual UInt_tTGFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType() const; ",MatchSource.WIKI,root/html528/TGLineLBEntry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLineLBEntry.html
https://root.cern/root/html528/TGLineLBEntry.html:16448,Availability,mask,mask,16448,,MatchSource.WIKI,root/html528/TGLineLBEntry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLineLBEntry.html
https://root.cern/root/html528/TGLineLBEntry.html:447,Usability,simpl,simple,447,". TGLineLBEntry. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGLineLBEntry. class TGLineLBEntry: public TGTextLBEntry. TGListBox, TGLBContainer, TGLBEntry and TGTextLBEntry. A listbox is a box, possibly with scrollbar, containing entries.; Currently entries are simple text strings (TGTextLBEntry).; A TGListBox looks a lot like a TGCanvas. It has a TGViewPort; containing a TGLBContainer which contains the entries and it also; has a vertical scrollbar which becomes visible if there are more; items than fit in the visible part of the container. The TGListBox is user callable. The other classes are service; classes of the listbox. Selecting an item in the listbox will generate the event:; kC_COMMAND, kCM_LISTBOX, listbox id, item id. Function Members (Methods); public:. TGLineLBEntry(const TGWindow* p = 0, Int_t id = -1, const char* str = 0, UInt_t w = 0, Style_t s = 0, UInt_t options = kHorizontalFrame, Pixel_t back = GetWhitePixel()); virtual~TGLineLBEntry(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGLBEntry::Activate(Bool_t a); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGFrame::ChangeOptions(UInt_t options); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Co",MatchSource.WIKI,root/html528/TGLineLBEntry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLineLBEntry.html
https://root.cern/root/html528/TGLineStyleComboBox.html:381,Availability,down,down,381,". TGLineStyleComboBox. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGLineStyleComboBox. class TGLineStyleComboBox: public TGComboBox. TGComboBox, TGComboBoxPopup. A combobox (also known as a drop down listbox) allows the selection; of one item out of a list of items. The selected item is visible in; a little window. To view the list of possible items one has to click; on a button on the right of the little window. This will drop down; a listbox. After selecting an item from the listbox the box will; disappear and the newly selected item will be shown in the little; window. The TGComboBox is user callable. The TGComboBoxPopup is a service; class of the combobox. Selecting an item in the combobox will generate the event:; kC_COMMAND, kCM_COMBOBOX, combobox id, item id. Function Members (Methods); public:. TGLineStyleComboBox(const TGWindow* p = 0, Int_t id = -1, UInt_t options = kHorizontalFrame|kSunkenFrame|kDoubleBorder, Pixel_t back = GetWhitePixel()); ~TGLineStyleComboBox(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidTGComboBox::AddEntry(TGString* s, Int_t id); virtual voidTGComboBox::AddEntry(const char* s, Int_t id); virtual voidTGComboBox::AddEntry(TGLBEntry* lbe, TGLayoutHints* lhints); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual voidTGWidget::Associate(const TGWindow* w); static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* meth",MatchSource.WIKI,root/html528/TGLineStyleComboBox.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLineStyleComboBox.html
https://root.cern/root/html528/TGLineStyleComboBox.html:618,Availability,down,down,618,". TGLineStyleComboBox. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGLineStyleComboBox. class TGLineStyleComboBox: public TGComboBox. TGComboBox, TGComboBoxPopup. A combobox (also known as a drop down listbox) allows the selection; of one item out of a list of items. The selected item is visible in; a little window. To view the list of possible items one has to click; on a button on the right of the little window. This will drop down; a listbox. After selecting an item from the listbox the box will; disappear and the newly selected item will be shown in the little; window. The TGComboBox is user callable. The TGComboBoxPopup is a service; class of the combobox. Selecting an item in the combobox will generate the event:; kC_COMMAND, kCM_COMBOBOX, combobox id, item id. Function Members (Methods); public:. TGLineStyleComboBox(const TGWindow* p = 0, Int_t id = -1, UInt_t options = kHorizontalFrame|kSunkenFrame|kDoubleBorder, Pixel_t back = GetWhitePixel()); ~TGLineStyleComboBox(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidTGComboBox::AddEntry(TGString* s, Int_t id); virtual voidTGComboBox::AddEntry(const char* s, Int_t id); virtual voidTGComboBox::AddEntry(TGLBEntry* lbe, TGLayoutHints* lhints); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual voidTGWidget::Associate(const TGWindow* w); static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* meth",MatchSource.WIKI,root/html528/TGLineStyleComboBox.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLineStyleComboBox.html
https://root.cern/root/html528/TGLineStyleComboBox.html:5148,Availability,error,error,5148," voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTGComboBox::EnableTextInput(Bool_t on)TOGGLE GETTER ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGLBEntry*TGComboBox::FindEntry(const char* s) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; const char*TGWidget::GetCommand() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDime",MatchSource.WIKI,root/html528/TGLineStyleComboBox.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLineStyleComboBox.html
https://root.cern/root/html528/TGLineStyleComboBox.html:5232,Availability,error,error,5232,"* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTGComboBox::EnableTextInput(Bool_t on)TOGGLE GETTER ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGLBEntry*TGComboBox::FindEntry(const char* s) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; const char*TGWidget::GetCommand() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGComboBox::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultW",MatchSource.WIKI,root/html528/TGLineStyleComboBox.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLineStyleComboBox.html
https://root.cern/root/html528/TGLineStyleComboBox.html:19156,Availability,down,down,19156,,MatchSource.WIKI,root/html528/TGLineStyleComboBox.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLineStyleComboBox.html
https://root.cern/root/html528/TGLineStyleComboBox.html:19311,Availability,mask,mask,19311,,MatchSource.WIKI,root/html528/TGLineStyleComboBox.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLineStyleComboBox.html
https://root.cern/root/html528/TGLineWidthComboBox.html:381,Availability,down,down,381,". TGLineWidthComboBox. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGLineWidthComboBox. class TGLineWidthComboBox: public TGComboBox. TGComboBox, TGComboBoxPopup. A combobox (also known as a drop down listbox) allows the selection; of one item out of a list of items. The selected item is visible in; a little window. To view the list of possible items one has to click; on a button on the right of the little window. This will drop down; a listbox. After selecting an item from the listbox the box will; disappear and the newly selected item will be shown in the little; window. The TGComboBox is user callable. The TGComboBoxPopup is a service; class of the combobox. Selecting an item in the combobox will generate the event:; kC_COMMAND, kCM_COMBOBOX, combobox id, item id. Function Members (Methods); public:. TGLineWidthComboBox(const TGWindow* p = 0, Int_t id = -1, UInt_t options = kHorizontalFrame|kSunkenFrame|kDoubleBorder, Pixel_t back = GetWhitePixel(), Bool_t none = kFALSE); ~TGLineWidthComboBox(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidTGComboBox::AddEntry(TGString* s, Int_t id); virtual voidTGComboBox::AddEntry(const char* s, Int_t id); virtual voidTGComboBox::AddEntry(TGLBEntry* lbe, TGLayoutHints* lhints); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual voidTGWidget::Associate(const TGWindow* w); static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::Chan",MatchSource.WIKI,root/html528/TGLineWidthComboBox.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLineWidthComboBox.html
https://root.cern/root/html528/TGLineWidthComboBox.html:618,Availability,down,down,618,". TGLineWidthComboBox. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGLineWidthComboBox. class TGLineWidthComboBox: public TGComboBox. TGComboBox, TGComboBoxPopup. A combobox (also known as a drop down listbox) allows the selection; of one item out of a list of items. The selected item is visible in; a little window. To view the list of possible items one has to click; on a button on the right of the little window. This will drop down; a listbox. After selecting an item from the listbox the box will; disappear and the newly selected item will be shown in the little; window. The TGComboBox is user callable. The TGComboBoxPopup is a service; class of the combobox. Selecting an item in the combobox will generate the event:; kC_COMMAND, kCM_COMBOBOX, combobox id, item id. Function Members (Methods); public:. TGLineWidthComboBox(const TGWindow* p = 0, Int_t id = -1, UInt_t options = kHorizontalFrame|kSunkenFrame|kDoubleBorder, Pixel_t back = GetWhitePixel(), Bool_t none = kFALSE); ~TGLineWidthComboBox(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidTGComboBox::AddEntry(TGString* s, Int_t id); virtual voidTGComboBox::AddEntry(const char* s, Int_t id); virtual voidTGComboBox::AddEntry(TGLBEntry* lbe, TGLayoutHints* lhints); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual voidTGWidget::Associate(const TGWindow* w); static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::Chan",MatchSource.WIKI,root/html528/TGLineWidthComboBox.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLineWidthComboBox.html
https://root.cern/root/html528/TGLineWidthComboBox.html:5170,Availability,error,error,5170," voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTGComboBox::EnableTextInput(Bool_t on)TOGGLE GETTER ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGLBEntry*TGComboBox::FindEntry(const char* s) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; const char*TGWidget::GetCommand() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDime",MatchSource.WIKI,root/html528/TGLineWidthComboBox.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLineWidthComboBox.html
https://root.cern/root/html528/TGLineWidthComboBox.html:5254,Availability,error,error,5254,"* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTGComboBox::EnableTextInput(Bool_t on)TOGGLE GETTER ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGLBEntry*TGComboBox::FindEntry(const char* s) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; const char*TGWidget::GetCommand() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGComboBox::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultW",MatchSource.WIKI,root/html528/TGLineWidthComboBox.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLineWidthComboBox.html
https://root.cern/root/html528/TGLineWidthComboBox.html:19178,Availability,down,down,19178,,MatchSource.WIKI,root/html528/TGLineWidthComboBox.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLineWidthComboBox.html
https://root.cern/root/html528/TGLineWidthComboBox.html:19333,Availability,mask,mask,19333,,MatchSource.WIKI,root/html528/TGLineWidthComboBox.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLineWidthComboBox.html
https://root.cern/root/html528/TGLIsoPainter.html:4512,Modifiability,variab,variables,4512,"TIsoMesh<float> > >fIsos; pair<double,double>fMinMax; TGLLevelPalettefPalette; TGLTH3SlicefXOYSlice; TGLTH3SlicefXOZSlice; TGLTH3SlicefYOZSlice. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLIsoPainter(TH1* hist, TGLPlotCamera* camera, TGLPlotCoordinates* coord); Constructor. char * GetPlotInfo(Int_t px, Int_t py); Return info for plot part under cursor. Bool_t InitGeometry(); Initializes meshes for 3d iso contours. void StartPan(Int_t px, Int_t py); User clicks right mouse button (in a pad). void Pan(Int_t px, Int_t py); User's moving mouse cursor, with middle mouse button pressed (for pad).; Calculate 3d shift related to 2d mouse movement.; User's moving mouse cursor, with middle mouse button pressed (for pad).; Calculate 3d shift related to 2d mouse movement. void AddOption(const TString& option); No additional options for TGLIsoPainter. void ProcessEvent(Int_t event, Int_t px, Int_t py); Change color sheme. void InitGL() const; Initialize OpenGL state variables. void DeInitGL() const; Initialize OpenGL state variables. void DrawPlot() const; Draw mesh. void DrawSectionXOZ() const; Draw XOZ parallel section. void DrawSectionYOZ() const; Draw YOZ parallel section. void DrawSectionXOY() const; Draw XOY parallel section. Bool_t HasSections() const; Any section exists. void SetSurfaceColor(Int_t ind) const; Set color for surface. void SetMesh(TGLIsoPainter::Mesh_t& mesh, Double_t isoValue); Grid geometry. void DrawMesh(const TGLIsoPainter::Mesh_t& mesh, Int_t level) const; Draw TF3 surface. void FindMinMax(); Find max/min bin contents for TH3. TGLIsoPainter(TH1* hist, TGLPlotCamera* camera, TGLPlotCoordinates* coord). » Author: Timur Pocheptsov 31/08/2006 » Copyright (C) 1995-2006, Rene Brun and Fons Rademakers. *; » Last changed: root/gl:$Id$ » Last generated: 2010-09-23 20:06; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to RO",MatchSource.WIKI,root/html528/TGLIsoPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLIsoPainter.html
https://root.cern/root/html528/TGLIsoPainter.html:4570,Modifiability,variab,variables,4570,"at> > >fIsos; pair<double,double>fMinMax; TGLLevelPalettefPalette; TGLTH3SlicefXOYSlice; TGLTH3SlicefXOZSlice; TGLTH3SlicefYOZSlice. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLIsoPainter(TH1* hist, TGLPlotCamera* camera, TGLPlotCoordinates* coord); Constructor. char * GetPlotInfo(Int_t px, Int_t py); Return info for plot part under cursor. Bool_t InitGeometry(); Initializes meshes for 3d iso contours. void StartPan(Int_t px, Int_t py); User clicks right mouse button (in a pad). void Pan(Int_t px, Int_t py); User's moving mouse cursor, with middle mouse button pressed (for pad).; Calculate 3d shift related to 2d mouse movement.; User's moving mouse cursor, with middle mouse button pressed (for pad).; Calculate 3d shift related to 2d mouse movement. void AddOption(const TString& option); No additional options for TGLIsoPainter. void ProcessEvent(Int_t event, Int_t px, Int_t py); Change color sheme. void InitGL() const; Initialize OpenGL state variables. void DeInitGL() const; Initialize OpenGL state variables. void DrawPlot() const; Draw mesh. void DrawSectionXOZ() const; Draw XOZ parallel section. void DrawSectionYOZ() const; Draw YOZ parallel section. void DrawSectionXOY() const; Draw XOY parallel section. Bool_t HasSections() const; Any section exists. void SetSurfaceColor(Int_t ind) const; Set color for surface. void SetMesh(TGLIsoPainter::Mesh_t& mesh, Double_t isoValue); Grid geometry. void DrawMesh(const TGLIsoPainter::Mesh_t& mesh, Int_t level) const; Draw TF3 surface. void FindMinMax(); Find max/min bin contents for TH3. TGLIsoPainter(TH1* hist, TGLPlotCamera* camera, TGLPlotCoordinates* coord). » Author: Timur Pocheptsov 31/08/2006 » Copyright (C) 1995-2006, Rene Brun and Fons Rademakers. *; » Last changed: root/gl:$Id$ » Last generated: 2010-09-23 20:06; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html528/TGLIsoPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLIsoPainter.html
https://root.cern/root/html528/TGListBox.html:5278,Availability,error,error,5278,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGLBEntry*FindEntry(const char* s) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; const char*TGWidget::GetCommand() const; virtual TGFrame*GetContainer() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBa",MatchSource.WIKI,root/html528/TGListBox.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGListBox.html
https://root.cern/root/html528/TGListBox.html:5362,Availability,error,error,5362,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGLBEntry*FindEntry(const char* s) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; const char*TGWidget::GetCommand() const; virtual TGFrame*GetContainer() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionGetDefaultSize() const; virtual UInt_tTGCompositeFram",MatchSource.WIKI,root/html528/TGListBox.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGListBox.html
https://root.cern/root/html528/TGListBox.html:19177,Availability,mask,mask,19177,"dObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Pixel_tTGFrame::fBackgroundframe background color; Int_tTGFrame::fBorderWidthframe border width; TGClient*TGObject::fClientConnection to display server; TStringTGWidget::fCommandcommand to be executed; Int_tTGFrame::fDNDStateEDNDFlags; UInt_tTGWindow::fEditDisabledflags used for ""guibuilding""; UInt_tTGFrame::fEventMaskcurrenty active event mask; TGFrameElement*TGFrame::fFEpointer to frame element; UInt_tTGFrame::fHeightframe height; Handle_tTGObject::fIdX11/Win32 Window identifier; Bool_tfIntegralHeighttrue if height should be multiple of fItemVsize; UInt_tfItemVsizemaximum height of single entry; Bool_tTGCompositeFrame::fLayoutBrokenno layout manager is used; TGLayoutManager*TGCompositeFrame::fLayoutManagerlayout manager; TGLBContainer*fLbclistbox container; TList*TGCompositeFrame::fListcontainer of frame elements; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Bool_tTGCompositeFrame::fMapSubwindowskTRUE - map subwindows; UInt_tTGFrame::fMaxHeightmaximal frame height; UInt_tTGFrame::fMaxWidthmaximal frame width; UInt_tTGFrame::fMinHeightminimal frame height; UInt_tTGFrame::fMinWidthminimal frame width; const TGWindow*TGWidget::fMsgWindowwindow which handles widget events; Int_tTGCompositeFrame::fMustCleanupcleanup mode (see EFrameCleanup); TStringTGWindow::fNamename of the window used in SavePrimitive(); Bool_tTGWindow::fNeedRedrawkTRUE if window needs to be redrawn; UInt_tTGFrame::fOptionsframe options; const TGWindow*TGWindow::fParentParent window; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; TGVScrollBar*fVScrollbarvertical scrollbar; TGViewPort*fVportlistbox viewport (see TGCanvas.h); Int_tTGWidget::fWidgetFlagswidget status flags (OR of EWidgetStatus); Int_tTGWidget::fWidgetIdthe widget id (used for event process",MatchSource.WIKI,root/html528/TGListBox.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGListBox.html
https://root.cern/root/html528/TGListBox.html:22176,Integrability,rout,routine,22176,"tatic Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGListBox(const TGWindow* p = 0, Int_t id = -1, UInt_t options = kSunkenFrame|kDoubleBorder, Pixel_t back = GetWhitePixel()); Create a listbox. ~TGListBox(); Delete a listbox widget. void InitListBox(); Initiate the internal classes of a list box. void DrawBorder(); Draw borders of the list box widget. void AddEntry(TGString* s, Int_t id); Add entry with specified string and id to listbox. The id will be; used in the event processing routine when the item is selected.; The string will be adopted by the listbox. void AddEntry(const char* s, Int_t id); Add entry with specified string and id to listbox. The id will be; used in the event processing routine when the item is selected. void AddEntry(TGLBEntry* lbe, TGLayoutHints* lhints); Add specified TGLBEntry and TGLayoutHints to listbox. The; entry and layout will be adopted and later deleted by the listbox. void AddEntrySort(TGString* s, Int_t id); Add entry with specified string and id to listbox sorted by increasing id.; This sorting works proberly only if EntrySort functions are used to add; entries without mixing them with other add or insert functions. The id will be; used in the event processing routine when the item is selected.; The string will be adopted by the listbox. void AddEntrySort(const char* s, Int_t id); Add entry with specified string and id to listbox sorted by increasing id.; This sorting works proberly only if EntrySort functions are used ",MatchSource.WIKI,root/html528/TGListBox.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGListBox.html
https://root.cern/root/html528/TGListBox.html:22391,Integrability,rout,routine,22391,"gHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGListBox(const TGWindow* p = 0, Int_t id = -1, UInt_t options = kSunkenFrame|kDoubleBorder, Pixel_t back = GetWhitePixel()); Create a listbox. ~TGListBox(); Delete a listbox widget. void InitListBox(); Initiate the internal classes of a list box. void DrawBorder(); Draw borders of the list box widget. void AddEntry(TGString* s, Int_t id); Add entry with specified string and id to listbox. The id will be; used in the event processing routine when the item is selected.; The string will be adopted by the listbox. void AddEntry(const char* s, Int_t id); Add entry with specified string and id to listbox. The id will be; used in the event processing routine when the item is selected. void AddEntry(TGLBEntry* lbe, TGLayoutHints* lhints); Add specified TGLBEntry and TGLayoutHints to listbox. The; entry and layout will be adopted and later deleted by the listbox. void AddEntrySort(TGString* s, Int_t id); Add entry with specified string and id to listbox sorted by increasing id.; This sorting works proberly only if EntrySort functions are used to add; entries without mixing them with other add or insert functions. The id will be; used in the event processing routine when the item is selected.; The string will be adopted by the listbox. void AddEntrySort(const char* s, Int_t id); Add entry with specified string and id to listbox sorted by increasing id.; This sorting works proberly only if EntrySort functions are used to add; entries without mixing them with other add or insert functions. The id will be; used in the event processing routine when the item is selected. void AddEntrySort(TGLBEntry* lbe, TGLayoutHints* lhints); Add s",MatchSource.WIKI,root/html528/TGListBox.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGListBox.html
https://root.cern/root/html528/TGListBox.html:22906,Integrability,rout,routine,22906,"te a listbox widget. void InitListBox(); Initiate the internal classes of a list box. void DrawBorder(); Draw borders of the list box widget. void AddEntry(TGString* s, Int_t id); Add entry with specified string and id to listbox. The id will be; used in the event processing routine when the item is selected.; The string will be adopted by the listbox. void AddEntry(const char* s, Int_t id); Add entry with specified string and id to listbox. The id will be; used in the event processing routine when the item is selected. void AddEntry(TGLBEntry* lbe, TGLayoutHints* lhints); Add specified TGLBEntry and TGLayoutHints to listbox. The; entry and layout will be adopted and later deleted by the listbox. void AddEntrySort(TGString* s, Int_t id); Add entry with specified string and id to listbox sorted by increasing id.; This sorting works proberly only if EntrySort functions are used to add; entries without mixing them with other add or insert functions. The id will be; used in the event processing routine when the item is selected.; The string will be adopted by the listbox. void AddEntrySort(const char* s, Int_t id); Add entry with specified string and id to listbox sorted by increasing id.; This sorting works proberly only if EntrySort functions are used to add; entries without mixing them with other add or insert functions. The id will be; used in the event processing routine when the item is selected. void AddEntrySort(TGLBEntry* lbe, TGLayoutHints* lhints); Add specified TGLBEntry and TGLayoutHints to listbox sorted by increasing id.; This sorting works proberly only if EntrySort functions are used to add; entries without mixing them with other add or insert functions. The; entry and layout will be adopted and later deleted by the listbox. void InsertEntry(TGString* s, Int_t id, Int_t afterID); Insert entry with specified string and id behind the entry with afterID.; The string will be adopted and later deleted by the listbox. void InsertEntry(const char* s, Int_t id,",MatchSource.WIKI,root/html528/TGListBox.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGListBox.html
https://root.cern/root/html528/TGListBox.html:23287,Integrability,rout,routine,23287,"s, Int_t id); Add entry with specified string and id to listbox. The id will be; used in the event processing routine when the item is selected. void AddEntry(TGLBEntry* lbe, TGLayoutHints* lhints); Add specified TGLBEntry and TGLayoutHints to listbox. The; entry and layout will be adopted and later deleted by the listbox. void AddEntrySort(TGString* s, Int_t id); Add entry with specified string and id to listbox sorted by increasing id.; This sorting works proberly only if EntrySort functions are used to add; entries without mixing them with other add or insert functions. The id will be; used in the event processing routine when the item is selected.; The string will be adopted by the listbox. void AddEntrySort(const char* s, Int_t id); Add entry with specified string and id to listbox sorted by increasing id.; This sorting works proberly only if EntrySort functions are used to add; entries without mixing them with other add or insert functions. The id will be; used in the event processing routine when the item is selected. void AddEntrySort(TGLBEntry* lbe, TGLayoutHints* lhints); Add specified TGLBEntry and TGLayoutHints to listbox sorted by increasing id.; This sorting works proberly only if EntrySort functions are used to add; entries without mixing them with other add or insert functions. The; entry and layout will be adopted and later deleted by the listbox. void InsertEntry(TGString* s, Int_t id, Int_t afterID); Insert entry with specified string and id behind the entry with afterID.; The string will be adopted and later deleted by the listbox. void InsertEntry(const char* s, Int_t id, Int_t afterID); Insert entry with specified string and id behind the entry with afterID. void NewEntry(const char* s = ""Entry""); method used to add entry via context menu. void RemoveAll(); Remove all entries. void RemoveEntries(Int_t from_ID, Int_t to_ID); Remove a range of entries defined by from_ID and to_ID. void InsertEntry(TGLBEntry* lbe, TGLayoutHints* lhints, Int_t afte",MatchSource.WIKI,root/html528/TGListBox.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGListBox.html
https://root.cern/root/html528/TGListBox.html:25352,Integrability,message,messages,25352,"yout will be adopted and later deleted by the listbox. TGLBEntry * GetEntry(Int_t id) const; Returns list box entry with specified id. void SetTopEntry(Int_t id = -1); Scroll the entry with id to the top of the listbox. void Resize(UInt_t w, UInt_t h); Resize the listbox widget. If fIntegralHeight is true make the height; an integral number of the maximum height of a single entry. void MoveResize(Int_t x, Int_t y, UInt_t w, UInt_t h); Move and resize the listbox widget. TGDimension GetDefaultSize() const; Return default size of listbox widget. void Layout(); Layout the listbox components. void SortByName(Bool_t ascend = kTRUE); Sort entries by name. Int_t GetSelected() const; Return id of selected listbox item. void GetSelectedEntries(TList* selected); Adds all selected entries (TGLBEntry) of the list box into; the list selected. void ChangeBackground(Pixel_t back); Change background to all entries. Bool_t ProcessMessage(Long_t msg, Long_t parm1, Long_t parm2); Process messages generated by the listbox container and forward; messages to the listbox message handling window. void Selected(Int_t widgetId, Int_t id); Emit Selected signal with list box id and entry id. void DoubleClicked(Int_t widgetId, Int_t id); Emit DoubleClicked signal with list box id and entry id. TGLBEntry * FindEntry(const char* s) const; Find entry by name. void SavePrimitive(ostream& out, Option_t* option = """"); Save a list box widget as a C++ statement(s) on output stream out. TGTextLBEntry & operator=(const TGListBox& ). void RemoveEntry(Int_t id = -1). Bool_t GetSelection(Int_t id). TGLBEntry * GetSelectedEntry() const; { return fLastActive; }. TGLBEntry * Select(Int_t id, Bool_t sel = kTRUE). TGVScrollBar * GetVScrollbar() const. void SetMultipleSelections(Bool_t multi = kTRUE). Bool_t GetMultipleSelections() const; { return fMultiSelect; }. TGListBox(const TGListBox& ). void SetContainer(TGFrame* f); { fVport->SetContainer(f); }. Int_t GetNumberOfEntries() const; { return fLbc->GetList()->G",MatchSource.WIKI,root/html528/TGListBox.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGListBox.html
https://root.cern/root/html528/TGListBox.html:25409,Integrability,message,messages,25409,"yout will be adopted and later deleted by the listbox. TGLBEntry * GetEntry(Int_t id) const; Returns list box entry with specified id. void SetTopEntry(Int_t id = -1); Scroll the entry with id to the top of the listbox. void Resize(UInt_t w, UInt_t h); Resize the listbox widget. If fIntegralHeight is true make the height; an integral number of the maximum height of a single entry. void MoveResize(Int_t x, Int_t y, UInt_t w, UInt_t h); Move and resize the listbox widget. TGDimension GetDefaultSize() const; Return default size of listbox widget. void Layout(); Layout the listbox components. void SortByName(Bool_t ascend = kTRUE); Sort entries by name. Int_t GetSelected() const; Return id of selected listbox item. void GetSelectedEntries(TList* selected); Adds all selected entries (TGLBEntry) of the list box into; the list selected. void ChangeBackground(Pixel_t back); Change background to all entries. Bool_t ProcessMessage(Long_t msg, Long_t parm1, Long_t parm2); Process messages generated by the listbox container and forward; messages to the listbox message handling window. void Selected(Int_t widgetId, Int_t id); Emit Selected signal with list box id and entry id. void DoubleClicked(Int_t widgetId, Int_t id); Emit DoubleClicked signal with list box id and entry id. TGLBEntry * FindEntry(const char* s) const; Find entry by name. void SavePrimitive(ostream& out, Option_t* option = """"); Save a list box widget as a C++ statement(s) on output stream out. TGTextLBEntry & operator=(const TGListBox& ). void RemoveEntry(Int_t id = -1). Bool_t GetSelection(Int_t id). TGLBEntry * GetSelectedEntry() const; { return fLastActive; }. TGLBEntry * Select(Int_t id, Bool_t sel = kTRUE). TGVScrollBar * GetVScrollbar() const. void SetMultipleSelections(Bool_t multi = kTRUE). Bool_t GetMultipleSelections() const; { return fMultiSelect; }. TGListBox(const TGListBox& ). void SetContainer(TGFrame* f); { fVport->SetContainer(f); }. Int_t GetNumberOfEntries() const; { return fLbc->GetList()->G",MatchSource.WIKI,root/html528/TGListBox.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGListBox.html
https://root.cern/root/html528/TGListBox.html:25433,Integrability,message,message,25433,"yout will be adopted and later deleted by the listbox. TGLBEntry * GetEntry(Int_t id) const; Returns list box entry with specified id. void SetTopEntry(Int_t id = -1); Scroll the entry with id to the top of the listbox. void Resize(UInt_t w, UInt_t h); Resize the listbox widget. If fIntegralHeight is true make the height; an integral number of the maximum height of a single entry. void MoveResize(Int_t x, Int_t y, UInt_t w, UInt_t h); Move and resize the listbox widget. TGDimension GetDefaultSize() const; Return default size of listbox widget. void Layout(); Layout the listbox components. void SortByName(Bool_t ascend = kTRUE); Sort entries by name. Int_t GetSelected() const; Return id of selected listbox item. void GetSelectedEntries(TList* selected); Adds all selected entries (TGLBEntry) of the list box into; the list selected. void ChangeBackground(Pixel_t back); Change background to all entries. Bool_t ProcessMessage(Long_t msg, Long_t parm1, Long_t parm2); Process messages generated by the listbox container and forward; messages to the listbox message handling window. void Selected(Int_t widgetId, Int_t id); Emit Selected signal with list box id and entry id. void DoubleClicked(Int_t widgetId, Int_t id); Emit DoubleClicked signal with list box id and entry id. TGLBEntry * FindEntry(const char* s) const; Find entry by name. void SavePrimitive(ostream& out, Option_t* option = """"); Save a list box widget as a C++ statement(s) on output stream out. TGTextLBEntry & operator=(const TGListBox& ). void RemoveEntry(Int_t id = -1). Bool_t GetSelection(Int_t id). TGLBEntry * GetSelectedEntry() const; { return fLastActive; }. TGLBEntry * Select(Int_t id, Bool_t sel = kTRUE). TGVScrollBar * GetVScrollbar() const. void SetMultipleSelections(Bool_t multi = kTRUE). Bool_t GetMultipleSelections() const; { return fMultiSelect; }. TGListBox(const TGListBox& ). void SetContainer(TGFrame* f); { fVport->SetContainer(f); }. Int_t GetNumberOfEntries() const; { return fLbc->GetList()->G",MatchSource.WIKI,root/html528/TGListBox.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGListBox.html
https://root.cern/root/html528/TGListBox.html:455,Usability,simpl,simple,455,". TGListBox. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGListBox. class TGListBox: public TGCompositeFrame, public TGWidget. TGListBox, TGLBContainer, TGLBEntry and TGTextLBEntry. A listbox is a box, possibly with scrollbar, containing entries.; Currently entries are simple text strings (TGTextLBEntry).; A TGListBox looks a lot like a TGCanvas. It has a TGViewPort; containing a TGLBContainer which contains the entries and it also; has a vertical scrollbar which becomes visible if there are more; items than fit in the visible part of the container. The TGListBox is user callable. The other classes are service; classes of the listbox. Selecting an item in the listbox will generate the event:; kC_COMMAND, kCM_LISTBOX, listbox id, item id. Function Members (Methods); public:. TGListBox(const TGWindow* p = 0, Int_t id = -1, UInt_t options = kSunkenFrame|kDoubleBorder, Pixel_t back = GetWhitePixel()); virtual~TGListBox(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidAddEntry(TGString* s, Int_t id); virtual voidAddEntry(const char* s, Int_t id); virtual voidAddEntry(TGLBEntry* lbe, TGLayoutHints* lhints); virtual voidAddEntrySort(TGString* s, Int_t id); virtual voidAddEntrySort(const char* s, Int_t id); virtual voidAddEntrySort(TGLBEntry* lbe, TGLayoutHints* lhints); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual voidTGWidget::Associate(const TGWindow* w); static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidChangeBackground(Pix",MatchSource.WIKI,root/html528/TGListBox.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGListBox.html
https://root.cern/root/html528/TGListDetailsLayout.html:803,Availability,down,downward,803,". TGListDetailsLayout. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGListDetailsLayout. class TGListDetailsLayout: public TGTileLayout. A number of different layout classes (TGLayoutManager,; TGVerticalLayout, TGHorizontalLayout, TGLayoutHints, etc.). Concerning the TGMatrixLayout class:. It arranges frames in a matrix-like way.; This manager provides :; - a column number (0 means unlimited); - a row number (0 means unlimited); - horizontal & vertical separators. Notes : If both column and row are fixed values, any remaining; frames outside the count won't be managed.; Unlimited rows means the frame can expand downward; (the default behaviour in most UI).; Both unlimited rows and columns is undefined (read: will; crash the algorithm ;-).; With fixed dimensions, frames are always arranged in rows.; That is: 1st frame is at position (0,0), next one is at; row(0), column(1) and so on...; When specifying one dimension as unlimited (i.e. row=0 or; column=0) the frames are arranged according to the direction; of the fixed dimension. This layout manager does not make; use of TGLayoutHints. Function Members (Methods); public:. TGListDetailsLayout(TGCompositeFrame* main, Int_t sep = 0, UInt_t w = 0); ~TGListDetailsLayout(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Dra",MatchSource.WIKI,root/html528/TGListDetailsLayout.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGListDetailsLayout.html
https://root.cern/root/html528/TGListDetailsLayout.html:2332,Availability,error,error,2332,"Layout(TGCompositeFrame* main, Int_t sep = 0, UInt_t w = 0); ~TGListDetailsLayout(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TGDimensionGetDefaultSize() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObje",MatchSource.WIKI,root/html528/TGListDetailsLayout.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGListDetailsLayout.html
https://root.cern/root/html528/TGListDetailsLayout.html:2416,Availability,error,error,2416," voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TGDimensionGetDefaultSize() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(c",MatchSource.WIKI,root/html528/TGListDetailsLayout.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGListDetailsLayout.html
https://root.cern/root/html528/TGListLayout.html:782,Availability,down,downward,782,". TGListLayout. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGListLayout. class TGListLayout: public TGTileLayout. A number of different layout classes (TGLayoutManager,; TGVerticalLayout, TGHorizontalLayout, TGLayoutHints, etc.). Concerning the TGMatrixLayout class:. It arranges frames in a matrix-like way.; This manager provides :; - a column number (0 means unlimited); - a row number (0 means unlimited); - horizontal & vertical separators. Notes : If both column and row are fixed values, any remaining; frames outside the count won't be managed.; Unlimited rows means the frame can expand downward; (the default behaviour in most UI).; Both unlimited rows and columns is undefined (read: will; crash the algorithm ;-).; With fixed dimensions, frames are always arranged in rows.; That is: 1st frame is at position (0,0), next one is at; row(0), column(1) and so on...; When specifying one dimension as unlimited (i.e. row=0 or; column=0) the frames are arranged according to the direction; of the fixed dimension. This layout manager does not make; use of TGLayoutHints. Function Members (Methods); public:. TGListLayout(TGCompositeFrame* main, Int_t sep = 0); ~TGListLayout(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::Dr",MatchSource.WIKI,root/html528/TGListLayout.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGListLayout.html
https://root.cern/root/html528/TGListLayout.html:2283,Availability,error,error,2283," TGListLayout(TGCompositeFrame* main, Int_t sep = 0); ~TGListLayout(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::Dr",MatchSource.WIKI,root/html528/TGListLayout.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGListLayout.html
https://root.cern/root/html528/TGListLayout.html:2367,Availability,error,error,2367," voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TGDimensionGetDefaultSize() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(c",MatchSource.WIKI,root/html528/TGListLayout.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGListLayout.html
https://root.cern/root/html528/TGListTree.html:2907,Availability,mask,mask,2907,"ate(const TGWindow* w); static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidTGCompositeFrame::ChangeSubframesBackground(Pixel_t back); voidCheckAllChildren(TGListTreeItem* item, Bool_t state); virtual voidChecked(TObject* obj, Bool_t check)SIGNAL ; voidCheckItem(TGListTreeItem* item, Bool_t check = kTRUE); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTGCompositeFrame::Cleanup(); virtual voidTObject::Clear(Option_t* = """"); voidClearHighlighted(); virtual voidTGContainer::ClearViewPort(); virtual voidClicked(TGListTreeItem* entry, Int_t btn)SIGNAL ; virtual voidClicked(TGListTreeItem* entry, Int_t btn, Int_t x, Int_t y)SIGNAL ; virtual voidClicked(TGListTreeItem* entry, Int_t btn, UInt_t mask, Int_t x, Int_t y)SIGNAL ; virtual TObject*TObject::Clone(const char* newname = """") const; voidCloseItem(TGListTreeItem* item); voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(const char* sender_class, const char* signal, const char* receiver_class, void* receiver, const char* slot); virtual voidTQObject::Connected(const char*); Bool_tTGFrame::Contains(Int_t x, Int_t y) const; virtual voidTObject::Copy(TObject& object) const; virtual voidDataDropped(TGListTreeItem* item, TDNDData* data)SIGNAL ; virtual voidTGFrame::Delete(Option_t* = """"); Int_tDeleteChildren(TGListTreeItem* item); Int_tDeleteItem(TGListTreeItem* item); Int_tDeleteSelected()MENU ;",MatchSource.WIKI,root/html528/TGListTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGListTree.html
https://root.cern/root/html528/TGListTree.html:6349,Availability,error,error,6349," signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidEnd(Bool_t select = kFALSE); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; TGListTreeItem*FindChildByData(TGListTreeItem* item, void* userData); TGListTreeItem*FindChildByName(TGListTreeItem* item, const char* name); virtual TGFrameElement*TGContainer::FindFrame(Int_t x, Int_t y, Bool_t exclude = kTRUE); virtual TGFrame*TGContainer::FindFrameByName(const char* name); virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; TGListTreeItem*FindItemByObj(TGListTreeItem* item, void* ptr); TGListTreeItem*FindItemByPathname(const char* path); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TGListTreeItem*FindSiblingByData(TGListTreeItem* item, void* userData); TGListTreeItem*FindSiblingByName(TGListTreeItem* item, const char* name); Int_tFo",MatchSource.WIKI,root/html528/TGListTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGListTree.html
https://root.cern/root/html528/TGListTree.html:6433,Availability,error,error,6433,"TQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidEnd(Bool_t select = kFALSE); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; TGListTreeItem*FindChildByData(TGListTreeItem* item, void* userData); TGListTreeItem*FindChildByName(TGListTreeItem* item, const char* name); virtual TGFrameElement*TGContainer::FindFrame(Int_t x, Int_t y, Bool_t exclude = kTRUE); virtual TGFrame*TGContainer::FindFrameByName(const char* name); virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; TGListTreeItem*FindItemByObj(TGListTreeItem* item, void* ptr); TGListTreeItem*FindItemByPathname(const char* path); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TGListTreeItem*FindSiblingByData(TGListTreeItem* item, void* userData); TGListTreeItem*FindSiblingByName(TGListTreeItem* item, const char* name); Int_tFontAscent(); Int_tFontHeight(); virtual Pixel_tTGFrame::GetBackground() const; static",MatchSource.WIKI,root/html528/TGListTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGListTree.html
https://root.cern/root/html528/TGListTree.html:13929,Availability,mask,mask,13929,"t(UInt_t f); virtual voidTGContainer::InvertSelection()SIGNAL ; virtual TClass*IsA() const; virtual Bool_tTGFrame::IsActive() const; Bool_tTGCompositeFrame::IsArranged(TGFrame* f) const; Bool_tTGCompositeFrame::IsArranged(TGFrameElement* ptr) const; virtual Bool_tTGCompositeFrame::IsComposite() const; Bool_tTGFrame::IsDNDSource() const; Bool_tTGFrame::IsDNDTarget() const; virtual Bool_tTGCompositeFrame::IsEditable() const; virtual Bool_tTGObject::IsEqual(const TObject* obj) const; Bool_tIsEventHandled() const; virtual Bool_tTObject::IsFolder() const; virtual Bool_tTGCompositeFrame::IsLayoutBroken() const; virtual Bool_tTGWindow::IsMapped(); virtual Bool_tTGCompositeFrame::IsMapSubwindows() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTGCompositeFrame::IsVisible(TGFrame* f) const; Bool_tTGCompositeFrame::IsVisible(TGFrameElement* ptr) const; Bool_tTObject::IsZombie() const; virtual voidKeyPressed(TGListTreeItem* entry, UInt_t keysym, UInt_t mask)SIGNAL ; virtual voidLineDown(Bool_t select = kFALSE); virtual voidTGContainer::LineLeft(Bool_t select = kFALSE); virtual voidTGContainer::LineRight(Bool_t select = kFALSE); virtual voidLineUp(Bool_t select = kFALSE); static voidTQObject::LoadRQ_OBJECT(); virtual voidTGWindow::LowerWindow(); virtual voidTQObject::LowPriority(const char* signal_name, const char* slot_name = 0); virtual voidTObject::ls(Option_t* option = """") const; virtual voidTGFrame::MapRaised(); virtual voidTGCompositeFrame::MapSubwindows(); virtual voidTGFrame::MapWindow(); voidTObject::MayNotUse(const char* method) const; virtual voidTQObject::Message(const char* msg)SIGNAL ; virtual voidMouseOver(TGListTreeItem* entry)SIGNAL ; virtual voidMouseOver(TGListTreeItem* entry, UInt_t mask)SIGNAL ; virtual voidTGFrame::Move(Int_t x, Int_t y); virtual voidTGFrame::MoveResize(Int_t x, Int_t y, UInt_t w = 0, UInt_t h = 0); virtual Int_tTGCompositeFrame::MustCleanup() const; virtual Bool_tTObject::Notify(); virtual Int_tTQO",MatchSource.WIKI,root/html528/TGListTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGListTree.html
https://root.cern/root/html528/TGListTree.html:14693,Availability,mask,mask,14693,"Sortable() const; Bool_tTGCompositeFrame::IsVisible(TGFrame* f) const; Bool_tTGCompositeFrame::IsVisible(TGFrameElement* ptr) const; Bool_tTObject::IsZombie() const; virtual voidKeyPressed(TGListTreeItem* entry, UInt_t keysym, UInt_t mask)SIGNAL ; virtual voidLineDown(Bool_t select = kFALSE); virtual voidTGContainer::LineLeft(Bool_t select = kFALSE); virtual voidTGContainer::LineRight(Bool_t select = kFALSE); virtual voidLineUp(Bool_t select = kFALSE); static voidTQObject::LoadRQ_OBJECT(); virtual voidTGWindow::LowerWindow(); virtual voidTQObject::LowPriority(const char* signal_name, const char* slot_name = 0); virtual voidTObject::ls(Option_t* option = """") const; virtual voidTGFrame::MapRaised(); virtual voidTGCompositeFrame::MapSubwindows(); virtual voidTGFrame::MapWindow(); voidTObject::MayNotUse(const char* method) const; virtual voidTQObject::Message(const char* msg)SIGNAL ; virtual voidMouseOver(TGListTreeItem* entry)SIGNAL ; virtual voidMouseOver(TGListTreeItem* entry, UInt_t mask)SIGNAL ; virtual voidTGFrame::Move(Int_t x, Int_t y); virtual voidTGFrame::MoveResize(Int_t x, Int_t y, UInt_t w = 0, UInt_t h = 0); virtual Int_tTGCompositeFrame::MustCleanup() const; virtual Bool_tTObject::Notify(); virtual Int_tTQObject::NumberOfConnections() const; virtual Int_tTQObject::NumberOfSignals() const; virtual Int_tTGContainer::NumItems() const; virtual Int_tTGContainer::NumSelected() const; voidOpenItem(TGListTreeItem* item); static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidPageDown(Bool_t select = kFALSE); virtual voidPageUp(Bool_t select = kFALSE); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObj",MatchSource.WIKI,root/html528/TGListTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGListTree.html
https://root.cern/root/html528/TGListTree.html:25971,Availability,mask,mask,25971,"rame border width; TBufferFile*fBufbuffer used for Drag and Drop; TGCanvas*TGContainer::fCanvaspointer to canvas; TGListTree::ECheckModefCheckModehow to propagate check properties through the tree; TGClient*TGObject::fClientConnection to display server; GContext_tfColorGCdrawing context for main item color; TGListTree::EColorMarkupModefColorModeif/how to render item's main color; TGListTreeItem*fCurrentpointer to current item in list; TDNDDatafDNDDataDrag and Drop data; Int_tTGFrame::fDNDStateEDNDFlags; Atom_t*fDNDTypeListhandles DND types; UInt_tfDefhdefault list height; UInt_tfDefwdefault list width; Bool_tfDisableOpendisable branch opening on double-clicks; Bool_tTGContainer::fDraggingtrue if in dragging mode; GContext_tfDrawGCicon drawing context; TGListTreeItem*fDropItemitem on which DND is over; UInt_tTGWindow::fEditDisabledflags used for ""guibuilding""; Bool_tfEventHandledflag used from user code to bypass standard event handling; UInt_tTGFrame::fEventMaskcurrenty active event mask; Int_tfExposeBottombottom y position of visible region; Int_tfExposeToptop y postion of visible region; TGRectangleTGContainer::fExposedRegionexposed area; TGFrameElement*TGFrame::fFEpointer to frame element; TGListTreeItem*fFirstpointer to first item in list; FontStruct_tfFontfont used to draw item text; Pixel_tfGrayPixelgray draw color; UInt_tTGFrame::fHeightframe height; GContext_tfHighlightGChighlighted icon drawing context; Int_tfHspacinghorizontal spacing between items; Handle_tTGObject::fIdX11/Win32 Window identifier; Int_tfIndentnumber of pixels indentation; TStringTGContainer::fKeyInputkeyboard input (buffer); TTimer*TGContainer::fKeyTimerkeyboard timer; Bool_tTGContainer::fKeyTimerActivekTRUE - keyboard timer is active; TGListTreeItem*fLastpointer to last item in list; TGFrameElement*TGContainer::fLastActiveEllast active item; Bool_tTGContainer::fLastCasecase sensetivity of last search; Bool_tTGContainer::fLastDirdirection of last search; UInt_tfLastEventStatemodifier state",MatchSource.WIKI,root/html528/TGListTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGListTree.html
https://root.cern/root/html528/TGListTree.html:32284,Availability,mask,mask,32284,"l_t HandleButton(Event_t* event); Handle button events in the list tree. Bool_t HandleDoubleClick(Event_t* event); Handle double click event in the list tree (only for kButton1). Bool_t HandleCrossing(Event_t* event); Handle mouse crossing event. Atom_t HandleDNDPosition(Int_t x, Int_t y, Atom_t action, Int_t xroot, Int_t yroot); Handle dragging position events. Atom_t HandleDNDEnter(Atom_t* typelist); Handle drag enter events. Bool_t HandleDNDLeave(); Handle drag leave events. Bool_t HandleDNDDrop(TDNDData* data); Handle drop events. void DataDropped(TGListTreeItem* item, TDNDData* data); Emit DataDropped() signal. Bool_t HandleMotion(Event_t* event); Handle mouse motion event. Used to set tool tip, to emit; MouseOver() signal and for DND handling. Bool_t HandleKey(Event_t* event); The key press event handler converts a key press to some line editor; action. void MouseOver(TGListTreeItem* entry); Signal emitted when pointer is over entry. void MouseOver(TGListTreeItem* entry, UInt_t mask); Signal emitted when pointer is over entry. void KeyPressed(TGListTreeItem* entry, UInt_t keysym, UInt_t mask); Signal emitted when keyboard key pressed. entry - selected item; keysym - defined in ""KeySymbols.h""; mask - modifier key mask, defined in ""GuiTypes.h"". const Mask_t kKeyShiftMask = BIT(0);; const Mask_t kKeyLockMask = BIT(1);; const Mask_t kKeyControlMask = BIT(2);; const Mask_t kKeyMod1Mask = BIT(3); // typically the Alt key; const Mask_t kButton1Mask = BIT(8);; const Mask_t kButton2Mask = BIT(9);; const Mask_t kButton3Mask = BIT(10);; const Mask_t kButton4Mask = BIT(11);; const Mask_t kButton5Mask = BIT(12);; const Mask_t kAnyModifier = BIT(15);. void ReturnPressed(TGListTreeItem* entry); Emit ReturnPressed() signal. void Checked(TObject* obj, Bool_t check); Emit Checked() signal. void Clicked(TGListTreeItem* entry, Int_t btn); Emit Clicked() signal. void Clicked(TGListTreeItem* entry, Int_t btn, Int_t x, Int_t y); Emit Clicked() signal. void Clicked(TGListTreeItem* ent",MatchSource.WIKI,root/html528/TGListTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGListTree.html
https://root.cern/root/html528/TGListTree.html:32395,Availability,mask,mask,32395,"_t* event); Handle double click event in the list tree (only for kButton1). Bool_t HandleCrossing(Event_t* event); Handle mouse crossing event. Atom_t HandleDNDPosition(Int_t x, Int_t y, Atom_t action, Int_t xroot, Int_t yroot); Handle dragging position events. Atom_t HandleDNDEnter(Atom_t* typelist); Handle drag enter events. Bool_t HandleDNDLeave(); Handle drag leave events. Bool_t HandleDNDDrop(TDNDData* data); Handle drop events. void DataDropped(TGListTreeItem* item, TDNDData* data); Emit DataDropped() signal. Bool_t HandleMotion(Event_t* event); Handle mouse motion event. Used to set tool tip, to emit; MouseOver() signal and for DND handling. Bool_t HandleKey(Event_t* event); The key press event handler converts a key press to some line editor; action. void MouseOver(TGListTreeItem* entry); Signal emitted when pointer is over entry. void MouseOver(TGListTreeItem* entry, UInt_t mask); Signal emitted when pointer is over entry. void KeyPressed(TGListTreeItem* entry, UInt_t keysym, UInt_t mask); Signal emitted when keyboard key pressed. entry - selected item; keysym - defined in ""KeySymbols.h""; mask - modifier key mask, defined in ""GuiTypes.h"". const Mask_t kKeyShiftMask = BIT(0);; const Mask_t kKeyLockMask = BIT(1);; const Mask_t kKeyControlMask = BIT(2);; const Mask_t kKeyMod1Mask = BIT(3); // typically the Alt key; const Mask_t kButton1Mask = BIT(8);; const Mask_t kButton2Mask = BIT(9);; const Mask_t kButton3Mask = BIT(10);; const Mask_t kButton4Mask = BIT(11);; const Mask_t kButton5Mask = BIT(12);; const Mask_t kAnyModifier = BIT(15);. void ReturnPressed(TGListTreeItem* entry); Emit ReturnPressed() signal. void Checked(TObject* obj, Bool_t check); Emit Checked() signal. void Clicked(TGListTreeItem* entry, Int_t btn); Emit Clicked() signal. void Clicked(TGListTreeItem* entry, Int_t btn, Int_t x, Int_t y); Emit Clicked() signal. void Clicked(TGListTreeItem* entry, Int_t btn, UInt_t mask, Int_t x, Int_t y); Emit Clicked() signal. void DoubleClicked(TGListTreeIte",MatchSource.WIKI,root/html528/TGListTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGListTree.html
https://root.cern/root/html528/TGListTree.html:32503,Availability,mask,mask,32503," event. Atom_t HandleDNDPosition(Int_t x, Int_t y, Atom_t action, Int_t xroot, Int_t yroot); Handle dragging position events. Atom_t HandleDNDEnter(Atom_t* typelist); Handle drag enter events. Bool_t HandleDNDLeave(); Handle drag leave events. Bool_t HandleDNDDrop(TDNDData* data); Handle drop events. void DataDropped(TGListTreeItem* item, TDNDData* data); Emit DataDropped() signal. Bool_t HandleMotion(Event_t* event); Handle mouse motion event. Used to set tool tip, to emit; MouseOver() signal and for DND handling. Bool_t HandleKey(Event_t* event); The key press event handler converts a key press to some line editor; action. void MouseOver(TGListTreeItem* entry); Signal emitted when pointer is over entry. void MouseOver(TGListTreeItem* entry, UInt_t mask); Signal emitted when pointer is over entry. void KeyPressed(TGListTreeItem* entry, UInt_t keysym, UInt_t mask); Signal emitted when keyboard key pressed. entry - selected item; keysym - defined in ""KeySymbols.h""; mask - modifier key mask, defined in ""GuiTypes.h"". const Mask_t kKeyShiftMask = BIT(0);; const Mask_t kKeyLockMask = BIT(1);; const Mask_t kKeyControlMask = BIT(2);; const Mask_t kKeyMod1Mask = BIT(3); // typically the Alt key; const Mask_t kButton1Mask = BIT(8);; const Mask_t kButton2Mask = BIT(9);; const Mask_t kButton3Mask = BIT(10);; const Mask_t kButton4Mask = BIT(11);; const Mask_t kButton5Mask = BIT(12);; const Mask_t kAnyModifier = BIT(15);. void ReturnPressed(TGListTreeItem* entry); Emit ReturnPressed() signal. void Checked(TObject* obj, Bool_t check); Emit Checked() signal. void Clicked(TGListTreeItem* entry, Int_t btn); Emit Clicked() signal. void Clicked(TGListTreeItem* entry, Int_t btn, Int_t x, Int_t y); Emit Clicked() signal. void Clicked(TGListTreeItem* entry, Int_t btn, UInt_t mask, Int_t x, Int_t y); Emit Clicked() signal. void DoubleClicked(TGListTreeItem* entry, Int_t btn); Emit DoubleClicked() signal. void DoubleClicked(TGListTreeItem* entry, Int_t btn, Int_t x, Int_t y); Emit DoubleCli",MatchSource.WIKI,root/html528/TGListTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGListTree.html
https://root.cern/root/html528/TGListTree.html:32523,Availability,mask,mask,32523," event. Atom_t HandleDNDPosition(Int_t x, Int_t y, Atom_t action, Int_t xroot, Int_t yroot); Handle dragging position events. Atom_t HandleDNDEnter(Atom_t* typelist); Handle drag enter events. Bool_t HandleDNDLeave(); Handle drag leave events. Bool_t HandleDNDDrop(TDNDData* data); Handle drop events. void DataDropped(TGListTreeItem* item, TDNDData* data); Emit DataDropped() signal. Bool_t HandleMotion(Event_t* event); Handle mouse motion event. Used to set tool tip, to emit; MouseOver() signal and for DND handling. Bool_t HandleKey(Event_t* event); The key press event handler converts a key press to some line editor; action. void MouseOver(TGListTreeItem* entry); Signal emitted when pointer is over entry. void MouseOver(TGListTreeItem* entry, UInt_t mask); Signal emitted when pointer is over entry. void KeyPressed(TGListTreeItem* entry, UInt_t keysym, UInt_t mask); Signal emitted when keyboard key pressed. entry - selected item; keysym - defined in ""KeySymbols.h""; mask - modifier key mask, defined in ""GuiTypes.h"". const Mask_t kKeyShiftMask = BIT(0);; const Mask_t kKeyLockMask = BIT(1);; const Mask_t kKeyControlMask = BIT(2);; const Mask_t kKeyMod1Mask = BIT(3); // typically the Alt key; const Mask_t kButton1Mask = BIT(8);; const Mask_t kButton2Mask = BIT(9);; const Mask_t kButton3Mask = BIT(10);; const Mask_t kButton4Mask = BIT(11);; const Mask_t kButton5Mask = BIT(12);; const Mask_t kAnyModifier = BIT(15);. void ReturnPressed(TGListTreeItem* entry); Emit ReturnPressed() signal. void Checked(TObject* obj, Bool_t check); Emit Checked() signal. void Clicked(TGListTreeItem* entry, Int_t btn); Emit Clicked() signal. void Clicked(TGListTreeItem* entry, Int_t btn, Int_t x, Int_t y); Emit Clicked() signal. void Clicked(TGListTreeItem* entry, Int_t btn, UInt_t mask, Int_t x, Int_t y); Emit Clicked() signal. void DoubleClicked(TGListTreeItem* entry, Int_t btn); Emit DoubleClicked() signal. void DoubleClicked(TGListTreeItem* entry, Int_t btn, Int_t x, Int_t y); Emit DoubleCli",MatchSource.WIKI,root/html528/TGListTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGListTree.html
https://root.cern/root/html528/TGListTree.html:33308,Availability,mask,mask,33308,"d when pointer is over entry. void KeyPressed(TGListTreeItem* entry, UInt_t keysym, UInt_t mask); Signal emitted when keyboard key pressed. entry - selected item; keysym - defined in ""KeySymbols.h""; mask - modifier key mask, defined in ""GuiTypes.h"". const Mask_t kKeyShiftMask = BIT(0);; const Mask_t kKeyLockMask = BIT(1);; const Mask_t kKeyControlMask = BIT(2);; const Mask_t kKeyMod1Mask = BIT(3); // typically the Alt key; const Mask_t kButton1Mask = BIT(8);; const Mask_t kButton2Mask = BIT(9);; const Mask_t kButton3Mask = BIT(10);; const Mask_t kButton4Mask = BIT(11);; const Mask_t kButton5Mask = BIT(12);; const Mask_t kAnyModifier = BIT(15);. void ReturnPressed(TGListTreeItem* entry); Emit ReturnPressed() signal. void Checked(TObject* obj, Bool_t check); Emit Checked() signal. void Clicked(TGListTreeItem* entry, Int_t btn); Emit Clicked() signal. void Clicked(TGListTreeItem* entry, Int_t btn, Int_t x, Int_t y); Emit Clicked() signal. void Clicked(TGListTreeItem* entry, Int_t btn, UInt_t mask, Int_t x, Int_t y); Emit Clicked() signal. void DoubleClicked(TGListTreeItem* entry, Int_t btn); Emit DoubleClicked() signal. void DoubleClicked(TGListTreeItem* entry, Int_t btn, Int_t x, Int_t y); Emit DoubleClicked() signal. void Home(Bool_t select = kFALSE); Move content to the top. void End(Bool_t select = kFALSE); Move content to the bottom. void PageUp(Bool_t select = kFALSE); Move content one page up. void PageDown(Bool_t select = kFALSE); Move content one page down. void LineUp(Bool_t select = kFALSE); Move content one item-size up. void LineDown(Bool_t select = kFALSE); Move content one item-size down. void AdjustPosition(TGListTreeItem* item); Move content to position of item. If item is 0, move to position; of currently selected item. void Search(Bool_t close = kTRUE); Invokes search dialog. Looks for item with the entered name. void DrawRegion(Int_t x, Int_t y, UInt_t w, UInt_t h); Redraw list tree. void Draw(Handle_t id, Int_t yevent, Int_t hevent); Draw list tree",MatchSource.WIKI,root/html528/TGListTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGListTree.html
https://root.cern/root/html528/TGListTree.html:33786,Availability,down,down,33786,"= BIT(8);; const Mask_t kButton2Mask = BIT(9);; const Mask_t kButton3Mask = BIT(10);; const Mask_t kButton4Mask = BIT(11);; const Mask_t kButton5Mask = BIT(12);; const Mask_t kAnyModifier = BIT(15);. void ReturnPressed(TGListTreeItem* entry); Emit ReturnPressed() signal. void Checked(TObject* obj, Bool_t check); Emit Checked() signal. void Clicked(TGListTreeItem* entry, Int_t btn); Emit Clicked() signal. void Clicked(TGListTreeItem* entry, Int_t btn, Int_t x, Int_t y); Emit Clicked() signal. void Clicked(TGListTreeItem* entry, Int_t btn, UInt_t mask, Int_t x, Int_t y); Emit Clicked() signal. void DoubleClicked(TGListTreeItem* entry, Int_t btn); Emit DoubleClicked() signal. void DoubleClicked(TGListTreeItem* entry, Int_t btn, Int_t x, Int_t y); Emit DoubleClicked() signal. void Home(Bool_t select = kFALSE); Move content to the top. void End(Bool_t select = kFALSE); Move content to the bottom. void PageUp(Bool_t select = kFALSE); Move content one page up. void PageDown(Bool_t select = kFALSE); Move content one page down. void LineUp(Bool_t select = kFALSE); Move content one item-size up. void LineDown(Bool_t select = kFALSE); Move content one item-size down. void AdjustPosition(TGListTreeItem* item); Move content to position of item. If item is 0, move to position; of currently selected item. void Search(Bool_t close = kTRUE); Invokes search dialog. Looks for item with the entered name. void DrawRegion(Int_t x, Int_t y, UInt_t w, UInt_t h); Redraw list tree. void Draw(Handle_t id, Int_t yevent, Int_t hevent); Draw list tree widget. Int_t DrawChildren(Handle_t id, TGListTreeItem* item, Int_t x, Int_t y, Int_t xroot); Draw children of item in list tree. void DrawItem(Handle_t id, TGListTreeItem* item, Int_t x, Int_t y, Int_t* xroot, UInt_t* retwidth, UInt_t* retheight); Draw list tree item. void DrawOutline(Handle_t id, TGListTreeItem* item, Pixel_t col = 0xbbbbbb, Bool_t clear = kFALSE); Draw a outline of color 'col' around an item. void DrawActive(Handle_t id, TGListTr",MatchSource.WIKI,root/html528/TGListTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGListTree.html
https://root.cern/root/html528/TGListTree.html:33926,Availability,down,down,33926,"Button5Mask = BIT(12);; const Mask_t kAnyModifier = BIT(15);. void ReturnPressed(TGListTreeItem* entry); Emit ReturnPressed() signal. void Checked(TObject* obj, Bool_t check); Emit Checked() signal. void Clicked(TGListTreeItem* entry, Int_t btn); Emit Clicked() signal. void Clicked(TGListTreeItem* entry, Int_t btn, Int_t x, Int_t y); Emit Clicked() signal. void Clicked(TGListTreeItem* entry, Int_t btn, UInt_t mask, Int_t x, Int_t y); Emit Clicked() signal. void DoubleClicked(TGListTreeItem* entry, Int_t btn); Emit DoubleClicked() signal. void DoubleClicked(TGListTreeItem* entry, Int_t btn, Int_t x, Int_t y); Emit DoubleClicked() signal. void Home(Bool_t select = kFALSE); Move content to the top. void End(Bool_t select = kFALSE); Move content to the bottom. void PageUp(Bool_t select = kFALSE); Move content one page up. void PageDown(Bool_t select = kFALSE); Move content one page down. void LineUp(Bool_t select = kFALSE); Move content one item-size up. void LineDown(Bool_t select = kFALSE); Move content one item-size down. void AdjustPosition(TGListTreeItem* item); Move content to position of item. If item is 0, move to position; of currently selected item. void Search(Bool_t close = kTRUE); Invokes search dialog. Looks for item with the entered name. void DrawRegion(Int_t x, Int_t y, UInt_t w, UInt_t h); Redraw list tree. void Draw(Handle_t id, Int_t yevent, Int_t hevent); Draw list tree widget. Int_t DrawChildren(Handle_t id, TGListTreeItem* item, Int_t x, Int_t y, Int_t xroot); Draw children of item in list tree. void DrawItem(Handle_t id, TGListTreeItem* item, Int_t x, Int_t y, Int_t* xroot, UInt_t* retwidth, UInt_t* retheight); Draw list tree item. void DrawOutline(Handle_t id, TGListTreeItem* item, Pixel_t col = 0xbbbbbb, Bool_t clear = kFALSE); Draw a outline of color 'col' around an item. void DrawActive(Handle_t id, TGListTreeItem* item); Draw active item with its active color. void DrawItemName(Handle_t id, TGListTreeItem* item); Draw name of list tree item.",MatchSource.WIKI,root/html528/TGListTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGListTree.html
https://root.cern/root/html528/TGListTree.html:37054,Availability,down,downwards,37054," findy. void AddItem(TGListTreeItem* parent, TGListTreeItem* item); Add given item to list tree. TGListTreeItem * AddItem(TGListTreeItem* parent, const char* string, const TGPicture* open = 0, const TGPicture* closed = 0, Bool_t checkbox = kFALSE); Add item to list tree. Returns new item. TGListTreeItem * AddItem(TGListTreeItem* parent, const char* string, void* userData, const TGPicture* open = 0, const TGPicture* closed = 0, Bool_t checkbox = kFALSE); Add item to list tree. If item with same userData already exists; don't add it. Returns new item. void RenameItem(TGListTreeItem* item, const char* string); Rename item in list tree. Int_t DeleteItem(TGListTreeItem* item); Delete item from list tree. void OpenItem(TGListTreeItem* item); Open item in list tree (i.e. show child items). void CloseItem(TGListTreeItem* item); Close item in list tree (i.e. hide child items). Int_t RecursiveDeleteItem(TGListTreeItem* item, void* userData); Delete item with fUserData == ptr. Search tree downwards starting; at item. void SetToolTipItem(TGListTreeItem* item, const char* string); Set tooltip text for this item. By default an item for which the; userData is a pointer to an TObject the TObject::GetTitle() will; be used to get the tip text. Int_t DeleteChildren(TGListTreeItem* item); Delete children of item from list. Int_t Reparent(TGListTreeItem* item, TGListTreeItem* newparent); Make newparent the new parent of item. Int_t ReparentChildren(TGListTreeItem* item, TGListTreeItem* newparent); Make newparent the new parent of the children of item. Int_t Sort(TGListTreeItem* item); Sort items starting with item. Int_t SortSiblings(TGListTreeItem* item); Sort siblings of item. Int_t SortChildren(TGListTreeItem* item); Sort children of item. TGListTreeItem * FindSiblingByName(TGListTreeItem* item, const char* name); Find sibling of item by name. TGListTreeItem * FindSiblingByData(TGListTreeItem* item, void* userData); Find sibling of item by userData. TGListTreeItem * FindChildByName(TG",MatchSource.WIKI,root/html528/TGListTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGListTree.html
https://root.cern/root/html528/TGListTree.html:40251,Availability,down,downwards,40251,"turns the icon used by items in closed state. const TGPicture * GetCheckedPic(); Returns the icon used for checked checkbox. const TGPicture * GetUncheckedPic(); Returns the icon used for unchecked checkbox. void SavePrimitive(ostream& out, Option_t* option = """"); Save a list tree widget as a C++ statements on output stream out. void SaveChildren(ostream& out, TGListTreeItem* item, Int_t& n); Save child items as a C++ statements on output stream out. void CheckItem(TGListTreeItem* item, Bool_t check = kTRUE); Set check button state for the node 'item'. void SetCheckBox(TGListTreeItem* item, Bool_t on = kTRUE); Set check button state for the node 'item'. void ToggleItem(TGListTreeItem* item); Toggle check button state of the node 'item'. void UpdateChecked(TGListTreeItem* item, Bool_t redraw = kFALSE); Update the state of the node 'item' according to the children states. TGListTreeItem * FindItemByObj(TGListTreeItem* item, void* ptr); Find item with fUserData == ptr. Search tree downwards starting; at item. void GetChecked(TList* checked); Add all checked list tree items of this list tree into; the list 'checked'. This list is not adopted and must; be deleted by the user later. void GetCheckedChildren(TList* checked, TGListTreeItem* item); Add all child items of 'item' into the list 'checked'. void CheckAllChildren(TGListTreeItem* item, Bool_t state); Check all child items of 'item' and 'item' itself according; to the state value: kTRUE means check all, kFALSE - uncheck all. TGListTreeItem& operator=(const TGListTree& ). void Draw(Handle_t id, Int_t yevent, Int_t hevent). TGListTreeItem * FindItem(Int_t findy). void Layout(); {}. void OnMouseOver(TGFrame* ); { }. void CurrentChanged(Int_t , Int_t ); { }. void CurrentChanged(TGFrame* ); { }. void ReturnPressed(TGFrame* ); { }. void Clicked(TGFrame* , Int_t ); { }. void Clicked(TGFrame* , Int_t , Int_t , Int_t ); { }. void DoubleClicked(TGFrame* , Int_t ); { }. void DoubleClicked(TGFrame* , Int_t , Int_t , Int_t ); { }.",MatchSource.WIKI,root/html528/TGListTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGListTree.html
https://root.cern/root/html528/TGListTree.html:27872,Integrability,message,messages,27872,t search; Bool_tTGContainer::fLastDirdirection of last search; UInt_tfLastEventStatemodifier state of the last keyboard event; TStringTGContainer::fLastNamethe name of object of last search; Bool_tTGContainer::fLastSubstringsubstring search option of last search; Bool_tTGCompositeFrame::fLayoutBrokenno layout manager is used; TGLayoutManager*TGCompositeFrame::fLayoutManagerlayout manager; GContext_tfLineGCdashed line drawing context; TList*TGCompositeFrame::fListcontainer of frame elements; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Bool_tTGCompositeFrame::fMapSubwindowskTRUE - map subwindows; Int_tfMarginnumber of pixels margin from left side; UInt_tTGFrame::fMaxHeightmaximal frame height; UInt_tTGFrame::fMaxWidthmaximal frame width; UInt_tTGFrame::fMinHeightminimal frame height; UInt_tTGFrame::fMinWidthminimal frame width; const TGWindow*TGContainer::fMsgWindowwindow handling container messages; Int_tTGCompositeFrame::fMustCleanupcleanup mode (see EFrameCleanup); TStringTGWindow::fNamename of the window used in SavePrimitive(); Bool_tTGWindow::fNeedRedrawkTRUE if window needs to be redrawn; Bool_tTGContainer::fOnMouseOverkTRUE when mouse pointer is over entry; UInt_tTGFrame::fOptionsframe options; const TGWindow*TGWindow::fParentParent window; TTimer*TGContainer::fScrollTimerautoscroll timer; Bool_tTGContainer::fScrollingkTRUE - when scrolling is ON; TGListTreeItem*fSelectedpointer to selected item in list; Int_tTGContainer::fSelectednumber of selected items; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; TGToolTip*fTiptooltip shown when moving over list items; TGListTreeItem*fTipItemitem for which tooltip is set; Int_tTGContainer::fTotaltotal items; Bool_tfUserControlledlet user decides what is the behaviour on events; TGViewPort*TGContainer::fViewPortcontainer viewport; Int_tfVspacingvertical spacing between items; UInt_tTGFrame::fWidthframe widt,MatchSource.WIKI,root/html528/TGListTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGListTree.html
https://root.cern/root/html528/TGListTree.html:5050,Usability,clear,clear,5050,"::DestroyWindow(); voidDisableOpen(Bool_t disable = kTRUE); Bool_tTQObject::Disconnect(const char* signal = 0, void* receiver = 0, const char* slot = 0); static Bool_tTQObject::Disconnect(TQObject* sender, const char* signal = 0, void* receiver = 0, const char* slot = 0); static Bool_tTQObject::Disconnect(const char* class_name, const char* signal, void* receiver = 0, const char* slot = 0); virtual voidTQObject::Disconnected(const char*); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDoubleClicked(TGListTreeItem* entry, Int_t btn)SIGNAL ; virtual voidDoubleClicked(TGListTreeItem* entry, Int_t btn, Int_t x, Int_t y)SIGNAL ; virtual voidDrawActive(Handle_t id, TGListTreeItem* item); virtual voidTGFrame::DrawBorder(); virtual voidTGFrame::DrawClass() const; virtual TObject*TGFrame::DrawClone(Option_t* = """") const; virtual voidTGFrame::DrawCopy(Handle_t, Int_t, Int_t); virtual voidDrawOutline(Handle_t id, TGListTreeItem* item, Pixel_t col = 0xbbbbbb, Bool_t clear = kFALSE); virtual voidDrawRegion(Int_t x, Int_t y, UInt_t w, UInt_t h); virtual voidTGFrame::Dump() const; voidTQObject::Emit(const char* signal); voidTQObject::Emit(const char* signal, Long_t* paramArr); voidTQObject::Emit(const char* signal, const char* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::Emi",MatchSource.WIKI,root/html528/TGListTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGListTree.html
https://root.cern/root/html528/TGListTree.html:34658,Usability,clear,clear,34658,"to the bottom. void PageUp(Bool_t select = kFALSE); Move content one page up. void PageDown(Bool_t select = kFALSE); Move content one page down. void LineUp(Bool_t select = kFALSE); Move content one item-size up. void LineDown(Bool_t select = kFALSE); Move content one item-size down. void AdjustPosition(TGListTreeItem* item); Move content to position of item. If item is 0, move to position; of currently selected item. void Search(Bool_t close = kTRUE); Invokes search dialog. Looks for item with the entered name. void DrawRegion(Int_t x, Int_t y, UInt_t w, UInt_t h); Redraw list tree. void Draw(Handle_t id, Int_t yevent, Int_t hevent); Draw list tree widget. Int_t DrawChildren(Handle_t id, TGListTreeItem* item, Int_t x, Int_t y, Int_t xroot); Draw children of item in list tree. void DrawItem(Handle_t id, TGListTreeItem* item, Int_t x, Int_t y, Int_t* xroot, UInt_t* retwidth, UInt_t* retheight); Draw list tree item. void DrawOutline(Handle_t id, TGListTreeItem* item, Pixel_t col = 0xbbbbbb, Bool_t clear = kFALSE); Draw a outline of color 'col' around an item. void DrawActive(Handle_t id, TGListTreeItem* item); Draw active item with its active color. void DrawItemName(Handle_t id, TGListTreeItem* item); Draw name of list tree item. void DrawNode(Handle_t id, TGListTreeItem* item, Int_t x, Int_t y); Draw node (little + in box). void SetToolTipText(const char* text, Int_t x, Int_t y, Long_t delayms); Set tool tip text associated with this item. The delay is in; milliseconds (minimum 250). To remove tool tip call method with; delayms = 0. To change delayms you first have to call this method; with delayms=0. void RemoveReference(TGListTreeItem* item); This function removes the specified item from the linked list.; It does not do anything with the data contained in the item, though. void PDeleteItem(TGListTreeItem* item); Delete given item. Takes care of list-tree state members; fSelected, fCurrent and fBelowMouse. void PDeleteChildren(TGListTreeItem* item); Recursively del",MatchSource.WIKI,root/html528/TGListTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGListTree.html
https://root.cern/root/html528/TGListTreeItem.html:890,Availability,avail,available,890,". TGListTreeItem. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGListTreeItem. class TGListTreeItem. TGListTree and TGListTreeItem. A list tree is a widget that can contain a number of items; arranged in a tree structure. The items are represented by small; folder icons that can be either open or closed. The TGListTree is user callable. The TGListTreeItem is a service; class of the list tree. A list tree can generate the following events:; kC_LISTTREE, kCT_ITEMCLICK, which button, location (y<<16|x).; kC_LISTTREE, kCT_ITEMDBLCLICK, which button, location (y<<16|x). Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TGListTreeItem(); virtual voidCheckAllChildren(Bool_t = kTRUE); virtual voidCheckChildren(TGListTreeItem*, Bool_t); virtual voidCheckItem(Bool_t = kTRUE); static TClass*Class(); virtual voidClearColor(); virtual Pixel_tGetActiveColor() const; virtual const TGPicture*GetCheckBoxPicture() const; virtual Color_tGetColor() const; TGListTreeItem*GetFirstChild() const; TGListTreeItem*GetLastChild() const; TGListTreeItem*GetNextSibling() const; TGListTreeItem*GetParent() const; virtual const TGPicture*GetPicture() const; virtual UInt_tGetPicWidth() const; TGListTreeItem*GetPrevSibling() const; virtual const char*GetText() const; virtual Int_tGetTextLength() const; virtual const char*GetTipText() const; virtual Int_tGetTipTextLength() const; virtual void*GetUserData() const; virtual voidHandleDrag(); virtual voidHandleDrop(); virtual Bool_tHandlesDragAndDrop() const; virtual Bool_tHasCheckBox() const; virtual Bool_tHasCheckedChild(Bool_t = kFALSE); virtual Bool_tHasColor() const; virtual Bool_tHasUnCheckedChild(Bool_t = kFALSE); virtual TClass*IsA() const; virt",MatchSource.WIKI,root/html528/TGListTreeItem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGListTreeItem.html
https://root.cern/root/html528/TGListView.html:4887,Availability,error,error,4887,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; TGFrame*TGCanvas::GetContainer() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCanvas::GetDefaultSize() const; virtual UInt_tTGFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGF",MatchSource.WIKI,root/html528/TGListView.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGListView.html
https://root.cern/root/html528/TGListView.html:4971,Availability,error,error,4971,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; TGFrame*TGCanvas::GetContainer() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCanvas::GetDefaultSize() const; virtual UInt_tTGFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType() const; virtual Option_t*TObject::GetDrawOption() const; virtual ",MatchSource.WIKI,root/html528/TGListView.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGListView.html
https://root.cern/root/html528/TGListView.html:17384,Availability,mask,mask,17384,,MatchSource.WIKI,root/html528/TGListView.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGListView.html
https://root.cern/root/html528/TGListView.html:21596,Integrability,message,messages,21596,"xt and cmode is the x text; alignmode for the item text. const char * GetHeader(Int_t idx) const; Returns name of header idx. If illegal idx or header not set for idx; 0 is returned. void SetDefaultHeaders(); Default headers are: Name, Attributes, Size, Owner, Group, Modified.; The default is good for file system items. void SetViewMode(EListViewMode viewMode); Set list view mode. void SetContainer(TGFrame* f); Set list view container. Container must be at least of type; TGLVContainer. void SetIncrements(Int_t hInc, Int_t vInc); Set horizontal and vertical scrollbar increments. void SetDefaultColumnWidth(TGVFileSplitter* splitter); Set default column width of the columns headers. void ResizeColumns(); Resize column headers to show whole item names. void Layout(); Layout list view components (container and contents of container). void LayoutHeader(TGFrame* head); Layout list view components (container and contents of container). Bool_t ProcessMessage(Long_t msg, Long_t parm1, Long_t parm2); Handle messages generated by the list view components. void Clicked(TGLVEntry* entry, Int_t btn); Emit Clicked() signal. void Clicked(TGLVEntry* entry, Int_t btn, Int_t x, Int_t y); Emit Clicked() signal. void DoubleClicked(TGLVEntry* entry, Int_t btn); Emit DoubleClicked() signal. void DoubleClicked(TGLVEntry* entry, Int_t btn, Int_t x, Int_t y); Emit DoubleClicked() signal. FontStruct_t GetDefaultFontStruct(); Return the default font structure in use. const TGGC & GetDefaultGC(); Return the default graphics context in use. void SavePrimitive(ostream& out, Option_t* option = """"); Save a list view widget as a C++ statement(s) on output stream out. TGLVEntry& operator=(const TGListView& ). EListViewMode GetViewMode() const; { return fViewMode; }. TGListView(const TGListView& ). void AdjustHeaders(); { fJustChanged = kTRUE; LayoutHeader(0); }. TGTextButton** GetHeaderButtons(); { return fColHeader; }. UInt_t GetNumColumns(); { return fNColumns; }. TGDimension GetMaxItemSize() const;",MatchSource.WIKI,root/html528/TGListView.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGListView.html
https://root.cern/root/html528/TGLLegoPainter.html:4804,Modifiability,variab,variables,4804," pair<double,double>fMinMaxValFor texture coordinates generation.; Double_tfMinZ; TGLLevelPalettefPalette; TGLQuadricfQuadric; vector<Rgl::Range_t>fXEdges; vector<Rgl::Range_t>fYEdges. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLLegoPainter(TH1* hist, TGLPlotCamera* camera, TGLPlotCoordinates* coord); Ctor. char * GetPlotInfo(Int_t px, Int_t py); Obtain bin's info (i, j, value). Bool_t InitGeometry(); Select method. Bool_t InitGeometryCartesian(); Geometry for lego in cartesian coords. Bool_t InitGeometryPolar(); Geometry for lego in polar coords. Bool_t InitGeometryCylindrical(); Geometry for lego in cylindrical coords. Bool_t InitGeometrySpherical(); Geometry for lego in spherical coords. void StartPan(Int_t px, Int_t py); User clicks on a lego with middle mouse button (middle for pad). void Pan(Int_t px, Int_t py); Move lego or section. void AddOption(const TString& stringOption); Parse additional options. void InitGL() const; Initialize some gl state variables. void DeInitGL() const; Return some gl states to original values. void DrawPlot() const; Select method corresponding to coordinate system. void DrawLegoCartesian() const; Lego in cartesian system. void DrawLegoPolar() const; Lego in polar system. void DrawLegoCylindrical() const; Lego in cylindrical system. void DrawLegoSpherical() const; Lego in spherical system. void SetLegoColor() const; Set lego's color. void DrawSectionXOZ() const; XOZ plane parallel section. void DrawSectionYOZ() const; YOZ plane parallel section. void DrawSectionXOY() const; Empty. No such sections for lego. void ProcessEvent(Int_t event, Int_t px, Int_t py); Remove all sections and repaint. Bool_t ClampZ(Double_t& zVal) const; Clamp z value. Bool_t PreparePalette() const; Initialize color palette. void DrawPalette() const; Draw. Palette.; Originally, fCamera was never null.; It can be a null now because of gl-viewer. void DrawPaletteAxis() const; Draw. Palette. Axis. TGLLegoPainter(c",MatchSource.WIKI,root/html528/TGLLegoPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLLegoPainter.html
https://root.cern/root/html528/TGLLightSet.html:1335,Availability,error,error,1335," TGLLightSet(); virtual~TGLLightSet(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Float_tGetFrontPower() const; virtual const char*TObject::GetIconName() const; UInt_tGetLightState(); virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static B",MatchSource.WIKI,root/html528/TGLLightSet.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLLightSet.html
https://root.cern/root/html528/TGLLightSet.html:1419,Availability,error,error,1419," voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Float_tGetFrontPower() const; virtual const char*TObject::GetIconName() const; UInt_tGetLightState(); virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Float_tGetSidePower() const; Float_tGetSpecularPower() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; Bool_tGetUseSpecular() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; v",MatchSource.WIKI,root/html528/TGLLightSet.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLLightSet.html
https://root.cern/root/html528/TGLLightSet.html:5723,Availability,mask,mask,5723,"::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). private:. TGLLightSet(const TGLLightSet&); TGLLightSet&operator=(const TGLLightSet&). Data Members; public:. enum ELight { kLightFront; kLightTop; kLightBottom; kLightLeft; kLightRight; kLightMask; kLightSpecular; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Float_tfFrontPower! power of the front lamp; UInt_tfLightState! light states (on/off) mask; Float_tfSidePower! power of the side lamps; Float_tfSpecularPower! power of specular lamp; Bool_tfUseSpecular!. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLLightSet(); Constructor. void ToggleLight(TGLLightSet::ELight light); Toggle light on/off. void SetLight(TGLLightSet::ELight light, Bool_t on); Set a light on/off. void StdSetupLights(const TGLBoundingBox& bbox, const TGLCamera& camera, Bool_t debug = kFALSE); Setup lights for current given bounding box and camera.; This is called by standard GL viewer.; Expects matrix-mode to be model-view. TGLLightSet(const TGLLightSet& ). TGLLightSet& operator=(const TGLLightSet& ). virtual ~TGLLightSet(); {}. UInt_t GetLightState(); { return fLightState; }. Bool_t GetUseSpecular() const; { return fUseSpecular; }. void SetUseSpecular(Bool_t s); { fUseSpecular = s; }. Float_t GetFrontPower() const; { return fFrontPower; }. Float_t GetSidePower() const; { return fSidePower; }. Float_t GetSpecularPower() cons",MatchSource.WIKI,root/html528/TGLLightSet.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLLightSet.html
https://root.cern/root/html528/TGLLightSet.html:5657,Energy Efficiency,power,power,5657,"::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). private:. TGLLightSet(const TGLLightSet&); TGLLightSet&operator=(const TGLLightSet&). Data Members; public:. enum ELight { kLightFront; kLightTop; kLightBottom; kLightLeft; kLightRight; kLightMask; kLightSpecular; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Float_tfFrontPower! power of the front lamp; UInt_tfLightState! light states (on/off) mask; Float_tfSidePower! power of the side lamps; Float_tfSpecularPower! power of specular lamp; Bool_tfUseSpecular!. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLLightSet(); Constructor. void ToggleLight(TGLLightSet::ELight light); Toggle light on/off. void SetLight(TGLLightSet::ELight light, Bool_t on); Set a light on/off. void StdSetupLights(const TGLBoundingBox& bbox, const TGLCamera& camera, Bool_t debug = kFALSE); Setup lights for current given bounding box and camera.; This is called by standard GL viewer.; Expects matrix-mode to be model-view. TGLLightSet(const TGLLightSet& ). TGLLightSet& operator=(const TGLLightSet& ). virtual ~TGLLightSet(); {}. UInt_t GetLightState(); { return fLightState; }. Bool_t GetUseSpecular() const; { return fUseSpecular; }. void SetUseSpecular(Bool_t s); { fUseSpecular = s; }. Float_t GetFrontPower() const; { return fFrontPower; }. Float_t GetSidePower() const; { return fSidePower; }. Float_t GetSpecularPower() cons",MatchSource.WIKI,root/html528/TGLLightSet.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLLightSet.html
https://root.cern/root/html528/TGLLightSet.html:5748,Energy Efficiency,power,power,5748,"::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). private:. TGLLightSet(const TGLLightSet&); TGLLightSet&operator=(const TGLLightSet&). Data Members; public:. enum ELight { kLightFront; kLightTop; kLightBottom; kLightLeft; kLightRight; kLightMask; kLightSpecular; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Float_tfFrontPower! power of the front lamp; UInt_tfLightState! light states (on/off) mask; Float_tfSidePower! power of the side lamps; Float_tfSpecularPower! power of specular lamp; Bool_tfUseSpecular!. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLLightSet(); Constructor. void ToggleLight(TGLLightSet::ELight light); Toggle light on/off. void SetLight(TGLLightSet::ELight light, Bool_t on); Set a light on/off. void StdSetupLights(const TGLBoundingBox& bbox, const TGLCamera& camera, Bool_t debug = kFALSE); Setup lights for current given bounding box and camera.; This is called by standard GL viewer.; Expects matrix-mode to be model-view. TGLLightSet(const TGLLightSet& ). TGLLightSet& operator=(const TGLLightSet& ). virtual ~TGLLightSet(); {}. UInt_t GetLightState(); { return fLightState; }. Bool_t GetUseSpecular() const; { return fUseSpecular; }. void SetUseSpecular(Bool_t s); { fUseSpecular = s; }. Float_t GetFrontPower() const; { return fFrontPower; }. Float_t GetSidePower() const; { return fSidePower; }. Float_t GetSpecularPower() cons",MatchSource.WIKI,root/html528/TGLLightSet.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLLightSet.html
https://root.cern/root/html528/TGLLightSet.html:5796,Energy Efficiency,power,power,5796,"::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). private:. TGLLightSet(const TGLLightSet&); TGLLightSet&operator=(const TGLLightSet&). Data Members; public:. enum ELight { kLightFront; kLightTop; kLightBottom; kLightLeft; kLightRight; kLightMask; kLightSpecular; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Float_tfFrontPower! power of the front lamp; UInt_tfLightState! light states (on/off) mask; Float_tfSidePower! power of the side lamps; Float_tfSpecularPower! power of specular lamp; Bool_tfUseSpecular!. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLLightSet(); Constructor. void ToggleLight(TGLLightSet::ELight light); Toggle light on/off. void SetLight(TGLLightSet::ELight light, Bool_t on); Set a light on/off. void StdSetupLights(const TGLBoundingBox& bbox, const TGLCamera& camera, Bool_t debug = kFALSE); Setup lights for current given bounding box and camera.; This is called by standard GL viewer.; Expects matrix-mode to be model-view. TGLLightSet(const TGLLightSet& ). TGLLightSet& operator=(const TGLLightSet& ). virtual ~TGLLightSet(); {}. UInt_t GetLightState(); { return fLightState; }. Bool_t GetUseSpecular() const; { return fUseSpecular; }. void SetUseSpecular(Bool_t s); { fUseSpecular = s; }. Float_t GetFrontPower() const; { return fFrontPower; }. Float_t GetSidePower() const; { return fSidePower; }. Float_t GetSpecularPower() cons",MatchSource.WIKI,root/html528/TGLLightSet.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLLightSet.html
https://root.cern/root/html528/TGLLightSetEditor.html:4490,Availability,error,error,4490,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const;",MatchSource.WIKI,root/html528/TGLLightSetEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLLightSetEditor.html
https://root.cern/root/html528/TGLLightSetEditor.html:4574,Availability,error,error,4574,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType() c",MatchSource.WIKI,root/html528/TGLLightSetEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLLightSetEditor.html
https://root.cern/root/html528/TGLLightSetEditor.html:17278,Availability,mask,mask,17278,,MatchSource.WIKI,root/html528/TGLLightSetEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLLightSetEditor.html
https://root.cern/root/html528/TGLLightSetSubEditor.html:4188,Availability,error,error,4188,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const;",MatchSource.WIKI,root/html528/TGLLightSetSubEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLLightSetSubEditor.html
https://root.cern/root/html528/TGLLightSetSubEditor.html:4272,Availability,error,error,4272,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType() c",MatchSource.WIKI,root/html528/TGLLightSetSubEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLLightSetSubEditor.html
https://root.cern/root/html528/TGLLightSetSubEditor.html:16651,Availability,mask,mask,16651,,MatchSource.WIKI,root/html528/TGLLightSetSubEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLLightSetSubEditor.html
https://root.cern/root/html528/TGLLine3.html:387,Integrability,wrap,wraps,387,". TGLLine3. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLLine3. class TGLLine3. TGLLine3. 3D space, fixed length, line class, with direction / length 'vector',; passing through point 'vertex'. Just wraps a TGLVector3 / TGLVertex3; pair. Function Members (Methods); public:. TGLLine3(const TGLLine3&); TGLLine3(const TGLVertex3& start, const TGLVertex3& end); TGLLine3(const TGLVertex3& start, const TGLVector3& vector); virtual~TGLLine3(); static TClass*Class(); voidDraw() const; const TGLVertex3End() const; virtual TClass*IsA() const; TGLLine3&operator=(const TGLLine3&); voidSet(const TGLVertex3& start, const TGLVertex3& end); voidSet(const TGLVertex3& start, const TGLVector3& vector); virtual voidShowMembers(TMemberInspector& insp); const TGLVertex3&Start() const; virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); const TGLVector3&Vector() const. Data Members; private:. TGLVector3fVector! Vector of line from fVertex; TGLVertex3fVertex! Start vertex of line. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLLine3(const TGLVertex3& start, const TGLVertex3& end); Construct 3D line running from 'start' to 'end'. TGLLine3(const TGLVertex3& start, const TGLVector3& vector); Construct 3D line running from 'start', magnitude 'vect'. ~TGLLine3(); Destroy 3D line object. void Set(const TGLVertex3& start, const TGLVertex3& end); Set 3D line running from 'start' to 'end'. void Set(const TGLVertex3& start, const TGLVector3& vector); Set 3D line running from start, magnitude 'vect'. void Draw() const; Draw line in current basic GL color. Assume we are in the correct reference; frame. TGLLine3(const TGLVertex3& start, const TGLVertex3& end). const TGLVertex3 & Start() const; Bitwise copy constructor and = operator are fine; Accessors. { r",MatchSource.WIKI,root/html528/TGLLine3.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLLine3.html
https://root.cern/root/html528/TGLLockable.html:1560,Availability,failure,failure,1560,"l_tIsDrawOrSelectLock() const; Bool_tIsLocked() const; virtual const char*LockIdStr() const; static const char*LockName(TGLLockable::ELock lock); static Bool_tLockValid(TGLLockable::ELock lock); Bool_tReleaseLock(TGLLockable::ELock lock) const; virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); Bool_tTakeLock(TGLLockable::ELock lock) const. private:. TGLLockable(const TGLLockable&); TGLLockable&operator=(const TGLLockable&). Data Members; public:. enum ELock { kUnlocked; kDrawLock; kSelectLock; kModifyLock; };. protected:. TGLLockable::ELockfLockLock state. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLLockable(); Constructor. Bool_t TakeLock(TGLLockable::ELock lock) const; Lock the object in mode 'lock'. Return TRUE if successful, FALSE; if the object is already locked. Bool_t ReleaseLock(TGLLockable::ELock lock) const; Release current lock, make sure it the same as the 'lock' argument.; Returns TRUE on success, FALSE on failure. const char* LockName(TGLLockable::ELock lock); Return name-string for given lock-type. Bool_t LockValid(TGLLockable::ELock lock); Test if lock is a valid type to take/release.; kUnlocked is never valid in these cases. TGLLockable(const TGLLockable& ). TGLLockable& operator=(const TGLLockable& ). virtual ~TGLLockable(); {}. const char* LockIdStr() const; { return ""<unknown>""; }. Bool_t IsLocked() const; { return (fLock != kUnlocked); }. ELock CurrentLock() const; { return fLock; }. Bool_t IsDrawOrSelectLock() const; { return fLock == kDrawLock || fLock == kSelectLock; }. » Author: Matevz Tadel, Feb 2007 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/gl:$Id: TGLLockable.h 32465 2010-03-04 20:29:52Z matevz $ » Last generated: 2010-09-23 20:06; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html528/TGLLockable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLLockable.html
https://root.cern/root/html528/TGLLockable.html:1736,Deployability,release,release,1736,"l_tIsDrawOrSelectLock() const; Bool_tIsLocked() const; virtual const char*LockIdStr() const; static const char*LockName(TGLLockable::ELock lock); static Bool_tLockValid(TGLLockable::ELock lock); Bool_tReleaseLock(TGLLockable::ELock lock) const; virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); Bool_tTakeLock(TGLLockable::ELock lock) const. private:. TGLLockable(const TGLLockable&); TGLLockable&operator=(const TGLLockable&). Data Members; public:. enum ELock { kUnlocked; kDrawLock; kSelectLock; kModifyLock; };. protected:. TGLLockable::ELockfLockLock state. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLLockable(); Constructor. Bool_t TakeLock(TGLLockable::ELock lock) const; Lock the object in mode 'lock'. Return TRUE if successful, FALSE; if the object is already locked. Bool_t ReleaseLock(TGLLockable::ELock lock) const; Release current lock, make sure it the same as the 'lock' argument.; Returns TRUE on success, FALSE on failure. const char* LockName(TGLLockable::ELock lock); Return name-string for given lock-type. Bool_t LockValid(TGLLockable::ELock lock); Test if lock is a valid type to take/release.; kUnlocked is never valid in these cases. TGLLockable(const TGLLockable& ). TGLLockable& operator=(const TGLLockable& ). virtual ~TGLLockable(); {}. const char* LockIdStr() const; { return ""<unknown>""; }. Bool_t IsLocked() const; { return (fLock != kUnlocked); }. ELock CurrentLock() const; { return fLock; }. Bool_t IsDrawOrSelectLock() const; { return fLock == kDrawLock || fLock == kSelectLock; }. » Author: Matevz Tadel, Feb 2007 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/gl:$Id: TGLLockable.h 32465 2010-03-04 20:29:52Z matevz $ » Last generated: 2010-09-23 20:06; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html528/TGLLockable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLLockable.html
https://root.cern/root/html528/TGLLockable.html:306,Integrability,interface,interface,306,". TGLLockable. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLLockable. class TGLLockable. TGLLockable. Simple locking interface used by viewer and scene. Function Members (Methods); public:. TGLLockable(); virtual~TGLLockable(); static TClass*Class(); TGLLockable::ELockCurrentLock() const; virtual TClass*IsA() const; Bool_tIsDrawOrSelectLock() const; Bool_tIsLocked() const; virtual const char*LockIdStr() const; static const char*LockName(TGLLockable::ELock lock); static Bool_tLockValid(TGLLockable::ELock lock); Bool_tReleaseLock(TGLLockable::ELock lock) const; virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); Bool_tTakeLock(TGLLockable::ELock lock) const. private:. TGLLockable(const TGLLockable&); TGLLockable&operator=(const TGLLockable&). Data Members; public:. enum ELock { kUnlocked; kDrawLock; kSelectLock; kModifyLock; };. protected:. TGLLockable::ELockfLockLock state. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLLockable(); Constructor. Bool_t TakeLock(TGLLockable::ELock lock) const; Lock the object in mode 'lock'. Return TRUE if successful, FALSE; if the object is already locked. Bool_t ReleaseLock(TGLLockable::ELock lock) const; Release current lock, make sure it the same as the 'lock' argument.; Returns TRUE on success, FALSE on failure. const char* LockName(TGLLockable::ELock lock); Return name-string for given lock-type. Bool_t LockValid(TGLLockable::ELock lock); Test if lock is a valid type to take/release.; kUnlocked is never valid in these cases. TGLLockable(const TGLLockable& ). TGLLockable& operator=(const TGLLockable& ). virtual ~TGLLockable(); {}. const char* LockIdStr() const; { return ""<unknown>""; }. Bool_t IsLocked() const; { return (fLock != kUnlock",MatchSource.WIKI,root/html528/TGLLockable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLLockable.html
https://root.cern/root/html528/TGLLogicalShape.html:2197,Availability,avail,available,2197,"al shapes which are using it. Display list information is also stored here, possibly per LOD; level. Most classes does not support LOD (only sphere and tube) and; therefore reasonable defaults are encoded in the following virtual; functions:. * ELODAxes SupportedLODAxes() { return kLODAxesNone; }; * Int_t DLCacheSize() { return 1; }; * UInt_t DLOffset(lod); // Transform lod into DL offset.; * Short_t QuantizeShapeLOD(); // Quantize lod. Classes that have per-LOD display-lists than override these functions.; 'UShort_t fDLValid' is used as a bit-field determining validity of; each quantized LOD-level; hopefully one will not have more than 16; LOD levels per class.; See also: TGLPhysicalShape::CalculateShapeLOD() where LOD is calculated. See base/src/TVirtualViewer3D for description of common external 3D; viewer architecture and how external viewer clients use it. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TGLLogicalShape(); voidAddRef(TGLPhysicalShape* phys) const; virtual Bool_tAlwaysSecondarySelect() const; const TGLBoundingBox&BoundingBox() const; static TClass*Class(); voidDestroyPhysicals(); virtual voidDirectDraw(TGLRnrCtx& rnrCtx) const; virtual voidDLCacheClear(); virtual voidDLCacheDrop(); virtual voidDLCachePurge(); virtual UInt_tDLOffset(Short_t) const; virtual voidDraw(TGLRnrCtx& rnrCtx) const; virtual voidDrawHighlight(TGLRnrCtx& rnrCtx, const TGLPhysicalShape* pshp, Int_t lvl = -1) const; TObject*GetExternal() const; const TGLPhysicalShape*GetFirstPhysical() const; TGLScene*GetScene() const; TObject*ID() const; virtual Bool_tIgnoreSizeForOfInterest() const; voidInvokeContextMenu(TContextMenu& menu, UInt_t x, UInt_t y) const; virtual TClass*IsA() const; virtual Bool_tKeepDuringSmartRefresh() const; virtual voidProcessSelection(TGLRnrCtx& rnrCtx, TGLSelectRecord& rec); virtual Short_tQuantizeShapeLOD(Short_t shapeLOD, Short_t ",MatchSource.WIKI,root/html528/TGLLogicalShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLLogicalShape.html
https://root.cern/root/html528/TGLLogicalShape.html:985,Energy Efficiency,reduce,reduces,985,":; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLLogicalShape. class TGLLogicalShape. Abstract logical shape - a GL 'drawable' - base for all shapes -; faceset sphere etc. Logical shapes are a unique piece of geometry,; described in it's local frame - e.g if we have three spheres in :; Sphere A - Radius r1, center v1; Sphere B - Radius r2, center v2; Sphere C - Radius r1, center v3. Spheres A and C can share a common logical sphere of radius r1 - and; place them with two physicals with translations of v1 & v2. Sphere B; requires a different logical (radius r2), placed with physical with; translation v2. Physical shapes know about and can share logicals. Logicals do not; about (aside from reference counting) physicals or share them. This sharing of logical shapes greatly reduces memory consumption and; scene (re)build times in typical detector geometries which have many; repeated objects placements. TGLLogicalShapes have reference counting, performed by the client; physical shapes which are using it. Display list information is also stored here, possibly per LOD; level. Most classes does not support LOD (only sphere and tube) and; therefore reasonable defaults are encoded in the following virtual; functions:. * ELODAxes SupportedLODAxes() { return kLODAxesNone; }; * Int_t DLCacheSize() { return 1; }; * UInt_t DLOffset(lod); // Transform lod into DL offset.; * Short_t QuantizeShapeLOD(); // Quantize lod. Classes that have per-LOD display-lists than override these functions.; 'UShort_t fDLValid' is used as a bit-field determining validity of; each quantized LOD-level; hopefully one will not have more than 16; LOD levels per class.; See also: TGLPhysicalShape::CalculateShapeLOD() where LOD is calculated. See base/src/TVirtualViewer3D for description of common external 3D; viewer architecture and how",MatchSource.WIKI,root/html528/TGLLogicalShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLLogicalShape.html
https://root.cern/root/html528/TGLLogicalShape.html:1000,Energy Efficiency,consumption,consumption,1000,":; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLLogicalShape. class TGLLogicalShape. Abstract logical shape - a GL 'drawable' - base for all shapes -; faceset sphere etc. Logical shapes are a unique piece of geometry,; described in it's local frame - e.g if we have three spheres in :; Sphere A - Radius r1, center v1; Sphere B - Radius r2, center v2; Sphere C - Radius r1, center v3. Spheres A and C can share a common logical sphere of radius r1 - and; place them with two physicals with translations of v1 & v2. Sphere B; requires a different logical (radius r2), placed with physical with; translation v2. Physical shapes know about and can share logicals. Logicals do not; about (aside from reference counting) physicals or share them. This sharing of logical shapes greatly reduces memory consumption and; scene (re)build times in typical detector geometries which have many; repeated objects placements. TGLLogicalShapes have reference counting, performed by the client; physical shapes which are using it. Display list information is also stored here, possibly per LOD; level. Most classes does not support LOD (only sphere and tube) and; therefore reasonable defaults are encoded in the following virtual; functions:. * ELODAxes SupportedLODAxes() { return kLODAxesNone; }; * Int_t DLCacheSize() { return 1; }; * UInt_t DLOffset(lod); // Transform lod into DL offset.; * Short_t QuantizeShapeLOD(); // Quantize lod. Classes that have per-LOD display-lists than override these functions.; 'UShort_t fDLValid' is used as a bit-field determining validity of; each quantized LOD-level; hopefully one will not have more than 16; LOD levels per class.; See also: TGLPhysicalShape::CalculateShapeLOD() where LOD is calculated. See base/src/TVirtualViewer3D for description of common external 3D; viewer architecture and how",MatchSource.WIKI,root/html528/TGLLogicalShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLLogicalShape.html
https://root.cern/root/html528/TGLLogicalShape.html:5215,Integrability,depend,dependent,5215,"Object*fExternalObj! Also plays the role of ID.; TGLPhysicalShape*fFirstPhysical! first replica; Bool_tfOwnExtObj! External object is a fake; UInt_tfRef! physical instance ref counting; Bool_tfRefStrong! Strong ref (delete on 0 ref); not in scene; TGLScene*fScene! scene where object is stored (can be zero!). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~TGLLogicalShape(); Destroy logical shape. void AddRef(TGLPhysicalShape* phys) const; Add reference to given physical shape. void SubRef(TGLPhysicalShape* phys) const; Remove reference to given physical shape, potentially deleting; *this* object when hitting zero ref-count (if fRefStrong is; true). void DestroyPhysicals(); Destroy all physicals attached to this logical. UInt_t UnrefFirstPhysical(); Unreference first physical in the list, returning its id and; making it fit for destruction somewhere else.; Returns 0 if there are no replicas attached. void UpdateBoundingBoxesOfPhysicals(); Update bounding-boxed of all dependent physicals. Bool_t SetDLCache(Bool_t cached); Modify capture of draws into display list cache kTRUE - capture,; kFALSE direct draw. Return kTRUE is state changed, kFALSE if not. Bool_t ShouldDLCache(const TGLRnrCtx& rnrCtx) const; Returns kTRUE if draws should be display list cached; kFALSE otherwise. Here we check that:; a) fScene is set (Scene manages link to GL-context);; b) secondary selection is not in progress as different; render-path is usually taken in this case. Otherwise we return internal bool. Override this in sub-class if different behaviour is required. void DLCacheClear(); Clear all entries for all LODs for this drawable from the; display list cache but keeping the reserved ids from GL context. void DLCacheDrop(); Drop all entries for all LODs for this drawable from the display; list cache, WITHOUT returning the reserved ids to GL context. This is called by scene if it realized that the GL context was; destroyed. void DLCachePurge(); Pur",MatchSource.WIKI,root/html528/TGLLogicalShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLLogicalShape.html
https://root.cern/root/html528/TGLLogicalShape.html:1158,Performance,perform,performed,1158," description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLLogicalShape. class TGLLogicalShape. Abstract logical shape - a GL 'drawable' - base for all shapes -; faceset sphere etc. Logical shapes are a unique piece of geometry,; described in it's local frame - e.g if we have three spheres in :; Sphere A - Radius r1, center v1; Sphere B - Radius r2, center v2; Sphere C - Radius r1, center v3. Spheres A and C can share a common logical sphere of radius r1 - and; place them with two physicals with translations of v1 & v2. Sphere B; requires a different logical (radius r2), placed with physical with; translation v2. Physical shapes know about and can share logicals. Logicals do not; about (aside from reference counting) physicals or share them. This sharing of logical shapes greatly reduces memory consumption and; scene (re)build times in typical detector geometries which have many; repeated objects placements. TGLLogicalShapes have reference counting, performed by the client; physical shapes which are using it. Display list information is also stored here, possibly per LOD; level. Most classes does not support LOD (only sphere and tube) and; therefore reasonable defaults are encoded in the following virtual; functions:. * ELODAxes SupportedLODAxes() { return kLODAxesNone; }; * Int_t DLCacheSize() { return 1; }; * UInt_t DLOffset(lod); // Transform lod into DL offset.; * Short_t QuantizeShapeLOD(); // Quantize lod. Classes that have per-LOD display-lists than override these functions.; 'UShort_t fDLValid' is used as a bit-field determining validity of; each quantized LOD-level; hopefully one will not have more than 16; LOD levels per class.; See also: TGLPhysicalShape::CalculateShapeLOD() where LOD is calculated. See base/src/TVirtualViewer3D for description of common external 3D; viewer architecture and how external viewer clients use it. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Lo",MatchSource.WIKI,root/html528/TGLLogicalShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLLogicalShape.html
https://root.cern/root/html528/TGLLogicalShape.html:3250,Performance,cache,cached,3250,"ption of common external 3D; viewer architecture and how external viewer clients use it. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TGLLogicalShape(); voidAddRef(TGLPhysicalShape* phys) const; virtual Bool_tAlwaysSecondarySelect() const; const TGLBoundingBox&BoundingBox() const; static TClass*Class(); voidDestroyPhysicals(); virtual voidDirectDraw(TGLRnrCtx& rnrCtx) const; virtual voidDLCacheClear(); virtual voidDLCacheDrop(); virtual voidDLCachePurge(); virtual UInt_tDLOffset(Short_t) const; virtual voidDraw(TGLRnrCtx& rnrCtx) const; virtual voidDrawHighlight(TGLRnrCtx& rnrCtx, const TGLPhysicalShape* pshp, Int_t lvl = -1) const; TObject*GetExternal() const; const TGLPhysicalShape*GetFirstPhysical() const; TGLScene*GetScene() const; TObject*ID() const; virtual Bool_tIgnoreSizeForOfInterest() const; voidInvokeContextMenu(TContextMenu& menu, UInt_t x, UInt_t y) const; virtual TClass*IsA() const; virtual Bool_tKeepDuringSmartRefresh() const; virtual voidProcessSelection(TGLRnrCtx& rnrCtx, TGLSelectRecord& rec); virtual Short_tQuantizeShapeLOD(Short_t shapeLOD, Short_t combiLOD) const; UInt_tRef() const; Bool_tSetDLCache(Bool_t cached); virtual Bool_tShouldDLCache(const TGLRnrCtx& rnrCtx) const; virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); voidStrongRef(Bool_t strong) const; voidSubRef(TGLPhysicalShape* phys) const; virtual TGLLogicalShape::ELODAxesSupportedLODAxes() const; virtual Bool_tSupportsSecondarySelect() const; UInt_tUnrefFirstPhysical(); virtual voidUpdateBoundingBox(); voidUpdateBoundingBoxesOfPhysicals(). protected:. voidPurgeDLRange(UInt_t base, Int_t size) const. private:. TGLLogicalShape&operator=(const TGLLogicalShape&). Data Members; public:. enum ELODAxes { kLODAxesNone; kLODAxesX; kLODAxesY; kLODAxesZ; kLODAxesAll; };. protected:. TGLBoundingBoxfBou",MatchSource.WIKI,root/html528/TGLLogicalShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLLogicalShape.html
https://root.cern/root/html528/TGLLogicalShape.html:5261,Performance,cache,cached,5261,"wnExtObj! External object is a fake; UInt_tfRef! physical instance ref counting; Bool_tfRefStrong! Strong ref (delete on 0 ref); not in scene; TGLScene*fScene! scene where object is stored (can be zero!). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~TGLLogicalShape(); Destroy logical shape. void AddRef(TGLPhysicalShape* phys) const; Add reference to given physical shape. void SubRef(TGLPhysicalShape* phys) const; Remove reference to given physical shape, potentially deleting; *this* object when hitting zero ref-count (if fRefStrong is; true). void DestroyPhysicals(); Destroy all physicals attached to this logical. UInt_t UnrefFirstPhysical(); Unreference first physical in the list, returning its id and; making it fit for destruction somewhere else.; Returns 0 if there are no replicas attached. void UpdateBoundingBoxesOfPhysicals(); Update bounding-boxed of all dependent physicals. Bool_t SetDLCache(Bool_t cached); Modify capture of draws into display list cache kTRUE - capture,; kFALSE direct draw. Return kTRUE is state changed, kFALSE if not. Bool_t ShouldDLCache(const TGLRnrCtx& rnrCtx) const; Returns kTRUE if draws should be display list cached; kFALSE otherwise. Here we check that:; a) fScene is set (Scene manages link to GL-context);; b) secondary selection is not in progress as different; render-path is usually taken in this case. Otherwise we return internal bool. Override this in sub-class if different behaviour is required. void DLCacheClear(); Clear all entries for all LODs for this drawable from the; display list cache but keeping the reserved ids from GL context. void DLCacheDrop(); Drop all entries for all LODs for this drawable from the display; list cache, WITHOUT returning the reserved ids to GL context. This is called by scene if it realized that the GL context was; destroyed. void DLCachePurge(); Purge all entries for all LODs for this drawable from the; display list cache, returning the reserved ids t",MatchSource.WIKI,root/html528/TGLLogicalShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLLogicalShape.html
https://root.cern/root/html528/TGLLogicalShape.html:5312,Performance,cache,cache,5312,"wnExtObj! External object is a fake; UInt_tfRef! physical instance ref counting; Bool_tfRefStrong! Strong ref (delete on 0 ref); not in scene; TGLScene*fScene! scene where object is stored (can be zero!). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~TGLLogicalShape(); Destroy logical shape. void AddRef(TGLPhysicalShape* phys) const; Add reference to given physical shape. void SubRef(TGLPhysicalShape* phys) const; Remove reference to given physical shape, potentially deleting; *this* object when hitting zero ref-count (if fRefStrong is; true). void DestroyPhysicals(); Destroy all physicals attached to this logical. UInt_t UnrefFirstPhysical(); Unreference first physical in the list, returning its id and; making it fit for destruction somewhere else.; Returns 0 if there are no replicas attached. void UpdateBoundingBoxesOfPhysicals(); Update bounding-boxed of all dependent physicals. Bool_t SetDLCache(Bool_t cached); Modify capture of draws into display list cache kTRUE - capture,; kFALSE direct draw. Return kTRUE is state changed, kFALSE if not. Bool_t ShouldDLCache(const TGLRnrCtx& rnrCtx) const; Returns kTRUE if draws should be display list cached; kFALSE otherwise. Here we check that:; a) fScene is set (Scene manages link to GL-context);; b) secondary selection is not in progress as different; render-path is usually taken in this case. Otherwise we return internal bool. Override this in sub-class if different behaviour is required. void DLCacheClear(); Clear all entries for all LODs for this drawable from the; display list cache but keeping the reserved ids from GL context. void DLCacheDrop(); Drop all entries for all LODs for this drawable from the display; list cache, WITHOUT returning the reserved ids to GL context. This is called by scene if it realized that the GL context was; destroyed. void DLCachePurge(); Purge all entries for all LODs for this drawable from the; display list cache, returning the reserved ids t",MatchSource.WIKI,root/html528/TGLLogicalShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLLogicalShape.html
https://root.cern/root/html528/TGLLogicalShape.html:5501,Performance,cache,cached,5501,"ere object is stored (can be zero!). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~TGLLogicalShape(); Destroy logical shape. void AddRef(TGLPhysicalShape* phys) const; Add reference to given physical shape. void SubRef(TGLPhysicalShape* phys) const; Remove reference to given physical shape, potentially deleting; *this* object when hitting zero ref-count (if fRefStrong is; true). void DestroyPhysicals(); Destroy all physicals attached to this logical. UInt_t UnrefFirstPhysical(); Unreference first physical in the list, returning its id and; making it fit for destruction somewhere else.; Returns 0 if there are no replicas attached. void UpdateBoundingBoxesOfPhysicals(); Update bounding-boxed of all dependent physicals. Bool_t SetDLCache(Bool_t cached); Modify capture of draws into display list cache kTRUE - capture,; kFALSE direct draw. Return kTRUE is state changed, kFALSE if not. Bool_t ShouldDLCache(const TGLRnrCtx& rnrCtx) const; Returns kTRUE if draws should be display list cached; kFALSE otherwise. Here we check that:; a) fScene is set (Scene manages link to GL-context);; b) secondary selection is not in progress as different; render-path is usually taken in this case. Otherwise we return internal bool. Override this in sub-class if different behaviour is required. void DLCacheClear(); Clear all entries for all LODs for this drawable from the; display list cache but keeping the reserved ids from GL context. void DLCacheDrop(); Drop all entries for all LODs for this drawable from the display; list cache, WITHOUT returning the reserved ids to GL context. This is called by scene if it realized that the GL context was; destroyed. void DLCachePurge(); Purge all entries for all LODs for this drawable from the; display list cache, returning the reserved ids to GL context. If you override this function:; 1. call the base-class version from it;; 2. call it from the destructor of the derived class!. void PurgeDLRange(UInt_t bas",MatchSource.WIKI,root/html528/TGLLogicalShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLLogicalShape.html
https://root.cern/root/html528/TGLLogicalShape.html:5892,Performance,cache,cache,5892,"RefStrong is; true). void DestroyPhysicals(); Destroy all physicals attached to this logical. UInt_t UnrefFirstPhysical(); Unreference first physical in the list, returning its id and; making it fit for destruction somewhere else.; Returns 0 if there are no replicas attached. void UpdateBoundingBoxesOfPhysicals(); Update bounding-boxed of all dependent physicals. Bool_t SetDLCache(Bool_t cached); Modify capture of draws into display list cache kTRUE - capture,; kFALSE direct draw. Return kTRUE is state changed, kFALSE if not. Bool_t ShouldDLCache(const TGLRnrCtx& rnrCtx) const; Returns kTRUE if draws should be display list cached; kFALSE otherwise. Here we check that:; a) fScene is set (Scene manages link to GL-context);; b) secondary selection is not in progress as different; render-path is usually taken in this case. Otherwise we return internal bool. Override this in sub-class if different behaviour is required. void DLCacheClear(); Clear all entries for all LODs for this drawable from the; display list cache but keeping the reserved ids from GL context. void DLCacheDrop(); Drop all entries for all LODs for this drawable from the display; list cache, WITHOUT returning the reserved ids to GL context. This is called by scene if it realized that the GL context was; destroyed. void DLCachePurge(); Purge all entries for all LODs for this drawable from the; display list cache, returning the reserved ids to GL context. If you override this function:; 1. call the base-class version from it;; 2. call it from the destructor of the derived class!. void PurgeDLRange(UInt_t base, Int_t size) const; Purge given display-list range.; Utility function. Short_t QuantizeShapeLOD(Short_t shapeLOD, Short_t combiLOD) const; Logical shapes usually support only discreet LOD values,; especially in view of display-list caching.; This function should be overriden to perform the desired quantization.; See TGLSphere. void Draw(TGLRnrCtx& rnrCtx) const; Draw the GL drawable, using draw flags. ",MatchSource.WIKI,root/html528/TGLLogicalShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLLogicalShape.html
https://root.cern/root/html528/TGLLogicalShape.html:6035,Performance,cache,cache,6035,"al in the list, returning its id and; making it fit for destruction somewhere else.; Returns 0 if there are no replicas attached. void UpdateBoundingBoxesOfPhysicals(); Update bounding-boxed of all dependent physicals. Bool_t SetDLCache(Bool_t cached); Modify capture of draws into display list cache kTRUE - capture,; kFALSE direct draw. Return kTRUE is state changed, kFALSE if not. Bool_t ShouldDLCache(const TGLRnrCtx& rnrCtx) const; Returns kTRUE if draws should be display list cached; kFALSE otherwise. Here we check that:; a) fScene is set (Scene manages link to GL-context);; b) secondary selection is not in progress as different; render-path is usually taken in this case. Otherwise we return internal bool. Override this in sub-class if different behaviour is required. void DLCacheClear(); Clear all entries for all LODs for this drawable from the; display list cache but keeping the reserved ids from GL context. void DLCacheDrop(); Drop all entries for all LODs for this drawable from the display; list cache, WITHOUT returning the reserved ids to GL context. This is called by scene if it realized that the GL context was; destroyed. void DLCachePurge(); Purge all entries for all LODs for this drawable from the; display list cache, returning the reserved ids to GL context. If you override this function:; 1. call the base-class version from it;; 2. call it from the destructor of the derived class!. void PurgeDLRange(UInt_t base, Int_t size) const; Purge given display-list range.; Utility function. Short_t QuantizeShapeLOD(Short_t shapeLOD, Short_t combiLOD) const; Logical shapes usually support only discreet LOD values,; especially in view of display-list caching.; This function should be overriden to perform the desired quantization.; See TGLSphere. void Draw(TGLRnrCtx& rnrCtx) const; Draw the GL drawable, using draw flags. If DL caching is enabled; (see SetDLCache) then attempt to draw from the cache, if not found; attempt to capture the draw - done by DirectDraw() -",MatchSource.WIKI,root/html528/TGLLogicalShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLLogicalShape.html
https://root.cern/root/html528/TGLLogicalShape.html:6260,Performance,cache,cache,6260,"ool_t SetDLCache(Bool_t cached); Modify capture of draws into display list cache kTRUE - capture,; kFALSE direct draw. Return kTRUE is state changed, kFALSE if not. Bool_t ShouldDLCache(const TGLRnrCtx& rnrCtx) const; Returns kTRUE if draws should be display list cached; kFALSE otherwise. Here we check that:; a) fScene is set (Scene manages link to GL-context);; b) secondary selection is not in progress as different; render-path is usually taken in this case. Otherwise we return internal bool. Override this in sub-class if different behaviour is required. void DLCacheClear(); Clear all entries for all LODs for this drawable from the; display list cache but keeping the reserved ids from GL context. void DLCacheDrop(); Drop all entries for all LODs for this drawable from the display; list cache, WITHOUT returning the reserved ids to GL context. This is called by scene if it realized that the GL context was; destroyed. void DLCachePurge(); Purge all entries for all LODs for this drawable from the; display list cache, returning the reserved ids to GL context. If you override this function:; 1. call the base-class version from it;; 2. call it from the destructor of the derived class!. void PurgeDLRange(UInt_t base, Int_t size) const; Purge given display-list range.; Utility function. Short_t QuantizeShapeLOD(Short_t shapeLOD, Short_t combiLOD) const; Logical shapes usually support only discreet LOD values,; especially in view of display-list caching.; This function should be overriden to perform the desired quantization.; See TGLSphere. void Draw(TGLRnrCtx& rnrCtx) const; Draw the GL drawable, using draw flags. If DL caching is enabled; (see SetDLCache) then attempt to draw from the cache, if not found; attempt to capture the draw - done by DirectDraw() - into a new cache entry.; If not cached just call DirectDraw() for normal non DL cached drawing. void DrawHighlight(TGLRnrCtx& rnrCtx, const TGLPhysicalShape* pshp, Int_t lvl = -1) const; Draw the logical shape in highli",MatchSource.WIKI,root/html528/TGLLogicalShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLLogicalShape.html
https://root.cern/root/html528/TGLLogicalShape.html:6745,Performance,perform,perform,6745,"de this in sub-class if different behaviour is required. void DLCacheClear(); Clear all entries for all LODs for this drawable from the; display list cache but keeping the reserved ids from GL context. void DLCacheDrop(); Drop all entries for all LODs for this drawable from the display; list cache, WITHOUT returning the reserved ids to GL context. This is called by scene if it realized that the GL context was; destroyed. void DLCachePurge(); Purge all entries for all LODs for this drawable from the; display list cache, returning the reserved ids to GL context. If you override this function:; 1. call the base-class version from it;; 2. call it from the destructor of the derived class!. void PurgeDLRange(UInt_t base, Int_t size) const; Purge given display-list range.; Utility function. Short_t QuantizeShapeLOD(Short_t shapeLOD, Short_t combiLOD) const; Logical shapes usually support only discreet LOD values,; especially in view of display-list caching.; This function should be overriden to perform the desired quantization.; See TGLSphere. void Draw(TGLRnrCtx& rnrCtx) const; Draw the GL drawable, using draw flags. If DL caching is enabled; (see SetDLCache) then attempt to draw from the cache, if not found; attempt to capture the draw - done by DirectDraw() - into a new cache entry.; If not cached just call DirectDraw() for normal non DL cached drawing. void DrawHighlight(TGLRnrCtx& rnrCtx, const TGLPhysicalShape* pshp, Int_t lvl = -1) const; Draw the logical shape in highlight mode.; If lvl argument is less than 0 (-1 by default), the index into color-set; is taken from the physical shape itself. void ProcessSelection(TGLRnrCtx& rnrCtx, TGLSelectRecord& rec); Virtual method called-back after a secondary selection hit; is recorded (see TGLViewer::HandleButton(), Ctrl-Button1).; The ptr argument holds the GL pick-record of the closest hit. This base-class implementation simply prints out the result. void InvokeContextMenu(TContextMenu& menu, UInt_t x, UInt_t y) const; In",MatchSource.WIKI,root/html528/TGLLogicalShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLLogicalShape.html
https://root.cern/root/html528/TGLLogicalShape.html:6944,Performance,cache,cache,6944,"eDrop(); Drop all entries for all LODs for this drawable from the display; list cache, WITHOUT returning the reserved ids to GL context. This is called by scene if it realized that the GL context was; destroyed. void DLCachePurge(); Purge all entries for all LODs for this drawable from the; display list cache, returning the reserved ids to GL context. If you override this function:; 1. call the base-class version from it;; 2. call it from the destructor of the derived class!. void PurgeDLRange(UInt_t base, Int_t size) const; Purge given display-list range.; Utility function. Short_t QuantizeShapeLOD(Short_t shapeLOD, Short_t combiLOD) const; Logical shapes usually support only discreet LOD values,; especially in view of display-list caching.; This function should be overriden to perform the desired quantization.; See TGLSphere. void Draw(TGLRnrCtx& rnrCtx) const; Draw the GL drawable, using draw flags. If DL caching is enabled; (see SetDLCache) then attempt to draw from the cache, if not found; attempt to capture the draw - done by DirectDraw() - into a new cache entry.; If not cached just call DirectDraw() for normal non DL cached drawing. void DrawHighlight(TGLRnrCtx& rnrCtx, const TGLPhysicalShape* pshp, Int_t lvl = -1) const; Draw the logical shape in highlight mode.; If lvl argument is less than 0 (-1 by default), the index into color-set; is taken from the physical shape itself. void ProcessSelection(TGLRnrCtx& rnrCtx, TGLSelectRecord& rec); Virtual method called-back after a secondary selection hit; is recorded (see TGLViewer::HandleButton(), Ctrl-Button1).; The ptr argument holds the GL pick-record of the closest hit. This base-class implementation simply prints out the result. void InvokeContextMenu(TContextMenu& menu, UInt_t x, UInt_t y) const; Invoke popup menu or our bound external TObject (if any), using passed; 'menu' object, at location 'x' 'y'. TGLLogicalShape& operator=(const TGLLogicalShape& ). UInt_t Ref() const; Physical shape reference-counting, ",MatchSource.WIKI,root/html528/TGLLogicalShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLLogicalShape.html
https://root.cern/root/html528/TGLLogicalShape.html:7029,Performance,cache,cache,7029,"eDrop(); Drop all entries for all LODs for this drawable from the display; list cache, WITHOUT returning the reserved ids to GL context. This is called by scene if it realized that the GL context was; destroyed. void DLCachePurge(); Purge all entries for all LODs for this drawable from the; display list cache, returning the reserved ids to GL context. If you override this function:; 1. call the base-class version from it;; 2. call it from the destructor of the derived class!. void PurgeDLRange(UInt_t base, Int_t size) const; Purge given display-list range.; Utility function. Short_t QuantizeShapeLOD(Short_t shapeLOD, Short_t combiLOD) const; Logical shapes usually support only discreet LOD values,; especially in view of display-list caching.; This function should be overriden to perform the desired quantization.; See TGLSphere. void Draw(TGLRnrCtx& rnrCtx) const; Draw the GL drawable, using draw flags. If DL caching is enabled; (see SetDLCache) then attempt to draw from the cache, if not found; attempt to capture the draw - done by DirectDraw() - into a new cache entry.; If not cached just call DirectDraw() for normal non DL cached drawing. void DrawHighlight(TGLRnrCtx& rnrCtx, const TGLPhysicalShape* pshp, Int_t lvl = -1) const; Draw the logical shape in highlight mode.; If lvl argument is less than 0 (-1 by default), the index into color-set; is taken from the physical shape itself. void ProcessSelection(TGLRnrCtx& rnrCtx, TGLSelectRecord& rec); Virtual method called-back after a secondary selection hit; is recorded (see TGLViewer::HandleButton(), Ctrl-Button1).; The ptr argument holds the GL pick-record of the closest hit. This base-class implementation simply prints out the result. void InvokeContextMenu(TContextMenu& menu, UInt_t x, UInt_t y) const; Invoke popup menu or our bound external TObject (if any), using passed; 'menu' object, at location 'x' 'y'. TGLLogicalShape& operator=(const TGLLogicalShape& ). UInt_t Ref() const; Physical shape reference-counting, ",MatchSource.WIKI,root/html528/TGLLogicalShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLLogicalShape.html
https://root.cern/root/html528/TGLLogicalShape.html:7050,Performance,cache,cached,7050,"to GL context. This is called by scene if it realized that the GL context was; destroyed. void DLCachePurge(); Purge all entries for all LODs for this drawable from the; display list cache, returning the reserved ids to GL context. If you override this function:; 1. call the base-class version from it;; 2. call it from the destructor of the derived class!. void PurgeDLRange(UInt_t base, Int_t size) const; Purge given display-list range.; Utility function. Short_t QuantizeShapeLOD(Short_t shapeLOD, Short_t combiLOD) const; Logical shapes usually support only discreet LOD values,; especially in view of display-list caching.; This function should be overriden to perform the desired quantization.; See TGLSphere. void Draw(TGLRnrCtx& rnrCtx) const; Draw the GL drawable, using draw flags. If DL caching is enabled; (see SetDLCache) then attempt to draw from the cache, if not found; attempt to capture the draw - done by DirectDraw() - into a new cache entry.; If not cached just call DirectDraw() for normal non DL cached drawing. void DrawHighlight(TGLRnrCtx& rnrCtx, const TGLPhysicalShape* pshp, Int_t lvl = -1) const; Draw the logical shape in highlight mode.; If lvl argument is less than 0 (-1 by default), the index into color-set; is taken from the physical shape itself. void ProcessSelection(TGLRnrCtx& rnrCtx, TGLSelectRecord& rec); Virtual method called-back after a secondary selection hit; is recorded (see TGLViewer::HandleButton(), Ctrl-Button1).; The ptr argument holds the GL pick-record of the closest hit. This base-class implementation simply prints out the result. void InvokeContextMenu(TContextMenu& menu, UInt_t x, UInt_t y) const; Invoke popup menu or our bound external TObject (if any), using passed; 'menu' object, at location 'x' 'y'. TGLLogicalShape& operator=(const TGLLogicalShape& ). UInt_t Ref() const; Physical shape reference-counting, replica management. { return fRef; }. void StrongRef(Bool_t strong) const; { fRefStrong = strong; }. const TGLPhysicalSha",MatchSource.WIKI,root/html528/TGLLogicalShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLLogicalShape.html
https://root.cern/root/html528/TGLLogicalShape.html:7098,Performance,cache,cached,7098,"to GL context. This is called by scene if it realized that the GL context was; destroyed. void DLCachePurge(); Purge all entries for all LODs for this drawable from the; display list cache, returning the reserved ids to GL context. If you override this function:; 1. call the base-class version from it;; 2. call it from the destructor of the derived class!. void PurgeDLRange(UInt_t base, Int_t size) const; Purge given display-list range.; Utility function. Short_t QuantizeShapeLOD(Short_t shapeLOD, Short_t combiLOD) const; Logical shapes usually support only discreet LOD values,; especially in view of display-list caching.; This function should be overriden to perform the desired quantization.; See TGLSphere. void Draw(TGLRnrCtx& rnrCtx) const; Draw the GL drawable, using draw flags. If DL caching is enabled; (see SetDLCache) then attempt to draw from the cache, if not found; attempt to capture the draw - done by DirectDraw() - into a new cache entry.; If not cached just call DirectDraw() for normal non DL cached drawing. void DrawHighlight(TGLRnrCtx& rnrCtx, const TGLPhysicalShape* pshp, Int_t lvl = -1) const; Draw the logical shape in highlight mode.; If lvl argument is less than 0 (-1 by default), the index into color-set; is taken from the physical shape itself. void ProcessSelection(TGLRnrCtx& rnrCtx, TGLSelectRecord& rec); Virtual method called-back after a secondary selection hit; is recorded (see TGLViewer::HandleButton(), Ctrl-Button1).; The ptr argument holds the GL pick-record of the closest hit. This base-class implementation simply prints out the result. void InvokeContextMenu(TContextMenu& menu, UInt_t x, UInt_t y) const; Invoke popup menu or our bound external TObject (if any), using passed; 'menu' object, at location 'x' 'y'. TGLLogicalShape& operator=(const TGLLogicalShape& ). UInt_t Ref() const; Physical shape reference-counting, replica management. { return fRef; }. void StrongRef(Bool_t strong) const; { fRefStrong = strong; }. const TGLPhysicalSha",MatchSource.WIKI,root/html528/TGLLogicalShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLLogicalShape.html
https://root.cern/root/html528/TGLLogicalShape.html:1050,Safety,detect,detector,1050,":; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLLogicalShape. class TGLLogicalShape. Abstract logical shape - a GL 'drawable' - base for all shapes -; faceset sphere etc. Logical shapes are a unique piece of geometry,; described in it's local frame - e.g if we have three spheres in :; Sphere A - Radius r1, center v1; Sphere B - Radius r2, center v2; Sphere C - Radius r1, center v3. Spheres A and C can share a common logical sphere of radius r1 - and; place them with two physicals with translations of v1 & v2. Sphere B; requires a different logical (radius r2), placed with physical with; translation v2. Physical shapes know about and can share logicals. Logicals do not; about (aside from reference counting) physicals or share them. This sharing of logical shapes greatly reduces memory consumption and; scene (re)build times in typical detector geometries which have many; repeated objects placements. TGLLogicalShapes have reference counting, performed by the client; physical shapes which are using it. Display list information is also stored here, possibly per LOD; level. Most classes does not support LOD (only sphere and tube) and; therefore reasonable defaults are encoded in the following virtual; functions:. * ELODAxes SupportedLODAxes() { return kLODAxesNone; }; * Int_t DLCacheSize() { return 1; }; * UInt_t DLOffset(lod); // Transform lod into DL offset.; * Short_t QuantizeShapeLOD(); // Quantize lod. Classes that have per-LOD display-lists than override these functions.; 'UShort_t fDLValid' is used as a bit-field determining validity of; each quantized LOD-level; hopefully one will not have more than 16; LOD levels per class.; See also: TGLPhysicalShape::CalculateShapeLOD() where LOD is calculated. See base/src/TVirtualViewer3D for description of common external 3D; viewer architecture and how",MatchSource.WIKI,root/html528/TGLLogicalShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLLogicalShape.html
https://root.cern/root/html528/TGLLogicalShape.html:299,Testability,log,logical,299,". TGLLogicalShape. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLLogicalShape. class TGLLogicalShape. Abstract logical shape - a GL 'drawable' - base for all shapes -; faceset sphere etc. Logical shapes are a unique piece of geometry,; described in it's local frame - e.g if we have three spheres in :; Sphere A - Radius r1, center v1; Sphere B - Radius r2, center v2; Sphere C - Radius r1, center v3. Spheres A and C can share a common logical sphere of radius r1 - and; place them with two physicals with translations of v1 & v2. Sphere B; requires a different logical (radius r2), placed with physical with; translation v2. Physical shapes know about and can share logicals. Logicals do not; about (aside from reference counting) physicals or share them. This sharing of logical shapes greatly reduces memory consumption and; scene (re)build times in typical detector geometries which have many; repeated objects placements. TGLLogicalShapes have reference counting, performed by the client; physical shapes which are using it. Display list information is also stored here, possibly per LOD; level. Most classes does not support LOD (only sphere and tube) and; therefore reasonable defaults are encoded in the following virtual; functions:. * ELODAxes SupportedLODAxes() { return kLODAxesNone; }; * Int_t DLCacheSize() { return 1; }; * UInt_t DLOffset(lod); // Transform lod into DL offset.; * Short_t QuantizeShapeLOD(); // Quantize lod. Classes that have per-LOD display-lists than override these functions.; 'UShort_t fDLValid' is used as a bit-field determining validity of; each quantized LOD-level; hopefully one will not have more than 16; LOD levels per class.; See also: TGLPhysicalShape::CalculateShapeLOD() where LOD is calculated. See base/src/TVirtualViewer3D for description of common external 3D",MatchSource.WIKI,root/html528/TGLLogicalShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLLogicalShape.html
https://root.cern/root/html528/TGLLogicalShape.html:625,Testability,log,logical,625,". TGLLogicalShape. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLLogicalShape. class TGLLogicalShape. Abstract logical shape - a GL 'drawable' - base for all shapes -; faceset sphere etc. Logical shapes are a unique piece of geometry,; described in it's local frame - e.g if we have three spheres in :; Sphere A - Radius r1, center v1; Sphere B - Radius r2, center v2; Sphere C - Radius r1, center v3. Spheres A and C can share a common logical sphere of radius r1 - and; place them with two physicals with translations of v1 & v2. Sphere B; requires a different logical (radius r2), placed with physical with; translation v2. Physical shapes know about and can share logicals. Logicals do not; about (aside from reference counting) physicals or share them. This sharing of logical shapes greatly reduces memory consumption and; scene (re)build times in typical detector geometries which have many; repeated objects placements. TGLLogicalShapes have reference counting, performed by the client; physical shapes which are using it. Display list information is also stored here, possibly per LOD; level. Most classes does not support LOD (only sphere and tube) and; therefore reasonable defaults are encoded in the following virtual; functions:. * ELODAxes SupportedLODAxes() { return kLODAxesNone; }; * Int_t DLCacheSize() { return 1; }; * UInt_t DLOffset(lod); // Transform lod into DL offset.; * Short_t QuantizeShapeLOD(); // Quantize lod. Classes that have per-LOD display-lists than override these functions.; 'UShort_t fDLValid' is used as a bit-field determining validity of; each quantized LOD-level; hopefully one will not have more than 16; LOD levels per class.; See also: TGLPhysicalShape::CalculateShapeLOD() where LOD is calculated. See base/src/TVirtualViewer3D for description of common external 3D",MatchSource.WIKI,root/html528/TGLLogicalShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLLogicalShape.html
https://root.cern/root/html528/TGLLogicalShape.html:751,Testability,log,logical,751,". TGLLogicalShape. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLLogicalShape. class TGLLogicalShape. Abstract logical shape - a GL 'drawable' - base for all shapes -; faceset sphere etc. Logical shapes are a unique piece of geometry,; described in it's local frame - e.g if we have three spheres in :; Sphere A - Radius r1, center v1; Sphere B - Radius r2, center v2; Sphere C - Radius r1, center v3. Spheres A and C can share a common logical sphere of radius r1 - and; place them with two physicals with translations of v1 & v2. Sphere B; requires a different logical (radius r2), placed with physical with; translation v2. Physical shapes know about and can share logicals. Logicals do not; about (aside from reference counting) physicals or share them. This sharing of logical shapes greatly reduces memory consumption and; scene (re)build times in typical detector geometries which have many; repeated objects placements. TGLLogicalShapes have reference counting, performed by the client; physical shapes which are using it. Display list information is also stored here, possibly per LOD; level. Most classes does not support LOD (only sphere and tube) and; therefore reasonable defaults are encoded in the following virtual; functions:. * ELODAxes SupportedLODAxes() { return kLODAxesNone; }; * Int_t DLCacheSize() { return 1; }; * UInt_t DLOffset(lod); // Transform lod into DL offset.; * Short_t QuantizeShapeLOD(); // Quantize lod. Classes that have per-LOD display-lists than override these functions.; 'UShort_t fDLValid' is used as a bit-field determining validity of; each quantized LOD-level; hopefully one will not have more than 16; LOD levels per class.; See also: TGLPhysicalShape::CalculateShapeLOD() where LOD is calculated. See base/src/TVirtualViewer3D for description of common external 3D",MatchSource.WIKI,root/html528/TGLLogicalShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLLogicalShape.html
https://root.cern/root/html528/TGLLogicalShape.html:856,Testability,log,logicals,856,". TGLLogicalShape. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLLogicalShape. class TGLLogicalShape. Abstract logical shape - a GL 'drawable' - base for all shapes -; faceset sphere etc. Logical shapes are a unique piece of geometry,; described in it's local frame - e.g if we have three spheres in :; Sphere A - Radius r1, center v1; Sphere B - Radius r2, center v2; Sphere C - Radius r1, center v3. Spheres A and C can share a common logical sphere of radius r1 - and; place them with two physicals with translations of v1 & v2. Sphere B; requires a different logical (radius r2), placed with physical with; translation v2. Physical shapes know about and can share logicals. Logicals do not; about (aside from reference counting) physicals or share them. This sharing of logical shapes greatly reduces memory consumption and; scene (re)build times in typical detector geometries which have many; repeated objects placements. TGLLogicalShapes have reference counting, performed by the client; physical shapes which are using it. Display list information is also stored here, possibly per LOD; level. Most classes does not support LOD (only sphere and tube) and; therefore reasonable defaults are encoded in the following virtual; functions:. * ELODAxes SupportedLODAxes() { return kLODAxesNone; }; * Int_t DLCacheSize() { return 1; }; * UInt_t DLOffset(lod); // Transform lod into DL offset.; * Short_t QuantizeShapeLOD(); // Quantize lod. Classes that have per-LOD display-lists than override these functions.; 'UShort_t fDLValid' is used as a bit-field determining validity of; each quantized LOD-level; hopefully one will not have more than 16; LOD levels per class.; See also: TGLPhysicalShape::CalculateShapeLOD() where LOD is calculated. See base/src/TVirtualViewer3D for description of common external 3D",MatchSource.WIKI,root/html528/TGLLogicalShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLLogicalShape.html
https://root.cern/root/html528/TGLLogicalShape.html:962,Testability,log,logical,962,":; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLLogicalShape. class TGLLogicalShape. Abstract logical shape - a GL 'drawable' - base for all shapes -; faceset sphere etc. Logical shapes are a unique piece of geometry,; described in it's local frame - e.g if we have three spheres in :; Sphere A - Radius r1, center v1; Sphere B - Radius r2, center v2; Sphere C - Radius r1, center v3. Spheres A and C can share a common logical sphere of radius r1 - and; place them with two physicals with translations of v1 & v2. Sphere B; requires a different logical (radius r2), placed with physical with; translation v2. Physical shapes know about and can share logicals. Logicals do not; about (aside from reference counting) physicals or share them. This sharing of logical shapes greatly reduces memory consumption and; scene (re)build times in typical detector geometries which have many; repeated objects placements. TGLLogicalShapes have reference counting, performed by the client; physical shapes which are using it. Display list information is also stored here, possibly per LOD; level. Most classes does not support LOD (only sphere and tube) and; therefore reasonable defaults are encoded in the following virtual; functions:. * ELODAxes SupportedLODAxes() { return kLODAxesNone; }; * Int_t DLCacheSize() { return 1; }; * UInt_t DLOffset(lod); // Transform lod into DL offset.; * Short_t QuantizeShapeLOD(); // Quantize lod. Classes that have per-LOD display-lists than override these functions.; 'UShort_t fDLValid' is used as a bit-field determining validity of; each quantized LOD-level; hopefully one will not have more than 16; LOD levels per class.; See also: TGLPhysicalShape::CalculateShapeLOD() where LOD is calculated. See base/src/TVirtualViewer3D for description of common external 3D; viewer architecture and how",MatchSource.WIKI,root/html528/TGLLogicalShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLLogicalShape.html
https://root.cern/root/html528/TGLLogicalShape.html:4619,Testability,log,logical,4619,"ndarySelect() const; UInt_tUnrefFirstPhysical(); virtual voidUpdateBoundingBox(); voidUpdateBoundingBoxesOfPhysicals(). protected:. voidPurgeDLRange(UInt_t base, Int_t size) const. private:. TGLLogicalShape&operator=(const TGLLogicalShape&). Data Members; public:. enum ELODAxes { kLODAxesNone; kLODAxesX; kLODAxesY; kLODAxesZ; kLODAxesAll; };. protected:. TGLBoundingBoxfBoundingBox! Shape's bounding box.; UInt_tfDLBase! display-list id base; Bool_tfDLCache! use display list caching; Int_tfDLSize! display-list size for different LODs; UShort_tfDLValid! display-list validity bit-field; TObject*fExternalObj! Also plays the role of ID.; TGLPhysicalShape*fFirstPhysical! first replica; Bool_tfOwnExtObj! External object is a fake; UInt_tfRef! physical instance ref counting; Bool_tfRefStrong! Strong ref (delete on 0 ref); not in scene; TGLScene*fScene! scene where object is stored (can be zero!). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~TGLLogicalShape(); Destroy logical shape. void AddRef(TGLPhysicalShape* phys) const; Add reference to given physical shape. void SubRef(TGLPhysicalShape* phys) const; Remove reference to given physical shape, potentially deleting; *this* object when hitting zero ref-count (if fRefStrong is; true). void DestroyPhysicals(); Destroy all physicals attached to this logical. UInt_t UnrefFirstPhysical(); Unreference first physical in the list, returning its id and; making it fit for destruction somewhere else.; Returns 0 if there are no replicas attached. void UpdateBoundingBoxesOfPhysicals(); Update bounding-boxed of all dependent physicals. Bool_t SetDLCache(Bool_t cached); Modify capture of draws into display list cache kTRUE - capture,; kFALSE direct draw. Return kTRUE is state changed, kFALSE if not. Bool_t ShouldDLCache(const TGLRnrCtx& rnrCtx) const; Returns kTRUE if draws should be display list cached; kFALSE otherwise. Here we check that:; a) fScene is set (Scene manages link to GL-context);",MatchSource.WIKI,root/html528/TGLLogicalShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLLogicalShape.html
https://root.cern/root/html528/TGLLogicalShape.html:4955,Testability,log,logical,4955," kLODAxesAll; };. protected:. TGLBoundingBoxfBoundingBox! Shape's bounding box.; UInt_tfDLBase! display-list id base; Bool_tfDLCache! use display list caching; Int_tfDLSize! display-list size for different LODs; UShort_tfDLValid! display-list validity bit-field; TObject*fExternalObj! Also plays the role of ID.; TGLPhysicalShape*fFirstPhysical! first replica; Bool_tfOwnExtObj! External object is a fake; UInt_tfRef! physical instance ref counting; Bool_tfRefStrong! Strong ref (delete on 0 ref); not in scene; TGLScene*fScene! scene where object is stored (can be zero!). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~TGLLogicalShape(); Destroy logical shape. void AddRef(TGLPhysicalShape* phys) const; Add reference to given physical shape. void SubRef(TGLPhysicalShape* phys) const; Remove reference to given physical shape, potentially deleting; *this* object when hitting zero ref-count (if fRefStrong is; true). void DestroyPhysicals(); Destroy all physicals attached to this logical. UInt_t UnrefFirstPhysical(); Unreference first physical in the list, returning its id and; making it fit for destruction somewhere else.; Returns 0 if there are no replicas attached. void UpdateBoundingBoxesOfPhysicals(); Update bounding-boxed of all dependent physicals. Bool_t SetDLCache(Bool_t cached); Modify capture of draws into display list cache kTRUE - capture,; kFALSE direct draw. Return kTRUE is state changed, kFALSE if not. Bool_t ShouldDLCache(const TGLRnrCtx& rnrCtx) const; Returns kTRUE if draws should be display list cached; kFALSE otherwise. Here we check that:; a) fScene is set (Scene manages link to GL-context);; b) secondary selection is not in progress as different; render-path is usually taken in this case. Otherwise we return internal bool. Override this in sub-class if different behaviour is required. void DLCacheClear(); Clear all entries for all LODs for this drawable from the; display list cache but keeping the reserved ids ",MatchSource.WIKI,root/html528/TGLLogicalShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLLogicalShape.html
https://root.cern/root/html528/TGLLogicalShape.html:7214,Testability,log,logical,7214,"Purge(); Purge all entries for all LODs for this drawable from the; display list cache, returning the reserved ids to GL context. If you override this function:; 1. call the base-class version from it;; 2. call it from the destructor of the derived class!. void PurgeDLRange(UInt_t base, Int_t size) const; Purge given display-list range.; Utility function. Short_t QuantizeShapeLOD(Short_t shapeLOD, Short_t combiLOD) const; Logical shapes usually support only discreet LOD values,; especially in view of display-list caching.; This function should be overriden to perform the desired quantization.; See TGLSphere. void Draw(TGLRnrCtx& rnrCtx) const; Draw the GL drawable, using draw flags. If DL caching is enabled; (see SetDLCache) then attempt to draw from the cache, if not found; attempt to capture the draw - done by DirectDraw() - into a new cache entry.; If not cached just call DirectDraw() for normal non DL cached drawing. void DrawHighlight(TGLRnrCtx& rnrCtx, const TGLPhysicalShape* pshp, Int_t lvl = -1) const; Draw the logical shape in highlight mode.; If lvl argument is less than 0 (-1 by default), the index into color-set; is taken from the physical shape itself. void ProcessSelection(TGLRnrCtx& rnrCtx, TGLSelectRecord& rec); Virtual method called-back after a secondary selection hit; is recorded (see TGLViewer::HandleButton(), Ctrl-Button1).; The ptr argument holds the GL pick-record of the closest hit. This base-class implementation simply prints out the result. void InvokeContextMenu(TContextMenu& menu, UInt_t x, UInt_t y) const; Invoke popup menu or our bound external TObject (if any), using passed; 'menu' object, at location 'x' 'y'. TGLLogicalShape& operator=(const TGLLogicalShape& ). UInt_t Ref() const; Physical shape reference-counting, replica management. { return fRef; }. void StrongRef(Bool_t strong) const; { fRefStrong = strong; }. const TGLPhysicalShape* GetFirstPhysical() const; { return fFirstPhysical; }. TObject* ID() const; { return fExternalObj; }",MatchSource.WIKI,root/html528/TGLLogicalShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLLogicalShape.html
https://root.cern/root/html528/TGLLogicalShape.html:7640,Usability,simpl,simply,7640,"ly discreet LOD values,; especially in view of display-list caching.; This function should be overriden to perform the desired quantization.; See TGLSphere. void Draw(TGLRnrCtx& rnrCtx) const; Draw the GL drawable, using draw flags. If DL caching is enabled; (see SetDLCache) then attempt to draw from the cache, if not found; attempt to capture the draw - done by DirectDraw() - into a new cache entry.; If not cached just call DirectDraw() for normal non DL cached drawing. void DrawHighlight(TGLRnrCtx& rnrCtx, const TGLPhysicalShape* pshp, Int_t lvl = -1) const; Draw the logical shape in highlight mode.; If lvl argument is less than 0 (-1 by default), the index into color-set; is taken from the physical shape itself. void ProcessSelection(TGLRnrCtx& rnrCtx, TGLSelectRecord& rec); Virtual method called-back after a secondary selection hit; is recorded (see TGLViewer::HandleButton(), Ctrl-Button1).; The ptr argument holds the GL pick-record of the closest hit. This base-class implementation simply prints out the result. void InvokeContextMenu(TContextMenu& menu, UInt_t x, UInt_t y) const; Invoke popup menu or our bound external TObject (if any), using passed; 'menu' object, at location 'x' 'y'. TGLLogicalShape& operator=(const TGLLogicalShape& ). UInt_t Ref() const; Physical shape reference-counting, replica management. { return fRef; }. void StrongRef(Bool_t strong) const; { fRefStrong = strong; }. const TGLPhysicalShape* GetFirstPhysical() const; { return fFirstPhysical; }. TObject* ID() const; { return fExternalObj; }. TObject* GetExternal() const; { return fExternalObj; }. TGLScene* GetScene() const; { return fScene; }. void UpdateBoundingBox(); {}. UInt_t DLOffset(Short_t ) const; { return 0; }. ELODAxes SupportedLODAxes() const; { return kLODAxesNone; }. void DirectDraw(TGLRnrCtx& rnrCtx) const. Bool_t IgnoreSizeForOfInterest() const; { return kFALSE; }. Bool_t KeepDuringSmartRefresh() const; Override in sub-classes that do direct object rendering (e.g. TGLObject).",MatchSource.WIKI,root/html528/TGLLogicalShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLLogicalShape.html
https://root.cern/root/html528/TGLManager.html:496,Availability,avail,available,496,". TGLManager. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TGLManager. class TGLManager: public TNamed. TVirtualGL. The TVirtualGL class is an abstract base class defining the; OpenGL interface protocol. All interactions with OpenGL should be; done via the global pointer gVirtualGL. If the OpenGL library is; available this pointer is pointing to an instance of the TGLKernel; class which provides the actual interface to OpenGL. Using this; scheme of ABC we can use OpenGL in other parts of the framework; without having to link with the OpenGL library in case we don't; use the classes using OpenGL. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. ~TGLManager(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual Bool_tAttachOffScreenDevice(Int_t ctxInd, Int_t x, Int_t y, UInt_t w, UInt_t h); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual Int_tCreateGLContext(Int_t winInd); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidDeleteGLContext(Int_t ctxInd); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTOb",MatchSource.WIKI,root/html528/TGLManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLManager.html
https://root.cern/root/html528/TGLManager.html:923,Availability,avail,available,923,". TGLManager. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TGLManager. class TGLManager: public TNamed. TVirtualGL. The TVirtualGL class is an abstract base class defining the; OpenGL interface protocol. All interactions with OpenGL should be; done via the global pointer gVirtualGL. If the OpenGL library is; available this pointer is pointing to an instance of the TGLKernel; class which provides the actual interface to OpenGL. Using this; scheme of ABC we can use OpenGL in other parts of the framework; without having to link with the OpenGL library in case we don't; use the classes using OpenGL. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. ~TGLManager(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual Bool_tAttachOffScreenDevice(Int_t ctxInd, Int_t x, Int_t y, UInt_t w, UInt_t h); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual Int_tCreateGLContext(Int_t winInd); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidDeleteGLContext(Int_t ctxInd); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTOb",MatchSource.WIKI,root/html528/TGLManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLManager.html
https://root.cern/root/html528/TGLManager.html:2062,Availability,error,error,2062,"t* option = """"); virtual Bool_tAttachOffScreenDevice(Int_t ctxInd, Int_t x, Int_t y, UInt_t w, UInt_t h); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual Int_tCreateGLContext(Int_t winInd); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidDeleteGLContext(Int_t ctxInd); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidExtractViewport(Int_t ctxInd, Int_t* vp); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidFlush(Int_t ctxInd); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual char*GetPlotInfo(TVirtualGLPainter* plot, Int_t px, Int_t py); virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Int_tGetVirtu",MatchSource.WIKI,root/html528/TGLManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLManager.html
https://root.cern/root/html528/TGLManager.html:2146,Availability,error,error,2146," UInt_t w, UInt_t h); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual Int_tCreateGLContext(Int_t winInd); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidDeleteGLContext(Int_t ctxInd); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidExtractViewport(Int_t ctxInd, Int_t* vp); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidFlush(Int_t ctxInd); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual char*GetPlotInfo(TVirtualGLPainter* plot, Int_t px, Int_t py); virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Int_tGetVirtualXInd(Int_t ctxInd); virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULo",MatchSource.WIKI,root/html528/TGLManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLManager.html
https://root.cern/root/html528/TGLManager.html:370,Integrability,interface,interface,370,". TGLManager. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TGLManager. class TGLManager: public TNamed. TVirtualGL. The TVirtualGL class is an abstract base class defining the; OpenGL interface protocol. All interactions with OpenGL should be; done via the global pointer gVirtualGL. If the OpenGL library is; available this pointer is pointing to an instance of the TGLKernel; class which provides the actual interface to OpenGL. Using this; scheme of ABC we can use OpenGL in other parts of the framework; without having to link with the OpenGL library in case we don't; use the classes using OpenGL. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. ~TGLManager(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual Bool_tAttachOffScreenDevice(Int_t ctxInd, Int_t x, Int_t y, UInt_t w, UInt_t h); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual Int_tCreateGLContext(Int_t winInd); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidDeleteGLContext(Int_t ctxInd); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTOb",MatchSource.WIKI,root/html528/TGLManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLManager.html
https://root.cern/root/html528/TGLManager.html:380,Integrability,protocol,protocol,380,". TGLManager. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TGLManager. class TGLManager: public TNamed. TVirtualGL. The TVirtualGL class is an abstract base class defining the; OpenGL interface protocol. All interactions with OpenGL should be; done via the global pointer gVirtualGL. If the OpenGL library is; available this pointer is pointing to an instance of the TGLKernel; class which provides the actual interface to OpenGL. Using this; scheme of ABC we can use OpenGL in other parts of the framework; without having to link with the OpenGL library in case we don't; use the classes using OpenGL. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. ~TGLManager(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual Bool_tAttachOffScreenDevice(Int_t ctxInd, Int_t x, Int_t y, UInt_t w, UInt_t h); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual Int_tCreateGLContext(Int_t winInd); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidDeleteGLContext(Int_t ctxInd); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTOb",MatchSource.WIKI,root/html528/TGLManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLManager.html
https://root.cern/root/html528/TGLManager.html:596,Integrability,interface,interface,596,". TGLManager. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TGLManager. class TGLManager: public TNamed. TVirtualGL. The TVirtualGL class is an abstract base class defining the; OpenGL interface protocol. All interactions with OpenGL should be; done via the global pointer gVirtualGL. If the OpenGL library is; available this pointer is pointing to an instance of the TGLKernel; class which provides the actual interface to OpenGL. Using this; scheme of ABC we can use OpenGL in other parts of the framework; without having to link with the OpenGL library in case we don't; use the classes using OpenGL. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. ~TGLManager(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual Bool_tAttachOffScreenDevice(Int_t ctxInd, Int_t x, Int_t y, UInt_t w, UInt_t h); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual Int_tCreateGLContext(Int_t winInd); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidDeleteGLContext(Int_t ctxInd); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTOb",MatchSource.WIKI,root/html528/TGLManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLManager.html
https://root.cern/root/html528/TGLManip.html:856,Availability,avail,available,856,". TGLManip. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLManip. class TGLManip: public TVirtualGLManip. Abstract base class for viewer manipulators, which allow direct in; viewer manipulation of a (TGlPhysicalShape) object - currently; translation, scaling and rotation along/round objects local axes.; See derived classes for these implementations. This class provides binding to the zero or one manipulated physical,; hit testing (selection) for manipulator sub component (widget), and; some common mouse action handling/tracking. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TGLManip(); voidAttach(TGLPhysicalShape* shape); static TClass*Class(); virtual voidDraw(const TGLCamera& camera) const; Bool_tGetActive() const; TGLPhysicalShape*GetAttached() const; UInt_tGetSelectedWidget() const; virtual Bool_tHandleButton(const Event_t& event, const TGLCamera& camera); virtual Bool_tHandleMotion(const Event_t& event, const TGLCamera& camera); virtual TClass*IsA() const; virtual Bool_tSelect(const TGLCamera&, const TGLRect&, const TGLBoundingBox&); voidSetActive(Bool_t a); voidSetSelectedWidget(UInt_t s); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). protected:. voidCalcDrawScale(const TGLBoundingBox& box, const TGLCamera& camera, Double_t& base, TGLVector3* axis) const; const UChar_t*ColorFor(UInt_t widget) const; TGLManip&operator=(const TGLManip&). Data Members; protected:. Bool_tfActive! manipulator is active?; TPointfFirstMouse! first (start) mouse position (in WINDOW coords); TPointfLastMouse! last (latest) mouse position (in WINDOW coords); UInt_tfSelectedWidget! active width (axis) compon",MatchSource.WIKI,root/html528/TGLManip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLManip.html
https://root.cern/root/html528/TGLManip.html:613,Testability,test,testing,613,". TGLManip. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLManip. class TGLManip: public TVirtualGLManip. Abstract base class for viewer manipulators, which allow direct in; viewer manipulation of a (TGlPhysicalShape) object - currently; translation, scaling and rotation along/round objects local axes.; See derived classes for these implementations. This class provides binding to the zero or one manipulated physical,; hit testing (selection) for manipulator sub component (widget), and; some common mouse action handling/tracking. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TGLManip(); voidAttach(TGLPhysicalShape* shape); static TClass*Class(); virtual voidDraw(const TGLCamera& camera) const; Bool_tGetActive() const; TGLPhysicalShape*GetAttached() const; UInt_tGetSelectedWidget() const; virtual Bool_tHandleButton(const Event_t& event, const TGLCamera& camera); virtual Bool_tHandleMotion(const Event_t& event, const TGLCamera& camera); virtual TClass*IsA() const; virtual Bool_tSelect(const TGLCamera&, const TGLRect&, const TGLBoundingBox&); voidSetActive(Bool_t a); voidSetSelectedWidget(UInt_t s); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). protected:. voidCalcDrawScale(const TGLBoundingBox& box, const TGLCamera& camera, Double_t& base, TGLVector3* axis) const; const UChar_t*ColorFor(UInt_t widget) const; TGLManip&operator=(const TGLManip&). Data Members; protected:. Bool_tfActive! manipulator is active?; TPointfFirstMouse! first (start) mouse position (in WINDOW coords); TPointfLastMouse! last (latest) mouse position (in WINDOW coords); UInt_tfSelectedWidget! active width (axis) compon",MatchSource.WIKI,root/html528/TGLManip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLManip.html
https://root.cern/root/html528/TGLManipSet.html:337,Availability,avail,available,337,". TGLManipSet. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLManipSet. class TGLManipSet: public TGLOverlayElement, public TGLPShapeRef. Combine all available manipulators in a collection. At first I wanted to merge them back into TGLManip (to have a; single class) but then it seemed somehow messy.; Maybe next time. Function Members (Methods); public:. TGLManipSet(); virtual~TGLManipSet(); static TClass*Class(); TGLManip*GetCurrentManip() const; Bool_tGetDrawBBox() const; Int_tGetManipType() const; TGLPhysicalShape*TGLPShapeRef::GetPShape() const; TGLOverlayElement::ERoleTGLOverlayElement::GetRole() const; TGLOverlayElement::EStateTGLOverlayElement::GetState() const; virtual Bool_tHandle(TGLRnrCtx& rnrCtx, TGLOvlSelectRecord& selRec, Event_t* event); virtual TClass*IsA() const; virtual Bool_tMouseEnter(TGLOvlSelectRecord& selRec); virtual voidMouseLeave(); virtual Bool_tTGLOverlayElement::MouseStillInside(TGLOvlSelectRecord& selRec); virtual voidTGLPShapeRef::PShapeModified(); virtual voidRender(TGLRnrCtx& rnrCtx); voidTGLOverlayElement::SetBinaryState(Bool_t s); voidSetDrawBBox(Bool_t bb); voidSetManipType(Int_t type); virtual voidSetPShape(TGLPhysicalShape* shape); voidTGLOverlayElement::SetRole(TGLOverlayElement::ERole r); voidTGLOverlayElement::SetState(TGLOverlayElement::EState s); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). protected:. voidTGLOverlayElement::ProjectionMatrixPushIdentity(). private:. TGLManipSet(const TGLManipSet&); TGLManipSet&operator=(const TGLManipSet&). Data Members; public:. enum EManip { kTrans; kScale; kRotate; kEndType; };; enum TGLOverlayElement::ERole { kUser; kViewer; kAnnotation; kAll; };; enum TGLOverlayElement::EState { kInvisible; kDisabled; kActive; kAllVisible; };. protec",MatchSource.WIKI,root/html528/TGLManipSet.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLManipSet.html
https://root.cern/root/html528/TGLMatrix.html:552,Security,access,accessors,552,". TGLMatrix. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLMatrix. class TGLMatrix. TGLMatrix. 16 component (4x4) transform matrix - column MAJOR as per GL.; Provides limited support for adjusting the translation, scale and; rotation components. This is part of collection of simple utility classes for GL only in; TGLUtil.h/cxx. These provide const and non-const accessors Arr() &; CArr() to a GL compatible internal field - so can be used directly; with OpenGL C API calls - which TVector3 etc cannot (easily).; They are not intended to be fully featured just provide minimum; required. Function Members (Methods); public:. TGLMatrix(); TGLMatrix(const TGLVertex3& translation); TGLMatrix(const Double_t* vals); TGLMatrix(const TGLMatrix& other); TGLMatrix(const TGLVertex3& origin, const TGLVector3& zAxis); TGLMatrix(Double_t x, Double_t y, Double_t z); TGLMatrix(const TGLVertex3& origin, const TGLVector3& zAxis, const TGLVector3& xAxis); virtual~TGLMatrix(); Double_t*Arr(); const Double_t*CArr() const; static TClass*Class(); voidDump() const; TGLVector3GetBaseVec(Int_t b) const; voidGetBaseVec(Int_t b, TGLVector3& v) const; voidGetBaseVec(Int_t b, Double_t* x) const; TGLVector3GetScale() const; TGLVector3GetTranslation() const; Double_tInvert(); virtual TClass*IsA() const; voidMove3LF(Double_t x, Double_t y, Double_t z); voidMoveLF(Int_t ai, Double_t amount); TGLVector3Multiply(const TGLVector3& v, Double_t w = 1) const; voidMultiplyIP(TGLVector3& v, Double_t w = 1) const; voidMultLeft(const TGLMatrix& lhs); voidMultRight(const TGLMatrix& rhs); TGLMatrix&operator*=(const TGLMatrix& rhs); TGLMatrix&operator=(const TGLMatrix& rhs); Double_t&operator[](Int_t index); Double_toperator[](Int_t index) const; TGLVector3Rotate(const TGLVector3& v) const; voidRotate(const TGLVertex3& pivot, const TG",MatchSource.WIKI,root/html528/TGLMatrix.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLMatrix.html
https://root.cern/root/html528/TGLMatrix.html:464,Usability,simpl,simple,464,". TGLMatrix. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLMatrix. class TGLMatrix. TGLMatrix. 16 component (4x4) transform matrix - column MAJOR as per GL.; Provides limited support for adjusting the translation, scale and; rotation components. This is part of collection of simple utility classes for GL only in; TGLUtil.h/cxx. These provide const and non-const accessors Arr() &; CArr() to a GL compatible internal field - so can be used directly; with OpenGL C API calls - which TVector3 etc cannot (easily).; They are not intended to be fully featured just provide minimum; required. Function Members (Methods); public:. TGLMatrix(); TGLMatrix(const TGLVertex3& translation); TGLMatrix(const Double_t* vals); TGLMatrix(const TGLMatrix& other); TGLMatrix(const TGLVertex3& origin, const TGLVector3& zAxis); TGLMatrix(Double_t x, Double_t y, Double_t z); TGLMatrix(const TGLVertex3& origin, const TGLVector3& zAxis, const TGLVector3& xAxis); virtual~TGLMatrix(); Double_t*Arr(); const Double_t*CArr() const; static TClass*Class(); voidDump() const; TGLVector3GetBaseVec(Int_t b) const; voidGetBaseVec(Int_t b, TGLVector3& v) const; voidGetBaseVec(Int_t b, Double_t* x) const; TGLVector3GetScale() const; TGLVector3GetTranslation() const; Double_tInvert(); virtual TClass*IsA() const; voidMove3LF(Double_t x, Double_t y, Double_t z); voidMoveLF(Int_t ai, Double_t amount); TGLVector3Multiply(const TGLVector3& v, Double_t w = 1) const; voidMultiplyIP(TGLVector3& v, Double_t w = 1) const; voidMultLeft(const TGLMatrix& lhs); voidMultRight(const TGLMatrix& rhs); TGLMatrix&operator*=(const TGLMatrix& rhs); TGLMatrix&operator=(const TGLMatrix& rhs); Double_t&operator[](Int_t index); Double_toperator[](Int_t index) const; TGLVector3Rotate(const TGLVector3& v) const; voidRotate(const TGLVertex3& pivot, const TG",MatchSource.WIKI,root/html528/TGLMatrix.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLMatrix.html
https://root.cern/root/html528/TGlobal.html:1563,Availability,error,error,1563," TGlobal(DataMemberInfo_t* info = 0); TGlobal(const TGlobal&); virtual~TGlobal(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; void*GetAddress() const; Int_",MatchSource.WIKI,root/html528/TGlobal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGlobal.html
https://root.cern/root/html528/TGlobal.html:1647,Availability,error,error,1647,"oidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; void*GetAddress() const; Int_tGetArrayDim() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); const char*GetFullTypeName() const; virtual const char*TObject::GetIconName() const; Int_tGetMaxIndex(Int_t dim) const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; const char*GetTypeName() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::",MatchSource.WIKI,root/html528/TGlobal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGlobal.html
https://root.cern/root/html528/TGlobal.html:293,Modifiability,variab,variables,293,". TGlobal. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » META; » TGlobal. class TGlobal: public TDictionary. Global variables class (global variables are obtained from CINT).; This class describes the attributes of a global variable.; The TROOT class contains a list of all currently defined global; variables (accessible via TROOT::GetListOfGlobals()). Function Members (Methods); public:. TGlobal(DataMemberInfo_t* info = 0); TGlobal(const TGlobal&); virtual~TGlobal(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; void*GetAddress() const; Int_",MatchSource.WIKI,root/html528/TGlobal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGlobal.html
https://root.cern/root/html528/TGlobal.html:317,Modifiability,variab,variables,317,". TGlobal. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » META; » TGlobal. class TGlobal: public TDictionary. Global variables class (global variables are obtained from CINT).; This class describes the attributes of a global variable.; The TROOT class contains a list of all currently defined global; variables (accessible via TROOT::GetListOfGlobals()). Function Members (Methods); public:. TGlobal(DataMemberInfo_t* info = 0); TGlobal(const TGlobal&); virtual~TGlobal(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; void*GetAddress() const; Int_",MatchSource.WIKI,root/html528/TGlobal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGlobal.html
https://root.cern/root/html528/TGlobal.html:401,Modifiability,variab,variable,401,". TGlobal. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » META; » TGlobal. class TGlobal: public TDictionary. Global variables class (global variables are obtained from CINT).; This class describes the attributes of a global variable.; The TROOT class contains a list of all currently defined global; variables (accessible via TROOT::GetListOfGlobals()). Function Members (Methods); public:. TGlobal(DataMemberInfo_t* info = 0); TGlobal(const TGlobal&); virtual~TGlobal(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; void*GetAddress() const; Int_",MatchSource.WIKI,root/html528/TGlobal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGlobal.html
https://root.cern/root/html528/TGlobal.html:477,Modifiability,variab,variables,477,". TGlobal. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » META; » TGlobal. class TGlobal: public TDictionary. Global variables class (global variables are obtained from CINT).; This class describes the attributes of a global variable.; The TROOT class contains a list of all currently defined global; variables (accessible via TROOT::GetListOfGlobals()). Function Members (Methods); public:. TGlobal(DataMemberInfo_t* info = 0); TGlobal(const TGlobal&); virtual~TGlobal(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; void*GetAddress() const; Int_",MatchSource.WIKI,root/html528/TGlobal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGlobal.html
https://root.cern/root/html528/TGlobal.html:6583,Modifiability,variab,variable,6583,"_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum TDictionary::ESTLType { kNone; kVector; kList; kDeque; kMap; kMultimap; kSet; kMultiset; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. DataMemberInfo_t*fInfopointer to CINT data member info. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGlobal(DataMemberInfo_t* info = 0); Default TGlobal ctor. TGlobals are constructed in TROOT via; a call to TCint::UpdateListOfGlobals(). TGlobal(const TGlobal& ); Copy constructor. TGlobal & operator=(const TGlobal& ); Assignment operator. ~TGlobal(); TGlobal dtor deletes adopted CINT DataMemberInfo object. void * GetAddress() const; Return address of global. Int_t GetArrayDim() const; Return number of array dimensions. Int_t GetMaxIndex(Int_t dim) const; Return maximum index for array dimension ""dim"". const char * GetTypeName() const; Get type of global variable, e,g.: ""class TDirectory*"" -> ""TDirectory"".; Result needs to be used or copied immediately. const char * GetFullTypeName() const; Get full type description of global variable, e,g.: ""class TDirectory*"". Long_t Property() const; Get property description word. For meaning of bits see EProperty. » Author: Rene Brun 13/11/95 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/meta:$Id: TGlobal.h 26606 2008-12-02 20:36:09Z pcanal $ » Last generated: 2010-09-23 20:10; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html528/TGlobal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGlobal.html
https://root.cern/root/html528/TGlobal.html:6758,Modifiability,variab,variable,6758,"_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum TDictionary::ESTLType { kNone; kVector; kList; kDeque; kMap; kMultimap; kSet; kMultiset; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. DataMemberInfo_t*fInfopointer to CINT data member info. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGlobal(DataMemberInfo_t* info = 0); Default TGlobal ctor. TGlobals are constructed in TROOT via; a call to TCint::UpdateListOfGlobals(). TGlobal(const TGlobal& ); Copy constructor. TGlobal & operator=(const TGlobal& ); Assignment operator. ~TGlobal(); TGlobal dtor deletes adopted CINT DataMemberInfo object. void * GetAddress() const; Return address of global. Int_t GetArrayDim() const; Return number of array dimensions. Int_t GetMaxIndex(Int_t dim) const; Return maximum index for array dimension ""dim"". const char * GetTypeName() const; Get type of global variable, e,g.: ""class TDirectory*"" -> ""TDirectory"".; Result needs to be used or copied immediately. const char * GetFullTypeName() const; Get full type description of global variable, e,g.: ""class TDirectory*"". Long_t Property() const; Get property description word. For meaning of bits see EProperty. » Author: Rene Brun 13/11/95 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/meta:$Id: TGlobal.h 26606 2008-12-02 20:36:09Z pcanal $ » Last generated: 2010-09-23 20:10; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html528/TGlobal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGlobal.html
https://root.cern/root/html528/TGlobal.html:488,Security,access,accessible,488,". TGlobal. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » META; » TGlobal. class TGlobal: public TDictionary. Global variables class (global variables are obtained from CINT).; This class describes the attributes of a global variable.; The TROOT class contains a list of all currently defined global; variables (accessible via TROOT::GetListOfGlobals()). Function Members (Methods); public:. TGlobal(DataMemberInfo_t* info = 0); TGlobal(const TGlobal&); virtual~TGlobal(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; void*GetAddress() const; Int_",MatchSource.WIKI,root/html528/TGlobal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGlobal.html
https://root.cern/root/html528/TGLObject.html:857,Availability,avail,available,857,". TGLObject. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLObject. class TGLObject: public TGLLogicalShape. Base-class for direct OpenGL renderers.; This allows classes to circumvent passing of TBuffer3D and; use user-provided OpenGL code.; By convention, if you want class TFoo : public TObject to have direct rendering; you should also provide TFooGL : public TGLObject and implement; abstract functions SetModel() and SetBBox().; TAttBBox can be used to facilitate calculation of bounding-boxes.; See TPointSet3D and TPointSet3DGL. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TGLObject(); voidTGLLogicalShape::AddRef(TGLPhysicalShape* phys) const; virtual Bool_tTGLLogicalShape::AlwaysSecondarySelect() const; const TGLBoundingBox&TGLLogicalShape::BoundingBox() const; static TClass*Class(); voidTGLLogicalShape::DestroyPhysicals(); virtual voidTGLLogicalShape::DirectDraw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DLCacheClear(); virtual voidTGLLogicalShape::DLCacheDrop(); virtual voidTGLLogicalShape::DLCachePurge(); virtual UInt_tTGLLogicalShape::DLOffset(Short_t) const; virtual voidTGLLogicalShape::Draw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DrawHighlight(TGLRnrCtx& rnrCtx, const TGLPhysicalShape* pshp, Int_t lvl = -1) const; TObject*TGLLogicalShape::GetExternal() const; const TGLPhysicalShape*TGLLogicalShape::GetFirstPhysical() const; static TClass*GetGLRenderer(TClass* isa); TGLScene*TGLLogicalShape::GetScene() const; TObject*TGLLogicalShape::ID() const; virtual Bool_tTGLLogicalShape::IgnoreSizeForOfInterest() const; voidTGLLogicalShape::InvokeContextMenu(TContextMenu& menu, UInt_t x, UInt_t y) const; virtual TClass*IsA() const; v",MatchSource.WIKI,root/html528/TGLObject.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLObject.html
https://root.cern/root/html528/TGLObject.html:2326,Performance,cache,cached,2326,"hape* phys) const; virtual Bool_tTGLLogicalShape::AlwaysSecondarySelect() const; const TGLBoundingBox&TGLLogicalShape::BoundingBox() const; static TClass*Class(); voidTGLLogicalShape::DestroyPhysicals(); virtual voidTGLLogicalShape::DirectDraw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DLCacheClear(); virtual voidTGLLogicalShape::DLCacheDrop(); virtual voidTGLLogicalShape::DLCachePurge(); virtual UInt_tTGLLogicalShape::DLOffset(Short_t) const; virtual voidTGLLogicalShape::Draw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DrawHighlight(TGLRnrCtx& rnrCtx, const TGLPhysicalShape* pshp, Int_t lvl = -1) const; TObject*TGLLogicalShape::GetExternal() const; const TGLPhysicalShape*TGLLogicalShape::GetFirstPhysical() const; static TClass*GetGLRenderer(TClass* isa); TGLScene*TGLLogicalShape::GetScene() const; TObject*TGLLogicalShape::ID() const; virtual Bool_tTGLLogicalShape::IgnoreSizeForOfInterest() const; voidTGLLogicalShape::InvokeContextMenu(TContextMenu& menu, UInt_t x, UInt_t y) const; virtual TClass*IsA() const; virtual Bool_tKeepDuringSmartRefresh() const; virtual voidTGLLogicalShape::ProcessSelection(TGLRnrCtx& rnrCtx, TGLSelectRecord& rec); virtual Short_tTGLLogicalShape::QuantizeShapeLOD(Short_t shapeLOD, Short_t combiLOD) const; UInt_tTGLLogicalShape::Ref() const; virtual voidSetBBox(); Bool_tTGLLogicalShape::SetDLCache(Bool_t cached); virtual Bool_tSetModel(TObject* obj, Option_t* opt = 0); virtual Bool_tShouldDLCache(const TGLRnrCtx& rnrCtx) const; virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); voidTGLLogicalShape::StrongRef(Bool_t strong) const; voidTGLLogicalShape::SubRef(TGLPhysicalShape* phys) const; virtual TGLLogicalShape::ELODAxesTGLLogicalShape::SupportedLODAxes() const; virtual Bool_tTGLLogicalShape::SupportsSecondarySelect() const; UInt_tTGLLogicalShape::UnrefFirstPhysical(); virtual voidUpdateBoundingBox(); voidTGLLogicalShape::UpdateBoundingBoxesOfPhysicals().",MatchSource.WIKI,root/html528/TGLObject.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLObject.html
https://root.cern/root/html528/TGLOrthoCamera.html:545,Availability,down,down,545,". TGLOrthoCamera. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLOrthoCamera. class TGLOrthoCamera: public TGLCamera. TGLOrthoCamera. Orthographic projection camera. Currently limited to three types; defined at construction time - kXOY, kXOZ, kZOY - where this refers; to the viewport plane axis - e.g. kXOY has X axis horizontal, Y; vertical - i.e. looking down Z axis with Y vertical. The plane types restriction could easily be removed to supported; arbitary ortho projections along any axis/orientation with free; rotations about them. Function Members (Methods); public:. TGLOrthoCamera(TGLOrthoCamera::EType type, const TGLVector3& hAxis, const TGLVector3& vAxis); virtual~TGLOrthoCamera(); Bool_tTGLCamera::AdjustAndClampVal(Double_t& val, Double_t min, Double_t max, Int_t screenShift, Int_t screenShiftRange, Bool_t mod1, Bool_t mod2) const; Double_tTGLCamera::AdjustDelta(Double_t screenShift, Double_t deltaFactor, Bool_t mod1, Bool_t mod2) const; virtual voidApply(const TGLBoundingBox& sceneBox, const TGLRect* pickRect = 0) const; static TClass*Class(); virtual voidConfigure(Double_t zoom, Double_t dolly, Double_t* center, Double_t hRotate, Double_t vRotate); virtual Bool_tDolly(Int_t delta, Bool_t mod1, Bool_t mod2); voidTGLCamera::DrawDebugAids() const; TGLVector3TGLCamera::EyeDirection() const; TGLVertex3TGLCamera::EyePoint() const; TGLVertex3TGLCamera::FrustumCenter() const; EOverlapTGLCamera::FrustumOverlap(const TGLBoundingBox& box) const; const TGLPlane&TGLCamera::FrustumPlane(TGLCamera::EFrustumPlane plane) const; const TGLMatrix&TGLCamera::GetCamBase() const; const TGLMatrix&TGLCamera::GetCamTrans() const; Double_t*TGLCamera::GetCenterVec(); Bool_tGetDollyToZoom() const; Bool_tGetEnableRotate() const; Bool_tTGLCamera::GetExternalCenter(); Double_tTGLCamera::GetFarClip() const;",MatchSource.WIKI,root/html528/TGLOrthoCamera.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLOrthoCamera.html
https://root.cern/root/html528/TGLOrthoCamera.html:10340,Availability,down,down,10340,"otate(Int_t xDelta, Int_t yDelta, Bool_t mod1, Bool_t mod2); Rotate the camera - 'swivel round the view volume center'.; Returns kTRUE is redraw required (camera change), kFALSE otherwise. void Apply(const TGLBoundingBox& sceneBox, const TGLRect* pickRect = 0) const; Apply the camera to the current GL context, setting the viewport, projection; and modelview matricies. After this verticies etc can be directly entered; in the world frame. This also updates the cached frustum values, enabling; all the projection, overlap tests etc defined in TGLCamera to be used. Arguments are:; 'box' - view volume box - ignored for ortho camera. Assumed to be same; as one passed to Setup().; 'pickRect' - optional picking rect. If non-null, restrict drawing to this; viewport rect. void Configure(Double_t zoom, Double_t dolly, Double_t* center, Double_t hRotate, Double_t vRotate); Configure the camera state.; zoom - set directly (default = 0.78);; dolly - additional move along the camera forward direction;; center - new camera center (can be 0 for no change);; hRotate - additional ""up/down"" rotation in radians;; vRotate - additional ""left/right"" rotation in radians. Bool_t IsOrthographic() const; { return kTRUE; }. void SetEnableRotate(Bool_t x); { fEnableRotate = x; }. Bool_t GetEnableRotate() const; { return fEnableRotate; }. Double_t GetZoomMin() const; { return fZoomMin; }. Double_t GetZoomMax() const; { return fZoomMax; }. void SetZoomMinMax(Double_t min, Double_t max); { SetZoomMin(min); SetZoomMax(max); }. void SetDollyToZoom(Bool_t x); { fDollyToZoom = x; }. Bool_t GetDollyToZoom() const; { return fDollyToZoom; }. » Author: Richard Maunder 25/05/2005 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/gl:$Id: TGLOrthoCamera.h 28212 2009-04-15 11:05:29Z matevz $ » Last generated: 2010-09-23 20:06; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html528/TGLOrthoCamera.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLOrthoCamera.html
https://root.cern/root/html528/TGLOrthoCamera.html:9710,Deployability,update,updates,9710,"ens 'focal length'. Returns kTRUE is redraw required (camera change), kFALSE otherwise. void SetZoomMin(Double_t z); Set minimum zoom factor. If current zoom is less than z it is; set to z. void SetZoomMax(Double_t z); Set maximum zoom factor. If current zoom is greater than z it; is set to z. Bool_t Truck(Int_t xDelta, Int_t yDelta, Bool_t mod1, Bool_t mod2); Truck the camera - 'move camera parallel to film plane'.; Returns kTRUE is redraw required (camera change), kFALSE otherwise. Bool_t Rotate(Int_t xDelta, Int_t yDelta, Bool_t mod1, Bool_t mod2); Rotate the camera - 'swivel round the view volume center'.; Returns kTRUE is redraw required (camera change), kFALSE otherwise. void Apply(const TGLBoundingBox& sceneBox, const TGLRect* pickRect = 0) const; Apply the camera to the current GL context, setting the viewport, projection; and modelview matricies. After this verticies etc can be directly entered; in the world frame. This also updates the cached frustum values, enabling; all the projection, overlap tests etc defined in TGLCamera to be used. Arguments are:; 'box' - view volume box - ignored for ortho camera. Assumed to be same; as one passed to Setup().; 'pickRect' - optional picking rect. If non-null, restrict drawing to this; viewport rect. void Configure(Double_t zoom, Double_t dolly, Double_t* center, Double_t hRotate, Double_t vRotate); Configure the camera state.; zoom - set directly (default = 0.78);; dolly - additional move along the camera forward direction;; center - new camera center (can be 0 for no change);; hRotate - additional ""up/down"" rotation in radians;; vRotate - additional ""left/right"" rotation in radians. Bool_t IsOrthographic() const; { return kTRUE; }. void SetEnableRotate(Bool_t x); { fEnableRotate = x; }. Bool_t GetEnableRotate() const; { return fEnableRotate; }. Double_t GetZoomMin() const; { return fZoomMin; }. Double_t GetZoomMax() const; { return fZoomMax; }. void SetZoomMinMax(Double_t min, Double_t max); { SetZoomMin(min); SetZo",MatchSource.WIKI,root/html528/TGLOrthoCamera.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLOrthoCamera.html
https://root.cern/root/html528/TGLOrthoCamera.html:5517,Performance,cache,cached,5517,"mera::UpdateCache() const. Data Members; public:. enum EType { kZOY; kXOZ; kXOY; kZnOY; kXnOZ; kXnOY; };; enum TGLCamera::EFrustumPlane { kNear; kLeft; kRight; kTop; kBottom; kFar; kPlanesPerFrustum; };. protected:. Bool_tTGLCamera::fCacheDirty! cached items dirty?; TGLMatrixTGLCamera::fCamBase! tranformation to center and rotation from up to x vector; TGLMatrixTGLCamera::fCamTrans! transformation relative to fCamTrans; TGLVector3*TGLCamera::fCenter! current camera center; TGLMatrixTGLCamera::fClipM! object space clip matrix (cached); TGLVector3TGLCamera::fDefCenter! deafult camera center; Double_tTGLCamera::fDollyDefault! default distnce from viewing centre; Double_tTGLCamera::fDollyDistance! unit distance for camera movement in fwd/bck direction; TGLVector3TGLCamera::fExtCenter! external camera center; Bool_tTGLCamera::fExternalCenter! use external center insead of scene center; TGLVector3TGLCamera::fFDCenter! fixed deafult camera center; Double_tTGLCamera::fFarClip! last applied far-clip; Bool_tTGLCamera::fFixDefCenter! use fixed default center; TGLPlaneTGLCamera::fFrustumPlanes[6]! frustum planes (cached); TGLBoundingBoxTGLCamera::fInterestBox! the interest box - created in UpdateInterest(); Double_tTGLCamera::fLargestSeen! largest box diagonal seen in OfInterest() - used when; TGLMatrixTGLCamera::fLastNoPickProjM! no-pick projection matrix (cached); TGLMatrixTGLCamera::fModVM! modelView matrix (cached); Double_tTGLCamera::fNearClip! last applied near-clip; TGLMatrixTGLCamera::fProjM! projection matrix (cached); UInt_tTGLCamera::fTimeStamp! timestamp; Float_tTGLCamera::fVAxisMinAngle! minimal allowed angle between up and fCamTrans Z vector; TGLRectTGLCamera::fViewport! viewport (GL coords - origin bottom left); static UInt_tTGLCamera::fgDollyDeltaSens. private:. Double_tfDefXSize; Double_tfDefYSize! x, y size of scene from camera view; Bool_tfDollyToZoom! zoom when dolly is requested; Bool_tfEnableRotate! enable rotation; TGLOrthoCamera::ETypefType! camera type; ",MatchSource.WIKI,root/html528/TGLOrthoCamera.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLOrthoCamera.html
https://root.cern/root/html528/TGLOrthoCamera.html:5803,Performance,cache,cached,5803,"mera::UpdateCache() const. Data Members; public:. enum EType { kZOY; kXOZ; kXOY; kZnOY; kXnOZ; kXnOY; };; enum TGLCamera::EFrustumPlane { kNear; kLeft; kRight; kTop; kBottom; kFar; kPlanesPerFrustum; };. protected:. Bool_tTGLCamera::fCacheDirty! cached items dirty?; TGLMatrixTGLCamera::fCamBase! tranformation to center and rotation from up to x vector; TGLMatrixTGLCamera::fCamTrans! transformation relative to fCamTrans; TGLVector3*TGLCamera::fCenter! current camera center; TGLMatrixTGLCamera::fClipM! object space clip matrix (cached); TGLVector3TGLCamera::fDefCenter! deafult camera center; Double_tTGLCamera::fDollyDefault! default distnce from viewing centre; Double_tTGLCamera::fDollyDistance! unit distance for camera movement in fwd/bck direction; TGLVector3TGLCamera::fExtCenter! external camera center; Bool_tTGLCamera::fExternalCenter! use external center insead of scene center; TGLVector3TGLCamera::fFDCenter! fixed deafult camera center; Double_tTGLCamera::fFarClip! last applied far-clip; Bool_tTGLCamera::fFixDefCenter! use fixed default center; TGLPlaneTGLCamera::fFrustumPlanes[6]! frustum planes (cached); TGLBoundingBoxTGLCamera::fInterestBox! the interest box - created in UpdateInterest(); Double_tTGLCamera::fLargestSeen! largest box diagonal seen in OfInterest() - used when; TGLMatrixTGLCamera::fLastNoPickProjM! no-pick projection matrix (cached); TGLMatrixTGLCamera::fModVM! modelView matrix (cached); Double_tTGLCamera::fNearClip! last applied near-clip; TGLMatrixTGLCamera::fProjM! projection matrix (cached); UInt_tTGLCamera::fTimeStamp! timestamp; Float_tTGLCamera::fVAxisMinAngle! minimal allowed angle between up and fCamTrans Z vector; TGLRectTGLCamera::fViewport! viewport (GL coords - origin bottom left); static UInt_tTGLCamera::fgDollyDeltaSens. private:. Double_tfDefXSize; Double_tfDefYSize! x, y size of scene from camera view; Bool_tfDollyToZoom! zoom when dolly is requested; Bool_tfEnableRotate! enable rotation; TGLOrthoCamera::ETypefType! camera type; ",MatchSource.WIKI,root/html528/TGLOrthoCamera.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLOrthoCamera.html
https://root.cern/root/html528/TGLOrthoCamera.html:6390,Performance,cache,cached,6390,"mera::UpdateCache() const. Data Members; public:. enum EType { kZOY; kXOZ; kXOY; kZnOY; kXnOZ; kXnOY; };; enum TGLCamera::EFrustumPlane { kNear; kLeft; kRight; kTop; kBottom; kFar; kPlanesPerFrustum; };. protected:. Bool_tTGLCamera::fCacheDirty! cached items dirty?; TGLMatrixTGLCamera::fCamBase! tranformation to center and rotation from up to x vector; TGLMatrixTGLCamera::fCamTrans! transformation relative to fCamTrans; TGLVector3*TGLCamera::fCenter! current camera center; TGLMatrixTGLCamera::fClipM! object space clip matrix (cached); TGLVector3TGLCamera::fDefCenter! deafult camera center; Double_tTGLCamera::fDollyDefault! default distnce from viewing centre; Double_tTGLCamera::fDollyDistance! unit distance for camera movement in fwd/bck direction; TGLVector3TGLCamera::fExtCenter! external camera center; Bool_tTGLCamera::fExternalCenter! use external center insead of scene center; TGLVector3TGLCamera::fFDCenter! fixed deafult camera center; Double_tTGLCamera::fFarClip! last applied far-clip; Bool_tTGLCamera::fFixDefCenter! use fixed default center; TGLPlaneTGLCamera::fFrustumPlanes[6]! frustum planes (cached); TGLBoundingBoxTGLCamera::fInterestBox! the interest box - created in UpdateInterest(); Double_tTGLCamera::fLargestSeen! largest box diagonal seen in OfInterest() - used when; TGLMatrixTGLCamera::fLastNoPickProjM! no-pick projection matrix (cached); TGLMatrixTGLCamera::fModVM! modelView matrix (cached); Double_tTGLCamera::fNearClip! last applied near-clip; TGLMatrixTGLCamera::fProjM! projection matrix (cached); UInt_tTGLCamera::fTimeStamp! timestamp; Float_tTGLCamera::fVAxisMinAngle! minimal allowed angle between up and fCamTrans Z vector; TGLRectTGLCamera::fViewport! viewport (GL coords - origin bottom left); static UInt_tTGLCamera::fgDollyDeltaSens. private:. Double_tfDefXSize; Double_tfDefYSize! x, y size of scene from camera view; Bool_tfDollyToZoom! zoom when dolly is requested; Bool_tfEnableRotate! enable rotation; TGLOrthoCamera::ETypefType! camera type; ",MatchSource.WIKI,root/html528/TGLOrthoCamera.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLOrthoCamera.html
https://root.cern/root/html528/TGLOrthoCamera.html:6639,Performance,cache,cached,6639,"mera::UpdateCache() const. Data Members; public:. enum EType { kZOY; kXOZ; kXOY; kZnOY; kXnOZ; kXnOY; };; enum TGLCamera::EFrustumPlane { kNear; kLeft; kRight; kTop; kBottom; kFar; kPlanesPerFrustum; };. protected:. Bool_tTGLCamera::fCacheDirty! cached items dirty?; TGLMatrixTGLCamera::fCamBase! tranformation to center and rotation from up to x vector; TGLMatrixTGLCamera::fCamTrans! transformation relative to fCamTrans; TGLVector3*TGLCamera::fCenter! current camera center; TGLMatrixTGLCamera::fClipM! object space clip matrix (cached); TGLVector3TGLCamera::fDefCenter! deafult camera center; Double_tTGLCamera::fDollyDefault! default distnce from viewing centre; Double_tTGLCamera::fDollyDistance! unit distance for camera movement in fwd/bck direction; TGLVector3TGLCamera::fExtCenter! external camera center; Bool_tTGLCamera::fExternalCenter! use external center insead of scene center; TGLVector3TGLCamera::fFDCenter! fixed deafult camera center; Double_tTGLCamera::fFarClip! last applied far-clip; Bool_tTGLCamera::fFixDefCenter! use fixed default center; TGLPlaneTGLCamera::fFrustumPlanes[6]! frustum planes (cached); TGLBoundingBoxTGLCamera::fInterestBox! the interest box - created in UpdateInterest(); Double_tTGLCamera::fLargestSeen! largest box diagonal seen in OfInterest() - used when; TGLMatrixTGLCamera::fLastNoPickProjM! no-pick projection matrix (cached); TGLMatrixTGLCamera::fModVM! modelView matrix (cached); Double_tTGLCamera::fNearClip! last applied near-clip; TGLMatrixTGLCamera::fProjM! projection matrix (cached); UInt_tTGLCamera::fTimeStamp! timestamp; Float_tTGLCamera::fVAxisMinAngle! minimal allowed angle between up and fCamTrans Z vector; TGLRectTGLCamera::fViewport! viewport (GL coords - origin bottom left); static UInt_tTGLCamera::fgDollyDeltaSens. private:. Double_tfDefXSize; Double_tfDefYSize! x, y size of scene from camera view; Bool_tfDollyToZoom! zoom when dolly is requested; Bool_tfEnableRotate! enable rotation; TGLOrthoCamera::ETypefType! camera type; ",MatchSource.WIKI,root/html528/TGLOrthoCamera.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLOrthoCamera.html
https://root.cern/root/html528/TGLOrthoCamera.html:6694,Performance,cache,cached,6694,"mera::UpdateCache() const. Data Members; public:. enum EType { kZOY; kXOZ; kXOY; kZnOY; kXnOZ; kXnOY; };; enum TGLCamera::EFrustumPlane { kNear; kLeft; kRight; kTop; kBottom; kFar; kPlanesPerFrustum; };. protected:. Bool_tTGLCamera::fCacheDirty! cached items dirty?; TGLMatrixTGLCamera::fCamBase! tranformation to center and rotation from up to x vector; TGLMatrixTGLCamera::fCamTrans! transformation relative to fCamTrans; TGLVector3*TGLCamera::fCenter! current camera center; TGLMatrixTGLCamera::fClipM! object space clip matrix (cached); TGLVector3TGLCamera::fDefCenter! deafult camera center; Double_tTGLCamera::fDollyDefault! default distnce from viewing centre; Double_tTGLCamera::fDollyDistance! unit distance for camera movement in fwd/bck direction; TGLVector3TGLCamera::fExtCenter! external camera center; Bool_tTGLCamera::fExternalCenter! use external center insead of scene center; TGLVector3TGLCamera::fFDCenter! fixed deafult camera center; Double_tTGLCamera::fFarClip! last applied far-clip; Bool_tTGLCamera::fFixDefCenter! use fixed default center; TGLPlaneTGLCamera::fFrustumPlanes[6]! frustum planes (cached); TGLBoundingBoxTGLCamera::fInterestBox! the interest box - created in UpdateInterest(); Double_tTGLCamera::fLargestSeen! largest box diagonal seen in OfInterest() - used when; TGLMatrixTGLCamera::fLastNoPickProjM! no-pick projection matrix (cached); TGLMatrixTGLCamera::fModVM! modelView matrix (cached); Double_tTGLCamera::fNearClip! last applied near-clip; TGLMatrixTGLCamera::fProjM! projection matrix (cached); UInt_tTGLCamera::fTimeStamp! timestamp; Float_tTGLCamera::fVAxisMinAngle! minimal allowed angle between up and fCamTrans Z vector; TGLRectTGLCamera::fViewport! viewport (GL coords - origin bottom left); static UInt_tTGLCamera::fgDollyDeltaSens. private:. Double_tfDefXSize; Double_tfDefYSize! x, y size of scene from camera view; Bool_tfDollyToZoom! zoom when dolly is requested; Bool_tfEnableRotate! enable rotation; TGLOrthoCamera::ETypefType! camera type; ",MatchSource.WIKI,root/html528/TGLOrthoCamera.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLOrthoCamera.html
https://root.cern/root/html528/TGLOrthoCamera.html:6804,Performance,cache,cached,6804,"mera::UpdateCache() const. Data Members; public:. enum EType { kZOY; kXOZ; kXOY; kZnOY; kXnOZ; kXnOY; };; enum TGLCamera::EFrustumPlane { kNear; kLeft; kRight; kTop; kBottom; kFar; kPlanesPerFrustum; };. protected:. Bool_tTGLCamera::fCacheDirty! cached items dirty?; TGLMatrixTGLCamera::fCamBase! tranformation to center and rotation from up to x vector; TGLMatrixTGLCamera::fCamTrans! transformation relative to fCamTrans; TGLVector3*TGLCamera::fCenter! current camera center; TGLMatrixTGLCamera::fClipM! object space clip matrix (cached); TGLVector3TGLCamera::fDefCenter! deafult camera center; Double_tTGLCamera::fDollyDefault! default distnce from viewing centre; Double_tTGLCamera::fDollyDistance! unit distance for camera movement in fwd/bck direction; TGLVector3TGLCamera::fExtCenter! external camera center; Bool_tTGLCamera::fExternalCenter! use external center insead of scene center; TGLVector3TGLCamera::fFDCenter! fixed deafult camera center; Double_tTGLCamera::fFarClip! last applied far-clip; Bool_tTGLCamera::fFixDefCenter! use fixed default center; TGLPlaneTGLCamera::fFrustumPlanes[6]! frustum planes (cached); TGLBoundingBoxTGLCamera::fInterestBox! the interest box - created in UpdateInterest(); Double_tTGLCamera::fLargestSeen! largest box diagonal seen in OfInterest() - used when; TGLMatrixTGLCamera::fLastNoPickProjM! no-pick projection matrix (cached); TGLMatrixTGLCamera::fModVM! modelView matrix (cached); Double_tTGLCamera::fNearClip! last applied near-clip; TGLMatrixTGLCamera::fProjM! projection matrix (cached); UInt_tTGLCamera::fTimeStamp! timestamp; Float_tTGLCamera::fVAxisMinAngle! minimal allowed angle between up and fCamTrans Z vector; TGLRectTGLCamera::fViewport! viewport (GL coords - origin bottom left); static UInt_tTGLCamera::fgDollyDeltaSens. private:. Double_tfDefXSize; Double_tfDefYSize! x, y size of scene from camera view; Bool_tfDollyToZoom! zoom when dolly is requested; Bool_tfEnableRotate! enable rotation; TGLOrthoCamera::ETypefType! camera type; ",MatchSource.WIKI,root/html528/TGLOrthoCamera.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLOrthoCamera.html
https://root.cern/root/html528/TGLOrthoCamera.html:9722,Performance,cache,cached,9722,"ens 'focal length'. Returns kTRUE is redraw required (camera change), kFALSE otherwise. void SetZoomMin(Double_t z); Set minimum zoom factor. If current zoom is less than z it is; set to z. void SetZoomMax(Double_t z); Set maximum zoom factor. If current zoom is greater than z it; is set to z. Bool_t Truck(Int_t xDelta, Int_t yDelta, Bool_t mod1, Bool_t mod2); Truck the camera - 'move camera parallel to film plane'.; Returns kTRUE is redraw required (camera change), kFALSE otherwise. Bool_t Rotate(Int_t xDelta, Int_t yDelta, Bool_t mod1, Bool_t mod2); Rotate the camera - 'swivel round the view volume center'.; Returns kTRUE is redraw required (camera change), kFALSE otherwise. void Apply(const TGLBoundingBox& sceneBox, const TGLRect* pickRect = 0) const; Apply the camera to the current GL context, setting the viewport, projection; and modelview matricies. After this verticies etc can be directly entered; in the world frame. This also updates the cached frustum values, enabling; all the projection, overlap tests etc defined in TGLCamera to be used. Arguments are:; 'box' - view volume box - ignored for ortho camera. Assumed to be same; as one passed to Setup().; 'pickRect' - optional picking rect. If non-null, restrict drawing to this; viewport rect. void Configure(Double_t zoom, Double_t dolly, Double_t* center, Double_t hRotate, Double_t vRotate); Configure the camera state.; zoom - set directly (default = 0.78);; dolly - additional move along the camera forward direction;; center - new camera center (can be 0 for no change);; hRotate - additional ""up/down"" rotation in radians;; vRotate - additional ""left/right"" rotation in radians. Bool_t IsOrthographic() const; { return kTRUE; }. void SetEnableRotate(Bool_t x); { fEnableRotate = x; }. Bool_t GetEnableRotate() const; { return fEnableRotate; }. Double_t GetZoomMin() const; { return fZoomMin; }. Double_t GetZoomMax() const; { return fZoomMax; }. void SetZoomMinMax(Double_t min, Double_t max); { SetZoomMin(min); SetZo",MatchSource.WIKI,root/html528/TGLOrthoCamera.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLOrthoCamera.html
https://root.cern/root/html528/TGLOrthoCamera.html:8646,Testability,log,logically,8646,"hAxis, const TGLVector3& vAxis); Construct orthographic camera. ~TGLOrthoCamera(); Destroy orthographic camera. void Setup(const TGLBoundingBox& box, Bool_t reset = kTRUE); Setup camera limits suitible to view the world volume defined by 'box'; and call Reset() to initialise camera. void Reset(); Reset the camera to defaults - trucking, zooming to reframe the world volume; established in Setup(). Note: limits defined in Setup() are not adjusted. Bool_t Dolly(Int_t delta, Bool_t mod1, Bool_t mod2); Dolly the camera.; By default the dolly is reinterpreted to zoom, but it can be; changed by modifying the fDollyToZoom data-member. Bool_t Zoom(Int_t delta, Bool_t mod1, Bool_t mod2); Zoom the camera - 'adjust lens focal length, retaining camera position'.; Arguments are:. 'delta' - mouse viewport delta (pixels) - +ive zoom in, -ive zoom out; 'mod1' / 'mod2' - sensitivity modifiers - see TGLCamera::AdjustAndClampVal(). For an orthographic camera dollying and zooming are identical and both equate; logically to a rescaling of the viewport limits - without center shift.; There is no perspective foreshortening or lens 'focal length'. Returns kTRUE is redraw required (camera change), kFALSE otherwise. void SetZoomMin(Double_t z); Set minimum zoom factor. If current zoom is less than z it is; set to z. void SetZoomMax(Double_t z); Set maximum zoom factor. If current zoom is greater than z it; is set to z. Bool_t Truck(Int_t xDelta, Int_t yDelta, Bool_t mod1, Bool_t mod2); Truck the camera - 'move camera parallel to film plane'.; Returns kTRUE is redraw required (camera change), kFALSE otherwise. Bool_t Rotate(Int_t xDelta, Int_t yDelta, Bool_t mod1, Bool_t mod2); Rotate the camera - 'swivel round the view volume center'.; Returns kTRUE is redraw required (camera change), kFALSE otherwise. void Apply(const TGLBoundingBox& sceneBox, const TGLRect* pickRect = 0) const; Apply the camera to the current GL context, setting the viewport, projection; and modelview matricies. After this v",MatchSource.WIKI,root/html528/TGLOrthoCamera.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLOrthoCamera.html
https://root.cern/root/html528/TGLOrthoCamera.html:9783,Testability,test,tests,9783,"ens 'focal length'. Returns kTRUE is redraw required (camera change), kFALSE otherwise. void SetZoomMin(Double_t z); Set minimum zoom factor. If current zoom is less than z it is; set to z. void SetZoomMax(Double_t z); Set maximum zoom factor. If current zoom is greater than z it; is set to z. Bool_t Truck(Int_t xDelta, Int_t yDelta, Bool_t mod1, Bool_t mod2); Truck the camera - 'move camera parallel to film plane'.; Returns kTRUE is redraw required (camera change), kFALSE otherwise. Bool_t Rotate(Int_t xDelta, Int_t yDelta, Bool_t mod1, Bool_t mod2); Rotate the camera - 'swivel round the view volume center'.; Returns kTRUE is redraw required (camera change), kFALSE otherwise. void Apply(const TGLBoundingBox& sceneBox, const TGLRect* pickRect = 0) const; Apply the camera to the current GL context, setting the viewport, projection; and modelview matricies. After this verticies etc can be directly entered; in the world frame. This also updates the cached frustum values, enabling; all the projection, overlap tests etc defined in TGLCamera to be used. Arguments are:; 'box' - view volume box - ignored for ortho camera. Assumed to be same; as one passed to Setup().; 'pickRect' - optional picking rect. If non-null, restrict drawing to this; viewport rect. void Configure(Double_t zoom, Double_t dolly, Double_t* center, Double_t hRotate, Double_t vRotate); Configure the camera state.; zoom - set directly (default = 0.78);; dolly - additional move along the camera forward direction;; center - new camera center (can be 0 for no change);; hRotate - additional ""up/down"" rotation in radians;; vRotate - additional ""left/right"" rotation in radians. Bool_t IsOrthographic() const; { return kTRUE; }. void SetEnableRotate(Bool_t x); { fEnableRotate = x; }. Bool_t GetEnableRotate() const; { return fEnableRotate; }. Double_t GetZoomMin() const; { return fZoomMin; }. Double_t GetZoomMax() const; { return fZoomMax; }. void SetZoomMinMax(Double_t min, Double_t max); { SetZoomMin(min); SetZo",MatchSource.WIKI,root/html528/TGLOrthoCamera.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLOrthoCamera.html
https://root.cern/root/html528/TGLOutput.html:321,Integrability,rout,routines,321,". TGLOutput. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLOutput. class TGLOutput. TGLOutput. Wrapper class for GL capture & output routines. Function Members (Methods); public:. TGLOutput(); TGLOutput(const TGLOutput&); virtual~TGLOutput(); static voidCapture(TGLViewer& viewer); static Bool_tCapture(TGLViewer& viewer, TGLOutput::EFormat format, const char* filePath = 0); static TClass*Class(); static voidCloseEmbeddedPS(); virtual TClass*IsA() const; TGLOutput&operator=(const TGLOutput&); virtual voidShowMembers(TMemberInspector& insp); static voidStartEmbeddedPS(); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). private:. static Bool_tCapturePostscript(TGLViewer& viewer, TGLOutput::EFormat format, const char* filePath). Data Members; public:. enum EFormat { kEPS_SIMPLE; kEPS_BSP; kPDF_SIMPLE; kPDF_BSP; };. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Bool_t Capture(TGLViewer& viewer, TGLOutput::EFormat format, const char* filePath = 0); Capture viewer to file. Arguments are:; 'viewer' - viewer object to capture from; 'format' - output format - only postscript types presently.; One of kEPS_SIMPLE, kEPS_BSP, kPDF_SIMPLE or kPDF_BSP; See TGLOutput::CapturePostscript() for meanings; 'filePath' - file output name. If null defaults to './viewer.eps' or './viewer.pdf'; depending on format requested. Note : Output files can be large and take considerable time (up to mins); to generate. Bool_t CapturePostscript(TGLViewer& viewer, TGLOutput::EFormat format, const char* filePath); Capture viewer to postscript file. Arguments are:; 'viewer' - viewer object to capture from; 'format' - output format; kEPS_SIMPLE - lower quality EPS; kEPS_BSP - higher quality EPS; kPDF_SIMPLE - lower quality PDF; kPDF_BSP - higher quality PDF; 'f",MatchSource.WIKI,root/html528/TGLOutput.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLOutput.html
https://root.cern/root/html528/TGLOutput.html:1540,Integrability,depend,depending,1540,"ePath = 0); static TClass*Class(); static voidCloseEmbeddedPS(); virtual TClass*IsA() const; TGLOutput&operator=(const TGLOutput&); virtual voidShowMembers(TMemberInspector& insp); static voidStartEmbeddedPS(); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). private:. static Bool_tCapturePostscript(TGLViewer& viewer, TGLOutput::EFormat format, const char* filePath). Data Members; public:. enum EFormat { kEPS_SIMPLE; kEPS_BSP; kPDF_SIMPLE; kPDF_BSP; };. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Bool_t Capture(TGLViewer& viewer, TGLOutput::EFormat format, const char* filePath = 0); Capture viewer to file. Arguments are:; 'viewer' - viewer object to capture from; 'format' - output format - only postscript types presently.; One of kEPS_SIMPLE, kEPS_BSP, kPDF_SIMPLE or kPDF_BSP; See TGLOutput::CapturePostscript() for meanings; 'filePath' - file output name. If null defaults to './viewer.eps' or './viewer.pdf'; depending on format requested. Note : Output files can be large and take considerable time (up to mins); to generate. Bool_t CapturePostscript(TGLViewer& viewer, TGLOutput::EFormat format, const char* filePath); Capture viewer to postscript file. Arguments are:; 'viewer' - viewer object to capture from; 'format' - output format; kEPS_SIMPLE - lower quality EPS; kEPS_BSP - higher quality EPS; kPDF_SIMPLE - lower quality PDF; kPDF_BSP - higher quality PDF; 'filePath' - file output name. If null defaults to './viewer.eps' or './viewer.pdf'; depending on format requested. void StartEmbeddedPS(); this function used by gl-in-pad. void CloseEmbeddedPS(); this function used by gl-in-pad; Restore the gVirtualPS output stream. void Capture(TGLViewer& viewer); this function used by gl-viewer, embedded into pad. virtual ~TGLOutput(); { }. » Author: Richard Maunder, Olivier Couet 02/07/2005 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/gl:$Id: TGLOutput.h 20882 2007-11-19 11",MatchSource.WIKI,root/html528/TGLOutput.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLOutput.html
https://root.cern/root/html528/TGLOutput.html:2084,Integrability,depend,depending,2084,"PS(); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). private:. static Bool_tCapturePostscript(TGLViewer& viewer, TGLOutput::EFormat format, const char* filePath). Data Members; public:. enum EFormat { kEPS_SIMPLE; kEPS_BSP; kPDF_SIMPLE; kPDF_BSP; };. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Bool_t Capture(TGLViewer& viewer, TGLOutput::EFormat format, const char* filePath = 0); Capture viewer to file. Arguments are:; 'viewer' - viewer object to capture from; 'format' - output format - only postscript types presently.; One of kEPS_SIMPLE, kEPS_BSP, kPDF_SIMPLE or kPDF_BSP; See TGLOutput::CapturePostscript() for meanings; 'filePath' - file output name. If null defaults to './viewer.eps' or './viewer.pdf'; depending on format requested. Note : Output files can be large and take considerable time (up to mins); to generate. Bool_t CapturePostscript(TGLViewer& viewer, TGLOutput::EFormat format, const char* filePath); Capture viewer to postscript file. Arguments are:; 'viewer' - viewer object to capture from; 'format' - output format; kEPS_SIMPLE - lower quality EPS; kEPS_BSP - higher quality EPS; kPDF_SIMPLE - lower quality PDF; kPDF_BSP - higher quality PDF; 'filePath' - file output name. If null defaults to './viewer.eps' or './viewer.pdf'; depending on format requested. void StartEmbeddedPS(); this function used by gl-in-pad. void CloseEmbeddedPS(); this function used by gl-in-pad; Restore the gVirtualPS output stream. void Capture(TGLViewer& viewer); this function used by gl-viewer, embedded into pad. virtual ~TGLOutput(); { }. » Author: Richard Maunder, Olivier Couet 02/07/2005 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/gl:$Id: TGLOutput.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2010-09-23 20:06; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html528/TGLOutput.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLOutput.html
https://root.cern/root/html528/TGLOverlayElement.html:496,Availability,avail,available,496,". TGLOverlayElement. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLOverlayElement. class TGLOverlayElement. An overlay element. Supports drawing (Render) and event-handling. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TGLOverlayElement(); static TClass*Class(); TGLOverlayElement::ERoleGetRole() const; TGLOverlayElement::EStateGetState() const; virtual Bool_tHandle(TGLRnrCtx& rnrCtx, TGLOvlSelectRecord& selRec, Event_t* event); virtual TClass*IsA() const; virtual Bool_tMouseEnter(TGLOvlSelectRecord& selRec); virtual voidMouseLeave(); virtual Bool_tMouseStillInside(TGLOvlSelectRecord& selRec); virtual voidRender(TGLRnrCtx& rnrCtx); voidSetBinaryState(Bool_t s); voidSetRole(TGLOverlayElement::ERole r); voidSetState(TGLOverlayElement::EState s); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). protected:. voidProjectionMatrixPushIdentity(). private:. TGLOverlayElement&operator=(const TGLOverlayElement&). Data Members; public:. enum ERole { kUser; kViewer; kAnnotation; kAll; };; enum EState { kInvisible; kDisabled; kActive; kAllVisible; };. protected:. TGLOverlayElement::ERolefRole; TGLOverlayElement::EStatefState. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Bool_t MouseEnter(TGLOvlSelectRecord& selRec); Mouse has enetered this element.; Return TRUE if you want additional events. Bool_t MouseStillInside(TGLOvlSelectRecord& selRec); A new overlay hit is about to be processed.; By returning FALSE one can force mouse-leave (MouseLeave will be; called shortly).; If you return TRUE, Handle will be called soon.; Use this if your overlay object has som",MatchSource.WIKI,root/html528/TGLOverlayElement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLOverlayElement.html
https://root.cern/root/html528/TGLPadPainter.html:501,Modifiability,inherit,inherit,501,". TGLPadPainter. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLPadPainter. class TGLPadPainter: public TVirtualPadPainter. ""Delegating"" part of TGLPadPainter. Line/fill/etc. attributes can be; set inside TPad, but not only there:; many of them are set by base sub-objects of 2d primitives; (2d primitives usually inherit TAttLine or TAttFill etc.). And these sub-objects; call gVirtualX->SetLineWidth ... etc. So, if I save some attributes in my painter,; it will be mess - at any moment I do not know, where to take line attribute - from; gVirtualX or from my own member. So! All attributed, _ALL_ go to/from gVirtualX. Function Members (Methods); public:. TGLPadPainter(); ~TGLPadPainter(); static TClass*Class(); virtual voidClearDrawable(); virtual voidCopyDrawable(Int_t id, Int_t px, Int_t py); virtual Int_tCreateDrawable(UInt_t w, UInt_t h); virtual voidDestroyDrawable(); virtual voidDrawBox(Double_t x1, Double_t y1, Double_t x2, Double_t y2, TVirtualPadPainter::EBoxMode mode); virtual voidDrawFillArea(Int_t n, const Double_t* x, const Double_t* y); virtual voidDrawFillArea(Int_t n, const Float_t* x, const Float_t* y); virtual voidDrawLine(Double_t x1, Double_t y1, Double_t x2, Double_t y2); virtual voidDrawLineNDC(Double_t u1, Double_t v1, Double_t u2, Double_t v2); virtual voidDrawPolyLine(Int_t n, const Double_t* x, const Double_t* y); virtual voidDrawPolyLine(Int_t n, const Float_t* x, const Float_t* y); virtual voidDrawPolyLineNDC(Int_t n, const Double_t* u, const Double_t* v); virtual voidDrawPolyMarker(Int_t n, const Double_t* x, const Double_t* y); virtual voidDrawPolyMarker(Int_t n, const Float_t* x, const Float_t* y); virtual voidDrawText(Double_t x, Double_t y, const char* text, TVirtualPadPainter::ETextMode mode); virtual voidDrawTextNDC(Double_t x, Double_t y, const char* t",MatchSource.WIKI,root/html528/TGLPadPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLPadPainter.html
https://root.cern/root/html528/TGLPadPainter.html:6173,Testability,test,test,6173,"tTextSize() const; Delegate to gVirtualX. Float_t GetTextMagnitude() const; Delegate to gVirtualX. void SetTextAlign(Short_t align); Delegate to gVirtualX. void SetTextAngle(Float_t tangle); Delegate to gVirtualX. void SetTextColor(Color_t tcolor); Delegate to gVirtualX. void SetTextFont(Font_t tfont); Delegate to gVirtualX. void SetTextSize(Float_t tsize); Delegate to gVirtualX. void SetTextSizePixels(Int_t npixels); Delegate to gVirtualX. Int_t CreateDrawable(UInt_t w, UInt_t h); Not required at the moment. void ClearDrawable(); Not required at the moment. void CopyDrawable(Int_t id, Int_t px, Int_t py); Not required at the moment. void DestroyDrawable(); Not required at the moment. void SelectDrawable(Int_t device); For gVirtualX this means select pixmap (or window); and all subsequent drawings will go into; this pixmap. For OpenGL this means the change of; coordinate system and viewport. void InitPainter(); Init gl-pad painter:; 1. 2D painter does not use depth test, should not modify; depth-buffer content (except initial cleanup).; 2. Disable cull face.; 3. Disable lighting.; 4. Set viewport (to the whole canvas area).; 5. Set camera.; 6. Unlock painter. void InvalidateCS(); When TPad::Range for gPad is called, projection; must be changed in OpenGL. void LockPainter(); Locked state of painter means, that; GL context can be invalid, so no GL calls; can be executed. void DrawLine(Double_t x1, Double_t y1, Double_t x2, Double_t y2); Draw line segment. void DrawLineNDC(Double_t u1, Double_t v1, Double_t u2, Double_t v2); Draw line segment in NDC coordinates. void DrawBox(Double_t x1, Double_t y1, Double_t x2, Double_t y2, TVirtualPadPainter::EBoxMode mode); Draw filled or hollow box. void DrawFillArea(Int_t n, const Double_t* x, const Double_t* y); Draw tesselated polygon (probably, outline only). void DrawFillArea(Int_t n, const Float_t* x, const Float_t* y); Draw tesselated polygon (never called, probably, since TPad::PaintFillArea for floats; is deprecated). voi",MatchSource.WIKI,root/html528/TGLPadPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLPadPainter.html
https://root.cern/root/html528/TGLPadPainter.html:7830,Testability,assert,assert,7830," x2, Double_t y2, TVirtualPadPainter::EBoxMode mode); Draw filled or hollow box. void DrawFillArea(Int_t n, const Double_t* x, const Double_t* y); Draw tesselated polygon (probably, outline only). void DrawFillArea(Int_t n, const Float_t* x, const Float_t* y); Draw tesselated polygon (never called, probably, since TPad::PaintFillArea for floats; is deprecated). void DrawPolyLine(Int_t n, const Double_t* x, const Double_t* y); Draw poly-line in user coordinates. void DrawPolyLine(Int_t n, const Float_t* x, const Float_t* y); Never called?. void DrawPolyLineNDC(Int_t n, const Double_t* u, const Double_t* v); Poly line in NDC. void DrawPolyMarker(Int_t n, const Double_t* x, const Double_t* y); Poly-marker. void DrawPolyMarker(Int_t n, const Float_t* x, const Float_t* y); Poly-marker. void DrawPolyMarker(); Poly-marker. void DrawText(Double_t x, Double_t y, const char* text, TVirtualPadPainter::ETextMode mode); Draw text. This operation is especially; dangerous if in locked state -; ftgl will assert on zero texture size; (which is result of bad GL context). void DrawTextNDC(Double_t x, Double_t y, const char* text, TVirtualPadPainter::ETextMode mode); Draw text in NDC. This operation is especially; dangerous if in locked state -; ftgl will assert on zero texture size; (which is result of bad GL context). void SaveProjectionMatrix() const; Save the projection matrix.; Attention! GL_PROJECTION will become the current matrix; after this call!. void RestoreProjectionMatrix() const; Restore the projection matrix.; Attention! GL_PROJECTION will become the current matrix; after this call!. void SaveModelviewMatrix() const; Save the modelview matrix.; Attention! GL_MODELVIEW will become the current matrix; after this call!. void RestoreModelviewMatrix() const; Restore the modelview matrix.; Attention! GL_MODELVIEW will become the current matrix; after this call!. void SaveViewport(); Extract and save the current viewport. void RestoreViewport(); Restore the saved viewport. void",MatchSource.WIKI,root/html528/TGLPadPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLPadPainter.html
https://root.cern/root/html528/TGLPadPainter.html:8082,Testability,assert,assert,8082,"t_t* y); Draw tesselated polygon (never called, probably, since TPad::PaintFillArea for floats; is deprecated). void DrawPolyLine(Int_t n, const Double_t* x, const Double_t* y); Draw poly-line in user coordinates. void DrawPolyLine(Int_t n, const Float_t* x, const Float_t* y); Never called?. void DrawPolyLineNDC(Int_t n, const Double_t* u, const Double_t* v); Poly line in NDC. void DrawPolyMarker(Int_t n, const Double_t* x, const Double_t* y); Poly-marker. void DrawPolyMarker(Int_t n, const Float_t* x, const Float_t* y); Poly-marker. void DrawPolyMarker(); Poly-marker. void DrawText(Double_t x, Double_t y, const char* text, TVirtualPadPainter::ETextMode mode); Draw text. This operation is especially; dangerous if in locked state -; ftgl will assert on zero texture size; (which is result of bad GL context). void DrawTextNDC(Double_t x, Double_t y, const char* text, TVirtualPadPainter::ETextMode mode); Draw text in NDC. This operation is especially; dangerous if in locked state -; ftgl will assert on zero texture size; (which is result of bad GL context). void SaveProjectionMatrix() const; Save the projection matrix.; Attention! GL_PROJECTION will become the current matrix; after this call!. void RestoreProjectionMatrix() const; Restore the projection matrix.; Attention! GL_PROJECTION will become the current matrix; after this call!. void SaveModelviewMatrix() const; Save the modelview matrix.; Attention! GL_MODELVIEW will become the current matrix; after this call!. void RestoreModelviewMatrix() const; Restore the modelview matrix.; Attention! GL_MODELVIEW will become the current matrix; after this call!. void SaveViewport(); Extract and save the current viewport. void RestoreViewport(); Restore the saved viewport. void SaveImage(TVirtualPad* pad, const char* fileName, Int_t type) const; Using TImage save frame-buffer contents as a picture. TGLPadPainter(). » Author: Timur Pocheptsov 06/05/2009 » Copyright (C) 1995-2009, Rene Brun and Fons Rademakers. *; » Last chang",MatchSource.WIKI,root/html528/TGLPadPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLPadPainter.html
https://root.cern/root/html528/TGLPaintDevice.html:493,Availability,avail,available,493,". TGLPaintDevice. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TGLPaintDevice. class TGLPaintDevice. TVirtualGL. The TVirtualGL class is an abstract base class defining the; OpenGL interface protocol. All interactions with OpenGL should be; done via the global pointer gVirtualGL. If the OpenGL library is; available this pointer is pointing to an instance of the TGLKernel; class which provides the actual interface to OpenGL. Using this; scheme of ABC we can use OpenGL in other parts of the framework; without having to link with the OpenGL library in case we don't; use the classes using OpenGL. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TGLPaintDevice(); static TClass*Class(); virtual voidExtractViewport(Int_t* vp) const; virtual const TGLContext*GetContext() const; virtual const TGLFormat*GetPixelFormat() const; virtual TClass*IsA() const; virtual Bool_tMakeCurrent(); TGLPaintDevice&operator=(const TGLPaintDevice&); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidSwapBuffers(). private:. virtual voidAddContext(TGLContext* ctx); virtual voidRemoveContext(TGLContext* ctx). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void ExtractViewport(Int_t ctxInd, Int_t *vp); Off-screen device holds sizes for glViewport. Bool_t MakeCurrent(Int_t ctxInd); ]; Make the gl context current. virtual ~TGLPaintDevice(); {}. void SwapBuffers(). const TGLFormat * GetPixelFormat() const. const TGLContext * GetContext() const. void AddContext(TGLContext* ctx). void RemoveContext(TGLContext* ctx). » Author: Valery Fine(fine@vxcern.cern.ch) 05/03/97 » Copyrig",MatchSource.WIKI,root/html528/TGLPaintDevice.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLPaintDevice.html
https://root.cern/root/html528/TGLPaintDevice.html:920,Availability,avail,available,920,". TGLPaintDevice. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TGLPaintDevice. class TGLPaintDevice. TVirtualGL. The TVirtualGL class is an abstract base class defining the; OpenGL interface protocol. All interactions with OpenGL should be; done via the global pointer gVirtualGL. If the OpenGL library is; available this pointer is pointing to an instance of the TGLKernel; class which provides the actual interface to OpenGL. Using this; scheme of ABC we can use OpenGL in other parts of the framework; without having to link with the OpenGL library in case we don't; use the classes using OpenGL. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TGLPaintDevice(); static TClass*Class(); virtual voidExtractViewport(Int_t* vp) const; virtual const TGLContext*GetContext() const; virtual const TGLFormat*GetPixelFormat() const; virtual TClass*IsA() const; virtual Bool_tMakeCurrent(); TGLPaintDevice&operator=(const TGLPaintDevice&); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidSwapBuffers(). private:. virtual voidAddContext(TGLContext* ctx); virtual voidRemoveContext(TGLContext* ctx). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void ExtractViewport(Int_t ctxInd, Int_t *vp); Off-screen device holds sizes for glViewport. Bool_t MakeCurrent(Int_t ctxInd); ]; Make the gl context current. virtual ~TGLPaintDevice(); {}. void SwapBuffers(). const TGLFormat * GetPixelFormat() const. const TGLContext * GetContext() const. void AddContext(TGLContext* ctx). void RemoveContext(TGLContext* ctx). » Author: Valery Fine(fine@vxcern.cern.ch) 05/03/97 » Copyrig",MatchSource.WIKI,root/html528/TGLPaintDevice.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLPaintDevice.html
https://root.cern/root/html528/TGLPaintDevice.html:367,Integrability,interface,interface,367,". TGLPaintDevice. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TGLPaintDevice. class TGLPaintDevice. TVirtualGL. The TVirtualGL class is an abstract base class defining the; OpenGL interface protocol. All interactions with OpenGL should be; done via the global pointer gVirtualGL. If the OpenGL library is; available this pointer is pointing to an instance of the TGLKernel; class which provides the actual interface to OpenGL. Using this; scheme of ABC we can use OpenGL in other parts of the framework; without having to link with the OpenGL library in case we don't; use the classes using OpenGL. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TGLPaintDevice(); static TClass*Class(); virtual voidExtractViewport(Int_t* vp) const; virtual const TGLContext*GetContext() const; virtual const TGLFormat*GetPixelFormat() const; virtual TClass*IsA() const; virtual Bool_tMakeCurrent(); TGLPaintDevice&operator=(const TGLPaintDevice&); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidSwapBuffers(). private:. virtual voidAddContext(TGLContext* ctx); virtual voidRemoveContext(TGLContext* ctx). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void ExtractViewport(Int_t ctxInd, Int_t *vp); Off-screen device holds sizes for glViewport. Bool_t MakeCurrent(Int_t ctxInd); ]; Make the gl context current. virtual ~TGLPaintDevice(); {}. void SwapBuffers(). const TGLFormat * GetPixelFormat() const. const TGLContext * GetContext() const. void AddContext(TGLContext* ctx). void RemoveContext(TGLContext* ctx). » Author: Valery Fine(fine@vxcern.cern.ch) 05/03/97 » Copyrig",MatchSource.WIKI,root/html528/TGLPaintDevice.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLPaintDevice.html
https://root.cern/root/html528/TGLPaintDevice.html:377,Integrability,protocol,protocol,377,". TGLPaintDevice. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TGLPaintDevice. class TGLPaintDevice. TVirtualGL. The TVirtualGL class is an abstract base class defining the; OpenGL interface protocol. All interactions with OpenGL should be; done via the global pointer gVirtualGL. If the OpenGL library is; available this pointer is pointing to an instance of the TGLKernel; class which provides the actual interface to OpenGL. Using this; scheme of ABC we can use OpenGL in other parts of the framework; without having to link with the OpenGL library in case we don't; use the classes using OpenGL. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TGLPaintDevice(); static TClass*Class(); virtual voidExtractViewport(Int_t* vp) const; virtual const TGLContext*GetContext() const; virtual const TGLFormat*GetPixelFormat() const; virtual TClass*IsA() const; virtual Bool_tMakeCurrent(); TGLPaintDevice&operator=(const TGLPaintDevice&); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidSwapBuffers(). private:. virtual voidAddContext(TGLContext* ctx); virtual voidRemoveContext(TGLContext* ctx). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void ExtractViewport(Int_t ctxInd, Int_t *vp); Off-screen device holds sizes for glViewport. Bool_t MakeCurrent(Int_t ctxInd); ]; Make the gl context current. virtual ~TGLPaintDevice(); {}. void SwapBuffers(). const TGLFormat * GetPixelFormat() const. const TGLContext * GetContext() const. void AddContext(TGLContext* ctx). void RemoveContext(TGLContext* ctx). » Author: Valery Fine(fine@vxcern.cern.ch) 05/03/97 » Copyrig",MatchSource.WIKI,root/html528/TGLPaintDevice.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLPaintDevice.html
https://root.cern/root/html528/TGLPaintDevice.html:593,Integrability,interface,interface,593,". TGLPaintDevice. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TGLPaintDevice. class TGLPaintDevice. TVirtualGL. The TVirtualGL class is an abstract base class defining the; OpenGL interface protocol. All interactions with OpenGL should be; done via the global pointer gVirtualGL. If the OpenGL library is; available this pointer is pointing to an instance of the TGLKernel; class which provides the actual interface to OpenGL. Using this; scheme of ABC we can use OpenGL in other parts of the framework; without having to link with the OpenGL library in case we don't; use the classes using OpenGL. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TGLPaintDevice(); static TClass*Class(); virtual voidExtractViewport(Int_t* vp) const; virtual const TGLContext*GetContext() const; virtual const TGLFormat*GetPixelFormat() const; virtual TClass*IsA() const; virtual Bool_tMakeCurrent(); TGLPaintDevice&operator=(const TGLPaintDevice&); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidSwapBuffers(). private:. virtual voidAddContext(TGLContext* ctx); virtual voidRemoveContext(TGLContext* ctx). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void ExtractViewport(Int_t ctxInd, Int_t *vp); Off-screen device holds sizes for glViewport. Bool_t MakeCurrent(Int_t ctxInd); ]; Make the gl context current. virtual ~TGLPaintDevice(); {}. void SwapBuffers(). const TGLFormat * GetPixelFormat() const. const TGLContext * GetContext() const. void AddContext(TGLContext* ctx). void RemoveContext(TGLContext* ctx). » Author: Valery Fine(fine@vxcern.cern.ch) 05/03/97 » Copyrig",MatchSource.WIKI,root/html528/TGLPaintDevice.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLPaintDevice.html
https://root.cern/root/html528/TGLParametricEquation.html:2424,Availability,error,error,2424,"LParametricEquation(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; voidEvalVertex(TGLVertex3& newVertex, Double_t u, Double_t v) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; Rgl::Range_tGetURange() const; Rgl::Range_tGetVRange() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, c",MatchSource.WIKI,root/html528/TGLParametricEquation.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLParametricEquation.html
https://root.cern/root/html528/TGLParametricEquation.html:2508,Availability,error,error,2508,"l voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; voidEvalVertex(TGLVertex3& newVertex, Double_t u, Double_t v) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; Rgl::Range_tGetURange() const; Rgl::Range_tGetVRange() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname)",MatchSource.WIKI,root/html528/TGLParametricEquation.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLParametricEquation.html
https://root.cern/root/html528/TGLParametricEquation.html:7330,Availability,error,errors,7330,"const TGLParametricEquation&). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. Bool_tfConstrained; ParametricEquation_tfEquation; Bool_tfModified; auto_ptr<TGLHistPainter>fPainter; pair<double,double>fURange; pair<double,double>fVRange; auto_ptr<TF2>fXEquation; auto_ptr<TF2>fYEquation; auto_ptr<TF2>fZEquation. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLParametricEquation(const TString& name, const TString& xEquation, const TString& yEquation, const TString& zEquation, Double_t uMin, Double_t uMax, Double_t vMin, Double_t vMax); Surface is defined by three strings.; ROOT does not use exceptions in ctors,; so, I have to use MakeZombie to let; external user know about errors. TGLParametricEquation(const TString& name, ParametricEquation_t equation, Double_t uMin, Double_t uMax, Double_t vMin, Double_t vMax); Surface defined by user's function (see ParametricEquation_t declaration in TGLParametricEquation.h). Rgl::Range_t GetURange() const; [uMin, uMax]. Rgl::Range_t GetVRange() const; [vMin, vMax]. Bool_t IsConstrained() const; Check is constrained. void SetConstrained(Bool_t c); Set constrained. Bool_t IsModified() const; Something was changed in parametric equation (or constrained option was changed). void SetModified(Bool_t m); Set modified. void EvalVertex(TGLVertex3& newVertex, Double_t u, Double_t v) const; Calculate vertex. Int_t DistancetoPrimitive(Int_t px, Int_t py); Check, if parametric surface is under cursor. void ExecuteEvent(Int_t event, Int_t px, Int_t py); Pass event to painter. char * GetObjectInfo(Int_t px, Int_t py) const; No object info yet. void Paint(Option_t* option); Delegate p",MatchSource.WIKI,root/html528/TGLParametricEquation.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLParametricEquation.html
https://root.cern/root/html528/TGLParametricEquationGL.html:344,Integrability,wrap,wrapper,344,". TGLParametricEquationGL. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLParametricEquationGL. class TGLParametricEquationGL: public TGLPlot3D. GL-renderer wrapper for TGLParametricEquation.; This allows rendering of parametric-equations in standard GL viewer. Function Members (Methods); public:. TGLParametricEquationGL(); virtual~TGLParametricEquationGL(); voidTGLLogicalShape::AddRef(TGLPhysicalShape* phys) const; virtual Bool_tTGLLogicalShape::AlwaysSecondarySelect() const; const TGLBoundingBox&TGLLogicalShape::BoundingBox() const; static TClass*Class(); static TGLPlot3D*TGLPlot3D::CreatePlot(TObject* obj, Option_t* opt, TVirtualPad* pad); static TGLPlot3D*TGLPlot3D::CreatePlot(TObject* obj, Option_t* opt, Bool_t logx, Bool_t logy, Bool_t logz); voidTGLLogicalShape::DestroyPhysicals(); virtual voidDirectDraw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DLCacheClear(); virtual voidTGLLogicalShape::DLCacheDrop(); virtual voidTGLLogicalShape::DLCachePurge(); virtual UInt_tTGLLogicalShape::DLOffset(Short_t) const; virtual voidTGLLogicalShape::Draw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DrawHighlight(TGLRnrCtx& rnrCtx, const TGLPhysicalShape* pshp, Int_t lvl = -1) const; TObject*TGLLogicalShape::GetExternal() const; const TGLPhysicalShape*TGLLogicalShape::GetFirstPhysical() const; static TClass*TGLObject::GetGLRenderer(TClass* isa); TGLScene*TGLLogicalShape::GetScene() const; TObject*TGLLogicalShape::ID() const; virtual Bool_tTGLLogicalShape::IgnoreSizeForOfInterest() const; voidTGLLogicalShape::InvokeContextMenu(TContextMenu& menu, UInt_t x, UInt_t y) const; virtual TClass*IsA() const; virtual Bool_tKeepDuringSmartRefresh() const; virtual voidTGLLogicalShape::ProcessSelection(TGLRnrCtx& rnrCtx, TGLSelectRecord& rec); virtual Short_tTGLLogicalShape::QuantizeSh",MatchSource.WIKI,root/html528/TGLParametricEquationGL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLParametricEquationGL.html
https://root.cern/root/html528/TGLParametricEquationGL.html:2151,Performance,cache,cached,2151,"obj, Option_t* opt, TVirtualPad* pad); static TGLPlot3D*TGLPlot3D::CreatePlot(TObject* obj, Option_t* opt, Bool_t logx, Bool_t logy, Bool_t logz); voidTGLLogicalShape::DestroyPhysicals(); virtual voidDirectDraw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DLCacheClear(); virtual voidTGLLogicalShape::DLCacheDrop(); virtual voidTGLLogicalShape::DLCachePurge(); virtual UInt_tTGLLogicalShape::DLOffset(Short_t) const; virtual voidTGLLogicalShape::Draw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DrawHighlight(TGLRnrCtx& rnrCtx, const TGLPhysicalShape* pshp, Int_t lvl = -1) const; TObject*TGLLogicalShape::GetExternal() const; const TGLPhysicalShape*TGLLogicalShape::GetFirstPhysical() const; static TClass*TGLObject::GetGLRenderer(TClass* isa); TGLScene*TGLLogicalShape::GetScene() const; TObject*TGLLogicalShape::ID() const; virtual Bool_tTGLLogicalShape::IgnoreSizeForOfInterest() const; voidTGLLogicalShape::InvokeContextMenu(TContextMenu& menu, UInt_t x, UInt_t y) const; virtual TClass*IsA() const; virtual Bool_tKeepDuringSmartRefresh() const; virtual voidTGLLogicalShape::ProcessSelection(TGLRnrCtx& rnrCtx, TGLSelectRecord& rec); virtual Short_tTGLLogicalShape::QuantizeShapeLOD(Short_t shapeLOD, Short_t combiLOD) const; UInt_tTGLLogicalShape::Ref() const; virtual voidSetBBox(); Bool_tTGLLogicalShape::SetDLCache(Bool_t cached); virtual Bool_tSetModel(TObject* obj, Option_t* opt = 0); virtual Bool_tTGLObject::ShouldDLCache(const TGLRnrCtx& rnrCtx) const; virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); voidTGLLogicalShape::StrongRef(Bool_t strong) const; voidTGLLogicalShape::SubRef(TGLPhysicalShape* phys) const; virtual TGLLogicalShape::ELODAxesTGLLogicalShape::SupportedLODAxes() const; virtual Bool_tTGLLogicalShape::SupportsSecondarySelect() const; UInt_tTGLLogicalShape::UnrefFirstPhysical(); virtual voidTGLObject::UpdateBoundingBox(); voidTGLLogicalShape::UpdateBoundingBoxesOfPhysicals().",MatchSource.WIKI,root/html528/TGLParametricEquationGL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLParametricEquationGL.html
https://root.cern/root/html528/TGLParametricEquationGL.html:913,Testability,log,logx,913," TGLParametricEquationGL(); virtual~TGLParametricEquationGL(); voidTGLLogicalShape::AddRef(TGLPhysicalShape* phys) const; virtual Bool_tTGLLogicalShape::AlwaysSecondarySelect() const; const TGLBoundingBox&TGLLogicalShape::BoundingBox() const; static TClass*Class(); static TGLPlot3D*TGLPlot3D::CreatePlot(TObject* obj, Option_t* opt, TVirtualPad* pad); static TGLPlot3D*TGLPlot3D::CreatePlot(TObject* obj, Option_t* opt, Bool_t logx, Bool_t logy, Bool_t logz); voidTGLLogicalShape::DestroyPhysicals(); virtual voidDirectDraw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DLCacheClear(); virtual voidTGLLogicalShape::DLCacheDrop(); virtual voidTGLLogicalShape::DLCachePurge(); virtual UInt_tTGLLogicalShape::DLOffset(Short_t) const; virtual voidTGLLogicalShape::Draw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DrawHighlight(TGLRnrCtx& rnrCtx, const TGLPhysicalShape* pshp, Int_t lvl = -1) const; TObject*TGLLogicalShape::GetExternal() const; const TGLPhysicalShape*TGLLogicalShape::GetFirstPhysical() const; static TClass*TGLObject::GetGLRenderer(TClass* isa); TGLScene*TGLLogicalShape::GetScene() const; TObject*TGLLogicalShape::ID() const; virtual Bool_tTGLLogicalShape::IgnoreSizeForOfInterest() const; voidTGLLogicalShape::InvokeContextMenu(TContextMenu& menu, UInt_t x, UInt_t y) const; virtual TClass*IsA() const; virtual Bool_tKeepDuringSmartRefresh() const; virtual voidTGLLogicalShape::ProcessSelection(TGLRnrCtx& rnrCtx, TGLSelectRecord& rec); virtual Short_tTGLLogicalShape::QuantizeSh",MatchSource.WIKI,root/html528/TGLParametricEquationGL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLParametricEquationGL.html
https://root.cern/root/html528/TGLParametricEquationGL.html:926,Testability,log,logy,926," TGLParametricEquationGL(); virtual~TGLParametricEquationGL(); voidTGLLogicalShape::AddRef(TGLPhysicalShape* phys) const; virtual Bool_tTGLLogicalShape::AlwaysSecondarySelect() const; const TGLBoundingBox&TGLLogicalShape::BoundingBox() const; static TClass*Class(); static TGLPlot3D*TGLPlot3D::CreatePlot(TObject* obj, Option_t* opt, TVirtualPad* pad); static TGLPlot3D*TGLPlot3D::CreatePlot(TObject* obj, Option_t* opt, Bool_t logx, Bool_t logy, Bool_t logz); voidTGLLogicalShape::DestroyPhysicals(); virtual voidDirectDraw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DLCacheClear(); virtual voidTGLLogicalShape::DLCacheDrop(); virtual voidTGLLogicalShape::DLCachePurge(); virtual UInt_tTGLLogicalShape::DLOffset(Short_t) const; virtual voidTGLLogicalShape::Draw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DrawHighlight(TGLRnrCtx& rnrCtx, const TGLPhysicalShape* pshp, Int_t lvl = -1) const; TObject*TGLLogicalShape::GetExternal() const; const TGLPhysicalShape*TGLLogicalShape::GetFirstPhysical() const; static TClass*TGLObject::GetGLRenderer(TClass* isa); TGLScene*TGLLogicalShape::GetScene() const; TObject*TGLLogicalShape::ID() const; virtual Bool_tTGLLogicalShape::IgnoreSizeForOfInterest() const; voidTGLLogicalShape::InvokeContextMenu(TContextMenu& menu, UInt_t x, UInt_t y) const; virtual TClass*IsA() const; virtual Bool_tKeepDuringSmartRefresh() const; virtual voidTGLLogicalShape::ProcessSelection(TGLRnrCtx& rnrCtx, TGLSelectRecord& rec); virtual Short_tTGLLogicalShape::QuantizeSh",MatchSource.WIKI,root/html528/TGLParametricEquationGL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLParametricEquationGL.html
https://root.cern/root/html528/TGLParametricEquationGL.html:939,Testability,log,logz,939," TGLParametricEquationGL(); virtual~TGLParametricEquationGL(); voidTGLLogicalShape::AddRef(TGLPhysicalShape* phys) const; virtual Bool_tTGLLogicalShape::AlwaysSecondarySelect() const; const TGLBoundingBox&TGLLogicalShape::BoundingBox() const; static TClass*Class(); static TGLPlot3D*TGLPlot3D::CreatePlot(TObject* obj, Option_t* opt, TVirtualPad* pad); static TGLPlot3D*TGLPlot3D::CreatePlot(TObject* obj, Option_t* opt, Bool_t logx, Bool_t logy, Bool_t logz); voidTGLLogicalShape::DestroyPhysicals(); virtual voidDirectDraw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DLCacheClear(); virtual voidTGLLogicalShape::DLCacheDrop(); virtual voidTGLLogicalShape::DLCachePurge(); virtual UInt_tTGLLogicalShape::DLOffset(Short_t) const; virtual voidTGLLogicalShape::Draw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DrawHighlight(TGLRnrCtx& rnrCtx, const TGLPhysicalShape* pshp, Int_t lvl = -1) const; TObject*TGLLogicalShape::GetExternal() const; const TGLPhysicalShape*TGLLogicalShape::GetFirstPhysical() const; static TClass*TGLObject::GetGLRenderer(TClass* isa); TGLScene*TGLLogicalShape::GetScene() const; TObject*TGLLogicalShape::ID() const; virtual Bool_tTGLLogicalShape::IgnoreSizeForOfInterest() const; voidTGLLogicalShape::InvokeContextMenu(TContextMenu& menu, UInt_t x, UInt_t y) const; virtual TClass*IsA() const; virtual Bool_tKeepDuringSmartRefresh() const; virtual voidTGLLogicalShape::ProcessSelection(TGLRnrCtx& rnrCtx, TGLSelectRecord& rec); virtual Short_tTGLLogicalShape::QuantizeSh",MatchSource.WIKI,root/html528/TGLParametricEquationGL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLParametricEquationGL.html
https://root.cern/root/html528/TGLParametricPlot.html:5167,Usability,simpl,simple,5167,"TAxis*TGLPlotPainter::fZAxis; vector<Double_t>TGLPlotPainter::fZLevels. private:. Int_tfColorScheme; TGLParametricEquation*fEquation; TGL2DArray<TGLParametricPlot::Vertex_t>fMesh; Int_tfMeshSize; Bool_tfShowMesh. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLParametricPlot(TGLParametricEquation* equation, TGLPlotCamera* camera); Constructor. Bool_t InitGeometry(); Build mesh. The surface is 'immutable':; the only reason to rebuild it - the change in size or; if one of equations contain reference to TF2 function, whose; parameters were changed. void StartPan(Int_t px, Int_t py); User clicks right mouse button (in a pad). void Pan(Int_t px, Int_t py); User's moving mouse cursor, with middle mouse button pressed (for pad).; Calculate 3d shift related to 2d mouse movement. char * GetPlotInfo(Int_t px, Int_t py); No object info yet. void AddOption(const TString& option); No additional options for parametric surfaces. void ProcessEvent(Int_t event, Int_t px, Int_t py); Change color/mesh size or switch on/off mesh/box cut.; Left double click - remove box cut. void InitGL() const; Initialize gl state. void DeInitGL() const; Initialize gl state. void DrawPlot() const; Draw parametric surface. void InitColors(); Calculate colors for vertices,; using one of 20 color themes.; -1 simple 'metal' surface. void DrawSectionXOZ() const; No such sections. void DrawSectionYOZ() const; No such sections. void DrawSectionXOY() const; No such sections. void SetSurfaceColor() const; Set material properties. TGLParametricPlot(TGLParametricEquation* equation, TGLPlotCamera* camera). » Author: Timur Pocheptsov 26/01/2007 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/gl:$Id: TGLParametric.h 28464 2009-05-06 12:37:21Z brun $ » Last generated: 2010-09-23 20:06; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html528/TGLParametricPlot.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLParametricPlot.html
https://root.cern/root/html528/TGLPerspectiveCamera.html:8841,Availability,down,down,8841,"Setup() are not adjusted. Bool_t Zoom(Int_t delta, Bool_t mod1, Bool_t mod2); Zoom the camera - 'adjust lens focal length, retaining camera position'.; Arguments are:. 'delta' - mouse viewport delta (pixels) - +ive zoom in, -ive zoom out; 'mod1' / 'mod2' - sensitivity modifiers - see TGLCamera::AdjustAndClampVal(). Returns kTRUE is redraw required (camera change), kFALSE otherwise. Bool_t Truck(Int_t xDelta, Int_t yDelta, Bool_t mod1, Bool_t mod2); Truck the camera - 'move camera parallel to film plane'.; Returns kTRUE is redraw required (camera change), kFALSE otherwise. void Apply(const TGLBoundingBox& box, const TGLRect* pickRect = 0) const; Apply the camera to the current GL context, setting the viewport, projection; and modelview matricies. After this verticies etc can be directly entered; in the world frame. This also updates the cached frustum values, enabling; all the projection, overlap tests etc defined in TGLCamera to be used. Arguments are:; 'box' - view volume box - used to adjust near/far clipping; 'pickRect' - optional picking rect. If non-null, restrict drawing to this; viewport rect. void Configure(Double_t fov, Double_t dolly, Double_t* center, Double_t hRotate, Double_t vRotate); Configure the camera state.; fov - set directly field-of-view in degrees (default = 30);; dolly - additional move along the camera forward direction;; center - new camera center (can be 0 for no change);; hRotate - additional ""up/down"" rotation in radians;; vRotate - additional ""left/right"" rotation in radians. Bool_t IsPerspective() const; { return kTRUE; }. Double_t GetFOV() const; { return fFOV; }. » Author: Richard Maunder 25/05/2005 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/gl:$Id: TGLPerspectiveCamera.h 31821 2009-12-10 18:22:44Z matevz $ » Last generated: 2010-09-23 20:06; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html528/TGLPerspectiveCamera.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLPerspectiveCamera.html
https://root.cern/root/html528/TGLPerspectiveCamera.html:667,Deployability,integrat,integrate,667,". TGLPerspectiveCamera. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLPerspectiveCamera. class TGLPerspectiveCamera: public TGLCamera. TGLPerspectiveCamera. Perspective projection camera - with characteristic foreshortening. TODO: Currently constrains YOZ plane to be floor - this is never; 'tipped'. While useful we really need to extend so can:; i) Pick any one of the three natural planes of the world to be floor.; ii) Can use a free arcball style camera with no contraint - integrate; TArcBall. Function Members (Methods); public:. TGLPerspectiveCamera(const TGLVector3& hAxis, const TGLVector3& vAxis); virtual~TGLPerspectiveCamera(); Bool_tTGLCamera::AdjustAndClampVal(Double_t& val, Double_t min, Double_t max, Int_t screenShift, Int_t screenShiftRange, Bool_t mod1, Bool_t mod2) const; Double_tTGLCamera::AdjustDelta(Double_t screenShift, Double_t deltaFactor, Bool_t mod1, Bool_t mod2) const; virtual voidApply(const TGLBoundingBox& box, const TGLRect* pickRect = 0) const; static TClass*Class(); virtual voidConfigure(Double_t fov, Double_t dolly, Double_t* center, Double_t hRotate, Double_t vRotate); virtual Bool_tTGLCamera::Dolly(Int_t delta, Bool_t mod1, Bool_t mod2); voidTGLCamera::DrawDebugAids() const; TGLVector3TGLCamera::EyeDirection() const; TGLVertex3TGLCamera::EyePoint() const; TGLVertex3TGLCamera::FrustumCenter() const; EOverlapTGLCamera::FrustumOverlap(const TGLBoundingBox& box) const; const TGLPlane&TGLCamera::FrustumPlane(TGLCamera::EFrustumPlane plane) const; const TGLMatrix&TGLCamera::GetCamBase() const; const TGLMatrix&TGLCamera::GetCamTrans() const; Double_t*TGLCamera::GetCenterVec(); Bool_tTGLCamera::GetExternalCenter(); Double_tTGLCamera::GetFarClip() const; Double_t*TGLCamera::GetFixDefCenterVec(); Double_tGetFOV() const; Double_tTGLCamera::GetNearClip() const; Doub",MatchSource.WIKI,root/html528/TGLPerspectiveCamera.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLPerspectiveCamera.html
https://root.cern/root/html528/TGLPerspectiveCamera.html:8229,Deployability,update,updates,8229,"camera to defaults - reframe the world volume established in Setup(); in default state. Note: limits defined in Setup() are not adjusted. Bool_t Zoom(Int_t delta, Bool_t mod1, Bool_t mod2); Zoom the camera - 'adjust lens focal length, retaining camera position'.; Arguments are:. 'delta' - mouse viewport delta (pixels) - +ive zoom in, -ive zoom out; 'mod1' / 'mod2' - sensitivity modifiers - see TGLCamera::AdjustAndClampVal(). Returns kTRUE is redraw required (camera change), kFALSE otherwise. Bool_t Truck(Int_t xDelta, Int_t yDelta, Bool_t mod1, Bool_t mod2); Truck the camera - 'move camera parallel to film plane'.; Returns kTRUE is redraw required (camera change), kFALSE otherwise. void Apply(const TGLBoundingBox& box, const TGLRect* pickRect = 0) const; Apply the camera to the current GL context, setting the viewport, projection; and modelview matricies. After this verticies etc can be directly entered; in the world frame. This also updates the cached frustum values, enabling; all the projection, overlap tests etc defined in TGLCamera to be used. Arguments are:; 'box' - view volume box - used to adjust near/far clipping; 'pickRect' - optional picking rect. If non-null, restrict drawing to this; viewport rect. void Configure(Double_t fov, Double_t dolly, Double_t* center, Double_t hRotate, Double_t vRotate); Configure the camera state.; fov - set directly field-of-view in degrees (default = 30);; dolly - additional move along the camera forward direction;; center - new camera center (can be 0 for no change);; hRotate - additional ""up/down"" rotation in radians;; vRotate - additional ""left/right"" rotation in radians. Bool_t IsPerspective() const; { return kTRUE; }. Double_t GetFOV() const; { return fFOV; }. » Author: Richard Maunder 25/05/2005 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/gl:$Id: TGLPerspectiveCamera.h 31821 2009-12-10 18:22:44Z matevz $ » Last generated: 2010-09-23 20:06; This page has been automatically generated.",MatchSource.WIKI,root/html528/TGLPerspectiveCamera.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLPerspectiveCamera.html
https://root.cern/root/html528/TGLPerspectiveCamera.html:667,Integrability,integrat,integrate,667,". TGLPerspectiveCamera. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLPerspectiveCamera. class TGLPerspectiveCamera: public TGLCamera. TGLPerspectiveCamera. Perspective projection camera - with characteristic foreshortening. TODO: Currently constrains YOZ plane to be floor - this is never; 'tipped'. While useful we really need to extend so can:; i) Pick any one of the three natural planes of the world to be floor.; ii) Can use a free arcball style camera with no contraint - integrate; TArcBall. Function Members (Methods); public:. TGLPerspectiveCamera(const TGLVector3& hAxis, const TGLVector3& vAxis); virtual~TGLPerspectiveCamera(); Bool_tTGLCamera::AdjustAndClampVal(Double_t& val, Double_t min, Double_t max, Int_t screenShift, Int_t screenShiftRange, Bool_t mod1, Bool_t mod2) const; Double_tTGLCamera::AdjustDelta(Double_t screenShift, Double_t deltaFactor, Bool_t mod1, Bool_t mod2) const; virtual voidApply(const TGLBoundingBox& box, const TGLRect* pickRect = 0) const; static TClass*Class(); virtual voidConfigure(Double_t fov, Double_t dolly, Double_t* center, Double_t hRotate, Double_t vRotate); virtual Bool_tTGLCamera::Dolly(Int_t delta, Bool_t mod1, Bool_t mod2); voidTGLCamera::DrawDebugAids() const; TGLVector3TGLCamera::EyeDirection() const; TGLVertex3TGLCamera::EyePoint() const; TGLVertex3TGLCamera::FrustumCenter() const; EOverlapTGLCamera::FrustumOverlap(const TGLBoundingBox& box) const; const TGLPlane&TGLCamera::FrustumPlane(TGLCamera::EFrustumPlane plane) const; const TGLMatrix&TGLCamera::GetCamBase() const; const TGLMatrix&TGLCamera::GetCamTrans() const; Double_t*TGLCamera::GetCenterVec(); Bool_tTGLCamera::GetExternalCenter(); Double_tTGLCamera::GetFarClip() const; Double_t*TGLCamera::GetFixDefCenterVec(); Double_tGetFOV() const; Double_tTGLCamera::GetNearClip() const; Doub",MatchSource.WIKI,root/html528/TGLPerspectiveCamera.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLPerspectiveCamera.html
https://root.cern/root/html528/TGLPerspectiveCamera.html:520,Modifiability,extend,extend,520,". TGLPerspectiveCamera. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLPerspectiveCamera. class TGLPerspectiveCamera: public TGLCamera. TGLPerspectiveCamera. Perspective projection camera - with characteristic foreshortening. TODO: Currently constrains YOZ plane to be floor - this is never; 'tipped'. While useful we really need to extend so can:; i) Pick any one of the three natural planes of the world to be floor.; ii) Can use a free arcball style camera with no contraint - integrate; TArcBall. Function Members (Methods); public:. TGLPerspectiveCamera(const TGLVector3& hAxis, const TGLVector3& vAxis); virtual~TGLPerspectiveCamera(); Bool_tTGLCamera::AdjustAndClampVal(Double_t& val, Double_t min, Double_t max, Int_t screenShift, Int_t screenShiftRange, Bool_t mod1, Bool_t mod2) const; Double_tTGLCamera::AdjustDelta(Double_t screenShift, Double_t deltaFactor, Bool_t mod1, Bool_t mod2) const; virtual voidApply(const TGLBoundingBox& box, const TGLRect* pickRect = 0) const; static TClass*Class(); virtual voidConfigure(Double_t fov, Double_t dolly, Double_t* center, Double_t hRotate, Double_t vRotate); virtual Bool_tTGLCamera::Dolly(Int_t delta, Bool_t mod1, Bool_t mod2); voidTGLCamera::DrawDebugAids() const; TGLVector3TGLCamera::EyeDirection() const; TGLVertex3TGLCamera::EyePoint() const; TGLVertex3TGLCamera::FrustumCenter() const; EOverlapTGLCamera::FrustumOverlap(const TGLBoundingBox& box) const; const TGLPlane&TGLCamera::FrustumPlane(TGLCamera::EFrustumPlane plane) const; const TGLMatrix&TGLCamera::GetCamBase() const; const TGLMatrix&TGLCamera::GetCamTrans() const; Double_t*TGLCamera::GetCenterVec(); Bool_tTGLCamera::GetExternalCenter(); Double_tTGLCamera::GetFarClip() const; Double_t*TGLCamera::GetFixDefCenterVec(); Double_tGetFOV() const; Double_tTGLCamera::GetNearClip() const; Doub",MatchSource.WIKI,root/html528/TGLPerspectiveCamera.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLPerspectiveCamera.html
https://root.cern/root/html528/TGLPerspectiveCamera.html:5165,Performance,cache,cached,5165," delta, Bool_t mod1, Bool_t mod2). protected:. voidTGLCamera::UpdateCache() const. Data Members; public:. enum TGLCamera::EFrustumPlane { kNear; kLeft; kRight; kTop; kBottom; kFar; kPlanesPerFrustum; };. protected:. Bool_tTGLCamera::fCacheDirty! cached items dirty?; TGLMatrixTGLCamera::fCamBase! tranformation to center and rotation from up to x vector; TGLMatrixTGLCamera::fCamTrans! transformation relative to fCamTrans; TGLVector3*TGLCamera::fCenter! current camera center; TGLMatrixTGLCamera::fClipM! object space clip matrix (cached); TGLVector3TGLCamera::fDefCenter! deafult camera center; Double_tTGLCamera::fDollyDefault! default distnce from viewing centre; Double_tTGLCamera::fDollyDistance! unit distance for camera movement in fwd/bck direction; TGLVector3TGLCamera::fExtCenter! external camera center; Bool_tTGLCamera::fExternalCenter! use external center insead of scene center; TGLVector3TGLCamera::fFDCenter! fixed deafult camera center; Double_tTGLCamera::fFarClip! last applied far-clip; Bool_tTGLCamera::fFixDefCenter! use fixed default center; TGLPlaneTGLCamera::fFrustumPlanes[6]! frustum planes (cached); TGLBoundingBoxTGLCamera::fInterestBox! the interest box - created in UpdateInterest(); Double_tTGLCamera::fLargestSeen! largest box diagonal seen in OfInterest() - used when; TGLMatrixTGLCamera::fLastNoPickProjM! no-pick projection matrix (cached); TGLMatrixTGLCamera::fModVM! modelView matrix (cached); Double_tTGLCamera::fNearClip! last applied near-clip; TGLMatrixTGLCamera::fProjM! projection matrix (cached); UInt_tTGLCamera::fTimeStamp! timestamp; Float_tTGLCamera::fVAxisMinAngle! minimal allowed angle between up and fCamTrans Z vector; TGLRectTGLCamera::fViewport! viewport (GL coords - origin bottom left); static UInt_tTGLCamera::fgDollyDeltaSens. private:. Double_tfFOV!; static Double_tfgFOVDefault; static UInt_tfgFOVDeltaSens; static Double_tfgFOVMax; static Double_tfgFOVMin. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function docum",MatchSource.WIKI,root/html528/TGLPerspectiveCamera.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLPerspectiveCamera.html
https://root.cern/root/html528/TGLPerspectiveCamera.html:5451,Performance,cache,cached,5451," delta, Bool_t mod1, Bool_t mod2). protected:. voidTGLCamera::UpdateCache() const. Data Members; public:. enum TGLCamera::EFrustumPlane { kNear; kLeft; kRight; kTop; kBottom; kFar; kPlanesPerFrustum; };. protected:. Bool_tTGLCamera::fCacheDirty! cached items dirty?; TGLMatrixTGLCamera::fCamBase! tranformation to center and rotation from up to x vector; TGLMatrixTGLCamera::fCamTrans! transformation relative to fCamTrans; TGLVector3*TGLCamera::fCenter! current camera center; TGLMatrixTGLCamera::fClipM! object space clip matrix (cached); TGLVector3TGLCamera::fDefCenter! deafult camera center; Double_tTGLCamera::fDollyDefault! default distnce from viewing centre; Double_tTGLCamera::fDollyDistance! unit distance for camera movement in fwd/bck direction; TGLVector3TGLCamera::fExtCenter! external camera center; Bool_tTGLCamera::fExternalCenter! use external center insead of scene center; TGLVector3TGLCamera::fFDCenter! fixed deafult camera center; Double_tTGLCamera::fFarClip! last applied far-clip; Bool_tTGLCamera::fFixDefCenter! use fixed default center; TGLPlaneTGLCamera::fFrustumPlanes[6]! frustum planes (cached); TGLBoundingBoxTGLCamera::fInterestBox! the interest box - created in UpdateInterest(); Double_tTGLCamera::fLargestSeen! largest box diagonal seen in OfInterest() - used when; TGLMatrixTGLCamera::fLastNoPickProjM! no-pick projection matrix (cached); TGLMatrixTGLCamera::fModVM! modelView matrix (cached); Double_tTGLCamera::fNearClip! last applied near-clip; TGLMatrixTGLCamera::fProjM! projection matrix (cached); UInt_tTGLCamera::fTimeStamp! timestamp; Float_tTGLCamera::fVAxisMinAngle! minimal allowed angle between up and fCamTrans Z vector; TGLRectTGLCamera::fViewport! viewport (GL coords - origin bottom left); static UInt_tTGLCamera::fgDollyDeltaSens. private:. Double_tfFOV!; static Double_tfgFOVDefault; static UInt_tfgFOVDeltaSens; static Double_tfgFOVMax; static Double_tfgFOVMin. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function docum",MatchSource.WIKI,root/html528/TGLPerspectiveCamera.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLPerspectiveCamera.html
https://root.cern/root/html528/TGLPerspectiveCamera.html:6038,Performance,cache,cached,6038," delta, Bool_t mod1, Bool_t mod2). protected:. voidTGLCamera::UpdateCache() const. Data Members; public:. enum TGLCamera::EFrustumPlane { kNear; kLeft; kRight; kTop; kBottom; kFar; kPlanesPerFrustum; };. protected:. Bool_tTGLCamera::fCacheDirty! cached items dirty?; TGLMatrixTGLCamera::fCamBase! tranformation to center and rotation from up to x vector; TGLMatrixTGLCamera::fCamTrans! transformation relative to fCamTrans; TGLVector3*TGLCamera::fCenter! current camera center; TGLMatrixTGLCamera::fClipM! object space clip matrix (cached); TGLVector3TGLCamera::fDefCenter! deafult camera center; Double_tTGLCamera::fDollyDefault! default distnce from viewing centre; Double_tTGLCamera::fDollyDistance! unit distance for camera movement in fwd/bck direction; TGLVector3TGLCamera::fExtCenter! external camera center; Bool_tTGLCamera::fExternalCenter! use external center insead of scene center; TGLVector3TGLCamera::fFDCenter! fixed deafult camera center; Double_tTGLCamera::fFarClip! last applied far-clip; Bool_tTGLCamera::fFixDefCenter! use fixed default center; TGLPlaneTGLCamera::fFrustumPlanes[6]! frustum planes (cached); TGLBoundingBoxTGLCamera::fInterestBox! the interest box - created in UpdateInterest(); Double_tTGLCamera::fLargestSeen! largest box diagonal seen in OfInterest() - used when; TGLMatrixTGLCamera::fLastNoPickProjM! no-pick projection matrix (cached); TGLMatrixTGLCamera::fModVM! modelView matrix (cached); Double_tTGLCamera::fNearClip! last applied near-clip; TGLMatrixTGLCamera::fProjM! projection matrix (cached); UInt_tTGLCamera::fTimeStamp! timestamp; Float_tTGLCamera::fVAxisMinAngle! minimal allowed angle between up and fCamTrans Z vector; TGLRectTGLCamera::fViewport! viewport (GL coords - origin bottom left); static UInt_tTGLCamera::fgDollyDeltaSens. private:. Double_tfFOV!; static Double_tfgFOVDefault; static UInt_tfgFOVDeltaSens; static Double_tfgFOVMax; static Double_tfgFOVMin. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function docum",MatchSource.WIKI,root/html528/TGLPerspectiveCamera.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLPerspectiveCamera.html
https://root.cern/root/html528/TGLPerspectiveCamera.html:6287,Performance,cache,cached,6287," delta, Bool_t mod1, Bool_t mod2). protected:. voidTGLCamera::UpdateCache() const. Data Members; public:. enum TGLCamera::EFrustumPlane { kNear; kLeft; kRight; kTop; kBottom; kFar; kPlanesPerFrustum; };. protected:. Bool_tTGLCamera::fCacheDirty! cached items dirty?; TGLMatrixTGLCamera::fCamBase! tranformation to center and rotation from up to x vector; TGLMatrixTGLCamera::fCamTrans! transformation relative to fCamTrans; TGLVector3*TGLCamera::fCenter! current camera center; TGLMatrixTGLCamera::fClipM! object space clip matrix (cached); TGLVector3TGLCamera::fDefCenter! deafult camera center; Double_tTGLCamera::fDollyDefault! default distnce from viewing centre; Double_tTGLCamera::fDollyDistance! unit distance for camera movement in fwd/bck direction; TGLVector3TGLCamera::fExtCenter! external camera center; Bool_tTGLCamera::fExternalCenter! use external center insead of scene center; TGLVector3TGLCamera::fFDCenter! fixed deafult camera center; Double_tTGLCamera::fFarClip! last applied far-clip; Bool_tTGLCamera::fFixDefCenter! use fixed default center; TGLPlaneTGLCamera::fFrustumPlanes[6]! frustum planes (cached); TGLBoundingBoxTGLCamera::fInterestBox! the interest box - created in UpdateInterest(); Double_tTGLCamera::fLargestSeen! largest box diagonal seen in OfInterest() - used when; TGLMatrixTGLCamera::fLastNoPickProjM! no-pick projection matrix (cached); TGLMatrixTGLCamera::fModVM! modelView matrix (cached); Double_tTGLCamera::fNearClip! last applied near-clip; TGLMatrixTGLCamera::fProjM! projection matrix (cached); UInt_tTGLCamera::fTimeStamp! timestamp; Float_tTGLCamera::fVAxisMinAngle! minimal allowed angle between up and fCamTrans Z vector; TGLRectTGLCamera::fViewport! viewport (GL coords - origin bottom left); static UInt_tTGLCamera::fgDollyDeltaSens. private:. Double_tfFOV!; static Double_tfgFOVDefault; static UInt_tfgFOVDeltaSens; static Double_tfgFOVMax; static Double_tfgFOVMin. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function docum",MatchSource.WIKI,root/html528/TGLPerspectiveCamera.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLPerspectiveCamera.html
https://root.cern/root/html528/TGLPerspectiveCamera.html:6342,Performance,cache,cached,6342," delta, Bool_t mod1, Bool_t mod2). protected:. voidTGLCamera::UpdateCache() const. Data Members; public:. enum TGLCamera::EFrustumPlane { kNear; kLeft; kRight; kTop; kBottom; kFar; kPlanesPerFrustum; };. protected:. Bool_tTGLCamera::fCacheDirty! cached items dirty?; TGLMatrixTGLCamera::fCamBase! tranformation to center and rotation from up to x vector; TGLMatrixTGLCamera::fCamTrans! transformation relative to fCamTrans; TGLVector3*TGLCamera::fCenter! current camera center; TGLMatrixTGLCamera::fClipM! object space clip matrix (cached); TGLVector3TGLCamera::fDefCenter! deafult camera center; Double_tTGLCamera::fDollyDefault! default distnce from viewing centre; Double_tTGLCamera::fDollyDistance! unit distance for camera movement in fwd/bck direction; TGLVector3TGLCamera::fExtCenter! external camera center; Bool_tTGLCamera::fExternalCenter! use external center insead of scene center; TGLVector3TGLCamera::fFDCenter! fixed deafult camera center; Double_tTGLCamera::fFarClip! last applied far-clip; Bool_tTGLCamera::fFixDefCenter! use fixed default center; TGLPlaneTGLCamera::fFrustumPlanes[6]! frustum planes (cached); TGLBoundingBoxTGLCamera::fInterestBox! the interest box - created in UpdateInterest(); Double_tTGLCamera::fLargestSeen! largest box diagonal seen in OfInterest() - used when; TGLMatrixTGLCamera::fLastNoPickProjM! no-pick projection matrix (cached); TGLMatrixTGLCamera::fModVM! modelView matrix (cached); Double_tTGLCamera::fNearClip! last applied near-clip; TGLMatrixTGLCamera::fProjM! projection matrix (cached); UInt_tTGLCamera::fTimeStamp! timestamp; Float_tTGLCamera::fVAxisMinAngle! minimal allowed angle between up and fCamTrans Z vector; TGLRectTGLCamera::fViewport! viewport (GL coords - origin bottom left); static UInt_tTGLCamera::fgDollyDeltaSens. private:. Double_tfFOV!; static Double_tfgFOVDefault; static UInt_tfgFOVDeltaSens; static Double_tfgFOVMax; static Double_tfgFOVMin. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function docum",MatchSource.WIKI,root/html528/TGLPerspectiveCamera.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLPerspectiveCamera.html
https://root.cern/root/html528/TGLPerspectiveCamera.html:6452,Performance,cache,cached,6452," delta, Bool_t mod1, Bool_t mod2). protected:. voidTGLCamera::UpdateCache() const. Data Members; public:. enum TGLCamera::EFrustumPlane { kNear; kLeft; kRight; kTop; kBottom; kFar; kPlanesPerFrustum; };. protected:. Bool_tTGLCamera::fCacheDirty! cached items dirty?; TGLMatrixTGLCamera::fCamBase! tranformation to center and rotation from up to x vector; TGLMatrixTGLCamera::fCamTrans! transformation relative to fCamTrans; TGLVector3*TGLCamera::fCenter! current camera center; TGLMatrixTGLCamera::fClipM! object space clip matrix (cached); TGLVector3TGLCamera::fDefCenter! deafult camera center; Double_tTGLCamera::fDollyDefault! default distnce from viewing centre; Double_tTGLCamera::fDollyDistance! unit distance for camera movement in fwd/bck direction; TGLVector3TGLCamera::fExtCenter! external camera center; Bool_tTGLCamera::fExternalCenter! use external center insead of scene center; TGLVector3TGLCamera::fFDCenter! fixed deafult camera center; Double_tTGLCamera::fFarClip! last applied far-clip; Bool_tTGLCamera::fFixDefCenter! use fixed default center; TGLPlaneTGLCamera::fFrustumPlanes[6]! frustum planes (cached); TGLBoundingBoxTGLCamera::fInterestBox! the interest box - created in UpdateInterest(); Double_tTGLCamera::fLargestSeen! largest box diagonal seen in OfInterest() - used when; TGLMatrixTGLCamera::fLastNoPickProjM! no-pick projection matrix (cached); TGLMatrixTGLCamera::fModVM! modelView matrix (cached); Double_tTGLCamera::fNearClip! last applied near-clip; TGLMatrixTGLCamera::fProjM! projection matrix (cached); UInt_tTGLCamera::fTimeStamp! timestamp; Float_tTGLCamera::fVAxisMinAngle! minimal allowed angle between up and fCamTrans Z vector; TGLRectTGLCamera::fViewport! viewport (GL coords - origin bottom left); static UInt_tTGLCamera::fgDollyDeltaSens. private:. Double_tfFOV!; static Double_tfgFOVDefault; static UInt_tfgFOVDeltaSens; static Double_tfgFOVMax; static Double_tfgFOVMin. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function docum",MatchSource.WIKI,root/html528/TGLPerspectiveCamera.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLPerspectiveCamera.html
https://root.cern/root/html528/TGLPerspectiveCamera.html:8241,Performance,cache,cached,8241,"camera to defaults - reframe the world volume established in Setup(); in default state. Note: limits defined in Setup() are not adjusted. Bool_t Zoom(Int_t delta, Bool_t mod1, Bool_t mod2); Zoom the camera - 'adjust lens focal length, retaining camera position'.; Arguments are:. 'delta' - mouse viewport delta (pixels) - +ive zoom in, -ive zoom out; 'mod1' / 'mod2' - sensitivity modifiers - see TGLCamera::AdjustAndClampVal(). Returns kTRUE is redraw required (camera change), kFALSE otherwise. Bool_t Truck(Int_t xDelta, Int_t yDelta, Bool_t mod1, Bool_t mod2); Truck the camera - 'move camera parallel to film plane'.; Returns kTRUE is redraw required (camera change), kFALSE otherwise. void Apply(const TGLBoundingBox& box, const TGLRect* pickRect = 0) const; Apply the camera to the current GL context, setting the viewport, projection; and modelview matricies. After this verticies etc can be directly entered; in the world frame. This also updates the cached frustum values, enabling; all the projection, overlap tests etc defined in TGLCamera to be used. Arguments are:; 'box' - view volume box - used to adjust near/far clipping; 'pickRect' - optional picking rect. If non-null, restrict drawing to this; viewport rect. void Configure(Double_t fov, Double_t dolly, Double_t* center, Double_t hRotate, Double_t vRotate); Configure the camera state.; fov - set directly field-of-view in degrees (default = 30);; dolly - additional move along the camera forward direction;; center - new camera center (can be 0 for no change);; hRotate - additional ""up/down"" rotation in radians;; vRotate - additional ""left/right"" rotation in radians. Bool_t IsPerspective() const; { return kTRUE; }. Double_t GetFOV() const; { return fFOV; }. » Author: Richard Maunder 25/05/2005 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/gl:$Id: TGLPerspectiveCamera.h 31821 2009-12-10 18:22:44Z matevz $ » Last generated: 2010-09-23 20:06; This page has been automatically generated.",MatchSource.WIKI,root/html528/TGLPerspectiveCamera.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLPerspectiveCamera.html
https://root.cern/root/html528/TGLPerspectiveCamera.html:8302,Testability,test,tests,8302,"camera to defaults - reframe the world volume established in Setup(); in default state. Note: limits defined in Setup() are not adjusted. Bool_t Zoom(Int_t delta, Bool_t mod1, Bool_t mod2); Zoom the camera - 'adjust lens focal length, retaining camera position'.; Arguments are:. 'delta' - mouse viewport delta (pixels) - +ive zoom in, -ive zoom out; 'mod1' / 'mod2' - sensitivity modifiers - see TGLCamera::AdjustAndClampVal(). Returns kTRUE is redraw required (camera change), kFALSE otherwise. Bool_t Truck(Int_t xDelta, Int_t yDelta, Bool_t mod1, Bool_t mod2); Truck the camera - 'move camera parallel to film plane'.; Returns kTRUE is redraw required (camera change), kFALSE otherwise. void Apply(const TGLBoundingBox& box, const TGLRect* pickRect = 0) const; Apply the camera to the current GL context, setting the viewport, projection; and modelview matricies. After this verticies etc can be directly entered; in the world frame. This also updates the cached frustum values, enabling; all the projection, overlap tests etc defined in TGLCamera to be used. Arguments are:; 'box' - view volume box - used to adjust near/far clipping; 'pickRect' - optional picking rect. If non-null, restrict drawing to this; viewport rect. void Configure(Double_t fov, Double_t dolly, Double_t* center, Double_t hRotate, Double_t vRotate); Configure the camera state.; fov - set directly field-of-view in degrees (default = 30);; dolly - additional move along the camera forward direction;; center - new camera center (can be 0 for no change);; hRotate - additional ""up/down"" rotation in radians;; vRotate - additional ""left/right"" rotation in radians. Bool_t IsPerspective() const; { return kTRUE; }. Double_t GetFOV() const; { return fFOV; }. » Author: Richard Maunder 25/05/2005 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/gl:$Id: TGLPerspectiveCamera.h 31821 2009-12-10 18:22:44Z matevz $ » Last generated: 2010-09-23 20:06; This page has been automatically generated.",MatchSource.WIKI,root/html528/TGLPerspectiveCamera.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLPerspectiveCamera.html
https://root.cern/root/html528/TGLPhysicalShape.html:937,Performance,perform,perform,937,". TGLPhysicalShape. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLPhysicalShape. class TGLPhysicalShape. Concrete physical shape - a GL drawable. Physical shapes are the; objects the user can actually see, select, move in the viewer. It is; a placement of the associated local frame TGLLogicaShape into the; world frame. The draw process is:. Load attributes - material colors etc; Load translation matrix - placement; Load gl name (for selection); Call our associated logical shape Draw() to draw placed shape. The physical shape supports translation, scaling and rotation,; selection, color changes, and permitted modification flags etc.; A physical shape cannot modify or be bound to another (or no); logical shape - hence const & handle. It can perform mutable; reference counting on the logical to enable purging. Physical shape also maintains a list of references to it and; provides notifications of change and destruction.; See class TGLPShapeRef which needs to be sub-classes for real use. See base/src/TVirtualViewer3D for description of common external 3D; viewer architecture and how external viewer clients use it. Function Members (Methods); public:. TGLPhysicalShape(UInt_t ID, const TGLLogicalShape& logicalShape, const TGLMatrix& transform, Bool_t invertedWind, const Float_t* rgba); TGLPhysicalShape(UInt_t ID, const TGLLogicalShape& logicalShape, const double* transform, Bool_t invertedWind, const Float_t* rgba); virtual~TGLPhysicalShape(); voidAddReference(TGLPShapeRef* ref); const TGLBoundingBox&BoundingBox() const; virtual voidCalculateShapeLOD(TGLRnrCtx& rnrCtx, Float_t& pixSize, Short_t& shapeLOD) const; static TClass*Class(); const Float_t*Color() const; virtual voidDraw(TGLRnrCtx& rnrCtx) const; const TGLLogicalShape*GetLogical() const; TGLPhysicalShape::EManipGetManip() const; ",MatchSource.WIKI,root/html528/TGLPhysicalShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLPhysicalShape.html
https://root.cern/root/html528/TGLPhysicalShape.html:6605,Performance,cache,cache,6605,"ding box (in global frame). void InitColor(const Float_t* rgba); Initialise the colors, using basic RGBA diffuse material color supplied. void SetColor(const Float_t* rgba); Set full color attributes - see OpenGL material documentation; for full description.; 0->3 diffuse, 4->7 ambient, 8->11 specular, 12->15 emission, 16 shininess. void SetColorOnFamily(const Float_t* rgba); Set full color attributes to all physicals sharing the same; logical with this object. void SetDiffuseColor(const Float_t rgba[4]); Set color from ROOT color index and transparency [0,100]. void SetDiffuseColor(const UChar_t rgba[4]); Set color from RGBA quadruplet. void SetDiffuseColor(Color_t ci, UChar_t transparency); Set color from standard ROOT representation, that is color index; + transparency in range [0, 100]. void SetupGLColors(TGLRnrCtx& rnrCtx, const Float_t* color = 0) const; Setup colors - avoid setting things not required; for current draw flags. void Draw(TGLRnrCtx& rnrCtx) const; Draw physical shape, using LOD flags, potential from display list cache. void CalculateShapeLOD(TGLRnrCtx& rnrCtx, Float_t& pixSize, Short_t& shapeLOD) const; Calculate shape-lod, suitible for use under; projection defined by 'rnrCtx', taking account of which local; axes of the shape support LOD adjustment, and the global; 'sceneFlags' passed. Returned shapeLOD component is from 0 (kLODPixel - lowest; quality) to 100 (kLODHigh - highest quality). Scene flags are not used. LOD quantization is not done. RnrCtx; is not modified as this is called via lodification stage of; rendering. void QuantizeShapeLOD(Short_t shapeLOD, Short_t combiLOD, Short_t& quantLOD) const; Factor in scene/vierer LOD and Quantize ... forward to; logical shape. void InvokeContextMenu(TContextMenu& menu, UInt_t x, UInt_t y) const; Request creation of context menu on shape, attached to 'menu' at screen position; 'x' 'y'. TGLVector3 GetScale() const. TGLVertex3 GetTranslation() const. void SetTransform(const TGLMatrix& transform). void",MatchSource.WIKI,root/html528/TGLPhysicalShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLPhysicalShape.html
https://root.cern/root/html528/TGLPhysicalShape.html:6444,Safety,avoid,avoid,6444,"cal so that the information; can be propagated to the object referencing it. void UpdateBoundingBox(); Update our internal bounding box (in global frame). void InitColor(const Float_t* rgba); Initialise the colors, using basic RGBA diffuse material color supplied. void SetColor(const Float_t* rgba); Set full color attributes - see OpenGL material documentation; for full description.; 0->3 diffuse, 4->7 ambient, 8->11 specular, 12->15 emission, 16 shininess. void SetColorOnFamily(const Float_t* rgba); Set full color attributes to all physicals sharing the same; logical with this object. void SetDiffuseColor(const Float_t rgba[4]); Set color from ROOT color index and transparency [0,100]. void SetDiffuseColor(const UChar_t rgba[4]); Set color from RGBA quadruplet. void SetDiffuseColor(Color_t ci, UChar_t transparency); Set color from standard ROOT representation, that is color index; + transparency in range [0, 100]. void SetupGLColors(TGLRnrCtx& rnrCtx, const Float_t* color = 0) const; Setup colors - avoid setting things not required; for current draw flags. void Draw(TGLRnrCtx& rnrCtx) const; Draw physical shape, using LOD flags, potential from display list cache. void CalculateShapeLOD(TGLRnrCtx& rnrCtx, Float_t& pixSize, Short_t& shapeLOD) const; Calculate shape-lod, suitible for use under; projection defined by 'rnrCtx', taking account of which local; axes of the shape support LOD adjustment, and the global; 'sceneFlags' passed. Returned shapeLOD component is from 0 (kLODPixel - lowest; quality) to 100 (kLODHigh - highest quality). Scene flags are not used. LOD quantization is not done. RnrCtx; is not modified as this is called via lodification stage of; rendering. void QuantizeShapeLOD(Short_t shapeLOD, Short_t combiLOD, Short_t& quantLOD) const; Factor in scene/vierer LOD and Quantize ... forward to; logical shape. void InvokeContextMenu(TContextMenu& menu, UInt_t x, UInt_t y) const; Request creation of context menu on shape, attached to 'menu' at screen positio",MatchSource.WIKI,root/html528/TGLPhysicalShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLPhysicalShape.html
https://root.cern/root/html528/TGLPhysicalShape.html:657,Testability,log,logical,657,". TGLPhysicalShape. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLPhysicalShape. class TGLPhysicalShape. Concrete physical shape - a GL drawable. Physical shapes are the; objects the user can actually see, select, move in the viewer. It is; a placement of the associated local frame TGLLogicaShape into the; world frame. The draw process is:. Load attributes - material colors etc; Load translation matrix - placement; Load gl name (for selection); Call our associated logical shape Draw() to draw placed shape. The physical shape supports translation, scaling and rotation,; selection, color changes, and permitted modification flags etc.; A physical shape cannot modify or be bound to another (or no); logical shape - hence const & handle. It can perform mutable; reference counting on the logical to enable purging. Physical shape also maintains a list of references to it and; provides notifications of change and destruction.; See class TGLPShapeRef which needs to be sub-classes for real use. See base/src/TVirtualViewer3D for description of common external 3D; viewer architecture and how external viewer clients use it. Function Members (Methods); public:. TGLPhysicalShape(UInt_t ID, const TGLLogicalShape& logicalShape, const TGLMatrix& transform, Bool_t invertedWind, const Float_t* rgba); TGLPhysicalShape(UInt_t ID, const TGLLogicalShape& logicalShape, const double* transform, Bool_t invertedWind, const Float_t* rgba); virtual~TGLPhysicalShape(); voidAddReference(TGLPShapeRef* ref); const TGLBoundingBox&BoundingBox() const; virtual voidCalculateShapeLOD(TGLRnrCtx& rnrCtx, Float_t& pixSize, Short_t& shapeLOD) const; static TClass*Class(); const Float_t*Color() const; virtual voidDraw(TGLRnrCtx& rnrCtx) const; const TGLLogicalShape*GetLogical() const; TGLPhysicalShape::EManipGetManip() const; ",MatchSource.WIKI,root/html528/TGLPhysicalShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLPhysicalShape.html
https://root.cern/root/html528/TGLPhysicalShape.html:892,Testability,log,logical,892,". TGLPhysicalShape. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLPhysicalShape. class TGLPhysicalShape. Concrete physical shape - a GL drawable. Physical shapes are the; objects the user can actually see, select, move in the viewer. It is; a placement of the associated local frame TGLLogicaShape into the; world frame. The draw process is:. Load attributes - material colors etc; Load translation matrix - placement; Load gl name (for selection); Call our associated logical shape Draw() to draw placed shape. The physical shape supports translation, scaling and rotation,; selection, color changes, and permitted modification flags etc.; A physical shape cannot modify or be bound to another (or no); logical shape - hence const & handle. It can perform mutable; reference counting on the logical to enable purging. Physical shape also maintains a list of references to it and; provides notifications of change and destruction.; See class TGLPShapeRef which needs to be sub-classes for real use. See base/src/TVirtualViewer3D for description of common external 3D; viewer architecture and how external viewer clients use it. Function Members (Methods); public:. TGLPhysicalShape(UInt_t ID, const TGLLogicalShape& logicalShape, const TGLMatrix& transform, Bool_t invertedWind, const Float_t* rgba); TGLPhysicalShape(UInt_t ID, const TGLLogicalShape& logicalShape, const double* transform, Bool_t invertedWind, const Float_t* rgba); virtual~TGLPhysicalShape(); voidAddReference(TGLPShapeRef* ref); const TGLBoundingBox&BoundingBox() const; virtual voidCalculateShapeLOD(TGLRnrCtx& rnrCtx, Float_t& pixSize, Short_t& shapeLOD) const; static TClass*Class(); const Float_t*Color() const; virtual voidDraw(TGLRnrCtx& rnrCtx) const; const TGLLogicalShape*GetLogical() const; TGLPhysicalShape::EManipGetManip() const; ",MatchSource.WIKI,root/html528/TGLPhysicalShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLPhysicalShape.html
https://root.cern/root/html528/TGLPhysicalShape.html:980,Testability,log,logical,980,". TGLPhysicalShape. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLPhysicalShape. class TGLPhysicalShape. Concrete physical shape - a GL drawable. Physical shapes are the; objects the user can actually see, select, move in the viewer. It is; a placement of the associated local frame TGLLogicaShape into the; world frame. The draw process is:. Load attributes - material colors etc; Load translation matrix - placement; Load gl name (for selection); Call our associated logical shape Draw() to draw placed shape. The physical shape supports translation, scaling and rotation,; selection, color changes, and permitted modification flags etc.; A physical shape cannot modify or be bound to another (or no); logical shape - hence const & handle. It can perform mutable; reference counting on the logical to enable purging. Physical shape also maintains a list of references to it and; provides notifications of change and destruction.; See class TGLPShapeRef which needs to be sub-classes for real use. See base/src/TVirtualViewer3D for description of common external 3D; viewer architecture and how external viewer clients use it. Function Members (Methods); public:. TGLPhysicalShape(UInt_t ID, const TGLLogicalShape& logicalShape, const TGLMatrix& transform, Bool_t invertedWind, const Float_t* rgba); TGLPhysicalShape(UInt_t ID, const TGLLogicalShape& logicalShape, const double* transform, Bool_t invertedWind, const Float_t* rgba); virtual~TGLPhysicalShape(); voidAddReference(TGLPShapeRef* ref); const TGLBoundingBox&BoundingBox() const; virtual voidCalculateShapeLOD(TGLRnrCtx& rnrCtx, Float_t& pixSize, Short_t& shapeLOD) const; static TClass*Class(); const Float_t*Color() const; virtual voidDraw(TGLRnrCtx& rnrCtx) const; const TGLLogicalShape*GetLogical() const; TGLPhysicalShape::EManipGetManip() const; ",MatchSource.WIKI,root/html528/TGLPhysicalShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLPhysicalShape.html
https://root.cern/root/html528/TGLPhysicalShape.html:1404,Testability,log,logicalShape,1404,"t. Function Members (Methods); public:. TGLPhysicalShape(UInt_t ID, const TGLLogicalShape& logicalShape, const TGLMatrix& transform, Bool_t invertedWind, const Float_t* rgba); TGLPhysicalShape(UInt_t ID, const TGLLogicalShape& logicalShape, const double* transform, Bool_t invertedWind, const Float_t* rgba); virtual~TGLPhysicalShape(); voidAddReference(TGLPShapeRef* ref); const TGLBoundingBox&BoundingBox() const; virtual voidCalculateShapeLOD(TGLRnrCtx& rnrCtx, Float_t& pixSize, Short_t& shapeLOD) const; static TClass*Class(); const Float_t*Color() const; virtual voidDraw(TGLRnrCtx& rnrCtx) const; const TGLLogicalShape*GetLogical() const; TGLPhysicalShape::EManipGetManip() const; const TGLPhysicalShape*GetNextPhysical() const; TGLVector3GetScale() const; UChar_tGetSelected() const; TGLVertex3GetTranslation() const; UInt_tID() const; voidInvokeContextMenu(TContextMenu& menu, UInt_t x, UInt_t y) const; virtual TClass*IsA() const; Bool_tIsInvisible() const; Bool_tIsModified() const; Bool_tIsSelected() const; Bool_tIsTransparent() const; voidModified(); virtual voidQuantizeShapeLOD(Short_t shapeLOD, Short_t combiLOD, Short_t& quantLOD) const; voidRemoveReference(TGLPShapeRef* ref); voidRotate(const TGLVertex3& pivot, const TGLVector3& axis, Double_t angle); voidScale(const TGLVector3& scale); voidSelect(UChar_t select); voidSetColor(const Float_t* rgba); voidSetColorOnFamily(const Float_t* rgba); voidSetDiffuseColor(const Float_t* rgba); voidSetDiffuseColor(const UChar_t* rgba); voidSetDiffuseColor(Color_t ci, UChar_t transparency); voidSetManip(TGLPhysicalShape::EManip manip); voidSetTransform(const TGLMatrix& transform); voidSetTransform(const Double_t* vals); voidSetTranslation(const TGLVertex3& translation); voidSetupGLColors(TGLRnrCtx& rnrCtx, const Float_t* color = 0) const; virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); voidTranslate(const TGLVector3& vect). private:. TGLPhysicalShape(const TGLPh",MatchSource.WIKI,root/html528/TGLPhysicalShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLPhysicalShape.html
https://root.cern/root/html528/TGLPhysicalShape.html:1540,Testability,log,logicalShape,1540,"t. Function Members (Methods); public:. TGLPhysicalShape(UInt_t ID, const TGLLogicalShape& logicalShape, const TGLMatrix& transform, Bool_t invertedWind, const Float_t* rgba); TGLPhysicalShape(UInt_t ID, const TGLLogicalShape& logicalShape, const double* transform, Bool_t invertedWind, const Float_t* rgba); virtual~TGLPhysicalShape(); voidAddReference(TGLPShapeRef* ref); const TGLBoundingBox&BoundingBox() const; virtual voidCalculateShapeLOD(TGLRnrCtx& rnrCtx, Float_t& pixSize, Short_t& shapeLOD) const; static TClass*Class(); const Float_t*Color() const; virtual voidDraw(TGLRnrCtx& rnrCtx) const; const TGLLogicalShape*GetLogical() const; TGLPhysicalShape::EManipGetManip() const; const TGLPhysicalShape*GetNextPhysical() const; TGLVector3GetScale() const; UChar_tGetSelected() const; TGLVertex3GetTranslation() const; UInt_tID() const; voidInvokeContextMenu(TContextMenu& menu, UInt_t x, UInt_t y) const; virtual TClass*IsA() const; Bool_tIsInvisible() const; Bool_tIsModified() const; Bool_tIsSelected() const; Bool_tIsTransparent() const; voidModified(); virtual voidQuantizeShapeLOD(Short_t shapeLOD, Short_t combiLOD, Short_t& quantLOD) const; voidRemoveReference(TGLPShapeRef* ref); voidRotate(const TGLVertex3& pivot, const TGLVector3& axis, Double_t angle); voidScale(const TGLVector3& scale); voidSelect(UChar_t select); voidSetColor(const Float_t* rgba); voidSetColorOnFamily(const Float_t* rgba); voidSetDiffuseColor(const Float_t* rgba); voidSetDiffuseColor(const UChar_t* rgba); voidSetDiffuseColor(Color_t ci, UChar_t transparency); voidSetManip(TGLPhysicalShape::EManip manip); voidSetTransform(const TGLMatrix& transform); voidSetTransform(const Double_t* vals); voidSetTranslation(const TGLVertex3& translation); voidSetupGLColors(TGLRnrCtx& rnrCtx, const Float_t* color = 0) const; virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); voidTranslate(const TGLVector3& vect). private:. TGLPhysicalShape(const TGLPh",MatchSource.WIKI,root/html528/TGLPhysicalShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLPhysicalShape.html
https://root.cern/root/html528/TGLPhysicalShape.html:3982,Testability,log,logical,3982,"ransform(const Double_t* vals); voidSetTranslation(const TGLVertex3& translation); voidSetupGLColors(TGLRnrCtx& rnrCtx, const Float_t* color = 0) const; virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); voidTranslate(const TGLVector3& vect). private:. TGLPhysicalShape(const TGLPhysicalShape&); voidInitColor(const Float_t* rgba); TGLPhysicalShape&operator=(const TGLPhysicalShape&); voidUpdateBoundingBox(). Data Members; public:. enum EManip { kTranslateX; kTranslateY; kTranslateZ; kTranslateAll; kScaleX; kScaleY; kScaleZ; kScaleAll; kRotateX; kRotateY; kRotateZ; kRotateAll; kManipAll; };. private:. TGLBoundingBoxfBoundingBox! bounding box of the physical (transformed); Float_tfColor[17]! GL color array; TGLPShapeRef*fFirstPSRef! pointer to first reference; UInt_tfID! unique physical ID within containing scene; Bool_tfInvertedWind! face winding TODO: can get directly from fTransform?; const TGLLogicalShape*fLogicalShape! the associated logical shape; TGLPhysicalShape::EManipfManip! permitted manipulation bitflags - see EManip; Bool_tfModified! has been modified - retain across scene rebuilds; TGLPhysicalShape*fNextPhysical! pointer to next replica; UChar_tfSelected! selected state; TGLMatrixfTransform! transform (placement) of physical instance. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLPhysicalShape(UInt_t ID, const TGLLogicalShape& logicalShape, const TGLMatrix& transform, Bool_t invertedWind, const Float_t* rgba); Construct a physical shape using arguments:; ID - unique drawable id.; logicalShape - bound logical shape; transform - transform for placement of logical drawing; invertedWind - use inverted face polygon winding?; rgba - basic four component (RGBA) diffuse color. TGLPhysicalShape(UInt_t ID, const TGLLogicalShape& logicalShape, const double* transform, Bool_t invertedWind, const Float_t* rgba); Construct a physical shape using arguments:; i",MatchSource.WIKI,root/html528/TGLPhysicalShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLPhysicalShape.html
https://root.cern/root/html528/TGLPhysicalShape.html:4440,Testability,log,logicalShape,4440," kTranslateX; kTranslateY; kTranslateZ; kTranslateAll; kScaleX; kScaleY; kScaleZ; kScaleAll; kRotateX; kRotateY; kRotateZ; kRotateAll; kManipAll; };. private:. TGLBoundingBoxfBoundingBox! bounding box of the physical (transformed); Float_tfColor[17]! GL color array; TGLPShapeRef*fFirstPSRef! pointer to first reference; UInt_tfID! unique physical ID within containing scene; Bool_tfInvertedWind! face winding TODO: can get directly from fTransform?; const TGLLogicalShape*fLogicalShape! the associated logical shape; TGLPhysicalShape::EManipfManip! permitted manipulation bitflags - see EManip; Bool_tfModified! has been modified - retain across scene rebuilds; TGLPhysicalShape*fNextPhysical! pointer to next replica; UChar_tfSelected! selected state; TGLMatrixfTransform! transform (placement) of physical instance. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLPhysicalShape(UInt_t ID, const TGLLogicalShape& logicalShape, const TGLMatrix& transform, Bool_t invertedWind, const Float_t* rgba); Construct a physical shape using arguments:; ID - unique drawable id.; logicalShape - bound logical shape; transform - transform for placement of logical drawing; invertedWind - use inverted face polygon winding?; rgba - basic four component (RGBA) diffuse color. TGLPhysicalShape(UInt_t ID, const TGLLogicalShape& logicalShape, const double* transform, Bool_t invertedWind, const Float_t* rgba); Construct a physical shape using arguments:; id - unique drawable id.; logicalShape - bound logical shape; transform - 16 Double_t component transform for placement of logical drawing; invertedWind - use inverted face polygon winding?; rgba - basic four component (RGBA) diffuse color. ~TGLPhysicalShape(); Destroy the physical shape. void AddReference(TGLPShapeRef* ref); Add reference ref. void RemoveReference(TGLPShapeRef* ref); Remove reference ref. void Modified(); Call this after modifying the physical so that the information; can be propagated to ",MatchSource.WIKI,root/html528/TGLPhysicalShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLPhysicalShape.html
https://root.cern/root/html528/TGLPhysicalShape.html:4596,Testability,log,logicalShape,4596,"ical (transformed); Float_tfColor[17]! GL color array; TGLPShapeRef*fFirstPSRef! pointer to first reference; UInt_tfID! unique physical ID within containing scene; Bool_tfInvertedWind! face winding TODO: can get directly from fTransform?; const TGLLogicalShape*fLogicalShape! the associated logical shape; TGLPhysicalShape::EManipfManip! permitted manipulation bitflags - see EManip; Bool_tfModified! has been modified - retain across scene rebuilds; TGLPhysicalShape*fNextPhysical! pointer to next replica; UChar_tfSelected! selected state; TGLMatrixfTransform! transform (placement) of physical instance. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLPhysicalShape(UInt_t ID, const TGLLogicalShape& logicalShape, const TGLMatrix& transform, Bool_t invertedWind, const Float_t* rgba); Construct a physical shape using arguments:; ID - unique drawable id.; logicalShape - bound logical shape; transform - transform for placement of logical drawing; invertedWind - use inverted face polygon winding?; rgba - basic four component (RGBA) diffuse color. TGLPhysicalShape(UInt_t ID, const TGLLogicalShape& logicalShape, const double* transform, Bool_t invertedWind, const Float_t* rgba); Construct a physical shape using arguments:; id - unique drawable id.; logicalShape - bound logical shape; transform - 16 Double_t component transform for placement of logical drawing; invertedWind - use inverted face polygon winding?; rgba - basic four component (RGBA) diffuse color. ~TGLPhysicalShape(); Destroy the physical shape. void AddReference(TGLPShapeRef* ref); Add reference ref. void RemoveReference(TGLPShapeRef* ref); Remove reference ref. void Modified(); Call this after modifying the physical so that the information; can be propagated to the object referencing it. void UpdateBoundingBox(); Update our internal bounding box (in global frame). void InitColor(const Float_t* rgba); Initialise the colors, using basic RGBA diffuse material color supplie",MatchSource.WIKI,root/html528/TGLPhysicalShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLPhysicalShape.html
https://root.cern/root/html528/TGLPhysicalShape.html:4617,Testability,log,logical,4617,"ical (transformed); Float_tfColor[17]! GL color array; TGLPShapeRef*fFirstPSRef! pointer to first reference; UInt_tfID! unique physical ID within containing scene; Bool_tfInvertedWind! face winding TODO: can get directly from fTransform?; const TGLLogicalShape*fLogicalShape! the associated logical shape; TGLPhysicalShape::EManipfManip! permitted manipulation bitflags - see EManip; Bool_tfModified! has been modified - retain across scene rebuilds; TGLPhysicalShape*fNextPhysical! pointer to next replica; UChar_tfSelected! selected state; TGLMatrixfTransform! transform (placement) of physical instance. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLPhysicalShape(UInt_t ID, const TGLLogicalShape& logicalShape, const TGLMatrix& transform, Bool_t invertedWind, const Float_t* rgba); Construct a physical shape using arguments:; ID - unique drawable id.; logicalShape - bound logical shape; transform - transform for placement of logical drawing; invertedWind - use inverted face polygon winding?; rgba - basic four component (RGBA) diffuse color. TGLPhysicalShape(UInt_t ID, const TGLLogicalShape& logicalShape, const double* transform, Bool_t invertedWind, const Float_t* rgba); Construct a physical shape using arguments:; id - unique drawable id.; logicalShape - bound logical shape; transform - 16 Double_t component transform for placement of logical drawing; invertedWind - use inverted face polygon winding?; rgba - basic four component (RGBA) diffuse color. ~TGLPhysicalShape(); Destroy the physical shape. void AddReference(TGLPShapeRef* ref); Add reference ref. void RemoveReference(TGLPShapeRef* ref); Remove reference ref. void Modified(); Call this after modifying the physical so that the information; can be propagated to the object referencing it. void UpdateBoundingBox(); Update our internal bounding box (in global frame). void InitColor(const Float_t* rgba); Initialise the colors, using basic RGBA diffuse material color supplie",MatchSource.WIKI,root/html528/TGLPhysicalShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLPhysicalShape.html
https://root.cern/root/html528/TGLPhysicalShape.html:4671,Testability,log,logical,4671,"ical (transformed); Float_tfColor[17]! GL color array; TGLPShapeRef*fFirstPSRef! pointer to first reference; UInt_tfID! unique physical ID within containing scene; Bool_tfInvertedWind! face winding TODO: can get directly from fTransform?; const TGLLogicalShape*fLogicalShape! the associated logical shape; TGLPhysicalShape::EManipfManip! permitted manipulation bitflags - see EManip; Bool_tfModified! has been modified - retain across scene rebuilds; TGLPhysicalShape*fNextPhysical! pointer to next replica; UChar_tfSelected! selected state; TGLMatrixfTransform! transform (placement) of physical instance. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLPhysicalShape(UInt_t ID, const TGLLogicalShape& logicalShape, const TGLMatrix& transform, Bool_t invertedWind, const Float_t* rgba); Construct a physical shape using arguments:; ID - unique drawable id.; logicalShape - bound logical shape; transform - transform for placement of logical drawing; invertedWind - use inverted face polygon winding?; rgba - basic four component (RGBA) diffuse color. TGLPhysicalShape(UInt_t ID, const TGLLogicalShape& logicalShape, const double* transform, Bool_t invertedWind, const Float_t* rgba); Construct a physical shape using arguments:; id - unique drawable id.; logicalShape - bound logical shape; transform - 16 Double_t component transform for placement of logical drawing; invertedWind - use inverted face polygon winding?; rgba - basic four component (RGBA) diffuse color. ~TGLPhysicalShape(); Destroy the physical shape. void AddReference(TGLPShapeRef* ref); Add reference ref. void RemoveReference(TGLPShapeRef* ref); Remove reference ref. void Modified(); Call this after modifying the physical so that the information; can be propagated to the object referencing it. void UpdateBoundingBox(); Update our internal bounding box (in global frame). void InitColor(const Float_t* rgba); Initialise the colors, using basic RGBA diffuse material color supplie",MatchSource.WIKI,root/html528/TGLPhysicalShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLPhysicalShape.html
https://root.cern/root/html528/TGLPhysicalShape.html:4840,Testability,log,logicalShape,4840,"TODO: can get directly from fTransform?; const TGLLogicalShape*fLogicalShape! the associated logical shape; TGLPhysicalShape::EManipfManip! permitted manipulation bitflags - see EManip; Bool_tfModified! has been modified - retain across scene rebuilds; TGLPhysicalShape*fNextPhysical! pointer to next replica; UChar_tfSelected! selected state; TGLMatrixfTransform! transform (placement) of physical instance. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLPhysicalShape(UInt_t ID, const TGLLogicalShape& logicalShape, const TGLMatrix& transform, Bool_t invertedWind, const Float_t* rgba); Construct a physical shape using arguments:; ID - unique drawable id.; logicalShape - bound logical shape; transform - transform for placement of logical drawing; invertedWind - use inverted face polygon winding?; rgba - basic four component (RGBA) diffuse color. TGLPhysicalShape(UInt_t ID, const TGLLogicalShape& logicalShape, const double* transform, Bool_t invertedWind, const Float_t* rgba); Construct a physical shape using arguments:; id - unique drawable id.; logicalShape - bound logical shape; transform - 16 Double_t component transform for placement of logical drawing; invertedWind - use inverted face polygon winding?; rgba - basic four component (RGBA) diffuse color. ~TGLPhysicalShape(); Destroy the physical shape. void AddReference(TGLPShapeRef* ref); Add reference ref. void RemoveReference(TGLPShapeRef* ref); Remove reference ref. void Modified(); Call this after modifying the physical so that the information; can be propagated to the object referencing it. void UpdateBoundingBox(); Update our internal bounding box (in global frame). void InitColor(const Float_t* rgba); Initialise the colors, using basic RGBA diffuse material color supplied. void SetColor(const Float_t* rgba); Set full color attributes - see OpenGL material documentation; for full description.; 0->3 diffuse, 4->7 ambient, 8->11 specular, 12->15 emission, 16 shininess.",MatchSource.WIKI,root/html528/TGLPhysicalShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLPhysicalShape.html
https://root.cern/root/html528/TGLPhysicalShape.html:4993,Testability,log,logicalShape,4993,"n modified - retain across scene rebuilds; TGLPhysicalShape*fNextPhysical! pointer to next replica; UChar_tfSelected! selected state; TGLMatrixfTransform! transform (placement) of physical instance. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLPhysicalShape(UInt_t ID, const TGLLogicalShape& logicalShape, const TGLMatrix& transform, Bool_t invertedWind, const Float_t* rgba); Construct a physical shape using arguments:; ID - unique drawable id.; logicalShape - bound logical shape; transform - transform for placement of logical drawing; invertedWind - use inverted face polygon winding?; rgba - basic four component (RGBA) diffuse color. TGLPhysicalShape(UInt_t ID, const TGLLogicalShape& logicalShape, const double* transform, Bool_t invertedWind, const Float_t* rgba); Construct a physical shape using arguments:; id - unique drawable id.; logicalShape - bound logical shape; transform - 16 Double_t component transform for placement of logical drawing; invertedWind - use inverted face polygon winding?; rgba - basic four component (RGBA) diffuse color. ~TGLPhysicalShape(); Destroy the physical shape. void AddReference(TGLPShapeRef* ref); Add reference ref. void RemoveReference(TGLPShapeRef* ref); Remove reference ref. void Modified(); Call this after modifying the physical so that the information; can be propagated to the object referencing it. void UpdateBoundingBox(); Update our internal bounding box (in global frame). void InitColor(const Float_t* rgba); Initialise the colors, using basic RGBA diffuse material color supplied. void SetColor(const Float_t* rgba); Set full color attributes - see OpenGL material documentation; for full description.; 0->3 diffuse, 4->7 ambient, 8->11 specular, 12->15 emission, 16 shininess. void SetColorOnFamily(const Float_t* rgba); Set full color attributes to all physicals sharing the same; logical with this object. void SetDiffuseColor(const Float_t rgba[4]); Set color from ROOT color index ",MatchSource.WIKI,root/html528/TGLPhysicalShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLPhysicalShape.html
https://root.cern/root/html528/TGLPhysicalShape.html:5014,Testability,log,logical,5014,"n modified - retain across scene rebuilds; TGLPhysicalShape*fNextPhysical! pointer to next replica; UChar_tfSelected! selected state; TGLMatrixfTransform! transform (placement) of physical instance. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLPhysicalShape(UInt_t ID, const TGLLogicalShape& logicalShape, const TGLMatrix& transform, Bool_t invertedWind, const Float_t* rgba); Construct a physical shape using arguments:; ID - unique drawable id.; logicalShape - bound logical shape; transform - transform for placement of logical drawing; invertedWind - use inverted face polygon winding?; rgba - basic four component (RGBA) diffuse color. TGLPhysicalShape(UInt_t ID, const TGLLogicalShape& logicalShape, const double* transform, Bool_t invertedWind, const Float_t* rgba); Construct a physical shape using arguments:; id - unique drawable id.; logicalShape - bound logical shape; transform - 16 Double_t component transform for placement of logical drawing; invertedWind - use inverted face polygon winding?; rgba - basic four component (RGBA) diffuse color. ~TGLPhysicalShape(); Destroy the physical shape. void AddReference(TGLPShapeRef* ref); Add reference ref. void RemoveReference(TGLPShapeRef* ref); Remove reference ref. void Modified(); Call this after modifying the physical so that the information; can be propagated to the object referencing it. void UpdateBoundingBox(); Update our internal bounding box (in global frame). void InitColor(const Float_t* rgba); Initialise the colors, using basic RGBA diffuse material color supplied. void SetColor(const Float_t* rgba); Set full color attributes - see OpenGL material documentation; for full description.; 0->3 diffuse, 4->7 ambient, 8->11 specular, 12->15 emission, 16 shininess. void SetColorOnFamily(const Float_t* rgba); Set full color attributes to all physicals sharing the same; logical with this object. void SetDiffuseColor(const Float_t rgba[4]); Set color from ROOT color index ",MatchSource.WIKI,root/html528/TGLPhysicalShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLPhysicalShape.html
https://root.cern/root/html528/TGLPhysicalShape.html:5090,Testability,log,logical,5090,"n modified - retain across scene rebuilds; TGLPhysicalShape*fNextPhysical! pointer to next replica; UChar_tfSelected! selected state; TGLMatrixfTransform! transform (placement) of physical instance. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLPhysicalShape(UInt_t ID, const TGLLogicalShape& logicalShape, const TGLMatrix& transform, Bool_t invertedWind, const Float_t* rgba); Construct a physical shape using arguments:; ID - unique drawable id.; logicalShape - bound logical shape; transform - transform for placement of logical drawing; invertedWind - use inverted face polygon winding?; rgba - basic four component (RGBA) diffuse color. TGLPhysicalShape(UInt_t ID, const TGLLogicalShape& logicalShape, const double* transform, Bool_t invertedWind, const Float_t* rgba); Construct a physical shape using arguments:; id - unique drawable id.; logicalShape - bound logical shape; transform - 16 Double_t component transform for placement of logical drawing; invertedWind - use inverted face polygon winding?; rgba - basic four component (RGBA) diffuse color. ~TGLPhysicalShape(); Destroy the physical shape. void AddReference(TGLPShapeRef* ref); Add reference ref. void RemoveReference(TGLPShapeRef* ref); Remove reference ref. void Modified(); Call this after modifying the physical so that the information; can be propagated to the object referencing it. void UpdateBoundingBox(); Update our internal bounding box (in global frame). void InitColor(const Float_t* rgba); Initialise the colors, using basic RGBA diffuse material color supplied. void SetColor(const Float_t* rgba); Set full color attributes - see OpenGL material documentation; for full description.; 0->3 diffuse, 4->7 ambient, 8->11 specular, 12->15 emission, 16 shininess. void SetColorOnFamily(const Float_t* rgba); Set full color attributes to all physicals sharing the same; logical with this object. void SetDiffuseColor(const Float_t rgba[4]); Set color from ROOT color index ",MatchSource.WIKI,root/html528/TGLPhysicalShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLPhysicalShape.html
https://root.cern/root/html528/TGLPhysicalShape.html:5996,Testability,log,logical,5996,"arguments:; id - unique drawable id.; logicalShape - bound logical shape; transform - 16 Double_t component transform for placement of logical drawing; invertedWind - use inverted face polygon winding?; rgba - basic four component (RGBA) diffuse color. ~TGLPhysicalShape(); Destroy the physical shape. void AddReference(TGLPShapeRef* ref); Add reference ref. void RemoveReference(TGLPShapeRef* ref); Remove reference ref. void Modified(); Call this after modifying the physical so that the information; can be propagated to the object referencing it. void UpdateBoundingBox(); Update our internal bounding box (in global frame). void InitColor(const Float_t* rgba); Initialise the colors, using basic RGBA diffuse material color supplied. void SetColor(const Float_t* rgba); Set full color attributes - see OpenGL material documentation; for full description.; 0->3 diffuse, 4->7 ambient, 8->11 specular, 12->15 emission, 16 shininess. void SetColorOnFamily(const Float_t* rgba); Set full color attributes to all physicals sharing the same; logical with this object. void SetDiffuseColor(const Float_t rgba[4]); Set color from ROOT color index and transparency [0,100]. void SetDiffuseColor(const UChar_t rgba[4]); Set color from RGBA quadruplet. void SetDiffuseColor(Color_t ci, UChar_t transparency); Set color from standard ROOT representation, that is color index; + transparency in range [0, 100]. void SetupGLColors(TGLRnrCtx& rnrCtx, const Float_t* color = 0) const; Setup colors - avoid setting things not required; for current draw flags. void Draw(TGLRnrCtx& rnrCtx) const; Draw physical shape, using LOD flags, potential from display list cache. void CalculateShapeLOD(TGLRnrCtx& rnrCtx, Float_t& pixSize, Short_t& shapeLOD) const; Calculate shape-lod, suitible for use under; projection defined by 'rnrCtx', taking account of which local; axes of the shape support LOD adjustment, and the global; 'sceneFlags' passed. Returned shapeLOD component is from 0 (kLODPixel - lowest; quality) to ",MatchSource.WIKI,root/html528/TGLPhysicalShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLPhysicalShape.html
https://root.cern/root/html528/TGLPhysicalShape.html:7266,Testability,log,logical,7266,"r from standard ROOT representation, that is color index; + transparency in range [0, 100]. void SetupGLColors(TGLRnrCtx& rnrCtx, const Float_t* color = 0) const; Setup colors - avoid setting things not required; for current draw flags. void Draw(TGLRnrCtx& rnrCtx) const; Draw physical shape, using LOD flags, potential from display list cache. void CalculateShapeLOD(TGLRnrCtx& rnrCtx, Float_t& pixSize, Short_t& shapeLOD) const; Calculate shape-lod, suitible for use under; projection defined by 'rnrCtx', taking account of which local; axes of the shape support LOD adjustment, and the global; 'sceneFlags' passed. Returned shapeLOD component is from 0 (kLODPixel - lowest; quality) to 100 (kLODHigh - highest quality). Scene flags are not used. LOD quantization is not done. RnrCtx; is not modified as this is called via lodification stage of; rendering. void QuantizeShapeLOD(Short_t shapeLOD, Short_t combiLOD, Short_t& quantLOD) const; Factor in scene/vierer LOD and Quantize ... forward to; logical shape. void InvokeContextMenu(TContextMenu& menu, UInt_t x, UInt_t y) const; Request creation of context menu on shape, attached to 'menu' at screen position; 'x' 'y'. TGLVector3 GetScale() const. TGLVertex3 GetTranslation() const. void SetTransform(const TGLMatrix& transform). void SetTransform(const Double_t* vals). void SetTranslation(const TGLVertex3& translation). void Translate(const TGLVector3& vect). void Scale(const TGLVector3& scale). void Rotate(const TGLVertex3& pivot, const TGLVector3& axis, Double_t angle). TGLPhysicalShape(const TGLPhysicalShape& ). TGLPhysicalShape& operator=(const TGLPhysicalShape& ). UInt_t ID() const; { return fID; }. const TGLLogicalShape * GetLogical() const; { return fLogicalShape; }. const TGLPhysicalShape * GetNextPhysical() const; { return fNextPhysical; }. EManip GetManip() const; Modification and manipulation. { return fManip; }. void SetManip(TGLPhysicalShape::EManip manip); { fManip = manip; }. Bool_t IsModified() const; { return fMo",MatchSource.WIKI,root/html528/TGLPhysicalShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLPhysicalShape.html
https://root.cern/root/html528/TGLPlane.html:446,Security,access,accessors,446,". TGLPlane. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLPlane. class TGLPlane. TGLPlane. 3D plane class - of format Ax + By + Cz + D = 0. This is part of collection of simple utility classes for GL only in; TGLUtil.h/cxx. These provide const and non-const accessors Arr() &; CArr() to a GL compatible internal field - so can be used directly; with OpenGL C API calls - which TVector3 etc cannot (easily).; They are not intended to be fully featured just provide minimum; required. Function Members (Methods); public:. TGLPlane(); TGLPlane(const TGLPlane& other); TGLPlane(Double_t* eq); TGLPlane(const TGLVector3& norm, const TGLVertex3& point); TGLPlane(const TGLVertex3& p1, const TGLVertex3& p2, const TGLVertex3& p3); TGLPlane(Double_t a, Double_t b, Double_t c, Double_t d); virtual~TGLPlane(); Double_tA() const; Double_t*Arr(); Double_tB() const; Double_tC() const; const Double_t*CArr() const; static TClass*Class(); Double_tD() const; Double_tDistanceTo(const TGLVertex3& vertex) const; voidDump() const; virtual TClass*IsA() const; TGLVertex3NearestOn(const TGLVertex3& point) const; voidNegate(); TGLVector3Norm() const; TGLPlane&operator=(const TGLPlane&); voidSet(const TGLPlane& other); voidSet(Double_t* eq); voidSet(const TGLVector3& norm, const TGLVertex3& point); voidSet(const TGLVertex3& p1, const TGLVertex3& p2, const TGLVertex3& p3); voidSet(Double_t a, Double_t b, Double_t c, Double_t d); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). private:. voidNormalise(). Data Members; private:. Double_tfVals[4]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLPlane(); Construct a default plane of x + y + z = 0. TGLPlane(const TGLPlane& other); Construct plane from 'other'. T",MatchSource.WIKI,root/html528/TGLPlane.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLPlane.html
https://root.cern/root/html528/TGLPlane.html:358,Usability,simpl,simple,358,". TGLPlane. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLPlane. class TGLPlane. TGLPlane. 3D plane class - of format Ax + By + Cz + D = 0. This is part of collection of simple utility classes for GL only in; TGLUtil.h/cxx. These provide const and non-const accessors Arr() &; CArr() to a GL compatible internal field - so can be used directly; with OpenGL C API calls - which TVector3 etc cannot (easily).; They are not intended to be fully featured just provide minimum; required. Function Members (Methods); public:. TGLPlane(); TGLPlane(const TGLPlane& other); TGLPlane(Double_t* eq); TGLPlane(const TGLVector3& norm, const TGLVertex3& point); TGLPlane(const TGLVertex3& p1, const TGLVertex3& p2, const TGLVertex3& p3); TGLPlane(Double_t a, Double_t b, Double_t c, Double_t d); virtual~TGLPlane(); Double_tA() const; Double_t*Arr(); Double_tB() const; Double_tC() const; const Double_t*CArr() const; static TClass*Class(); Double_tD() const; Double_tDistanceTo(const TGLVertex3& vertex) const; voidDump() const; virtual TClass*IsA() const; TGLVertex3NearestOn(const TGLVertex3& point) const; voidNegate(); TGLVector3Norm() const; TGLPlane&operator=(const TGLPlane&); voidSet(const TGLPlane& other); voidSet(Double_t* eq); voidSet(const TGLVector3& norm, const TGLVertex3& point); voidSet(const TGLVertex3& p1, const TGLVertex3& p2, const TGLVertex3& p3); voidSet(Double_t a, Double_t b, Double_t c, Double_t d); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). private:. voidNormalise(). Data Members; private:. Double_tfVals[4]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLPlane(); Construct a default plane of x + y + z = 0. TGLPlane(const TGLPlane& other); Construct plane from 'other'. T",MatchSource.WIKI,root/html528/TGLPlane.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLPlane.html
https://root.cern/root/html528/TGLPlot3D.html:450,Availability,avail,available,450,". TGLPlot3D. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLPlot3D. class TGLPlot3D: public TGLObject. Description of TGLPlot3D. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TGLPlot3D(); voidTGLLogicalShape::AddRef(TGLPhysicalShape* phys) const; virtual Bool_tTGLLogicalShape::AlwaysSecondarySelect() const; const TGLBoundingBox&TGLLogicalShape::BoundingBox() const; static TClass*Class(); static TGLPlot3D*CreatePlot(TObject* obj, Option_t* opt, TVirtualPad* pad); static TGLPlot3D*CreatePlot(TObject* obj, Option_t* opt, Bool_t logx, Bool_t logy, Bool_t logz); voidTGLLogicalShape::DestroyPhysicals(); virtual voidTGLLogicalShape::DirectDraw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DLCacheClear(); virtual voidTGLLogicalShape::DLCacheDrop(); virtual voidTGLLogicalShape::DLCachePurge(); virtual UInt_tTGLLogicalShape::DLOffset(Short_t) const; virtual voidTGLLogicalShape::Draw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DrawHighlight(TGLRnrCtx& rnrCtx, const TGLPhysicalShape* pshp, Int_t lvl = -1) const; TObject*TGLLogicalShape::GetExternal() const; const TGLPhysicalShape*TGLLogicalShape::GetFirstPhysical() const; static TClass*TGLObject::GetGLRenderer(TClass* isa); TGLScene*TGLLogicalShape::GetScene() const; TObject*TGLLogicalShape::ID() const; virtual Bool_tTGLLogicalShape::IgnoreSizeForOfInterest() const; voidTGLLogicalShape::InvokeContextMenu(TContextMenu& menu, UInt_t x, UInt_t y) const; virtual TClass*IsA() const; virtual Bool_tKeepDuringSmartRefresh() const; virtual voidTGLLogicalShape::ProcessSelection(TGLRnrCtx& rnrCtx, TGLSelectRecord& rec); virtual Short_tTGLLogicalShape::QuantizeShapeLOD(Short_t shapeLOD, Short_t combiLOD) const",MatchSource.WIKI,root/html528/TGLPlot3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLPlot3D.html
https://root.cern/root/html528/TGLPlot3D.html:2114,Performance,cache,cached,2114,"Pad* pad); static TGLPlot3D*CreatePlot(TObject* obj, Option_t* opt, Bool_t logx, Bool_t logy, Bool_t logz); voidTGLLogicalShape::DestroyPhysicals(); virtual voidTGLLogicalShape::DirectDraw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DLCacheClear(); virtual voidTGLLogicalShape::DLCacheDrop(); virtual voidTGLLogicalShape::DLCachePurge(); virtual UInt_tTGLLogicalShape::DLOffset(Short_t) const; virtual voidTGLLogicalShape::Draw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DrawHighlight(TGLRnrCtx& rnrCtx, const TGLPhysicalShape* pshp, Int_t lvl = -1) const; TObject*TGLLogicalShape::GetExternal() const; const TGLPhysicalShape*TGLLogicalShape::GetFirstPhysical() const; static TClass*TGLObject::GetGLRenderer(TClass* isa); TGLScene*TGLLogicalShape::GetScene() const; TObject*TGLLogicalShape::ID() const; virtual Bool_tTGLLogicalShape::IgnoreSizeForOfInterest() const; voidTGLLogicalShape::InvokeContextMenu(TContextMenu& menu, UInt_t x, UInt_t y) const; virtual TClass*IsA() const; virtual Bool_tKeepDuringSmartRefresh() const; virtual voidTGLLogicalShape::ProcessSelection(TGLRnrCtx& rnrCtx, TGLSelectRecord& rec); virtual Short_tTGLLogicalShape::QuantizeShapeLOD(Short_t shapeLOD, Short_t combiLOD) const; UInt_tTGLLogicalShape::Ref() const; virtual voidTGLObject::SetBBox(); Bool_tTGLLogicalShape::SetDLCache(Bool_t cached); virtual Bool_tTGLObject::SetModel(TObject* obj, Option_t* opt = 0); virtual Bool_tTGLObject::ShouldDLCache(const TGLRnrCtx& rnrCtx) const; virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); voidTGLLogicalShape::StrongRef(Bool_t strong) const; voidTGLLogicalShape::SubRef(TGLPhysicalShape* phys) const; virtual TGLLogicalShape::ELODAxesTGLLogicalShape::SupportedLODAxes() const; virtual Bool_tTGLLogicalShape::SupportsSecondarySelect() const; UInt_tTGLLogicalShape::UnrefFirstPhysical(); virtual voidTGLObject::UpdateBoundingBox(); voidTGLLogicalShape::UpdateBoundingBoxesOfPhysicals().",MatchSource.WIKI,root/html528/TGLPlot3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLPlot3D.html
https://root.cern/root/html528/TGLPlot3D.html:848,Testability,log,logx,848," virtual~TGLPlot3D(); voidTGLLogicalShape::AddRef(TGLPhysicalShape* phys) const; virtual Bool_tTGLLogicalShape::AlwaysSecondarySelect() const; const TGLBoundingBox&TGLLogicalShape::BoundingBox() const; static TClass*Class(); static TGLPlot3D*CreatePlot(TObject* obj, Option_t* opt, TVirtualPad* pad); static TGLPlot3D*CreatePlot(TObject* obj, Option_t* opt, Bool_t logx, Bool_t logy, Bool_t logz); voidTGLLogicalShape::DestroyPhysicals(); virtual voidTGLLogicalShape::DirectDraw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DLCacheClear(); virtual voidTGLLogicalShape::DLCacheDrop(); virtual voidTGLLogicalShape::DLCachePurge(); virtual UInt_tTGLLogicalShape::DLOffset(Short_t) const; virtual voidTGLLogicalShape::Draw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DrawHighlight(TGLRnrCtx& rnrCtx, const TGLPhysicalShape* pshp, Int_t lvl = -1) const; TObject*TGLLogicalShape::GetExternal() const; const TGLPhysicalShape*TGLLogicalShape::GetFirstPhysical() const; static TClass*TGLObject::GetGLRenderer(TClass* isa); TGLScene*TGLLogicalShape::GetScene() const; TObject*TGLLogicalShape::ID() const; virtual Bool_tTGLLogicalShape::IgnoreSizeForOfInterest() const; voidTGLLogicalShape::InvokeContextMenu(TContextMenu& menu, UInt_t x, UInt_t y) const; virtual TClass*IsA() const; virtual Bool_tKeepDuringSmartRefresh() const; virtual voidTGLLogicalShape::ProcessSelection(TGLRnrCtx& rnrCtx, TGLSelectRecord& rec); virtual Short_tTGLLogicalShape::QuantizeShapeLOD(Short_t shapeLOD, Short_t combiLOD) const",MatchSource.WIKI,root/html528/TGLPlot3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLPlot3D.html
https://root.cern/root/html528/TGLPlot3D.html:861,Testability,log,logy,861," virtual~TGLPlot3D(); voidTGLLogicalShape::AddRef(TGLPhysicalShape* phys) const; virtual Bool_tTGLLogicalShape::AlwaysSecondarySelect() const; const TGLBoundingBox&TGLLogicalShape::BoundingBox() const; static TClass*Class(); static TGLPlot3D*CreatePlot(TObject* obj, Option_t* opt, TVirtualPad* pad); static TGLPlot3D*CreatePlot(TObject* obj, Option_t* opt, Bool_t logx, Bool_t logy, Bool_t logz); voidTGLLogicalShape::DestroyPhysicals(); virtual voidTGLLogicalShape::DirectDraw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DLCacheClear(); virtual voidTGLLogicalShape::DLCacheDrop(); virtual voidTGLLogicalShape::DLCachePurge(); virtual UInt_tTGLLogicalShape::DLOffset(Short_t) const; virtual voidTGLLogicalShape::Draw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DrawHighlight(TGLRnrCtx& rnrCtx, const TGLPhysicalShape* pshp, Int_t lvl = -1) const; TObject*TGLLogicalShape::GetExternal() const; const TGLPhysicalShape*TGLLogicalShape::GetFirstPhysical() const; static TClass*TGLObject::GetGLRenderer(TClass* isa); TGLScene*TGLLogicalShape::GetScene() const; TObject*TGLLogicalShape::ID() const; virtual Bool_tTGLLogicalShape::IgnoreSizeForOfInterest() const; voidTGLLogicalShape::InvokeContextMenu(TContextMenu& menu, UInt_t x, UInt_t y) const; virtual TClass*IsA() const; virtual Bool_tKeepDuringSmartRefresh() const; virtual voidTGLLogicalShape::ProcessSelection(TGLRnrCtx& rnrCtx, TGLSelectRecord& rec); virtual Short_tTGLLogicalShape::QuantizeShapeLOD(Short_t shapeLOD, Short_t combiLOD) const",MatchSource.WIKI,root/html528/TGLPlot3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLPlot3D.html
https://root.cern/root/html528/TGLPlot3D.html:874,Testability,log,logz,874," virtual~TGLPlot3D(); voidTGLLogicalShape::AddRef(TGLPhysicalShape* phys) const; virtual Bool_tTGLLogicalShape::AlwaysSecondarySelect() const; const TGLBoundingBox&TGLLogicalShape::BoundingBox() const; static TClass*Class(); static TGLPlot3D*CreatePlot(TObject* obj, Option_t* opt, TVirtualPad* pad); static TGLPlot3D*CreatePlot(TObject* obj, Option_t* opt, Bool_t logx, Bool_t logy, Bool_t logz); voidTGLLogicalShape::DestroyPhysicals(); virtual voidTGLLogicalShape::DirectDraw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DLCacheClear(); virtual voidTGLLogicalShape::DLCacheDrop(); virtual voidTGLLogicalShape::DLCachePurge(); virtual UInt_tTGLLogicalShape::DLOffset(Short_t) const; virtual voidTGLLogicalShape::Draw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DrawHighlight(TGLRnrCtx& rnrCtx, const TGLPhysicalShape* pshp, Int_t lvl = -1) const; TObject*TGLLogicalShape::GetExternal() const; const TGLPhysicalShape*TGLLogicalShape::GetFirstPhysical() const; static TClass*TGLObject::GetGLRenderer(TClass* isa); TGLScene*TGLLogicalShape::GetScene() const; TObject*TGLLogicalShape::ID() const; virtual Bool_tTGLLogicalShape::IgnoreSizeForOfInterest() const; voidTGLLogicalShape::InvokeContextMenu(TContextMenu& menu, UInt_t x, UInt_t y) const; virtual TClass*IsA() const; virtual Bool_tKeepDuringSmartRefresh() const; virtual voidTGLLogicalShape::ProcessSelection(TGLRnrCtx& rnrCtx, TGLSelectRecord& rec); virtual Short_tTGLLogicalShape::QuantizeShapeLOD(Short_t shapeLOD, Short_t combiLOD) const",MatchSource.WIKI,root/html528/TGLPlot3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLPlot3D.html
https://root.cern/root/html528/TGLPlot3D.html:4663,Testability,log,logarithmic,4663,"ngBoxTGLLogicalShape::fBoundingBox! Shape's bounding box.; TGLPlotCoordinatesfCoord; UInt_tTGLLogicalShape::fDLBase! display-list id base; Bool_tTGLLogicalShape::fDLCache! use display list caching; Int_tTGLLogicalShape::fDLSize! display-list size for different LODs; UShort_tTGLLogicalShape::fDLValid! display-list validity bit-field; TObject*TGLLogicalShape::fExternalObj! Also plays the role of ID.; TGLPhysicalShape*TGLLogicalShape::fFirstPhysical! first replica; Bool_tTGLObject::fMultiColorAre multiple colors used for object rendering.; Bool_tTGLLogicalShape::fOwnExtObj! External object is a fake; TGLPlotPainter*fPlotPainter; UInt_tTGLLogicalShape::fRef! physical instance ref counting; Bool_tTGLLogicalShape::fRefStrong! Strong ref (delete on 0 ref); not in scene; TGLScene*TGLLogicalShape::fScene! scene where object is stored (can be zero!). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~TGLPlot3D(); Destructor. void SetPainter(TGLPlotPainter* p); Set painter object and destroy the old one. TGLPlot3D* InstantiatePlot(TObject* obj); Instantiate the correct plot-painter for given object.; Protected method. TGLPlot3D* CreatePlot(TObject* obj, Option_t* opt, TVirtualPad* pad); Create GL plot for specified object and options.; Which axes are logarithmic is determined from a pad. TGLPlot3D* CreatePlot(TObject* obj, Option_t* opt, Bool_t logx, Bool_t logy, Bool_t logz); Create GL plot for specified object and options.; Which axes are logarithmic is determined from explicit arguments. TGLPlot3D& operator=(const TGLPlot3D& ). Bool_t KeepDuringSmartRefresh() const; { return kFALSE; }. » Author: Matevz Tadel 2007 » Copyright (C) 1995-2007, Rene Brun and Fons Rademakers. *; » Last changed: root/gl:$Id: TGLPlot3D.h 33579 2010-05-19 12:43:08Z rdm $ » Last generated: 2010-09-23 20:06; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html528/TGLPlot3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLPlot3D.html
https://root.cern/root/html528/TGLPlot3D.html:4759,Testability,log,logx,4759,"ngBoxTGLLogicalShape::fBoundingBox! Shape's bounding box.; TGLPlotCoordinatesfCoord; UInt_tTGLLogicalShape::fDLBase! display-list id base; Bool_tTGLLogicalShape::fDLCache! use display list caching; Int_tTGLLogicalShape::fDLSize! display-list size for different LODs; UShort_tTGLLogicalShape::fDLValid! display-list validity bit-field; TObject*TGLLogicalShape::fExternalObj! Also plays the role of ID.; TGLPhysicalShape*TGLLogicalShape::fFirstPhysical! first replica; Bool_tTGLObject::fMultiColorAre multiple colors used for object rendering.; Bool_tTGLLogicalShape::fOwnExtObj! External object is a fake; TGLPlotPainter*fPlotPainter; UInt_tTGLLogicalShape::fRef! physical instance ref counting; Bool_tTGLLogicalShape::fRefStrong! Strong ref (delete on 0 ref); not in scene; TGLScene*TGLLogicalShape::fScene! scene where object is stored (can be zero!). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~TGLPlot3D(); Destructor. void SetPainter(TGLPlotPainter* p); Set painter object and destroy the old one. TGLPlot3D* InstantiatePlot(TObject* obj); Instantiate the correct plot-painter for given object.; Protected method. TGLPlot3D* CreatePlot(TObject* obj, Option_t* opt, TVirtualPad* pad); Create GL plot for specified object and options.; Which axes are logarithmic is determined from a pad. TGLPlot3D* CreatePlot(TObject* obj, Option_t* opt, Bool_t logx, Bool_t logy, Bool_t logz); Create GL plot for specified object and options.; Which axes are logarithmic is determined from explicit arguments. TGLPlot3D& operator=(const TGLPlot3D& ). Bool_t KeepDuringSmartRefresh() const; { return kFALSE; }. » Author: Matevz Tadel 2007 » Copyright (C) 1995-2007, Rene Brun and Fons Rademakers. *; » Last changed: root/gl:$Id: TGLPlot3D.h 33579 2010-05-19 12:43:08Z rdm $ » Last generated: 2010-09-23 20:06; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html528/TGLPlot3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLPlot3D.html
https://root.cern/root/html528/TGLPlot3D.html:4772,Testability,log,logy,4772,"ngBoxTGLLogicalShape::fBoundingBox! Shape's bounding box.; TGLPlotCoordinatesfCoord; UInt_tTGLLogicalShape::fDLBase! display-list id base; Bool_tTGLLogicalShape::fDLCache! use display list caching; Int_tTGLLogicalShape::fDLSize! display-list size for different LODs; UShort_tTGLLogicalShape::fDLValid! display-list validity bit-field; TObject*TGLLogicalShape::fExternalObj! Also plays the role of ID.; TGLPhysicalShape*TGLLogicalShape::fFirstPhysical! first replica; Bool_tTGLObject::fMultiColorAre multiple colors used for object rendering.; Bool_tTGLLogicalShape::fOwnExtObj! External object is a fake; TGLPlotPainter*fPlotPainter; UInt_tTGLLogicalShape::fRef! physical instance ref counting; Bool_tTGLLogicalShape::fRefStrong! Strong ref (delete on 0 ref); not in scene; TGLScene*TGLLogicalShape::fScene! scene where object is stored (can be zero!). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~TGLPlot3D(); Destructor. void SetPainter(TGLPlotPainter* p); Set painter object and destroy the old one. TGLPlot3D* InstantiatePlot(TObject* obj); Instantiate the correct plot-painter for given object.; Protected method. TGLPlot3D* CreatePlot(TObject* obj, Option_t* opt, TVirtualPad* pad); Create GL plot for specified object and options.; Which axes are logarithmic is determined from a pad. TGLPlot3D* CreatePlot(TObject* obj, Option_t* opt, Bool_t logx, Bool_t logy, Bool_t logz); Create GL plot for specified object and options.; Which axes are logarithmic is determined from explicit arguments. TGLPlot3D& operator=(const TGLPlot3D& ). Bool_t KeepDuringSmartRefresh() const; { return kFALSE; }. » Author: Matevz Tadel 2007 » Copyright (C) 1995-2007, Rene Brun and Fons Rademakers. *; » Last changed: root/gl:$Id: TGLPlot3D.h 33579 2010-05-19 12:43:08Z rdm $ » Last generated: 2010-09-23 20:06; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html528/TGLPlot3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLPlot3D.html
https://root.cern/root/html528/TGLPlot3D.html:4785,Testability,log,logz,4785,"ngBoxTGLLogicalShape::fBoundingBox! Shape's bounding box.; TGLPlotCoordinatesfCoord; UInt_tTGLLogicalShape::fDLBase! display-list id base; Bool_tTGLLogicalShape::fDLCache! use display list caching; Int_tTGLLogicalShape::fDLSize! display-list size for different LODs; UShort_tTGLLogicalShape::fDLValid! display-list validity bit-field; TObject*TGLLogicalShape::fExternalObj! Also plays the role of ID.; TGLPhysicalShape*TGLLogicalShape::fFirstPhysical! first replica; Bool_tTGLObject::fMultiColorAre multiple colors used for object rendering.; Bool_tTGLLogicalShape::fOwnExtObj! External object is a fake; TGLPlotPainter*fPlotPainter; UInt_tTGLLogicalShape::fRef! physical instance ref counting; Bool_tTGLLogicalShape::fRefStrong! Strong ref (delete on 0 ref); not in scene; TGLScene*TGLLogicalShape::fScene! scene where object is stored (can be zero!). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~TGLPlot3D(); Destructor. void SetPainter(TGLPlotPainter* p); Set painter object and destroy the old one. TGLPlot3D* InstantiatePlot(TObject* obj); Instantiate the correct plot-painter for given object.; Protected method. TGLPlot3D* CreatePlot(TObject* obj, Option_t* opt, TVirtualPad* pad); Create GL plot for specified object and options.; Which axes are logarithmic is determined from a pad. TGLPlot3D* CreatePlot(TObject* obj, Option_t* opt, Bool_t logx, Bool_t logy, Bool_t logz); Create GL plot for specified object and options.; Which axes are logarithmic is determined from explicit arguments. TGLPlot3D& operator=(const TGLPlot3D& ). Bool_t KeepDuringSmartRefresh() const; { return kFALSE; }. » Author: Matevz Tadel 2007 » Copyright (C) 1995-2007, Rene Brun and Fons Rademakers. *; » Last changed: root/gl:$Id: TGLPlot3D.h 33579 2010-05-19 12:43:08Z rdm $ » Last generated: 2010-09-23 20:06; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html528/TGLPlot3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLPlot3D.html
https://root.cern/root/html528/TGLPlot3D.html:4857,Testability,log,logarithmic,4857,"ngBoxTGLLogicalShape::fBoundingBox! Shape's bounding box.; TGLPlotCoordinatesfCoord; UInt_tTGLLogicalShape::fDLBase! display-list id base; Bool_tTGLLogicalShape::fDLCache! use display list caching; Int_tTGLLogicalShape::fDLSize! display-list size for different LODs; UShort_tTGLLogicalShape::fDLValid! display-list validity bit-field; TObject*TGLLogicalShape::fExternalObj! Also plays the role of ID.; TGLPhysicalShape*TGLLogicalShape::fFirstPhysical! first replica; Bool_tTGLObject::fMultiColorAre multiple colors used for object rendering.; Bool_tTGLLogicalShape::fOwnExtObj! External object is a fake; TGLPlotPainter*fPlotPainter; UInt_tTGLLogicalShape::fRef! physical instance ref counting; Bool_tTGLLogicalShape::fRefStrong! Strong ref (delete on 0 ref); not in scene; TGLScene*TGLLogicalShape::fScene! scene where object is stored (can be zero!). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~TGLPlot3D(); Destructor. void SetPainter(TGLPlotPainter* p); Set painter object and destroy the old one. TGLPlot3D* InstantiatePlot(TObject* obj); Instantiate the correct plot-painter for given object.; Protected method. TGLPlot3D* CreatePlot(TObject* obj, Option_t* opt, TVirtualPad* pad); Create GL plot for specified object and options.; Which axes are logarithmic is determined from a pad. TGLPlot3D* CreatePlot(TObject* obj, Option_t* opt, Bool_t logx, Bool_t logy, Bool_t logz); Create GL plot for specified object and options.; Which axes are logarithmic is determined from explicit arguments. TGLPlot3D& operator=(const TGLPlot3D& ). Bool_t KeepDuringSmartRefresh() const; { return kFALSE; }. » Author: Matevz Tadel 2007 » Copyright (C) 1995-2007, Rene Brun and Fons Rademakers. *; » Last changed: root/gl:$Id: TGLPlot3D.h 33579 2010-05-19 12:43:08Z rdm $ » Last generated: 2010-09-23 20:06; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html528/TGLPlot3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLPlot3D.html
https://root.cern/root/html528/TGLPlotCoordinates.html:1614,Availability,error,errors,1614,"bers; data members; class charts. ROOT; » GRAF3D; » GL; » TGLPlotCoordinates. class TGLPlotCoordinates. Helper class for plot-painters holding information about axis; ranges, numbers of bins and flags if certain axis is logartihmic. Function Members (Methods); public:. TGLPlotCoordinates(); virtual~TGLPlotCoordinates(); static TClass*Class(); EGLCoordTypeGetCoordType() const; Double_tGetFactor() const; Int_tGetFirstXBin() const; Int_tGetFirstYBin() const; Int_tGetFirstZBin() const; Int_tGetLastXBin() const; Int_tGetLastYBin() const; Int_tGetLastZBin() const; Int_tGetNXBins() const; Int_tGetNYBins() const; Int_tGetNZBins() const; const Rgl::BinRange_t&GetXBins() const; Double_tGetXLength() const; Bool_tGetXLog() const; const Rgl::Range_t&GetXRange() const; const Rgl::Range_t&GetXRangeScaled() const; Double_tGetXScale() const; const Rgl::BinRange_t&GetYBins() const; Double_tGetYLength() const; Bool_tGetYLog() const; const Rgl::Range_t&GetYRange() const; const Rgl::Range_t&GetYRangeScaled() const; Double_tGetYScale() const; const Rgl::BinRange_t&GetZBins() const; Double_tGetZLength() const; Bool_tGetZLog() const; const Rgl::Range_t&GetZRange() const; const Rgl::Range_t&GetZRangeScaled() const; Double_tGetZScale() const; virtual TClass*IsA() const; Bool_tModified() const; voidResetModified(); voidSetCoordType(EGLCoordType type); Bool_tSetRanges(TH2Poly* hist); Bool_tSetRanges(const TH1* hist, Bool_t errors = kFALSE, Bool_t zBins = kFALSE); Bool_tSetRanges(const TAxis* xAxis, const TAxis* yAxis, const TAxis* zAxis); voidSetXLog(Bool_t xLog); voidSetYLog(Bool_t yLog); voidSetZLog(Bool_t zLog); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). private:. TGLPlotCoordinates(const TGLPlotCoordinates&); TGLPlotCoordinates&operator=(const TGLPlotCoordinates&); Bool_tSetRangesCartesian(const TH1* hist, Bool_t errors = kFALSE, Bool_t zBins = kFALSE); Bool_tSetRangesCylindrical(const TH1* hist); Bool_tSetRangesPola",MatchSource.WIKI,root/html528/TGLPlotCoordinates.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLPlotCoordinates.html
https://root.cern/root/html528/TGLPlotCoordinates.html:2090,Availability,error,errors,2090,"st; Bool_tGetYLog() const; const Rgl::Range_t&GetYRange() const; const Rgl::Range_t&GetYRangeScaled() const; Double_tGetYScale() const; const Rgl::BinRange_t&GetZBins() const; Double_tGetZLength() const; Bool_tGetZLog() const; const Rgl::Range_t&GetZRange() const; const Rgl::Range_t&GetZRangeScaled() const; Double_tGetZScale() const; virtual TClass*IsA() const; Bool_tModified() const; voidResetModified(); voidSetCoordType(EGLCoordType type); Bool_tSetRanges(TH2Poly* hist); Bool_tSetRanges(const TH1* hist, Bool_t errors = kFALSE, Bool_t zBins = kFALSE); Bool_tSetRanges(const TAxis* xAxis, const TAxis* yAxis, const TAxis* zAxis); voidSetXLog(Bool_t xLog); voidSetYLog(Bool_t yLog); voidSetZLog(Bool_t zLog); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). private:. TGLPlotCoordinates(const TGLPlotCoordinates&); TGLPlotCoordinates&operator=(const TGLPlotCoordinates&); Bool_tSetRangesCartesian(const TH1* hist, Bool_t errors = kFALSE, Bool_t zBins = kFALSE); Bool_tSetRangesCylindrical(const TH1* hist); Bool_tSetRangesPolar(const TH1* hist); Bool_tSetRangesSpherical(const TH1* hist). Data Members; private:. EGLCoordTypefCoordType; Double_tfFactor; Bool_tfModified; pair<int,int>fXBins; Bool_tfXLog; pair<double,double>fXRange; pair<double,double>fXRangeScaled; Double_tfXScale; pair<int,int>fYBins; Bool_tfYLog; pair<double,double>fYRange; pair<double,double>fYRangeScaled; Double_tfYScale; pair<int,int>fZBins; Bool_tfZLog; pair<double,double>fZRange; pair<double,double>fZRangeScaled; Double_tfZScale. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLPlotCoordinates(); Constructor. ~TGLPlotCoordinates(); Destructor. void SetCoordType(EGLCoordType type); If coord type was changed, plot must reset sections (if any),; set fModified. EGLCoordType GetCoordType() const; Get coordinates type. void SetXLog(Bool_t xLog); If log changed, sections must be reset,; set fModified. B",MatchSource.WIKI,root/html528/TGLPlotCoordinates.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLPlotCoordinates.html
https://root.cern/root/html528/TGLPlotCoordinates.html:3481,Availability,error,errors,3481,"double,double>fYRange; pair<double,double>fYRangeScaled; Double_tfYScale; pair<int,int>fZBins; Bool_tfZLog; pair<double,double>fZRange; pair<double,double>fZRangeScaled; Double_tfZScale. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLPlotCoordinates(); Constructor. ~TGLPlotCoordinates(); Destructor. void SetCoordType(EGLCoordType type); If coord type was changed, plot must reset sections (if any),; set fModified. EGLCoordType GetCoordType() const; Get coordinates type. void SetXLog(Bool_t xLog); If log changed, sections must be reset,; set fModified. Bool_t GetXLog() const; Get X log. void SetYLog(Bool_t yLog); If log changed, sections must be reset,; set fModified. Bool_t GetYLog() const; Get Y log. void SetZLog(Bool_t zLog); If log changed, sections must be reset,; set fModified. Bool_t GetZLog() const; Get Z log. void ResetModified(); Reset modified. Bool_t Modified() const; Modified. Bool_t SetRanges(const TH1* hist, Bool_t errors = kFALSE, Bool_t zBins = kFALSE); Set bin ranges, ranges. Int_t GetNXBins() const; Number of X bins. Int_t GetNYBins() const; Number of Y bins. Int_t GetNZBins() const; Number of Z bins. const Rgl::BinRange_t & GetXBins() const; X bins range. const Rgl::BinRange_t & GetYBins() const; Y bins range. const Rgl::BinRange_t & GetZBins() const; Z bins range. const Rgl::Range_t & GetXRange() const; X range. Double_t GetXLength() const; X length. const Rgl::Range_t & GetYRange() const; Y range. Double_t GetYLength() const; Y length. const Rgl::Range_t & GetZRange() const; Z range. Double_t GetZLength() const; Z length. const Rgl::Range_t & GetXRangeScaled() const; Scaled range. const Rgl::Range_t & GetYRangeScaled() const; Scaled range. const Rgl::Range_t & GetZRangeScaled() const; Scaled range. Double_t GetFactor() const; Get factor. Bool_t SetRangesCartesian(const TH1* hist, Bool_t errors = kFALSE, Bool_t zBins = kFALSE); Set bin ranges, ranges, etc. Bool_t SetRanges(TH2Poly* hist); Set bin rang",MatchSource.WIKI,root/html528/TGLPlotCoordinates.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLPlotCoordinates.html
https://root.cern/root/html528/TGLPlotCoordinates.html:4377,Availability,error,errors,4377,"); Reset modified. Bool_t Modified() const; Modified. Bool_t SetRanges(const TH1* hist, Bool_t errors = kFALSE, Bool_t zBins = kFALSE); Set bin ranges, ranges. Int_t GetNXBins() const; Number of X bins. Int_t GetNYBins() const; Number of Y bins. Int_t GetNZBins() const; Number of Z bins. const Rgl::BinRange_t & GetXBins() const; X bins range. const Rgl::BinRange_t & GetYBins() const; Y bins range. const Rgl::BinRange_t & GetZBins() const; Z bins range. const Rgl::Range_t & GetXRange() const; X range. Double_t GetXLength() const; X length. const Rgl::Range_t & GetYRange() const; Y range. Double_t GetYLength() const; Y length. const Rgl::Range_t & GetZRange() const; Z range. Double_t GetZLength() const; Z length. const Rgl::Range_t & GetXRangeScaled() const; Scaled range. const Rgl::Range_t & GetYRangeScaled() const; Scaled range. const Rgl::Range_t & GetZRangeScaled() const; Scaled range. Double_t GetFactor() const; Get factor. Bool_t SetRangesCartesian(const TH1* hist, Bool_t errors = kFALSE, Bool_t zBins = kFALSE); Set bin ranges, ranges, etc. Bool_t SetRanges(TH2Poly* hist); Set bin ranges, ranges, etc. Bool_t SetRanges(const TAxis* xAxis, const TAxis* yAxis, const TAxis* zAxis); Set bin ranges, ranges, etc. Bool_t SetRangesPolar(const TH1* hist); Set bin ranges, ranges, etc. Bool_t SetRangesCylindrical(const TH1* hist); Set ranges cylindrical. Bool_t SetRangesSpherical(const TH1* hist); Set ranges spherical. TGLPlotCoordinates(). Double_t GetXScale() const; {return fXScale;}. Double_t GetYScale() const; {return fYScale;}. Double_t GetZScale() const; {return fZScale;}. Int_t GetFirstXBin() const; {return fXBins.first;}. Int_t GetLastXBin() const; {return fXBins.second;}. Int_t GetFirstYBin() const; {return fYBins.first;}. Int_t GetLastYBin() const; {return fYBins.second;}. Int_t GetFirstZBin() const; {return fZBins.first;}. Int_t GetLastZBin() const; {return fZBins.second;}. » Author: Timur Pocheptsov 14/06/2006 » Copyright (C) 1995-2004, Rene Brun and Fons Radema",MatchSource.WIKI,root/html528/TGLPlotCoordinates.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLPlotCoordinates.html
https://root.cern/root/html528/TGLPlotCoordinates.html:415,Testability,log,logartihmic,415,". TGLPlotCoordinates. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLPlotCoordinates. class TGLPlotCoordinates. Helper class for plot-painters holding information about axis; ranges, numbers of bins and flags if certain axis is logartihmic. Function Members (Methods); public:. TGLPlotCoordinates(); virtual~TGLPlotCoordinates(); static TClass*Class(); EGLCoordTypeGetCoordType() const; Double_tGetFactor() const; Int_tGetFirstXBin() const; Int_tGetFirstYBin() const; Int_tGetFirstZBin() const; Int_tGetLastXBin() const; Int_tGetLastYBin() const; Int_tGetLastZBin() const; Int_tGetNXBins() const; Int_tGetNYBins() const; Int_tGetNZBins() const; const Rgl::BinRange_t&GetXBins() const; Double_tGetXLength() const; Bool_tGetXLog() const; const Rgl::Range_t&GetXRange() const; const Rgl::Range_t&GetXRangeScaled() const; Double_tGetXScale() const; const Rgl::BinRange_t&GetYBins() const; Double_tGetYLength() const; Bool_tGetYLog() const; const Rgl::Range_t&GetYRange() const; const Rgl::Range_t&GetYRangeScaled() const; Double_tGetYScale() const; const Rgl::BinRange_t&GetZBins() const; Double_tGetZLength() const; Bool_tGetZLog() const; const Rgl::Range_t&GetZRange() const; const Rgl::Range_t&GetZRangeScaled() const; Double_tGetZScale() const; virtual TClass*IsA() const; Bool_tModified() const; voidResetModified(); voidSetCoordType(EGLCoordType type); Bool_tSetRanges(TH2Poly* hist); Bool_tSetRanges(const TH1* hist, Bool_t errors = kFALSE, Bool_t zBins = kFALSE); Bool_tSetRanges(const TAxis* xAxis, const TAxis* yAxis, const TAxis* zAxis); voidSetXLog(Bool_t xLog); voidSetYLog(Bool_t yLog); voidSetZLog(Bool_t zLog); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). private:. TGLPlotCoordinates(const TGLPlotCoordinates&); TGLPlotCoordinate",MatchSource.WIKI,root/html528/TGLPlotCoordinates.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLPlotCoordinates.html
https://root.cern/root/html528/TGLPlotCoordinates.html:3043,Testability,log,log,3043,"gesCartesian(const TH1* hist, Bool_t errors = kFALSE, Bool_t zBins = kFALSE); Bool_tSetRangesCylindrical(const TH1* hist); Bool_tSetRangesPolar(const TH1* hist); Bool_tSetRangesSpherical(const TH1* hist). Data Members; private:. EGLCoordTypefCoordType; Double_tfFactor; Bool_tfModified; pair<int,int>fXBins; Bool_tfXLog; pair<double,double>fXRange; pair<double,double>fXRangeScaled; Double_tfXScale; pair<int,int>fYBins; Bool_tfYLog; pair<double,double>fYRange; pair<double,double>fYRangeScaled; Double_tfYScale; pair<int,int>fZBins; Bool_tfZLog; pair<double,double>fZRange; pair<double,double>fZRangeScaled; Double_tfZScale. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLPlotCoordinates(); Constructor. ~TGLPlotCoordinates(); Destructor. void SetCoordType(EGLCoordType type); If coord type was changed, plot must reset sections (if any),; set fModified. EGLCoordType GetCoordType() const; Get coordinates type. void SetXLog(Bool_t xLog); If log changed, sections must be reset,; set fModified. Bool_t GetXLog() const; Get X log. void SetYLog(Bool_t yLog); If log changed, sections must be reset,; set fModified. Bool_t GetYLog() const; Get Y log. void SetZLog(Bool_t zLog); If log changed, sections must be reset,; set fModified. Bool_t GetZLog() const; Get Z log. void ResetModified(); Reset modified. Bool_t Modified() const; Modified. Bool_t SetRanges(const TH1* hist, Bool_t errors = kFALSE, Bool_t zBins = kFALSE); Set bin ranges, ranges. Int_t GetNXBins() const; Number of X bins. Int_t GetNYBins() const; Number of Y bins. Int_t GetNZBins() const; Number of Z bins. const Rgl::BinRange_t & GetXBins() const; X bins range. const Rgl::BinRange_t & GetYBins() const; Y bins range. const Rgl::BinRange_t & GetZBins() const; Z bins range. const Rgl::Range_t & GetXRange() const; X range. Double_t GetXLength() const; X length. const Rgl::Range_t & GetYRange() const; Y range. Double_t GetYLength() const; Y length. const Rgl::Range_t & GetZRange() co",MatchSource.WIKI,root/html528/TGLPlotCoordinates.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLPlotCoordinates.html
https://root.cern/root/html528/TGLPlotCoordinates.html:3126,Testability,log,log,3126,"t zBins = kFALSE); Bool_tSetRangesCylindrical(const TH1* hist); Bool_tSetRangesPolar(const TH1* hist); Bool_tSetRangesSpherical(const TH1* hist). Data Members; private:. EGLCoordTypefCoordType; Double_tfFactor; Bool_tfModified; pair<int,int>fXBins; Bool_tfXLog; pair<double,double>fXRange; pair<double,double>fXRangeScaled; Double_tfXScale; pair<int,int>fYBins; Bool_tfYLog; pair<double,double>fYRange; pair<double,double>fYRangeScaled; Double_tfYScale; pair<int,int>fZBins; Bool_tfZLog; pair<double,double>fZRange; pair<double,double>fZRangeScaled; Double_tfZScale. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLPlotCoordinates(); Constructor. ~TGLPlotCoordinates(); Destructor. void SetCoordType(EGLCoordType type); If coord type was changed, plot must reset sections (if any),; set fModified. EGLCoordType GetCoordType() const; Get coordinates type. void SetXLog(Bool_t xLog); If log changed, sections must be reset,; set fModified. Bool_t GetXLog() const; Get X log. void SetYLog(Bool_t yLog); If log changed, sections must be reset,; set fModified. Bool_t GetYLog() const; Get Y log. void SetZLog(Bool_t zLog); If log changed, sections must be reset,; set fModified. Bool_t GetZLog() const; Get Z log. void ResetModified(); Reset modified. Bool_t Modified() const; Modified. Bool_t SetRanges(const TH1* hist, Bool_t errors = kFALSE, Bool_t zBins = kFALSE); Set bin ranges, ranges. Int_t GetNXBins() const; Number of X bins. Int_t GetNYBins() const; Number of Y bins. Int_t GetNZBins() const; Number of Z bins. const Rgl::BinRange_t & GetXBins() const; X bins range. const Rgl::BinRange_t & GetYBins() const; Y bins range. const Rgl::BinRange_t & GetZBins() const; Z bins range. const Rgl::Range_t & GetXRange() const; X range. Double_t GetXLength() const; X length. const Rgl::Range_t & GetYRange() const; Y range. Double_t GetYLength() const; Y length. const Rgl::Range_t & GetZRange() const; Z range. Double_t GetZLength() const; Z length. const ",MatchSource.WIKI,root/html528/TGLPlotCoordinates.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLPlotCoordinates.html
https://root.cern/root/html528/TGLPlotCoordinates.html:3161,Testability,log,log,3161,"st); Bool_tSetRangesPolar(const TH1* hist); Bool_tSetRangesSpherical(const TH1* hist). Data Members; private:. EGLCoordTypefCoordType; Double_tfFactor; Bool_tfModified; pair<int,int>fXBins; Bool_tfXLog; pair<double,double>fXRange; pair<double,double>fXRangeScaled; Double_tfXScale; pair<int,int>fYBins; Bool_tfYLog; pair<double,double>fYRange; pair<double,double>fYRangeScaled; Double_tfYScale; pair<int,int>fZBins; Bool_tfZLog; pair<double,double>fZRange; pair<double,double>fZRangeScaled; Double_tfZScale. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLPlotCoordinates(); Constructor. ~TGLPlotCoordinates(); Destructor. void SetCoordType(EGLCoordType type); If coord type was changed, plot must reset sections (if any),; set fModified. EGLCoordType GetCoordType() const; Get coordinates type. void SetXLog(Bool_t xLog); If log changed, sections must be reset,; set fModified. Bool_t GetXLog() const; Get X log. void SetYLog(Bool_t yLog); If log changed, sections must be reset,; set fModified. Bool_t GetYLog() const; Get Y log. void SetZLog(Bool_t zLog); If log changed, sections must be reset,; set fModified. Bool_t GetZLog() const; Get Z log. void ResetModified(); Reset modified. Bool_t Modified() const; Modified. Bool_t SetRanges(const TH1* hist, Bool_t errors = kFALSE, Bool_t zBins = kFALSE); Set bin ranges, ranges. Int_t GetNXBins() const; Number of X bins. Int_t GetNYBins() const; Number of Y bins. Int_t GetNZBins() const; Number of Z bins. const Rgl::BinRange_t & GetXBins() const; X bins range. const Rgl::BinRange_t & GetYBins() const; Y bins range. const Rgl::BinRange_t & GetZBins() const; Z bins range. const Rgl::Range_t & GetXRange() const; X range. Double_t GetXLength() const; X length. const Rgl::Range_t & GetYRange() const; Y range. Double_t GetYLength() const; Y length. const Rgl::Range_t & GetZRange() const; Z range. Double_t GetZLength() const; Z length. const Rgl::Range_t & GetXRangeScaled() const; Scaled range. const",MatchSource.WIKI,root/html528/TGLPlotCoordinates.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLPlotCoordinates.html
https://root.cern/root/html528/TGLPlotCoordinates.html:3244,Testability,log,log,3244,"Spherical(const TH1* hist). Data Members; private:. EGLCoordTypefCoordType; Double_tfFactor; Bool_tfModified; pair<int,int>fXBins; Bool_tfXLog; pair<double,double>fXRange; pair<double,double>fXRangeScaled; Double_tfXScale; pair<int,int>fYBins; Bool_tfYLog; pair<double,double>fYRange; pair<double,double>fYRangeScaled; Double_tfYScale; pair<int,int>fZBins; Bool_tfZLog; pair<double,double>fZRange; pair<double,double>fZRangeScaled; Double_tfZScale. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLPlotCoordinates(); Constructor. ~TGLPlotCoordinates(); Destructor. void SetCoordType(EGLCoordType type); If coord type was changed, plot must reset sections (if any),; set fModified. EGLCoordType GetCoordType() const; Get coordinates type. void SetXLog(Bool_t xLog); If log changed, sections must be reset,; set fModified. Bool_t GetXLog() const; Get X log. void SetYLog(Bool_t yLog); If log changed, sections must be reset,; set fModified. Bool_t GetYLog() const; Get Y log. void SetZLog(Bool_t zLog); If log changed, sections must be reset,; set fModified. Bool_t GetZLog() const; Get Z log. void ResetModified(); Reset modified. Bool_t Modified() const; Modified. Bool_t SetRanges(const TH1* hist, Bool_t errors = kFALSE, Bool_t zBins = kFALSE); Set bin ranges, ranges. Int_t GetNXBins() const; Number of X bins. Int_t GetNYBins() const; Number of Y bins. Int_t GetNZBins() const; Number of Z bins. const Rgl::BinRange_t & GetXBins() const; X bins range. const Rgl::BinRange_t & GetYBins() const; Y bins range. const Rgl::BinRange_t & GetZBins() const; Z bins range. const Rgl::Range_t & GetXRange() const; X range. Double_t GetXLength() const; X length. const Rgl::Range_t & GetYRange() const; Y range. Double_t GetYLength() const; Y length. const Rgl::Range_t & GetZRange() const; Z range. Double_t GetZLength() const; Z length. const Rgl::Range_t & GetXRangeScaled() const; Scaled range. const Rgl::Range_t & GetYRangeScaled() const; Scaled range. cons",MatchSource.WIKI,root/html528/TGLPlotCoordinates.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLPlotCoordinates.html
https://root.cern/root/html528/TGLPlotCoordinates.html:3279,Testability,log,log,3279,"dTypefCoordType; Double_tfFactor; Bool_tfModified; pair<int,int>fXBins; Bool_tfXLog; pair<double,double>fXRange; pair<double,double>fXRangeScaled; Double_tfXScale; pair<int,int>fYBins; Bool_tfYLog; pair<double,double>fYRange; pair<double,double>fYRangeScaled; Double_tfYScale; pair<int,int>fZBins; Bool_tfZLog; pair<double,double>fZRange; pair<double,double>fZRangeScaled; Double_tfZScale. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLPlotCoordinates(); Constructor. ~TGLPlotCoordinates(); Destructor. void SetCoordType(EGLCoordType type); If coord type was changed, plot must reset sections (if any),; set fModified. EGLCoordType GetCoordType() const; Get coordinates type. void SetXLog(Bool_t xLog); If log changed, sections must be reset,; set fModified. Bool_t GetXLog() const; Get X log. void SetYLog(Bool_t yLog); If log changed, sections must be reset,; set fModified. Bool_t GetYLog() const; Get Y log. void SetZLog(Bool_t zLog); If log changed, sections must be reset,; set fModified. Bool_t GetZLog() const; Get Z log. void ResetModified(); Reset modified. Bool_t Modified() const; Modified. Bool_t SetRanges(const TH1* hist, Bool_t errors = kFALSE, Bool_t zBins = kFALSE); Set bin ranges, ranges. Int_t GetNXBins() const; Number of X bins. Int_t GetNYBins() const; Number of Y bins. Int_t GetNZBins() const; Number of Z bins. const Rgl::BinRange_t & GetXBins() const; X bins range. const Rgl::BinRange_t & GetYBins() const; Y bins range. const Rgl::BinRange_t & GetZBins() const; Z bins range. const Rgl::Range_t & GetXRange() const; X range. Double_t GetXLength() const; X length. const Rgl::Range_t & GetYRange() const; Y range. Double_t GetYLength() const; Y length. const Rgl::Range_t & GetZRange() const; Z range. Double_t GetZLength() const; Z length. const Rgl::Range_t & GetXRangeScaled() const; Scaled range. const Rgl::Range_t & GetYRangeScaled() const; Scaled range. const Rgl::Range_t & GetZRangeScaled() const; Scaled range. Dou",MatchSource.WIKI,root/html528/TGLPlotCoordinates.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLPlotCoordinates.html
https://root.cern/root/html528/TGLPlotCoordinates.html:3362,Testability,log,log,3362,",int>fXBins; Bool_tfXLog; pair<double,double>fXRange; pair<double,double>fXRangeScaled; Double_tfXScale; pair<int,int>fYBins; Bool_tfYLog; pair<double,double>fYRange; pair<double,double>fYRangeScaled; Double_tfYScale; pair<int,int>fZBins; Bool_tfZLog; pair<double,double>fZRange; pair<double,double>fZRangeScaled; Double_tfZScale. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLPlotCoordinates(); Constructor. ~TGLPlotCoordinates(); Destructor. void SetCoordType(EGLCoordType type); If coord type was changed, plot must reset sections (if any),; set fModified. EGLCoordType GetCoordType() const; Get coordinates type. void SetXLog(Bool_t xLog); If log changed, sections must be reset,; set fModified. Bool_t GetXLog() const; Get X log. void SetYLog(Bool_t yLog); If log changed, sections must be reset,; set fModified. Bool_t GetYLog() const; Get Y log. void SetZLog(Bool_t zLog); If log changed, sections must be reset,; set fModified. Bool_t GetZLog() const; Get Z log. void ResetModified(); Reset modified. Bool_t Modified() const; Modified. Bool_t SetRanges(const TH1* hist, Bool_t errors = kFALSE, Bool_t zBins = kFALSE); Set bin ranges, ranges. Int_t GetNXBins() const; Number of X bins. Int_t GetNYBins() const; Number of Y bins. Int_t GetNZBins() const; Number of Z bins. const Rgl::BinRange_t & GetXBins() const; X bins range. const Rgl::BinRange_t & GetYBins() const; Y bins range. const Rgl::BinRange_t & GetZBins() const; Z bins range. const Rgl::Range_t & GetXRange() const; X range. Double_t GetXLength() const; X length. const Rgl::Range_t & GetYRange() const; Y range. Double_t GetYLength() const; Y length. const Rgl::Range_t & GetZRange() const; Z range. Double_t GetZLength() const; Z length. const Rgl::Range_t & GetXRangeScaled() const; Scaled range. const Rgl::Range_t & GetYRangeScaled() const; Scaled range. const Rgl::Range_t & GetZRangeScaled() const; Scaled range. Double_t GetFactor() const; Get factor. Bool_t SetRangesCartes",MatchSource.WIKI,root/html528/TGLPlotCoordinates.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLPlotCoordinates.html
https://root.cern/root/html528/TGLPlotPainter.html:571,Availability,avail,available,571,". TGLPlotPainter. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLPlotPainter. class TGLPlotPainter: public TVirtualGLPainter. Base class for plot-painters that provide GL rendering of various; 2D and 3D histograms, functions and parametric surfaces. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. ~TGLPlotPainter(); virtual voidAddOption(const TString& stringOption); static TClass*Class(); Bool_tCutAxisSelected() const; virtual voidDeInitGL() const; virtual voidDrawPlot() const; virtual char*TVirtualGLPainter::GetPlotInfo(Int_t px, Int_t py); virtual Bool_tInitGeometry(); virtual voidInitGL() const; voidInvalidateSelection(); virtual TClass*IsA() const; TVirtualGLPainter&TVirtualGLPainter::operator=(const TVirtualGLPainter&); virtual voidPaint(); virtual voidTVirtualGLPainter::Pan(Int_t px, Int_t py); virtual Bool_tPlotSelected(Int_t px, Int_t py); virtual voidProcessEvent(Int_t event, Int_t px, Int_t py); const TGLPlotBox&RefBackBox() const; virtual voidSetFrameColor(const TColor* frameColor); voidSetPadColor(const TColor* color); virtual voidShowMembers(TMemberInspector& insp); virtual voidStartPan(Int_t px, Int_t py); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). protected:. virtual voidClearBuffers() const; virtual voidDrawPaletteAxis() const; voidDrawSections() const; virtual voidDrawSectionXOY() const; virtual voidDrawSectionXOZ() const; virtual voidDrawSectionYOZ() const; const TColor*GetPadColor() const; voidMoveSection(Int_t px, Int_t py); voidPrintPlot() const; voidRestoreModelviewMatrix() const; voidRestoreProjectionMatrix() const; voidSaveModelviewMatrix() const; voidSaveProjectionMatrix() const. Data Members; public:. enum ESelectio",MatchSource.WIKI,root/html528/TGLPlotPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLPlotPainter.html
https://root.cern/root/html528/TGLPlotPainter.html:3084,Deployability,update,updated,3084,"num ECutAxisID { kXAxis; kYAxis; kZAxis; };. protected:. TGLPlotBoxfBackBox; TGLBoxCutfBoxCut; TGLPlotCamera*fCamera; TGLPlotCoordinates*fCoord; Bool_tfDrawPalette; Bool_tfHighColor; TH1*fHist; TPointfMousePosition; Double_tfPadPhi; Double_tfPadTheta; Int_tfSelectedPart; TGLSelectionBufferfSelection; TGLPlotPainter::ESelectionBasefSelectionBase; Bool_tfSelectionPass; Bool_tfUpdateSelection; TAxis*fXAxis; Double_tfXOYSectionPos; Double_tfXOZSectionPos; TAxis*fYAxis; Double_tfYOZSectionPos; TAxis*fZAxis; vector<Double_t>fZLevels. private:. const TColor*fPadColor. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void Paint(); Draw lego/surf/whatever you can. void PrintPlot() const; Generate PS using gl2ps. Bool_t PlotSelected(Int_t px, Int_t py); Read color buffer content to find selected object. void SetPadColor(const TColor* color); Used in a pad. void SetFrameColor(const TColor* frameColor); Set plot's back box color. void InvalidateSelection(); Selection must be updated. const TColor * GetPadColor() const; Get pad color. void MoveSection(Int_t px, Int_t py); Create dynamic profile using selected plane. void DrawSections() const; Draw sections (if any). void ClearBuffers() const. // Clear buffer.; Float_t rgb[3] = {1.f, 1.f, 1.f};; if (const TColor *color = GetPadColor()); color->GetRGB(rgb[0], rgb[1], rgb[2]);; glClearColor(rgb[0], rgb[1], rgb[2], 1.);; glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);. void DrawPaletteAxis() const; Draw. Palette. Axis. void SaveModelviewMatrix() const. void SaveProjectionMatrix() const. void RestoreModelviewMatrix() const. void RestoreProjectionMatrix() const. const TGLPlotBox& RefBackBox() const; { return fBackBox; }. void InitGL() const. void DeInitGL() const. void DrawPlot() const. Bool_t InitGeometry(); Init geometry does plot's specific initialization. void StartPan(Int_t px, Int_t py); Pan function is already declared in TVirtualGLPainter. void AddOption(const TString& stringOption)",MatchSource.WIKI,root/html528/TGLPlotPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLPlotPainter.html
https://root.cern/root/html528/TGLPolyLine.html:3574,Modifiability,inherit,inheritance,3574,"Shape::StrongRef(Bool_t strong) const; voidTGLLogicalShape::SubRef(TGLPhysicalShape* phys) const; virtual TGLLogicalShape::ELODAxesTGLLogicalShape::SupportedLODAxes() const; virtual Bool_tTGLLogicalShape::SupportsSecondarySelect() const; UInt_tTGLLogicalShape::UnrefFirstPhysical(); virtual voidTGLLogicalShape::UpdateBoundingBox(); voidTGLLogicalShape::UpdateBoundingBoxesOfPhysicals(). protected:. voidTGLLogicalShape::PurgeDLRange(UInt_t base, Int_t size) const. Data Members; public:. enum TGLLogicalShape::ELODAxes { kLODAxesNone; kLODAxesX; kLODAxesY; kLODAxesZ; kLODAxesAll; };. protected:. TGLBoundingBoxTGLLogicalShape::fBoundingBox! Shape's bounding box.; UInt_tTGLLogicalShape::fDLBase! display-list id base; Bool_tTGLLogicalShape::fDLCache! use display list caching; Int_tTGLLogicalShape::fDLSize! display-list size for different LODs; UShort_tTGLLogicalShape::fDLValid! display-list validity bit-field; TObject*TGLLogicalShape::fExternalObj! Also plays the role of ID.; TGLPhysicalShape*TGLLogicalShape::fFirstPhysical! first replica; Bool_tTGLLogicalShape::fOwnExtObj! External object is a fake; UInt_tTGLLogicalShape::fRef! physical instance ref counting; Bool_tTGLLogicalShape::fRefStrong! Strong ref (delete on 0 ref); not in scene; TGLScene*TGLLogicalShape::fScene! scene where object is stored (can be zero!). private:. Double_tfLineWidth; vector<Double_t>fVertices. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLPolyLine(const TBuffer3D& buffer); constructor; dynamic_cast because of multiple inheritance. void DirectDraw(TGLRnrCtx& rnrCtx) const; Debug tracing. » Author: Timur Pocheptsov 03/08/2004 » Copyright (C) 1995-2006, Rene Brun and Fons Rademakers. *; » Last changed: root/gl:$Id: TGLPolyLine.h 21252 2007-12-07 01:39:32Z matevz $ » Last generated: 2010-09-23 20:06; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html528/TGLPolyLine.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLPolyLine.html
https://root.cern/root/html528/TGLPolyLine.html:1796,Performance,cache,cached,1796,"yLine(const TBuffer3D& buffer); ~TGLPolyLine(); voidTGLLogicalShape::AddRef(TGLPhysicalShape* phys) const; virtual Bool_tTGLLogicalShape::AlwaysSecondarySelect() const; const TGLBoundingBox&TGLLogicalShape::BoundingBox() const; static TClass*Class(); voidTGLLogicalShape::DestroyPhysicals(); virtual voidDirectDraw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DLCacheClear(); virtual voidTGLLogicalShape::DLCacheDrop(); virtual voidTGLLogicalShape::DLCachePurge(); virtual UInt_tTGLLogicalShape::DLOffset(Short_t) const; virtual voidTGLLogicalShape::Draw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DrawHighlight(TGLRnrCtx& rnrCtx, const TGLPhysicalShape* pshp, Int_t lvl = -1) const; TObject*TGLLogicalShape::GetExternal() const; const TGLPhysicalShape*TGLLogicalShape::GetFirstPhysical() const; TGLScene*TGLLogicalShape::GetScene() const; TObject*TGLLogicalShape::ID() const; virtual Bool_tTGLLogicalShape::IgnoreSizeForOfInterest() const; voidTGLLogicalShape::InvokeContextMenu(TContextMenu& menu, UInt_t x, UInt_t y) const; virtual TClass*IsA() const; virtual Bool_tTGLLogicalShape::KeepDuringSmartRefresh() const; virtual voidTGLLogicalShape::ProcessSelection(TGLRnrCtx& rnrCtx, TGLSelectRecord& rec); virtual Short_tTGLLogicalShape::QuantizeShapeLOD(Short_t shapeLOD, Short_t combiLOD) const; UInt_tTGLLogicalShape::Ref() const; Bool_tTGLLogicalShape::SetDLCache(Bool_t cached); virtual Bool_tTGLLogicalShape::ShouldDLCache(const TGLRnrCtx& rnrCtx) const; virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); voidTGLLogicalShape::StrongRef(Bool_t strong) const; voidTGLLogicalShape::SubRef(TGLPhysicalShape* phys) const; virtual TGLLogicalShape::ELODAxesTGLLogicalShape::SupportedLODAxes() const; virtual Bool_tTGLLogicalShape::SupportsSecondarySelect() const; UInt_tTGLLogicalShape::UnrefFirstPhysical(); virtual voidTGLLogicalShape::UpdateBoundingBox(); voidTGLLogicalShape::UpdateBoundingBoxesOfPhysicals().",MatchSource.WIKI,root/html528/TGLPolyLine.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLPolyLine.html
https://root.cern/root/html528/TGLPolyMarker.html:1793,Performance,cache,cached,1793,"c:. TGLPolyMarker(const TBuffer3D& buffer); ~TGLPolyMarker(); voidTGLLogicalShape::AddRef(TGLPhysicalShape* phys) const; virtual Bool_tTGLLogicalShape::AlwaysSecondarySelect() const; const TGLBoundingBox&TGLLogicalShape::BoundingBox() const; static TClass*Class(); voidTGLLogicalShape::DestroyPhysicals(); virtual voidDirectDraw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DLCacheClear(); virtual voidTGLLogicalShape::DLCacheDrop(); virtual voidTGLLogicalShape::DLCachePurge(); virtual UInt_tTGLLogicalShape::DLOffset(Short_t) const; virtual voidTGLLogicalShape::Draw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DrawHighlight(TGLRnrCtx& rnrCtx, const TGLPhysicalShape* pshp, Int_t lvl = -1) const; TObject*TGLLogicalShape::GetExternal() const; const TGLPhysicalShape*TGLLogicalShape::GetFirstPhysical() const; TGLScene*TGLLogicalShape::GetScene() const; TObject*TGLLogicalShape::ID() const; virtual Bool_tIgnoreSizeForOfInterest() const; voidTGLLogicalShape::InvokeContextMenu(TContextMenu& menu, UInt_t x, UInt_t y) const; virtual TClass*IsA() const; virtual Bool_tTGLLogicalShape::KeepDuringSmartRefresh() const; virtual voidTGLLogicalShape::ProcessSelection(TGLRnrCtx& rnrCtx, TGLSelectRecord& rec); virtual Short_tTGLLogicalShape::QuantizeShapeLOD(Short_t shapeLOD, Short_t combiLOD) const; UInt_tTGLLogicalShape::Ref() const; Bool_tTGLLogicalShape::SetDLCache(Bool_t cached); virtual Bool_tTGLLogicalShape::ShouldDLCache(const TGLRnrCtx& rnrCtx) const; virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); voidTGLLogicalShape::StrongRef(Bool_t strong) const; voidTGLLogicalShape::SubRef(TGLPhysicalShape* phys) const; virtual TGLLogicalShape::ELODAxesTGLLogicalShape::SupportedLODAxes() const; virtual Bool_tTGLLogicalShape::SupportsSecondarySelect() const; UInt_tTGLLogicalShape::UnrefFirstPhysical(); virtual voidTGLLogicalShape::UpdateBoundingBox(); voidTGLLogicalShape::UpdateBoundingBoxesOfPhysicals(). pr",MatchSource.WIKI,root/html528/TGLPolyMarker.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLPolyMarker.html
https://root.cern/root/html528/TGLPShapeObj.html:1420,Availability,error,error,1420,"hapeObj(); TGLPShapeObj(TGLPhysicalShape* sh, TGLViewer* v); virtual~TGLPShapeObj(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtu",MatchSource.WIKI,root/html528/TGLPShapeObj.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLPShapeObj.html
https://root.cern/root/html528/TGLPShapeObj.html:1504,Availability,error,error,1504," voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect",MatchSource.WIKI,root/html528/TGLPShapeObj.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLPShapeObj.html
https://root.cern/root/html528/TGLPShapeObjEditor.html:4653,Availability,error,error,4653,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; voidGeoValueSet(Long_t unusedVal); virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompo",MatchSource.WIKI,root/html528/TGLPShapeObjEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLPShapeObjEditor.html
https://root.cern/root/html528/TGLPShapeObjEditor.html:4737,Availability,error,error,4737,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; voidGeoValueSet(Long_t unusedVal); virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); vi",MatchSource.WIKI,root/html528/TGLPShapeObjEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLPShapeObjEditor.html
https://root.cern/root/html528/TGLPShapeObjEditor.html:17882,Availability,mask,mask,17882,"renced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Bool_tTGedFrame::fAvoidSignalflag for executing slots; Pixel_tTGFrame::fBackgroundframe background color; Int_tTGFrame::fBorderWidthframe border width; TGClient*TGObject::fClientConnection to display server; Int_tTGFrame::fDNDStateEDNDFlags; UInt_tTGWindow::fEditDisabledflags used for ""guibuilding""; UInt_tTGFrame::fEventMaskcurrenty active event mask; TList*TGedFrame::fExtraTabsaddtional tabs in ged editor; TGFrameElement*TGFrame::fFEpointer to frame element; TGedEditor*TGedFrame::fGedEditormanager of this frame; UInt_tTGFrame::fHeightframe height; Handle_tTGObject::fIdX11/Win32 Window identifier; Bool_tTGedFrame::fInitinit flag for setting signals/slots; Bool_tTGCompositeFrame::fLayoutBrokenno layout manager is used; TGLayoutManager*TGCompositeFrame::fLayoutManagerlayout manager; TList*TGCompositeFrame::fListcontainer of frame elements; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Bool_tTGCompositeFrame::fMapSubwindowskTRUE - map subwindows; UInt_tTGFrame::fMaxHeightmaximal frame height; UInt_tTGFrame::fMaxWidthmaximal frame width; UInt_tTGFrame::fMinHeightminimal frame height; UInt_tTGFrame::fMinWidthminimal frame width; TClass*TGedFrame::fModelClassclass corresponding to instantiated GedFrame; Int_tTGCompositeFrame::fMustCleanupcleanup mode (see EFrameCleanup); TStringTGWindow::fNamename of the window used in SavePrimitive(); Bool_tTGWindow::fNeedRedrawkTRUE if window needs to be redrawn; UInt_tTGFrame::fOptionsframe options; TGLPhysicalShape*TGLPShapeRef::fPShapePointer to referenced physical shape.; const TGWindow*TGWindow::fParentParent window; Int_tTGedFrame::fPrioritylocation in GedEditor; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; UInt_tTGFrame::fWidth",MatchSource.WIKI,root/html528/TGLPShapeObjEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLPShapeObjEditor.html
https://root.cern/root/html528/TGLPShapeObjEditor.html:22145,Deployability,update,update,22145,"r multiplet; TGHSlider*fRedSliderred component of selected material; TGHSlider*fShineSliderspecular refelction of selected material. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLPShapeObjEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor of TGLPhysicalShape editor GUI. ~TGLPShapeObjEditor(); Destroy color editor GUI component.; Done automatically. void SetPShape(TGLPhysicalShape* shape); Shape has changed.; Check if set to zero and make sure we're no longer in editor. void PShapeModified(); Shape has been modified.; Update editor if we're still shown. Otherwise unref. void SetModel(TObject* obj); Sets model or disables/hides viewer. void SetCenter(const Double_t* center); Set internal center data from 3 component 'c'. void SetScale(const Double_t* scale); Set internal scale data from 3 component 'c'. void DoGeoButton(); Process 'Apply' - update the viewer object from GUI. void GetObjectData(Double_t* shift, Double_t* scale); Extract the GUI object data, return center in 3 component 'center'; scale in 3 component 'scale'. void GeoValueSet(Long_t unusedVal); Process setting of value in edit box - activate 'Apply' button. void CreateGeoControls(); Create GUI for setting scale and position. void SetRGBA(const Float_t* rgba); Set color sliders from 17 component 'rgba'. void DoColorSlider(Int_t val); Process slider movement. void DoColorButton(); Process button action. void CreateColorRadioButtons(); Create Diffuse/Ambient/Specular/Emissive radio buttons and sub-frames. void CreateColorSliders(); Create GUI for setting light color. void SetColorSlidersPos(); Update GUI sliders from internal data. void DoRedraw(); Redraw widget. Render sphere and pass to base-class. void DrawSphere() const; Draw local sphere reflecting current color options. void CreateColorControls(); Create widgets to chhos colors componnet and its RGBA v",MatchSource.WIKI,root/html528/TGLPShapeObjEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLPShapeObjEditor.html
https://root.cern/root/html528/TGLPShapeRef.html:1521,Performance,perform,perform,1521,"t need to be notified; when the shape is destroyed.; Could also deliver 'change' notifications. Function Members (Methods); public:. TGLPShapeRef(); TGLPShapeRef(TGLPhysicalShape* shape); virtual~TGLPShapeRef(); static TClass*Class(); TGLPhysicalShape*GetPShape() const; virtual TClass*IsA() const; virtual voidPShapeModified(); virtual voidSetPShape(TGLPhysicalShape* shape); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). private:. TGLPShapeRef(const TGLPShapeRef&); TGLPShapeRef&operator=(const TGLPShapeRef&). Data Members; protected:. TGLPhysicalShape*fPShapePointer to referenced physical shape. private:. TGLPShapeRef*fNextPSRefInternal pointer to the next reference (used by TGLPhysicalShape directly). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLPShapeRef(); Default contructor. TGLPShapeRef(TGLPhysicalShape* shape); Constructor with known shape - reference it. ~TGLPShapeRef(); Destructor - unreference the shape if set. void SetPShape(TGLPhysicalShape* shape); Set the shape. Unreference the old and reference the new.; This is virtual so that sub-classes can perform other tasks; on change. This function should be called first from there. This is also called from destructor of the refereced physical; shape with 0 argument. void PShapeModified(); This is called from physical shape when it is modified.; Sub-classes can override and take appropriate action. TGLPShapeRef(const TGLPShapeRef& ). TGLPShapeRef& operator=(const TGLPShapeRef& ). TGLPhysicalShape * GetPShape() const; { return fPShape; }. » Author: Matevz Tadel, Feb 2007 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/gl:$Id: TGLPShapeRef.h 26394 2008-11-23 14:35:25Z matevz $ » Last generated: 2010-09-23 20:06; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html528/TGLPShapeRef.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLPShapeRef.html
https://root.cern/root/html528/TGLRnrCtx.html:6983,Availability,avail,available,6983,"Base* viewer); Constructor. ~TGLRnrCtx(); Destructor. TGLSceneBase * GetScene(); Return current scene (based on scene-info data). TGLSceneBase & RefScene(); Return current scene (based on scene-info data). Bool_t IsDrawPassFilled() const; Returns true if current render-pass uses filled polygon style. Bool_t HasStopwatchTimedOut(); Check if the stopwatch went beyond the render time limit. void BeginSelection(Int_t x, Int_t y, Int_t r = 3); Setup context for running selection.; x and y are in window coordinates. void EndSelection(Int_t glResult); End selection. TGLRect * GetPickRectangle(); Return current pick rectangle. This is *zero* when; selection is not set. Int_t GetPickRadius(); Return pick radius. If selection is not active it returns 0. void PushColorSet(); Create copy of current color-set on the top of the stack. TGLColorSet& ColorSet(); Return reference to current color-set (top of hte stack). void PopColorSet(); Pops the top-most color-set.; If only one entry is available, error is printed and the entry remains. TGLColorSet* ChangeBaseColorSet(TGLColorSet* set); Change the default/bottom color-set.; Returns the previous color-set. TGLColorSet* GetBaseColorSet(); Returns the current base color-set. void ColorOrForeground(Color_t col); Set col if it is different from background, otherwise use; current foreground color. void OpenDLCapture(); Start display-list capture. void CloseDLCapture(); End display list capture. void ReleaseFont(TGLFont& font); Release font in the GL rendering context. void RegisterFontNoScale(Int_t size, Int_t file, Int_t mode, TGLFont& out); Get font in the GL rendering context. void RegisterFontNoScale(Int_t size, const char* name, Int_t mode, TGLFont& out); Get font in the GL rendering context. void RegisterFont(Int_t size, Int_t file, Int_t mode, TGLFont& out); Get font in the GL rendering context.; The font is scaled relative to current render scale. void RegisterFont(Int_t size, const char* name, Int_t mode, TGLFont& out); Get font",MatchSource.WIKI,root/html528/TGLRnrCtx.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLRnrCtx.html
https://root.cern/root/html528/TGLRnrCtx.html:6994,Availability,error,error,6994,"Base* viewer); Constructor. ~TGLRnrCtx(); Destructor. TGLSceneBase * GetScene(); Return current scene (based on scene-info data). TGLSceneBase & RefScene(); Return current scene (based on scene-info data). Bool_t IsDrawPassFilled() const; Returns true if current render-pass uses filled polygon style. Bool_t HasStopwatchTimedOut(); Check if the stopwatch went beyond the render time limit. void BeginSelection(Int_t x, Int_t y, Int_t r = 3); Setup context for running selection.; x and y are in window coordinates. void EndSelection(Int_t glResult); End selection. TGLRect * GetPickRectangle(); Return current pick rectangle. This is *zero* when; selection is not set. Int_t GetPickRadius(); Return pick radius. If selection is not active it returns 0. void PushColorSet(); Create copy of current color-set on the top of the stack. TGLColorSet& ColorSet(); Return reference to current color-set (top of hte stack). void PopColorSet(); Pops the top-most color-set.; If only one entry is available, error is printed and the entry remains. TGLColorSet* ChangeBaseColorSet(TGLColorSet* set); Change the default/bottom color-set.; Returns the previous color-set. TGLColorSet* GetBaseColorSet(); Returns the current base color-set. void ColorOrForeground(Color_t col); Set col if it is different from background, otherwise use; current foreground color. void OpenDLCapture(); Start display-list capture. void CloseDLCapture(); End display list capture. void ReleaseFont(TGLFont& font); Release font in the GL rendering context. void RegisterFontNoScale(Int_t size, Int_t file, Int_t mode, TGLFont& out); Get font in the GL rendering context. void RegisterFontNoScale(Int_t size, const char* name, Int_t mode, TGLFont& out); Get font in the GL rendering context. void RegisterFont(Int_t size, Int_t file, Int_t mode, TGLFont& out); Get font in the GL rendering context.; The font is scaled relative to current render scale. void RegisterFont(Int_t size, const char* name, Int_t mode, TGLFont& out); Get font",MatchSource.WIKI,root/html528/TGLRnrCtx.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLRnrCtx.html
https://root.cern/root/html528/TGLRnrCtx.html:533,Testability,log,logical,533,". TGLRnrCtx. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLRnrCtx. class TGLRnrCtx. The TGLRnrCtx class aggregates data for a given redering context as; needed by various parts of the ROOT's OpenGL infractructure. It; serves as a connecting point between the steering part of the; infrastructure (viewer, scene) and concrete rendering classes; (logical, physical shape). It is just a data-holder, there is no; functionality in it. Development notes:. One RnrCtx is created by each viewer and it is just an extension of; the viewer context that changes along the render; descend. Separating this also has some abstract benefit of hiding; viewer implementation from those that do not need to know it. Current scene / scene-info part is always initialized by viewer,; scenes can assume they're ok. Function Members (Methods); public:. TGLRnrCtx(TGLViewerBase* viewer); virtual~TGLRnrCtx(); voidBeginSelection(Int_t x, Int_t y, Int_t r = 3); TGLColorSet*ChangeBaseColorSet(TGLColorSet* set); static TClass*Class(); TGLClip*Clip() const; voidCloseDLCapture(); voidColorOrForeground(Color_t col); TGLColorSet&ColorSet(); Short_tCombiLOD() const; Short_tDrawPass() const; voidEndSelection(Int_t glResult); TGLColorSet*GetBaseColorSet(); TGLCamera*GetCamera(); const TGLCamera*GetCamera() const; UInt_tGetEventKeySym() const; TGLContextIdentity*GetGLCtxIdentity() const; GLUquadric*GetGluQuadric(); UChar_t*GetGrabbedImage() const; Int_tGetGrabBuffer() const; Bool_tGetGrabImage() const; Int_tGetPickRadius(); TGLRect*GetPickRectangle(); Float_tGetRenderScale() const; TGLSceneBase*GetScene(); TGLSceneInfo*GetSceneInfo(); TGLSelectBuffer*GetSelectBuffer() const; TGLViewerBase*GetViewer(); Bool_tHasClip() const; Bool_tHasStopwatchTimedOut(); Bool_tHighlight() const; Bool_tHighlightOutline() const; virtual TClass*IsA()",MatchSource.WIKI,root/html528/TGLRnrCtx.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLRnrCtx.html
https://root.cern/root/html528/TGLRotateManip.html:614,Energy Efficiency,green,green,614,". TGLRotateManip. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLRotateManip. class TGLRotateManip: public TGLManip. Rotate manipulator - attaches to physical shape and draws local axes; widgets - rings drawn from attached physical center, in plane defined; by axis. User can mouse over (turns yellow) and L click/drag to; rotate attached physical round the ring center.; Widgets use standard 3D package axes colours: X red, Y green, Z blue. Function Members (Methods); public:. TGLRotateManip(); TGLRotateManip(TGLPhysicalShape* shape); TGLRotateManip(const TGLRotateManip&); virtual~TGLRotateManip(); voidTGLManip::Attach(TGLPhysicalShape* shape); static TClass*Class(); virtual voidDraw(const TGLCamera& camera) const; Bool_tTGLManip::GetActive() const; TGLPhysicalShape*TGLManip::GetAttached() const; UInt_tTGLManip::GetSelectedWidget() const; virtual Bool_tHandleButton(const Event_t& event, const TGLCamera& camera); virtual Bool_tHandleMotion(const Event_t& event, const TGLCamera& camera); virtual TClass*IsA() const; virtual Bool_tTGLManip::Select(const TGLCamera&, const TGLRect&, const TGLBoundingBox&); voidTGLManip::SetActive(Bool_t a); voidTGLManip::SetSelectedWidget(UInt_t s); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). protected:. static Double_tAngle(const TGLVector3& v1, const TGLVector3& v2); static Double_tAngle(const TGLVector3& v1, const TGLVector3& v2, const TGLVector3& ref); voidTGLManip::CalcDrawScale(const TGLBoundingBox& box, const TGLCamera& camera, Double_t& base, TGLVector3* axis) const; const UChar_t*TGLManip::ColorFor(UInt_t widget) const; TGLManip&TGLManip::operator=(const TGLManip&). private:. Double_tCalculateAngleDelta(const TPoint& mouse, const TGLCamera& camera); TGLLine3CalculateRingLine(con",MatchSource.WIKI,root/html528/TGLRotateManip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLRotateManip.html
https://root.cern/root/html528/TGLRotateManip.html:3746,Energy Efficiency,green,green,3746,"nt! front or back of the active shallow ring?; Bool_tfShallowRing! does active ring form shallow angle to eye?. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Double_t Angle(const TGLVector3& v1, const TGLVector3& v2); Calculate unsigned angle between vectors v1 and v2. Double_t Angle(const TGLVector3& v1, const TGLVector3& v2, const TGLVector3& ref); Calculate signed angle between vectors v1 and v2, using ref to define right handed coord system; If v1.v2 parallel to ref vector: +ive for clockwise, -ive for anticlockwise; If v1.v2 antiparallel to ref vector: -ive for clockwise, +ive for anticlockwise. TGLRotateManip(); Construct rotation manipulator not bound to any physical shape. TGLRotateManip(TGLPhysicalShape* shape); Construct rotation manipulator bound to TGLPhysicalShape 'shape'. ~TGLRotateManip(); Destory the rotation manipulator. void Draw(const TGLCamera& camera) const; Draw rotate manipulator - axis rings drawn from attached; physical center, in plane defined by axis as normal, in red(X),; green(Y) and blue(Z), with white center sphere. If selected; widget (mouse over) this is drawn in active colour (yellow). Bool_t HandleButton(const Event_t& event, const TGLCamera& camera); Handle mouse button event over manipulator - returns kTRUE if; redraw required kFALSE otherwise. Bool_t HandleMotion(const Event_t& event, const TGLCamera& camera); Handle mouse motion over manipulator - if active (selected; widget) rotate physical around selected ring widget plane; normal. Returns kTRUE if redraw required kFALSE otherwise. Double_t CalculateAngleDelta(const TPoint& mouse, const TGLCamera& camera); Calculate angle delta for rotation based on new mouse position. TGLLine3 CalculateRingLine(const TPoint& mouse, const TGLCamera& camera) const; Calculated interaction line between 'mouse' viewport point, and; current selected widget (ring), under supplied 'camera'; projection. void DrawAxisRing(const TGLVertex3& origin, const TGLV",MatchSource.WIKI,root/html528/TGLRotateManip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLRotateManip.html
https://root.cern/root/html528/TGLSAFrame.html:4375,Availability,error,error,4375,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); TList*TGMainFrame::GetBindList() const; static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; voidTGMainFrame::GetClassHints(const char*& className, const char*& resourceName) const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBa",MatchSource.WIKI,root/html528/TGLSAFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLSAFrame.html
https://root.cern/root/html528/TGLSAFrame.html:4459,Availability,error,error,4459,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); TList*TGMainFrame::GetBindList() const; static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; voidTGMainFrame::GetClassHints(const char*& className, const char*& resourceName) const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UIn",MatchSource.WIKI,root/html528/TGLSAFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLSAFrame.html
https://root.cern/root/html528/TGLSAFrame.html:18423,Availability,mask,mask,18423,,MatchSource.WIKI,root/html528/TGLSAFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLSAFrame.html
https://root.cern/root/html528/TGLSAFrame.html:21665,Integrability,message,message,21665,"Int_tTGMainFrame::fWMXWM x position; Int_tTGMainFrame::fWMYWM y position; UInt_tTGFrame::fWidthframe width; TStringTGMainFrame::fWindowNamewindow name; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. private:. TGLSAViewer&fViewer. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLSAFrame(TGLSAViewer& viewer); Construct GUI frame, bound to passed 'viewer'. TGLSAFrame(const TGWindow* parent, TGLSAViewer& viewer); Construct GUI frame, bound to passed 'viewer'. ~TGLSAFrame(); Destroy the GUI frame. Bool_t ProcessMessage(Long_t msg, Long_t parm1, Long_t parm2); Process GUI message - defered back up to TGLSAViewer::ProcessFrameMessage(). void CloseWindow(); Close the GUI frame. TGLSAFrame(const TGLSAFrame& ); non-copyable class. » Author: Richard Maunder 10/08/2005 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/gl:$Id: TGLSAFrame.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2010-09-23 20:06; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html528/TGLSAFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLSAFrame.html
https://root.cern/root/html528/TGLSAViewer.html:5463,Availability,error,error,5463,"am); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidEnableMenuBarHiding(); virtual voidTGLViewer::EndScene(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGLViewer::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; Bool_tTGLViewerBase::FindClosestOpaqueRecord(TGLSelectRecord& rec, Int_t& recIdx); Bool_tTGLViewerBase::FindClosestOverlayRecord(TGLOvlSelectRecord& rec, Int_t& recIdx); Bool_tTGLViewerBase::FindClosestRecord(TGLSelectRecord& rec, Int_t& recIdx); TGLLogicalShape*TGLViewerBase::FindLogicalInScenes(TObject* id); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TGLAutoRotator*TGLViewer::GetAutoRotator(); TGLCameraOverlay*TGLViewer::GetCameraOverlay() const; Bool_tTGLViewer::GetClipAutoUpdate() const; TGLClipSet*TGLViewer::GetClipSet() const; TGLOverlayElement*TGLViewer::GetCurrentOvlElm() const; static TGLColorSet&TGLViewer::GetDefaultColorSet(); Int_tTGLViewer::GetDev() const; TGLV",MatchSource.WIKI,root/html528/TGLSAViewer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLSAViewer.html
https://root.cern/root/html528/TGLSAViewer.html:5547,Availability,error,error,5547,"char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidEnableMenuBarHiding(); virtual voidTGLViewer::EndScene(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGLViewer::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; Bool_tTGLViewerBase::FindClosestOpaqueRecord(TGLSelectRecord& rec, Int_t& recIdx); Bool_tTGLViewerBase::FindClosestOverlayRecord(TGLOvlSelectRecord& rec, Int_t& recIdx); Bool_tTGLViewerBase::FindClosestRecord(TGLSelectRecord& rec, Int_t& recIdx); TGLLogicalShape*TGLViewerBase::FindLogicalInScenes(TObject* id); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TGLAutoRotator*TGLViewer::GetAutoRotator(); TGLCameraOverlay*TGLViewer::GetCameraOverlay() const; Bool_tTGLViewer::GetClipAutoUpdate() const; TGLClipSet*TGLViewer::GetClipSet() const; TGLOverlayElement*TGLViewer::GetCurrentOvlElm() const; static TGLColorSet&TGLViewer::GetDefaultColorSet(); Int_tTGLViewer::GetDev() const; TGLViewer::EDragActionTGLViewer::GetDragAction() const; Bool_tTGLViewer::GetDrawCameraCe",MatchSource.WIKI,root/html528/TGLSAViewer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLSAViewer.html
https://root.cern/root/html528/TGLSAViewer.html:26178,Availability,error,error,26178,"TGCompositeFrame*fRightVerticalFrame; Int_tfTypeIdx; static const char*fgHelpText1; static const char*fgHelpText2; static const Int_tfgInitH; static const Int_tfgInitW; static const Int_tfgInitX; static const Int_tfgInitY; static Long_tfgMenuHidingTimeout. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLSAViewer(TVirtualPad* pad, TGLFormat* format = 0); Construct a standalone viewer, bound to supplied 'pad'. TGLSAViewer(const TGWindow* parent, TVirtualPad* pad, TGedEditor* ged = 0, TGLFormat* format = 0); Construct an embedded standalone viewer, bound to supplied 'pad'.; If format is passed, it gets adopted by the viewer as it might; need to be reused several times when recreating the GL-widget. Modified version of the previous constructor for embedding the; viewer into another frame (parent). ~TGLSAViewer(); Destroy standalone viewer object. TGCompositeFrame* GetFrame() const; Return the main-frame. void CreateGLWidget(); Create a GLwidget, it is an error if it is already created.; This is needed for frame-swapping on mac. void DestroyGLWidget(); Destroy the GLwidget, it is an error if it does not exist.; This is needed for frame-swapping on mac. void CreateMenus(); File/Camera/Help menus. void CreateFrames(); Internal frames creation. void SelectionChanged(); Update GUI components for embedded viewer selection change.; Override from TGLViewer. void Show(); Show the viewer. void Close(); Close the viewer - destructed. void DeleteMenuBar(); Delete the menu bar. void DisableCloseMenuEntries(); Deactivate menu entries for closing the GL window and exiting ROOT. void EnableMenuBarHiding(); Enable hiding of menu bar. void DisableMenuBarHiding(); Disable hiding of menu bar. void HandleMenuBarHiding(Event_t* ev); Maybe switch menu-bar / menu-button. void ResetMenuHidingTimer(Bool_t show_menu); Reset the timer for menu-bar hiding. void MenuHidingTimeout(); Action for menu-hiding timeout. void SetMenuHidingTimeout(Long_t timeout)",MatchSource.WIKI,root/html528/TGLSAViewer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLSAViewer.html
https://root.cern/root/html528/TGLSAViewer.html:26308,Availability,error,error,26308,"t Int_tfgInitH; static const Int_tfgInitW; static const Int_tfgInitX; static const Int_tfgInitY; static Long_tfgMenuHidingTimeout. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLSAViewer(TVirtualPad* pad, TGLFormat* format = 0); Construct a standalone viewer, bound to supplied 'pad'. TGLSAViewer(const TGWindow* parent, TVirtualPad* pad, TGedEditor* ged = 0, TGLFormat* format = 0); Construct an embedded standalone viewer, bound to supplied 'pad'.; If format is passed, it gets adopted by the viewer as it might; need to be reused several times when recreating the GL-widget. Modified version of the previous constructor for embedding the; viewer into another frame (parent). ~TGLSAViewer(); Destroy standalone viewer object. TGCompositeFrame* GetFrame() const; Return the main-frame. void CreateGLWidget(); Create a GLwidget, it is an error if it is already created.; This is needed for frame-swapping on mac. void DestroyGLWidget(); Destroy the GLwidget, it is an error if it does not exist.; This is needed for frame-swapping on mac. void CreateMenus(); File/Camera/Help menus. void CreateFrames(); Internal frames creation. void SelectionChanged(); Update GUI components for embedded viewer selection change.; Override from TGLViewer. void Show(); Show the viewer. void Close(); Close the viewer - destructed. void DeleteMenuBar(); Delete the menu bar. void DisableCloseMenuEntries(); Deactivate menu entries for closing the GL window and exiting ROOT. void EnableMenuBarHiding(); Enable hiding of menu bar. void DisableMenuBarHiding(); Disable hiding of menu bar. void HandleMenuBarHiding(Event_t* ev); Maybe switch menu-bar / menu-button. void ResetMenuHidingTimer(Bool_t show_menu); Reset the timer for menu-bar hiding. void MenuHidingTimeout(); Action for menu-hiding timeout. void SetMenuHidingTimeout(Long_t timeout); Set global timeout for menu-hiding in mili-seconds.; Static function. Bool_t ProcessFrameMessage(Long_t msg, Long_t parm1, L",MatchSource.WIKI,root/html528/TGLSAViewer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLSAViewer.html
https://root.cern/root/html528/TGLSAViewer.html:21446,Deployability,update,update,21446," enum TGLLockable::ELock { kUnlocked; kDrawLock; kSelectLock; kModifyLock; };. protected:. TGLAutoRotator*TGLViewer::fAutoRotator!; Bool_tTGLViewer::fAxesDepthTest! remove guides hidden-lines; Int_tTGLViewer::fAxesType! axes type; TGLCamera*TGLViewerBase::fCameraCamera for rendering.; TGLCameraOverlay*TGLViewer::fCameraOverlay! markup size of viewport in scene units; Bool_tTGLViewerBase::fChangedChange requiring redraw is pending.; TGLClip*TGLViewerBase::fClipViewer clipping-plane.; TGLClipSet*TGLViewer::fClipSet!; TContextMenu*TGLViewer::fContextMenu!; TGLCamera*TGLViewer::fCurrentCamera!; TGLOverlayElement*TGLViewer::fCurrentOvlElm! current overlay element; TGLSelectRecordTGLViewer::fCurrentSelRec! select record in use as selected; TGLColorSetTGLViewer::fDarkColorSet! color-set with dark background; Bool_tTGLViewer::fDebugMode! debug mode (forced rebuild + draw scene/frustum/interest boxes); TGLViewer::EDragActionTGLViewer::fDragAction; Bool_tTGLViewer::fDrawCameraCenter! reference marker on?; TGEventHandler*TGLViewer::fEventHandler! event handler; Float_tTGLViewer::fFader! fade the view (0 - no fade/default, 1 - full fade/no rendering done); TGLContextIdentity*TGLViewer::fGLCtxId!for embedded gl viewer; Int_tTGLViewer::fGLDevice!for embedded gl viewer; TGLWidget*TGLViewer::fGLWidget; TGedEditor*TGLViewer::fGedEditor! GED editor; Bool_tTGLViewer::fIgnoreSizesOnUpdateignore sizes of bounding-boxes on update; Bool_tTGLViewer::fIsPrinting!; Short_tTGLViewerBase::fLODViewer-lod for rendering.; TGLColorSetTGLViewer::fLightColorSet! color-set with light background; TGLLightSet*TGLViewer::fLightSet!; Float_tTGLViewer::fLineScale! width scale for lines; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; TGLLockable::ELockTGLLockable::fLockLock state.; Float_tTGLViewer::fMaxSceneDrawTimeHQ! max time for scene rendering at high LOD (in ms); Float_tTGLViewer::fMaxSceneDrawTimeLQ! max time f",MatchSource.WIKI,root/html528/TGLSAViewer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLSAViewer.html
https://root.cern/root/html528/TGLSAViewer.html:23311,Deployability,update,update,23311,GLViewer::fMaxSceneDrawTimeLQ! max time for scene rendering at high LOD (in ms); Float_tTGLViewerBase::fOLLineWOptional override of scene outline line-width; TGLOrthoCameraTGLViewer::fOrthoXOYCamera!; TGLOrthoCameraTGLViewer::fOrthoXOZCamera!; TGLOrthoCameraTGLViewer::fOrthoXnOYCamera!; TGLOrthoCameraTGLViewer::fOrthoXnOZCamera!; TGLOrthoCameraTGLViewer::fOrthoZOYCamera!; TGLOrthoCameraTGLViewer::fOrthoZnOYCamera!; TGLBoundingBoxTGLViewerBase::fOverallBoundingBoxAxis-aligned union of scene bboxes.; vector<TGLOverlayElement*>TGLViewerBase::fOverlay; TGLOvlSelectRecordTGLViewer::fOvlSelRec! select record from last overlay select; TGLPShapeObj*TGLViewer::fPShapeWrap; TVirtualPad*TGLViewer::fPad! external pad - remove replace with signal; TGLPerspectiveCameraTGLViewer::fPerspectiveCameraXOY!; TGLPerspectiveCameraTGLViewer::fPerspectiveCameraXOZ!; TGLPerspectiveCameraTGLViewer::fPerspectiveCameraYOZ!; TStringTGLViewer::fPictureFileName! default file-name for SavePicture(); Float_tTGLViewer::fPointScale! size scale for points; TGLViewer::EPushActionTGLViewer::fPushAction; TGLRedrawTimer*TGLViewer::fRedrawTimer! timer for triggering redraws; Bool_tTGLViewer::fReferenceOn! reference marker on?; TGLVertex3TGLViewer::fReferencePos! reference position; Bool_tTGLViewer::fResetCamerasOnNextUpdatereposition camera on next update; Bool_tTGLViewer::fResetCamerasOnUpdatereposition camera on each update; Bool_tTGLViewerBase::fResetSceneInfosOnRenderRequest rebuild of view-specific scene data.; TGLRnrCtx*TGLViewerBase::fRnrCtx; list<TGLSceneInfo*>TGLViewerBase::fScenesRegistered scenes.; TGLSelectRecordTGLViewer::fSecSelRec! select record from last secondary select (should go to context); TGLSelectRecordTGLViewer::fSelRec! select record from last select (should go to context); TGLManipSet*TGLViewer::fSelectedPShapeRef!; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; Bool_tTGLViewer::fSmartRefresh! cache logicals during scene rebuilds; Bool_tTGLViewer::fSmoothLin,MatchSource.WIKI,root/html528/TGLSAViewer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLSAViewer.html
https://root.cern/root/html528/TGLSAViewer.html:23383,Deployability,update,update,23383,GLViewer::fMaxSceneDrawTimeLQ! max time for scene rendering at high LOD (in ms); Float_tTGLViewerBase::fOLLineWOptional override of scene outline line-width; TGLOrthoCameraTGLViewer::fOrthoXOYCamera!; TGLOrthoCameraTGLViewer::fOrthoXOZCamera!; TGLOrthoCameraTGLViewer::fOrthoXnOYCamera!; TGLOrthoCameraTGLViewer::fOrthoXnOZCamera!; TGLOrthoCameraTGLViewer::fOrthoZOYCamera!; TGLOrthoCameraTGLViewer::fOrthoZnOYCamera!; TGLBoundingBoxTGLViewerBase::fOverallBoundingBoxAxis-aligned union of scene bboxes.; vector<TGLOverlayElement*>TGLViewerBase::fOverlay; TGLOvlSelectRecordTGLViewer::fOvlSelRec! select record from last overlay select; TGLPShapeObj*TGLViewer::fPShapeWrap; TVirtualPad*TGLViewer::fPad! external pad - remove replace with signal; TGLPerspectiveCameraTGLViewer::fPerspectiveCameraXOY!; TGLPerspectiveCameraTGLViewer::fPerspectiveCameraXOZ!; TGLPerspectiveCameraTGLViewer::fPerspectiveCameraYOZ!; TStringTGLViewer::fPictureFileName! default file-name for SavePicture(); Float_tTGLViewer::fPointScale! size scale for points; TGLViewer::EPushActionTGLViewer::fPushAction; TGLRedrawTimer*TGLViewer::fRedrawTimer! timer for triggering redraws; Bool_tTGLViewer::fReferenceOn! reference marker on?; TGLVertex3TGLViewer::fReferencePos! reference position; Bool_tTGLViewer::fResetCamerasOnNextUpdatereposition camera on next update; Bool_tTGLViewer::fResetCamerasOnUpdatereposition camera on each update; Bool_tTGLViewerBase::fResetSceneInfosOnRenderRequest rebuild of view-specific scene data.; TGLRnrCtx*TGLViewerBase::fRnrCtx; list<TGLSceneInfo*>TGLViewerBase::fScenesRegistered scenes.; TGLSelectRecordTGLViewer::fSecSelRec! select record from last secondary select (should go to context); TGLSelectRecordTGLViewer::fSelRec! select record from last select (should go to context); TGLManipSet*TGLViewer::fSelectedPShapeRef!; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; Bool_tTGLViewer::fSmartRefresh! cache logicals during scene rebuilds; Bool_tTGLViewer::fSmoothLin,MatchSource.WIKI,root/html528/TGLSAViewer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLSAViewer.html
https://root.cern/root/html528/TGLSAViewer.html:27315,Integrability,message,message,27315,".; This is needed for frame-swapping on mac. void DestroyGLWidget(); Destroy the GLwidget, it is an error if it does not exist.; This is needed for frame-swapping on mac. void CreateMenus(); File/Camera/Help menus. void CreateFrames(); Internal frames creation. void SelectionChanged(); Update GUI components for embedded viewer selection change.; Override from TGLViewer. void Show(); Show the viewer. void Close(); Close the viewer - destructed. void DeleteMenuBar(); Delete the menu bar. void DisableCloseMenuEntries(); Deactivate menu entries for closing the GL window and exiting ROOT. void EnableMenuBarHiding(); Enable hiding of menu bar. void DisableMenuBarHiding(); Disable hiding of menu bar. void HandleMenuBarHiding(Event_t* ev); Maybe switch menu-bar / menu-button. void ResetMenuHidingTimer(Bool_t show_menu); Reset the timer for menu-bar hiding. void MenuHidingTimeout(); Action for menu-hiding timeout. void SetMenuHidingTimeout(Long_t timeout); Set global timeout for menu-hiding in mili-seconds.; Static function. Bool_t ProcessFrameMessage(Long_t msg, Long_t parm1, Long_t ); Process GUI message capture by the main GUI frame (TGLSAFrame). void ToggleEditObject(); Toggle state of the 'Edit Object' menu entry. void ToggleOrthoRotate(); Toggle state of the 'Ortho allow rotate' menu entry. void ToggleOrthoDolly(); Toggle state of the 'Ortho allow dolly' menu entry. TGLSAViewer(const TGLSAViewer& ); non-copyable class. const char* GetName() const; { return ""GLViewer""; }. TGCompositeFrame* GetLeftVerticalFrame() const; { return fLeftVerticalFrame; }. TGLFormat* GetFormat() const; { return fFormat; }. » Author: Richard Maunder / Timur Pocheptsov » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/gl:$Id: TGLSAViewer.h 36895 2010-11-24 11:46:09Z matevz $ » Last generated: 2010-11-26 14:26; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html528/TGLSAViewer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLSAViewer.html
https://root.cern/root/html528/TGLSAViewer.html:345,Modifiability,plugin,plugin,345,". TGLSAViewer. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLSAViewer. class TGLSAViewer: public TGLViewer. The top level standalone GL-viewer - created via plugin manager. Function Members (Methods); public:. TGLSAViewer(TVirtualPad* pad, TGLFormat* format = 0); TGLSAViewer(const TGWindow* parent, TVirtualPad* pad, TGedEditor* ged = 0, TGLFormat* format = 0); virtual~TGLSAViewer(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGLViewer::Activated()SIGNAL ; virtual voidTGLViewer::AddCompositeOp(UInt_t); virtual Int_tTGLViewer::AddObject(const TBuffer3D&, Bool_t* = 0); virtual Int_tTGLViewer::AddObject(UInt_t, const TBuffer3D&, Bool_t* = 0); virtual voidTGLViewerBase::AddOverlayElement(TGLOverlayElement* el); TGLSceneInfo*TGLViewerBase::AddScene(TGLSceneBase* scene); virtual voidTObject::AppendPad(Option_t* option = """"); voidTGLViewer::ApplySelection(); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; voidTGLViewer::AutoFade(Float_t fade, Float_t time = 1, Int_t steps = 10); virtual voidTGLViewer::BeginScene(); static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual Bool_tTGLViewer::BuildingScene() const; virtual Bool_tTGLViewer::CanLoopOnPrimitives() const; virtual voidTGLViewerBase::Changed(); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); voidTGLViewer::ClearCurrentOvlElm(); virtual voidTGLViewer::Clicked(TObject* obj)SIGNAL ; virtual voidTGLViewer::Clicked(TObject* obj, UInt_t button, UInt_t state)SIGNAL ; TGLClip*TGLViewerBase::Clip() const; virtual TObject*TObject::Clone(const char* newname = """") const; voidC",MatchSource.WIKI,root/html528/TGLSAViewer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLSAViewer.html
https://root.cern/root/html528/TGLSAViewer.html:23917,Performance,cache,cache,23917,"er::fPointScale! size scale for points; TGLViewer::EPushActionTGLViewer::fPushAction; TGLRedrawTimer*TGLViewer::fRedrawTimer! timer for triggering redraws; Bool_tTGLViewer::fReferenceOn! reference marker on?; TGLVertex3TGLViewer::fReferencePos! reference position; Bool_tTGLViewer::fResetCamerasOnNextUpdatereposition camera on next update; Bool_tTGLViewer::fResetCamerasOnUpdatereposition camera on each update; Bool_tTGLViewerBase::fResetSceneInfosOnRenderRequest rebuild of view-specific scene data.; TGLRnrCtx*TGLViewerBase::fRnrCtx; list<TGLSceneInfo*>TGLViewerBase::fScenesRegistered scenes.; TGLSelectRecordTGLViewer::fSecSelRec! select record from last secondary select (should go to context); TGLSelectRecordTGLViewer::fSelRec! select record from last select (should go to context); TGLManipSet*TGLViewer::fSelectedPShapeRef!; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; Bool_tTGLViewer::fSmartRefresh! cache logicals during scene rebuilds; Bool_tTGLViewer::fSmoothLines! smooth line edge rendering; Bool_tTGLViewer::fSmoothPoints! smooth point edge rendering; Bool_tTGLViewer::fStereo! use stereo rendering; Float_tTGLViewer::fStereoEyeOffsetFac!; Float_tTGLViewer::fStereoFrustumAsymFac!; Float_tTGLViewer::fStereoZeroParallax! position of zero-parallax plane: 0 - near clipping plane, 1 - far clipping plane; Short_tTGLViewerBase::fStyleViewer-style for rendering.; TGLRectTGLViewer::fViewport! viewport - drawn area; vector<TGLSceneInfo*>TGLViewerBase::fVisScenesVisible scenes.; Float_tTGLViewerBase::fWFLineWOptional override of scene wire-frame line-width; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static TGLColorSetTGLViewer::fgDefaultColorSet! a shared, default color-set; static Bool_tTGLViewer::fgUseDefaultColorSetForNewViewers! name says it all. private:. TGPopupMenu*fCameraMenu; Bool_tfDeleteMenuBar; TStringfDirName; TGPopupMenu*fFileMenu; TGPopupMenu*fFileSaveMenu; TGLFormat*fFormat; TGLSAFrame*fFrame; ",MatchSource.WIKI,root/html528/TGLSAViewer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLSAViewer.html
https://root.cern/root/html528/TGLSAViewer.html:15283,Safety,timeout,timeout,15283,"tBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTGLViewer::SetCameraOverlay(TGLCameraOverlay* m); voidTGLViewer::SetClearColor(Color_t col); voidTGLViewerBase::SetClip(TGLClip* p); voidTGLViewer::SetClipAutoUpdate(Bool_t x); voidTGLViewer::SetCurrentCamera(TGLViewer::ECameraType camera); voidTGLViewer::SetDrawCameraCenter(Bool_t x); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTGLViewer::SetEventHandler(TGEventHandler* handler); voidTGLViewer::SetFader(Float_t x); virtual voidTGLViewer::SetGedEditor(TGedEditor* ed); voidTGLViewer::SetGuideState(Int_t axesType, Bool_t axesDepthTest, Bool_t referenceOn, const Double_t* referencePos); voidTGLViewer::SetIgnoreSizesOnUpdate(Bool_t v); voidTGLViewer::SetLineScale(Float_t s); voidTGLViewerBase::SetLOD(Short_t lod); voidTGLViewer::SetMaxSceneDrawTimeHQ(Float_t t); voidTGLViewer::SetMaxSceneDrawTimeLQ(Float_t t); static voidSetMenuHidingTimeout(Long_t timeout); static voidTObject::SetObjectStat(Bool_t stat); voidTGLViewerBase::SetOLLineW(Float_t w); voidTGLViewer::SetOrthoCamera(TGLViewer::ECameraType camera, Double_t zoom, Double_t dolly, Double_t* center, Double_t hRotate, Double_t vRotate); voidTGLViewer::SetPerspectiveCamera(TGLViewer::ECameraType camera, Double_t fov, Double_t dolly, Double_t* center, Double_t hRotate, Double_t vRotate); voidTGLViewer::SetPictureFileName(const TString& f); voidTGLViewer::SetPointScale(Float_t s); voidTGLViewer::SetResetCamerasOnUpdate(Bool_t v); voidTGLViewer::SetSmartRefresh(Bool_t smart_ref); voidTGLViewer::SetSmoothLines(Bool_t s); voidTGLViewer::SetSmoothPoints(Bool_t s); voidTGLViewer::SetStereo(Bool_t s); voidTGLViewer::SetStereoEyeOffsetFac(Float_t f); voidTGLViewer::SetStereoFrustumAsymFac(Float_t f); voidTGLViewer::SetStereoZeroParallax(Float_t f); voidTGLViewerBase::SetStyle(Short_t st); virtual voidTObject::SetUniqueID(UInt_t uid); voidTGLViewerBase::SetWFLineW(Float_t w); voidShow(); vi",MatchSource.WIKI,root/html528/TGLSAViewer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLSAViewer.html
https://root.cern/root/html528/TGLSAViewer.html:27118,Safety,timeout,timeout,27118,"const; Return the main-frame. void CreateGLWidget(); Create a GLwidget, it is an error if it is already created.; This is needed for frame-swapping on mac. void DestroyGLWidget(); Destroy the GLwidget, it is an error if it does not exist.; This is needed for frame-swapping on mac. void CreateMenus(); File/Camera/Help menus. void CreateFrames(); Internal frames creation. void SelectionChanged(); Update GUI components for embedded viewer selection change.; Override from TGLViewer. void Show(); Show the viewer. void Close(); Close the viewer - destructed. void DeleteMenuBar(); Delete the menu bar. void DisableCloseMenuEntries(); Deactivate menu entries for closing the GL window and exiting ROOT. void EnableMenuBarHiding(); Enable hiding of menu bar. void DisableMenuBarHiding(); Disable hiding of menu bar. void HandleMenuBarHiding(Event_t* ev); Maybe switch menu-bar / menu-button. void ResetMenuHidingTimer(Bool_t show_menu); Reset the timer for menu-bar hiding. void MenuHidingTimeout(); Action for menu-hiding timeout. void SetMenuHidingTimeout(Long_t timeout); Set global timeout for menu-hiding in mili-seconds.; Static function. Bool_t ProcessFrameMessage(Long_t msg, Long_t parm1, Long_t ); Process GUI message capture by the main GUI frame (TGLSAFrame). void ToggleEditObject(); Toggle state of the 'Edit Object' menu entry. void ToggleOrthoRotate(); Toggle state of the 'Ortho allow rotate' menu entry. void ToggleOrthoDolly(); Toggle state of the 'Ortho allow dolly' menu entry. TGLSAViewer(const TGLSAViewer& ); non-copyable class. const char* GetName() const; { return ""GLViewer""; }. TGCompositeFrame* GetLeftVerticalFrame() const; { return fLeftVerticalFrame; }. TGLFormat* GetFormat() const; { return fFormat; }. » Author: Richard Maunder / Timur Pocheptsov » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/gl:$Id: TGLSAViewer.h 36895 2010-11-24 11:46:09Z matevz $ » Last generated: 2010-11-26 14:26; This page has been automatically generated. ",MatchSource.WIKI,root/html528/TGLSAViewer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLSAViewer.html
https://root.cern/root/html528/TGLSAViewer.html:27160,Safety,timeout,timeout,27160,"s an error if it is already created.; This is needed for frame-swapping on mac. void DestroyGLWidget(); Destroy the GLwidget, it is an error if it does not exist.; This is needed for frame-swapping on mac. void CreateMenus(); File/Camera/Help menus. void CreateFrames(); Internal frames creation. void SelectionChanged(); Update GUI components for embedded viewer selection change.; Override from TGLViewer. void Show(); Show the viewer. void Close(); Close the viewer - destructed. void DeleteMenuBar(); Delete the menu bar. void DisableCloseMenuEntries(); Deactivate menu entries for closing the GL window and exiting ROOT. void EnableMenuBarHiding(); Enable hiding of menu bar. void DisableMenuBarHiding(); Disable hiding of menu bar. void HandleMenuBarHiding(Event_t* ev); Maybe switch menu-bar / menu-button. void ResetMenuHidingTimer(Bool_t show_menu); Reset the timer for menu-bar hiding. void MenuHidingTimeout(); Action for menu-hiding timeout. void SetMenuHidingTimeout(Long_t timeout); Set global timeout for menu-hiding in mili-seconds.; Static function. Bool_t ProcessFrameMessage(Long_t msg, Long_t parm1, Long_t ); Process GUI message capture by the main GUI frame (TGLSAFrame). void ToggleEditObject(); Toggle state of the 'Edit Object' menu entry. void ToggleOrthoRotate(); Toggle state of the 'Ortho allow rotate' menu entry. void ToggleOrthoDolly(); Toggle state of the 'Ortho allow dolly' menu entry. TGLSAViewer(const TGLSAViewer& ); non-copyable class. const char* GetName() const; { return ""GLViewer""; }. TGCompositeFrame* GetLeftVerticalFrame() const; { return fLeftVerticalFrame; }. TGLFormat* GetFormat() const; { return fFormat; }. » Author: Richard Maunder / Timur Pocheptsov » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/gl:$Id: TGLSAViewer.h 36895 2010-11-24 11:46:09Z matevz $ » Last generated: 2010-11-26 14:26; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general pl",MatchSource.WIKI,root/html528/TGLSAViewer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLSAViewer.html
https://root.cern/root/html528/TGLSAViewer.html:27181,Safety,timeout,timeout,27181,"s an error if it is already created.; This is needed for frame-swapping on mac. void DestroyGLWidget(); Destroy the GLwidget, it is an error if it does not exist.; This is needed for frame-swapping on mac. void CreateMenus(); File/Camera/Help menus. void CreateFrames(); Internal frames creation. void SelectionChanged(); Update GUI components for embedded viewer selection change.; Override from TGLViewer. void Show(); Show the viewer. void Close(); Close the viewer - destructed. void DeleteMenuBar(); Delete the menu bar. void DisableCloseMenuEntries(); Deactivate menu entries for closing the GL window and exiting ROOT. void EnableMenuBarHiding(); Enable hiding of menu bar. void DisableMenuBarHiding(); Disable hiding of menu bar. void HandleMenuBarHiding(Event_t* ev); Maybe switch menu-bar / menu-button. void ResetMenuHidingTimer(Bool_t show_menu); Reset the timer for menu-bar hiding. void MenuHidingTimeout(); Action for menu-hiding timeout. void SetMenuHidingTimeout(Long_t timeout); Set global timeout for menu-hiding in mili-seconds.; Static function. Bool_t ProcessFrameMessage(Long_t msg, Long_t parm1, Long_t ); Process GUI message capture by the main GUI frame (TGLSAFrame). void ToggleEditObject(); Toggle state of the 'Edit Object' menu entry. void ToggleOrthoRotate(); Toggle state of the 'Ortho allow rotate' menu entry. void ToggleOrthoDolly(); Toggle state of the 'Ortho allow dolly' menu entry. TGLSAViewer(const TGLSAViewer& ); non-copyable class. const char* GetName() const; { return ""GLViewer""; }. TGCompositeFrame* GetLeftVerticalFrame() const; { return fLeftVerticalFrame; }. TGLFormat* GetFormat() const; { return fFormat; }. » Author: Richard Maunder / Timur Pocheptsov » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/gl:$Id: TGLSAViewer.h 36895 2010-11-24 11:46:09Z matevz $ » Last generated: 2010-11-26 14:26; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general pl",MatchSource.WIKI,root/html528/TGLSAViewer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLSAViewer.html
https://root.cern/root/html528/TGLSAViewer.html:23923,Testability,log,logicals,23923,"er::fPointScale! size scale for points; TGLViewer::EPushActionTGLViewer::fPushAction; TGLRedrawTimer*TGLViewer::fRedrawTimer! timer for triggering redraws; Bool_tTGLViewer::fReferenceOn! reference marker on?; TGLVertex3TGLViewer::fReferencePos! reference position; Bool_tTGLViewer::fResetCamerasOnNextUpdatereposition camera on next update; Bool_tTGLViewer::fResetCamerasOnUpdatereposition camera on each update; Bool_tTGLViewerBase::fResetSceneInfosOnRenderRequest rebuild of view-specific scene data.; TGLRnrCtx*TGLViewerBase::fRnrCtx; list<TGLSceneInfo*>TGLViewerBase::fScenesRegistered scenes.; TGLSelectRecordTGLViewer::fSecSelRec! select record from last secondary select (should go to context); TGLSelectRecordTGLViewer::fSelRec! select record from last select (should go to context); TGLManipSet*TGLViewer::fSelectedPShapeRef!; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; Bool_tTGLViewer::fSmartRefresh! cache logicals during scene rebuilds; Bool_tTGLViewer::fSmoothLines! smooth line edge rendering; Bool_tTGLViewer::fSmoothPoints! smooth point edge rendering; Bool_tTGLViewer::fStereo! use stereo rendering; Float_tTGLViewer::fStereoEyeOffsetFac!; Float_tTGLViewer::fStereoFrustumAsymFac!; Float_tTGLViewer::fStereoZeroParallax! position of zero-parallax plane: 0 - near clipping plane, 1 - far clipping plane; Short_tTGLViewerBase::fStyleViewer-style for rendering.; TGLRectTGLViewer::fViewport! viewport - drawn area; vector<TGLSceneInfo*>TGLViewerBase::fVisScenesVisible scenes.; Float_tTGLViewerBase::fWFLineWOptional override of scene wire-frame line-width; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static TGLColorSetTGLViewer::fgDefaultColorSet! a shared, default color-set; static Bool_tTGLViewer::fgUseDefaultColorSetForNewViewers! name says it all. private:. TGPopupMenu*fCameraMenu; Bool_tfDeleteMenuBar; TStringfDirName; TGPopupMenu*fFileMenu; TGPopupMenu*fFileSaveMenu; TGLFormat*fFormat; TGLSAFrame*fFrame; ",MatchSource.WIKI,root/html528/TGLSAViewer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLSAViewer.html
https://root.cern/root/html528/TGLSAViewer.html:20193,Usability,guid,guides,20193,"GLSavePNG; kGLSaveGIF; kGLSaveAnimGIF; kGLSaveJPG; kGLSaveAS; kGLCloseViewer; kGLQuitROOT; kGLEditObject; kGLHideMenus; };; enum TGLViewer::ECameraType { kCameraPerspXOZ; kCameraPerspYOZ; kCameraPerspXOY; kCameraOrthoXOY; kCameraOrthoXOZ; kCameraOrthoZOY; kCameraOrthoXnOY; kCameraOrthoXnOZ; kCameraOrthoZnOY; };; enum TGLViewer::ESecSelType { kOnRequest; kOnKeyMod1; };; enum TGLViewer::EPushAction { kPushStd; kPushCamCenter; kPushAnnotate; };; enum TGLViewer::EDragAction { kDragNone; kDragCameraRotate; kDragCameraTruck; kDragCameraDolly; kDragOverlay; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };; enum TGLLockable::ELock { kUnlocked; kDrawLock; kSelectLock; kModifyLock; };. protected:. TGLAutoRotator*TGLViewer::fAutoRotator!; Bool_tTGLViewer::fAxesDepthTest! remove guides hidden-lines; Int_tTGLViewer::fAxesType! axes type; TGLCamera*TGLViewerBase::fCameraCamera for rendering.; TGLCameraOverlay*TGLViewer::fCameraOverlay! markup size of viewport in scene units; Bool_tTGLViewerBase::fChangedChange requiring redraw is pending.; TGLClip*TGLViewerBase::fClipViewer clipping-plane.; TGLClipSet*TGLViewer::fClipSet!; TContextMenu*TGLViewer::fContextMenu!; TGLCamera*TGLViewer::fCurrentCamera!; TGLOverlayElement*TGLViewer::fCurrentOvlElm! current overlay element; TGLSelectRecordTGLViewer::fCurrentSelRec! select record in use as selected; TGLColorSetTGLViewer::fDarkColorSet! color-set with dark background; Bool_tTGLViewer::fDebugMode! debug mode (forced rebuild + draw scene/frustum/interest boxes); TGLViewer::EDragActionTGLViewer::fDragAction; Bool_tTGLViewer::fDrawCameraCenter! reference marker on?; TGEventHandler*TGLViewer::fEventHandler! event handler; Float_tTGLViewer::fFader! fade the view (0 - no fade/default, 1 - full fade/no rendering done); TGLContextIdentity*TGLVi",MatchSource.WIKI,root/html528/TGLSAViewer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLSAViewer.html
https://root.cern/root/html528/TGLScaleManip.html:544,Energy Efficiency,green,green,544,". TGLScaleManip. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLScaleManip. class TGLScaleManip: public TGLManip. TGLScaleManip. Scale manipulator - attaches to physical shape and draws local axes; widgets with box heads. User can mouse over (turns yellow) and L; click/drag to scale along this axis.; Widgets use standard 3D package axes colours: X red, Y green, Z blue. Function Members (Methods); public:. TGLScaleManip(); TGLScaleManip(TGLPhysicalShape* shape); TGLScaleManip(const TGLScaleManip&); virtual~TGLScaleManip(); voidTGLManip::Attach(TGLPhysicalShape* shape); static TClass*Class(); virtual voidDraw(const TGLCamera& camera) const; Bool_tTGLManip::GetActive() const; TGLPhysicalShape*TGLManip::GetAttached() const; UInt_tTGLManip::GetSelectedWidget() const; virtual Bool_tHandleButton(const Event_t& event, const TGLCamera& camera); virtual Bool_tHandleMotion(const Event_t& event, const TGLCamera& camera); virtual TClass*IsA() const; virtual Bool_tTGLManip::Select(const TGLCamera&, const TGLRect&, const TGLBoundingBox&); voidTGLManip::SetActive(Bool_t a); voidTGLManip::SetSelectedWidget(UInt_t s); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). protected:. voidTGLManip::CalcDrawScale(const TGLBoundingBox& box, const TGLCamera& camera, Double_t& base, TGLVector3* axis) const; const UChar_t*TGLManip::ColorFor(UInt_t widget) const; TGLManip&TGLManip::operator=(const TGLManip&). private:. voidLimitScale(Double_t& factor) const. Data Members; protected:. Bool_tTGLManip::fActive! manipulator is active?; TPointTGLManip::fFirstMouse! first (start) mouse position (in WINDOW coords); TPointTGLManip::fLastMouse! last (latest) mouse position (in WINDOW coords); UInt_tTGLManip::fSelectedWidget! active width (axis) component; ",MatchSource.WIKI,root/html528/TGLScaleManip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLScaleManip.html
https://root.cern/root/html528/TGLScaleManip.html:2568,Energy Efficiency,green,green,2568,"base, TGLVector3* axis) const; const UChar_t*TGLManip::ColorFor(UInt_t widget) const; TGLManip&TGLManip::operator=(const TGLManip&). private:. voidLimitScale(Double_t& factor) const. Data Members; protected:. Bool_tTGLManip::fActive! manipulator is active?; TPointTGLManip::fFirstMouse! first (start) mouse position (in WINDOW coords); TPointTGLManip::fLastMouse! last (latest) mouse position (in WINDOW coords); UInt_tTGLManip::fSelectedWidget! active width (axis) component; TGLPhysicalShape*TGLManip::fShape! manipulated shape. private:. TGLVector3fStartScale! initial scaling factors. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLScaleManip(); Construct scale manipulator not bound to any physical shape. TGLScaleManip(TGLPhysicalShape* shape); Construct scale manipulator bound to TGLPhysicalShape 'shape'. ~TGLScaleManip(); Destory the scale manipulator. void Draw(const TGLCamera& camera) const; Draw scale manipulator - tubes with box heads, in local axes of; attached shape, in red(X), green(Y) and blue(Z), with white center sphere.; If selected widget (mouse over) this is drawn in active colour (yellow). Bool_t HandleButton(const Event_t& event, const TGLCamera& camera); Handle mouse button event over manipulator - returns kTRUE if; redraw required kFALSE otherwise. Bool_t HandleMotion(const Event_t& event, const TGLCamera& camera); Handle mouse motion over manipulator - if active (selected; widget) scale physical along selected widget (axis) of the; manipulator, so it tracks mouse action. Returns kTRUE if redraw; required kFALSE otherwise. void LimitScale(Double_t& factor) const; Clamp scale to sizable values: 1000 - 1/1000; Guards against div by zero problems. TGLScaleManip(). » Author: Richard Maunder 16/09/2005 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/gl:$Id: TGLScaleManip.h 30815 2009-10-20 13:49:22Z rdm $ » Last generated: 2010-09-23 20:06; This page has been automatically gen",MatchSource.WIKI,root/html528/TGLScaleManip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLScaleManip.html
https://root.cern/root/html528/TGLScene.html:10981,Availability,error,error,10981,"wElementPtrVec_t& elVec, Bool_t check_timeout, const TGLPlaneSet_t* clipPlanes = 0); Render DrawElements in elementVec with given timeout.; If clipPlanes is non-zero, test each element against its; clipping planes. Bool_t ResolveSelectRecord(TGLSelectRecord& rec, Int_t curIdx); Process selection record rec.; 'curIdx' is the item position where the scene should start; its processing.; Return TRUE if an object has been identified or FALSE otherwise.; The scene-info member of the record is already set by the caller. void CalcBoundingBox() const; Encapsulates all physical shapes bounding box with axes aligned box.; Validity checked in the base-class. void AdoptLogical(TGLLogicalShape& shape); Adopt dynamically created logical 'shape' - add to internal map; and take responsibility for deleting. Bool_t DestroyLogical(TObject* logid, Bool_t mustFind = kTRUE); Destroy logical shape defined by unique 'ID'.; Returns kTRUE if found/destroyed - kFALSE otherwise. If mustFind is true, an error is reported if the logical is not; found. Int_t DestroyLogicals(); Destroy all logical shapes in scene.; Return number of destroyed logicals. TGLLogicalShape * FindLogical(TObject* logid) const; Find and return logical shape identified by unqiue logid.; Returns 0 if not found. void AdoptPhysical(TGLPhysicalShape& shape); Adopt dynamically created physical 'shape' - add to internal map and take; responsibility for deleting. void DestroyPhysicalInternal(TGLScene::PhysicalShapeMapIt_t pit); Virtual function to destroy a physical. Sub-classes might have; special checks to perform.; Caller should also invalidate the draw-list. Bool_t DestroyPhysical(UInt_t phid); Destroy physical shape defined by unique 'ID'.; Returns kTRUE if found/destroyed - kFALSE otherwise. Int_t DestroyPhysicals(); Destroy physical shapes. TGLPhysicalShape* FindPhysical(UInt_t phid) const; Find and return physical shape identified by unqiue 'ID'.; Returns 0 if not found. UInt_t GetMaxPhysicalID(); Returns the maximum used ",MatchSource.WIKI,root/html528/TGLScene.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLScene.html
https://root.cern/root/html528/TGLScene.html:2368,Deployability,update,updateViewers,2368, TGLScene(); virtual~TGLScene(); voidTGLSceneBase::AddViewer(TGLViewerBase* viewer); virtual voidAdoptLogical(TGLLogicalShape& shape); virtual voidAdoptPhysical(TGLPhysicalShape& shape); UInt_tBeginSmartRefresh(); virtual Bool_tBeginUpdate(); const TGLBoundingBox&TGLSceneBase::BoundingBox() const; virtual voidCalcBoundingBox() const; static TClass*Class(); TGLClip*TGLSceneBase::Clip() const; virtual TGLScene::TSceneInfo*CreateSceneInfo(TGLViewerBase* view); ,MatchSource.WIKI,root/html528/TGLScene.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLScene.html
https://root.cern/root/html528/TGLScene.html:6264,Deployability,update,update,6264,"Int_t phid, Double_t* trans, UChar_t* col); virtual voidUpdatePhysical(UInt_t phid, Double_t* trans, Color_t cidx = -1, UChar_t transp = 0); virtual voidUpdatePhysioLogical(TObject* logid, Double_t* trans, UChar_t* col); virtual voidUpdatePhysioLogical(TObject* logid, Double_t* trans, Color_t cidx, UChar_t transp); virtual voidUpdateSceneInfo(TGLRnrCtx& rnrCtx). protected:. virtual voidDestroyPhysicalInternal(TGLScene::PhysicalShapeMapIt_t pit); voidReleaseGLCtxIdentity(). private:. TGLScene(const TGLScene&); static Bool_tComparePhysicalDiagonals(const TGLPhysicalShape* shape1, const TGLPhysicalShape* shape2); static Bool_tComparePhysicalVolumes(const TGLPhysicalShape* shape1, const TGLPhysicalShape* shape2); TGLScene&operator=(const TGLScene&). Data Members; public:. enum TGLLockable::ELock { kUnlocked; kDrawLock; kSelectLock; kModifyLock; };. protected:. Bool_tTGLSceneBase::fAutoDestruct; TGLBoundingBoxTGLSceneBase::fBoundingBoxbounding box for scene (axis aligned) - lazy update - use BoundingBox() to access; Bool_tTGLSceneBase::fBoundingBoxValidbounding box valid?; TGLClip*TGLSceneBase::fClipScene clipping-plane.; Bool_tTGLSceneBase::fDoClipCheckPerform global clip-plane-check in UpdateSceneInfo(); Bool_tTGLSceneBase::fDoFrustumCheckPerform global frustum-check in UpdateSceneInfo(); TGLContextIdentity*fGLCtxIdentity; Bool_tfInSmartRefresh!; Short_tTGLSceneBase::fLODScene-lod.; Float_tfLastLineWidthScale; Float_tfLastPointSizeScale; TGLLockable::ELockTGLLockable::fLockLock state.; map<TObject*,TGLLogicalShape*>fLogicalShapes!; UInt_tTGLSceneBase::fMinorStampCounter increased on minimal update.; TStringTGLSceneBase::fNameObject identifier.; Float_tTGLSceneBase::fOLLineWScene outline line-width.; map<unsigned int,TGLPhysicalShape*>fPhysicalShapes!; UInt_tTGLSceneBase::fSceneIDUnique scene id.; Bool_tTGLSceneBase::fSelectableObjects in the scene are selectable.; map<TObject*,TGLLogicalShape*>fSmartRefreshCache!; Short_tTGLSceneBase::fStyleScene-style.; UInt_tTGLSceneB",MatchSource.WIKI,root/html528/TGLScene.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLScene.html
https://root.cern/root/html528/TGLScene.html:6890,Deployability,update,update,6890,"ysicalShape* shape1, const TGLPhysicalShape* shape2); static Bool_tComparePhysicalVolumes(const TGLPhysicalShape* shape1, const TGLPhysicalShape* shape2); TGLScene&operator=(const TGLScene&). Data Members; public:. enum TGLLockable::ELock { kUnlocked; kDrawLock; kSelectLock; kModifyLock; };. protected:. Bool_tTGLSceneBase::fAutoDestruct; TGLBoundingBoxTGLSceneBase::fBoundingBoxbounding box for scene (axis aligned) - lazy update - use BoundingBox() to access; Bool_tTGLSceneBase::fBoundingBoxValidbounding box valid?; TGLClip*TGLSceneBase::fClipScene clipping-plane.; Bool_tTGLSceneBase::fDoClipCheckPerform global clip-plane-check in UpdateSceneInfo(); Bool_tTGLSceneBase::fDoFrustumCheckPerform global frustum-check in UpdateSceneInfo(); TGLContextIdentity*fGLCtxIdentity; Bool_tfInSmartRefresh!; Short_tTGLSceneBase::fLODScene-lod.; Float_tfLastLineWidthScale; Float_tfLastPointSizeScale; TGLLockable::ELockTGLLockable::fLockLock state.; map<TObject*,TGLLogicalShape*>fLogicalShapes!; UInt_tTGLSceneBase::fMinorStampCounter increased on minimal update.; TStringTGLSceneBase::fNameObject identifier.; Float_tTGLSceneBase::fOLLineWScene outline line-width.; map<unsigned int,TGLPhysicalShape*>fPhysicalShapes!; UInt_tTGLSceneBase::fSceneIDUnique scene id.; Bool_tTGLSceneBase::fSelectableObjects in the scene are selectable.; map<TObject*,TGLLogicalShape*>fSmartRefreshCache!; Short_tTGLSceneBase::fStyleScene-style.; UInt_tTGLSceneBase::fTimeStampCounter increased on every update.; TStringTGLSceneBase::fTitleObject title.; list<TGLViewerBase*>TGLSceneBase::fViewers; Float_tTGLSceneBase::fWFLineWScene wire-frame line-width. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLScene(); {}. ~TGLScene(); Destroy scene objects. void ReleaseGLCtxIdentity(); Release all GL resources for current context identity.; Requires iteration over all logical shapes. Bool_t ComparePhysicalVolumes(const TGLPhysicalShape* shape1, const TGLPhysicalShape* shape2); C",MatchSource.WIKI,root/html528/TGLScene.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLScene.html
https://root.cern/root/html528/TGLScene.html:7318,Deployability,update,update,7318,"o access; Bool_tTGLSceneBase::fBoundingBoxValidbounding box valid?; TGLClip*TGLSceneBase::fClipScene clipping-plane.; Bool_tTGLSceneBase::fDoClipCheckPerform global clip-plane-check in UpdateSceneInfo(); Bool_tTGLSceneBase::fDoFrustumCheckPerform global frustum-check in UpdateSceneInfo(); TGLContextIdentity*fGLCtxIdentity; Bool_tfInSmartRefresh!; Short_tTGLSceneBase::fLODScene-lod.; Float_tfLastLineWidthScale; Float_tfLastPointSizeScale; TGLLockable::ELockTGLLockable::fLockLock state.; map<TObject*,TGLLogicalShape*>fLogicalShapes!; UInt_tTGLSceneBase::fMinorStampCounter increased on minimal update.; TStringTGLSceneBase::fNameObject identifier.; Float_tTGLSceneBase::fOLLineWScene outline line-width.; map<unsigned int,TGLPhysicalShape*>fPhysicalShapes!; UInt_tTGLSceneBase::fSceneIDUnique scene id.; Bool_tTGLSceneBase::fSelectableObjects in the scene are selectable.; map<TObject*,TGLLogicalShape*>fSmartRefreshCache!; Short_tTGLSceneBase::fStyleScene-style.; UInt_tTGLSceneBase::fTimeStampCounter increased on every update.; TStringTGLSceneBase::fTitleObject title.; list<TGLViewerBase*>TGLSceneBase::fViewers; Float_tTGLSceneBase::fWFLineWScene wire-frame line-width. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLScene(); {}. ~TGLScene(); Destroy scene objects. void ReleaseGLCtxIdentity(); Release all GL resources for current context identity.; Requires iteration over all logical shapes. Bool_t ComparePhysicalVolumes(const TGLPhysicalShape* shape1, const TGLPhysicalShape* shape2); Compare 'shape1' and 'shape2' bounding box volumes - return kTRUE if; 'shape1' bigger than 'shape2'. Bool_t ComparePhysicalDiagonals(const TGLPhysicalShape* shape1, const TGLPhysicalShape* shape2); Compare 'shape1' and 'shape2' bounding box volumes - return kTRUE if; 'shape1' bigger than 'shape2'. void RebuildSceneInfo(TGLRnrCtx& rnrCtx); Major change in scene, need to rebuild all-element draw-vector and; sort it. Sort the TGLPhysical draw list by sh",MatchSource.WIKI,root/html528/TGLScene.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLScene.html
https://root.cern/root/html528/TGLScene.html:12061,Deployability,update,update,12061,"l logical shapes in scene.; Return number of destroyed logicals. TGLLogicalShape * FindLogical(TObject* logid) const; Find and return logical shape identified by unqiue logid.; Returns 0 if not found. void AdoptPhysical(TGLPhysicalShape& shape); Adopt dynamically created physical 'shape' - add to internal map and take; responsibility for deleting. void DestroyPhysicalInternal(TGLScene::PhysicalShapeMapIt_t pit); Virtual function to destroy a physical. Sub-classes might have; special checks to perform.; Caller should also invalidate the draw-list. Bool_t DestroyPhysical(UInt_t phid); Destroy physical shape defined by unique 'ID'.; Returns kTRUE if found/destroyed - kFALSE otherwise. Int_t DestroyPhysicals(); Destroy physical shapes. TGLPhysicalShape* FindPhysical(UInt_t phid) const; Find and return physical shape identified by unqiue 'ID'.; Returns 0 if not found. UInt_t GetMaxPhysicalID(); Returns the maximum used physical id.; Returns 0 if empty. Bool_t BeginUpdate(); Put scene in update mode, return true if lock acquired. void EndUpdate(Bool_t minorChange = kTRUE, Bool_t sceneChanged = kTRUE, Bool_t updateViewers = kTRUE); Exit scene update mode. If sceneChanged is true (default), the scene timestamp is; increased and basic draw-lists etc will be rebuild on next draw; request. If you only changed colors or some other visual; parameters that do not affect object bounding-box or; transformation matrix, you can set it to false. If updateViewers is true (default), the viewers using this scene; will be tagged as changed. If sceneChanged is true the; updateViewers should be true as well, unless you take care of; the viewers elsewhere or in some other way. void UpdateLogical(TObject* logid); Drop display-lists for the logical (assume TGLObject/direct rendering).; Re-calculate the bounding box (also for all physicals). void UpdatePhysical(UInt_t phid, Double_t* trans, UChar_t* col); Reposition/recolor physical shape. void UpdatePhysical(UInt_t phid, Double_t* trans, Color",MatchSource.WIKI,root/html528/TGLScene.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLScene.html
https://root.cern/root/html528/TGLScene.html:12183,Deployability,update,updateViewers,12183,"* logid) const; Find and return logical shape identified by unqiue logid.; Returns 0 if not found. void AdoptPhysical(TGLPhysicalShape& shape); Adopt dynamically created physical 'shape' - add to internal map and take; responsibility for deleting. void DestroyPhysicalInternal(TGLScene::PhysicalShapeMapIt_t pit); Virtual function to destroy a physical. Sub-classes might have; special checks to perform.; Caller should also invalidate the draw-list. Bool_t DestroyPhysical(UInt_t phid); Destroy physical shape defined by unique 'ID'.; Returns kTRUE if found/destroyed - kFALSE otherwise. Int_t DestroyPhysicals(); Destroy physical shapes. TGLPhysicalShape* FindPhysical(UInt_t phid) const; Find and return physical shape identified by unqiue 'ID'.; Returns 0 if not found. UInt_t GetMaxPhysicalID(); Returns the maximum used physical id.; Returns 0 if empty. Bool_t BeginUpdate(); Put scene in update mode, return true if lock acquired. void EndUpdate(Bool_t minorChange = kTRUE, Bool_t sceneChanged = kTRUE, Bool_t updateViewers = kTRUE); Exit scene update mode. If sceneChanged is true (default), the scene timestamp is; increased and basic draw-lists etc will be rebuild on next draw; request. If you only changed colors or some other visual; parameters that do not affect object bounding-box or; transformation matrix, you can set it to false. If updateViewers is true (default), the viewers using this scene; will be tagged as changed. If sceneChanged is true the; updateViewers should be true as well, unless you take care of; the viewers elsewhere or in some other way. void UpdateLogical(TObject* logid); Drop display-lists for the logical (assume TGLObject/direct rendering).; Re-calculate the bounding box (also for all physicals). void UpdatePhysical(UInt_t phid, Double_t* trans, UChar_t* col); Reposition/recolor physical shape. void UpdatePhysical(UInt_t phid, Double_t* trans, Color_t cidx = -1, UChar_t transp = 0); Reposition/recolor physical shape. void UpdatePhysioLogical(TObject*",MatchSource.WIKI,root/html528/TGLScene.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLScene.html
https://root.cern/root/html528/TGLScene.html:12218,Deployability,update,update,12218,"* logid) const; Find and return logical shape identified by unqiue logid.; Returns 0 if not found. void AdoptPhysical(TGLPhysicalShape& shape); Adopt dynamically created physical 'shape' - add to internal map and take; responsibility for deleting. void DestroyPhysicalInternal(TGLScene::PhysicalShapeMapIt_t pit); Virtual function to destroy a physical. Sub-classes might have; special checks to perform.; Caller should also invalidate the draw-list. Bool_t DestroyPhysical(UInt_t phid); Destroy physical shape defined by unique 'ID'.; Returns kTRUE if found/destroyed - kFALSE otherwise. Int_t DestroyPhysicals(); Destroy physical shapes. TGLPhysicalShape* FindPhysical(UInt_t phid) const; Find and return physical shape identified by unqiue 'ID'.; Returns 0 if not found. UInt_t GetMaxPhysicalID(); Returns the maximum used physical id.; Returns 0 if empty. Bool_t BeginUpdate(); Put scene in update mode, return true if lock acquired. void EndUpdate(Bool_t minorChange = kTRUE, Bool_t sceneChanged = kTRUE, Bool_t updateViewers = kTRUE); Exit scene update mode. If sceneChanged is true (default), the scene timestamp is; increased and basic draw-lists etc will be rebuild on next draw; request. If you only changed colors or some other visual; parameters that do not affect object bounding-box or; transformation matrix, you can set it to false. If updateViewers is true (default), the viewers using this scene; will be tagged as changed. If sceneChanged is true the; updateViewers should be true as well, unless you take care of; the viewers elsewhere or in some other way. void UpdateLogical(TObject* logid); Drop display-lists for the logical (assume TGLObject/direct rendering).; Re-calculate the bounding box (also for all physicals). void UpdatePhysical(UInt_t phid, Double_t* trans, UChar_t* col); Reposition/recolor physical shape. void UpdatePhysical(UInt_t phid, Double_t* trans, Color_t cidx = -1, UChar_t transp = 0); Reposition/recolor physical shape. void UpdatePhysioLogical(TObject*",MatchSource.WIKI,root/html528/TGLScene.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLScene.html
https://root.cern/root/html528/TGLScene.html:12518,Deployability,update,updateViewers,12518,"o perform.; Caller should also invalidate the draw-list. Bool_t DestroyPhysical(UInt_t phid); Destroy physical shape defined by unique 'ID'.; Returns kTRUE if found/destroyed - kFALSE otherwise. Int_t DestroyPhysicals(); Destroy physical shapes. TGLPhysicalShape* FindPhysical(UInt_t phid) const; Find and return physical shape identified by unqiue 'ID'.; Returns 0 if not found. UInt_t GetMaxPhysicalID(); Returns the maximum used physical id.; Returns 0 if empty. Bool_t BeginUpdate(); Put scene in update mode, return true if lock acquired. void EndUpdate(Bool_t minorChange = kTRUE, Bool_t sceneChanged = kTRUE, Bool_t updateViewers = kTRUE); Exit scene update mode. If sceneChanged is true (default), the scene timestamp is; increased and basic draw-lists etc will be rebuild on next draw; request. If you only changed colors or some other visual; parameters that do not affect object bounding-box or; transformation matrix, you can set it to false. If updateViewers is true (default), the viewers using this scene; will be tagged as changed. If sceneChanged is true the; updateViewers should be true as well, unless you take care of; the viewers elsewhere or in some other way. void UpdateLogical(TObject* logid); Drop display-lists for the logical (assume TGLObject/direct rendering).; Re-calculate the bounding box (also for all physicals). void UpdatePhysical(UInt_t phid, Double_t* trans, UChar_t* col); Reposition/recolor physical shape. void UpdatePhysical(UInt_t phid, Double_t* trans, Color_t cidx = -1, UChar_t transp = 0); Reposition/recolor physical shape. void UpdatePhysioLogical(TObject* logid, Double_t* trans, UChar_t* col); Reposition/recolor physical for given logical (assume TGLObject and; a single physical). void UpdatePhysioLogical(TObject* logid, Double_t* trans, Color_t cidx, UChar_t transp); Reposition/recolor physical for given logical (assume TGLObject and; a single physical). UInt_t BeginSmartRefresh(); Moves logicals that support smart-refresh to intermediate c",MatchSource.WIKI,root/html528/TGLScene.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLScene.html
https://root.cern/root/html528/TGLScene.html:12637,Deployability,update,updateViewers,12637,"e defined by unique 'ID'.; Returns kTRUE if found/destroyed - kFALSE otherwise. Int_t DestroyPhysicals(); Destroy physical shapes. TGLPhysicalShape* FindPhysical(UInt_t phid) const; Find and return physical shape identified by unqiue 'ID'.; Returns 0 if not found. UInt_t GetMaxPhysicalID(); Returns the maximum used physical id.; Returns 0 if empty. Bool_t BeginUpdate(); Put scene in update mode, return true if lock acquired. void EndUpdate(Bool_t minorChange = kTRUE, Bool_t sceneChanged = kTRUE, Bool_t updateViewers = kTRUE); Exit scene update mode. If sceneChanged is true (default), the scene timestamp is; increased and basic draw-lists etc will be rebuild on next draw; request. If you only changed colors or some other visual; parameters that do not affect object bounding-box or; transformation matrix, you can set it to false. If updateViewers is true (default), the viewers using this scene; will be tagged as changed. If sceneChanged is true the; updateViewers should be true as well, unless you take care of; the viewers elsewhere or in some other way. void UpdateLogical(TObject* logid); Drop display-lists for the logical (assume TGLObject/direct rendering).; Re-calculate the bounding box (also for all physicals). void UpdatePhysical(UInt_t phid, Double_t* trans, UChar_t* col); Reposition/recolor physical shape. void UpdatePhysical(UInt_t phid, Double_t* trans, Color_t cidx = -1, UChar_t transp = 0); Reposition/recolor physical shape. void UpdatePhysioLogical(TObject* logid, Double_t* trans, UChar_t* col); Reposition/recolor physical for given logical (assume TGLObject and; a single physical). void UpdatePhysioLogical(TObject* logid, Double_t* trans, Color_t cidx, UChar_t transp); Reposition/recolor physical for given logical (assume TGLObject and; a single physical). UInt_t BeginSmartRefresh(); Moves logicals that support smart-refresh to intermediate cache.; Destroys the others and returns the number of destroyed ones. void EndSmartRefresh(); Wipes logicals in ref",MatchSource.WIKI,root/html528/TGLScene.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLScene.html
https://root.cern/root/html528/TGLScene.html:605,Integrability,interface,interface,605,". TGLScene. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLScene. class TGLScene: public TGLSceneBase. TGLScene provides managememnt and rendering of ROOT's default 3D; object representation as logical and physical shapes. A GL scene is the container for all the viewable objects (shapes); loaded into the viewer. It consists of two main stl::maps containing; the TGLLogicalShape and TGLPhysicalShape collections, and interface; functions enabling viewers to manage objects in these. The physical; shapes defined the placement of copies of the logical shapes - see; TGLLogicalShape/TGLPhysicalShape for more information on relationship. The scene can be drawn by owning viewer, passing camera, draw style; & quality (LOD), clipping etc - see Draw(). The scene can also be; drawn for selection in similar fashion - see Select(). The scene; keeps track of a single selected physical - which can be modified by; viewers. The scene maintains a lazy calculated bounding box for the total; scene extents, axis aligned round TGLPhysicalShape shapes. Currently a scene is owned exclusively by one viewer - however it is; intended that it could easily be shared by multiple viewers - for; efficiency and syncronisation reasons. Hence viewer variant objects; camera, clips etc being owned by viewer and passed at draw/select. Function Members (Methods); public:. TGLScene(); virtual~TGLScene(); voidTGLSceneBase::AddViewer(TGLViewerBase* viewer); virtual voidAdoptLogical(TGLLogicalShape& shape); virtual voidAdoptPhysical(TGLPhysicalShape& shape); UInt_tBeginSmartRefresh(); virtual Bool_tBeginUpdate(); const TGLBoundingBox&TGLSceneBase::BoundingBox() const; virtual voidCalcBoundingBox() const; static TClass*Class(); TGLClip*TGLSceneBase::Clip() const; virtual TGLScene::TSceneInfo*CreateSceneInfo(TGLViewerBase* view); ",MatchSource.WIKI,root/html528/TGLScene.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLScene.html
https://root.cern/root/html528/TGLScene.html:8957,Integrability,depend,dependant,8957,"ComparePhysicalDiagonals(const TGLPhysicalShape* shape1, const TGLPhysicalShape* shape2); Compare 'shape1' and 'shape2' bounding box volumes - return kTRUE if; 'shape1' bigger than 'shape2'. void RebuildSceneInfo(TGLRnrCtx& rnrCtx); Major change in scene, need to rebuild all-element draw-vector and; sort it. Sort the TGLPhysical draw list by shape bounding box diagonal, from; large to small. This makes dropout of shapes with time limited; Draw() calls must less noticable. As this does not use projected; size it only needs to be done after a scene content change - not; everytime scene drawn (potential camera/projection change). void UpdateSceneInfo(TGLRnrCtx& rnrCtx); Fill scene-info with information needed for rendering, take into; account the render-context (viewer state, camera, clipping).; Here we have to iterate over all the physical shapes and select; the visible ones. While at it, opaque and transparent shapes are; divided into two groups. void LodifySceneInfo(TGLRnrCtx& rnrCtx); Setup LOD-dependant values in scene-info.; We have to perform LOD quantization for all draw-elements. void PreDraw(TGLRnrCtx& rnrCtx); Initialize rendering.; Pass to base-class where most work is done.; Check if GL-ctx is shared with the previous one; if not; wipe display-lists of all logicals. void RenderOpaque(TGLRnrCtx& rnrCtx); Render opaque elements. void RenderTransp(TGLRnrCtx& rnrCtx); Render transparent elements. void RenderSelOpaque(TGLRnrCtx& rnrCtx); Render selected opaque elements. void RenderSelTransp(TGLRnrCtx& rnrCtx); Render selected transparent elements. void PostDraw(TGLRnrCtx& rnrCtx); Called after the rendering is finished.; In debug mode draw statistcs is dumped.; Parent's PostDraw is called for GL cleanup. void RenderAllPasses(TGLRnrCtx& rnrCtx, TGLScene::DrawElementPtrVec_t& elVec, Bool_t check_timeout); Do full rendering of scene. First draw the opaques, then the transparents. For each we do; the number of passes required by draw mode and clipping setup. void Re",MatchSource.WIKI,root/html528/TGLScene.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLScene.html
https://root.cern/root/html528/TGLScene.html:477,Performance,load,loaded,477,". TGLScene. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLScene. class TGLScene: public TGLSceneBase. TGLScene provides managememnt and rendering of ROOT's default 3D; object representation as logical and physical shapes. A GL scene is the container for all the viewable objects (shapes); loaded into the viewer. It consists of two main stl::maps containing; the TGLLogicalShape and TGLPhysicalShape collections, and interface; functions enabling viewers to manage objects in these. The physical; shapes defined the placement of copies of the logical shapes - see; TGLLogicalShape/TGLPhysicalShape for more information on relationship. The scene can be drawn by owning viewer, passing camera, draw style; & quality (LOD), clipping etc - see Draw(). The scene can also be; drawn for selection in similar fashion - see Select(). The scene; keeps track of a single selected physical - which can be modified by; viewers. The scene maintains a lazy calculated bounding box for the total; scene extents, axis aligned round TGLPhysicalShape shapes. Currently a scene is owned exclusively by one viewer - however it is; intended that it could easily be shared by multiple viewers - for; efficiency and syncronisation reasons. Hence viewer variant objects; camera, clips etc being owned by viewer and passed at draw/select. Function Members (Methods); public:. TGLScene(); virtual~TGLScene(); voidTGLSceneBase::AddViewer(TGLViewerBase* viewer); virtual voidAdoptLogical(TGLLogicalShape& shape); virtual voidAdoptPhysical(TGLPhysicalShape& shape); UInt_tBeginSmartRefresh(); virtual Bool_tBeginUpdate(); const TGLBoundingBox&TGLSceneBase::BoundingBox() const; virtual voidCalcBoundingBox() const; static TClass*Class(); TGLClip*TGLSceneBase::Clip() const; virtual TGLScene::TSceneInfo*CreateSceneInfo(TGLViewerBase* view); ",MatchSource.WIKI,root/html528/TGLScene.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLScene.html
https://root.cern/root/html528/TGLScene.html:9001,Performance,perform,perform,9001,"alShape* shape2); Compare 'shape1' and 'shape2' bounding box volumes - return kTRUE if; 'shape1' bigger than 'shape2'. void RebuildSceneInfo(TGLRnrCtx& rnrCtx); Major change in scene, need to rebuild all-element draw-vector and; sort it. Sort the TGLPhysical draw list by shape bounding box diagonal, from; large to small. This makes dropout of shapes with time limited; Draw() calls must less noticable. As this does not use projected; size it only needs to be done after a scene content change - not; everytime scene drawn (potential camera/projection change). void UpdateSceneInfo(TGLRnrCtx& rnrCtx); Fill scene-info with information needed for rendering, take into; account the render-context (viewer state, camera, clipping).; Here we have to iterate over all the physical shapes and select; the visible ones. While at it, opaque and transparent shapes are; divided into two groups. void LodifySceneInfo(TGLRnrCtx& rnrCtx); Setup LOD-dependant values in scene-info.; We have to perform LOD quantization for all draw-elements. void PreDraw(TGLRnrCtx& rnrCtx); Initialize rendering.; Pass to base-class where most work is done.; Check if GL-ctx is shared with the previous one; if not; wipe display-lists of all logicals. void RenderOpaque(TGLRnrCtx& rnrCtx); Render opaque elements. void RenderTransp(TGLRnrCtx& rnrCtx); Render transparent elements. void RenderSelOpaque(TGLRnrCtx& rnrCtx); Render selected opaque elements. void RenderSelTransp(TGLRnrCtx& rnrCtx); Render selected transparent elements. void PostDraw(TGLRnrCtx& rnrCtx); Called after the rendering is finished.; In debug mode draw statistcs is dumped.; Parent's PostDraw is called for GL cleanup. void RenderAllPasses(TGLRnrCtx& rnrCtx, TGLScene::DrawElementPtrVec_t& elVec, Bool_t check_timeout); Do full rendering of scene. First draw the opaques, then the transparents. For each we do; the number of passes required by draw mode and clipping setup. void RenderElements(TGLRnrCtx& rnrCtx, TGLScene::DrawElementPtrVec_t& elVec, B",MatchSource.WIKI,root/html528/TGLScene.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLScene.html
https://root.cern/root/html528/TGLScene.html:11562,Performance,perform,perform,11562,"apsulates all physical shapes bounding box with axes aligned box.; Validity checked in the base-class. void AdoptLogical(TGLLogicalShape& shape); Adopt dynamically created logical 'shape' - add to internal map; and take responsibility for deleting. Bool_t DestroyLogical(TObject* logid, Bool_t mustFind = kTRUE); Destroy logical shape defined by unique 'ID'.; Returns kTRUE if found/destroyed - kFALSE otherwise. If mustFind is true, an error is reported if the logical is not; found. Int_t DestroyLogicals(); Destroy all logical shapes in scene.; Return number of destroyed logicals. TGLLogicalShape * FindLogical(TObject* logid) const; Find and return logical shape identified by unqiue logid.; Returns 0 if not found. void AdoptPhysical(TGLPhysicalShape& shape); Adopt dynamically created physical 'shape' - add to internal map and take; responsibility for deleting. void DestroyPhysicalInternal(TGLScene::PhysicalShapeMapIt_t pit); Virtual function to destroy a physical. Sub-classes might have; special checks to perform.; Caller should also invalidate the draw-list. Bool_t DestroyPhysical(UInt_t phid); Destroy physical shape defined by unique 'ID'.; Returns kTRUE if found/destroyed - kFALSE otherwise. Int_t DestroyPhysicals(); Destroy physical shapes. TGLPhysicalShape* FindPhysical(UInt_t phid) const; Find and return physical shape identified by unqiue 'ID'.; Returns 0 if not found. UInt_t GetMaxPhysicalID(); Returns the maximum used physical id.; Returns 0 if empty. Bool_t BeginUpdate(); Put scene in update mode, return true if lock acquired. void EndUpdate(Bool_t minorChange = kTRUE, Bool_t sceneChanged = kTRUE, Bool_t updateViewers = kTRUE); Exit scene update mode. If sceneChanged is true (default), the scene timestamp is; increased and basic draw-lists etc will be rebuild on next draw; request. If you only changed colors or some other visual; parameters that do not affect object bounding-box or; transformation matrix, you can set it to false. If updateViewers is true (defa",MatchSource.WIKI,root/html528/TGLScene.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLScene.html
https://root.cern/root/html528/TGLScene.html:13560,Performance,cache,cache,13560,"pdateViewers is true (default), the viewers using this scene; will be tagged as changed. If sceneChanged is true the; updateViewers should be true as well, unless you take care of; the viewers elsewhere or in some other way. void UpdateLogical(TObject* logid); Drop display-lists for the logical (assume TGLObject/direct rendering).; Re-calculate the bounding box (also for all physicals). void UpdatePhysical(UInt_t phid, Double_t* trans, UChar_t* col); Reposition/recolor physical shape. void UpdatePhysical(UInt_t phid, Double_t* trans, Color_t cidx = -1, UChar_t transp = 0); Reposition/recolor physical shape. void UpdatePhysioLogical(TObject* logid, Double_t* trans, UChar_t* col); Reposition/recolor physical for given logical (assume TGLObject and; a single physical). void UpdatePhysioLogical(TObject* logid, Double_t* trans, Color_t cidx, UChar_t transp); Reposition/recolor physical for given logical (assume TGLObject and; a single physical). UInt_t BeginSmartRefresh(); Moves logicals that support smart-refresh to intermediate cache.; Destroys the others and returns the number of destroyed ones. void EndSmartRefresh(); Wipes logicals in refresh-cache. TGLLogicalShape * FindLogicalSmartRefresh(TObject* ID) const; Find and return logical shape identified by unqiue 'ID' in refresh-cache.; Returns 0 if not found. UInt_t SizeOfScene() const; Return memory cost of scene.; Warning: NOT CORRECT at present - doesn't correctly calculate size.; of logical shapes with dynamic internal contents. void DumpMapSizes() const; Print sizes of logical nad physical-shape maps. void RGBAFromColorIdx(Float_t* rgba, Color_t ci, Char_t transp = 0); Fill rgba color from ROOT color-index ci and transparency (0->100). Bool_t IsOutside(const TGLBoundingBox& box, const TGLPlaneSet_t& planes); Check if box is outside of all planes. TGLScene(const TGLScene& ). TGLScene& operator=(const TGLScene& ). TSceneInfo* CreateSceneInfo(TGLViewerBase* view). LogicalShapeMap_t& RefLogicalShapes(); Temporary expo",MatchSource.WIKI,root/html528/TGLScene.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLScene.html
https://root.cern/root/html528/TGLScene.html:13680,Performance,cache,cache,13680," be true as well, unless you take care of; the viewers elsewhere or in some other way. void UpdateLogical(TObject* logid); Drop display-lists for the logical (assume TGLObject/direct rendering).; Re-calculate the bounding box (also for all physicals). void UpdatePhysical(UInt_t phid, Double_t* trans, UChar_t* col); Reposition/recolor physical shape. void UpdatePhysical(UInt_t phid, Double_t* trans, Color_t cidx = -1, UChar_t transp = 0); Reposition/recolor physical shape. void UpdatePhysioLogical(TObject* logid, Double_t* trans, UChar_t* col); Reposition/recolor physical for given logical (assume TGLObject and; a single physical). void UpdatePhysioLogical(TObject* logid, Double_t* trans, Color_t cidx, UChar_t transp); Reposition/recolor physical for given logical (assume TGLObject and; a single physical). UInt_t BeginSmartRefresh(); Moves logicals that support smart-refresh to intermediate cache.; Destroys the others and returns the number of destroyed ones. void EndSmartRefresh(); Wipes logicals in refresh-cache. TGLLogicalShape * FindLogicalSmartRefresh(TObject* ID) const; Find and return logical shape identified by unqiue 'ID' in refresh-cache.; Returns 0 if not found. UInt_t SizeOfScene() const; Return memory cost of scene.; Warning: NOT CORRECT at present - doesn't correctly calculate size.; of logical shapes with dynamic internal contents. void DumpMapSizes() const; Print sizes of logical nad physical-shape maps. void RGBAFromColorIdx(Float_t* rgba, Color_t ci, Char_t transp = 0); Fill rgba color from ROOT color-index ci and transparency (0->100). Bool_t IsOutside(const TGLBoundingBox& box, const TGLPlaneSet_t& planes); Check if box is outside of all planes. TGLScene(const TGLScene& ). TGLScene& operator=(const TGLScene& ). TSceneInfo* CreateSceneInfo(TGLViewerBase* view). LogicalShapeMap_t& RefLogicalShapes(); Temporary export for setting selected-state of physical shapes. { return fLogicalShapes; }. TGLContextIdentity* GetGLCtxIdentity() const. GL-context hol",MatchSource.WIKI,root/html528/TGLScene.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLScene.html
https://root.cern/root/html528/TGLScene.html:13816,Performance,cache,cache,13816,"eLogical(TObject* logid); Drop display-lists for the logical (assume TGLObject/direct rendering).; Re-calculate the bounding box (also for all physicals). void UpdatePhysical(UInt_t phid, Double_t* trans, UChar_t* col); Reposition/recolor physical shape. void UpdatePhysical(UInt_t phid, Double_t* trans, Color_t cidx = -1, UChar_t transp = 0); Reposition/recolor physical shape. void UpdatePhysioLogical(TObject* logid, Double_t* trans, UChar_t* col); Reposition/recolor physical for given logical (assume TGLObject and; a single physical). void UpdatePhysioLogical(TObject* logid, Double_t* trans, Color_t cidx, UChar_t transp); Reposition/recolor physical for given logical (assume TGLObject and; a single physical). UInt_t BeginSmartRefresh(); Moves logicals that support smart-refresh to intermediate cache.; Destroys the others and returns the number of destroyed ones. void EndSmartRefresh(); Wipes logicals in refresh-cache. TGLLogicalShape * FindLogicalSmartRefresh(TObject* ID) const; Find and return logical shape identified by unqiue 'ID' in refresh-cache.; Returns 0 if not found. UInt_t SizeOfScene() const; Return memory cost of scene.; Warning: NOT CORRECT at present - doesn't correctly calculate size.; of logical shapes with dynamic internal contents. void DumpMapSizes() const; Print sizes of logical nad physical-shape maps. void RGBAFromColorIdx(Float_t* rgba, Color_t ci, Char_t transp = 0); Fill rgba color from ROOT color-index ci and transparency (0->100). Bool_t IsOutside(const TGLBoundingBox& box, const TGLPlaneSet_t& planes); Check if box is outside of all planes. TGLScene(const TGLScene& ). TGLScene& operator=(const TGLScene& ). TSceneInfo* CreateSceneInfo(TGLViewerBase* view). LogicalShapeMap_t& RefLogicalShapes(); Temporary export for setting selected-state of physical shapes. { return fLogicalShapes; }. TGLContextIdentity* GetGLCtxIdentity() const. GL-context holding display-list definitions. { return fGLCtxIdentity; }. » Author: Matevz Tadel, Feb 2007 » Co",MatchSource.WIKI,root/html528/TGLScene.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLScene.html
https://root.cern/root/html528/TGLScene.html:10122,Safety,timeout,timeout,10122,"draw-elements. void PreDraw(TGLRnrCtx& rnrCtx); Initialize rendering.; Pass to base-class where most work is done.; Check if GL-ctx is shared with the previous one; if not; wipe display-lists of all logicals. void RenderOpaque(TGLRnrCtx& rnrCtx); Render opaque elements. void RenderTransp(TGLRnrCtx& rnrCtx); Render transparent elements. void RenderSelOpaque(TGLRnrCtx& rnrCtx); Render selected opaque elements. void RenderSelTransp(TGLRnrCtx& rnrCtx); Render selected transparent elements. void PostDraw(TGLRnrCtx& rnrCtx); Called after the rendering is finished.; In debug mode draw statistcs is dumped.; Parent's PostDraw is called for GL cleanup. void RenderAllPasses(TGLRnrCtx& rnrCtx, TGLScene::DrawElementPtrVec_t& elVec, Bool_t check_timeout); Do full rendering of scene. First draw the opaques, then the transparents. For each we do; the number of passes required by draw mode and clipping setup. void RenderElements(TGLRnrCtx& rnrCtx, TGLScene::DrawElementPtrVec_t& elVec, Bool_t check_timeout, const TGLPlaneSet_t* clipPlanes = 0); Render DrawElements in elementVec with given timeout.; If clipPlanes is non-zero, test each element against its; clipping planes. Bool_t ResolveSelectRecord(TGLSelectRecord& rec, Int_t curIdx); Process selection record rec.; 'curIdx' is the item position where the scene should start; its processing.; Return TRUE if an object has been identified or FALSE otherwise.; The scene-info member of the record is already set by the caller. void CalcBoundingBox() const; Encapsulates all physical shapes bounding box with axes aligned box.; Validity checked in the base-class. void AdoptLogical(TGLLogicalShape& shape); Adopt dynamically created logical 'shape' - add to internal map; and take responsibility for deleting. Bool_t DestroyLogical(TObject* logid, Bool_t mustFind = kTRUE); Destroy logical shape defined by unique 'ID'.; Returns kTRUE if found/destroyed - kFALSE otherwise. If mustFind is true, an error is reported if the logical is not; found. Int_t ",MatchSource.WIKI,root/html528/TGLScene.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLScene.html
https://root.cern/root/html528/TGLScene.html:6294,Security,access,access,6294,"Int_t phid, Double_t* trans, UChar_t* col); virtual voidUpdatePhysical(UInt_t phid, Double_t* trans, Color_t cidx = -1, UChar_t transp = 0); virtual voidUpdatePhysioLogical(TObject* logid, Double_t* trans, UChar_t* col); virtual voidUpdatePhysioLogical(TObject* logid, Double_t* trans, Color_t cidx, UChar_t transp); virtual voidUpdateSceneInfo(TGLRnrCtx& rnrCtx). protected:. virtual voidDestroyPhysicalInternal(TGLScene::PhysicalShapeMapIt_t pit); voidReleaseGLCtxIdentity(). private:. TGLScene(const TGLScene&); static Bool_tComparePhysicalDiagonals(const TGLPhysicalShape* shape1, const TGLPhysicalShape* shape2); static Bool_tComparePhysicalVolumes(const TGLPhysicalShape* shape1, const TGLPhysicalShape* shape2); TGLScene&operator=(const TGLScene&). Data Members; public:. enum TGLLockable::ELock { kUnlocked; kDrawLock; kSelectLock; kModifyLock; };. protected:. Bool_tTGLSceneBase::fAutoDestruct; TGLBoundingBoxTGLSceneBase::fBoundingBoxbounding box for scene (axis aligned) - lazy update - use BoundingBox() to access; Bool_tTGLSceneBase::fBoundingBoxValidbounding box valid?; TGLClip*TGLSceneBase::fClipScene clipping-plane.; Bool_tTGLSceneBase::fDoClipCheckPerform global clip-plane-check in UpdateSceneInfo(); Bool_tTGLSceneBase::fDoFrustumCheckPerform global frustum-check in UpdateSceneInfo(); TGLContextIdentity*fGLCtxIdentity; Bool_tfInSmartRefresh!; Short_tTGLSceneBase::fLODScene-lod.; Float_tfLastLineWidthScale; Float_tfLastPointSizeScale; TGLLockable::ELockTGLLockable::fLockLock state.; map<TObject*,TGLLogicalShape*>fLogicalShapes!; UInt_tTGLSceneBase::fMinorStampCounter increased on minimal update.; TStringTGLSceneBase::fNameObject identifier.; Float_tTGLSceneBase::fOLLineWScene outline line-width.; map<unsigned int,TGLPhysicalShape*>fPhysicalShapes!; UInt_tTGLSceneBase::fSceneIDUnique scene id.; Bool_tTGLSceneBase::fSelectableObjects in the scene are selectable.; map<TObject*,TGLLogicalShape*>fSmartRefreshCache!; Short_tTGLSceneBase::fStyleScene-style.; UInt_tTGLSceneB",MatchSource.WIKI,root/html528/TGLScene.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLScene.html
https://root.cern/root/html528/TGLScene.html:381,Testability,log,logical,381,". TGLScene. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLScene. class TGLScene: public TGLSceneBase. TGLScene provides managememnt and rendering of ROOT's default 3D; object representation as logical and physical shapes. A GL scene is the container for all the viewable objects (shapes); loaded into the viewer. It consists of two main stl::maps containing; the TGLLogicalShape and TGLPhysicalShape collections, and interface; functions enabling viewers to manage objects in these. The physical; shapes defined the placement of copies of the logical shapes - see; TGLLogicalShape/TGLPhysicalShape for more information on relationship. The scene can be drawn by owning viewer, passing camera, draw style; & quality (LOD), clipping etc - see Draw(). The scene can also be; drawn for selection in similar fashion - see Select(). The scene; keeps track of a single selected physical - which can be modified by; viewers. The scene maintains a lazy calculated bounding box for the total; scene extents, axis aligned round TGLPhysicalShape shapes. Currently a scene is owned exclusively by one viewer - however it is; intended that it could easily be shared by multiple viewers - for; efficiency and syncronisation reasons. Hence viewer variant objects; camera, clips etc being owned by viewer and passed at draw/select. Function Members (Methods); public:. TGLScene(); virtual~TGLScene(); voidTGLSceneBase::AddViewer(TGLViewerBase* viewer); virtual voidAdoptLogical(TGLLogicalShape& shape); virtual voidAdoptPhysical(TGLPhysicalShape& shape); UInt_tBeginSmartRefresh(); virtual Bool_tBeginUpdate(); const TGLBoundingBox&TGLSceneBase::BoundingBox() const; virtual voidCalcBoundingBox() const; static TClass*Class(); TGLClip*TGLSceneBase::Clip() const; virtual TGLScene::TSceneInfo*CreateSceneInfo(TGLViewerBase* view); ",MatchSource.WIKI,root/html528/TGLScene.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLScene.html
https://root.cern/root/html528/TGLScene.html:731,Testability,log,logical,731,". TGLScene. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLScene. class TGLScene: public TGLSceneBase. TGLScene provides managememnt and rendering of ROOT's default 3D; object representation as logical and physical shapes. A GL scene is the container for all the viewable objects (shapes); loaded into the viewer. It consists of two main stl::maps containing; the TGLLogicalShape and TGLPhysicalShape collections, and interface; functions enabling viewers to manage objects in these. The physical; shapes defined the placement of copies of the logical shapes - see; TGLLogicalShape/TGLPhysicalShape for more information on relationship. The scene can be drawn by owning viewer, passing camera, draw style; & quality (LOD), clipping etc - see Draw(). The scene can also be; drawn for selection in similar fashion - see Select(). The scene; keeps track of a single selected physical - which can be modified by; viewers. The scene maintains a lazy calculated bounding box for the total; scene extents, axis aligned round TGLPhysicalShape shapes. Currently a scene is owned exclusively by one viewer - however it is; intended that it could easily be shared by multiple viewers - for; efficiency and syncronisation reasons. Hence viewer variant objects; camera, clips etc being owned by viewer and passed at draw/select. Function Members (Methods); public:. TGLScene(); virtual~TGLScene(); voidTGLSceneBase::AddViewer(TGLViewerBase* viewer); virtual voidAdoptLogical(TGLLogicalShape& shape); virtual voidAdoptPhysical(TGLPhysicalShape& shape); UInt_tBeginSmartRefresh(); virtual Bool_tBeginUpdate(); const TGLBoundingBox&TGLSceneBase::BoundingBox() const; virtual voidCalcBoundingBox() const; static TClass*Class(); TGLClip*TGLSceneBase::Clip() const; virtual TGLScene::TSceneInfo*CreateSceneInfo(TGLViewerBase* view); ",MatchSource.WIKI,root/html528/TGLScene.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLScene.html
https://root.cern/root/html528/TGLScene.html:2091,Testability,log,logid,2091, TGLScene(); virtual~TGLScene(); voidTGLSceneBase::AddViewer(TGLViewerBase* viewer); virtual voidAdoptLogical(TGLLogicalShape& shape); virtual voidAdoptPhysical(TGLPhysicalShape& shape); UInt_tBeginSmartRefresh(); virtual Bool_tBeginUpdate(); const TGLBoundingBox&TGLSceneBase::BoundingBox() const; virtual voidCalcBoundingBox() const; static TClass*Class(); TGLClip*TGLSceneBase::Clip() const; virtual TGLScene::TSceneInfo*CreateSceneInfo(TGLViewerBase* view); ,MatchSource.WIKI,root/html528/TGLScene.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLScene.html
https://root.cern/root/html528/TGLScene.html:2437,Testability,log,logid,2437, TGLScene(); virtual~TGLScene(); voidTGLSceneBase::AddViewer(TGLViewerBase* viewer); virtual voidAdoptLogical(TGLLogicalShape& shape); virtual voidAdoptPhysical(TGLPhysicalShape& shape); UInt_tBeginSmartRefresh(); virtual Bool_tBeginUpdate(); const TGLBoundingBox&TGLSceneBase::BoundingBox() const; virtual voidCalcBoundingBox() const; static TClass*Class(); TGLClip*TGLSceneBase::Clip() const; virtual TGLScene::TSceneInfo*CreateSceneInfo(TGLViewerBase* view); ,MatchSource.WIKI,root/html528/TGLScene.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLScene.html
https://root.cern/root/html528/TGLScene.html:5239,Testability,log,logid,5239,"TGLSceneBase::PreRender(TGLRnrCtx& rnrCtx); virtual voidRebuildSceneInfo(TGLRnrCtx& rnrCtx); TGLScene::LogicalShapeMap_t&RefLogicalShapes(); Bool_tTGLLockable::ReleaseLock(TGLLockable::ELock lock) const; voidTGLSceneBase::RemoveViewer(TGLViewerBase* viewer); virtual voidTGLSceneBase::Render(TGLRnrCtx& rnrCtx); virtual voidRenderAllPasses(TGLRnrCtx& rnrCtx, TGLScene::DrawElementPtrVec_t& elVec, Bool_t check_timeout); virtual voidRenderElements(TGLRnrCtx& rnrCtx, TGLScene::DrawElementPtrVec_t& elVec, Bool_t check_timeout, const TGLPlaneSet_t* clipPlanes = 0); virtual voidRenderOpaque(TGLRnrCtx& rnrCtx); virtual voidRenderSelOpaque(TGLRnrCtx& rnrCtx); virtual voidRenderSelTransp(TGLRnrCtx& rnrCtx); virtual voidRenderTransp(TGLRnrCtx& rnrCtx); virtual Bool_tResolveSelectRecord(TGLSelectRecord& rec, Int_t curIdx); static voidRGBAFromColorIdx(Float_t* rgba, Color_t ci, Char_t transp = 0); voidTGLSceneBase::SetAutoDestruct(Bool_t a); voidTGLSceneBase::SetClip(TGLClip* p); voidTGLSceneBase::SetLOD(Short_t lod); virtual voidTGLSceneBase::SetName(const char* name); virtual voidTGLSceneBase::SetNameTitle(const char* name, const char* title); voidTGLSceneBase::SetSelectable(Bool_t a); voidTGLSceneBase::SetStyle(Short_t st); virtual voidTGLSceneBase::SetTitle(const char* title); virtual voidShowMembers(TMemberInspector& insp); UInt_tSizeOfScene() const; virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); Short_tTGLSceneBase::Style() const; voidTGLSceneBase::TagViewersChanged(); Bool_tTGLLockable::TakeLock(TGLLockable::ELock lock) const; virtual voidUpdateLogical(TObject* logid); virtual voidUpdatePhysical(UInt_t phid, Double_t* trans, UChar_t* col); virtual voidUpdatePhysical(UInt_t phid, Double_t* trans, Color_t cidx = -1, UChar_t transp = 0); virtual voidUpdatePhysioLogical(TObject* logid, Double_t* trans, UChar_t* col); virtual voidUpdatePhysioLogical(TObject* logid, Double_t* trans, Color_t cidx, UChar_t transp); virtual voidUpdateSceneInfo(TGLRnrCtx& rnrCtx).",MatchSource.WIKI,root/html528/TGLScene.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLScene.html
https://root.cern/root/html528/TGLScene.html:5457,Testability,log,logid,5457,"TGLSceneBase::PreRender(TGLRnrCtx& rnrCtx); virtual voidRebuildSceneInfo(TGLRnrCtx& rnrCtx); TGLScene::LogicalShapeMap_t&RefLogicalShapes(); Bool_tTGLLockable::ReleaseLock(TGLLockable::ELock lock) const; voidTGLSceneBase::RemoveViewer(TGLViewerBase* viewer); virtual voidTGLSceneBase::Render(TGLRnrCtx& rnrCtx); virtual voidRenderAllPasses(TGLRnrCtx& rnrCtx, TGLScene::DrawElementPtrVec_t& elVec, Bool_t check_timeout); virtual voidRenderElements(TGLRnrCtx& rnrCtx, TGLScene::DrawElementPtrVec_t& elVec, Bool_t check_timeout, const TGLPlaneSet_t* clipPlanes = 0); virtual voidRenderOpaque(TGLRnrCtx& rnrCtx); virtual voidRenderSelOpaque(TGLRnrCtx& rnrCtx); virtual voidRenderSelTransp(TGLRnrCtx& rnrCtx); virtual voidRenderTransp(TGLRnrCtx& rnrCtx); virtual Bool_tResolveSelectRecord(TGLSelectRecord& rec, Int_t curIdx); static voidRGBAFromColorIdx(Float_t* rgba, Color_t ci, Char_t transp = 0); voidTGLSceneBase::SetAutoDestruct(Bool_t a); voidTGLSceneBase::SetClip(TGLClip* p); voidTGLSceneBase::SetLOD(Short_t lod); virtual voidTGLSceneBase::SetName(const char* name); virtual voidTGLSceneBase::SetNameTitle(const char* name, const char* title); voidTGLSceneBase::SetSelectable(Bool_t a); voidTGLSceneBase::SetStyle(Short_t st); virtual voidTGLSceneBase::SetTitle(const char* title); virtual voidShowMembers(TMemberInspector& insp); UInt_tSizeOfScene() const; virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); Short_tTGLSceneBase::Style() const; voidTGLSceneBase::TagViewersChanged(); Bool_tTGLLockable::TakeLock(TGLLockable::ELock lock) const; virtual voidUpdateLogical(TObject* logid); virtual voidUpdatePhysical(UInt_t phid, Double_t* trans, UChar_t* col); virtual voidUpdatePhysical(UInt_t phid, Double_t* trans, Color_t cidx = -1, UChar_t transp = 0); virtual voidUpdatePhysioLogical(TObject* logid, Double_t* trans, UChar_t* col); virtual voidUpdatePhysioLogical(TObject* logid, Double_t* trans, Color_t cidx, UChar_t transp); virtual voidUpdateSceneInfo(TGLRnrCtx& rnrCtx).",MatchSource.WIKI,root/html528/TGLScene.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLScene.html
https://root.cern/root/html528/TGLScene.html:5537,Testability,log,logid,5537,"TGLSceneBase::PreRender(TGLRnrCtx& rnrCtx); virtual voidRebuildSceneInfo(TGLRnrCtx& rnrCtx); TGLScene::LogicalShapeMap_t&RefLogicalShapes(); Bool_tTGLLockable::ReleaseLock(TGLLockable::ELock lock) const; voidTGLSceneBase::RemoveViewer(TGLViewerBase* viewer); virtual voidTGLSceneBase::Render(TGLRnrCtx& rnrCtx); virtual voidRenderAllPasses(TGLRnrCtx& rnrCtx, TGLScene::DrawElementPtrVec_t& elVec, Bool_t check_timeout); virtual voidRenderElements(TGLRnrCtx& rnrCtx, TGLScene::DrawElementPtrVec_t& elVec, Bool_t check_timeout, const TGLPlaneSet_t* clipPlanes = 0); virtual voidRenderOpaque(TGLRnrCtx& rnrCtx); virtual voidRenderSelOpaque(TGLRnrCtx& rnrCtx); virtual voidRenderSelTransp(TGLRnrCtx& rnrCtx); virtual voidRenderTransp(TGLRnrCtx& rnrCtx); virtual Bool_tResolveSelectRecord(TGLSelectRecord& rec, Int_t curIdx); static voidRGBAFromColorIdx(Float_t* rgba, Color_t ci, Char_t transp = 0); voidTGLSceneBase::SetAutoDestruct(Bool_t a); voidTGLSceneBase::SetClip(TGLClip* p); voidTGLSceneBase::SetLOD(Short_t lod); virtual voidTGLSceneBase::SetName(const char* name); virtual voidTGLSceneBase::SetNameTitle(const char* name, const char* title); voidTGLSceneBase::SetSelectable(Bool_t a); voidTGLSceneBase::SetStyle(Short_t st); virtual voidTGLSceneBase::SetTitle(const char* title); virtual voidShowMembers(TMemberInspector& insp); UInt_tSizeOfScene() const; virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); Short_tTGLSceneBase::Style() const; voidTGLSceneBase::TagViewersChanged(); Bool_tTGLLockable::TakeLock(TGLLockable::ELock lock) const; virtual voidUpdateLogical(TObject* logid); virtual voidUpdatePhysical(UInt_t phid, Double_t* trans, UChar_t* col); virtual voidUpdatePhysical(UInt_t phid, Double_t* trans, Color_t cidx = -1, UChar_t transp = 0); virtual voidUpdatePhysioLogical(TObject* logid, Double_t* trans, UChar_t* col); virtual voidUpdatePhysioLogical(TObject* logid, Double_t* trans, Color_t cidx, UChar_t transp); virtual voidUpdateSceneInfo(TGLRnrCtx& rnrCtx).",MatchSource.WIKI,root/html528/TGLScene.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLScene.html
https://root.cern/root/html528/TGLScene.html:7727,Testability,log,logical,7727,"ointSizeScale; TGLLockable::ELockTGLLockable::fLockLock state.; map<TObject*,TGLLogicalShape*>fLogicalShapes!; UInt_tTGLSceneBase::fMinorStampCounter increased on minimal update.; TStringTGLSceneBase::fNameObject identifier.; Float_tTGLSceneBase::fOLLineWScene outline line-width.; map<unsigned int,TGLPhysicalShape*>fPhysicalShapes!; UInt_tTGLSceneBase::fSceneIDUnique scene id.; Bool_tTGLSceneBase::fSelectableObjects in the scene are selectable.; map<TObject*,TGLLogicalShape*>fSmartRefreshCache!; Short_tTGLSceneBase::fStyleScene-style.; UInt_tTGLSceneBase::fTimeStampCounter increased on every update.; TStringTGLSceneBase::fTitleObject title.; list<TGLViewerBase*>TGLSceneBase::fViewers; Float_tTGLSceneBase::fWFLineWScene wire-frame line-width. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLScene(); {}. ~TGLScene(); Destroy scene objects. void ReleaseGLCtxIdentity(); Release all GL resources for current context identity.; Requires iteration over all logical shapes. Bool_t ComparePhysicalVolumes(const TGLPhysicalShape* shape1, const TGLPhysicalShape* shape2); Compare 'shape1' and 'shape2' bounding box volumes - return kTRUE if; 'shape1' bigger than 'shape2'. Bool_t ComparePhysicalDiagonals(const TGLPhysicalShape* shape1, const TGLPhysicalShape* shape2); Compare 'shape1' and 'shape2' bounding box volumes - return kTRUE if; 'shape1' bigger than 'shape2'. void RebuildSceneInfo(TGLRnrCtx& rnrCtx); Major change in scene, need to rebuild all-element draw-vector and; sort it. Sort the TGLPhysical draw list by shape bounding box diagonal, from; large to small. This makes dropout of shapes with time limited; Draw() calls must less noticable. As this does not use projected; size it only needs to be done after a scene content change - not; everytime scene drawn (potential camera/projection change). void UpdateSceneInfo(TGLRnrCtx& rnrCtx); Fill scene-info with information needed for rendering, take into; account the render-context (view",MatchSource.WIKI,root/html528/TGLScene.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLScene.html
https://root.cern/root/html528/TGLScene.html:9233,Testability,log,logicals,9233,"scene, need to rebuild all-element draw-vector and; sort it. Sort the TGLPhysical draw list by shape bounding box diagonal, from; large to small. This makes dropout of shapes with time limited; Draw() calls must less noticable. As this does not use projected; size it only needs to be done after a scene content change - not; everytime scene drawn (potential camera/projection change). void UpdateSceneInfo(TGLRnrCtx& rnrCtx); Fill scene-info with information needed for rendering, take into; account the render-context (viewer state, camera, clipping).; Here we have to iterate over all the physical shapes and select; the visible ones. While at it, opaque and transparent shapes are; divided into two groups. void LodifySceneInfo(TGLRnrCtx& rnrCtx); Setup LOD-dependant values in scene-info.; We have to perform LOD quantization for all draw-elements. void PreDraw(TGLRnrCtx& rnrCtx); Initialize rendering.; Pass to base-class where most work is done.; Check if GL-ctx is shared with the previous one; if not; wipe display-lists of all logicals. void RenderOpaque(TGLRnrCtx& rnrCtx); Render opaque elements. void RenderTransp(TGLRnrCtx& rnrCtx); Render transparent elements. void RenderSelOpaque(TGLRnrCtx& rnrCtx); Render selected opaque elements. void RenderSelTransp(TGLRnrCtx& rnrCtx); Render selected transparent elements. void PostDraw(TGLRnrCtx& rnrCtx); Called after the rendering is finished.; In debug mode draw statistcs is dumped.; Parent's PostDraw is called for GL cleanup. void RenderAllPasses(TGLRnrCtx& rnrCtx, TGLScene::DrawElementPtrVec_t& elVec, Bool_t check_timeout); Do full rendering of scene. First draw the opaques, then the transparents. For each we do; the number of passes required by draw mode and clipping setup. void RenderElements(TGLRnrCtx& rnrCtx, TGLScene::DrawElementPtrVec_t& elVec, Bool_t check_timeout, const TGLPlaneSet_t* clipPlanes = 0); Render DrawElements in elementVec with given timeout.; If clipPlanes is non-zero, test each element against its; clipp",MatchSource.WIKI,root/html528/TGLScene.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLScene.html
https://root.cern/root/html528/TGLScene.html:10159,Testability,test,test,10159," shared with the previous one; if not; wipe display-lists of all logicals. void RenderOpaque(TGLRnrCtx& rnrCtx); Render opaque elements. void RenderTransp(TGLRnrCtx& rnrCtx); Render transparent elements. void RenderSelOpaque(TGLRnrCtx& rnrCtx); Render selected opaque elements. void RenderSelTransp(TGLRnrCtx& rnrCtx); Render selected transparent elements. void PostDraw(TGLRnrCtx& rnrCtx); Called after the rendering is finished.; In debug mode draw statistcs is dumped.; Parent's PostDraw is called for GL cleanup. void RenderAllPasses(TGLRnrCtx& rnrCtx, TGLScene::DrawElementPtrVec_t& elVec, Bool_t check_timeout); Do full rendering of scene. First draw the opaques, then the transparents. For each we do; the number of passes required by draw mode and clipping setup. void RenderElements(TGLRnrCtx& rnrCtx, TGLScene::DrawElementPtrVec_t& elVec, Bool_t check_timeout, const TGLPlaneSet_t* clipPlanes = 0); Render DrawElements in elementVec with given timeout.; If clipPlanes is non-zero, test each element against its; clipping planes. Bool_t ResolveSelectRecord(TGLSelectRecord& rec, Int_t curIdx); Process selection record rec.; 'curIdx' is the item position where the scene should start; its processing.; Return TRUE if an object has been identified or FALSE otherwise.; The scene-info member of the record is already set by the caller. void CalcBoundingBox() const; Encapsulates all physical shapes bounding box with axes aligned box.; Validity checked in the base-class. void AdoptLogical(TGLLogicalShape& shape); Adopt dynamically created logical 'shape' - add to internal map; and take responsibility for deleting. Bool_t DestroyLogical(TObject* logid, Bool_t mustFind = kTRUE); Destroy logical shape defined by unique 'ID'.; Returns kTRUE if found/destroyed - kFALSE otherwise. If mustFind is true, an error is reported if the logical is not; found. Int_t DestroyLogicals(); Destroy all logical shapes in scene.; Return number of destroyed logicals. TGLLogicalShape * FindLogical(TObject* ",MatchSource.WIKI,root/html528/TGLScene.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLScene.html
https://root.cern/root/html528/TGLScene.html:10716,Testability,log,logical,10716,"rCtx, TGLScene::DrawElementPtrVec_t& elVec, Bool_t check_timeout); Do full rendering of scene. First draw the opaques, then the transparents. For each we do; the number of passes required by draw mode and clipping setup. void RenderElements(TGLRnrCtx& rnrCtx, TGLScene::DrawElementPtrVec_t& elVec, Bool_t check_timeout, const TGLPlaneSet_t* clipPlanes = 0); Render DrawElements in elementVec with given timeout.; If clipPlanes is non-zero, test each element against its; clipping planes. Bool_t ResolveSelectRecord(TGLSelectRecord& rec, Int_t curIdx); Process selection record rec.; 'curIdx' is the item position where the scene should start; its processing.; Return TRUE if an object has been identified or FALSE otherwise.; The scene-info member of the record is already set by the caller. void CalcBoundingBox() const; Encapsulates all physical shapes bounding box with axes aligned box.; Validity checked in the base-class. void AdoptLogical(TGLLogicalShape& shape); Adopt dynamically created logical 'shape' - add to internal map; and take responsibility for deleting. Bool_t DestroyLogical(TObject* logid, Bool_t mustFind = kTRUE); Destroy logical shape defined by unique 'ID'.; Returns kTRUE if found/destroyed - kFALSE otherwise. If mustFind is true, an error is reported if the logical is not; found. Int_t DestroyLogicals(); Destroy all logical shapes in scene.; Return number of destroyed logicals. TGLLogicalShape * FindLogical(TObject* logid) const; Find and return logical shape identified by unqiue logid.; Returns 0 if not found. void AdoptPhysical(TGLPhysicalShape& shape); Adopt dynamically created physical 'shape' - add to internal map and take; responsibility for deleting. void DestroyPhysicalInternal(TGLScene::PhysicalShapeMapIt_t pit); Virtual function to destroy a physical. Sub-classes might have; special checks to perform.; Caller should also invalidate the draw-list. Bool_t DestroyPhysical(UInt_t phid); Destroy physical shape defined by unique 'ID'.; Returns kTRUE if ",MatchSource.WIKI,root/html528/TGLScene.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLScene.html
https://root.cern/root/html528/TGLScene.html:10824,Testability,log,logid,10824,"transparents. For each we do; the number of passes required by draw mode and clipping setup. void RenderElements(TGLRnrCtx& rnrCtx, TGLScene::DrawElementPtrVec_t& elVec, Bool_t check_timeout, const TGLPlaneSet_t* clipPlanes = 0); Render DrawElements in elementVec with given timeout.; If clipPlanes is non-zero, test each element against its; clipping planes. Bool_t ResolveSelectRecord(TGLSelectRecord& rec, Int_t curIdx); Process selection record rec.; 'curIdx' is the item position where the scene should start; its processing.; Return TRUE if an object has been identified or FALSE otherwise.; The scene-info member of the record is already set by the caller. void CalcBoundingBox() const; Encapsulates all physical shapes bounding box with axes aligned box.; Validity checked in the base-class. void AdoptLogical(TGLLogicalShape& shape); Adopt dynamically created logical 'shape' - add to internal map; and take responsibility for deleting. Bool_t DestroyLogical(TObject* logid, Bool_t mustFind = kTRUE); Destroy logical shape defined by unique 'ID'.; Returns kTRUE if found/destroyed - kFALSE otherwise. If mustFind is true, an error is reported if the logical is not; found. Int_t DestroyLogicals(); Destroy all logical shapes in scene.; Return number of destroyed logicals. TGLLogicalShape * FindLogical(TObject* logid) const; Find and return logical shape identified by unqiue logid.; Returns 0 if not found. void AdoptPhysical(TGLPhysicalShape& shape); Adopt dynamically created physical 'shape' - add to internal map and take; responsibility for deleting. void DestroyPhysicalInternal(TGLScene::PhysicalShapeMapIt_t pit); Virtual function to destroy a physical. Sub-classes might have; special checks to perform.; Caller should also invalidate the draw-list. Bool_t DestroyPhysical(UInt_t phid); Destroy physical shape defined by unique 'ID'.; Returns kTRUE if found/destroyed - kFALSE otherwise. Int_t DestroyPhysicals(); Destroy physical shapes. TGLPhysicalShape* FindPhysical(UInt_t phi",MatchSource.WIKI,root/html528/TGLScene.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLScene.html
https://root.cern/root/html528/TGLScene.html:10865,Testability,log,logical,10865,"transparents. For each we do; the number of passes required by draw mode and clipping setup. void RenderElements(TGLRnrCtx& rnrCtx, TGLScene::DrawElementPtrVec_t& elVec, Bool_t check_timeout, const TGLPlaneSet_t* clipPlanes = 0); Render DrawElements in elementVec with given timeout.; If clipPlanes is non-zero, test each element against its; clipping planes. Bool_t ResolveSelectRecord(TGLSelectRecord& rec, Int_t curIdx); Process selection record rec.; 'curIdx' is the item position where the scene should start; its processing.; Return TRUE if an object has been identified or FALSE otherwise.; The scene-info member of the record is already set by the caller. void CalcBoundingBox() const; Encapsulates all physical shapes bounding box with axes aligned box.; Validity checked in the base-class. void AdoptLogical(TGLLogicalShape& shape); Adopt dynamically created logical 'shape' - add to internal map; and take responsibility for deleting. Bool_t DestroyLogical(TObject* logid, Bool_t mustFind = kTRUE); Destroy logical shape defined by unique 'ID'.; Returns kTRUE if found/destroyed - kFALSE otherwise. If mustFind is true, an error is reported if the logical is not; found. Int_t DestroyLogicals(); Destroy all logical shapes in scene.; Return number of destroyed logicals. TGLLogicalShape * FindLogical(TObject* logid) const; Find and return logical shape identified by unqiue logid.; Returns 0 if not found. void AdoptPhysical(TGLPhysicalShape& shape); Adopt dynamically created physical 'shape' - add to internal map and take; responsibility for deleting. void DestroyPhysicalInternal(TGLScene::PhysicalShapeMapIt_t pit); Virtual function to destroy a physical. Sub-classes might have; special checks to perform.; Caller should also invalidate the draw-list. Bool_t DestroyPhysical(UInt_t phid); Destroy physical shape defined by unique 'ID'.; Returns kTRUE if found/destroyed - kFALSE otherwise. Int_t DestroyPhysicals(); Destroy physical shapes. TGLPhysicalShape* FindPhysical(UInt_t phi",MatchSource.WIKI,root/html528/TGLScene.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLScene.html
https://root.cern/root/html528/TGLScene.html:11006,Testability,log,logical,11006,"wElementPtrVec_t& elVec, Bool_t check_timeout, const TGLPlaneSet_t* clipPlanes = 0); Render DrawElements in elementVec with given timeout.; If clipPlanes is non-zero, test each element against its; clipping planes. Bool_t ResolveSelectRecord(TGLSelectRecord& rec, Int_t curIdx); Process selection record rec.; 'curIdx' is the item position where the scene should start; its processing.; Return TRUE if an object has been identified or FALSE otherwise.; The scene-info member of the record is already set by the caller. void CalcBoundingBox() const; Encapsulates all physical shapes bounding box with axes aligned box.; Validity checked in the base-class. void AdoptLogical(TGLLogicalShape& shape); Adopt dynamically created logical 'shape' - add to internal map; and take responsibility for deleting. Bool_t DestroyLogical(TObject* logid, Bool_t mustFind = kTRUE); Destroy logical shape defined by unique 'ID'.; Returns kTRUE if found/destroyed - kFALSE otherwise. If mustFind is true, an error is reported if the logical is not; found. Int_t DestroyLogicals(); Destroy all logical shapes in scene.; Return number of destroyed logicals. TGLLogicalShape * FindLogical(TObject* logid) const; Find and return logical shape identified by unqiue logid.; Returns 0 if not found. void AdoptPhysical(TGLPhysicalShape& shape); Adopt dynamically created physical 'shape' - add to internal map and take; responsibility for deleting. void DestroyPhysicalInternal(TGLScene::PhysicalShapeMapIt_t pit); Virtual function to destroy a physical. Sub-classes might have; special checks to perform.; Caller should also invalidate the draw-list. Bool_t DestroyPhysical(UInt_t phid); Destroy physical shape defined by unique 'ID'.; Returns kTRUE if found/destroyed - kFALSE otherwise. Int_t DestroyPhysicals(); Destroy physical shapes. TGLPhysicalShape* FindPhysical(UInt_t phid) const; Find and return physical shape identified by unqiue 'ID'.; Returns 0 if not found. UInt_t GetMaxPhysicalID(); Returns the maximum used ",MatchSource.WIKI,root/html528/TGLScene.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLScene.html
https://root.cern/root/html528/TGLScene.html:11066,Testability,log,logical,11066," clipPlanes = 0); Render DrawElements in elementVec with given timeout.; If clipPlanes is non-zero, test each element against its; clipping planes. Bool_t ResolveSelectRecord(TGLSelectRecord& rec, Int_t curIdx); Process selection record rec.; 'curIdx' is the item position where the scene should start; its processing.; Return TRUE if an object has been identified or FALSE otherwise.; The scene-info member of the record is already set by the caller. void CalcBoundingBox() const; Encapsulates all physical shapes bounding box with axes aligned box.; Validity checked in the base-class. void AdoptLogical(TGLLogicalShape& shape); Adopt dynamically created logical 'shape' - add to internal map; and take responsibility for deleting. Bool_t DestroyLogical(TObject* logid, Bool_t mustFind = kTRUE); Destroy logical shape defined by unique 'ID'.; Returns kTRUE if found/destroyed - kFALSE otherwise. If mustFind is true, an error is reported if the logical is not; found. Int_t DestroyLogicals(); Destroy all logical shapes in scene.; Return number of destroyed logicals. TGLLogicalShape * FindLogical(TObject* logid) const; Find and return logical shape identified by unqiue logid.; Returns 0 if not found. void AdoptPhysical(TGLPhysicalShape& shape); Adopt dynamically created physical 'shape' - add to internal map and take; responsibility for deleting. void DestroyPhysicalInternal(TGLScene::PhysicalShapeMapIt_t pit); Virtual function to destroy a physical. Sub-classes might have; special checks to perform.; Caller should also invalidate the draw-list. Bool_t DestroyPhysical(UInt_t phid); Destroy physical shape defined by unique 'ID'.; Returns kTRUE if found/destroyed - kFALSE otherwise. Int_t DestroyPhysicals(); Destroy physical shapes. TGLPhysicalShape* FindPhysical(UInt_t phid) const; Find and return physical shape identified by unqiue 'ID'.; Returns 0 if not found. UInt_t GetMaxPhysicalID(); Returns the maximum used physical id.; Returns 0 if empty. Bool_t BeginUpdate(); Put scene i",MatchSource.WIKI,root/html528/TGLScene.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLScene.html
https://root.cern/root/html528/TGLScene.html:11119,Testability,log,logicals,11119,"c with given timeout.; If clipPlanes is non-zero, test each element against its; clipping planes. Bool_t ResolveSelectRecord(TGLSelectRecord& rec, Int_t curIdx); Process selection record rec.; 'curIdx' is the item position where the scene should start; its processing.; Return TRUE if an object has been identified or FALSE otherwise.; The scene-info member of the record is already set by the caller. void CalcBoundingBox() const; Encapsulates all physical shapes bounding box with axes aligned box.; Validity checked in the base-class. void AdoptLogical(TGLLogicalShape& shape); Adopt dynamically created logical 'shape' - add to internal map; and take responsibility for deleting. Bool_t DestroyLogical(TObject* logid, Bool_t mustFind = kTRUE); Destroy logical shape defined by unique 'ID'.; Returns kTRUE if found/destroyed - kFALSE otherwise. If mustFind is true, an error is reported if the logical is not; found. Int_t DestroyLogicals(); Destroy all logical shapes in scene.; Return number of destroyed logicals. TGLLogicalShape * FindLogical(TObject* logid) const; Find and return logical shape identified by unqiue logid.; Returns 0 if not found. void AdoptPhysical(TGLPhysicalShape& shape); Adopt dynamically created physical 'shape' - add to internal map and take; responsibility for deleting. void DestroyPhysicalInternal(TGLScene::PhysicalShapeMapIt_t pit); Virtual function to destroy a physical. Sub-classes might have; special checks to perform.; Caller should also invalidate the draw-list. Bool_t DestroyPhysical(UInt_t phid); Destroy physical shape defined by unique 'ID'.; Returns kTRUE if found/destroyed - kFALSE otherwise. Int_t DestroyPhysicals(); Destroy physical shapes. TGLPhysicalShape* FindPhysical(UInt_t phid) const; Find and return physical shape identified by unqiue 'ID'.; Returns 0 if not found. UInt_t GetMaxPhysicalID(); Returns the maximum used physical id.; Returns 0 if empty. Bool_t BeginUpdate(); Put scene in update mode, return true if lock acquired. void ",MatchSource.WIKI,root/html528/TGLScene.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLScene.html
https://root.cern/root/html528/TGLScene.html:11168,Testability,log,logid,11168,"t its; clipping planes. Bool_t ResolveSelectRecord(TGLSelectRecord& rec, Int_t curIdx); Process selection record rec.; 'curIdx' is the item position where the scene should start; its processing.; Return TRUE if an object has been identified or FALSE otherwise.; The scene-info member of the record is already set by the caller. void CalcBoundingBox() const; Encapsulates all physical shapes bounding box with axes aligned box.; Validity checked in the base-class. void AdoptLogical(TGLLogicalShape& shape); Adopt dynamically created logical 'shape' - add to internal map; and take responsibility for deleting. Bool_t DestroyLogical(TObject* logid, Bool_t mustFind = kTRUE); Destroy logical shape defined by unique 'ID'.; Returns kTRUE if found/destroyed - kFALSE otherwise. If mustFind is true, an error is reported if the logical is not; found. Int_t DestroyLogicals(); Destroy all logical shapes in scene.; Return number of destroyed logicals. TGLLogicalShape * FindLogical(TObject* logid) const; Find and return logical shape identified by unqiue logid.; Returns 0 if not found. void AdoptPhysical(TGLPhysicalShape& shape); Adopt dynamically created physical 'shape' - add to internal map and take; responsibility for deleting. void DestroyPhysicalInternal(TGLScene::PhysicalShapeMapIt_t pit); Virtual function to destroy a physical. Sub-classes might have; special checks to perform.; Caller should also invalidate the draw-list. Bool_t DestroyPhysical(UInt_t phid); Destroy physical shape defined by unique 'ID'.; Returns kTRUE if found/destroyed - kFALSE otherwise. Int_t DestroyPhysicals(); Destroy physical shapes. TGLPhysicalShape* FindPhysical(UInt_t phid) const; Find and return physical shape identified by unqiue 'ID'.; Returns 0 if not found. UInt_t GetMaxPhysicalID(); Returns the maximum used physical id.; Returns 0 if empty. Bool_t BeginUpdate(); Put scene in update mode, return true if lock acquired. void EndUpdate(Bool_t minorChange = kTRUE, Bool_t sceneChanged = kTRUE, Bool_t u",MatchSource.WIKI,root/html528/TGLScene.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLScene.html
https://root.cern/root/html528/TGLScene.html:11198,Testability,log,logical,11198,"t its; clipping planes. Bool_t ResolveSelectRecord(TGLSelectRecord& rec, Int_t curIdx); Process selection record rec.; 'curIdx' is the item position where the scene should start; its processing.; Return TRUE if an object has been identified or FALSE otherwise.; The scene-info member of the record is already set by the caller. void CalcBoundingBox() const; Encapsulates all physical shapes bounding box with axes aligned box.; Validity checked in the base-class. void AdoptLogical(TGLLogicalShape& shape); Adopt dynamically created logical 'shape' - add to internal map; and take responsibility for deleting. Bool_t DestroyLogical(TObject* logid, Bool_t mustFind = kTRUE); Destroy logical shape defined by unique 'ID'.; Returns kTRUE if found/destroyed - kFALSE otherwise. If mustFind is true, an error is reported if the logical is not; found. Int_t DestroyLogicals(); Destroy all logical shapes in scene.; Return number of destroyed logicals. TGLLogicalShape * FindLogical(TObject* logid) const; Find and return logical shape identified by unqiue logid.; Returns 0 if not found. void AdoptPhysical(TGLPhysicalShape& shape); Adopt dynamically created physical 'shape' - add to internal map and take; responsibility for deleting. void DestroyPhysicalInternal(TGLScene::PhysicalShapeMapIt_t pit); Virtual function to destroy a physical. Sub-classes might have; special checks to perform.; Caller should also invalidate the draw-list. Bool_t DestroyPhysical(UInt_t phid); Destroy physical shape defined by unique 'ID'.; Returns kTRUE if found/destroyed - kFALSE otherwise. Int_t DestroyPhysicals(); Destroy physical shapes. TGLPhysicalShape* FindPhysical(UInt_t phid) const; Find and return physical shape identified by unqiue 'ID'.; Returns 0 if not found. UInt_t GetMaxPhysicalID(); Returns the maximum used physical id.; Returns 0 if empty. Bool_t BeginUpdate(); Put scene in update mode, return true if lock acquired. void EndUpdate(Bool_t minorChange = kTRUE, Bool_t sceneChanged = kTRUE, Bool_t u",MatchSource.WIKI,root/html528/TGLScene.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLScene.html
https://root.cern/root/html528/TGLScene.html:11233,Testability,log,logid,11233,"t its; clipping planes. Bool_t ResolveSelectRecord(TGLSelectRecord& rec, Int_t curIdx); Process selection record rec.; 'curIdx' is the item position where the scene should start; its processing.; Return TRUE if an object has been identified or FALSE otherwise.; The scene-info member of the record is already set by the caller. void CalcBoundingBox() const; Encapsulates all physical shapes bounding box with axes aligned box.; Validity checked in the base-class. void AdoptLogical(TGLLogicalShape& shape); Adopt dynamically created logical 'shape' - add to internal map; and take responsibility for deleting. Bool_t DestroyLogical(TObject* logid, Bool_t mustFind = kTRUE); Destroy logical shape defined by unique 'ID'.; Returns kTRUE if found/destroyed - kFALSE otherwise. If mustFind is true, an error is reported if the logical is not; found. Int_t DestroyLogicals(); Destroy all logical shapes in scene.; Return number of destroyed logicals. TGLLogicalShape * FindLogical(TObject* logid) const; Find and return logical shape identified by unqiue logid.; Returns 0 if not found. void AdoptPhysical(TGLPhysicalShape& shape); Adopt dynamically created physical 'shape' - add to internal map and take; responsibility for deleting. void DestroyPhysicalInternal(TGLScene::PhysicalShapeMapIt_t pit); Virtual function to destroy a physical. Sub-classes might have; special checks to perform.; Caller should also invalidate the draw-list. Bool_t DestroyPhysical(UInt_t phid); Destroy physical shape defined by unique 'ID'.; Returns kTRUE if found/destroyed - kFALSE otherwise. Int_t DestroyPhysicals(); Destroy physical shapes. TGLPhysicalShape* FindPhysical(UInt_t phid) const; Find and return physical shape identified by unqiue 'ID'.; Returns 0 if not found. UInt_t GetMaxPhysicalID(); Returns the maximum used physical id.; Returns 0 if empty. Bool_t BeginUpdate(); Put scene in update mode, return true if lock acquired. void EndUpdate(Bool_t minorChange = kTRUE, Bool_t sceneChanged = kTRUE, Bool_t u",MatchSource.WIKI,root/html528/TGLScene.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLScene.html
https://root.cern/root/html528/TGLScene.html:12772,Testability,log,logid,12772," shapes. TGLPhysicalShape* FindPhysical(UInt_t phid) const; Find and return physical shape identified by unqiue 'ID'.; Returns 0 if not found. UInt_t GetMaxPhysicalID(); Returns the maximum used physical id.; Returns 0 if empty. Bool_t BeginUpdate(); Put scene in update mode, return true if lock acquired. void EndUpdate(Bool_t minorChange = kTRUE, Bool_t sceneChanged = kTRUE, Bool_t updateViewers = kTRUE); Exit scene update mode. If sceneChanged is true (default), the scene timestamp is; increased and basic draw-lists etc will be rebuild on next draw; request. If you only changed colors or some other visual; parameters that do not affect object bounding-box or; transformation matrix, you can set it to false. If updateViewers is true (default), the viewers using this scene; will be tagged as changed. If sceneChanged is true the; updateViewers should be true as well, unless you take care of; the viewers elsewhere or in some other way. void UpdateLogical(TObject* logid); Drop display-lists for the logical (assume TGLObject/direct rendering).; Re-calculate the bounding box (also for all physicals). void UpdatePhysical(UInt_t phid, Double_t* trans, UChar_t* col); Reposition/recolor physical shape. void UpdatePhysical(UInt_t phid, Double_t* trans, Color_t cidx = -1, UChar_t transp = 0); Reposition/recolor physical shape. void UpdatePhysioLogical(TObject* logid, Double_t* trans, UChar_t* col); Reposition/recolor physical for given logical (assume TGLObject and; a single physical). void UpdatePhysioLogical(TObject* logid, Double_t* trans, Color_t cidx, UChar_t transp); Reposition/recolor physical for given logical (assume TGLObject and; a single physical). UInt_t BeginSmartRefresh(); Moves logicals that support smart-refresh to intermediate cache.; Destroys the others and returns the number of destroyed ones. void EndSmartRefresh(); Wipes logicals in refresh-cache. TGLLogicalShape * FindLogicalSmartRefresh(TObject* ID) const; Find and return logical shape identified by unqi",MatchSource.WIKI,root/html528/TGLScene.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLScene.html
https://root.cern/root/html528/TGLScene.html:12807,Testability,log,logical,12807," shapes. TGLPhysicalShape* FindPhysical(UInt_t phid) const; Find and return physical shape identified by unqiue 'ID'.; Returns 0 if not found. UInt_t GetMaxPhysicalID(); Returns the maximum used physical id.; Returns 0 if empty. Bool_t BeginUpdate(); Put scene in update mode, return true if lock acquired. void EndUpdate(Bool_t minorChange = kTRUE, Bool_t sceneChanged = kTRUE, Bool_t updateViewers = kTRUE); Exit scene update mode. If sceneChanged is true (default), the scene timestamp is; increased and basic draw-lists etc will be rebuild on next draw; request. If you only changed colors or some other visual; parameters that do not affect object bounding-box or; transformation matrix, you can set it to false. If updateViewers is true (default), the viewers using this scene; will be tagged as changed. If sceneChanged is true the; updateViewers should be true as well, unless you take care of; the viewers elsewhere or in some other way. void UpdateLogical(TObject* logid); Drop display-lists for the logical (assume TGLObject/direct rendering).; Re-calculate the bounding box (also for all physicals). void UpdatePhysical(UInt_t phid, Double_t* trans, UChar_t* col); Reposition/recolor physical shape. void UpdatePhysical(UInt_t phid, Double_t* trans, Color_t cidx = -1, UChar_t transp = 0); Reposition/recolor physical shape. void UpdatePhysioLogical(TObject* logid, Double_t* trans, UChar_t* col); Reposition/recolor physical for given logical (assume TGLObject and; a single physical). void UpdatePhysioLogical(TObject* logid, Double_t* trans, Color_t cidx, UChar_t transp); Reposition/recolor physical for given logical (assume TGLObject and; a single physical). UInt_t BeginSmartRefresh(); Moves logicals that support smart-refresh to intermediate cache.; Destroys the others and returns the number of destroyed ones. void EndSmartRefresh(); Wipes logicals in refresh-cache. TGLLogicalShape * FindLogicalSmartRefresh(TObject* ID) const; Find and return logical shape identified by unqi",MatchSource.WIKI,root/html528/TGLScene.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLScene.html
https://root.cern/root/html528/TGLScene.html:13168,Testability,log,logid,13168,"ene update mode. If sceneChanged is true (default), the scene timestamp is; increased and basic draw-lists etc will be rebuild on next draw; request. If you only changed colors or some other visual; parameters that do not affect object bounding-box or; transformation matrix, you can set it to false. If updateViewers is true (default), the viewers using this scene; will be tagged as changed. If sceneChanged is true the; updateViewers should be true as well, unless you take care of; the viewers elsewhere or in some other way. void UpdateLogical(TObject* logid); Drop display-lists for the logical (assume TGLObject/direct rendering).; Re-calculate the bounding box (also for all physicals). void UpdatePhysical(UInt_t phid, Double_t* trans, UChar_t* col); Reposition/recolor physical shape. void UpdatePhysical(UInt_t phid, Double_t* trans, Color_t cidx = -1, UChar_t transp = 0); Reposition/recolor physical shape. void UpdatePhysioLogical(TObject* logid, Double_t* trans, UChar_t* col); Reposition/recolor physical for given logical (assume TGLObject and; a single physical). void UpdatePhysioLogical(TObject* logid, Double_t* trans, Color_t cidx, UChar_t transp); Reposition/recolor physical for given logical (assume TGLObject and; a single physical). UInt_t BeginSmartRefresh(); Moves logicals that support smart-refresh to intermediate cache.; Destroys the others and returns the number of destroyed ones. void EndSmartRefresh(); Wipes logicals in refresh-cache. TGLLogicalShape * FindLogicalSmartRefresh(TObject* ID) const; Find and return logical shape identified by unqiue 'ID' in refresh-cache.; Returns 0 if not found. UInt_t SizeOfScene() const; Return memory cost of scene.; Warning: NOT CORRECT at present - doesn't correctly calculate size.; of logical shapes with dynamic internal contents. void DumpMapSizes() const; Print sizes of logical nad physical-shape maps. void RGBAFromColorIdx(Float_t* rgba, Color_t ci, Char_t transp = 0); Fill rgba color from ROOT color-index ci and ",MatchSource.WIKI,root/html528/TGLScene.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLScene.html
https://root.cern/root/html528/TGLScene.html:13245,Testability,log,logical,13245,"ene update mode. If sceneChanged is true (default), the scene timestamp is; increased and basic draw-lists etc will be rebuild on next draw; request. If you only changed colors or some other visual; parameters that do not affect object bounding-box or; transformation matrix, you can set it to false. If updateViewers is true (default), the viewers using this scene; will be tagged as changed. If sceneChanged is true the; updateViewers should be true as well, unless you take care of; the viewers elsewhere or in some other way. void UpdateLogical(TObject* logid); Drop display-lists for the logical (assume TGLObject/direct rendering).; Re-calculate the bounding box (also for all physicals). void UpdatePhysical(UInt_t phid, Double_t* trans, UChar_t* col); Reposition/recolor physical shape. void UpdatePhysical(UInt_t phid, Double_t* trans, Color_t cidx = -1, UChar_t transp = 0); Reposition/recolor physical shape. void UpdatePhysioLogical(TObject* logid, Double_t* trans, UChar_t* col); Reposition/recolor physical for given logical (assume TGLObject and; a single physical). void UpdatePhysioLogical(TObject* logid, Double_t* trans, Color_t cidx, UChar_t transp); Reposition/recolor physical for given logical (assume TGLObject and; a single physical). UInt_t BeginSmartRefresh(); Moves logicals that support smart-refresh to intermediate cache.; Destroys the others and returns the number of destroyed ones. void EndSmartRefresh(); Wipes logicals in refresh-cache. TGLLogicalShape * FindLogicalSmartRefresh(TObject* ID) const; Find and return logical shape identified by unqiue 'ID' in refresh-cache.; Returns 0 if not found. UInt_t SizeOfScene() const; Return memory cost of scene.; Warning: NOT CORRECT at present - doesn't correctly calculate size.; of logical shapes with dynamic internal contents. void DumpMapSizes() const; Print sizes of logical nad physical-shape maps. void RGBAFromColorIdx(Float_t* rgba, Color_t ci, Char_t transp = 0); Fill rgba color from ROOT color-index ci and ",MatchSource.WIKI,root/html528/TGLScene.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLScene.html
https://root.cern/root/html528/TGLScene.html:13330,Testability,log,logid,13330,"colors or some other visual; parameters that do not affect object bounding-box or; transformation matrix, you can set it to false. If updateViewers is true (default), the viewers using this scene; will be tagged as changed. If sceneChanged is true the; updateViewers should be true as well, unless you take care of; the viewers elsewhere or in some other way. void UpdateLogical(TObject* logid); Drop display-lists for the logical (assume TGLObject/direct rendering).; Re-calculate the bounding box (also for all physicals). void UpdatePhysical(UInt_t phid, Double_t* trans, UChar_t* col); Reposition/recolor physical shape. void UpdatePhysical(UInt_t phid, Double_t* trans, Color_t cidx = -1, UChar_t transp = 0); Reposition/recolor physical shape. void UpdatePhysioLogical(TObject* logid, Double_t* trans, UChar_t* col); Reposition/recolor physical for given logical (assume TGLObject and; a single physical). void UpdatePhysioLogical(TObject* logid, Double_t* trans, Color_t cidx, UChar_t transp); Reposition/recolor physical for given logical (assume TGLObject and; a single physical). UInt_t BeginSmartRefresh(); Moves logicals that support smart-refresh to intermediate cache.; Destroys the others and returns the number of destroyed ones. void EndSmartRefresh(); Wipes logicals in refresh-cache. TGLLogicalShape * FindLogicalSmartRefresh(TObject* ID) const; Find and return logical shape identified by unqiue 'ID' in refresh-cache.; Returns 0 if not found. UInt_t SizeOfScene() const; Return memory cost of scene.; Warning: NOT CORRECT at present - doesn't correctly calculate size.; of logical shapes with dynamic internal contents. void DumpMapSizes() const; Print sizes of logical nad physical-shape maps. void RGBAFromColorIdx(Float_t* rgba, Color_t ci, Char_t transp = 0); Fill rgba color from ROOT color-index ci and transparency (0->100). Bool_t IsOutside(const TGLBoundingBox& box, const TGLPlaneSet_t& planes); Check if box is outside of all planes. TGLScene(const TGLScene& ). TGLSce",MatchSource.WIKI,root/html528/TGLScene.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLScene.html
https://root.cern/root/html528/TGLScene.html:13423,Testability,log,logical,13423,"colors or some other visual; parameters that do not affect object bounding-box or; transformation matrix, you can set it to false. If updateViewers is true (default), the viewers using this scene; will be tagged as changed. If sceneChanged is true the; updateViewers should be true as well, unless you take care of; the viewers elsewhere or in some other way. void UpdateLogical(TObject* logid); Drop display-lists for the logical (assume TGLObject/direct rendering).; Re-calculate the bounding box (also for all physicals). void UpdatePhysical(UInt_t phid, Double_t* trans, UChar_t* col); Reposition/recolor physical shape. void UpdatePhysical(UInt_t phid, Double_t* trans, Color_t cidx = -1, UChar_t transp = 0); Reposition/recolor physical shape. void UpdatePhysioLogical(TObject* logid, Double_t* trans, UChar_t* col); Reposition/recolor physical for given logical (assume TGLObject and; a single physical). void UpdatePhysioLogical(TObject* logid, Double_t* trans, Color_t cidx, UChar_t transp); Reposition/recolor physical for given logical (assume TGLObject and; a single physical). UInt_t BeginSmartRefresh(); Moves logicals that support smart-refresh to intermediate cache.; Destroys the others and returns the number of destroyed ones. void EndSmartRefresh(); Wipes logicals in refresh-cache. TGLLogicalShape * FindLogicalSmartRefresh(TObject* ID) const; Find and return logical shape identified by unqiue 'ID' in refresh-cache.; Returns 0 if not found. UInt_t SizeOfScene() const; Return memory cost of scene.; Warning: NOT CORRECT at present - doesn't correctly calculate size.; of logical shapes with dynamic internal contents. void DumpMapSizes() const; Print sizes of logical nad physical-shape maps. void RGBAFromColorIdx(Float_t* rgba, Color_t ci, Char_t transp = 0); Fill rgba color from ROOT color-index ci and transparency (0->100). Bool_t IsOutside(const TGLBoundingBox& box, const TGLPlaneSet_t& planes); Check if box is outside of all planes. TGLScene(const TGLScene& ). TGLSce",MatchSource.WIKI,root/html528/TGLScene.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLScene.html
https://root.cern/root/html528/TGLScene.html:13508,Testability,log,logicals,13508,"pdateViewers is true (default), the viewers using this scene; will be tagged as changed. If sceneChanged is true the; updateViewers should be true as well, unless you take care of; the viewers elsewhere or in some other way. void UpdateLogical(TObject* logid); Drop display-lists for the logical (assume TGLObject/direct rendering).; Re-calculate the bounding box (also for all physicals). void UpdatePhysical(UInt_t phid, Double_t* trans, UChar_t* col); Reposition/recolor physical shape. void UpdatePhysical(UInt_t phid, Double_t* trans, Color_t cidx = -1, UChar_t transp = 0); Reposition/recolor physical shape. void UpdatePhysioLogical(TObject* logid, Double_t* trans, UChar_t* col); Reposition/recolor physical for given logical (assume TGLObject and; a single physical). void UpdatePhysioLogical(TObject* logid, Double_t* trans, Color_t cidx, UChar_t transp); Reposition/recolor physical for given logical (assume TGLObject and; a single physical). UInt_t BeginSmartRefresh(); Moves logicals that support smart-refresh to intermediate cache.; Destroys the others and returns the number of destroyed ones. void EndSmartRefresh(); Wipes logicals in refresh-cache. TGLLogicalShape * FindLogicalSmartRefresh(TObject* ID) const; Find and return logical shape identified by unqiue 'ID' in refresh-cache.; Returns 0 if not found. UInt_t SizeOfScene() const; Return memory cost of scene.; Warning: NOT CORRECT at present - doesn't correctly calculate size.; of logical shapes with dynamic internal contents. void DumpMapSizes() const; Print sizes of logical nad physical-shape maps. void RGBAFromColorIdx(Float_t* rgba, Color_t ci, Char_t transp = 0); Fill rgba color from ROOT color-index ci and transparency (0->100). Bool_t IsOutside(const TGLBoundingBox& box, const TGLPlaneSet_t& planes); Check if box is outside of all planes. TGLScene(const TGLScene& ). TGLScene& operator=(const TGLScene& ). TSceneInfo* CreateSceneInfo(TGLViewerBase* view). LogicalShapeMap_t& RefLogicalShapes(); Temporary expo",MatchSource.WIKI,root/html528/TGLScene.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLScene.html
https://root.cern/root/html528/TGLScene.html:13660,Testability,log,logicals,13660," be true as well, unless you take care of; the viewers elsewhere or in some other way. void UpdateLogical(TObject* logid); Drop display-lists for the logical (assume TGLObject/direct rendering).; Re-calculate the bounding box (also for all physicals). void UpdatePhysical(UInt_t phid, Double_t* trans, UChar_t* col); Reposition/recolor physical shape. void UpdatePhysical(UInt_t phid, Double_t* trans, Color_t cidx = -1, UChar_t transp = 0); Reposition/recolor physical shape. void UpdatePhysioLogical(TObject* logid, Double_t* trans, UChar_t* col); Reposition/recolor physical for given logical (assume TGLObject and; a single physical). void UpdatePhysioLogical(TObject* logid, Double_t* trans, Color_t cidx, UChar_t transp); Reposition/recolor physical for given logical (assume TGLObject and; a single physical). UInt_t BeginSmartRefresh(); Moves logicals that support smart-refresh to intermediate cache.; Destroys the others and returns the number of destroyed ones. void EndSmartRefresh(); Wipes logicals in refresh-cache. TGLLogicalShape * FindLogicalSmartRefresh(TObject* ID) const; Find and return logical shape identified by unqiue 'ID' in refresh-cache.; Returns 0 if not found. UInt_t SizeOfScene() const; Return memory cost of scene.; Warning: NOT CORRECT at present - doesn't correctly calculate size.; of logical shapes with dynamic internal contents. void DumpMapSizes() const; Print sizes of logical nad physical-shape maps. void RGBAFromColorIdx(Float_t* rgba, Color_t ci, Char_t transp = 0); Fill rgba color from ROOT color-index ci and transparency (0->100). Bool_t IsOutside(const TGLBoundingBox& box, const TGLPlaneSet_t& planes); Check if box is outside of all planes. TGLScene(const TGLScene& ). TGLScene& operator=(const TGLScene& ). TSceneInfo* CreateSceneInfo(TGLViewerBase* view). LogicalShapeMap_t& RefLogicalShapes(); Temporary export for setting selected-state of physical shapes. { return fLogicalShapes; }. TGLContextIdentity* GetGLCtxIdentity() const. GL-context hol",MatchSource.WIKI,root/html528/TGLScene.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLScene.html
https://root.cern/root/html528/TGLScene.html:13765,Testability,log,logical,13765,"eLogical(TObject* logid); Drop display-lists for the logical (assume TGLObject/direct rendering).; Re-calculate the bounding box (also for all physicals). void UpdatePhysical(UInt_t phid, Double_t* trans, UChar_t* col); Reposition/recolor physical shape. void UpdatePhysical(UInt_t phid, Double_t* trans, Color_t cidx = -1, UChar_t transp = 0); Reposition/recolor physical shape. void UpdatePhysioLogical(TObject* logid, Double_t* trans, UChar_t* col); Reposition/recolor physical for given logical (assume TGLObject and; a single physical). void UpdatePhysioLogical(TObject* logid, Double_t* trans, Color_t cidx, UChar_t transp); Reposition/recolor physical for given logical (assume TGLObject and; a single physical). UInt_t BeginSmartRefresh(); Moves logicals that support smart-refresh to intermediate cache.; Destroys the others and returns the number of destroyed ones. void EndSmartRefresh(); Wipes logicals in refresh-cache. TGLLogicalShape * FindLogicalSmartRefresh(TObject* ID) const; Find and return logical shape identified by unqiue 'ID' in refresh-cache.; Returns 0 if not found. UInt_t SizeOfScene() const; Return memory cost of scene.; Warning: NOT CORRECT at present - doesn't correctly calculate size.; of logical shapes with dynamic internal contents. void DumpMapSizes() const; Print sizes of logical nad physical-shape maps. void RGBAFromColorIdx(Float_t* rgba, Color_t ci, Char_t transp = 0); Fill rgba color from ROOT color-index ci and transparency (0->100). Bool_t IsOutside(const TGLBoundingBox& box, const TGLPlaneSet_t& planes); Check if box is outside of all planes. TGLScene(const TGLScene& ). TGLScene& operator=(const TGLScene& ). TSceneInfo* CreateSceneInfo(TGLViewerBase* view). LogicalShapeMap_t& RefLogicalShapes(); Temporary export for setting selected-state of physical shapes. { return fLogicalShapes; }. TGLContextIdentity* GetGLCtxIdentity() const. GL-context holding display-list definitions. { return fGLCtxIdentity; }. » Author: Matevz Tadel, Feb 2007 » Co",MatchSource.WIKI,root/html528/TGLScene.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLScene.html
https://root.cern/root/html528/TGLScene.html:13978,Testability,log,logical,13978,"cal shape. void UpdatePhysical(UInt_t phid, Double_t* trans, Color_t cidx = -1, UChar_t transp = 0); Reposition/recolor physical shape. void UpdatePhysioLogical(TObject* logid, Double_t* trans, UChar_t* col); Reposition/recolor physical for given logical (assume TGLObject and; a single physical). void UpdatePhysioLogical(TObject* logid, Double_t* trans, Color_t cidx, UChar_t transp); Reposition/recolor physical for given logical (assume TGLObject and; a single physical). UInt_t BeginSmartRefresh(); Moves logicals that support smart-refresh to intermediate cache.; Destroys the others and returns the number of destroyed ones. void EndSmartRefresh(); Wipes logicals in refresh-cache. TGLLogicalShape * FindLogicalSmartRefresh(TObject* ID) const; Find and return logical shape identified by unqiue 'ID' in refresh-cache.; Returns 0 if not found. UInt_t SizeOfScene() const; Return memory cost of scene.; Warning: NOT CORRECT at present - doesn't correctly calculate size.; of logical shapes with dynamic internal contents. void DumpMapSizes() const; Print sizes of logical nad physical-shape maps. void RGBAFromColorIdx(Float_t* rgba, Color_t ci, Char_t transp = 0); Fill rgba color from ROOT color-index ci and transparency (0->100). Bool_t IsOutside(const TGLBoundingBox& box, const TGLPlaneSet_t& planes); Check if box is outside of all planes. TGLScene(const TGLScene& ). TGLScene& operator=(const TGLScene& ). TSceneInfo* CreateSceneInfo(TGLViewerBase* view). LogicalShapeMap_t& RefLogicalShapes(); Temporary export for setting selected-state of physical shapes. { return fLogicalShapes; }. TGLContextIdentity* GetGLCtxIdentity() const. GL-context holding display-list definitions. { return fGLCtxIdentity; }. » Author: Matevz Tadel, Feb 2007 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/gl:$Id: TGLScene.h 32334 2010-02-12 11:52:13Z matevz $ » Last generated: 2010-12-08 16:56; This page has been automatically generated. For comments or suggestions rega",MatchSource.WIKI,root/html528/TGLScene.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLScene.html
https://root.cern/root/html528/TGLScene.html:14067,Testability,log,logical,14067,"lor_t cidx = -1, UChar_t transp = 0); Reposition/recolor physical shape. void UpdatePhysioLogical(TObject* logid, Double_t* trans, UChar_t* col); Reposition/recolor physical for given logical (assume TGLObject and; a single physical). void UpdatePhysioLogical(TObject* logid, Double_t* trans, Color_t cidx, UChar_t transp); Reposition/recolor physical for given logical (assume TGLObject and; a single physical). UInt_t BeginSmartRefresh(); Moves logicals that support smart-refresh to intermediate cache.; Destroys the others and returns the number of destroyed ones. void EndSmartRefresh(); Wipes logicals in refresh-cache. TGLLogicalShape * FindLogicalSmartRefresh(TObject* ID) const; Find and return logical shape identified by unqiue 'ID' in refresh-cache.; Returns 0 if not found. UInt_t SizeOfScene() const; Return memory cost of scene.; Warning: NOT CORRECT at present - doesn't correctly calculate size.; of logical shapes with dynamic internal contents. void DumpMapSizes() const; Print sizes of logical nad physical-shape maps. void RGBAFromColorIdx(Float_t* rgba, Color_t ci, Char_t transp = 0); Fill rgba color from ROOT color-index ci and transparency (0->100). Bool_t IsOutside(const TGLBoundingBox& box, const TGLPlaneSet_t& planes); Check if box is outside of all planes. TGLScene(const TGLScene& ). TGLScene& operator=(const TGLScene& ). TSceneInfo* CreateSceneInfo(TGLViewerBase* view). LogicalShapeMap_t& RefLogicalShapes(); Temporary export for setting selected-state of physical shapes. { return fLogicalShapes; }. TGLContextIdentity* GetGLCtxIdentity() const. GL-context holding display-list definitions. { return fGLCtxIdentity; }. » Author: Matevz Tadel, Feb 2007 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/gl:$Id: TGLScene.h 32334 2010-02-12 11:52:13Z matevz $ » Last generated: 2010-12-08 16:56; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail t",MatchSource.WIKI,root/html528/TGLScene.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLScene.html
https://root.cern/root/html528/TGLSceneBase.html:1041,Availability,avail,available,1041,"T Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLSceneBase. class TGLSceneBase: public TGLLockable. Scene base-class -- provides basic interface expected by the; TGLViewer or its sub-classes:; * unique scene id; * scene locking; * overall bounding box; * list of viewers displaying the scene (for update propagation); * virtual interface for draw/select/render (?). The standard ROOT OpenGL scene is implemented in direct sub-class; TGLScene. Note that while each scene can be shared among several viewers, ALL; of them are obliged to share the same display-list space (this can; be achieved on GL-context creation time; Matevz believes that by; default all GL contexts must use shared display-lists etc). Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TGLSceneBase(); voidAddViewer(TGLViewerBase* viewer); const TGLBoundingBox&BoundingBox() const; virtual voidCalcBoundingBox() const; static TClass*Class(); TGLClip*Clip() const; virtual TGLSceneInfo*CreateSceneInfo(TGLViewerBase* view); TGLLockable::ELockTGLLockable::CurrentLock() const; virtual TGLLogicalShape*FindLogical(TObject*) const; Bool_tGetAutoDestruct() const; UInt_tGetMinorStamp() const; virtual const char*GetName() const; Bool_tGetSelectable() const; UInt_tGetTimeStamp() const; virtual const char*GetTitle() const; voidIncMinorStamp(); voidIncTimeStamp(); voidInvalidateBoundingBox(); virtual TClass*IsA() const; Bool_tTGLLockable::IsDrawOrSelectLock() const; Bool_tTGLLockable::IsLocked() const; virtual const char*LockIdStr() const; static const char*TGLLockable::LockName(TGLLockable::ELock lock); static Bool_tTGLLockable::LockValid(TGLLockable::ELock lock); Short_tLOD() const; virtual voidLodifySceneInfo(TGLRnrCtx& ctx); virtua",MatchSource.WIKI,root/html528/TGLSceneBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLSceneBase.html
https://root.cern/root/html528/TGLSceneBase.html:498,Deployability,update,update,498,". TGLSceneBase. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLSceneBase. class TGLSceneBase: public TGLLockable. Scene base-class -- provides basic interface expected by the; TGLViewer or its sub-classes:; * unique scene id; * scene locking; * overall bounding box; * list of viewers displaying the scene (for update propagation); * virtual interface for draw/select/render (?). The standard ROOT OpenGL scene is implemented in direct sub-class; TGLScene. Note that while each scene can be shared among several viewers, ALL; of them are obliged to share the same display-list space (this can; be achieved on GL-context creation time; Matevz believes that by; default all GL contexts must use shared display-lists etc). Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TGLSceneBase(); voidAddViewer(TGLViewerBase* viewer); const TGLBoundingBox&BoundingBox() const; virtual voidCalcBoundingBox() const; static TClass*Class(); TGLClip*Clip() const; virtual TGLSceneInfo*CreateSceneInfo(TGLViewerBase* view); TGLLockable::ELockTGLLockable::CurrentLock() const; virtual TGLLogicalShape*FindLogical(TObject*) const; Bool_tGetAutoDestruct() const; UInt_tGetMinorStamp() const; virtual const char*GetName() const; Bool_tGetSelectable() const; UInt_tGetTimeStamp() const; virtual const char*GetTitle() const; voidIncMinorStamp(); voidIncTimeStamp(); voidInvalidateBoundingBox(); virtual TClass*IsA() const; Bool_tTGLLockable::IsDrawOrSelectLock() const; Bool_tTGLLockable::IsLocked() const; virtual const char*LockIdStr() const; static const char*TGLLockable::LockName(TGLLockable::ELock lock); static Bool_tTGLLockable::LockValid(TGLLockable::ELock lock); Short_tLOD() const; virtual voidLodify",MatchSource.WIKI,root/html528/TGLSceneBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLSceneBase.html
https://root.cern/root/html528/TGLSceneBase.html:3448,Deployability,update,update,3448,"RnrCtx& rnrCtx); virtual voidRenderSelTransp(TGLRnrCtx& rnrCtx); virtual voidRenderTransp(TGLRnrCtx& rnrCtx); virtual Bool_tResolveSelectRecord(TGLSelectRecord& rec, Int_t curIdx); voidSetAutoDestruct(Bool_t a); voidSetClip(TGLClip* p); voidSetLOD(Short_t lod); virtual voidSetName(const char* name); virtual voidSetNameTitle(const char* name, const char* title); voidSetSelectable(Bool_t a); voidSetStyle(Short_t st); virtual voidSetTitle(const char* title); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); Short_tStyle() const; voidTagViewersChanged(); Bool_tTGLLockable::TakeLock(TGLLockable::ELock lock) const; virtual voidUpdateSceneInfo(TGLRnrCtx& ctx). private:. TGLSceneBase&operator=(const TGLSceneBase&). Data Members; public:. enum TGLLockable::ELock { kUnlocked; kDrawLock; kSelectLock; kModifyLock; };. protected:. Bool_tfAutoDestruct; TGLBoundingBoxfBoundingBoxbounding box for scene (axis aligned) - lazy update - use BoundingBox() to access; Bool_tfBoundingBoxValidbounding box valid?; TGLClip*fClipScene clipping-plane.; Bool_tfDoClipCheckPerform global clip-plane-check in UpdateSceneInfo(); Bool_tfDoFrustumCheckPerform global frustum-check in UpdateSceneInfo(); Short_tfLODScene-lod.; TGLLockable::ELockTGLLockable::fLockLock state.; UInt_tfMinorStampCounter increased on minimal update.; TStringfNameObject identifier.; Float_tfOLLineWScene outline line-width.; UInt_tfSceneIDUnique scene id.; Bool_tfSelectableObjects in the scene are selectable.; Short_tfStyleScene-style.; UInt_tfTimeStampCounter increased on every update.; TStringfTitleObject title.; list<TGLViewerBase*>fViewers; Float_tfWFLineWScene wire-frame line-width. private:. static UInt_tfgSceneIDSrc. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~TGLSceneBase(); Destructor. void AddViewer(TGLViewerBase* viewer); Add viewer to the list. void RemoveViewer(TGLViewerBase* viewer); Remove viewer from ",MatchSource.WIKI,root/html528/TGLSceneBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLSceneBase.html
https://root.cern/root/html528/TGLSceneBase.html:3828,Deployability,update,update,3828,t char* title); voidSetSelectable(Bool_t a); voidSetStyle(Short_t st); virtual voidSetTitle(const char* title); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); Short_tStyle() const; voidTagViewersChanged(); Bool_tTGLLockable::TakeLock(TGLLockable::ELock lock) const; virtual voidUpdateSceneInfo(TGLRnrCtx& ctx). private:. TGLSceneBase&operator=(const TGLSceneBase&). Data Members; public:. enum TGLLockable::ELock { kUnlocked; kDrawLock; kSelectLock; kModifyLock; };. protected:. Bool_tfAutoDestruct; TGLBoundingBoxfBoundingBoxbounding box for scene (axis aligned) - lazy update - use BoundingBox() to access; Bool_tfBoundingBoxValidbounding box valid?; TGLClip*fClipScene clipping-plane.; Bool_tfDoClipCheckPerform global clip-plane-check in UpdateSceneInfo(); Bool_tfDoFrustumCheckPerform global frustum-check in UpdateSceneInfo(); Short_tfLODScene-lod.; TGLLockable::ELockTGLLockable::fLockLock state.; UInt_tfMinorStampCounter increased on minimal update.; TStringfNameObject identifier.; Float_tfOLLineWScene outline line-width.; UInt_tfSceneIDUnique scene id.; Bool_tfSelectableObjects in the scene are selectable.; Short_tfStyleScene-style.; UInt_tfTimeStampCounter increased on every update.; TStringfTitleObject title.; list<TGLViewerBase*>fViewers; Float_tfWFLineWScene wire-frame line-width. private:. static UInt_tfgSceneIDSrc. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~TGLSceneBase(); Destructor. void AddViewer(TGLViewerBase* viewer); Add viewer to the list. void RemoveViewer(TGLViewerBase* viewer); Remove viewer from the list.; If auto-destruct is on and the last viewer is removed the scene; destructs itself. void TagViewersChanged(); Tag all viewers as changed. const char* LockIdStr() const; Name printed on locking info messages. TGLSceneInfo* CreateSceneInfo(TGLViewerBase* view); Create a scene-info instance appropriate for this scene class.; Here we instan,MatchSource.WIKI,root/html528/TGLSceneBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLSceneBase.html
https://root.cern/root/html528/TGLSceneBase.html:4068,Deployability,update,update,4068,) const; voidTagViewersChanged(); Bool_tTGLLockable::TakeLock(TGLLockable::ELock lock) const; virtual voidUpdateSceneInfo(TGLRnrCtx& ctx). private:. TGLSceneBase&operator=(const TGLSceneBase&). Data Members; public:. enum TGLLockable::ELock { kUnlocked; kDrawLock; kSelectLock; kModifyLock; };. protected:. Bool_tfAutoDestruct; TGLBoundingBoxfBoundingBoxbounding box for scene (axis aligned) - lazy update - use BoundingBox() to access; Bool_tfBoundingBoxValidbounding box valid?; TGLClip*fClipScene clipping-plane.; Bool_tfDoClipCheckPerform global clip-plane-check in UpdateSceneInfo(); Bool_tfDoFrustumCheckPerform global frustum-check in UpdateSceneInfo(); Short_tfLODScene-lod.; TGLLockable::ELockTGLLockable::fLockLock state.; UInt_tfMinorStampCounter increased on minimal update.; TStringfNameObject identifier.; Float_tfOLLineWScene outline line-width.; UInt_tfSceneIDUnique scene id.; Bool_tfSelectableObjects in the scene are selectable.; Short_tfStyleScene-style.; UInt_tfTimeStampCounter increased on every update.; TStringfTitleObject title.; list<TGLViewerBase*>fViewers; Float_tfWFLineWScene wire-frame line-width. private:. static UInt_tfgSceneIDSrc. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~TGLSceneBase(); Destructor. void AddViewer(TGLViewerBase* viewer); Add viewer to the list. void RemoveViewer(TGLViewerBase* viewer); Remove viewer from the list.; If auto-destruct is on and the last viewer is removed the scene; destructs itself. void TagViewersChanged(); Tag all viewers as changed. const char* LockIdStr() const; Name printed on locking info messages. TGLSceneInfo* CreateSceneInfo(TGLViewerBase* view); Create a scene-info instance appropriate for this scene class.; Here we instantiate the scene-info base-class TGLSceneInfo. void RebuildSceneInfo(TGLRnrCtx& ctx); Fill scene-info with very basic information that is practically; view independent. This is called when scene content is changed; or when camera-interest cha,MatchSource.WIKI,root/html528/TGLSceneBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLSceneBase.html
https://root.cern/root/html528/TGLSceneBase.html:5352,Deployability,update,update,5352,"; Remove viewer from the list.; If auto-destruct is on and the last viewer is removed the scene; destructs itself. void TagViewersChanged(); Tag all viewers as changed. const char* LockIdStr() const; Name printed on locking info messages. TGLSceneInfo* CreateSceneInfo(TGLViewerBase* view); Create a scene-info instance appropriate for this scene class.; Here we instantiate the scene-info base-class TGLSceneInfo. void RebuildSceneInfo(TGLRnrCtx& ctx); Fill scene-info with very basic information that is practically; view independent. This is called when scene content is changed; or when camera-interest changes. void UpdateSceneInfo(TGLRnrCtx& ctx); Fill scene-info with information needed for rendering, take into; account the render-context (viewer state, camera, clipping).; Usually called from TGLViewer before rendering a scene if some; moderately significant part of render-context has changed. Here we update the basic state (clear last-LOD, mark the time,; set global <-> scene transforamtion matrices) and potentially; study and refine the clipping planes based on scene bounding box. void LodifySceneInfo(TGLRnrCtx& ctx); Setup LOD-dependant values in scene-info. Nothing to be done here but to store the last LOD. void PreDraw(TGLRnrCtx& rnrCtx); Perform basic pre-render initialization:; - calculate LOD, Style, Clipping,; - build draw lists. This is called in the beginning of the GL-viewer draw cycle. void PreRender(TGLRnrCtx& rnrCtx); Perform pre-render initialization - fill rnrCtx with; values stored during PreDraw(). This is called each time before RenderXyzz(). void Render(TGLRnrCtx& rnrCtx); This function does rendering of all stages, the shapes are; rendered in the following order: opaque, transparent,; selected-opaque, selected-transparent. GL-depth buffer is cleared after transparent shapes have been; rendered. This is never called from ROOT GL directly. Use it if you know; you are rendering a single scene. void RenderOpaque(TGLRnrCtx& rnrCtx); Render opaque eleme",MatchSource.WIKI,root/html528/TGLSceneBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLSceneBase.html
https://root.cern/root/html528/TGLSceneBase.html:336,Integrability,interface,interface,336,". TGLSceneBase. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLSceneBase. class TGLSceneBase: public TGLLockable. Scene base-class -- provides basic interface expected by the; TGLViewer or its sub-classes:; * unique scene id; * scene locking; * overall bounding box; * list of viewers displaying the scene (for update propagation); * virtual interface for draw/select/render (?). The standard ROOT OpenGL scene is implemented in direct sub-class; TGLScene. Note that while each scene can be shared among several viewers, ALL; of them are obliged to share the same display-list space (this can; be achieved on GL-context creation time; Matevz believes that by; default all GL contexts must use shared display-lists etc). Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TGLSceneBase(); voidAddViewer(TGLViewerBase* viewer); const TGLBoundingBox&BoundingBox() const; virtual voidCalcBoundingBox() const; static TClass*Class(); TGLClip*Clip() const; virtual TGLSceneInfo*CreateSceneInfo(TGLViewerBase* view); TGLLockable::ELockTGLLockable::CurrentLock() const; virtual TGLLogicalShape*FindLogical(TObject*) const; Bool_tGetAutoDestruct() const; UInt_tGetMinorStamp() const; virtual const char*GetName() const; Bool_tGetSelectable() const; UInt_tGetTimeStamp() const; virtual const char*GetTitle() const; voidIncMinorStamp(); voidIncTimeStamp(); voidInvalidateBoundingBox(); virtual TClass*IsA() const; Bool_tTGLLockable::IsDrawOrSelectLock() const; Bool_tTGLLockable::IsLocked() const; virtual const char*LockIdStr() const; static const char*TGLLockable::LockName(TGLLockable::ELock lock); static Bool_tTGLLockable::LockValid(TGLLockable::ELock lock); Short_tLOD() const; virtual voidLodify",MatchSource.WIKI,root/html528/TGLSceneBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLSceneBase.html
https://root.cern/root/html528/TGLSceneBase.html:529,Integrability,interface,interface,529,". TGLSceneBase. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLSceneBase. class TGLSceneBase: public TGLLockable. Scene base-class -- provides basic interface expected by the; TGLViewer or its sub-classes:; * unique scene id; * scene locking; * overall bounding box; * list of viewers displaying the scene (for update propagation); * virtual interface for draw/select/render (?). The standard ROOT OpenGL scene is implemented in direct sub-class; TGLScene. Note that while each scene can be shared among several viewers, ALL; of them are obliged to share the same display-list space (this can; be achieved on GL-context creation time; Matevz believes that by; default all GL contexts must use shared display-lists etc). Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TGLSceneBase(); voidAddViewer(TGLViewerBase* viewer); const TGLBoundingBox&BoundingBox() const; virtual voidCalcBoundingBox() const; static TClass*Class(); TGLClip*Clip() const; virtual TGLSceneInfo*CreateSceneInfo(TGLViewerBase* view); TGLLockable::ELockTGLLockable::CurrentLock() const; virtual TGLLogicalShape*FindLogical(TObject*) const; Bool_tGetAutoDestruct() const; UInt_tGetMinorStamp() const; virtual const char*GetName() const; Bool_tGetSelectable() const; UInt_tGetTimeStamp() const; virtual const char*GetTitle() const; voidIncMinorStamp(); voidIncTimeStamp(); voidInvalidateBoundingBox(); virtual TClass*IsA() const; Bool_tTGLLockable::IsDrawOrSelectLock() const; Bool_tTGLLockable::IsLocked() const; virtual const char*LockIdStr() const; static const char*TGLLockable::LockName(TGLLockable::ELock lock); static Bool_tTGLLockable::LockValid(TGLLockable::ELock lock); Short_tLOD() const; virtual voidLodify",MatchSource.WIKI,root/html528/TGLSceneBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLSceneBase.html
https://root.cern/root/html528/TGLSceneBase.html:4668,Integrability,message,messages,4668,"_tfDoFrustumCheckPerform global frustum-check in UpdateSceneInfo(); Short_tfLODScene-lod.; TGLLockable::ELockTGLLockable::fLockLock state.; UInt_tfMinorStampCounter increased on minimal update.; TStringfNameObject identifier.; Float_tfOLLineWScene outline line-width.; UInt_tfSceneIDUnique scene id.; Bool_tfSelectableObjects in the scene are selectable.; Short_tfStyleScene-style.; UInt_tfTimeStampCounter increased on every update.; TStringfTitleObject title.; list<TGLViewerBase*>fViewers; Float_tfWFLineWScene wire-frame line-width. private:. static UInt_tfgSceneIDSrc. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~TGLSceneBase(); Destructor. void AddViewer(TGLViewerBase* viewer); Add viewer to the list. void RemoveViewer(TGLViewerBase* viewer); Remove viewer from the list.; If auto-destruct is on and the last viewer is removed the scene; destructs itself. void TagViewersChanged(); Tag all viewers as changed. const char* LockIdStr() const; Name printed on locking info messages. TGLSceneInfo* CreateSceneInfo(TGLViewerBase* view); Create a scene-info instance appropriate for this scene class.; Here we instantiate the scene-info base-class TGLSceneInfo. void RebuildSceneInfo(TGLRnrCtx& ctx); Fill scene-info with very basic information that is practically; view independent. This is called when scene content is changed; or when camera-interest changes. void UpdateSceneInfo(TGLRnrCtx& ctx); Fill scene-info with information needed for rendering, take into; account the render-context (viewer state, camera, clipping).; Usually called from TGLViewer before rendering a scene if some; moderately significant part of render-context has changed. Here we update the basic state (clear last-LOD, mark the time,; set global <-> scene transforamtion matrices) and potentially; study and refine the clipping planes based on scene bounding box. void LodifySceneInfo(TGLRnrCtx& ctx); Setup LOD-dependant values in scene-info. Nothing to be done here b",MatchSource.WIKI,root/html528/TGLSceneBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLSceneBase.html
https://root.cern/root/html528/TGLSceneBase.html:5585,Integrability,depend,dependant,5585,"(); Tag all viewers as changed. const char* LockIdStr() const; Name printed on locking info messages. TGLSceneInfo* CreateSceneInfo(TGLViewerBase* view); Create a scene-info instance appropriate for this scene class.; Here we instantiate the scene-info base-class TGLSceneInfo. void RebuildSceneInfo(TGLRnrCtx& ctx); Fill scene-info with very basic information that is practically; view independent. This is called when scene content is changed; or when camera-interest changes. void UpdateSceneInfo(TGLRnrCtx& ctx); Fill scene-info with information needed for rendering, take into; account the render-context (viewer state, camera, clipping).; Usually called from TGLViewer before rendering a scene if some; moderately significant part of render-context has changed. Here we update the basic state (clear last-LOD, mark the time,; set global <-> scene transforamtion matrices) and potentially; study and refine the clipping planes based on scene bounding box. void LodifySceneInfo(TGLRnrCtx& ctx); Setup LOD-dependant values in scene-info. Nothing to be done here but to store the last LOD. void PreDraw(TGLRnrCtx& rnrCtx); Perform basic pre-render initialization:; - calculate LOD, Style, Clipping,; - build draw lists. This is called in the beginning of the GL-viewer draw cycle. void PreRender(TGLRnrCtx& rnrCtx); Perform pre-render initialization - fill rnrCtx with; values stored during PreDraw(). This is called each time before RenderXyzz(). void Render(TGLRnrCtx& rnrCtx); This function does rendering of all stages, the shapes are; rendered in the following order: opaque, transparent,; selected-opaque, selected-transparent. GL-depth buffer is cleared after transparent shapes have been; rendered. This is never called from ROOT GL directly. Use it if you know; you are rendering a single scene. void RenderOpaque(TGLRnrCtx& rnrCtx); Render opaque elements. void RenderTransp(TGLRnrCtx& rnrCtx); Render transparent elements. void RenderSelOpaque(TGLRnrCtx& rnrCtx); Render selected opaque ",MatchSource.WIKI,root/html528/TGLSceneBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLSceneBase.html
https://root.cern/root/html528/TGLSceneBase.html:3478,Security,access,access,3478,"RnrCtx& rnrCtx); virtual voidRenderSelTransp(TGLRnrCtx& rnrCtx); virtual voidRenderTransp(TGLRnrCtx& rnrCtx); virtual Bool_tResolveSelectRecord(TGLSelectRecord& rec, Int_t curIdx); voidSetAutoDestruct(Bool_t a); voidSetClip(TGLClip* p); voidSetLOD(Short_t lod); virtual voidSetName(const char* name); virtual voidSetNameTitle(const char* name, const char* title); voidSetSelectable(Bool_t a); voidSetStyle(Short_t st); virtual voidSetTitle(const char* title); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); Short_tStyle() const; voidTagViewersChanged(); Bool_tTGLLockable::TakeLock(TGLLockable::ELock lock) const; virtual voidUpdateSceneInfo(TGLRnrCtx& ctx). private:. TGLSceneBase&operator=(const TGLSceneBase&). Data Members; public:. enum TGLLockable::ELock { kUnlocked; kDrawLock; kSelectLock; kModifyLock; };. protected:. Bool_tfAutoDestruct; TGLBoundingBoxfBoundingBoxbounding box for scene (axis aligned) - lazy update - use BoundingBox() to access; Bool_tfBoundingBoxValidbounding box valid?; TGLClip*fClipScene clipping-plane.; Bool_tfDoClipCheckPerform global clip-plane-check in UpdateSceneInfo(); Bool_tfDoFrustumCheckPerform global frustum-check in UpdateSceneInfo(); Short_tfLODScene-lod.; TGLLockable::ELockTGLLockable::fLockLock state.; UInt_tfMinorStampCounter increased on minimal update.; TStringfNameObject identifier.; Float_tfOLLineWScene outline line-width.; UInt_tfSceneIDUnique scene id.; Bool_tfSelectableObjects in the scene are selectable.; Short_tfStyleScene-style.; UInt_tfTimeStampCounter increased on every update.; TStringfTitleObject title.; list<TGLViewerBase*>fViewers; Float_tfWFLineWScene wire-frame line-width. private:. static UInt_tfgSceneIDSrc. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~TGLSceneBase(); Destructor. void AddViewer(TGLViewerBase* viewer); Add viewer to the list. void RemoveViewer(TGLViewerBase* viewer); Remove viewer from ",MatchSource.WIKI,root/html528/TGLSceneBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLSceneBase.html
https://root.cern/root/html528/TGLSceneBase.html:5376,Usability,clear,clear,5376,"; Remove viewer from the list.; If auto-destruct is on and the last viewer is removed the scene; destructs itself. void TagViewersChanged(); Tag all viewers as changed. const char* LockIdStr() const; Name printed on locking info messages. TGLSceneInfo* CreateSceneInfo(TGLViewerBase* view); Create a scene-info instance appropriate for this scene class.; Here we instantiate the scene-info base-class TGLSceneInfo. void RebuildSceneInfo(TGLRnrCtx& ctx); Fill scene-info with very basic information that is practically; view independent. This is called when scene content is changed; or when camera-interest changes. void UpdateSceneInfo(TGLRnrCtx& ctx); Fill scene-info with information needed for rendering, take into; account the render-context (viewer state, camera, clipping).; Usually called from TGLViewer before rendering a scene if some; moderately significant part of render-context has changed. Here we update the basic state (clear last-LOD, mark the time,; set global <-> scene transforamtion matrices) and potentially; study and refine the clipping planes based on scene bounding box. void LodifySceneInfo(TGLRnrCtx& ctx); Setup LOD-dependant values in scene-info. Nothing to be done here but to store the last LOD. void PreDraw(TGLRnrCtx& rnrCtx); Perform basic pre-render initialization:; - calculate LOD, Style, Clipping,; - build draw lists. This is called in the beginning of the GL-viewer draw cycle. void PreRender(TGLRnrCtx& rnrCtx); Perform pre-render initialization - fill rnrCtx with; values stored during PreDraw(). This is called each time before RenderXyzz(). void Render(TGLRnrCtx& rnrCtx); This function does rendering of all stages, the shapes are; rendered in the following order: opaque, transparent,; selected-opaque, selected-transparent. GL-depth buffer is cleared after transparent shapes have been; rendered. This is never called from ROOT GL directly. Use it if you know; you are rendering a single scene. void RenderOpaque(TGLRnrCtx& rnrCtx); Render opaque eleme",MatchSource.WIKI,root/html528/TGLSceneBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLSceneBase.html
https://root.cern/root/html528/TGLSceneBase.html:6231,Usability,clear,cleared,6231,"wer before rendering a scene if some; moderately significant part of render-context has changed. Here we update the basic state (clear last-LOD, mark the time,; set global <-> scene transforamtion matrices) and potentially; study and refine the clipping planes based on scene bounding box. void LodifySceneInfo(TGLRnrCtx& ctx); Setup LOD-dependant values in scene-info. Nothing to be done here but to store the last LOD. void PreDraw(TGLRnrCtx& rnrCtx); Perform basic pre-render initialization:; - calculate LOD, Style, Clipping,; - build draw lists. This is called in the beginning of the GL-viewer draw cycle. void PreRender(TGLRnrCtx& rnrCtx); Perform pre-render initialization - fill rnrCtx with; values stored during PreDraw(). This is called each time before RenderXyzz(). void Render(TGLRnrCtx& rnrCtx); This function does rendering of all stages, the shapes are; rendered in the following order: opaque, transparent,; selected-opaque, selected-transparent. GL-depth buffer is cleared after transparent shapes have been; rendered. This is never called from ROOT GL directly. Use it if you know; you are rendering a single scene. void RenderOpaque(TGLRnrCtx& rnrCtx); Render opaque elements. void RenderTransp(TGLRnrCtx& rnrCtx); Render transparent elements. void RenderSelOpaque(TGLRnrCtx& rnrCtx); Render selected opaque elements. void RenderSelTransp(TGLRnrCtx& rnrCtx); Render selected transparent elements. void PostRender(TGLRnrCtx& rnrCtx); Perform post-render clean-up. void PostDraw(TGLRnrCtx& rnrCtx); Finalize drawing. This is called at the end of the GL-viewer draw cycle. Bool_t ResolveSelectRecord(TGLSelectRecord& rec, Int_t curIdx); Process selection record rec.; 'curIdx' is the item position where the scene should start; its processing.; Return TRUE if an object has been identified or FALSE otherwise.; The scene-info member of the record is already set by the caller. See implementation in sub-class TGLScene, here we just return FALSE. TGLSceneBase& operator=(const TGLScen",MatchSource.WIKI,root/html528/TGLSceneBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLSceneBase.html
https://root.cern/root/html528/TGLSceneInfo.html:2865,Deployability,update,update,2865,"tamp() const; voidSetActive(Bool_t a); voidSetCameraStamp(UInt_t ts); voidSetClip(TGLClip* p); voidSetClipStamp(UInt_t ts); voidSetLastCamera(TGLCamera* p); voidSetLastClip(TGLClip* p); voidSetLastLOD(Short_t ld); voidSetLastOLLineW(Float_t w); voidSetLastStyle(Short_t st); voidSetLastWFLineW(Float_t w); voidSetLOD(Short_t lod); voidSetOLLineW(Float_t w); voidSetSceneStamp(UInt_t ts); virtual voidSetSceneTrans(TGLMatrix&); voidSetStyle(Short_t st); voidSetupTransformsAndBBox(); voidSetWFLineW(Float_t w); Bool_tShouldClip() const; virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); Short_tStyle() const; voidUpdateTimeouted(); Bool_tViewCheck() const; voidViewCheck(Bool_t c); Float_tWFLineW() const. private:. TGLSceneInfo(const TGLSceneInfo&); TGLSceneInfo&operator=(const TGLSceneInfo&). Data Members; public:. enum EClipTest { kClipNone; kClipOutside; kClipInside; };. protected:. Bool_tfActiveShow fScene in fViewer; UInt_tfCameraStampCamera's time-stamp on last update.; TGLClip*fClipOptional override of clipping-plane; Char_tfClipModeClipping mode, can be disbled.; TGLPlaneSet_tfClipPlanesClipping planes from clip-object; which planes are kept depends on inside/outside mode.; UInt_tfClipStampClip's time-stamp on last update.; TGLPlaneSet_tfFrustumPlanesClipping planes defined by frustum; only those intersecting the scene volume are kept.; Bool_tfInClipIs scene contained within clipping-volume.; Bool_tfInFrustumIs scene intersecting view-frustum.; Short_tfLODOptional override of scene lod; TGLCamera*fLastCameraLast camera used.; TGLClip*fLastClipLast combined viewer/scene clip (set in scene::update); Short_tfLastLODLast combined viewer/scene lod (set in scene::lodify-scene-info).; Float_tfLastOLLineWLast combined viewer/scene outline line-width (set in scene::pre-draw).; Short_tfLastStyleLast combined viewer/scene style (set in scene::pre-draw).; Float_tfLastWFLineWLast combined viewer/scene wire-frame lin",MatchSource.WIKI,root/html528/TGLSceneInfo.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLSceneInfo.html
https://root.cern/root/html528/TGLSceneInfo.html:3126,Deployability,update,update,3126,"tLastWFLineW(Float_t w); voidSetLOD(Short_t lod); voidSetOLLineW(Float_t w); voidSetSceneStamp(UInt_t ts); virtual voidSetSceneTrans(TGLMatrix&); voidSetStyle(Short_t st); voidSetupTransformsAndBBox(); voidSetWFLineW(Float_t w); Bool_tShouldClip() const; virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); Short_tStyle() const; voidUpdateTimeouted(); Bool_tViewCheck() const; voidViewCheck(Bool_t c); Float_tWFLineW() const. private:. TGLSceneInfo(const TGLSceneInfo&); TGLSceneInfo&operator=(const TGLSceneInfo&). Data Members; public:. enum EClipTest { kClipNone; kClipOutside; kClipInside; };. protected:. Bool_tfActiveShow fScene in fViewer; UInt_tfCameraStampCamera's time-stamp on last update.; TGLClip*fClipOptional override of clipping-plane; Char_tfClipModeClipping mode, can be disbled.; TGLPlaneSet_tfClipPlanesClipping planes from clip-object; which planes are kept depends on inside/outside mode.; UInt_tfClipStampClip's time-stamp on last update.; TGLPlaneSet_tfFrustumPlanesClipping planes defined by frustum; only those intersecting the scene volume are kept.; Bool_tfInClipIs scene contained within clipping-volume.; Bool_tfInFrustumIs scene intersecting view-frustum.; Short_tfLODOptional override of scene lod; TGLCamera*fLastCameraLast camera used.; TGLClip*fLastClipLast combined viewer/scene clip (set in scene::update); Short_tfLastLODLast combined viewer/scene lod (set in scene::lodify-scene-info).; Float_tfLastOLLineWLast combined viewer/scene outline line-width (set in scene::pre-draw).; Short_tfLastStyleLast combined viewer/scene style (set in scene::pre-draw).; Float_tfLastWFLineWLast combined viewer/scene wire-frame line-width (set in scene::pre-draw).; Float_tfOLLineWOptional override of scene outline line-width; TGLSceneBase*fScene; UInt_tfSceneStampScene's time-stamp on last update.; Short_tfStyleOptional override of scene style; TGLBoundingBoxfTransformedBBox; Bool_tfUpdateTimeoutedSet if up",MatchSource.WIKI,root/html528/TGLSceneInfo.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLSceneInfo.html
https://root.cern/root/html528/TGLSceneInfo.html:3507,Deployability,update,update,3507,"ed(); Bool_tViewCheck() const; voidViewCheck(Bool_t c); Float_tWFLineW() const. private:. TGLSceneInfo(const TGLSceneInfo&); TGLSceneInfo&operator=(const TGLSceneInfo&). Data Members; public:. enum EClipTest { kClipNone; kClipOutside; kClipInside; };. protected:. Bool_tfActiveShow fScene in fViewer; UInt_tfCameraStampCamera's time-stamp on last update.; TGLClip*fClipOptional override of clipping-plane; Char_tfClipModeClipping mode, can be disbled.; TGLPlaneSet_tfClipPlanesClipping planes from clip-object; which planes are kept depends on inside/outside mode.; UInt_tfClipStampClip's time-stamp on last update.; TGLPlaneSet_tfFrustumPlanesClipping planes defined by frustum; only those intersecting the scene volume are kept.; Bool_tfInClipIs scene contained within clipping-volume.; Bool_tfInFrustumIs scene intersecting view-frustum.; Short_tfLODOptional override of scene lod; TGLCamera*fLastCameraLast camera used.; TGLClip*fLastClipLast combined viewer/scene clip (set in scene::update); Short_tfLastLODLast combined viewer/scene lod (set in scene::lodify-scene-info).; Float_tfLastOLLineWLast combined viewer/scene outline line-width (set in scene::pre-draw).; Short_tfLastStyleLast combined viewer/scene style (set in scene::pre-draw).; Float_tfLastWFLineWLast combined viewer/scene wire-frame line-width (set in scene::pre-draw).; Float_tfOLLineWOptional override of scene outline line-width; TGLSceneBase*fScene; UInt_tfSceneStampScene's time-stamp on last update.; Short_tfStyleOptional override of scene style; TGLBoundingBoxfTransformedBBox; Bool_tfUpdateTimeoutedSet if update was interrupted.; Bool_tfViewCheckViewer side check if render is necessary.; TGLViewerBase*fViewer; Float_tfWFLineWOptional override of scene wire-frame line-width. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLSceneInfo(TGLViewerBase* view = 0, TGLSceneBase* scene = 0); Default constructor. void SetActive(Bool_t a); Set active state of the scene, mark vie",MatchSource.WIKI,root/html528/TGLSceneInfo.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLSceneInfo.html
https://root.cern/root/html528/TGLSceneInfo.html:3989,Deployability,update,update,3989,"_tfClipModeClipping mode, can be disbled.; TGLPlaneSet_tfClipPlanesClipping planes from clip-object; which planes are kept depends on inside/outside mode.; UInt_tfClipStampClip's time-stamp on last update.; TGLPlaneSet_tfFrustumPlanesClipping planes defined by frustum; only those intersecting the scene volume are kept.; Bool_tfInClipIs scene contained within clipping-volume.; Bool_tfInFrustumIs scene intersecting view-frustum.; Short_tfLODOptional override of scene lod; TGLCamera*fLastCameraLast camera used.; TGLClip*fLastClipLast combined viewer/scene clip (set in scene::update); Short_tfLastLODLast combined viewer/scene lod (set in scene::lodify-scene-info).; Float_tfLastOLLineWLast combined viewer/scene outline line-width (set in scene::pre-draw).; Short_tfLastStyleLast combined viewer/scene style (set in scene::pre-draw).; Float_tfLastWFLineWLast combined viewer/scene wire-frame line-width (set in scene::pre-draw).; Float_tfOLLineWOptional override of scene outline line-width; TGLSceneBase*fScene; UInt_tfSceneStampScene's time-stamp on last update.; Short_tfStyleOptional override of scene style; TGLBoundingBoxfTransformedBBox; Bool_tfUpdateTimeoutedSet if update was interrupted.; Bool_tfViewCheckViewer side check if render is necessary.; TGLViewerBase*fViewer; Float_tfWFLineWOptional override of scene wire-frame line-width. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLSceneInfo(TGLViewerBase* view = 0, TGLSceneBase* scene = 0); Default constructor. void SetActive(Bool_t a); Set active state of the scene, mark viewer as changed. void SetupTransformsAndBBox(); Combine information from scene, scene-info and camera (should be; optional) into transformation matrices. Transform scene bounding box using this transformation. TGLSceneInfo(const TGLSceneInfo& ). TGLSceneInfo& operator=(const TGLSceneInfo& ). virtual ~TGLSceneInfo(); {}. TGLViewerBase * GetViewer() const; { return fViewer; }. TGLViewerBase & RefViewer() cons",MatchSource.WIKI,root/html528/TGLSceneInfo.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLSceneInfo.html
https://root.cern/root/html528/TGLSceneInfo.html:4106,Deployability,update,update,4106,"inside/outside mode.; UInt_tfClipStampClip's time-stamp on last update.; TGLPlaneSet_tfFrustumPlanesClipping planes defined by frustum; only those intersecting the scene volume are kept.; Bool_tfInClipIs scene contained within clipping-volume.; Bool_tfInFrustumIs scene intersecting view-frustum.; Short_tfLODOptional override of scene lod; TGLCamera*fLastCameraLast camera used.; TGLClip*fLastClipLast combined viewer/scene clip (set in scene::update); Short_tfLastLODLast combined viewer/scene lod (set in scene::lodify-scene-info).; Float_tfLastOLLineWLast combined viewer/scene outline line-width (set in scene::pre-draw).; Short_tfLastStyleLast combined viewer/scene style (set in scene::pre-draw).; Float_tfLastWFLineWLast combined viewer/scene wire-frame line-width (set in scene::pre-draw).; Float_tfOLLineWOptional override of scene outline line-width; TGLSceneBase*fScene; UInt_tfSceneStampScene's time-stamp on last update.; Short_tfStyleOptional override of scene style; TGLBoundingBoxfTransformedBBox; Bool_tfUpdateTimeoutedSet if update was interrupted.; Bool_tfViewCheckViewer side check if render is necessary.; TGLViewerBase*fViewer; Float_tfWFLineWOptional override of scene wire-frame line-width. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLSceneInfo(TGLViewerBase* view = 0, TGLSceneBase* scene = 0); Default constructor. void SetActive(Bool_t a); Set active state of the scene, mark viewer as changed. void SetupTransformsAndBBox(); Combine information from scene, scene-info and camera (should be; optional) into transformation matrices. Transform scene bounding box using this transformation. TGLSceneInfo(const TGLSceneInfo& ). TGLSceneInfo& operator=(const TGLSceneInfo& ). virtual ~TGLSceneInfo(); {}. TGLViewerBase * GetViewer() const; { return fViewer; }. TGLViewerBase & RefViewer() const; { return *fViewer; }. TGLSceneBase * GetScene() const; { return fScene; }. TGLSceneBase & RefScene() const; { return *fScene; }. Boo",MatchSource.WIKI,root/html528/TGLSceneInfo.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLSceneInfo.html
https://root.cern/root/html528/TGLSceneInfo.html:3051,Integrability,depend,depends,3051,"D(Short_t ld); voidSetLastOLLineW(Float_t w); voidSetLastStyle(Short_t st); voidSetLastWFLineW(Float_t w); voidSetLOD(Short_t lod); voidSetOLLineW(Float_t w); voidSetSceneStamp(UInt_t ts); virtual voidSetSceneTrans(TGLMatrix&); voidSetStyle(Short_t st); voidSetupTransformsAndBBox(); voidSetWFLineW(Float_t w); Bool_tShouldClip() const; virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); Short_tStyle() const; voidUpdateTimeouted(); Bool_tViewCheck() const; voidViewCheck(Bool_t c); Float_tWFLineW() const. private:. TGLSceneInfo(const TGLSceneInfo&); TGLSceneInfo&operator=(const TGLSceneInfo&). Data Members; public:. enum EClipTest { kClipNone; kClipOutside; kClipInside; };. protected:. Bool_tfActiveShow fScene in fViewer; UInt_tfCameraStampCamera's time-stamp on last update.; TGLClip*fClipOptional override of clipping-plane; Char_tfClipModeClipping mode, can be disbled.; TGLPlaneSet_tfClipPlanesClipping planes from clip-object; which planes are kept depends on inside/outside mode.; UInt_tfClipStampClip's time-stamp on last update.; TGLPlaneSet_tfFrustumPlanesClipping planes defined by frustum; only those intersecting the scene volume are kept.; Bool_tfInClipIs scene contained within clipping-volume.; Bool_tfInFrustumIs scene intersecting view-frustum.; Short_tfLODOptional override of scene lod; TGLCamera*fLastCameraLast camera used.; TGLClip*fLastClipLast combined viewer/scene clip (set in scene::update); Short_tfLastLODLast combined viewer/scene lod (set in scene::lodify-scene-info).; Float_tfLastOLLineWLast combined viewer/scene outline line-width (set in scene::pre-draw).; Short_tfLastStyleLast combined viewer/scene style (set in scene::pre-draw).; Float_tfLastWFLineWLast combined viewer/scene wire-frame line-width (set in scene::pre-draw).; Float_tfOLLineWOptional override of scene outline line-width; TGLSceneBase*fScene; UInt_tfSceneStampScene's time-stamp on last update.; Short_tfStyleOptional overri",MatchSource.WIKI,root/html528/TGLSceneInfo.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLSceneInfo.html
https://root.cern/root/html528/TGLSceneInfo.html:310,Modifiability,extend,extended,310,". TGLSceneInfo. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLSceneInfo. class TGLSceneInfo. TGLSceneInfo. Base class for extended scene context. Scenes can be shared among several viewers and each scene needs to; cache some viewer/camera/clipping specific state => this is a; storage class for this data. Sub-classes of TGLSceneBase can override the virtual; CreateSceneInfo() method and in it instantiate a sub-class of; TGLSceneInfo containing the needed information. See TGLScene and; inner class SceneInfo; note that some casting is needed in actual; methods as TGLRnrCtx holds the base-class pointer. Function Members (Methods); public:. TGLSceneInfo(TGLViewerBase* view = 0, TGLSceneBase* scene = 0); virtual~TGLSceneInfo(); UInt_tCameraStamp() const; static TClass*Class(); TGLClip*Clip() const; Char_tClipMode() const; voidClipMode(Char_t m); vector<TGLPlane>&ClipPlanes(); UInt_tClipStamp() const; vector<TGLPlane>&FrustumPlanes(); Bool_tGetActive() const; TGLSceneBase*GetScene() const; const TGLBoundingBox&GetTransformedBBox(); TGLViewerBase*GetViewer() const; Bool_tHasUpdateTimeouted() const; voidInClip(Bool_t c); voidInFrustum(Bool_t f); virtual TClass*IsA() const; Bool_tIsInClip() const; Bool_tIsInFrustum() const; Bool_tIsVisible() const; TGLCamera*LastCamera() const; TGLClip*LastClip() const; Short_tLastLOD() const; Float_tLastOLLineW() const; Short_tLastStyle() const; Float_tLastWFLineW() const; Short_tLOD() const; Float_tOLLineW() const; TGLSceneBase&RefScene() const; TGLViewerBase&RefViewer() const; voidResetCameraStamp(); voidResetClipStamp(); voidResetSceneStamp(); voidResetUpdateTimeouted(); UInt_tSceneStamp() const; voidSetActive(Bool_t a); voidSetCameraStamp(UInt_t ts); voidSetClip(TGLClip* p); voidSetClipStamp(UInt_t ts); voidSetLastCamera(TGLCamera* p); voidSetLastClip(TG",MatchSource.WIKI,root/html528/TGLSceneInfo.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLSceneInfo.html
https://root.cern/root/html528/TGLSceneInfo.html:402,Performance,cache,cache,402,". TGLSceneInfo. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLSceneInfo. class TGLSceneInfo. TGLSceneInfo. Base class for extended scene context. Scenes can be shared among several viewers and each scene needs to; cache some viewer/camera/clipping specific state => this is a; storage class for this data. Sub-classes of TGLSceneBase can override the virtual; CreateSceneInfo() method and in it instantiate a sub-class of; TGLSceneInfo containing the needed information. See TGLScene and; inner class SceneInfo; note that some casting is needed in actual; methods as TGLRnrCtx holds the base-class pointer. Function Members (Methods); public:. TGLSceneInfo(TGLViewerBase* view = 0, TGLSceneBase* scene = 0); virtual~TGLSceneInfo(); UInt_tCameraStamp() const; static TClass*Class(); TGLClip*Clip() const; Char_tClipMode() const; voidClipMode(Char_t m); vector<TGLPlane>&ClipPlanes(); UInt_tClipStamp() const; vector<TGLPlane>&FrustumPlanes(); Bool_tGetActive() const; TGLSceneBase*GetScene() const; const TGLBoundingBox&GetTransformedBBox(); TGLViewerBase*GetViewer() const; Bool_tHasUpdateTimeouted() const; voidInClip(Bool_t c); voidInFrustum(Bool_t f); virtual TClass*IsA() const; Bool_tIsInClip() const; Bool_tIsInFrustum() const; Bool_tIsVisible() const; TGLCamera*LastCamera() const; TGLClip*LastClip() const; Short_tLastLOD() const; Float_tLastOLLineW() const; Short_tLastStyle() const; Float_tLastWFLineW() const; Short_tLOD() const; Float_tOLLineW() const; TGLSceneBase&RefScene() const; TGLViewerBase&RefViewer() const; voidResetCameraStamp(); voidResetClipStamp(); voidResetSceneStamp(); voidResetUpdateTimeouted(); UInt_tSceneStamp() const; voidSetActive(Bool_t a); voidSetCameraStamp(UInt_t ts); voidSetClip(TGLClip* p); voidSetClipStamp(UInt_t ts); voidSetLastCamera(TGLCamera* p); voidSetLastClip(TG",MatchSource.WIKI,root/html528/TGLSceneInfo.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLSceneInfo.html
https://root.cern/root/html528/TGLScenePad.html:2816,Availability,error,error,2816," view); TGLLockable::ELockTGLLockable::CurrentLock() const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Bool_tTGLScene::DestroyLogical(TObject* logid, Bool_t mustFind = kTRUE); virtual Int_tTGLScene::DestroyLogicals(); virtual Bool_tTGLScene::DestroyPhysical(UInt_t phid); virtual Int_tTGLScene::DestroyPhysicals(); virtual Int_tDistancetoPrimitive(Int_t, Int_t); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTVirtualViewer3D::DrawViewer(); virtual voidTObject::Dump() constMENU ; voidTGLScene::DumpMapSizes() const; virtual voidEndScene(); voidTGLScene::EndSmartRefresh(); virtual voidTGLScene::EndUpdate(Bool_t minorChange = kTRUE, Bool_t sceneChanged = kTRUE, Bool_t updateViewers = kTRUE); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t, Int_t, Int_t); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGLLogicalShape*TGLScene::FindLogical(TObject* logid) const; TGLLogicalShape*TGLScene::FindLogicalSmartRefresh(TObject* ID) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TGLPhysicalShape*TGLScene::FindPhysical(UInt_t phid) const; Bool_tTGLSceneBase::GetAutoDestruct() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); TGLContextIdentity*TGLScene::GetGLCtxIdentity() const; virtual const char*TObject::GetIconName() const; virtual UInt_tTGLScene::GetMaxPhysicalID(); UInt_tTGLSceneBase::GetMinorStamp() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::Get",MatchSource.WIKI,root/html528/TGLScenePad.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLScenePad.html
https://root.cern/root/html528/TGLScenePad.html:2900,Availability,error,error,2900,"ete(Option_t* option = """")MENU ; virtual Bool_tTGLScene::DestroyLogical(TObject* logid, Bool_t mustFind = kTRUE); virtual Int_tTGLScene::DestroyLogicals(); virtual Bool_tTGLScene::DestroyPhysical(UInt_t phid); virtual Int_tTGLScene::DestroyPhysicals(); virtual Int_tDistancetoPrimitive(Int_t, Int_t); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTVirtualViewer3D::DrawViewer(); virtual voidTObject::Dump() constMENU ; voidTGLScene::DumpMapSizes() const; virtual voidEndScene(); voidTGLScene::EndSmartRefresh(); virtual voidTGLScene::EndUpdate(Bool_t minorChange = kTRUE, Bool_t sceneChanged = kTRUE, Bool_t updateViewers = kTRUE); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t, Int_t, Int_t); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGLLogicalShape*TGLScene::FindLogical(TObject* logid) const; TGLLogicalShape*TGLScene::FindLogicalSmartRefresh(TObject* ID) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TGLPhysicalShape*TGLScene::FindPhysical(UInt_t phid) const; Bool_tTGLSceneBase::GetAutoDestruct() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); TGLContextIdentity*TGLScene::GetGLCtxIdentity() const; virtual const char*TObject::GetIconName() const; virtual UInt_tTGLScene::GetMaxPhysicalID(); UInt_tTGLSceneBase::GetMinorStamp() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TVirtualPad*GetPad() cons",MatchSource.WIKI,root/html528/TGLScenePad.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLScenePad.html
https://root.cern/root/html528/TGLScenePad.html:2642,Deployability,update,updateViewers,2642,"l Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual TGLScene::TSceneInfo*TGLScene::CreateSceneInfo(TGLViewerBase* view); TGLLockable::ELockTGLLockable::CurrentLock() const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Bool_tTGLScene::DestroyLogical(TObject* logid, Bool_t mustFind = kTRUE); virtual Int_tTGLScene::DestroyLogicals(); virtual Bool_tTGLScene::DestroyPhysical(UInt_t phid); virtual Int_tTGLScene::DestroyPhysicals(); virtual Int_tDistancetoPrimitive(Int_t, Int_t); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTVirtualViewer3D::DrawViewer(); virtual voidTObject::Dump() constMENU ; voidTGLScene::DumpMapSizes() const; virtual voidEndScene(); voidTGLScene::EndSmartRefresh(); virtual voidTGLScene::EndUpdate(Bool_t minorChange = kTRUE, Bool_t sceneChanged = kTRUE, Bool_t updateViewers = kTRUE); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t, Int_t, Int_t); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGLLogicalShape*TGLScene::FindLogical(TObject* logid) const; TGLLogicalShape*TGLScene::FindLogicalSmartRefresh(TObject* ID) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TGLPhysicalShape*TGLScene::FindPhysical(UInt_t phid) const; Bool_tTGLSceneBase::GetAutoDestruct() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); TGLContextIdentity*TGLScene::GetGLCtxIdentity() const; virtual const char*TObject::GetIconName() const; virtual UInt_tTGLScene::GetMaxPhysicalID(); UInt_t",MatchSource.WIKI,root/html528/TGLScenePad.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLScenePad.html
https://root.cern/root/html528/TGLScenePad.html:11196,Deployability,update,update,11196,"t TBuffer3D& buffer, const TGLLogicalShape& logical) const; virtual voidTGLScene::DestroyPhysicalInternal(TGLScene::PhysicalShapeMapIt_t pit); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(); voidTGLScene::ReleaseGLCtxIdentity(); Int_tValidateObjectBuffer(const TBuffer3D& buffer, Bool_t includeRaw) const. private:. TGLScenePad(const TGLScenePad&); TGLScenePad&operator=(const TGLScenePad&). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };; enum TGLLockable::ELock { kUnlocked; kDrawLock; kSelectLock; kModifyLock; };. protected:. Int_tfAcceptedPhysicals; Bool_tTGLSceneBase::fAutoDestruct; TGLBoundingBoxTGLSceneBase::fBoundingBoxbounding box for scene (axis aligned) - lazy update - use BoundingBox() to access; Bool_tTGLSceneBase::fBoundingBoxValidbounding box valid?; UInt_tfCSLevel; vector<CSPart_t>fCSTokens; TGLClip*TGLSceneBase::fClipScene clipping-plane.; TGLFaceSet*fComposite! Paritally created composite; Bool_tTGLSceneBase::fDoClipCheckPerform global clip-plane-check in UpdateSceneInfo(); Bool_tTGLSceneBase::fDoFrustumCheckPerform global frustum-check in UpdateSceneInfo(); TGLContextIdentity*TGLScene::fGLCtxIdentity; Bool_tTGLScene::fInSmartRefresh!; Bool_tfInternalPIDs! using internal physical IDs; Short_tTGLSceneBase::fLODScene-lod.; Float_tTGLScene::fLastLineWidthScale; UInt_tfLastPID! last physical ID that was processed in AddObject(); Float_tTGLScene::fLastPointSizeScale; TGLLockable::ELockTGLLockable::fLockLock state.; map<TObject*,TGLLogicalShape*>TGLScene::fLogicalShapes!; UInt_tTGLSceneBase::fMinorStampCounter increased on minimal update.; TStringTGLSceneBase::fNameObject identifier.; UInt_tfNextInternalPID! next internal physical ID (from 1 - 0 reserved); Floa",MatchSource.WIKI,root/html528/TGLScenePad.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLScenePad.html
https://root.cern/root/html528/TGLScenePad.html:12085,Deployability,update,update,12085,"Lock; };. protected:. Int_tfAcceptedPhysicals; Bool_tTGLSceneBase::fAutoDestruct; TGLBoundingBoxTGLSceneBase::fBoundingBoxbounding box for scene (axis aligned) - lazy update - use BoundingBox() to access; Bool_tTGLSceneBase::fBoundingBoxValidbounding box valid?; UInt_tfCSLevel; vector<CSPart_t>fCSTokens; TGLClip*TGLSceneBase::fClipScene clipping-plane.; TGLFaceSet*fComposite! Paritally created composite; Bool_tTGLSceneBase::fDoClipCheckPerform global clip-plane-check in UpdateSceneInfo(); Bool_tTGLSceneBase::fDoFrustumCheckPerform global frustum-check in UpdateSceneInfo(); TGLContextIdentity*TGLScene::fGLCtxIdentity; Bool_tTGLScene::fInSmartRefresh!; Bool_tfInternalPIDs! using internal physical IDs; Short_tTGLSceneBase::fLODScene-lod.; Float_tTGLScene::fLastLineWidthScale; UInt_tfLastPID! last physical ID that was processed in AddObject(); Float_tTGLScene::fLastPointSizeScale; TGLLockable::ELockTGLLockable::fLockLock state.; map<TObject*,TGLLogicalShape*>TGLScene::fLogicalShapes!; UInt_tTGLSceneBase::fMinorStampCounter increased on minimal update.; TStringTGLSceneBase::fNameObject identifier.; UInt_tfNextInternalPID! next internal physical ID (from 1 - 0 reserved); Float_tTGLSceneBase::fOLLineWScene outline line-width.; TVirtualPad*fPad; map<unsigned int,TGLPhysicalShape*>TGLScene::fPhysicalShapes!; UInt_tTGLSceneBase::fSceneIDUnique scene id.; Bool_tTGLSceneBase::fSelectableObjects in the scene are selectable.; Bool_tfSmartRefresh! cache logicals during scene rebuilds; map<TObject*,TGLLogicalShape*>TGLScene::fSmartRefreshCache!; Short_tTGLSceneBase::fStyleScene-style.; UInt_tTGLSceneBase::fTimeStampCounter increased on every update.; TStringTGLSceneBase::fTitleObject title.; list<TGLViewerBase*>TGLSceneBase::fViewers; Float_tTGLSceneBase::fWFLineWScene wire-frame line-width. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLScenePad(TVirtualPad* pad); Constructor. void AddHistoPhysical(TGLLogicalShape* log); Scale and rot",MatchSource.WIKI,root/html528/TGLScenePad.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLScenePad.html
https://root.cern/root/html528/TGLScenePad.html:12683,Deployability,update,update,12683,"l_tTGLScene::fInSmartRefresh!; Bool_tfInternalPIDs! using internal physical IDs; Short_tTGLSceneBase::fLODScene-lod.; Float_tTGLScene::fLastLineWidthScale; UInt_tfLastPID! last physical ID that was processed in AddObject(); Float_tTGLScene::fLastPointSizeScale; TGLLockable::ELockTGLLockable::fLockLock state.; map<TObject*,TGLLogicalShape*>TGLScene::fLogicalShapes!; UInt_tTGLSceneBase::fMinorStampCounter increased on minimal update.; TStringTGLSceneBase::fNameObject identifier.; UInt_tfNextInternalPID! next internal physical ID (from 1 - 0 reserved); Float_tTGLSceneBase::fOLLineWScene outline line-width.; TVirtualPad*fPad; map<unsigned int,TGLPhysicalShape*>TGLScene::fPhysicalShapes!; UInt_tTGLSceneBase::fSceneIDUnique scene id.; Bool_tTGLSceneBase::fSelectableObjects in the scene are selectable.; Bool_tfSmartRefresh! cache logicals during scene rebuilds; map<TObject*,TGLLogicalShape*>TGLScene::fSmartRefreshCache!; Short_tTGLSceneBase::fStyleScene-style.; UInt_tTGLSceneBase::fTimeStampCounter increased on every update.; TStringTGLSceneBase::fTitleObject title.; list<TGLViewerBase*>TGLSceneBase::fViewers; Float_tTGLSceneBase::fWFLineWScene wire-frame line-width. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLScenePad(TVirtualPad* pad); Constructor. void AddHistoPhysical(TGLLogicalShape* log); Scale and rotate a histo object to mimic placement in canvas. void SubPadPaint(TVirtualPad* pad); Iterate over pad-primitves and import them. void ObjectPaint(TObject* obj, Option_t* opt = """"); Override of virtual TVirtualViewer3D::ObjectPaint().; Special handling of 2D/3D histograms to activate Timur's; histo-painters. void PadPaintFromViewer(TGLViewer* viewer); Entry point for requesting update of scene's contents from; gl-viewer. void PadPaint(TVirtualPad* pad); Entry point for updating scene contents via VirtualViewer3D; interface.; For now this is handled by TGLViewer as it remains; the 'Viewer3D' of given pad. void BeginScene()",MatchSource.WIKI,root/html528/TGLScenePad.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLScenePad.html
https://root.cern/root/html528/TGLScenePad.html:13409,Deployability,update,update,13409,"; Bool_tTGLSceneBase::fSelectableObjects in the scene are selectable.; Bool_tfSmartRefresh! cache logicals during scene rebuilds; map<TObject*,TGLLogicalShape*>TGLScene::fSmartRefreshCache!; Short_tTGLSceneBase::fStyleScene-style.; UInt_tTGLSceneBase::fTimeStampCounter increased on every update.; TStringTGLSceneBase::fTitleObject title.; list<TGLViewerBase*>TGLSceneBase::fViewers; Float_tTGLSceneBase::fWFLineWScene wire-frame line-width. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLScenePad(TVirtualPad* pad); Constructor. void AddHistoPhysical(TGLLogicalShape* log); Scale and rotate a histo object to mimic placement in canvas. void SubPadPaint(TVirtualPad* pad); Iterate over pad-primitves and import them. void ObjectPaint(TObject* obj, Option_t* opt = """"); Override of virtual TVirtualViewer3D::ObjectPaint().; Special handling of 2D/3D histograms to activate Timur's; histo-painters. void PadPaintFromViewer(TGLViewer* viewer); Entry point for requesting update of scene's contents from; gl-viewer. void PadPaint(TVirtualPad* pad); Entry point for updating scene contents via VirtualViewer3D; interface.; For now this is handled by TGLViewer as it remains; the 'Viewer3D' of given pad. void BeginScene(); Start building of the scene.; Old contents is dropped, unless smart-refresh is in active. Then; the object supporting it are kept in a cache and possibly reused. TVirtualViewer3D interface overload - see base/src/TVirtualViewer3D.cxx; for description of viewer architecture. void EndScene(); End building of the scene.; TVirtualViewer3D interface overload - see base/src/TVirtualViewer3D.cxx; for description of viewer architecture. Int_t AddObject(const TBuffer3D& buffer, Bool_t* addChildren = 0); Add an object to the viewer, using internal physical IDs; TVirtualViewer3D interface overload - see base/src/TVirtualViewer3D.cxx; for description of viewer architecture. Int_t AddObject(UInt_t physicalID, const TBuffer3D& buffer, Bool_",MatchSource.WIKI,root/html528/TGLScenePad.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLScenePad.html
https://root.cern/root/html528/TGLScenePad.html:360,Integrability,interface,interface,360,". TGLScenePad. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLScenePad. class TGLScenePad: public TVirtualViewer3D, public TGLScene. TGLScenePad. Implements VirtualViewer3D interface and fills the base-class; visualization structures from pad contents. Function Members (Methods); public:. TGLScenePad(TVirtualPad* pad); virtual~TGLScenePad(); voidTObject::AbstractMethod(const char* method) const; virtual voidAddCompositeOp(UInt_t operation); voidAddHistoPhysical(TGLLogicalShape* log); virtual Int_tAddObject(const TBuffer3D& buffer, Bool_t* addChildren = 0); virtual Int_tAddObject(UInt_t physicalID, const TBuffer3D& buffer, Bool_t* addChildren = 0); voidTGLSceneBase::AddViewer(TGLViewerBase* viewer); virtual voidTGLScene::AdoptLogical(TGLLogicalShape& shape); virtual voidTGLScene::AdoptPhysical(TGLPhysicalShape& shape); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBeginScene(); UInt_tTGLScene::BeginSmartRefresh(); virtual Bool_tTGLScene::BeginUpdate(); const TGLBoundingBox&TGLSceneBase::BoundingBox() const; virtual voidTObject::Browse(TBrowser* b); virtual Bool_tBuildingScene() const; virtual voidTGLScene::CalcBoundingBox() const; virtual Bool_tCanLoopOnPrimitives() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); TGLClip*TGLSceneBase::Clip() const; virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidCloseComposite(); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual TGLScene::TSceneInfo*TGLScene::CreateSceneInfo(TGLViewerBase* view); TGLLockable::ELockTGLLockable::CurrentLock() const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Bool_tTGLScene::DestroyLogical(TObject* logid, Bool_t mus",MatchSource.WIKI,root/html528/TGLScenePad.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLScenePad.html
https://root.cern/root/html528/TGLScenePad.html:13547,Integrability,interface,interface,13547,"ing scene rebuilds; map<TObject*,TGLLogicalShape*>TGLScene::fSmartRefreshCache!; Short_tTGLSceneBase::fStyleScene-style.; UInt_tTGLSceneBase::fTimeStampCounter increased on every update.; TStringTGLSceneBase::fTitleObject title.; list<TGLViewerBase*>TGLSceneBase::fViewers; Float_tTGLSceneBase::fWFLineWScene wire-frame line-width. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLScenePad(TVirtualPad* pad); Constructor. void AddHistoPhysical(TGLLogicalShape* log); Scale and rotate a histo object to mimic placement in canvas. void SubPadPaint(TVirtualPad* pad); Iterate over pad-primitves and import them. void ObjectPaint(TObject* obj, Option_t* opt = """"); Override of virtual TVirtualViewer3D::ObjectPaint().; Special handling of 2D/3D histograms to activate Timur's; histo-painters. void PadPaintFromViewer(TGLViewer* viewer); Entry point for requesting update of scene's contents from; gl-viewer. void PadPaint(TVirtualPad* pad); Entry point for updating scene contents via VirtualViewer3D; interface.; For now this is handled by TGLViewer as it remains; the 'Viewer3D' of given pad. void BeginScene(); Start building of the scene.; Old contents is dropped, unless smart-refresh is in active. Then; the object supporting it are kept in a cache and possibly reused. TVirtualViewer3D interface overload - see base/src/TVirtualViewer3D.cxx; for description of viewer architecture. void EndScene(); End building of the scene.; TVirtualViewer3D interface overload - see base/src/TVirtualViewer3D.cxx; for description of viewer architecture. Int_t AddObject(const TBuffer3D& buffer, Bool_t* addChildren = 0); Add an object to the viewer, using internal physical IDs; TVirtualViewer3D interface overload - see base/src/TVirtualViewer3D.cxx; for description of viewer architecture. Int_t AddObject(UInt_t physicalID, const TBuffer3D& buffer, Bool_t* addChildren = 0); Add an object to the scene, using an external physical ID; TVirtualViewer3D interface ove",MatchSource.WIKI,root/html528/TGLScenePad.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLScenePad.html
https://root.cern/root/html528/TGLScenePad.html:13838,Integrability,interface,interface,13838,"ritance; Inherited Members; Includes; Libraries. Function documentation; TGLScenePad(TVirtualPad* pad); Constructor. void AddHistoPhysical(TGLLogicalShape* log); Scale and rotate a histo object to mimic placement in canvas. void SubPadPaint(TVirtualPad* pad); Iterate over pad-primitves and import them. void ObjectPaint(TObject* obj, Option_t* opt = """"); Override of virtual TVirtualViewer3D::ObjectPaint().; Special handling of 2D/3D histograms to activate Timur's; histo-painters. void PadPaintFromViewer(TGLViewer* viewer); Entry point for requesting update of scene's contents from; gl-viewer. void PadPaint(TVirtualPad* pad); Entry point for updating scene contents via VirtualViewer3D; interface.; For now this is handled by TGLViewer as it remains; the 'Viewer3D' of given pad. void BeginScene(); Start building of the scene.; Old contents is dropped, unless smart-refresh is in active. Then; the object supporting it are kept in a cache and possibly reused. TVirtualViewer3D interface overload - see base/src/TVirtualViewer3D.cxx; for description of viewer architecture. void EndScene(); End building of the scene.; TVirtualViewer3D interface overload - see base/src/TVirtualViewer3D.cxx; for description of viewer architecture. Int_t AddObject(const TBuffer3D& buffer, Bool_t* addChildren = 0); Add an object to the viewer, using internal physical IDs; TVirtualViewer3D interface overload - see base/src/TVirtualViewer3D.cxx; for description of viewer architecture. Int_t AddObject(UInt_t physicalID, const TBuffer3D& buffer, Bool_t* addChildren = 0); Add an object to the scene, using an external physical ID; TVirtualViewer3D interface overload - see base/src/TVirtualViewer3D.cxx; for description of viewer architecture. Bool_t OpenComposite(const TBuffer3D& buffer, Bool_t* addChildren = 0); Open new composite container.; TVirtualViewer3D interface overload - see base/src/TVirtualViewer3D.cxx; for description of viewer architecture. void CloseComposite(); Close composite container; T",MatchSource.WIKI,root/html528/TGLScenePad.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLScenePad.html
https://root.cern/root/html528/TGLScenePad.html:13996,Integrability,interface,interface,13996,"g); Scale and rotate a histo object to mimic placement in canvas. void SubPadPaint(TVirtualPad* pad); Iterate over pad-primitves and import them. void ObjectPaint(TObject* obj, Option_t* opt = """"); Override of virtual TVirtualViewer3D::ObjectPaint().; Special handling of 2D/3D histograms to activate Timur's; histo-painters. void PadPaintFromViewer(TGLViewer* viewer); Entry point for requesting update of scene's contents from; gl-viewer. void PadPaint(TVirtualPad* pad); Entry point for updating scene contents via VirtualViewer3D; interface.; For now this is handled by TGLViewer as it remains; the 'Viewer3D' of given pad. void BeginScene(); Start building of the scene.; Old contents is dropped, unless smart-refresh is in active. Then; the object supporting it are kept in a cache and possibly reused. TVirtualViewer3D interface overload - see base/src/TVirtualViewer3D.cxx; for description of viewer architecture. void EndScene(); End building of the scene.; TVirtualViewer3D interface overload - see base/src/TVirtualViewer3D.cxx; for description of viewer architecture. Int_t AddObject(const TBuffer3D& buffer, Bool_t* addChildren = 0); Add an object to the viewer, using internal physical IDs; TVirtualViewer3D interface overload - see base/src/TVirtualViewer3D.cxx; for description of viewer architecture. Int_t AddObject(UInt_t physicalID, const TBuffer3D& buffer, Bool_t* addChildren = 0); Add an object to the scene, using an external physical ID; TVirtualViewer3D interface overload - see base/src/TVirtualViewer3D.cxx; for description of viewer architecture. Bool_t OpenComposite(const TBuffer3D& buffer, Bool_t* addChildren = 0); Open new composite container.; TVirtualViewer3D interface overload - see base/src/TVirtualViewer3D.cxx; for description of viewer architecture. void CloseComposite(); Close composite container; TVirtualViewer3D interface overload - see base/src/TVirtualViewer3D.cxx; for description of viewer architecture. void AddCompositeOp(UInt_t operation); Add co",MatchSource.WIKI,root/html528/TGLScenePad.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLScenePad.html
https://root.cern/root/html528/TGLScenePad.html:14234,Integrability,interface,interface,14234," Option_t* opt = """"); Override of virtual TVirtualViewer3D::ObjectPaint().; Special handling of 2D/3D histograms to activate Timur's; histo-painters. void PadPaintFromViewer(TGLViewer* viewer); Entry point for requesting update of scene's contents from; gl-viewer. void PadPaint(TVirtualPad* pad); Entry point for updating scene contents via VirtualViewer3D; interface.; For now this is handled by TGLViewer as it remains; the 'Viewer3D' of given pad. void BeginScene(); Start building of the scene.; Old contents is dropped, unless smart-refresh is in active. Then; the object supporting it are kept in a cache and possibly reused. TVirtualViewer3D interface overload - see base/src/TVirtualViewer3D.cxx; for description of viewer architecture. void EndScene(); End building of the scene.; TVirtualViewer3D interface overload - see base/src/TVirtualViewer3D.cxx; for description of viewer architecture. Int_t AddObject(const TBuffer3D& buffer, Bool_t* addChildren = 0); Add an object to the viewer, using internal physical IDs; TVirtualViewer3D interface overload - see base/src/TVirtualViewer3D.cxx; for description of viewer architecture. Int_t AddObject(UInt_t physicalID, const TBuffer3D& buffer, Bool_t* addChildren = 0); Add an object to the scene, using an external physical ID; TVirtualViewer3D interface overload - see base/src/TVirtualViewer3D.cxx; for description of viewer architecture. Bool_t OpenComposite(const TBuffer3D& buffer, Bool_t* addChildren = 0); Open new composite container.; TVirtualViewer3D interface overload - see base/src/TVirtualViewer3D.cxx; for description of viewer architecture. void CloseComposite(); Close composite container; TVirtualViewer3D interface overload - see base/src/TVirtualViewer3D.cxx; for description of viewer architecture. void AddCompositeOp(UInt_t operation); Add composite operation used to combine objects added via AddObject; TVirtualViewer3D interface overload - see base/src/TVirtualViewer3D.cxx; for description of viewer architecture. ",MatchSource.WIKI,root/html528/TGLScenePad.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLScenePad.html
https://root.cern/root/html528/TGLScenePad.html:14492,Integrability,interface,interface,14492,"from; gl-viewer. void PadPaint(TVirtualPad* pad); Entry point for updating scene contents via VirtualViewer3D; interface.; For now this is handled by TGLViewer as it remains; the 'Viewer3D' of given pad. void BeginScene(); Start building of the scene.; Old contents is dropped, unless smart-refresh is in active. Then; the object supporting it are kept in a cache and possibly reused. TVirtualViewer3D interface overload - see base/src/TVirtualViewer3D.cxx; for description of viewer architecture. void EndScene(); End building of the scene.; TVirtualViewer3D interface overload - see base/src/TVirtualViewer3D.cxx; for description of viewer architecture. Int_t AddObject(const TBuffer3D& buffer, Bool_t* addChildren = 0); Add an object to the viewer, using internal physical IDs; TVirtualViewer3D interface overload - see base/src/TVirtualViewer3D.cxx; for description of viewer architecture. Int_t AddObject(UInt_t physicalID, const TBuffer3D& buffer, Bool_t* addChildren = 0); Add an object to the scene, using an external physical ID; TVirtualViewer3D interface overload - see base/src/TVirtualViewer3D.cxx; for description of viewer architecture. Bool_t OpenComposite(const TBuffer3D& buffer, Bool_t* addChildren = 0); Open new composite container.; TVirtualViewer3D interface overload - see base/src/TVirtualViewer3D.cxx; for description of viewer architecture. void CloseComposite(); Close composite container; TVirtualViewer3D interface overload - see base/src/TVirtualViewer3D.cxx; for description of viewer architecture. void AddCompositeOp(UInt_t operation); Add composite operation used to combine objects added via AddObject; TVirtualViewer3D interface overload - see base/src/TVirtualViewer3D.cxx; for description of viewer architecture. Int_t ValidateObjectBuffer(const TBuffer3D& buffer, Bool_t includeRaw) const; Validate if the passed 'buffer' contains all sections we require to add object.; Returns Int_t combination of TBuffer::ESection flags still required - or; TBuffer3D::kNon",MatchSource.WIKI,root/html528/TGLScenePad.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLScenePad.html
https://root.cern/root/html528/TGLScenePad.html:14708,Integrability,interface,interface,14708,"rt-refresh is in active. Then; the object supporting it are kept in a cache and possibly reused. TVirtualViewer3D interface overload - see base/src/TVirtualViewer3D.cxx; for description of viewer architecture. void EndScene(); End building of the scene.; TVirtualViewer3D interface overload - see base/src/TVirtualViewer3D.cxx; for description of viewer architecture. Int_t AddObject(const TBuffer3D& buffer, Bool_t* addChildren = 0); Add an object to the viewer, using internal physical IDs; TVirtualViewer3D interface overload - see base/src/TVirtualViewer3D.cxx; for description of viewer architecture. Int_t AddObject(UInt_t physicalID, const TBuffer3D& buffer, Bool_t* addChildren = 0); Add an object to the scene, using an external physical ID; TVirtualViewer3D interface overload - see base/src/TVirtualViewer3D.cxx; for description of viewer architecture. Bool_t OpenComposite(const TBuffer3D& buffer, Bool_t* addChildren = 0); Open new composite container.; TVirtualViewer3D interface overload - see base/src/TVirtualViewer3D.cxx; for description of viewer architecture. void CloseComposite(); Close composite container; TVirtualViewer3D interface overload - see base/src/TVirtualViewer3D.cxx; for description of viewer architecture. void AddCompositeOp(UInt_t operation); Add composite operation used to combine objects added via AddObject; TVirtualViewer3D interface overload - see base/src/TVirtualViewer3D.cxx; for description of viewer architecture. Int_t ValidateObjectBuffer(const TBuffer3D& buffer, Bool_t includeRaw) const; Validate if the passed 'buffer' contains all sections we require to add object.; Returns Int_t combination of TBuffer::ESection flags still required - or; TBuffer3D::kNone if buffer is valid.; If 'includeRaw' is kTRUE check for kRaw/kRawSizes - skip otherwise.; See base/src/TVirtualViewer3D.cxx for description of viewer architecture. TGLLogicalShape* CreateNewLogical(const TBuffer3D& buffer) const; Create and return a new TGLLogicalShape from the supplie",MatchSource.WIKI,root/html528/TGLScenePad.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLScenePad.html
https://root.cern/root/html528/TGLScenePad.html:14871,Integrability,interface,interface,14871," base/src/TVirtualViewer3D.cxx; for description of viewer architecture. void EndScene(); End building of the scene.; TVirtualViewer3D interface overload - see base/src/TVirtualViewer3D.cxx; for description of viewer architecture. Int_t AddObject(const TBuffer3D& buffer, Bool_t* addChildren = 0); Add an object to the viewer, using internal physical IDs; TVirtualViewer3D interface overload - see base/src/TVirtualViewer3D.cxx; for description of viewer architecture. Int_t AddObject(UInt_t physicalID, const TBuffer3D& buffer, Bool_t* addChildren = 0); Add an object to the scene, using an external physical ID; TVirtualViewer3D interface overload - see base/src/TVirtualViewer3D.cxx; for description of viewer architecture. Bool_t OpenComposite(const TBuffer3D& buffer, Bool_t* addChildren = 0); Open new composite container.; TVirtualViewer3D interface overload - see base/src/TVirtualViewer3D.cxx; for description of viewer architecture. void CloseComposite(); Close composite container; TVirtualViewer3D interface overload - see base/src/TVirtualViewer3D.cxx; for description of viewer architecture. void AddCompositeOp(UInt_t operation); Add composite operation used to combine objects added via AddObject; TVirtualViewer3D interface overload - see base/src/TVirtualViewer3D.cxx; for description of viewer architecture. Int_t ValidateObjectBuffer(const TBuffer3D& buffer, Bool_t includeRaw) const; Validate if the passed 'buffer' contains all sections we require to add object.; Returns Int_t combination of TBuffer::ESection flags still required - or; TBuffer3D::kNone if buffer is valid.; If 'includeRaw' is kTRUE check for kRaw/kRawSizes - skip otherwise.; See base/src/TVirtualViewer3D.cxx for description of viewer architecture. TGLLogicalShape* CreateNewLogical(const TBuffer3D& buffer) const; Create and return a new TGLLogicalShape from the supplied buffer. CreateNewPhysical(UInt_t physicalID, const TBuffer3D& buffer, const TGLLogicalShape& logical) const; Create and return a new TGLP",MatchSource.WIKI,root/html528/TGLScenePad.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLScenePad.html
https://root.cern/root/html528/TGLScenePad.html:15092,Integrability,interface,interface,15092,"r description of viewer architecture. Int_t AddObject(const TBuffer3D& buffer, Bool_t* addChildren = 0); Add an object to the viewer, using internal physical IDs; TVirtualViewer3D interface overload - see base/src/TVirtualViewer3D.cxx; for description of viewer architecture. Int_t AddObject(UInt_t physicalID, const TBuffer3D& buffer, Bool_t* addChildren = 0); Add an object to the scene, using an external physical ID; TVirtualViewer3D interface overload - see base/src/TVirtualViewer3D.cxx; for description of viewer architecture. Bool_t OpenComposite(const TBuffer3D& buffer, Bool_t* addChildren = 0); Open new composite container.; TVirtualViewer3D interface overload - see base/src/TVirtualViewer3D.cxx; for description of viewer architecture. void CloseComposite(); Close composite container; TVirtualViewer3D interface overload - see base/src/TVirtualViewer3D.cxx; for description of viewer architecture. void AddCompositeOp(UInt_t operation); Add composite operation used to combine objects added via AddObject; TVirtualViewer3D interface overload - see base/src/TVirtualViewer3D.cxx; for description of viewer architecture. Int_t ValidateObjectBuffer(const TBuffer3D& buffer, Bool_t includeRaw) const; Validate if the passed 'buffer' contains all sections we require to add object.; Returns Int_t combination of TBuffer::ESection flags still required - or; TBuffer3D::kNone if buffer is valid.; If 'includeRaw' is kTRUE check for kRaw/kRawSizes - skip otherwise.; See base/src/TVirtualViewer3D.cxx for description of viewer architecture. TGLLogicalShape* CreateNewLogical(const TBuffer3D& buffer) const; Create and return a new TGLLogicalShape from the supplied buffer. CreateNewPhysical(UInt_t physicalID, const TBuffer3D& buffer, const TGLLogicalShape& logical) const; Create and return a new TGLPhysicalShape with id 'ID', using; 'buffer' placement information (translation etc), and bound to; suppled 'logical'. RootCsg::TBaseMesh* BuildComposite(); Build and return composite shape mesh",MatchSource.WIKI,root/html528/TGLScenePad.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLScenePad.html
https://root.cern/root/html528/TGLScenePad.html:16683,Integrability,interface,interface,16683,"d object.; Returns Int_t combination of TBuffer::ESection flags still required - or; TBuffer3D::kNone if buffer is valid.; If 'includeRaw' is kTRUE check for kRaw/kRawSizes - skip otherwise.; See base/src/TVirtualViewer3D.cxx for description of viewer architecture. TGLLogicalShape* CreateNewLogical(const TBuffer3D& buffer) const; Create and return a new TGLLogicalShape from the supplied buffer. CreateNewPhysical(UInt_t physicalID, const TBuffer3D& buffer, const TGLLogicalShape& logical) const; Create and return a new TGLPhysicalShape with id 'ID', using; 'buffer' placement information (translation etc), and bound to; suppled 'logical'. RootCsg::TBaseMesh* BuildComposite(); Build and return composite shape mesh. TGLLogicalShape* AttemptDirectRenderer(TObject* id); Try to construct an appropriate logical-shape sub-class based; on id'class, following convention that SomeClassGL is a suitable; renderer for class SomeClass. TGLScenePad(const TGLScenePad& ). TGLScenePad& operator=(const TGLScenePad& ). virtual ~TGLScenePad(); {}. TVirtualPad* GetPad() const; void SetPad(TVirtualPad* p) { fPad = p; /* also need to drop contents */ }. { return fPad; }. Bool_t GetSmartRefresh() const; { return fSmartRefresh; }. void SetSmartRefresh(Bool_t smart_ref); { fSmartRefresh = smart_ref; }. Bool_t CanLoopOnPrimitives() const; TVirtualViewer3D interface. { return kTRUE; }. Int_t DistancetoPrimitive(Int_t , Int_t ); For now handled by viewer. { return 9999; }. void ExecuteEvent(Int_t , Int_t , Int_t ); {}. Bool_t PreferLocalFrame() const; { return kTRUE; }. Bool_t BuildingScene() const; { return CurrentLock() == kModifyLock; }. » Author: Matevz Tadel, Jun 2007 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/gl:$Id: TGLScenePad.h 36884 2010-11-23 17:52:08Z matevz $ » Last generated: 2010-11-24 09:09; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html528/TGLScenePad.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLScenePad.html
https://root.cern/root/html528/TGLScenePad.html:12486,Performance,cache,cache,12486,"fDoFrustumCheckPerform global frustum-check in UpdateSceneInfo(); TGLContextIdentity*TGLScene::fGLCtxIdentity; Bool_tTGLScene::fInSmartRefresh!; Bool_tfInternalPIDs! using internal physical IDs; Short_tTGLSceneBase::fLODScene-lod.; Float_tTGLScene::fLastLineWidthScale; UInt_tfLastPID! last physical ID that was processed in AddObject(); Float_tTGLScene::fLastPointSizeScale; TGLLockable::ELockTGLLockable::fLockLock state.; map<TObject*,TGLLogicalShape*>TGLScene::fLogicalShapes!; UInt_tTGLSceneBase::fMinorStampCounter increased on minimal update.; TStringTGLSceneBase::fNameObject identifier.; UInt_tfNextInternalPID! next internal physical ID (from 1 - 0 reserved); Float_tTGLSceneBase::fOLLineWScene outline line-width.; TVirtualPad*fPad; map<unsigned int,TGLPhysicalShape*>TGLScene::fPhysicalShapes!; UInt_tTGLSceneBase::fSceneIDUnique scene id.; Bool_tTGLSceneBase::fSelectableObjects in the scene are selectable.; Bool_tfSmartRefresh! cache logicals during scene rebuilds; map<TObject*,TGLLogicalShape*>TGLScene::fSmartRefreshCache!; Short_tTGLSceneBase::fStyleScene-style.; UInt_tTGLSceneBase::fTimeStampCounter increased on every update.; TStringTGLSceneBase::fTitleObject title.; list<TGLViewerBase*>TGLSceneBase::fViewers; Float_tTGLSceneBase::fWFLineWScene wire-frame line-width. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLScenePad(TVirtualPad* pad); Constructor. void AddHistoPhysical(TGLLogicalShape* log); Scale and rotate a histo object to mimic placement in canvas. void SubPadPaint(TVirtualPad* pad); Iterate over pad-primitves and import them. void ObjectPaint(TObject* obj, Option_t* opt = """"); Override of virtual TVirtualViewer3D::ObjectPaint().; Special handling of 2D/3D histograms to activate Timur's; histo-painters. void PadPaintFromViewer(TGLViewer* viewer); Entry point for requesting update of scene's contents from; gl-viewer. void PadPaint(TVirtualPad* pad); Entry point for updating scene contents via VirtualViewer3",MatchSource.WIKI,root/html528/TGLScenePad.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLScenePad.html
https://root.cern/root/html528/TGLScenePad.html:13794,Performance,cache,cache,13794,"tTGLSceneBase::fWFLineWScene wire-frame line-width. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLScenePad(TVirtualPad* pad); Constructor. void AddHistoPhysical(TGLLogicalShape* log); Scale and rotate a histo object to mimic placement in canvas. void SubPadPaint(TVirtualPad* pad); Iterate over pad-primitves and import them. void ObjectPaint(TObject* obj, Option_t* opt = """"); Override of virtual TVirtualViewer3D::ObjectPaint().; Special handling of 2D/3D histograms to activate Timur's; histo-painters. void PadPaintFromViewer(TGLViewer* viewer); Entry point for requesting update of scene's contents from; gl-viewer. void PadPaint(TVirtualPad* pad); Entry point for updating scene contents via VirtualViewer3D; interface.; For now this is handled by TGLViewer as it remains; the 'Viewer3D' of given pad. void BeginScene(); Start building of the scene.; Old contents is dropped, unless smart-refresh is in active. Then; the object supporting it are kept in a cache and possibly reused. TVirtualViewer3D interface overload - see base/src/TVirtualViewer3D.cxx; for description of viewer architecture. void EndScene(); End building of the scene.; TVirtualViewer3D interface overload - see base/src/TVirtualViewer3D.cxx; for description of viewer architecture. Int_t AddObject(const TBuffer3D& buffer, Bool_t* addChildren = 0); Add an object to the viewer, using internal physical IDs; TVirtualViewer3D interface overload - see base/src/TVirtualViewer3D.cxx; for description of viewer architecture. Int_t AddObject(UInt_t physicalID, const TBuffer3D& buffer, Bool_t* addChildren = 0); Add an object to the scene, using an external physical ID; TVirtualViewer3D interface overload - see base/src/TVirtualViewer3D.cxx; for description of viewer architecture. Bool_t OpenComposite(const TBuffer3D& buffer, Bool_t* addChildren = 0); Open new composite container.; TVirtualViewer3D interface overload - see base/src/TVirtualViewer3D.cxx; for description of v",MatchSource.WIKI,root/html528/TGLScenePad.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLScenePad.html
https://root.cern/root/html528/TGLScenePad.html:11226,Security,access,access,11226,"t TBuffer3D& buffer, const TGLLogicalShape& logical) const; virtual voidTGLScene::DestroyPhysicalInternal(TGLScene::PhysicalShapeMapIt_t pit); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(); voidTGLScene::ReleaseGLCtxIdentity(); Int_tValidateObjectBuffer(const TBuffer3D& buffer, Bool_t includeRaw) const. private:. TGLScenePad(const TGLScenePad&); TGLScenePad&operator=(const TGLScenePad&). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };; enum TGLLockable::ELock { kUnlocked; kDrawLock; kSelectLock; kModifyLock; };. protected:. Int_tfAcceptedPhysicals; Bool_tTGLSceneBase::fAutoDestruct; TGLBoundingBoxTGLSceneBase::fBoundingBoxbounding box for scene (axis aligned) - lazy update - use BoundingBox() to access; Bool_tTGLSceneBase::fBoundingBoxValidbounding box valid?; UInt_tfCSLevel; vector<CSPart_t>fCSTokens; TGLClip*TGLSceneBase::fClipScene clipping-plane.; TGLFaceSet*fComposite! Paritally created composite; Bool_tTGLSceneBase::fDoClipCheckPerform global clip-plane-check in UpdateSceneInfo(); Bool_tTGLSceneBase::fDoFrustumCheckPerform global frustum-check in UpdateSceneInfo(); TGLContextIdentity*TGLScene::fGLCtxIdentity; Bool_tTGLScene::fInSmartRefresh!; Bool_tfInternalPIDs! using internal physical IDs; Short_tTGLSceneBase::fLODScene-lod.; Float_tTGLScene::fLastLineWidthScale; UInt_tfLastPID! last physical ID that was processed in AddObject(); Float_tTGLScene::fLastPointSizeScale; TGLLockable::ELockTGLLockable::fLockLock state.; map<TObject*,TGLLogicalShape*>TGLScene::fLogicalShapes!; UInt_tTGLSceneBase::fMinorStampCounter increased on minimal update.; TStringTGLSceneBase::fNameObject identifier.; UInt_tfNextInternalPID! next internal physical ID (from 1 - 0 reserved); Floa",MatchSource.WIKI,root/html528/TGLScenePad.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLScenePad.html
https://root.cern/root/html528/TGLScenePad.html:670,Testability,log,log,670," TGLScenePad(TVirtualPad* pad); virtual~TGLScenePad(); voidTObject::AbstractMethod(const char* method) const; virtual voidAddCompositeOp(UInt_t operation); voidAddHistoPhysical(TGLLogicalShape* log); virtual Int_tAddObject(const TBuffer3D& buffer, Bool_t* addChildren = 0); virtual Int_tAddObject(UInt_t physicalID, const TBuffer3D& buffer, Bool_t* addChildren = 0); voidTGLSceneBase::AddViewer(TGLViewerBase* viewer); virtual voidTGLScene::AdoptLogical(TGLLogicalShape& shape); virtual voidTGLScene::AdoptPhysical(TGLPhysicalShape& shape); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBeginScene(); UInt_tTGLScene::BeginSmartRefresh(); virtual Bool_tTGLScene::BeginUpdate(); const TGLBoundingBox&TGLSceneBase::BoundingBox() const; virtual voidTObject::Browse(TBrowser* b); virtual Bool_tBuildingScene() const; virtual voidTGLScene::CalcBoundingBox() const; virtual Bool_tCanLoopOnPrimitives() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); TGLClip*TGLSceneBase::Clip() const; virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidCloseComposite(); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual TGLScene::TSceneInfo*TGLScene::CreateSceneInfo(TGLViewerBase* view); TGLLockable::ELockTGLLockable::CurrentLock() const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Bool_tTGLScene::DestroyLogical(TObject* logid, Bool_t mus",MatchSource.WIKI,root/html528/TGLScenePad.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLScenePad.html
https://root.cern/root/html528/TGLScenePad.html:1984,Testability,log,logid,1984,"cal(TGLPhysicalShape& shape); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBeginScene(); UInt_tTGLScene::BeginSmartRefresh(); virtual Bool_tTGLScene::BeginUpdate(); const TGLBoundingBox&TGLSceneBase::BoundingBox() const; virtual voidTObject::Browse(TBrowser* b); virtual Bool_tBuildingScene() const; virtual voidTGLScene::CalcBoundingBox() const; virtual Bool_tCanLoopOnPrimitives() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); TGLClip*TGLSceneBase::Clip() const; virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidCloseComposite(); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual TGLScene::TSceneInfo*TGLScene::CreateSceneInfo(TGLViewerBase* view); TGLLockable::ELockTGLLockable::CurrentLock() const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Bool_tTGLScene::DestroyLogical(TObject* logid, Bool_t mustFind = kTRUE); virtual Int_tTGLScene::DestroyLogicals(); virtual Bool_tTGLScene::DestroyPhysical(UInt_t phid); virtual Int_tTGLScene::DestroyPhysicals(); virtual Int_tDistancetoPrimitive(Int_t, Int_t); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTVirtualViewer3D::DrawViewer(); virtual voidTObject::Dump() constMENU ; voidTGLScene::DumpMapSizes() const; virtual voidEndScene(); voidTGLScene::EndSmartRefresh(); virtual voidTGLScene::EndUpdate(Bool_t minorChange = kTRUE, Bool_t sceneChanged = kTRUE, Bool_t updateViewers = kTRUE); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t, Int_t, Int_t); virtual voidTObject::Fatal(c",MatchSource.WIKI,root/html528/TGLScenePad.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLScenePad.html
https://root.cern/root/html528/TGLScenePad.html:3088,Testability,log,logid,3088,"hysical(UInt_t phid); virtual Int_tTGLScene::DestroyPhysicals(); virtual Int_tDistancetoPrimitive(Int_t, Int_t); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTVirtualViewer3D::DrawViewer(); virtual voidTObject::Dump() constMENU ; voidTGLScene::DumpMapSizes() const; virtual voidEndScene(); voidTGLScene::EndSmartRefresh(); virtual voidTGLScene::EndUpdate(Bool_t minorChange = kTRUE, Bool_t sceneChanged = kTRUE, Bool_t updateViewers = kTRUE); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t, Int_t, Int_t); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGLLogicalShape*TGLScene::FindLogical(TObject* logid) const; TGLLogicalShape*TGLScene::FindLogicalSmartRefresh(TObject* ID) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TGLPhysicalShape*TGLScene::FindPhysical(UInt_t phid) const; Bool_tTGLSceneBase::GetAutoDestruct() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); TGLContextIdentity*TGLScene::GetGLCtxIdentity() const; virtual const char*TObject::GetIconName() const; virtual UInt_tTGLScene::GetMaxPhysicalID(); UInt_tTGLSceneBase::GetMinorStamp() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TVirtualPad*GetPad() const; Bool_tTGLSceneBase::GetSelectable() const; Bool_tGetSmartRefresh() const; UInt_tTGLSceneBase::GetTimeStamp() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::",MatchSource.WIKI,root/html528/TGLScenePad.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLScenePad.html
https://root.cern/root/html528/TGLScenePad.html:9148,Testability,log,logid,9148,"; voidTObject::SetBit(UInt_t f, Bool_t set); voidTGLSceneBase::SetClip(TGLClip* p); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTGLSceneBase::SetLOD(Short_t lod); virtual voidTGLSceneBase::SetName(const char* name); virtual voidTGLSceneBase::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidTGLSceneBase::SetSelectable(Bool_t a); voidSetSmartRefresh(Bool_t smart_ref); voidTGLSceneBase::SetStyle(Short_t st); virtual voidTGLSceneBase::SetTitle(const char* title); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); UInt_tTGLScene::SizeOfScene() const; virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); Short_tTGLSceneBase::Style() const; voidSubPadPaint(TVirtualPad* pad); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; voidTGLSceneBase::TagViewersChanged(); Bool_tTGLLockable::TakeLock(TGLLockable::ELock lock) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTGLScene::UpdateLogical(TObject* logid); virtual voidTGLScene::UpdatePhysical(UInt_t phid, Double_t* trans, UChar_t* col); virtual voidTGLScene::UpdatePhysical(UInt_t phid, Double_t* trans, Color_t cidx = -1, UChar_t transp = 0); virtual voidTGLScene::UpdatePhysioLogical(TObject* logid, Double_t* trans, UChar_t* col); virtual voidTGLScene::UpdatePhysioLogical(TObject* logid, Double_t* trans, Color_t cidx, UChar_t transp); virtual voidTGLScene::UpdateSceneInfo(TGLRnrCtx& rnrCtx); virtual voidTObject::UseCurrentStyle(); static TVirtualViewer3D*TVirtualViewer3D::Viewer3D(TVirtualPad* pad = 0, Option_t* type = """"); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html528/TGLScenePad.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLScenePad.html
https://root.cern/root/html528/TGLScenePad.html:9396,Testability,log,logid,9396,"; voidTObject::SetBit(UInt_t f, Bool_t set); voidTGLSceneBase::SetClip(TGLClip* p); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTGLSceneBase::SetLOD(Short_t lod); virtual voidTGLSceneBase::SetName(const char* name); virtual voidTGLSceneBase::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidTGLSceneBase::SetSelectable(Bool_t a); voidSetSmartRefresh(Bool_t smart_ref); voidTGLSceneBase::SetStyle(Short_t st); virtual voidTGLSceneBase::SetTitle(const char* title); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); UInt_tTGLScene::SizeOfScene() const; virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); Short_tTGLSceneBase::Style() const; voidSubPadPaint(TVirtualPad* pad); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; voidTGLSceneBase::TagViewersChanged(); Bool_tTGLLockable::TakeLock(TGLLockable::ELock lock) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTGLScene::UpdateLogical(TObject* logid); virtual voidTGLScene::UpdatePhysical(UInt_t phid, Double_t* trans, UChar_t* col); virtual voidTGLScene::UpdatePhysical(UInt_t phid, Double_t* trans, Color_t cidx = -1, UChar_t transp = 0); virtual voidTGLScene::UpdatePhysioLogical(TObject* logid, Double_t* trans, UChar_t* col); virtual voidTGLScene::UpdatePhysioLogical(TObject* logid, Double_t* trans, Color_t cidx, UChar_t transp); virtual voidTGLScene::UpdateSceneInfo(TGLRnrCtx& rnrCtx); virtual voidTObject::UseCurrentStyle(); static TVirtualViewer3D*TVirtualViewer3D::Viewer3D(TVirtualPad* pad = 0, Option_t* type = """"); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html528/TGLScenePad.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLScenePad.html
https://root.cern/root/html528/TGLScenePad.html:9486,Testability,log,logid,9486,"; voidTObject::SetBit(UInt_t f, Bool_t set); voidTGLSceneBase::SetClip(TGLClip* p); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTGLSceneBase::SetLOD(Short_t lod); virtual voidTGLSceneBase::SetName(const char* name); virtual voidTGLSceneBase::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidTGLSceneBase::SetSelectable(Bool_t a); voidSetSmartRefresh(Bool_t smart_ref); voidTGLSceneBase::SetStyle(Short_t st); virtual voidTGLSceneBase::SetTitle(const char* title); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); UInt_tTGLScene::SizeOfScene() const; virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); Short_tTGLSceneBase::Style() const; voidSubPadPaint(TVirtualPad* pad); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; voidTGLSceneBase::TagViewersChanged(); Bool_tTGLLockable::TakeLock(TGLLockable::ELock lock) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTGLScene::UpdateLogical(TObject* logid); virtual voidTGLScene::UpdatePhysical(UInt_t phid, Double_t* trans, UChar_t* col); virtual voidTGLScene::UpdatePhysical(UInt_t phid, Double_t* trans, Color_t cidx = -1, UChar_t transp = 0); virtual voidTGLScene::UpdatePhysioLogical(TObject* logid, Double_t* trans, UChar_t* col); virtual voidTGLScene::UpdatePhysioLogical(TObject* logid, Double_t* trans, Color_t cidx, UChar_t transp); virtual voidTGLScene::UpdateSceneInfo(TGLRnrCtx& rnrCtx); virtual voidTObject::UseCurrentStyle(); static TVirtualViewer3D*TVirtualViewer3D::Viewer3D(TVirtualPad* pad = 0, Option_t* type = """"); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html528/TGLScenePad.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLScenePad.html
https://root.cern/root/html528/TGLScenePad.html:10260,Testability,log,logical,10260,"ans, Color_t cidx = -1, UChar_t transp = 0); virtual voidTGLScene::UpdatePhysioLogical(TObject* logid, Double_t* trans, UChar_t* col); virtual voidTGLScene::UpdatePhysioLogical(TObject* logid, Double_t* trans, Color_t cidx, UChar_t transp); virtual voidTGLScene::UpdateSceneInfo(TGLRnrCtx& rnrCtx); virtual voidTObject::UseCurrentStyle(); static TVirtualViewer3D*TVirtualViewer3D::Viewer3D(TVirtualPad* pad = 0, Option_t* type = """"); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. TGLLogicalShape*AttemptDirectRenderer(TObject* id); RootCsg::TBaseMesh*BuildComposite(); TGLLogicalShape*CreateNewLogical(const TBuffer3D& buffer) const; TGLPhysicalShape*CreateNewPhysical(UInt_t physicalID, const TBuffer3D& buffer, const TGLLogicalShape& logical) const; virtual voidTGLScene::DestroyPhysicalInternal(TGLScene::PhysicalShapeMapIt_t pit); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(); voidTGLScene::ReleaseGLCtxIdentity(); Int_tValidateObjectBuffer(const TBuffer3D& buffer, Bool_t includeRaw) const. private:. TGLScenePad(const TGLScenePad&); TGLScenePad&operator=(const TGLScenePad&). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };; enum TGLLockable::ELock { kUnlocked; kDrawLock; kSelectLock; kModifyLock; };. protected:. Int_tfAcceptedPhysicals; Bool_tTGLSceneBase::fAutoDestruct; TGLBoundingBoxTGLSceneBase::fBoundingBoxbounding box for scene (axis aligned) - lazy update - use BoundingBox() to access; Bool_tTGLSceneBase::fBoundingBoxValidbounding box valid?; UInt_tfCS",MatchSource.WIKI,root/html528/TGLScenePad.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLScenePad.html
https://root.cern/root/html528/TGLScenePad.html:12492,Testability,log,logicals,12492,"fDoFrustumCheckPerform global frustum-check in UpdateSceneInfo(); TGLContextIdentity*TGLScene::fGLCtxIdentity; Bool_tTGLScene::fInSmartRefresh!; Bool_tfInternalPIDs! using internal physical IDs; Short_tTGLSceneBase::fLODScene-lod.; Float_tTGLScene::fLastLineWidthScale; UInt_tfLastPID! last physical ID that was processed in AddObject(); Float_tTGLScene::fLastPointSizeScale; TGLLockable::ELockTGLLockable::fLockLock state.; map<TObject*,TGLLogicalShape*>TGLScene::fLogicalShapes!; UInt_tTGLSceneBase::fMinorStampCounter increased on minimal update.; TStringTGLSceneBase::fNameObject identifier.; UInt_tfNextInternalPID! next internal physical ID (from 1 - 0 reserved); Float_tTGLSceneBase::fOLLineWScene outline line-width.; TVirtualPad*fPad; map<unsigned int,TGLPhysicalShape*>TGLScene::fPhysicalShapes!; UInt_tTGLSceneBase::fSceneIDUnique scene id.; Bool_tTGLSceneBase::fSelectableObjects in the scene are selectable.; Bool_tfSmartRefresh! cache logicals during scene rebuilds; map<TObject*,TGLLogicalShape*>TGLScene::fSmartRefreshCache!; Short_tTGLSceneBase::fStyleScene-style.; UInt_tTGLSceneBase::fTimeStampCounter increased on every update.; TStringTGLSceneBase::fTitleObject title.; list<TGLViewerBase*>TGLSceneBase::fViewers; Float_tTGLSceneBase::fWFLineWScene wire-frame line-width. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLScenePad(TVirtualPad* pad); Constructor. void AddHistoPhysical(TGLLogicalShape* log); Scale and rotate a histo object to mimic placement in canvas. void SubPadPaint(TVirtualPad* pad); Iterate over pad-primitves and import them. void ObjectPaint(TObject* obj, Option_t* opt = """"); Override of virtual TVirtualViewer3D::ObjectPaint().; Special handling of 2D/3D histograms to activate Timur's; histo-painters. void PadPaintFromViewer(TGLViewer* viewer); Entry point for requesting update of scene's contents from; gl-viewer. void PadPaint(TVirtualPad* pad); Entry point for updating scene contents via VirtualViewer3",MatchSource.WIKI,root/html528/TGLScenePad.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLScenePad.html
https://root.cern/root/html528/TGLScenePad.html:13010,Testability,log,log,13010,"; UInt_tTGLSceneBase::fMinorStampCounter increased on minimal update.; TStringTGLSceneBase::fNameObject identifier.; UInt_tfNextInternalPID! next internal physical ID (from 1 - 0 reserved); Float_tTGLSceneBase::fOLLineWScene outline line-width.; TVirtualPad*fPad; map<unsigned int,TGLPhysicalShape*>TGLScene::fPhysicalShapes!; UInt_tTGLSceneBase::fSceneIDUnique scene id.; Bool_tTGLSceneBase::fSelectableObjects in the scene are selectable.; Bool_tfSmartRefresh! cache logicals during scene rebuilds; map<TObject*,TGLLogicalShape*>TGLScene::fSmartRefreshCache!; Short_tTGLSceneBase::fStyleScene-style.; UInt_tTGLSceneBase::fTimeStampCounter increased on every update.; TStringTGLSceneBase::fTitleObject title.; list<TGLViewerBase*>TGLSceneBase::fViewers; Float_tTGLSceneBase::fWFLineWScene wire-frame line-width. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLScenePad(TVirtualPad* pad); Constructor. void AddHistoPhysical(TGLLogicalShape* log); Scale and rotate a histo object to mimic placement in canvas. void SubPadPaint(TVirtualPad* pad); Iterate over pad-primitves and import them. void ObjectPaint(TObject* obj, Option_t* opt = """"); Override of virtual TVirtualViewer3D::ObjectPaint().; Special handling of 2D/3D histograms to activate Timur's; histo-painters. void PadPaintFromViewer(TGLViewer* viewer); Entry point for requesting update of scene's contents from; gl-viewer. void PadPaint(TVirtualPad* pad); Entry point for updating scene contents via VirtualViewer3D; interface.; For now this is handled by TGLViewer as it remains; the 'Viewer3D' of given pad. void BeginScene(); Start building of the scene.; Old contents is dropped, unless smart-refresh is in active. Then; the object supporting it are kept in a cache and possibly reused. TVirtualViewer3D interface overload - see base/src/TVirtualViewer3D.cxx; for description of viewer architecture. void EndScene(); End building of the scene.; TVirtualViewer3D interface overload - see bas",MatchSource.WIKI,root/html528/TGLScenePad.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLScenePad.html
https://root.cern/root/html528/TGLScenePad.html:15819,Testability,log,logical,15819,"irtualViewer3D interface overload - see base/src/TVirtualViewer3D.cxx; for description of viewer architecture. void AddCompositeOp(UInt_t operation); Add composite operation used to combine objects added via AddObject; TVirtualViewer3D interface overload - see base/src/TVirtualViewer3D.cxx; for description of viewer architecture. Int_t ValidateObjectBuffer(const TBuffer3D& buffer, Bool_t includeRaw) const; Validate if the passed 'buffer' contains all sections we require to add object.; Returns Int_t combination of TBuffer::ESection flags still required - or; TBuffer3D::kNone if buffer is valid.; If 'includeRaw' is kTRUE check for kRaw/kRawSizes - skip otherwise.; See base/src/TVirtualViewer3D.cxx for description of viewer architecture. TGLLogicalShape* CreateNewLogical(const TBuffer3D& buffer) const; Create and return a new TGLLogicalShape from the supplied buffer. CreateNewPhysical(UInt_t physicalID, const TBuffer3D& buffer, const TGLLogicalShape& logical) const; Create and return a new TGLPhysicalShape with id 'ID', using; 'buffer' placement information (translation etc), and bound to; suppled 'logical'. RootCsg::TBaseMesh* BuildComposite(); Build and return composite shape mesh. TGLLogicalShape* AttemptDirectRenderer(TObject* id); Try to construct an appropriate logical-shape sub-class based; on id'class, following convention that SomeClassGL is a suitable; renderer for class SomeClass. TGLScenePad(const TGLScenePad& ). TGLScenePad& operator=(const TGLScenePad& ). virtual ~TGLScenePad(); {}. TVirtualPad* GetPad() const; void SetPad(TVirtualPad* p) { fPad = p; /* also need to drop contents */ }. { return fPad; }. Bool_t GetSmartRefresh() const; { return fSmartRefresh; }. void SetSmartRefresh(Bool_t smart_ref); { fSmartRefresh = smart_ref; }. Bool_t CanLoopOnPrimitives() const; TVirtualViewer3D interface. { return kTRUE; }. Int_t DistancetoPrimitive(Int_t , Int_t ); For now handled by viewer. { return 9999; }. void ExecuteEvent(Int_t , Int_t , Int_t ); {}. Bool_t P",MatchSource.WIKI,root/html528/TGLScenePad.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLScenePad.html
https://root.cern/root/html528/TGLScenePad.html:15970,Testability,log,logical,15970,"irtualViewer3D interface overload - see base/src/TVirtualViewer3D.cxx; for description of viewer architecture. void AddCompositeOp(UInt_t operation); Add composite operation used to combine objects added via AddObject; TVirtualViewer3D interface overload - see base/src/TVirtualViewer3D.cxx; for description of viewer architecture. Int_t ValidateObjectBuffer(const TBuffer3D& buffer, Bool_t includeRaw) const; Validate if the passed 'buffer' contains all sections we require to add object.; Returns Int_t combination of TBuffer::ESection flags still required - or; TBuffer3D::kNone if buffer is valid.; If 'includeRaw' is kTRUE check for kRaw/kRawSizes - skip otherwise.; See base/src/TVirtualViewer3D.cxx for description of viewer architecture. TGLLogicalShape* CreateNewLogical(const TBuffer3D& buffer) const; Create and return a new TGLLogicalShape from the supplied buffer. CreateNewPhysical(UInt_t physicalID, const TBuffer3D& buffer, const TGLLogicalShape& logical) const; Create and return a new TGLPhysicalShape with id 'ID', using; 'buffer' placement information (translation etc), and bound to; suppled 'logical'. RootCsg::TBaseMesh* BuildComposite(); Build and return composite shape mesh. TGLLogicalShape* AttemptDirectRenderer(TObject* id); Try to construct an appropriate logical-shape sub-class based; on id'class, following convention that SomeClassGL is a suitable; renderer for class SomeClass. TGLScenePad(const TGLScenePad& ). TGLScenePad& operator=(const TGLScenePad& ). virtual ~TGLScenePad(); {}. TVirtualPad* GetPad() const; void SetPad(TVirtualPad* p) { fPad = p; /* also need to drop contents */ }. { return fPad; }. Bool_t GetSmartRefresh() const; { return fSmartRefresh; }. void SetSmartRefresh(Bool_t smart_ref); { fSmartRefresh = smart_ref; }. Bool_t CanLoopOnPrimitives() const; TVirtualViewer3D interface. { return kTRUE; }. Int_t DistancetoPrimitive(Int_t , Int_t ); For now handled by viewer. { return 9999; }. void ExecuteEvent(Int_t , Int_t , Int_t ); {}. Bool_t P",MatchSource.WIKI,root/html528/TGLScenePad.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLScenePad.html
https://root.cern/root/html528/TGLScenePad.html:16142,Testability,log,logical-shape,16142,"n of viewer architecture. Int_t ValidateObjectBuffer(const TBuffer3D& buffer, Bool_t includeRaw) const; Validate if the passed 'buffer' contains all sections we require to add object.; Returns Int_t combination of TBuffer::ESection flags still required - or; TBuffer3D::kNone if buffer is valid.; If 'includeRaw' is kTRUE check for kRaw/kRawSizes - skip otherwise.; See base/src/TVirtualViewer3D.cxx for description of viewer architecture. TGLLogicalShape* CreateNewLogical(const TBuffer3D& buffer) const; Create and return a new TGLLogicalShape from the supplied buffer. CreateNewPhysical(UInt_t physicalID, const TBuffer3D& buffer, const TGLLogicalShape& logical) const; Create and return a new TGLPhysicalShape with id 'ID', using; 'buffer' placement information (translation etc), and bound to; suppled 'logical'. RootCsg::TBaseMesh* BuildComposite(); Build and return composite shape mesh. TGLLogicalShape* AttemptDirectRenderer(TObject* id); Try to construct an appropriate logical-shape sub-class based; on id'class, following convention that SomeClassGL is a suitable; renderer for class SomeClass. TGLScenePad(const TGLScenePad& ). TGLScenePad& operator=(const TGLScenePad& ). virtual ~TGLScenePad(); {}. TVirtualPad* GetPad() const; void SetPad(TVirtualPad* p) { fPad = p; /* also need to drop contents */ }. { return fPad; }. Bool_t GetSmartRefresh() const; { return fSmartRefresh; }. void SetSmartRefresh(Bool_t smart_ref); { fSmartRefresh = smart_ref; }. Bool_t CanLoopOnPrimitives() const; TVirtualViewer3D interface. { return kTRUE; }. Int_t DistancetoPrimitive(Int_t , Int_t ); For now handled by viewer. { return 9999; }. void ExecuteEvent(Int_t , Int_t , Int_t ); {}. Bool_t PreferLocalFrame() const; { return kTRUE; }. Bool_t BuildingScene() const; { return CurrentLock() == kModifyLock; }. » Author: Matevz Tadel, Jun 2007 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/gl:$Id: TGLScenePad.h 36884 2010-11-23 17:52:08Z matevz $ » Last generated:",MatchSource.WIKI,root/html528/TGLScenePad.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLScenePad.html
https://root.cern/root/html528/TGLScene__TSceneInfo.html:4082,Deployability,update,update,4082,"hape& shape, Short_t lod); voidTGLSceneInfo::UpdateTimeouted(); Bool_tTGLSceneInfo::ViewCheck() const; voidTGLSceneInfo::ViewCheck(Bool_t c); Float_tTGLSceneInfo::WFLineW() const. protected:. voidClearDrawElementPtrVec(TGLScene::DrawElementPtrVec_t& vec, Int_t maxSize); voidClearDrawElementVec(TGLScene::DrawElementVec_t& vec, Int_t maxSize). private:. Bool_tCmpDrawElements(const TGLScene::DrawElement_t& de1, const TGLScene::DrawElement_t& de2). Data Members; public:. enum TGLSceneInfo::EClipTest { kClipNone; kClipOutside; kClipInside; };. public:. Int_tfAsPixelCnt; map<TClass*,UInt_t>fByShapeCnt; UInt_tfMinorStamp; Int_tfOpaqueCnt; TGLScene::DrawElementPtrVec_tfOpaqueElements; TGLScene::DrawElementPtrVec_tfSelOpaqueElements; TGLScene::DrawElementPtrVec_tfSelTranspElements; TGLScene::ShapeVec_tfShapesOfInterest; Int_tfTranspCnt; TGLScene::DrawElementPtrVec_tfTranspElements; TGLScene::DrawElementVec_tfVisibleElements. protected:. Bool_tTGLSceneInfo::fActiveShow fScene in fViewer; UInt_tTGLSceneInfo::fCameraStampCamera's time-stamp on last update.; TGLClip*TGLSceneInfo::fClipOptional override of clipping-plane; Char_tTGLSceneInfo::fClipModeClipping mode, can be disbled.; TGLPlaneSet_tTGLSceneInfo::fClipPlanesClipping planes from clip-object; which planes are kept depends on inside/outside mode.; UInt_tTGLSceneInfo::fClipStampClip's time-stamp on last update.; TGLPlaneSet_tTGLSceneInfo::fFrustumPlanesClipping planes defined by frustum; only those intersecting the scene volume are kept.; Bool_tTGLSceneInfo::fInClipIs scene contained within clipping-volume.; Bool_tTGLSceneInfo::fInFrustumIs scene intersecting view-frustum.; Short_tTGLSceneInfo::fLODOptional override of scene lod; TGLCamera*TGLSceneInfo::fLastCameraLast camera used.; TGLClip*TGLSceneInfo::fLastClipLast combined viewer/scene clip (set in scene::update); Short_tTGLSceneInfo::fLastLODLast combined viewer/scene lod (set in scene::lodify-scene-info).; Float_tTGLSceneInfo::fLastOLLineWLast combined viewer/scene o",MatchSource.WIKI,root/html528/TGLScene__TSceneInfo.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLScene__TSceneInfo.html
https://root.cern/root/html528/TGLScene__TSceneInfo.html:4399,Deployability,update,update,4399,"private:. Bool_tCmpDrawElements(const TGLScene::DrawElement_t& de1, const TGLScene::DrawElement_t& de2). Data Members; public:. enum TGLSceneInfo::EClipTest { kClipNone; kClipOutside; kClipInside; };. public:. Int_tfAsPixelCnt; map<TClass*,UInt_t>fByShapeCnt; UInt_tfMinorStamp; Int_tfOpaqueCnt; TGLScene::DrawElementPtrVec_tfOpaqueElements; TGLScene::DrawElementPtrVec_tfSelOpaqueElements; TGLScene::DrawElementPtrVec_tfSelTranspElements; TGLScene::ShapeVec_tfShapesOfInterest; Int_tfTranspCnt; TGLScene::DrawElementPtrVec_tfTranspElements; TGLScene::DrawElementVec_tfVisibleElements. protected:. Bool_tTGLSceneInfo::fActiveShow fScene in fViewer; UInt_tTGLSceneInfo::fCameraStampCamera's time-stamp on last update.; TGLClip*TGLSceneInfo::fClipOptional override of clipping-plane; Char_tTGLSceneInfo::fClipModeClipping mode, can be disbled.; TGLPlaneSet_tTGLSceneInfo::fClipPlanesClipping planes from clip-object; which planes are kept depends on inside/outside mode.; UInt_tTGLSceneInfo::fClipStampClip's time-stamp on last update.; TGLPlaneSet_tTGLSceneInfo::fFrustumPlanesClipping planes defined by frustum; only those intersecting the scene volume are kept.; Bool_tTGLSceneInfo::fInClipIs scene contained within clipping-volume.; Bool_tTGLSceneInfo::fInFrustumIs scene intersecting view-frustum.; Short_tTGLSceneInfo::fLODOptional override of scene lod; TGLCamera*TGLSceneInfo::fLastCameraLast camera used.; TGLClip*TGLSceneInfo::fLastClipLast combined viewer/scene clip (set in scene::update); Short_tTGLSceneInfo::fLastLODLast combined viewer/scene lod (set in scene::lodify-scene-info).; Float_tTGLSceneInfo::fLastOLLineWLast combined viewer/scene outline line-width (set in scene::pre-draw).; Short_tTGLSceneInfo::fLastStyleLast combined viewer/scene style (set in scene::pre-draw).; Float_tTGLSceneInfo::fLastWFLineWLast combined viewer/scene wire-frame line-width (set in scene::pre-draw).; Float_tTGLSceneInfo::fOLLineWOptional override of scene outline line-width; TGLSceneBase*TGLSceneIn",MatchSource.WIKI,root/html528/TGLScene__TSceneInfo.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLScene__TSceneInfo.html
https://root.cern/root/html528/TGLScene__TSceneInfo.html:4864,Deployability,update,update,4864,"ne::DrawElementPtrVec_tfTranspElements; TGLScene::DrawElementVec_tfVisibleElements. protected:. Bool_tTGLSceneInfo::fActiveShow fScene in fViewer; UInt_tTGLSceneInfo::fCameraStampCamera's time-stamp on last update.; TGLClip*TGLSceneInfo::fClipOptional override of clipping-plane; Char_tTGLSceneInfo::fClipModeClipping mode, can be disbled.; TGLPlaneSet_tTGLSceneInfo::fClipPlanesClipping planes from clip-object; which planes are kept depends on inside/outside mode.; UInt_tTGLSceneInfo::fClipStampClip's time-stamp on last update.; TGLPlaneSet_tTGLSceneInfo::fFrustumPlanesClipping planes defined by frustum; only those intersecting the scene volume are kept.; Bool_tTGLSceneInfo::fInClipIs scene contained within clipping-volume.; Bool_tTGLSceneInfo::fInFrustumIs scene intersecting view-frustum.; Short_tTGLSceneInfo::fLODOptional override of scene lod; TGLCamera*TGLSceneInfo::fLastCameraLast camera used.; TGLClip*TGLSceneInfo::fLastClipLast combined viewer/scene clip (set in scene::update); Short_tTGLSceneInfo::fLastLODLast combined viewer/scene lod (set in scene::lodify-scene-info).; Float_tTGLSceneInfo::fLastOLLineWLast combined viewer/scene outline line-width (set in scene::pre-draw).; Short_tTGLSceneInfo::fLastStyleLast combined viewer/scene style (set in scene::pre-draw).; Float_tTGLSceneInfo::fLastWFLineWLast combined viewer/scene wire-frame line-width (set in scene::pre-draw).; Float_tTGLSceneInfo::fOLLineWOptional override of scene outline line-width; TGLSceneBase*TGLSceneInfo::fScene; UInt_tTGLSceneInfo::fSceneStampScene's time-stamp on last update.; Short_tTGLSceneInfo::fStyleOptional override of scene style; TGLBoundingBoxTGLSceneInfo::fTransformedBBox; Bool_tTGLSceneInfo::fUpdateTimeoutedSet if update was interrupted.; Bool_tTGLSceneInfo::fViewCheckViewer side check if render is necessary.; TGLViewerBase*TGLSceneInfo::fViewer; Float_tTGLSceneInfo::fWFLineWOptional override of scene wire-frame line-width. Class Charts. Inheritance; Inherited Members; Includes; Lib",MatchSource.WIKI,root/html528/TGLScene__TSceneInfo.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLScene__TSceneInfo.html
https://root.cern/root/html528/TGLScene__TSceneInfo.html:5444,Deployability,update,update,5444,":fClipStampClip's time-stamp on last update.; TGLPlaneSet_tTGLSceneInfo::fFrustumPlanesClipping planes defined by frustum; only those intersecting the scene volume are kept.; Bool_tTGLSceneInfo::fInClipIs scene contained within clipping-volume.; Bool_tTGLSceneInfo::fInFrustumIs scene intersecting view-frustum.; Short_tTGLSceneInfo::fLODOptional override of scene lod; TGLCamera*TGLSceneInfo::fLastCameraLast camera used.; TGLClip*TGLSceneInfo::fLastClipLast combined viewer/scene clip (set in scene::update); Short_tTGLSceneInfo::fLastLODLast combined viewer/scene lod (set in scene::lodify-scene-info).; Float_tTGLSceneInfo::fLastOLLineWLast combined viewer/scene outline line-width (set in scene::pre-draw).; Short_tTGLSceneInfo::fLastStyleLast combined viewer/scene style (set in scene::pre-draw).; Float_tTGLSceneInfo::fLastWFLineWLast combined viewer/scene wire-frame line-width (set in scene::pre-draw).; Float_tTGLSceneInfo::fOLLineWOptional override of scene outline line-width; TGLSceneBase*TGLSceneInfo::fScene; UInt_tTGLSceneInfo::fSceneStampScene's time-stamp on last update.; Short_tTGLSceneInfo::fStyleOptional override of scene style; TGLBoundingBoxTGLSceneInfo::fTransformedBBox; Bool_tTGLSceneInfo::fUpdateTimeoutedSet if update was interrupted.; Bool_tTGLSceneInfo::fViewCheckViewer side check if render is necessary.; TGLViewerBase*TGLSceneInfo::fViewer; Float_tTGLSceneInfo::fWFLineWOptional override of scene wire-frame line-width. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Bool_t CmpDrawElements(const TGLScene::DrawElement_t& de1, const TGLScene::DrawElement_t& de2). void ClearDrawElementVec(TGLScene::DrawElementVec_t& vec, Int_t maxSize). void ClearDrawElementPtrVec(TGLScene::DrawElementPtrVec_t& vec, Int_t maxSize). TSceneInfo(TGLViewerBase* view = 0, TGLScene* scene = 0). virtual ~TSceneInfo(). void ClearAfterRebuild(). void ClearAfterUpdate(). void Lodify(TGLRnrCtx& ctx). void PreDraw(). void PostDraw(). void Reset",MatchSource.WIKI,root/html528/TGLScene__TSceneInfo.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLScene__TSceneInfo.html
https://root.cern/root/html528/TGLScene__TSceneInfo.html:5603,Deployability,update,update,5603,"ool_tTGLSceneInfo::fInClipIs scene contained within clipping-volume.; Bool_tTGLSceneInfo::fInFrustumIs scene intersecting view-frustum.; Short_tTGLSceneInfo::fLODOptional override of scene lod; TGLCamera*TGLSceneInfo::fLastCameraLast camera used.; TGLClip*TGLSceneInfo::fLastClipLast combined viewer/scene clip (set in scene::update); Short_tTGLSceneInfo::fLastLODLast combined viewer/scene lod (set in scene::lodify-scene-info).; Float_tTGLSceneInfo::fLastOLLineWLast combined viewer/scene outline line-width (set in scene::pre-draw).; Short_tTGLSceneInfo::fLastStyleLast combined viewer/scene style (set in scene::pre-draw).; Float_tTGLSceneInfo::fLastWFLineWLast combined viewer/scene wire-frame line-width (set in scene::pre-draw).; Float_tTGLSceneInfo::fOLLineWOptional override of scene outline line-width; TGLSceneBase*TGLSceneInfo::fScene; UInt_tTGLSceneInfo::fSceneStampScene's time-stamp on last update.; Short_tTGLSceneInfo::fStyleOptional override of scene style; TGLBoundingBoxTGLSceneInfo::fTransformedBBox; Bool_tTGLSceneInfo::fUpdateTimeoutedSet if update was interrupted.; Bool_tTGLSceneInfo::fViewCheckViewer side check if render is necessary.; TGLViewerBase*TGLSceneInfo::fViewer; Float_tTGLSceneInfo::fWFLineWOptional override of scene wire-frame line-width. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Bool_t CmpDrawElements(const TGLScene::DrawElement_t& de1, const TGLScene::DrawElement_t& de2). void ClearDrawElementVec(TGLScene::DrawElementVec_t& vec, Int_t maxSize). void ClearDrawElementPtrVec(TGLScene::DrawElementPtrVec_t& vec, Int_t maxSize). TSceneInfo(TGLViewerBase* view = 0, TGLScene* scene = 0). virtual ~TSceneInfo(). void ClearAfterRebuild(). void ClearAfterUpdate(). void Lodify(TGLRnrCtx& ctx). void PreDraw(). void PostDraw(). void ResetDrawStats(). void UpdateDrawStats(const TGLPhysicalShape& shape, Short_t lod). void DumpDrawStats(). » Author: Matevz Tadel, Feb 2007 » Copyright (C) 1995-2004, Rene Brun and Fo",MatchSource.WIKI,root/html528/TGLScene__TSceneInfo.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLScene__TSceneInfo.html
https://root.cern/root/html528/TGLScene__TSceneInfo.html:4310,Integrability,depend,depends,4310,"& vec, Int_t maxSize); voidClearDrawElementVec(TGLScene::DrawElementVec_t& vec, Int_t maxSize). private:. Bool_tCmpDrawElements(const TGLScene::DrawElement_t& de1, const TGLScene::DrawElement_t& de2). Data Members; public:. enum TGLSceneInfo::EClipTest { kClipNone; kClipOutside; kClipInside; };. public:. Int_tfAsPixelCnt; map<TClass*,UInt_t>fByShapeCnt; UInt_tfMinorStamp; Int_tfOpaqueCnt; TGLScene::DrawElementPtrVec_tfOpaqueElements; TGLScene::DrawElementPtrVec_tfSelOpaqueElements; TGLScene::DrawElementPtrVec_tfSelTranspElements; TGLScene::ShapeVec_tfShapesOfInterest; Int_tfTranspCnt; TGLScene::DrawElementPtrVec_tfTranspElements; TGLScene::DrawElementVec_tfVisibleElements. protected:. Bool_tTGLSceneInfo::fActiveShow fScene in fViewer; UInt_tTGLSceneInfo::fCameraStampCamera's time-stamp on last update.; TGLClip*TGLSceneInfo::fClipOptional override of clipping-plane; Char_tTGLSceneInfo::fClipModeClipping mode, can be disbled.; TGLPlaneSet_tTGLSceneInfo::fClipPlanesClipping planes from clip-object; which planes are kept depends on inside/outside mode.; UInt_tTGLSceneInfo::fClipStampClip's time-stamp on last update.; TGLPlaneSet_tTGLSceneInfo::fFrustumPlanesClipping planes defined by frustum; only those intersecting the scene volume are kept.; Bool_tTGLSceneInfo::fInClipIs scene contained within clipping-volume.; Bool_tTGLSceneInfo::fInFrustumIs scene intersecting view-frustum.; Short_tTGLSceneInfo::fLODOptional override of scene lod; TGLCamera*TGLSceneInfo::fLastCameraLast camera used.; TGLClip*TGLSceneInfo::fLastClipLast combined viewer/scene clip (set in scene::update); Short_tTGLSceneInfo::fLastLODLast combined viewer/scene lod (set in scene::lodify-scene-info).; Float_tTGLSceneInfo::fLastOLLineWLast combined viewer/scene outline line-width (set in scene::pre-draw).; Short_tTGLSceneInfo::fLastStyleLast combined viewer/scene style (set in scene::pre-draw).; Float_tTGLSceneInfo::fLastWFLineWLast combined viewer/scene wire-frame line-width (set in scene::pre-draw).; Flo",MatchSource.WIKI,root/html528/TGLScene__TSceneInfo.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLScene__TSceneInfo.html
https://root.cern/root/html528/TGLScene__TSceneInfo.html:314,Modifiability,extend,extended,314,. TGLScene::TSceneInfo. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file. viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLScene::TSceneInfo. class TGLScene::TSceneInfo: public TGLSceneInfo. SceneInfo ... extended scene context. Function Members (Methods); public:. virtual~TSceneInfo(); UInt_tTGLSceneInfo::CameraStamp() const; static TClass*TGLSceneInfo::Class(); voidClearAfterRebuild(); voidClearAfterUpdate(); TGLClip*TGLSceneInfo::Clip() const; Char_tTGLSceneInfo::ClipMode() const; voidTGLSceneInfo::ClipMode(Char_t m); vector<TGLPlane>&TGLSceneInfo::ClipPlanes(); UInt_tTGLSceneInfo::ClipStamp() const; voidDumpDrawStats(); vector<TGLPlane>&TGLSceneInfo::FrustumPlanes(); Bool_tTGLSceneInfo::GetActive() const; TGLSceneBase*TGLSceneInfo::GetScene() const; const TGLBoundingBox&TGLSceneInfo::GetTransformedBBox(); TGLViewerBase*TGLSceneInfo::GetViewer() const; Bool_tTGLSceneInfo::HasUpdateTimeouted() const; voidTGLSceneInfo::InClip(Bool_t c); voidTGLSceneInfo::InFrustum(Bool_t f); virtual TClass*TGLSceneInfo::IsA() const; Bool_tTGLSceneInfo::IsInClip() const; Bool_tTGLSceneInfo::IsInFrustum() const; Bool_tTGLSceneInfo::IsVisible() const; TGLCamera*TGLSceneInfo::LastCamera() const; TGLClip*TGLSceneInfo::LastClip() const; Short_tTGLSceneInfo::LastLOD() const; Float_tTGLSceneInfo::LastOLLineW() const; Short_tTGLSceneInfo::LastStyle() const; Float_tTGLSceneInfo::LastWFLineW() const; Short_tTGLSceneInfo::LOD() const; voidLodify(TGLRnrCtx& ctx); Float_tTGLSceneInfo::OLLineW() const; voidPostDraw(); voidPreDraw(); TGLSceneBase&TGLSceneInfo::RefScene() const; TGLViewerBase&TGLSceneInfo::RefViewer() const; voidTGLSceneInfo::ResetCameraStamp(); voidTGLSceneInfo::ResetClipStamp(); voidResetDrawStats(); voidTGLSceneInfo::ResetSceneStamp(); voidTGLSceneInfo::ResetUpdateTimeouted(); UInt_tTGLSceneInfo::SceneStamp() const; voidTGLSceneInfo::SetActive(Bool_t a); voidTGLSceneInfo::,MatchSource.WIKI,root/html528/TGLScene__TSceneInfo.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLScene__TSceneInfo.html
https://root.cern/root/html528/TGLSelectionBuffer.html:463,Security,access,accessors,463,". TGLSelectionBuffer. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLSelectionBuffer. class TGLSelectionBuffer. TGLVertex3. 3 component (x/y/z) vertex class. This is part of collection of simple utility classes for GL only in; TGLUtil.h/cxx. These provide const and non-const accessors Arr() &; CArr() to a GL compatible internal field - so can be used directly; with OpenGL C API calls - which TVector3 etc cannot (easily).; They are not intended to be fully featured just provide minimum; required. Function Members (Methods); public:. TGLSelectionBuffer(); virtual~TGLSelectionBuffer(); static TClass*Class(); const UChar_t*GetPixelColor(Int_t px, Int_t py) const; virtual TClass*IsA() const; voidReadColorBuffer(Int_t width, Int_t height); voidReadColorBuffer(Int_t x, Int_t y, Int_t width, Int_t height); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). private:. TGLSelectionBuffer(const TGLSelectionBuffer&); TGLSelectionBuffer&operator=(const TGLSelectionBuffer&). Data Members; private:. vector<UChar_t>fBuffer; Int_tfHeight; Int_tfWidth. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLSelectionBuffer(); TGLSelectionBuffer constructor. ~TGLSelectionBuffer(); TGLSelectionBuffer destructor. void ReadColorBuffer(Int_t width, Int_t height); Read color buffer. void ReadColorBuffer(Int_t x, Int_t y, Int_t width, Int_t height); Read color buffer. const UChar_t * GetPixelColor(Int_t px, Int_t py) const; Get pixel color. TGLColor& operator=(const TGLSelectionBuffer& ). TGLSelectionBuffer(). » Author: Richard Maunder 25/05/2005 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/gl:$Id: TGLUtil.h 36560 2010-11-09 15:26:23Z couet $ » Last generated: 2010-11-09",MatchSource.WIKI,root/html528/TGLSelectionBuffer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLSelectionBuffer.html
https://root.cern/root/html528/TGLSelectionBuffer.html:375,Usability,simpl,simple,375,". TGLSelectionBuffer. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLSelectionBuffer. class TGLSelectionBuffer. TGLVertex3. 3 component (x/y/z) vertex class. This is part of collection of simple utility classes for GL only in; TGLUtil.h/cxx. These provide const and non-const accessors Arr() &; CArr() to a GL compatible internal field - so can be used directly; with OpenGL C API calls - which TVector3 etc cannot (easily).; They are not intended to be fully featured just provide minimum; required. Function Members (Methods); public:. TGLSelectionBuffer(); virtual~TGLSelectionBuffer(); static TClass*Class(); const UChar_t*GetPixelColor(Int_t px, Int_t py) const; virtual TClass*IsA() const; voidReadColorBuffer(Int_t width, Int_t height); voidReadColorBuffer(Int_t x, Int_t y, Int_t width, Int_t height); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). private:. TGLSelectionBuffer(const TGLSelectionBuffer&); TGLSelectionBuffer&operator=(const TGLSelectionBuffer&). Data Members; private:. vector<UChar_t>fBuffer; Int_tfHeight; Int_tfWidth. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLSelectionBuffer(); TGLSelectionBuffer constructor. ~TGLSelectionBuffer(); TGLSelectionBuffer destructor. void ReadColorBuffer(Int_t width, Int_t height); Read color buffer. void ReadColorBuffer(Int_t x, Int_t y, Int_t width, Int_t height); Read color buffer. const UChar_t * GetPixelColor(Int_t px, Int_t py) const; Get pixel color. TGLColor& operator=(const TGLSelectionBuffer& ). TGLSelectionBuffer(). » Author: Richard Maunder 25/05/2005 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/gl:$Id: TGLUtil.h 36560 2010-11-09 15:26:23Z couet $ » Last generated: 2010-11-09",MatchSource.WIKI,root/html528/TGLSelectionBuffer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLSelectionBuffer.html
https://root.cern/root/html528/TGLSelectRecord.html:458,Usability,simpl,simply,458,". TGLSelectRecord. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLSelectRecord. class TGLSelectRecord: public TGLSelectRecordBase. Standard selection record including information about containing; scene and details ob out selected object (TGLPhysicalShape*,; TObject* or simply a void* for foreign scenes). Function Members (Methods); public:. TGLSelectRecord(); TGLSelectRecord(UInt_t* data); TGLSelectRecord(const TGLSelectRecord& rec); virtual~TGLSelectRecord(); static Bool_tAreSameSelectionWise(const TGLSelectRecord& r1, const TGLSelectRecord& r2); static TClass*Class(); UInt_tTGLSelectRecordBase::GetCurrItem() const; Bool_tGetHighlight() const; UInt_tTGLSelectRecordBase::GetItem(Int_t i) const; UInt_t*TGLSelectRecordBase::GetItems() const; Float_tTGLSelectRecordBase::GetMaxZ() const; Float_tTGLSelectRecordBase::GetMinZ() const; Bool_tGetMultiple() const; Int_tTGLSelectRecordBase::GetN() const; Int_tTGLSelectRecordBase::GetNLeft() const; TObject*GetObject() const; TGLPhysicalShape*GetPhysShape() const; TGLSceneInfo*GetSceneInfo() const; TGLSelectRecord::ESecSelResultGetSecSelResult() const; void*GetSpecific() const; Bool_tGetTransparent() const; virtual TClass*IsA() const; voidTGLSelectRecordBase::NextPos(); TGLSelectRecord&operator=(const TGLSelectRecord& rec); voidTGLSelectRecordBase::PrevPos(); voidPrint(); virtual voidReset(); voidTGLSelectRecordBase::ResetPos(); virtual voidSet(UInt_t* data); voidSetHighlight(Bool_t hlt); voidSetMultiple(Bool_t multi); voidSetObject(TObject* obj); voidSetPhysShape(TGLPhysicalShape* pshp); voidTGLSelectRecordBase::SetRawOnly(UInt_t* data); voidSetSceneInfo(TGLSceneInfo* si); voidSetSecSelResult(TGLSelectRecord::ESecSelResult r); voidSetSpecific(void* spec); voidSetTransparent(Bool_t t); virtual voidShowMembers(TMemberInspector& insp); virtual voi",MatchSource.WIKI,root/html528/TGLSelectRecord.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLSelectRecord.html
https://root.cern/root/html528/TGLSphere.html:1796,Performance,cache,cached,1796,"(Methods); public:. TGLSphere(const TBuffer3DSphere& buffer); ~TGLSphere(); voidTGLLogicalShape::AddRef(TGLPhysicalShape* phys) const; virtual Bool_tTGLLogicalShape::AlwaysSecondarySelect() const; const TGLBoundingBox&TGLLogicalShape::BoundingBox() const; static TClass*Class(); voidTGLLogicalShape::DestroyPhysicals(); virtual voidDirectDraw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DLCacheClear(); virtual voidTGLLogicalShape::DLCacheDrop(); virtual voidTGLLogicalShape::DLCachePurge(); virtual UInt_tDLOffset(Short_t lod) const; virtual voidTGLLogicalShape::Draw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DrawHighlight(TGLRnrCtx& rnrCtx, const TGLPhysicalShape* pshp, Int_t lvl = -1) const; TObject*TGLLogicalShape::GetExternal() const; const TGLPhysicalShape*TGLLogicalShape::GetFirstPhysical() const; TGLScene*TGLLogicalShape::GetScene() const; TObject*TGLLogicalShape::ID() const; virtual Bool_tTGLLogicalShape::IgnoreSizeForOfInterest() const; voidTGLLogicalShape::InvokeContextMenu(TContextMenu& menu, UInt_t x, UInt_t y) const; virtual TClass*IsA() const; virtual Bool_tTGLLogicalShape::KeepDuringSmartRefresh() const; virtual voidTGLLogicalShape::ProcessSelection(TGLRnrCtx& rnrCtx, TGLSelectRecord& rec); virtual Short_tQuantizeShapeLOD(Short_t shapeLOD, Short_t combiLOD) const; UInt_tTGLLogicalShape::Ref() const; Bool_tTGLLogicalShape::SetDLCache(Bool_t cached); virtual Bool_tTGLLogicalShape::ShouldDLCache(const TGLRnrCtx& rnrCtx) const; virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); voidTGLLogicalShape::StrongRef(Bool_t strong) const; voidTGLLogicalShape::SubRef(TGLPhysicalShape* phys) const; virtual TGLLogicalShape::ELODAxesSupportedLODAxes() const; virtual Bool_tTGLLogicalShape::SupportsSecondarySelect() const; UInt_tTGLLogicalShape::UnrefFirstPhysical(); virtual voidTGLLogicalShape::UpdateBoundingBox(); voidTGLLogicalShape::UpdateBoundingBoxesOfPhysicals(). protected:. voidTG",MatchSource.WIKI,root/html528/TGLSphere.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLSphere.html
https://root.cern/root/html528/TGLStopwatch.html:376,Performance,perform,perform,376,". TGLStopwatch. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLStopwatch. class TGLStopwatch. TGLStopwatch. Stopwatch object for timing GL work. We do not use the TStopwatch as; we need to perform GL flushing to get accurate times + we record; timing overheads here. Function Members (Methods); public:. TGLStopwatch(); TGLStopwatch(const TGLStopwatch&); virtual~TGLStopwatch(); static TClass*Class(); Double_tEnd(); virtual TClass*IsA() const; Double_tLap() const; Double_tLastRun() const; TGLStopwatch&operator=(const TGLStopwatch&); virtual voidShowMembers(TMemberInspector& insp); voidStart(); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). private:. Double_tGetClock() const. Data Members; private:. Double_tfEnd! end time (millisec); Double_tfLastRun! time of last run (milisec); Double_tfStart! start time (millisec). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLStopwatch(); Construct stopwatch object. ~TGLStopwatch(); Destroy stopwatch object. void Start(); Start timing. Double_t Lap() const; Return lap time since Start(), in milliseconds. Double_t End(); End timing, return total time since Start(), in milliseconds. Double_t GetClock(void); Get internal clock time, in milliseconds. TGLStopwatch(). Double_t LastRun() const; { return fLastRun; }. » Author: Richard Maunder 25/05/2005 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/gl:$Id: TGLStopwatch.h 23087 2008-04-09 14:10:56Z rdm $ » Last generated: 2010-09-23 20:06; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html528/TGLStopwatch.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLStopwatch.html
https://root.cern/root/html528/TGLSurfacePainter.html:4888,Modifiability,variab,variables,4888,"lPalettefPalette; TGLSurfacePainter::Projection_tfProj; Bool_tfSectionPass; TGL2DArray<Double_t>fTexMap; TGLSurfacePainter::ESurfaceTypefType; Bool_tfUpdateTexMap; list<Projection_t>fXOYProj; list<Projection_t>fXOZProj; list<Projection_t>fYOZProj; static TRandom*fgRandom. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLSurfacePainter(TH1* hist, TGLPlotCamera* camera, TGLPlotCoordinates* coord); Constructor. char * GetPlotInfo(Int_t px, Int_t py); Coords for point on surface under cursor. Bool_t InitGeometry(); Set mesh, normals. void StartPan(Int_t px, Int_t py); User clicks right mouse button (in a pad). void Pan(Int_t px, Int_t py); User's moving mouse cursor, with middle mouse button pressed (for pad).; Calculate 3d shift related to 2d mouse movement. void AddOption(const TString& stringOption); Additional options for surfaces. void ProcessEvent(Int_t event, Int_t px, Int_t py); Remove all profiles/sections. void InitGL() const; Initialize some OpenGL state variables. void DeInitGL() const; Initialize some OpenGL state variables. void SetNormals(); One normal per vertex;; this normal is average of; neighbouring triangles normals. void SetSurfaceColor() const; Set color for surface. void DrawPlot() const; Draw surf/surf1/surf2/surf4. Bool_t InitGeometryCartesian(); Find bin ranges for X and Y axes,; axes ranges for X, Y and Z.; Function returns false, if logarithmic scale for; some axis was requested, but we cannot; find correct range. Bool_t InitGeometryPolar(); Find bin ranges for X and Y axes,; axes ranges for X, Y and Z.; Function returns false, if logarithmic scale for; some axis was requested, but we cannot; find correct range. Bool_t InitGeometryCylindrical(); Find bin ranges for X and Y axes,; axes ranges for X, Y and Z.; Function returns false, if logarithmic scale for; some axis was requested, but we cannot; find correct range. Bool_t InitGeometrySpherical(); Find bin ranges for X and Y axes,; axes ranges for ",MatchSource.WIKI,root/html528/TGLSurfacePainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLSurfacePainter.html
https://root.cern/root/html528/TGLSurfacePainter.html:4951,Modifiability,variab,variables,4951,"fSectionPass; TGL2DArray<Double_t>fTexMap; TGLSurfacePainter::ESurfaceTypefType; Bool_tfUpdateTexMap; list<Projection_t>fXOYProj; list<Projection_t>fXOZProj; list<Projection_t>fYOZProj; static TRandom*fgRandom. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLSurfacePainter(TH1* hist, TGLPlotCamera* camera, TGLPlotCoordinates* coord); Constructor. char * GetPlotInfo(Int_t px, Int_t py); Coords for point on surface under cursor. Bool_t InitGeometry(); Set mesh, normals. void StartPan(Int_t px, Int_t py); User clicks right mouse button (in a pad). void Pan(Int_t px, Int_t py); User's moving mouse cursor, with middle mouse button pressed (for pad).; Calculate 3d shift related to 2d mouse movement. void AddOption(const TString& stringOption); Additional options for surfaces. void ProcessEvent(Int_t event, Int_t px, Int_t py); Remove all profiles/sections. void InitGL() const; Initialize some OpenGL state variables. void DeInitGL() const; Initialize some OpenGL state variables. void SetNormals(); One normal per vertex;; this normal is average of; neighbouring triangles normals. void SetSurfaceColor() const; Set color for surface. void DrawPlot() const; Draw surf/surf1/surf2/surf4. Bool_t InitGeometryCartesian(); Find bin ranges for X and Y axes,; axes ranges for X, Y and Z.; Function returns false, if logarithmic scale for; some axis was requested, but we cannot; find correct range. Bool_t InitGeometryPolar(); Find bin ranges for X and Y axes,; axes ranges for X, Y and Z.; Function returns false, if logarithmic scale for; some axis was requested, but we cannot; find correct range. Bool_t InitGeometryCylindrical(); Find bin ranges for X and Y axes,; axes ranges for X, Y and Z.; Function returns false, if logarithmic scale for; some axis was requested, but we cannot; find correct range. Bool_t InitGeometrySpherical(); Find bin ranges for X and Y axes,; axes ranges for X, Y and Z.; Function returns false, if logarithmic scale for;",MatchSource.WIKI,root/html528/TGLSurfacePainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLSurfacePainter.html
https://root.cern/root/html528/TGLSurfacePainter.html:5292,Testability,log,logarithmic,5292,"ctor. char * GetPlotInfo(Int_t px, Int_t py); Coords for point on surface under cursor. Bool_t InitGeometry(); Set mesh, normals. void StartPan(Int_t px, Int_t py); User clicks right mouse button (in a pad). void Pan(Int_t px, Int_t py); User's moving mouse cursor, with middle mouse button pressed (for pad).; Calculate 3d shift related to 2d mouse movement. void AddOption(const TString& stringOption); Additional options for surfaces. void ProcessEvent(Int_t event, Int_t px, Int_t py); Remove all profiles/sections. void InitGL() const; Initialize some OpenGL state variables. void DeInitGL() const; Initialize some OpenGL state variables. void SetNormals(); One normal per vertex;; this normal is average of; neighbouring triangles normals. void SetSurfaceColor() const; Set color for surface. void DrawPlot() const; Draw surf/surf1/surf2/surf4. Bool_t InitGeometryCartesian(); Find bin ranges for X and Y axes,; axes ranges for X, Y and Z.; Function returns false, if logarithmic scale for; some axis was requested, but we cannot; find correct range. Bool_t InitGeometryPolar(); Find bin ranges for X and Y axes,; axes ranges for X, Y and Z.; Function returns false, if logarithmic scale for; some axis was requested, but we cannot; find correct range. Bool_t InitGeometryCylindrical(); Find bin ranges for X and Y axes,; axes ranges for X, Y and Z.; Function returns false, if logarithmic scale for; some axis was requested, but we cannot; find correct range. Bool_t InitGeometrySpherical(); Find bin ranges for X and Y axes,; axes ranges for X, Y and Z.; Function returns false, if logarithmic scale for; some axis was requested, but we cannot; find correct range. void DrawProjections() const; Draw projections. void DrawSectionXOZ() const; Draw section X. void DrawSectionYOZ() const; Draw section Y. void DrawSectionXOY() const; Draw section Z. void ClampZ(Double_t& zVal) const; Clamp z value. char * WindowPointTo3DPoint(Int_t px, Int_t py) const; Find 3d coords using mouse cursor coords",MatchSource.WIKI,root/html528/TGLSurfacePainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLSurfacePainter.html
https://root.cern/root/html528/TGLSurfacePainter.html:5494,Testability,log,logarithmic,5494,"pad). void Pan(Int_t px, Int_t py); User's moving mouse cursor, with middle mouse button pressed (for pad).; Calculate 3d shift related to 2d mouse movement. void AddOption(const TString& stringOption); Additional options for surfaces. void ProcessEvent(Int_t event, Int_t px, Int_t py); Remove all profiles/sections. void InitGL() const; Initialize some OpenGL state variables. void DeInitGL() const; Initialize some OpenGL state variables. void SetNormals(); One normal per vertex;; this normal is average of; neighbouring triangles normals. void SetSurfaceColor() const; Set color for surface. void DrawPlot() const; Draw surf/surf1/surf2/surf4. Bool_t InitGeometryCartesian(); Find bin ranges for X and Y axes,; axes ranges for X, Y and Z.; Function returns false, if logarithmic scale for; some axis was requested, but we cannot; find correct range. Bool_t InitGeometryPolar(); Find bin ranges for X and Y axes,; axes ranges for X, Y and Z.; Function returns false, if logarithmic scale for; some axis was requested, but we cannot; find correct range. Bool_t InitGeometryCylindrical(); Find bin ranges for X and Y axes,; axes ranges for X, Y and Z.; Function returns false, if logarithmic scale for; some axis was requested, but we cannot; find correct range. Bool_t InitGeometrySpherical(); Find bin ranges for X and Y axes,; axes ranges for X, Y and Z.; Function returns false, if logarithmic scale for; some axis was requested, but we cannot; find correct range. void DrawProjections() const; Draw projections. void DrawSectionXOZ() const; Draw section X. void DrawSectionYOZ() const; Draw section Y. void DrawSectionXOY() const; Draw section Z. void ClampZ(Double_t& zVal) const; Clamp z value. char * WindowPointTo3DPoint(Int_t px, Int_t py) const; Find 3d coords using mouse cursor coords.; if (!MakeGLContextCurrent()) {; static char err[] = { ""Apocalipshit!"" };; return err;; }. Bool_t PreparePalette() const; Generate palette. void GenTexMap() const; Find texture coordinates. void DrawC",MatchSource.WIKI,root/html528/TGLSurfacePainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLSurfacePainter.html
https://root.cern/root/html528/TGLSurfacePainter.html:5702,Testability,log,logarithmic,5702,"ional options for surfaces. void ProcessEvent(Int_t event, Int_t px, Int_t py); Remove all profiles/sections. void InitGL() const; Initialize some OpenGL state variables. void DeInitGL() const; Initialize some OpenGL state variables. void SetNormals(); One normal per vertex;; this normal is average of; neighbouring triangles normals. void SetSurfaceColor() const; Set color for surface. void DrawPlot() const; Draw surf/surf1/surf2/surf4. Bool_t InitGeometryCartesian(); Find bin ranges for X and Y axes,; axes ranges for X, Y and Z.; Function returns false, if logarithmic scale for; some axis was requested, but we cannot; find correct range. Bool_t InitGeometryPolar(); Find bin ranges for X and Y axes,; axes ranges for X, Y and Z.; Function returns false, if logarithmic scale for; some axis was requested, but we cannot; find correct range. Bool_t InitGeometryCylindrical(); Find bin ranges for X and Y axes,; axes ranges for X, Y and Z.; Function returns false, if logarithmic scale for; some axis was requested, but we cannot; find correct range. Bool_t InitGeometrySpherical(); Find bin ranges for X and Y axes,; axes ranges for X, Y and Z.; Function returns false, if logarithmic scale for; some axis was requested, but we cannot; find correct range. void DrawProjections() const; Draw projections. void DrawSectionXOZ() const; Draw section X. void DrawSectionYOZ() const; Draw section Y. void DrawSectionXOY() const; Draw section Z. void ClampZ(Double_t& zVal) const; Clamp z value. char * WindowPointTo3DPoint(Int_t px, Int_t py) const; Find 3d coords using mouse cursor coords.; if (!MakeGLContextCurrent()) {; static char err[] = { ""Apocalipshit!"" };; return err;; }. Bool_t PreparePalette() const; Generate palette. void GenTexMap() const; Find texture coordinates. void DrawContoursProjection() const; Draw flat textured surface. Bool_t Textured() const; Checks, if surf requires texture. Bool_t HasSections() const; Any section exists. Bool_t HasProjections() const; Any projection ",MatchSource.WIKI,root/html528/TGLSurfacePainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLSurfacePainter.html
https://root.cern/root/html528/TGLSurfacePainter.html:5908,Testability,log,logarithmic,5908,"ome OpenGL state variables. void SetNormals(); One normal per vertex;; this normal is average of; neighbouring triangles normals. void SetSurfaceColor() const; Set color for surface. void DrawPlot() const; Draw surf/surf1/surf2/surf4. Bool_t InitGeometryCartesian(); Find bin ranges for X and Y axes,; axes ranges for X, Y and Z.; Function returns false, if logarithmic scale for; some axis was requested, but we cannot; find correct range. Bool_t InitGeometryPolar(); Find bin ranges for X and Y axes,; axes ranges for X, Y and Z.; Function returns false, if logarithmic scale for; some axis was requested, but we cannot; find correct range. Bool_t InitGeometryCylindrical(); Find bin ranges for X and Y axes,; axes ranges for X, Y and Z.; Function returns false, if logarithmic scale for; some axis was requested, but we cannot; find correct range. Bool_t InitGeometrySpherical(); Find bin ranges for X and Y axes,; axes ranges for X, Y and Z.; Function returns false, if logarithmic scale for; some axis was requested, but we cannot; find correct range. void DrawProjections() const; Draw projections. void DrawSectionXOZ() const; Draw section X. void DrawSectionYOZ() const; Draw section Y. void DrawSectionXOY() const; Draw section Z. void ClampZ(Double_t& zVal) const; Clamp z value. char * WindowPointTo3DPoint(Int_t px, Int_t py) const; Find 3d coords using mouse cursor coords.; if (!MakeGLContextCurrent()) {; static char err[] = { ""Apocalipshit!"" };; return err;; }. Bool_t PreparePalette() const; Generate palette. void GenTexMap() const; Find texture coordinates. void DrawContoursProjection() const; Draw flat textured surface. Bool_t Textured() const; Checks, if surf requires texture. Bool_t HasSections() const; Any section exists. Bool_t HasProjections() const; Any projection exists. void DrawPalette() const; Draw. Palette.; Originally, fCamera was never null.; It can be a null now because of gl-viewer. void DrawPaletteAxis() const; Draw. Palette. Axis. » Author: Timur Pocheptso",MatchSource.WIKI,root/html528/TGLSurfacePainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLSurfacePainter.html
https://root.cern/root/html528/TGLText.html:398,Integrability,interface,interface,398,". TGLText. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLText. class TGLText: public TAttText. GL Text; To draw a 3D text in a GL window. This class uses uses FTGL to render text.; FTGL is a package making the interface between the Free Type fonts and GL.; . Function Members (Methods); public:. TGLText(); TGLText(Double_t x, Double_t y, Double_t z, const char* text); virtual~TGLText(); voidBBox(const char* string, float& llx, float& lly, float& llz, float& urx, float& ury, float& urz); static TClass*Class(); voidTAttText::Copy(TAttText& atttext) const; FTFont*GetFont(); virtual Short_tTAttText::GetTextAlign() const; virtual Float_tTAttText::GetTextAngle() const; virtual Color_tTAttText::GetTextColor() const; virtual Font_tTAttText::GetTextFont() const; virtual Float_tTAttText::GetTextSize() const; virtual TClass*IsA() const; virtual voidTAttText::Modify(); voidPaintBBox(const char* text); voidPaintGLText(Double_t x, Double_t y, Double_t z, const char* text); virtual voidTAttText::ResetAttText(Option_t* toption = """"); virtual voidTAttText::SaveTextAttributes(ostream& out, const char* name, Int_t alidef = 12, Float_t angdef = 0, Int_t coldef = 1, Int_t fondef = 61, Float_t sizdef = 1); voidSetGLTextAngles(Double_t a1, Double_t a2, Double_t a3); voidSetGLTextFont(Font_t fontnumber); virtual voidTAttText::SetTextAlign(Short_t align = 11); virtual voidTAttText::SetTextAngle(Float_t tangle = 0)MENU ; virtual voidTAttText::SetTextAttributes()MENU ; virtual voidTAttText::SetTextColor(Color_t tcolor = 1); virtual voidTAttText::SetTextFont(Font_t tfont = 62); virtual voidTAttText::SetTextSize(Float_t tsize = 1); virtual voidTAttText::SetTextSizePixels(Int_t npixels); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). private:. ",MatchSource.WIKI,root/html528/TGLText.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLText.html
https://root.cern/root/html528/TGLTF3Painter.html:4209,Modifiability,variab,variables,4209,"s; TAxis*TGLPlotPainter::fYAxis; Double_tTGLPlotPainter::fYOZSectionPos; TAxis*TGLPlotPainter::fZAxis; vector<Double_t>TGLPlotPainter::fZLevels. private:. TF3*fF3; Rgl::Mc::TIsoMesh<double>fMesh; TGLTF3Painter::ETF3StylefStyle; TGLTH3SlicefXOYSlice; TGLTH3SlicefXOZSlice; TGLTH3SlicefYOZSlice. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLTF3Painter(TF3* fun, TH1* hist, TGLPlotCamera* camera, TGLPlotCoordinates* coord); Constructor. char * GetPlotInfo(Int_t px, Int_t py); Coords for point on surface under cursor. Bool_t InitGeometry(); Create mesh. void StartPan(Int_t px, Int_t py); User clicks right mouse button (in a pad). void Pan(Int_t px, Int_t py); User's moving mouse cursor, with middle mouse button pressed (for pad).; Calculate 3d shift related to 2d mouse movement.; Slicing is disabled (since somebody has broken it). void AddOption(const TString& stringOption); No options for tf3. void ProcessEvent(Int_t event, Int_t px, Int_t py); Change color sheme. void InitGL() const; Initialize OpenGL state variables. void DeInitGL() const; Initialize OpenGL state variables. void DrawToSelectionBuffer() const; Draw triangles, no normals, no lighting. void DrawDefaultPlot() const; Surface with material properties and lighting. void DrawMaplePlot() const; Colored surface, without lighting and; material properties. void DrawPlot() const; Draw mesh. void SetSurfaceColor() const; Set color for surface. Bool_t HasSections() const; Any section exists. void DrawSectionXOZ() const; Draw XOZ parallel section. void DrawSectionYOZ() const; Draw YOZ parallel section. void DrawSectionXOY() const; Draw XOY parallel section. » Author: Timur Pocheptsov 31/08/2006 » Copyright (C) 1995-2006, Rene Brun and Fons Rademakers. *; » Last changed: root/gl:$Id$ » Last generated: 2010-09-23 20:06; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html528/TGLTF3Painter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLTF3Painter.html
https://root.cern/root/html528/TGLTF3Painter.html:4267,Modifiability,variab,variables,4267,"s; TAxis*TGLPlotPainter::fYAxis; Double_tTGLPlotPainter::fYOZSectionPos; TAxis*TGLPlotPainter::fZAxis; vector<Double_t>TGLPlotPainter::fZLevels. private:. TF3*fF3; Rgl::Mc::TIsoMesh<double>fMesh; TGLTF3Painter::ETF3StylefStyle; TGLTH3SlicefXOYSlice; TGLTH3SlicefXOZSlice; TGLTH3SlicefYOZSlice. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLTF3Painter(TF3* fun, TH1* hist, TGLPlotCamera* camera, TGLPlotCoordinates* coord); Constructor. char * GetPlotInfo(Int_t px, Int_t py); Coords for point on surface under cursor. Bool_t InitGeometry(); Create mesh. void StartPan(Int_t px, Int_t py); User clicks right mouse button (in a pad). void Pan(Int_t px, Int_t py); User's moving mouse cursor, with middle mouse button pressed (for pad).; Calculate 3d shift related to 2d mouse movement.; Slicing is disabled (since somebody has broken it). void AddOption(const TString& stringOption); No options for tf3. void ProcessEvent(Int_t event, Int_t px, Int_t py); Change color sheme. void InitGL() const; Initialize OpenGL state variables. void DeInitGL() const; Initialize OpenGL state variables. void DrawToSelectionBuffer() const; Draw triangles, no normals, no lighting. void DrawDefaultPlot() const; Surface with material properties and lighting. void DrawMaplePlot() const; Colored surface, without lighting and; material properties. void DrawPlot() const; Draw mesh. void SetSurfaceColor() const; Set color for surface. Bool_t HasSections() const; Any section exists. void DrawSectionXOZ() const; Draw XOZ parallel section. void DrawSectionYOZ() const; Draw YOZ parallel section. void DrawSectionXOY() const; Draw XOY parallel section. » Author: Timur Pocheptsov 31/08/2006 » Copyright (C) 1995-2006, Rene Brun and Fons Rademakers. *; » Last changed: root/gl:$Id$ » Last generated: 2010-09-23 20:06; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html528/TGLTF3Painter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLTF3Painter.html
https://root.cern/root/html528/TGLTH3Composition.html:2795,Availability,error,error,2795," virtual voidTH1::DirectoryAutoAdd(TDirectory*); Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidTH1::Divide(const TH1* h1); virtual voidTH1::Divide(TF1* f1, Double_t c1 = 1); virtual voidTH1::Divide(const TH1* h1, const TH1* h2, Double_t c1 = 1, Double_t c2 = 1, Option_t* option = """")MENU ; virtual voidTH1::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual TH1*TH3C::DrawCopy(Option_t* option = """") const; virtual TH1*TH1::DrawNormalized(Option_t* option = """", Double_t norm = 1) const; virtual voidTH1::DrawPanel()MENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTH1::Eval(TF1* f1, Option_t* option = """"); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TH1*TH1::FFT(TH1* h_output, Option_t* option); virtual Int_tTH3::Fill(Double_t); virtual Int_tTH3::Fill(Double_t, Double_t); virtual Int_tTH3::Fill(const char*, Double_t); Int_tTH3::Fill(Double_t, const char*, Double_t); Int_tTH3::Fill(const char*, Double_t, Double_t); Int_tTH3::Fill(const char*, const char*, Double_t); virtual Int_tTH3::Fill(Double_t x, Double_t y, Double_t z); virtual Int_tTH3::Fill(Double_t x, Double_t y, Double_t z, Double_t w); virtual Int_tTH3::Fill(const char* namex, const char* namey, const char* namez, Double_t w); virtual Int_tTH3::Fill(const char* namex, Double_t y, const char* namez, Double_t w); virtual Int_tTH3::Fill(const char* namex, const char* namey, Double_t z, Double_t w); virtual Int_tTH3::Fill(Double_t x, const char* ",MatchSource.WIKI,root/html528/TGLTH3Composition.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLTH3Composition.html
https://root.cern/root/html528/TGLTH3Composition.html:2879,Availability,error,error,2879," px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidTH1::Divide(const TH1* h1); virtual voidTH1::Divide(TF1* f1, Double_t c1 = 1); virtual voidTH1::Divide(const TH1* h1, const TH1* h2, Double_t c1 = 1, Double_t c2 = 1, Option_t* option = """")MENU ; virtual voidTH1::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual TH1*TH3C::DrawCopy(Option_t* option = """") const; virtual TH1*TH1::DrawNormalized(Option_t* option = """", Double_t norm = 1) const; virtual voidTH1::DrawPanel()MENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTH1::Eval(TF1* f1, Option_t* option = """"); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TH1*TH1::FFT(TH1* h_output, Option_t* option); virtual Int_tTH3::Fill(Double_t); virtual Int_tTH3::Fill(Double_t, Double_t); virtual Int_tTH3::Fill(const char*, Double_t); Int_tTH3::Fill(Double_t, const char*, Double_t); Int_tTH3::Fill(const char*, Double_t, Double_t); Int_tTH3::Fill(const char*, const char*, Double_t); virtual Int_tTH3::Fill(Double_t x, Double_t y, Double_t z); virtual Int_tTH3::Fill(Double_t x, Double_t y, Double_t z, Double_t w); virtual Int_tTH3::Fill(const char* namex, const char* namey, const char* namez, Double_t w); virtual Int_tTH3::Fill(const char* namex, Double_t y, const char* namez, Double_t w); virtual Int_tTH3::Fill(const char* namex, const char* namey, Double_t z, Double_t w); virtual Int_tTH3::Fill(Double_t x, const char* namey, const char* namez, Double_t w); virtual Int_tTH3::Fill(Double_t x, const char",MatchSource.WIKI,root/html528/TGLTH3Composition.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLTH3Composition.html
https://root.cern/root/html528/TGLTH3Composition.html:15818,Availability,error,error,15818,,MatchSource.WIKI,root/html528/TGLTH3Composition.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLTH3Composition.html
https://root.cern/root/html528/TGLTH3Composition.html:15888,Availability,error,error,15888,,MatchSource.WIKI,root/html528/TGLTH3Composition.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLTH3Composition.html
https://root.cern/root/html528/TGLTH3Composition.html:15970,Availability,error,error,15970,,MatchSource.WIKI,root/html528/TGLTH3Composition.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLTH3Composition.html
https://root.cern/root/html528/TGLTH3Composition.html:17456,Availability,error,error,17456,"uble_t error); virtual voidTH1::SetBinError(Int_t binx, Int_t biny, Double_t error); virtual voidTH1::SetBinError(Int_t binx, Int_t biny, Int_t binz, Double_t error); virtual voidTH1::SetBins(Int_t nx, const Double_t* xBins); virtual voidTH1::SetBins(Int_t nx, Double_t xmin, Double_t xmax); virtual voidTH1::SetBins(Int_t nx, const Double_t* xBins, Int_t ny, const Double_t* yBins); virtual voidTH1::SetBins(Int_t nx, Double_t xmin, Double_t xmax, Int_t ny, Double_t ymin, Double_t ymax); virtual voidTH1::SetBins(Int_t nx, const Double_t* xBins, Int_t ny, const Double_t* yBins, Int_t nz, const Double_t* zBins); virtual voidTH1::SetBins(Int_t nx, Double_t xmin, Double_t xmax, Int_t ny, Double_t ymin, Double_t ymax, Int_t nz, Double_t zmin, Double_t zmax); virtual voidTH3C::SetBinsLength(Int_t n = -1); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTH1::SetBuffer(Int_t buffersize, Option_t* option = """"); virtual voidTH1::SetCellContent(Int_t binx, Int_t biny, Double_t content); virtual voidTH1::SetCellError(Int_t binx, Int_t biny, Double_t content); virtual voidTH1::SetContent(const Double_t* content); virtual voidTH1::SetContour(Int_t nlevels, const Double_t* levels = 0); virtual voidTH1::SetContourLevel(Int_t level, Double_t value); static voidTH1::SetDefaultBufferSize(Int_t buffersize = 1000); static voidTH1::SetDefaultSumw2(Bool_t sumw2 = kTRUE); virtual voidTH1::SetDirectory(TDirectory* dir); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTH1::SetEntries(Double_t n); virtual voidTH1::SetError(const Double_t* error); virtual voidTAttFill::SetFillAttributes()MENU ; virtual voidTAttFill::SetFillColor(Color_t fcolor); virtual voidTAttFill::SetFillStyle(Style_t fstyle); virtual voidTH1::SetLabelColor(Color_t color = 1, Option_t* axis = ""X""); virtual voidTH1::SetLabelFont(Style_t font = 62, Option_t* axis = ""X""); virtual voidTH1::SetLabelOffset(Float_t offset = 0.",MatchSource.WIKI,root/html528/TGLTH3Composition.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLTH3Composition.html
https://root.cern/root/html528/TGLTH3CompositionPainter.html:3978,Modifiability,variab,variables,3978,"Painter::fPadPhi; Double_tTGLPlotPainter::fPadTheta; Int_tTGLPlotPainter::fSelectedPart; TGLSelectionBufferTGLPlotPainter::fSelection; TGLPlotPainter::ESelectionBaseTGLPlotPainter::fSelectionBase; Bool_tTGLPlotPainter::fSelectionPass; Bool_tTGLPlotPainter::fUpdateSelection; TAxis*TGLPlotPainter::fXAxis; Double_tTGLPlotPainter::fXOYSectionPos; Double_tTGLPlotPainter::fXOZSectionPos; TAxis*TGLPlotPainter::fYAxis; Double_tTGLPlotPainter::fYOZSectionPos; TAxis*TGLPlotPainter::fZAxis; vector<Double_t>TGLPlotPainter::fZLevels. private:. TGLTH3Composition*fData; pair<Double_t,Double_t>fMinMaxVal; TGLQuadricfQuadric. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLTH3CompositionPainter(TGLTH3Composition* data, TGLPlotCamera* camera, TGLPlotCoordinates* coord); Ctor. char * GetPlotInfo(Int_t px, Int_t py); Will be never called from TPad. Bool_t InitGeometry(). void StartPan(Int_t px, Int_t py); Move plot or box cut. void Pan(Int_t px, Int_t py); User's moving mouse cursor, with middle mouse button pressed (for pad).; Calculate 3d shift related to 2d mouse movement. void AddOption(const TString& option); No options for composition. void ProcessEvent(Int_t event, Int_t px, Int_t py); Switch on/off box cut. void InitGL() const; Initialize some gl state variables. void DeInitGL() const; Return back some gl state variables. void DrawPlot() const; Draw composition of TH3s. void SetColor(Int_t color) const; Set material. TGLTH3CompositionPainter(TGLTH3Composition* data, TGLPlotCamera* camera, TGLPlotCoordinates* coord); TGLPlotPainter final-overriders. void DrawSectionXOZ() const; Empty overriders. {}. void DrawSectionYOZ() const; {}. void DrawSectionXOY() const; {}. » Last changed: root/gl:$Id: TGLTH3Composition.h 29714 2009-08-07 08:36:09Z brun $ » Last generated: 2010-09-23 20:07; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html528/TGLTH3CompositionPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLTH3CompositionPainter.html
https://root.cern/root/html528/TGLTH3CompositionPainter.html:4038,Modifiability,variab,variables,4038,"Painter::fPadPhi; Double_tTGLPlotPainter::fPadTheta; Int_tTGLPlotPainter::fSelectedPart; TGLSelectionBufferTGLPlotPainter::fSelection; TGLPlotPainter::ESelectionBaseTGLPlotPainter::fSelectionBase; Bool_tTGLPlotPainter::fSelectionPass; Bool_tTGLPlotPainter::fUpdateSelection; TAxis*TGLPlotPainter::fXAxis; Double_tTGLPlotPainter::fXOYSectionPos; Double_tTGLPlotPainter::fXOZSectionPos; TAxis*TGLPlotPainter::fYAxis; Double_tTGLPlotPainter::fYOZSectionPos; TAxis*TGLPlotPainter::fZAxis; vector<Double_t>TGLPlotPainter::fZLevels. private:. TGLTH3Composition*fData; pair<Double_t,Double_t>fMinMaxVal; TGLQuadricfQuadric. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLTH3CompositionPainter(TGLTH3Composition* data, TGLPlotCamera* camera, TGLPlotCoordinates* coord); Ctor. char * GetPlotInfo(Int_t px, Int_t py); Will be never called from TPad. Bool_t InitGeometry(). void StartPan(Int_t px, Int_t py); Move plot or box cut. void Pan(Int_t px, Int_t py); User's moving mouse cursor, with middle mouse button pressed (for pad).; Calculate 3d shift related to 2d mouse movement. void AddOption(const TString& option); No options for composition. void ProcessEvent(Int_t event, Int_t px, Int_t py); Switch on/off box cut. void InitGL() const; Initialize some gl state variables. void DeInitGL() const; Return back some gl state variables. void DrawPlot() const; Draw composition of TH3s. void SetColor(Int_t color) const; Set material. TGLTH3CompositionPainter(TGLTH3Composition* data, TGLPlotCamera* camera, TGLPlotCoordinates* coord); TGLPlotPainter final-overriders. void DrawSectionXOZ() const; Empty overriders. {}. void DrawSectionYOZ() const; {}. void DrawSectionXOY() const; {}. » Last changed: root/gl:$Id: TGLTH3Composition.h 29714 2009-08-07 08:36:09Z brun $ » Last generated: 2010-09-23 20:07; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html528/TGLTH3CompositionPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLTH3CompositionPainter.html
https://root.cern/root/html528/TGLTH3Slice.html:1613,Availability,error,error,1613," TGLTH3Slice::ESliceAxis axis); ~TGLTH3Slice(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; voidDrawSlice(Double_t pos) const; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; const TGLLevelPalette&GetPalette() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, con",MatchSource.WIKI,root/html528/TGLTH3Slice.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLTH3Slice.html
https://root.cern/root/html528/TGLTH3Slice.html:1697,Availability,error,error,1697,"ar* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; voidDrawSlice(Double_t pos) const; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; const TGLLevelPalette&GetPalette() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) c",MatchSource.WIKI,root/html528/TGLTH3Slice.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLTH3Slice.html
https://root.cern/root/html528/TGLTransManip.html:556,Energy Efficiency,green,green,556,". TGLTransManip. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLTransManip. class TGLTransManip: public TGLManip. TGLTransManip. Translation manipulator - attaches to physical shape and draws local; axes widgets with arrow heads. User can mouse over (turns yellow) and; L click/drag to translate along this axis.; Widgets use standard 3D package axes colours: X red, Y green, Z blue. Function Members (Methods); public:. TGLTransManip(); TGLTransManip(TGLPhysicalShape* shape); TGLTransManip(const TGLTransManip&); virtual~TGLTransManip(); voidTGLManip::Attach(TGLPhysicalShape* shape); static TClass*Class(); virtual voidDraw(const TGLCamera& camera) const; Bool_tTGLManip::GetActive() const; TGLPhysicalShape*TGLManip::GetAttached() const; UInt_tTGLManip::GetSelectedWidget() const; virtual Bool_tTGLManip::HandleButton(const Event_t& event, const TGLCamera& camera); virtual Bool_tHandleMotion(const Event_t& event, const TGLCamera& camera); virtual TClass*IsA() const; virtual Bool_tTGLManip::Select(const TGLCamera&, const TGLRect&, const TGLBoundingBox&); voidTGLManip::SetActive(Bool_t a); voidTGLManip::SetSelectedWidget(UInt_t s); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). protected:. voidTGLManip::CalcDrawScale(const TGLBoundingBox& box, const TGLCamera& camera, Double_t& base, TGLVector3* axis) const; const UChar_t*TGLManip::ColorFor(UInt_t widget) const; TGLManip&TGLManip::operator=(const TGLManip&). Data Members; protected:. Bool_tTGLManip::fActive! manipulator is active?; TPointTGLManip::fFirstMouse! first (start) mouse position (in WINDOW coords); TPointTGLManip::fLastMouse! last (latest) mouse position (in WINDOW coords); UInt_tTGLManip::fSelectedWidget! active width (axis) component; TGLPhysicalShape*TGLManip::f",MatchSource.WIKI,root/html528/TGLTransManip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLTransManip.html
https://root.cern/root/html528/TGLTransManip.html:2551,Energy Efficiency,green,green,2551,"owMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). protected:. voidTGLManip::CalcDrawScale(const TGLBoundingBox& box, const TGLCamera& camera, Double_t& base, TGLVector3* axis) const; const UChar_t*TGLManip::ColorFor(UInt_t widget) const; TGLManip&TGLManip::operator=(const TGLManip&). Data Members; protected:. Bool_tTGLManip::fActive! manipulator is active?; TPointTGLManip::fFirstMouse! first (start) mouse position (in WINDOW coords); TPointTGLManip::fLastMouse! last (latest) mouse position (in WINDOW coords); UInt_tTGLManip::fSelectedWidget! active width (axis) component; TGLPhysicalShape*TGLManip::fShape! manipulated shape. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLTransManip(); Construct translation manipulator not bound to any physical shape. TGLTransManip(TGLPhysicalShape* shape); Construct translation manipulator, attached to supplied TGLViewer; 'viewer', bound to TGLPhysicalShape 'shape'. ~TGLTransManip(); Destory the translation manipulator. void Draw(const TGLCamera& camera) const; Draw translation manipulator - tubes with arrow heads, in local axes of; attached shape, in red(X), green(Y) and blue(Z), with white center sphere.; If selected widget (mouse over) this is drawn in active colour (yellow). Bool_t HandleMotion(const Event_t& event, const TGLCamera& camera); Handle mouse motion over manipulator - if active (selected; widget) translate physical along selected widget (axis) of the; manipulator, so it tracks mouse action. Returns kTRUE if redraw; required kFALSE otherwise. TGLTransManip(). » Author: Richard Maunder 16/09/2005 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/gl:$Id: TGLTransManip.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2010-09-23 20:07; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html528/TGLTransManip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLTransManip.html
https://root.cern/root/html528/TGLUtil.html:316,Availability,error,error,316,". TGLUtil. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLUtil. class TGLUtil. Wrapper class for various misc static functions - error checking,; draw helpers etc. Function Members (Methods); public:. virtual~TGLUtil(); static voidBeginAttLine(const TAttLine& aline, Char_t transp, Int_t pick_radius = 0, Bool_t selection = kFALSE); static voidBeginExtendPickRegion(Float_t scale); static voidCheckError(const char* loc); static TClass*Class(); static voidColor(const TGLColor& color); static voidColor3f(Float_t r, Float_t g, Float_t b); static voidColor3fv(const Float_t* rgb); static voidColor3ub(UChar_t r, UChar_t g, UChar_t b); static voidColor3ubv(const UChar_t* rgb); static voidColor4f(Float_t r, Float_t g, Float_t b, Float_t a); static voidColor4fv(const Float_t* rgba); static voidColor4ub(UChar_t r, UChar_t g, UChar_t b, UChar_t a); static voidColor4ubv(const UChar_t* rgba); static voidColorAlpha(const TGLColor& color, UChar_t alpha); static voidColorAlpha(const TGLColor& color, Float_t alpha); static voidColorAlpha(Color_t color_index, Float_t alpha = 1); static voidColorTransparency(Color_t color_index, Char_t transparency = 0); static voidDrawLine(const TGLLine3& line, TGLUtil::ELineHeadShape head, Double_t size, const UChar_t* rgba); static voidDrawLine(const TGLVertex3& start, const TGLVector3& vector, TGLUtil::ELineHeadShape head, Double_t size, const UChar_t* rgba); static voidDrawNumber(const TString& num, const TGLVertex3& pos, Bool_t center = kFALSE); static voidDrawReferenceMarker(const TGLCamera& camera, const TGLVertex3& pos, Float_t radius = 3, const UChar_t* rgba = 0); static voidDrawRing(const TGLVertex3& center, const TGLVector3& normal, Double_t radius, const UChar_t* rgba); static voidDrawSimpleAxes(const TGLCamera& camera, const TGLBoundingBox& bbox, Int_t axesT",MatchSource.WIKI,root/html528/TGLUtil.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLUtil.html
https://root.cern/root/html528/TGLUtil.html:5289,Availability,error,error,5289," Float_tfgPointSize; static Float_tfgPointSizeScale. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; GLUtesselator* GetDrawTesselator3fv(); Returns a tesselator for direct drawing when using 3-vertices with; single precision. GLUtesselator* GetDrawTesselator4fv(); Returns a tesselator for direct drawing when using 4-vertices with; single precision. GLUtesselator* GetDrawTesselator3dv(); Returns a tesselator for direct drawing when using 3-vertices with; double precision. GLUtesselator* GetDrawTesselator4dv(); Returns a tesselator for direct drawing when using 4-vertices with; double precision. UInt_t GetDrawQuality(); static: get draw quality. void SetDrawQuality(UInt_t dq); static: set draw quality. void ResetDrawQuality(); static: reset draw quality. UInt_t GetDefaultDrawQuality(); static: get default draw quality. void SetDefaultDrawQuality(UInt_t dq); static: set default draw quality. void CheckError(const char* loc); Check current GL error state, outputing details via ROOT; Error method if one. UInt_t LockColor(); Prevent further color changes. UInt_t UnlockColor(); Allow color changes. Bool_t IsColorLocked(); Returns true if color lockcount is greater than 0. void Color(const TGLColor& color); Set color from TGLColor. void ColorAlpha(const TGLColor& color, UChar_t alpha); Set color from TGLColor and alpha value. void ColorAlpha(const TGLColor& color, Float_t alpha); Set color from TGLColor and alpha value. void ColorAlpha(Color_t color_index, Float_t alpha = 1); Set color from color_index and GL-style alpha (default 1). void ColorTransparency(Color_t color_index, Char_t transparency = 0); Set color from color_index and ROOT-style transparency (default 0). void Color3ub(UChar_t r, UChar_t g, UChar_t b); Wrapper for glColor3ub. void Color4ub(UChar_t r, UChar_t g, UChar_t b, UChar_t a); Wrapper for glColor4ub. void Color3ubv(const UChar_t* rgb); Wrapper for glColor3ubv. void Color4ubv(const UChar_t* rgba); Wrapper for glC",MatchSource.WIKI,root/html528/TGLUtil.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLUtil.html
https://root.cern/root/html528/TGLUtil.html:8583,Integrability,rout,routines,8583,"LSE, Bool_t sec_selection = kFALSE); Render polymarkers at points specified by p-array.; Supports point and cross-like styles. void RenderPoints(const TAttMarker& marker, Float_t* p, Int_t n, Int_t pick_radius = 0, Bool_t selection = kFALSE, Bool_t sec_selection = kFALSE); Render markers as circular or square points.; Color is never changed. void RenderCrosses(const TAttMarker& marker, Float_t* p, Int_t n, Bool_t sec_selection = kFALSE); Render markers as crosses.; Color is never changed. void RenderPolyLine(const TAttLine& aline, Char_t transp, Float_t* p, Int_t n, Int_t pick_radius = 0, Bool_t selection = kFALSE); Render poly-line as specified by the p-array. void BeginAttLine(const TAttLine& aline, Char_t transp, Int_t pick_radius = 0, Bool_t selection = kFALSE); Setup drawing parrameters according to passed TAttLine. void EndAttLine(Int_t pick_radius = 0, Bool_t selection = kFALSE); Restore previous line drawing state. void SetDrawColors(const UChar_t* rgba); Set basic draw colors from 4 component 'rgba'; Used by other TGLUtil drawing routines. Sets basic (unlit) color - glColor; and also GL materials (see OpenGL docs) thus:. diffuse : rgba; ambient : 0.0 0.0 0.0 1.0; specular : 0.6 0.6 0.6 1.0; emission : rgba/4.0; shininess: 60.0. emission is set so objects with no lights (but lighting still enabled); are partially visible. void DrawSphere(const TGLVertex3& position, Double_t radius, const UChar_t* rgba); Draw sphere, centered on vertex 'position', with radius 'radius',; color 'rgba'. void DrawLine(const TGLLine3& line, TGLUtil::ELineHeadShape head, Double_t size, const UChar_t* rgba); Draw thick line (tube) defined by 'line', with head at end shape; 'head' - box/arrow/none, (head) size 'size', color 'rgba'. void DrawLine(const TGLVertex3& start, const TGLVector3& vector, TGLUtil::ELineHeadShape head, Double_t size, const UChar_t* rgba); Draw thick line (tube) running from 'start', length 'vector',; with head at end of shape 'head' - box/arrow/none,; (head) si",MatchSource.WIKI,root/html528/TGLUtil.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLUtil.html
https://root.cern/root/html528/TGLUtil.html:10097,Usability,simpl,simple,10097,"abled); are partially visible. void DrawSphere(const TGLVertex3& position, Double_t radius, const UChar_t* rgba); Draw sphere, centered on vertex 'position', with radius 'radius',; color 'rgba'. void DrawLine(const TGLLine3& line, TGLUtil::ELineHeadShape head, Double_t size, const UChar_t* rgba); Draw thick line (tube) defined by 'line', with head at end shape; 'head' - box/arrow/none, (head) size 'size', color 'rgba'. void DrawLine(const TGLVertex3& start, const TGLVector3& vector, TGLUtil::ELineHeadShape head, Double_t size, const UChar_t* rgba); Draw thick line (tube) running from 'start', length 'vector',; with head at end of shape 'head' - box/arrow/none,; (head) size 'size', color 'rgba'. void DrawRing(const TGLVertex3& center, const TGLVector3& normal, Double_t radius, const UChar_t* rgba); Draw ring, centered on 'center', lying on plane defined by 'center' & 'normal'; of outer radius 'radius', color 'rgba'. void DrawReferenceMarker(const TGLCamera& camera, const TGLVertex3& pos, Float_t radius = 3, const UChar_t* rgba = 0); Draw a sphere- marker on world-coordinate 'pos' with pixel; radius 'radius'. Color argument is optional. void DrawSimpleAxes(const TGLCamera& camera, const TGLBoundingBox& bbox, Int_t axesType); Draw simple xyz-axes for given bounding-box. void DrawNumber(const TString& num, const TGLVertex3& pos, Bool_t center = kFALSE); Draw number in string 'num' via internal 8x8-pixel bitmap on; vertex 'pos'. If 'center' is true, the number is centered on 'pos'.; Only numbers, '.', '-' and ' ' are supported. TGLColor& operator=(const TGLUtil& ). TGLUtil(const TGLUtil& ). virtual ~TGLUtil(); {}. » Author: Richard Maunder 25/05/2005 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/gl:$Id: TGLUtil.h 36560 2010-11-09 15:26:23Z couet $ » Last generated: 2010-11-09 17:12; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html528/TGLUtil.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLUtil.html
https://root.cern/root/html528/TGLUtil__TColorLocker.html:433,Security,access,accessors,433,". TGLUtil::TColorLocker. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file. viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLUtil::TColorLocker. class TGLUtil::TColorLocker. TGLVertex3. 3 component (x/y/z) vertex class. This is part of collection of utility classes for GL in TGLUtil.h/cxx; These provide const and non-const accessors Arr() / CArr() to a GL; compatible internal field - so can be used directly with OpenGL C API; calls. They are not intended to be fully featured just provide; minimum required. Function Members (Methods); public:. virtual~TColorLocker(); static TClass*Class(); virtual TClass*IsA() const; TGLUtil::TColorLocker&operator=(const TGLUtil::TColorLocker&); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); TGLUtil::TColorLockerTColorLocker(); TGLUtil::TColorLockerTColorLocker(const TGLUtil::TColorLocker&). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLColor& operator=(const TGLUtil::TColorLocker& ). TColorLocker(); { LockColor(); }. virtual ~TColorLocker(); { UnlockColor(); }. » Author: Richard Maunder 25/05/2005 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/gl:$Id: TGLUtil.h 36624 2010-11-12 12:17:06Z couet $ » Last generated: 2010-11-12 15:50; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html528/TGLUtil__TColorLocker.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLUtil__TColorLocker.html
https://root.cern/root/html528/TGLUtil__TDrawQualityModifier.html:457,Security,access,accessors,457,". TGLUtil::TDrawQualityModifier. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file. viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLUtil::TDrawQualityModifier. class TGLUtil::TDrawQualityModifier. TGLVertex3. 3 component (x/y/z) vertex class. This is part of collection of utility classes for GL in TGLUtil.h/cxx; These provide const and non-const accessors Arr() / CArr() to a GL; compatible internal field - so can be used directly with OpenGL C API; calls. They are not intended to be fully featured just provide; minimum required. Function Members (Methods); public:. virtual~TDrawQualityModifier(); static TClass*Class(); virtual TClass*IsA() const; TGLUtil::TDrawQualityModifier&operator=(const TGLUtil::TDrawQualityModifier&); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); TGLUtil::TDrawQualityModifierTDrawQualityModifier(Int_t dq); TGLUtil::TDrawQualityModifierTDrawQualityModifier(const TGLUtil::TDrawQualityModifier&). Data Members; private:. Int_tfOldQuality. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLColor& operator=(const TGLUtil::TDrawQualityModifier& ). TDrawQualityModifier(Int_t dq); {SetDrawQuality(dq); }. virtual ~TDrawQualityModifier(); { SetDrawQuality(fOldQuality); }. » Author: Richard Maunder 25/05/2005 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/gl:$Id: TGLUtil.h 36624 2010-11-12 12:17:06Z couet $ » Last generated: 2010-11-12 15:50; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html528/TGLUtil__TDrawQualityModifier.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLUtil__TDrawQualityModifier.html
https://root.cern/root/html528/TGLUtil__TDrawQualityScaler.html:451,Security,access,accessors,451,". TGLUtil::TDrawQualityScaler. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file. viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLUtil::TDrawQualityScaler. class TGLUtil::TDrawQualityScaler. TGLVertex3. 3 component (x/y/z) vertex class. This is part of collection of utility classes for GL in TGLUtil.h/cxx; These provide const and non-const accessors Arr() / CArr() to a GL; compatible internal field - so can be used directly with OpenGL C API; calls. They are not intended to be fully featured just provide; minimum required. Function Members (Methods); public:. virtual~TDrawQualityScaler(); static TClass*Class(); virtual TClass*IsA() const; TGLUtil::TDrawQualityScaler&operator=(const TGLUtil::TDrawQualityScaler&); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); TGLUtil::TDrawQualityScalerTDrawQualityScaler(Float_t fac); TGLUtil::TDrawQualityScalerTDrawQualityScaler(const TGLUtil::TDrawQualityScaler&). Data Members; private:. Int_tfOldQuality. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLColor& operator=(const TGLUtil::TDrawQualityScaler& ). TDrawQualityScaler(Float_t fac); {SetDrawQuality((Int_t)(fac*fOldQuality)); }. virtual ~TDrawQualityScaler(); { SetDrawQuality(fOldQuality); }. » Author: Richard Maunder 25/05/2005 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/gl:$Id: TGLUtil.h 36624 2010-11-12 12:17:06Z couet $ » Last generated: 2010-11-12 15:50; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html528/TGLUtil__TDrawQualityScaler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLUtil__TDrawQualityScaler.html
https://root.cern/root/html528/TGLVContainer.html:5515,Availability,error,error,5515,"le_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTGContainer::End(Bool_t select = kFALSE); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGContainer::FindFrame(Int_t x, Int_t y, Bool_t exclude = kTRUE); virtual TGFrame*TGContainer::FindFrameByName(const char* name); virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual void*TGContainer::FindItem(const TString& name, Bool_t direction = kTRUE, Bool_t caseSensitive = kTRUE, Bool_t subString = kFALSE); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGCanvas*TGContainer::GetCanvas() const; TGClient*TGObject::Get",MatchSource.WIKI,root/html528/TGLVContainer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLVContainer.html
https://root.cern/root/html528/TGLVContainer.html:5599,Availability,error,error,5599,"t(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTGContainer::End(Bool_t select = kFALSE); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGContainer::FindFrame(Int_t x, Int_t y, Bool_t exclude = kTRUE); virtual TGFrame*TGContainer::FindFrameByName(const char* name); virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual void*TGContainer::FindItem(const TString& name, Bool_t direction = kTRUE, Bool_t caseSensitive = kTRUE, Bool_t subString = kFALSE); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGCanvas*TGContainer::GetCanvas() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaul",MatchSource.WIKI,root/html528/TGLVContainer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLVContainer.html
https://root.cern/root/html528/TGLVContainer.html:12321,Availability,mask,mask,12321,") const; voidTObject::InvertBit(UInt_t f); virtual voidTGContainer::InvertSelection()SIGNAL ; virtual TClass*IsA() const; virtual Bool_tTGFrame::IsActive() const; Bool_tTGCompositeFrame::IsArranged(TGFrame* f) const; Bool_tTGCompositeFrame::IsArranged(TGFrameElement* ptr) const; virtual Bool_tTGCompositeFrame::IsComposite() const; Bool_tTGFrame::IsDNDSource() const; Bool_tTGFrame::IsDNDTarget() const; virtual Bool_tTGCompositeFrame::IsEditable() const; virtual Bool_tTGObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; virtual Bool_tTGCompositeFrame::IsLayoutBroken() const; virtual Bool_tTGWindow::IsMapped(); virtual Bool_tTGCompositeFrame::IsMapSubwindows() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTGCompositeFrame::IsVisible(TGFrame* f) const; Bool_tTGCompositeFrame::IsVisible(TGFrameElement* ptr) const; Bool_tTObject::IsZombie() const; virtual voidTGContainer::KeyPressed(TGFrame*, UInt_t keysym, UInt_t mask)SIGNAL ; virtual voidTGContainer::Layout(); virtual voidLineDown(Bool_t select = kFALSE); virtual voidLineLeft(Bool_t select = kFALSE); virtual voidLineRight(Bool_t select = kFALSE); virtual voidLineUp(Bool_t select = kFALSE); static voidTQObject::LoadRQ_OBJECT(); virtual voidTGWindow::LowerWindow(); virtual voidTQObject::LowPriority(const char* signal_name, const char* slot_name = 0); virtual voidTObject::ls(Option_t* option = """") const; virtual voidTGFrame::MapRaised(); virtual voidTGCompositeFrame::MapSubwindows(); virtual voidTGFrame::MapWindow(); voidTObject::MayNotUse(const char* method) const; virtual voidTQObject::Message(const char* msg)SIGNAL ; virtual voidTGFrame::Move(Int_t x, Int_t y); virtual voidTGFrame::MoveResize(Int_t x, Int_t y, UInt_t w = 0, UInt_t h = 0); virtual Int_tTGCompositeFrame::MustCleanup() const; virtual Bool_tTObject::Notify(); virtual Int_tTQObject::NumberOfConnections() const; virtual Int_tTQObject::NumberOfSignals() const; virtual Int_tTGContainer::",MatchSource.WIKI,root/html528/TGLVContainer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLVContainer.html
https://root.cern/root/html528/TGLVContainer.html:21271,Availability,mask,mask,21271,,MatchSource.WIKI,root/html528/TGLVContainer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLVContainer.html
https://root.cern/root/html528/TGLVContainer.html:26820,Availability,down,down,26820," """"); set columns headers. void SetViewMode(EListViewMode viewMode); Set list view mode for container. void SetColumns(Int_t* cpos, Int_t* jmode); Set column information for list items. TGDimension GetMaxItemSize() const; Get size of largest item in container. Int_t GetMaxSubnameWidth(Int_t idx) const; Get width of largest subname in container. void RemoveItemWithData(void* userData); Remove item with fUserData == userData from container. void ActivateItem(TGFrameElement* el); Select/activate item. void DeActivateItem(TGFrameElement* el); Unselect/deactivate item. Bool_t HandleButton(Event_t* event); Handle mouse button event in container. TList * GetSelectedItems(); Get list of selected items in container. void LineLeft(Bool_t select = kFALSE); Move current position one column left. void LineRight(Bool_t select = kFALSE); Move current position one column right. void LineUp(Bool_t select = kFALSE); Make current position first line in window by scrolling up. void LineDown(Bool_t select = kFALSE); Move one line down. TGDimension GetPageDimension() const; Returns page dimension. void SavePrimitive(ostream& out, Option_t* option = """"); Save a list view container as a C++ statement(s) on output stream out. TGLVEntry& operator=(const TGLVContainer& ). EListViewMode GetViewMode() const; { return fViewMode; }. void SetHeaders(Int_t ncolumns). void SetHeader(const char* s, Int_t hmode, Int_t cmode, Int_t idx). void SetDefaultHeaders(). const char * GetHeader(Int_t idx) const. TGLVContainer(const TGLVContainer& ). TGListView * GetListView() const; { return fListView; }. void AddItem(TGLVEntry* item); { AddFrame(item, fItemLayout); item->SetColumns(fCpos, fJmode); fTotal++; }. void SetListView(TGListView* lv); { fListView = lv; }. Bool_t GetMultipleSelection() const; { return fMultiSelect; }. void SetMultipleSelection(Bool_t multi = kTRUE); { fMultiSelect = multi; }. » Author: Fons Rademakers 17/01/98 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: ",MatchSource.WIKI,root/html528/TGLVContainer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLVContainer.html
https://root.cern/root/html528/TGLVContainer.html:22758,Integrability,message,messages,22758,lement*TGContainer::fLastActiveEllast active item; Bool_tTGContainer::fLastCasecase sensetivity of last search; Bool_tTGContainer::fLastDirdirection of last search; TStringTGContainer::fLastNamethe name of object of last search; Bool_tTGContainer::fLastSubstringsubstring search option of last search; Bool_tTGCompositeFrame::fLayoutBrokenno layout manager is used; TGLayoutManager*TGCompositeFrame::fLayoutManagerlayout manager; TList*TGCompositeFrame::fListcontainer of frame elements; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; TGListView*fListViewlistview which contains this container; Bool_tTGCompositeFrame::fMapSubwindowskTRUE - map subwindows; UInt_tTGFrame::fMaxHeightmaximal frame height; UInt_tTGFrame::fMaxWidthmaximal frame width; UInt_tTGFrame::fMinHeightminimal frame height; UInt_tTGFrame::fMinWidthminimal frame width; const TGWindow*TGContainer::fMsgWindowwindow handling container messages; Bool_tfMultiSelecttrue = multiple file selection; Int_tTGCompositeFrame::fMustCleanupcleanup mode (see EFrameCleanup); TStringTGWindow::fNamename of the window used in SavePrimitive(); Bool_tTGWindow::fNeedRedrawkTRUE if window needs to be redrawn; Bool_tTGContainer::fOnMouseOverkTRUE when mouse pointer is over entry; UInt_tTGFrame::fOptionsframe options; const TGWindow*TGWindow::fParentParent window; TTimer*TGContainer::fScrollTimerautoscroll timer; Bool_tTGContainer::fScrollingkTRUE - when scrolling is ON; Int_tTGContainer::fSelectednumber of selected items; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; Int_tTGContainer::fTotaltotal items; EListViewModefViewModelist view viewing mode; TGViewPort*TGContainer::fViewPortcontainer viewport; UInt_tTGFrame::fWidthframe width; Int_tTGFrame::fXframe x position; Int_tTGContainer::fX0; Int_tTGContainer::fXDND; Int_tTGContainer::fXf; Int_tTGContainer::fXp; Int_tTGFrame::fYframe y position; Int_tTGContainer::fY0corn,MatchSource.WIKI,root/html528/TGLVContainer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLVContainer.html
https://root.cern/root/html528/TGLVector3.html:445,Security,access,accessors,445,". TGLVector3. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLVector3. class TGLVector3: public TGLVertex3. TGLVector3. 3 component (x/y/z) vector class. This is part of collection of utility classes for GL in TGLUtil.h/cxx; These provide const and non-const accessors Arr() / CArr() to a GL; compatible internal field - so can be used directly with OpenGL C API; calls. They are not intended to be fully featured just provide; minimum required. Function Members (Methods); public:. TGLVector3(); TGLVector3(const Double_t* src); TGLVector3(const TGLVector3& other); TGLVector3(Double_t x, Double_t y, Double_t z); virtual~TGLVector3(); Double_t*TGLVertex3::Arr(); const Double_t*TGLVertex3::CArr() const; static TClass*Class(); voidTGLVertex3::Dump() const; voidTGLVertex3::Fill(Double_t val); virtual TClass*IsA() const; Double_tMag() const; voidTGLVertex3::Maximum(const TGLVertex3& other); voidTGLVertex3::Minimum(const TGLVertex3& other); voidTGLVertex3::Negate(); voidNormalise(); TGLVertex3&TGLVertex3::operator*=(Double_t f); const TGLVertex3&TGLVertex3::operator+=(const TGLVector3& vec); TGLVector3operator-() const; const TGLVertex3&TGLVertex3::operator-=(const TGLVector3& vec); TGLVector3&operator/=(Double_t val); TGLVector3&operator=(const TGLVertex3& v); TGLVector3&operator=(const TGLVector3&); Bool_tTGLVertex3::operator==(const TGLVertex3& rhs) const; Double_t&TGLVertex3::operator[](Int_t index); const Double_t&TGLVertex3::operator[](Int_t index) const; voidTGLVertex3::Set(const Double_t* xyz); voidTGLVertex3::Set(const TGLVertex3& other); voidTGLVertex3::Set(Double_t x, Double_t y, Double_t z); voidTGLVertex3::Shift(TGLVector3& shift); voidTGLVertex3::Shift(Double_t xDelta, Double_t yDelta, Double_t zDelta); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& ",MatchSource.WIKI,root/html528/TGLVector3.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLVector3.html
https://root.cern/root/html528/TGLVEntry.html:4725,Availability,error,error,4725,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionGetDefaultSize() const; virtual UInt_tTGFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType() const; virtual Option_t*TObjec",MatchSource.WIKI,root/html528/TGLVEntry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLVEntry.html
https://root.cern/root/html528/TGLVEntry.html:4809,Availability,error,error,4809,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionGetDefaultSize() const; virtual UInt_tTGFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType() const; virtual Option_t*TObject::GetDrawOption() const; virtual Int_tTGFrame::GetDropType() const; static Long_tTO",MatchSource.WIKI,root/html528/TGLVEntry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLVEntry.html
https://root.cern/root/html528/TGLVEntry.html:16858,Availability,mask,mask,16858,,MatchSource.WIKI,root/html528/TGLVEntry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLVEntry.html
https://root.cern/root/html528/TGLVertex3.html:439,Security,access,accessors,439,". TGLVertex3. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLVertex3. class TGLVertex3. TGLVertex3. 3 component (x/y/z) vertex class. This is part of collection of simple utility classes for GL only in; TGLUtil.h/cxx. These provide const and non-const accessors Arr() &; CArr() to a GL compatible internal field - so can be used directly; with OpenGL C API calls - which TVector3 etc cannot (easily).; They are not intended to be fully featured just provide minimum; required. Function Members (Methods); public:. TGLVertex3(); TGLVertex3(Double_t* v); TGLVertex3(const TGLVertex3& other); TGLVertex3(Double_t x, Double_t y, Double_t z); virtual~TGLVertex3(); Double_t*Arr(); const Double_t*CArr() const; static TClass*Class(); voidDump() const; voidFill(Double_t val); virtual TClass*IsA() const; voidMaximum(const TGLVertex3& other); voidMinimum(const TGLVertex3& other); voidNegate(); TGLVertex3&operator*=(Double_t f); const TGLVertex3&operator+=(const TGLVector3& vec); TGLVertex3operator-() const; const TGLVertex3&operator-=(const TGLVector3& vec); TGLVertex3&operator=(const TGLVertex3& rhs); Bool_toperator==(const TGLVertex3& rhs) const; Double_t&operator[](Int_t index); const Double_t&operator[](Int_t index) const; voidSet(const Double_t* xyz); voidSet(const TGLVertex3& other); voidSet(Double_t x, Double_t y, Double_t z); voidShift(TGLVector3& shift); voidShift(Double_t xDelta, Double_t yDelta, Double_t zDelta); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); Double_tX() const; Double_t&X(); Double_tY() const; Double_t&Y(); Double_tZ() const; Double_t&Z(). protected:. Bool_tValidIndex(UInt_t index) const. Data Members; protected:. Double_tfVals[3]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function",MatchSource.WIKI,root/html528/TGLVertex3.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLVertex3.html
https://root.cern/root/html528/TGLVertex3.html:351,Usability,simpl,simple,351,". TGLVertex3. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLVertex3. class TGLVertex3. TGLVertex3. 3 component (x/y/z) vertex class. This is part of collection of simple utility classes for GL only in; TGLUtil.h/cxx. These provide const and non-const accessors Arr() &; CArr() to a GL compatible internal field - so can be used directly; with OpenGL C API calls - which TVector3 etc cannot (easily).; They are not intended to be fully featured just provide minimum; required. Function Members (Methods); public:. TGLVertex3(); TGLVertex3(Double_t* v); TGLVertex3(const TGLVertex3& other); TGLVertex3(Double_t x, Double_t y, Double_t z); virtual~TGLVertex3(); Double_t*Arr(); const Double_t*CArr() const; static TClass*Class(); voidDump() const; voidFill(Double_t val); virtual TClass*IsA() const; voidMaximum(const TGLVertex3& other); voidMinimum(const TGLVertex3& other); voidNegate(); TGLVertex3&operator*=(Double_t f); const TGLVertex3&operator+=(const TGLVector3& vec); TGLVertex3operator-() const; const TGLVertex3&operator-=(const TGLVector3& vec); TGLVertex3&operator=(const TGLVertex3& rhs); Bool_toperator==(const TGLVertex3& rhs) const; Double_t&operator[](Int_t index); const Double_t&operator[](Int_t index) const; voidSet(const Double_t* xyz); voidSet(const TGLVertex3& other); voidSet(Double_t x, Double_t y, Double_t z); voidShift(TGLVector3& shift); voidShift(Double_t xDelta, Double_t yDelta, Double_t zDelta); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); Double_tX() const; Double_t&X(); Double_tY() const; Double_t&Y(); Double_tZ() const; Double_t&Z(). protected:. Bool_tValidIndex(UInt_t index) const. Data Members; protected:. Double_tfVals[3]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function",MatchSource.WIKI,root/html528/TGLVertex3.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLVertex3.html
https://root.cern/root/html528/TGLViewer.html:5919,Availability,error,error,5919,":Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidEndScene(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; Bool_tTGLViewerBase::FindClosestOpaqueRecord(TGLSelectRecord& rec, Int_t& recIdx); Bool_tTGLViewerBase::FindClosestOverlayRecord(TGLOvlSelectRecord& rec, Int_t& recIdx); Bool_tTGLViewerBase::FindClosestRecord(TGLSelectRecord& rec, Int_t& recIdx); TGLLogicalShape*TGLViewerBase::FindLogicalInScenes(TObject* id); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TGLAutoRotator*GetAutoRotator(); TGLCameraOverlay*GetCameraOverlay() const; Bool_tGetClipAutoUpdate() const; TGLClipSet*GetClipSet() const; TGLOverlayElement*GetCurrentOvlElm() const; static TGLColorSet&GetDefaultColorSet(); Int_tGetDev() const; TGLViewer::EDragActionGetDragAction() const; Bool_tGetDrawCameraCenter(); virtual Option_t*T",MatchSource.WIKI,root/html528/TGLViewer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLViewer.html
https://root.cern/root/html528/TGLViewer.html:6003,Availability,error,error,6003,"ng_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidEndScene(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; Bool_tTGLViewerBase::FindClosestOpaqueRecord(TGLSelectRecord& rec, Int_t& recIdx); Bool_tTGLViewerBase::FindClosestOverlayRecord(TGLOvlSelectRecord& rec, Int_t& recIdx); Bool_tTGLViewerBase::FindClosestRecord(TGLSelectRecord& rec, Int_t& recIdx); TGLLogicalShape*TGLViewerBase::FindLogicalInScenes(TObject* id); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TGLAutoRotator*GetAutoRotator(); TGLCameraOverlay*GetCameraOverlay() const; Bool_tGetClipAutoUpdate() const; TGLClipSet*GetClipSet() const; TGLOverlayElement*GetCurrentOvlElm() const; static TGLColorSet&GetDefaultColorSet(); Int_tGetDev() const; TGLViewer::EDragActionGetDragAction() const; Bool_tGetDrawCameraCenter(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); TGEventHandler*G",MatchSource.WIKI,root/html528/TGLViewer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLViewer.html
https://root.cern/root/html528/TGLViewer.html:19648,Deployability,update,update,19648,"tMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };; enum TGLLockable::ELock { kUnlocked; kDrawLock; kSelectLock; kModifyLock; };. protected:. TGLAutoRotator*fAutoRotator!; Bool_tfAxesDepthTest! remove guides hidden-lines; Int_tfAxesType! axes type; TGLCamera*TGLViewerBase::fCameraCamera for rendering.; TGLCameraOverlay*fCameraOverlay! markup size of viewport in scene units; Bool_tTGLViewerBase::fChangedChange requiring redraw is pending.; TGLClip*TGLViewerBase::fClipViewer clipping-plane.; TGLClipSet*fClipSet!; TContextMenu*fContextMenu!; TGLCamera*fCurrentCamera!; TGLOverlayElement*fCurrentOvlElm! current overlay element; TGLSelectRecordfCurrentSelRec! select record in use as selected; TGLColorSetfDarkColorSet! color-set with dark background; Bool_tfDebugMode! debug mode (forced rebuild + draw scene/frustum/interest boxes); TGLViewer::EDragActionfDragAction; Bool_tfDrawCameraCenter! reference marker on?; TGEventHandler*fEventHandler! event handler; Float_tfFader! fade the view (0 - no fade/default, 1 - full fade/no rendering done); TGLContextIdentity*fGLCtxId!for embedded gl viewer; Int_tfGLDevice!for embedded gl viewer; TGLWidget*fGLWidget; TGedEditor*fGedEditor! GED editor; Bool_tfIgnoreSizesOnUpdateignore sizes of bounding-boxes on update; Bool_tfIsPrinting!; Short_tTGLViewerBase::fLODViewer-lod for rendering.; TGLColorSetfLightColorSet! color-set with light background; TGLLightSet*fLightSet!; Float_tfLineScale! width scale for lines; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; TGLLockable::ELockTGLLockable::fLockLock state.; Float_tfMaxSceneDrawTimeHQ! max time for scene rendering at high LOD (in ms); Float_tfMaxSceneDrawTimeLQ! max time for scene rendering at high LOD (in ms); Float_tTGLViewerBase::fOLLineWOptional override of scene outline line-width; TGLOrthoCamerafOrthoXOYCamera!;",MatchSource.WIKI,root/html528/TGLViewer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLViewer.html
https://root.cern/root/html528/TGLViewer.html:21238,Deployability,update,update,21238, from this object; TGLLockable::ELockTGLLockable::fLockLock state.; Float_tfMaxSceneDrawTimeHQ! max time for scene rendering at high LOD (in ms); Float_tfMaxSceneDrawTimeLQ! max time for scene rendering at high LOD (in ms); Float_tTGLViewerBase::fOLLineWOptional override of scene outline line-width; TGLOrthoCamerafOrthoXOYCamera!; TGLOrthoCamerafOrthoXOZCamera!; TGLOrthoCamerafOrthoXnOYCamera!; TGLOrthoCamerafOrthoXnOZCamera!; TGLOrthoCamerafOrthoZOYCamera!; TGLOrthoCamerafOrthoZnOYCamera!; TGLBoundingBoxTGLViewerBase::fOverallBoundingBoxAxis-aligned union of scene bboxes.; vector<TGLOverlayElement*>TGLViewerBase::fOverlay; TGLOvlSelectRecordfOvlSelRec! select record from last overlay select; TGLPShapeObj*fPShapeWrap; TVirtualPad*fPad! external pad - remove replace with signal; TGLPerspectiveCamerafPerspectiveCameraXOY!; TGLPerspectiveCamerafPerspectiveCameraXOZ!; TGLPerspectiveCamerafPerspectiveCameraYOZ!; TStringfPictureFileName! default file-name for SavePicture(); Float_tfPointScale! size scale for points; TGLViewer::EPushActionfPushAction; TGLRedrawTimer*fRedrawTimer! timer for triggering redraws; Bool_tfReferenceOn! reference marker on?; TGLVertex3fReferencePos! reference position; Bool_tfResetCamerasOnNextUpdatereposition camera on next update; Bool_tfResetCamerasOnUpdatereposition camera on each update; Bool_tTGLViewerBase::fResetSceneInfosOnRenderRequest rebuild of view-specific scene data.; TGLRnrCtx*TGLViewerBase::fRnrCtx; list<TGLSceneInfo*>TGLViewerBase::fScenesRegistered scenes.; TGLSelectRecordfSecSelRec! select record from last secondary select (should go to context); TGLSelectRecordfSelRec! select record from last select (should go to context); TGLManipSet*fSelectedPShapeRef!; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; Bool_tfSmartRefresh! cache logicals during scene rebuilds; Bool_tfSmoothLines! smooth line edge rendering; Bool_tfSmoothPoints! smooth point edge rendering; Bool_tfStereo! use stereo rendering; Float_tfStere,MatchSource.WIKI,root/html528/TGLViewer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLViewer.html
https://root.cern/root/html528/TGLViewer.html:21299,Deployability,update,update,21299, from this object; TGLLockable::ELockTGLLockable::fLockLock state.; Float_tfMaxSceneDrawTimeHQ! max time for scene rendering at high LOD (in ms); Float_tfMaxSceneDrawTimeLQ! max time for scene rendering at high LOD (in ms); Float_tTGLViewerBase::fOLLineWOptional override of scene outline line-width; TGLOrthoCamerafOrthoXOYCamera!; TGLOrthoCamerafOrthoXOZCamera!; TGLOrthoCamerafOrthoXnOYCamera!; TGLOrthoCamerafOrthoXnOZCamera!; TGLOrthoCamerafOrthoZOYCamera!; TGLOrthoCamerafOrthoZnOYCamera!; TGLBoundingBoxTGLViewerBase::fOverallBoundingBoxAxis-aligned union of scene bboxes.; vector<TGLOverlayElement*>TGLViewerBase::fOverlay; TGLOvlSelectRecordfOvlSelRec! select record from last overlay select; TGLPShapeObj*fPShapeWrap; TVirtualPad*fPad! external pad - remove replace with signal; TGLPerspectiveCamerafPerspectiveCameraXOY!; TGLPerspectiveCamerafPerspectiveCameraXOZ!; TGLPerspectiveCamerafPerspectiveCameraYOZ!; TStringfPictureFileName! default file-name for SavePicture(); Float_tfPointScale! size scale for points; TGLViewer::EPushActionfPushAction; TGLRedrawTimer*fRedrawTimer! timer for triggering redraws; Bool_tfReferenceOn! reference marker on?; TGLVertex3fReferencePos! reference position; Bool_tfResetCamerasOnNextUpdatereposition camera on next update; Bool_tfResetCamerasOnUpdatereposition camera on each update; Bool_tTGLViewerBase::fResetSceneInfosOnRenderRequest rebuild of view-specific scene data.; TGLRnrCtx*TGLViewerBase::fRnrCtx; list<TGLSceneInfo*>TGLViewerBase::fScenesRegistered scenes.; TGLSelectRecordfSecSelRec! select record from last secondary select (should go to context); TGLSelectRecordfSelRec! select record from last select (should go to context); TGLManipSet*fSelectedPShapeRef!; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; Bool_tfSmartRefresh! cache logicals during scene rebuilds; Bool_tfSmoothLines! smooth line edge rendering; Bool_tfSmoothPoints! smooth point edge rendering; Bool_tfStereo! use stereo rendering; Float_tfStere,MatchSource.WIKI,root/html528/TGLViewer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLViewer.html
https://root.cern/root/html528/TGLViewer.html:23585,Deployability,update,update,23585,"name says it all. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLViewer(TVirtualPad* pad, Int_t x, Int_t y, Int_t width, Int_t height); Construct the viewer object, with following arguments:; 'pad' - external pad viewer is bound to; 'x', 'y' - initial top left position; 'width', 'height' - initial width/height. TGLViewer(TVirtualPad* pad); gl-embedded viewer's ctor; Construct the viewer object, with following arguments:; 'pad' - external pad viewer is bound to; 'x', 'y' - initial top left position; 'width', 'height' - initial width/height. void InitSecondaryObjects(); Common initialization. ~TGLViewer(); Destroy viewer object. void PadPaint(TVirtualPad* pad); Entry point for updating viewer contents via VirtualViewer3D; interface.; We search and forward the request to appropriate TGLScenePad.; If it is not found we create a new TGLScenePad so this can; potentially also be used for registration of new pads. void UpdateScene(Bool_t redraw = kTRUE); Force update of pad-scenes. Eventually this could be generalized; to all scene-types via a virtual function in TGLSceneBase. void ResetCurrentCamera(); Resets position/rotation of current camera to default values. void SetupCameras(Bool_t reset); Setup cameras for current bounding box. void PostSceneBuildSetup(Bool_t resetCameras); Perform post scene-build setup. void InitGL(); Initialise GL state. void RequestDraw(Short_t LOD = TGLRnrCtx::kLODMed); Post request for redraw of viewer at level of detail 'LOD'; Request is directed via cross thread gVirtualGL object. void SetupClipObject(); Setup clip-object. Protected virtual method. void PreRender(); Initialize objects that influence rendering.; Called before every render. void PostRender(); Restore state set in PreRender().; Called after every render. void DoDraw(Bool_t swap_buffers = kTRUE); Draw out the viewer. void DoDrawMono(Bool_t swap_buffers); Draw out in monoscopic mode. void DoDrawStereo(Bool_t swap_buffers); Draw out in",MatchSource.WIKI,root/html528/TGLViewer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLViewer.html
https://root.cern/root/html528/TGLViewer.html:30352,Deployability,configurat,configuration,30352,"-set.; This is false at startup. Bool_t IsUsingDefaultColorSetForNewViewers(); Returns the value of the static flag that determines if new; viewers should use the default color-set.; This is false at startup. Bool_t IsColorSetDark() const; Returns true if curremt color set is dark. void SetViewport(Int_t x, Int_t y, Int_t width, Int_t height); Set viewer viewport (window area) with bottom/left at (x,y), with; dimensions 'width'/'height'. void SetViewport(const TGLRect& vp); Set viewr viewport from TGLRect. TGLCamera& RefCamera(TGLViewer::ECameraType camera); Return camera reference by type. void SetCurrentCamera(TGLViewer::ECameraType camera); Set current active camera - 'cameraType' one of:; kCameraPerspX, kCameraPerspY, kCameraPerspZ,; kCameraOrthoXOY, kCameraOrthoXOZ, kCameraOrthoZOY,; kCameraOrthoXnOY, kCameraOrthoXnOZ, kCameraOrthoZnOY. void SetOrthoCamera(TGLViewer::ECameraType camera, Double_t zoom, Double_t dolly, Double_t* center, Double_t hRotate, Double_t vRotate); Set an orthographic camera to supplied configuration - note this; does not need to be the current camera - though you will not see; the effect if it is not. 'camera' defines the ortho camera - one of kCameraOrthoXOY / XOZ / ZOY; 'left' / 'right' / 'top' / 'bottom' define the WORLD coordinates which; corresepond with the left/right/top/bottom positions on the GL viewer viewport; E.g. for kCameraOrthoXOY camera left/right are X world coords,; top/bottom are Y world coords; As this is an orthographic camera the other axis (in eye direction) is; no relevant. The near/far clip planes are set automatically based in scene; contents. void SetPerspectiveCamera(TGLViewer::ECameraType camera, Double_t fov, Double_t dolly, Double_t* center, Double_t hRotate, Double_t vRotate); Set a perspective camera to supplied configuration - note this; does not need to be the current camera - though you will not see; the effect if it is not. 'camera' defines the persp camera - one of kCameraPerspXOZ, kCameraPerspYOZ, k",MatchSource.WIKI,root/html528/TGLViewer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLViewer.html
https://root.cern/root/html528/TGLViewer.html:31126,Deployability,configurat,configuration,31126,"OrthoXOZ, kCameraOrthoZOY,; kCameraOrthoXnOY, kCameraOrthoXnOZ, kCameraOrthoZnOY. void SetOrthoCamera(TGLViewer::ECameraType camera, Double_t zoom, Double_t dolly, Double_t* center, Double_t hRotate, Double_t vRotate); Set an orthographic camera to supplied configuration - note this; does not need to be the current camera - though you will not see; the effect if it is not. 'camera' defines the ortho camera - one of kCameraOrthoXOY / XOZ / ZOY; 'left' / 'right' / 'top' / 'bottom' define the WORLD coordinates which; corresepond with the left/right/top/bottom positions on the GL viewer viewport; E.g. for kCameraOrthoXOY camera left/right are X world coords,; top/bottom are Y world coords; As this is an orthographic camera the other axis (in eye direction) is; no relevant. The near/far clip planes are set automatically based in scene; contents. void SetPerspectiveCamera(TGLViewer::ECameraType camera, Double_t fov, Double_t dolly, Double_t* center, Double_t hRotate, Double_t vRotate); Set a perspective camera to supplied configuration - note this; does not need to be the current camera - though you will not see; the effect if it is not. 'camera' defines the persp camera - one of kCameraPerspXOZ, kCameraPerspYOZ, kCameraPerspXOY; 'fov' - field of view (lens angle) in degrees (clamped to 0.1 - 170.0); 'dolly' - distance from 'center'; 'center' - world position from which dolly/hRotate/vRotate are measured; camera rotates round this, always facing in (in center of viewport); 'hRotate' - horizontal rotation from initial configuration in degrees; 'hRotate' - vertical rotation from initial configuration in degrees. TGLAutoRotator* GetAutoRotator(); Get the auto-rotator for this viewer. void SetAutoRotator(TGLAutoRotator* ar); Set the auto-rotator for this viewer. The old rotator is deleted. void GetGuideState(Int_t& axesType, Bool_t& axesDepthTest, Bool_t& referenceOn, Double_t* referencePos) const; Fetch the state of guides (axes & reference markers) into arguments. void SetGu",MatchSource.WIKI,root/html528/TGLViewer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLViewer.html
https://root.cern/root/html528/TGLViewer.html:31631,Deployability,configurat,configuration,31631,"' / 'bottom' define the WORLD coordinates which; corresepond with the left/right/top/bottom positions on the GL viewer viewport; E.g. for kCameraOrthoXOY camera left/right are X world coords,; top/bottom are Y world coords; As this is an orthographic camera the other axis (in eye direction) is; no relevant. The near/far clip planes are set automatically based in scene; contents. void SetPerspectiveCamera(TGLViewer::ECameraType camera, Double_t fov, Double_t dolly, Double_t* center, Double_t hRotate, Double_t vRotate); Set a perspective camera to supplied configuration - note this; does not need to be the current camera - though you will not see; the effect if it is not. 'camera' defines the persp camera - one of kCameraPerspXOZ, kCameraPerspYOZ, kCameraPerspXOY; 'fov' - field of view (lens angle) in degrees (clamped to 0.1 - 170.0); 'dolly' - distance from 'center'; 'center' - world position from which dolly/hRotate/vRotate are measured; camera rotates round this, always facing in (in center of viewport); 'hRotate' - horizontal rotation from initial configuration in degrees; 'hRotate' - vertical rotation from initial configuration in degrees. TGLAutoRotator* GetAutoRotator(); Get the auto-rotator for this viewer. void SetAutoRotator(TGLAutoRotator* ar); Set the auto-rotator for this viewer. The old rotator is deleted. void GetGuideState(Int_t& axesType, Bool_t& axesDepthTest, Bool_t& referenceOn, Double_t* referencePos) const; Fetch the state of guides (axes & reference markers) into arguments. void SetGuideState(Int_t axesType, Bool_t axesDepthTest, Bool_t referenceOn, const Double_t* referencePos); Set the state of guides (axes & reference markers) from arguments. void SetDrawCameraCenter(Bool_t x); Draw camera look at and rotation point. const TGLPhysicalShape * GetSelected() const; Return selected physical shape. void MouseOver(TGLPhysicalShape* ); Emit MouseOver signal. void MouseOver(TGLPhysicalShape* , UInt_t state); Emit MouseOver signal. void MouseOver(TObje",MatchSource.WIKI,root/html528/TGLViewer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLViewer.html
https://root.cern/root/html528/TGLViewer.html:31700,Deployability,configurat,configuration,31700,"' / 'bottom' define the WORLD coordinates which; corresepond with the left/right/top/bottom positions on the GL viewer viewport; E.g. for kCameraOrthoXOY camera left/right are X world coords,; top/bottom are Y world coords; As this is an orthographic camera the other axis (in eye direction) is; no relevant. The near/far clip planes are set automatically based in scene; contents. void SetPerspectiveCamera(TGLViewer::ECameraType camera, Double_t fov, Double_t dolly, Double_t* center, Double_t hRotate, Double_t vRotate); Set a perspective camera to supplied configuration - note this; does not need to be the current camera - though you will not see; the effect if it is not. 'camera' defines the persp camera - one of kCameraPerspXOZ, kCameraPerspYOZ, kCameraPerspXOY; 'fov' - field of view (lens angle) in degrees (clamped to 0.1 - 170.0); 'dolly' - distance from 'center'; 'center' - world position from which dolly/hRotate/vRotate are measured; camera rotates round this, always facing in (in center of viewport); 'hRotate' - horizontal rotation from initial configuration in degrees; 'hRotate' - vertical rotation from initial configuration in degrees. TGLAutoRotator* GetAutoRotator(); Get the auto-rotator for this viewer. void SetAutoRotator(TGLAutoRotator* ar); Set the auto-rotator for this viewer. The old rotator is deleted. void GetGuideState(Int_t& axesType, Bool_t& axesDepthTest, Bool_t& referenceOn, Double_t* referencePos) const; Fetch the state of guides (axes & reference markers) into arguments. void SetGuideState(Int_t axesType, Bool_t axesDepthTest, Bool_t referenceOn, const Double_t* referencePos); Set the state of guides (axes & reference markers) from arguments. void SetDrawCameraCenter(Bool_t x); Draw camera look at and rotation point. const TGLPhysicalShape * GetSelected() const; Return selected physical shape. void MouseOver(TGLPhysicalShape* ); Emit MouseOver signal. void MouseOver(TGLPhysicalShape* , UInt_t state); Emit MouseOver signal. void MouseOver(TObje",MatchSource.WIKI,root/html528/TGLViewer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLViewer.html
https://root.cern/root/html528/TGLViewer.html:23348,Integrability,interface,interface,23348,"ewerBase::fWFLineWOptional override of scene wire-frame line-width; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static TGLColorSetfgDefaultColorSet! a shared, default color-set; static Bool_tfgUseDefaultColorSetForNewViewers! name says it all. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLViewer(TVirtualPad* pad, Int_t x, Int_t y, Int_t width, Int_t height); Construct the viewer object, with following arguments:; 'pad' - external pad viewer is bound to; 'x', 'y' - initial top left position; 'width', 'height' - initial width/height. TGLViewer(TVirtualPad* pad); gl-embedded viewer's ctor; Construct the viewer object, with following arguments:; 'pad' - external pad viewer is bound to; 'x', 'y' - initial top left position; 'width', 'height' - initial width/height. void InitSecondaryObjects(); Common initialization. ~TGLViewer(); Destroy viewer object. void PadPaint(TVirtualPad* pad); Entry point for updating viewer contents via VirtualViewer3D; interface.; We search and forward the request to appropriate TGLScenePad.; If it is not found we create a new TGLScenePad so this can; potentially also be used for registration of new pads. void UpdateScene(Bool_t redraw = kTRUE); Force update of pad-scenes. Eventually this could be generalized; to all scene-types via a virtual function in TGLSceneBase. void ResetCurrentCamera(); Resets position/rotation of current camera to default values. void SetupCameras(Bool_t reset); Setup cameras for current bounding box. void PostSceneBuildSetup(Bool_t resetCameras); Perform post scene-build setup. void InitGL(); Initialise GL state. void RequestDraw(Short_t LOD = TGLRnrCtx::kLODMed); Post request for redraw of viewer at level of detail 'LOD'; Request is directed via cross thread gVirtualGL object. void SetupClipObject(); Setup clip-object. Protected virtual method. void PreRender(); Initialize objects that influence rendering.; Called before every ren",MatchSource.WIKI,root/html528/TGLViewer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLViewer.html
https://root.cern/root/html528/TGLViewer.html:34575,Integrability,interface,interface,34575,"cation px, py; This is provided for use when embedding GL viewer into pad. void PrintObjects(); Pass viewer for print capture by TGLOutput. void SelectionChanged(); Update GUI components for embedded viewer selection change. void OverlayDragFinished(); An overlay operation can result in change to an object.; Refresh geditor. void RefreshPadEditor(TObject* obj = 0); Update GED editor if it is set. void SetEventHandler(TGEventHandler* handler); Set the event-handler. The event-handler is owned by the viewer.; If GLWidget is set, the handler is propagated to it. If called with handler=0, the current handler will be deleted; (also from TGLWidget). void RemoveOverlayElement(TGLOverlayElement* el); Remove overlay element. void ClearCurrentOvlElm(); Reset current overlay-element to zero, eventually notifying the; old one that the mouse has left.; Usually called when mouse leaves the window. TGLViewer(const TGLViewer& ). TGLViewer & operator=(const TGLViewer& ). Bool_t CanLoopOnPrimitives() const; TVirtualViewer3D interface ... mostly a facade; Forward to TGLScenePad. { return kTRUE; }. Bool_t PreferLocalFrame() const; Only implemented because they're abstract ... should throw an; exception or assert they are not called. { return kTRUE; }. void BeginScene(); {}. Bool_t BuildingScene() const; { return kFALSE; }. void EndScene(); {}. Int_t AddObject(const TBuffer3D& , Bool_t* = 0); { return TBuffer3D::kNone; }. Int_t AddObject(UInt_t , const TBuffer3D& , Bool_t* = 0); { return TBuffer3D::kNone; }. Bool_t OpenComposite(const TBuffer3D& , Bool_t* = 0); { return kFALSE; }. void CloseComposite(); {}. void AddCompositeOp(UInt_t ); {}. void ResetCameras(); { SetupCameras(kTRUE); }. void ResetCamerasAfterNextUpdate(); { fResetCamerasOnNextUpdate = kTRUE; }. TGLWidget* GetGLWidget(); { return fGLWidget; }. void CreateGLWidget(); {}. void DestroyGLWidget(); {}. Int_t GetDev() const; { return fGLDevice; }. Bool_t GetSmartRefresh() const; { return fSmartRefresh; }. void SetSmartRefresh(B",MatchSource.WIKI,root/html528/TGLViewer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLViewer.html
https://root.cern/root/html528/TGLViewer.html:36599,Integrability,interface,interface,36599,fSmartRefresh = smart_ref; }. TGLColorSet& RefDarkColorSet(); { return fDarkColorSet; }. TGLColorSet& RefLightColorSet(); { return fLightColorSet; }. const TGLRect& RefViewport() const; { return fViewport; }. Int_t ViewportDiagonal() const; { return fViewport.Diagonal(); }. Float_t GetPointScale() const; { return fPointScale; }. Float_t GetLineScale() const; { return fLineScale; }. void SetPointScale(Float_t s); { fPointScale = s; }. void SetLineScale(Float_t s); { fLineScale = s; }. Bool_t GetSmoothPoints() const; { return fSmoothPoints; }. Bool_t GetSmoothLines() const; { return fSmoothLines; }. void SetSmoothPoints(Bool_t s); { fSmoothPoints = s; }. void SetSmoothLines(Bool_t s); { fSmoothLines = s; }. TGLLightSet* GetLightSet() const; { return fLightSet; }. TGLClipSet * GetClipSet() const; { return fClipSet; }. Bool_t GetClipAutoUpdate() const; { return fClipSet->GetAutoUpdate(); }. void SetClipAutoUpdate(Bool_t x); { fClipSet->SetAutoUpdate(x); }. TGLCamera & CurrentCamera() const; External GUI component interface. { return *fCurrentCamera; }. Bool_t GetDrawCameraCenter(); { return fDrawCameraCenter; }. void PickCameraCenter(); { fPushAction = kPushCamCenter; RefreshPadEditor(this); }. void PickAnnotate(); { fPushAction = kPushAnnotate; RefreshPadEditor(this); }. TGLCameraOverlay* GetCameraOverlay() const; { return fCameraOverlay; }. void SetCameraOverlay(TGLCameraOverlay* m); { fCameraOverlay = m; }. Bool_t GetStereo() const; Stereo. { return fStereo; }. Float_t GetStereoZeroParallax() const; { return fStereoZeroParallax; }. Float_t GetStereoEyeOffsetFac() const; { return fStereoEyeOffsetFac; }. Float_t GetStereoFrustumAsymFac() const; { return fStereoFrustumAsymFac; }. void SetStereo(Bool_t s); { fStereo = s; }. void SetStereoZeroParallax(Float_t f); { fStereoZeroParallax = f; }. void SetStereoEyeOffsetFac(Float_t f); { fStereoEyeOffsetFac = f; }. void SetStereoFrustumAsymFac(Float_t f); { fStereoFrustumAsymFac = f; }. EPushAction GetPushAction() const; Push /,MatchSource.WIKI,root/html528/TGLViewer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLViewer.html
https://root.cern/root/html528/TGLViewer.html:1215,Modifiability,plugin,plugin,1215,"ta members; class charts. ROOT; » GRAF3D; » GL; » TGLViewer. class TGLViewer: public TVirtualViewer3D, public TGLViewerBase, public TQObject. Base GL viewer object - used by both standalone and embedded (in pad); GL. Contains core viewer objects :. GL scene - collection of main drawn objects - see TGLStdScene; Cameras (fXyzzCamera) - ortho and perspective cameras - see TGLCamera; Clipping (fClipXyzz) - collection of clip objects - see TGLClip; Manipulators (fXyzzManip) - collection of manipulators - see TGLManip. It maintains the current active draw styles, clipping object,; manipulator, camera etc. TGLViewer is 'GUI free' in that it does not derive from any ROOT GUI; TGFrame etc - see TGLSAViewer for this. However it contains GUI; GUI style methods HandleButton() etc to which GUI events can be; directed from standalone frame or embedding pad to perform; interaction. Also, the TGLWidget needs to be created externally. It is not owned; by the viewer. For embedded (pad) GL this viewer is created directly by plugin; manager. For standalone the derived TGLSAViewer is. Function Members (Methods); public:. TGLViewer(TVirtualPad* pad); TGLViewer(TVirtualPad* pad, Int_t x, Int_t y, Int_t width, Int_t height); virtual~TGLViewer(); voidTObject::AbstractMethod(const char* method) const; virtual voidActivated()SIGNAL ; virtual voidAddCompositeOp(UInt_t); virtual Int_tAddObject(const TBuffer3D&, Bool_t* = 0); virtual Int_tAddObject(UInt_t, const TBuffer3D&, Bool_t* = 0); virtual voidTGLViewerBase::AddOverlayElement(TGLOverlayElement* el); TGLSceneInfo*TGLViewerBase::AddScene(TGLSceneBase* scene); virtual voidTObject::AppendPad(Option_t* option = """"); voidApplySelection(); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; voidAutoFade(Float_t fade, Float_t time = 1, Int_t steps = 10); virtual voidBeginScene(); static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); ",MatchSource.WIKI,root/html528/TGLViewer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLViewer.html
https://root.cern/root/html528/TGLViewer.html:30352,Modifiability,config,configuration,30352,"-set.; This is false at startup. Bool_t IsUsingDefaultColorSetForNewViewers(); Returns the value of the static flag that determines if new; viewers should use the default color-set.; This is false at startup. Bool_t IsColorSetDark() const; Returns true if curremt color set is dark. void SetViewport(Int_t x, Int_t y, Int_t width, Int_t height); Set viewer viewport (window area) with bottom/left at (x,y), with; dimensions 'width'/'height'. void SetViewport(const TGLRect& vp); Set viewr viewport from TGLRect. TGLCamera& RefCamera(TGLViewer::ECameraType camera); Return camera reference by type. void SetCurrentCamera(TGLViewer::ECameraType camera); Set current active camera - 'cameraType' one of:; kCameraPerspX, kCameraPerspY, kCameraPerspZ,; kCameraOrthoXOY, kCameraOrthoXOZ, kCameraOrthoZOY,; kCameraOrthoXnOY, kCameraOrthoXnOZ, kCameraOrthoZnOY. void SetOrthoCamera(TGLViewer::ECameraType camera, Double_t zoom, Double_t dolly, Double_t* center, Double_t hRotate, Double_t vRotate); Set an orthographic camera to supplied configuration - note this; does not need to be the current camera - though you will not see; the effect if it is not. 'camera' defines the ortho camera - one of kCameraOrthoXOY / XOZ / ZOY; 'left' / 'right' / 'top' / 'bottom' define the WORLD coordinates which; corresepond with the left/right/top/bottom positions on the GL viewer viewport; E.g. for kCameraOrthoXOY camera left/right are X world coords,; top/bottom are Y world coords; As this is an orthographic camera the other axis (in eye direction) is; no relevant. The near/far clip planes are set automatically based in scene; contents. void SetPerspectiveCamera(TGLViewer::ECameraType camera, Double_t fov, Double_t dolly, Double_t* center, Double_t hRotate, Double_t vRotate); Set a perspective camera to supplied configuration - note this; does not need to be the current camera - though you will not see; the effect if it is not. 'camera' defines the persp camera - one of kCameraPerspXOZ, kCameraPerspYOZ, k",MatchSource.WIKI,root/html528/TGLViewer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLViewer.html
https://root.cern/root/html528/TGLViewer.html:31126,Modifiability,config,configuration,31126,"OrthoXOZ, kCameraOrthoZOY,; kCameraOrthoXnOY, kCameraOrthoXnOZ, kCameraOrthoZnOY. void SetOrthoCamera(TGLViewer::ECameraType camera, Double_t zoom, Double_t dolly, Double_t* center, Double_t hRotate, Double_t vRotate); Set an orthographic camera to supplied configuration - note this; does not need to be the current camera - though you will not see; the effect if it is not. 'camera' defines the ortho camera - one of kCameraOrthoXOY / XOZ / ZOY; 'left' / 'right' / 'top' / 'bottom' define the WORLD coordinates which; corresepond with the left/right/top/bottom positions on the GL viewer viewport; E.g. for kCameraOrthoXOY camera left/right are X world coords,; top/bottom are Y world coords; As this is an orthographic camera the other axis (in eye direction) is; no relevant. The near/far clip planes are set automatically based in scene; contents. void SetPerspectiveCamera(TGLViewer::ECameraType camera, Double_t fov, Double_t dolly, Double_t* center, Double_t hRotate, Double_t vRotate); Set a perspective camera to supplied configuration - note this; does not need to be the current camera - though you will not see; the effect if it is not. 'camera' defines the persp camera - one of kCameraPerspXOZ, kCameraPerspYOZ, kCameraPerspXOY; 'fov' - field of view (lens angle) in degrees (clamped to 0.1 - 170.0); 'dolly' - distance from 'center'; 'center' - world position from which dolly/hRotate/vRotate are measured; camera rotates round this, always facing in (in center of viewport); 'hRotate' - horizontal rotation from initial configuration in degrees; 'hRotate' - vertical rotation from initial configuration in degrees. TGLAutoRotator* GetAutoRotator(); Get the auto-rotator for this viewer. void SetAutoRotator(TGLAutoRotator* ar); Set the auto-rotator for this viewer. The old rotator is deleted. void GetGuideState(Int_t& axesType, Bool_t& axesDepthTest, Bool_t& referenceOn, Double_t* referencePos) const; Fetch the state of guides (axes & reference markers) into arguments. void SetGu",MatchSource.WIKI,root/html528/TGLViewer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLViewer.html
https://root.cern/root/html528/TGLViewer.html:31631,Modifiability,config,configuration,31631,"' / 'bottom' define the WORLD coordinates which; corresepond with the left/right/top/bottom positions on the GL viewer viewport; E.g. for kCameraOrthoXOY camera left/right are X world coords,; top/bottom are Y world coords; As this is an orthographic camera the other axis (in eye direction) is; no relevant. The near/far clip planes are set automatically based in scene; contents. void SetPerspectiveCamera(TGLViewer::ECameraType camera, Double_t fov, Double_t dolly, Double_t* center, Double_t hRotate, Double_t vRotate); Set a perspective camera to supplied configuration - note this; does not need to be the current camera - though you will not see; the effect if it is not. 'camera' defines the persp camera - one of kCameraPerspXOZ, kCameraPerspYOZ, kCameraPerspXOY; 'fov' - field of view (lens angle) in degrees (clamped to 0.1 - 170.0); 'dolly' - distance from 'center'; 'center' - world position from which dolly/hRotate/vRotate are measured; camera rotates round this, always facing in (in center of viewport); 'hRotate' - horizontal rotation from initial configuration in degrees; 'hRotate' - vertical rotation from initial configuration in degrees. TGLAutoRotator* GetAutoRotator(); Get the auto-rotator for this viewer. void SetAutoRotator(TGLAutoRotator* ar); Set the auto-rotator for this viewer. The old rotator is deleted. void GetGuideState(Int_t& axesType, Bool_t& axesDepthTest, Bool_t& referenceOn, Double_t* referencePos) const; Fetch the state of guides (axes & reference markers) into arguments. void SetGuideState(Int_t axesType, Bool_t axesDepthTest, Bool_t referenceOn, const Double_t* referencePos); Set the state of guides (axes & reference markers) from arguments. void SetDrawCameraCenter(Bool_t x); Draw camera look at and rotation point. const TGLPhysicalShape * GetSelected() const; Return selected physical shape. void MouseOver(TGLPhysicalShape* ); Emit MouseOver signal. void MouseOver(TGLPhysicalShape* , UInt_t state); Emit MouseOver signal. void MouseOver(TObje",MatchSource.WIKI,root/html528/TGLViewer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLViewer.html
https://root.cern/root/html528/TGLViewer.html:31700,Modifiability,config,configuration,31700,"' / 'bottom' define the WORLD coordinates which; corresepond with the left/right/top/bottom positions on the GL viewer viewport; E.g. for kCameraOrthoXOY camera left/right are X world coords,; top/bottom are Y world coords; As this is an orthographic camera the other axis (in eye direction) is; no relevant. The near/far clip planes are set automatically based in scene; contents. void SetPerspectiveCamera(TGLViewer::ECameraType camera, Double_t fov, Double_t dolly, Double_t* center, Double_t hRotate, Double_t vRotate); Set a perspective camera to supplied configuration - note this; does not need to be the current camera - though you will not see; the effect if it is not. 'camera' defines the persp camera - one of kCameraPerspXOZ, kCameraPerspYOZ, kCameraPerspXOY; 'fov' - field of view (lens angle) in degrees (clamped to 0.1 - 170.0); 'dolly' - distance from 'center'; 'center' - world position from which dolly/hRotate/vRotate are measured; camera rotates round this, always facing in (in center of viewport); 'hRotate' - horizontal rotation from initial configuration in degrees; 'hRotate' - vertical rotation from initial configuration in degrees. TGLAutoRotator* GetAutoRotator(); Get the auto-rotator for this viewer. void SetAutoRotator(TGLAutoRotator* ar); Set the auto-rotator for this viewer. The old rotator is deleted. void GetGuideState(Int_t& axesType, Bool_t& axesDepthTest, Bool_t& referenceOn, Double_t* referencePos) const; Fetch the state of guides (axes & reference markers) into arguments. void SetGuideState(Int_t axesType, Bool_t axesDepthTest, Bool_t referenceOn, const Double_t* referencePos); Set the state of guides (axes & reference markers) from arguments. void SetDrawCameraCenter(Bool_t x); Draw camera look at and rotation point. const TGLPhysicalShape * GetSelected() const; Return selected physical shape. void MouseOver(TGLPhysicalShape* ); Emit MouseOver signal. void MouseOver(TGLPhysicalShape* , UInt_t state); Emit MouseOver signal. void MouseOver(TObje",MatchSource.WIKI,root/html528/TGLViewer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLViewer.html
https://root.cern/root/html528/TGLViewer.html:1052,Performance,perform,perform,1052,". TGLViewer. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLViewer. class TGLViewer: public TVirtualViewer3D, public TGLViewerBase, public TQObject. Base GL viewer object - used by both standalone and embedded (in pad); GL. Contains core viewer objects :. GL scene - collection of main drawn objects - see TGLStdScene; Cameras (fXyzzCamera) - ortho and perspective cameras - see TGLCamera; Clipping (fClipXyzz) - collection of clip objects - see TGLClip; Manipulators (fXyzzManip) - collection of manipulators - see TGLManip. It maintains the current active draw styles, clipping object,; manipulator, camera etc. TGLViewer is 'GUI free' in that it does not derive from any ROOT GUI; TGFrame etc - see TGLSAViewer for this. However it contains GUI; GUI style methods HandleButton() etc to which GUI events can be; directed from standalone frame or embedding pad to perform; interaction. Also, the TGLWidget needs to be created externally. It is not owned; by the viewer. For embedded (pad) GL this viewer is created directly by plugin; manager. For standalone the derived TGLSAViewer is. Function Members (Methods); public:. TGLViewer(TVirtualPad* pad); TGLViewer(TVirtualPad* pad, Int_t x, Int_t y, Int_t width, Int_t height); virtual~TGLViewer(); voidTObject::AbstractMethod(const char* method) const; virtual voidActivated()SIGNAL ; virtual voidAddCompositeOp(UInt_t); virtual Int_tAddObject(const TBuffer3D&, Bool_t* = 0); virtual Int_tAddObject(UInt_t, const TBuffer3D&, Bool_t* = 0); virtual voidTGLViewerBase::AddOverlayElement(TGLOverlayElement* el); TGLSceneInfo*TGLViewerBase::AddScene(TGLSceneBase* scene); virtual voidTObject::AppendPad(Option_t* option = """"); voidApplySelection(); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; voidAutoFade(Float_t fade, Fl",MatchSource.WIKI,root/html528/TGLViewer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLViewer.html
https://root.cern/root/html528/TGLViewer.html:21789,Performance,cache,cache,21789,"CameraXOZ!; TGLPerspectiveCamerafPerspectiveCameraYOZ!; TStringfPictureFileName! default file-name for SavePicture(); Float_tfPointScale! size scale for points; TGLViewer::EPushActionfPushAction; TGLRedrawTimer*fRedrawTimer! timer for triggering redraws; Bool_tfReferenceOn! reference marker on?; TGLVertex3fReferencePos! reference position; Bool_tfResetCamerasOnNextUpdatereposition camera on next update; Bool_tfResetCamerasOnUpdatereposition camera on each update; Bool_tTGLViewerBase::fResetSceneInfosOnRenderRequest rebuild of view-specific scene data.; TGLRnrCtx*TGLViewerBase::fRnrCtx; list<TGLSceneInfo*>TGLViewerBase::fScenesRegistered scenes.; TGLSelectRecordfSecSelRec! select record from last secondary select (should go to context); TGLSelectRecordfSelRec! select record from last select (should go to context); TGLManipSet*fSelectedPShapeRef!; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; Bool_tfSmartRefresh! cache logicals during scene rebuilds; Bool_tfSmoothLines! smooth line edge rendering; Bool_tfSmoothPoints! smooth point edge rendering; Bool_tfStereo! use stereo rendering; Float_tfStereoEyeOffsetFac!; Float_tfStereoFrustumAsymFac!; Float_tfStereoZeroParallax! position of zero-parallax plane: 0 - near clipping plane, 1 - far clipping plane; Short_tTGLViewerBase::fStyleViewer-style for rendering.; TGLRectfViewport! viewport - drawn area; vector<TGLSceneInfo*>TGLViewerBase::fVisScenesVisible scenes.; Float_tTGLViewerBase::fWFLineWOptional override of scene wire-frame line-width; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static TGLColorSetfgDefaultColorSet! a shared, default color-set; static Bool_tfgUseDefaultColorSetForNewViewers! name says it all. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLViewer(TVirtualPad* pad, Int_t x, Int_t y, Int_t width, Int_t height); Construct the viewer object, with following arguments:; 'pad' - external pad viewer i",MatchSource.WIKI,root/html528/TGLViewer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLViewer.html
https://root.cern/root/html528/TGLViewer.html:37749,Safety,timeout,timeouts,37749,"Center(); { fPushAction = kPushCamCenter; RefreshPadEditor(this); }. void PickAnnotate(); { fPushAction = kPushAnnotate; RefreshPadEditor(this); }. TGLCameraOverlay* GetCameraOverlay() const; { return fCameraOverlay; }. void SetCameraOverlay(TGLCameraOverlay* m); { fCameraOverlay = m; }. Bool_t GetStereo() const; Stereo. { return fStereo; }. Float_t GetStereoZeroParallax() const; { return fStereoZeroParallax; }. Float_t GetStereoEyeOffsetFac() const; { return fStereoEyeOffsetFac; }. Float_t GetStereoFrustumAsymFac() const; { return fStereoFrustumAsymFac; }. void SetStereo(Bool_t s); { fStereo = s; }. void SetStereoZeroParallax(Float_t f); { fStereoZeroParallax = f; }. void SetStereoEyeOffsetFac(Float_t f); { fStereoEyeOffsetFac = f; }. void SetStereoFrustumAsymFac(Float_t f); { fStereoFrustumAsymFac = f; }. EPushAction GetPushAction() const; Push / drag action. { return fPushAction; }. EDragAction GetDragAction() const; { return fDragAction; }. Float_t GetMaxSceneDrawTimeHQ() const; Draw and selection; Scene rendering timeouts. { return fMaxSceneDrawTimeHQ; }. Float_t GetMaxSceneDrawTimeLQ() const; { return fMaxSceneDrawTimeLQ; }. void SetMaxSceneDrawTimeHQ(Float_t t); { fMaxSceneDrawTimeHQ = t; }. void SetMaxSceneDrawTimeLQ(Float_t t); { fMaxSceneDrawTimeLQ = t; }. const char* GetPictureFileName() const; { return fPictureFileName.Data(); }. void SetPictureFileName(const TString& f); { fPictureFileName = f; }. Float_t GetFader() const; { return fFader; }. void SetFader(Float_t x); { fFader = x; }. Bool_t GetIgnoreSizesOnUpdate() const; { return fIgnoreSizesOnUpdate; }. void SetIgnoreSizesOnUpdate(Bool_t v); { fIgnoreSizesOnUpdate = v; }. Bool_t GetResetCamerasOnUpdate() const; { return fResetCamerasOnUpdate; }. void SetResetCamerasOnUpdate(Bool_t v); { fResetCamerasOnUpdate = v; }. void Activated(); { Emit(""Activated()""); }. void DoubleClicked(); { Emit(""DoubleClicked()""); }. TGEventHandler * GetEventHandler() const; { return fEventHandler; }. TGedEditor* GetGedEdito",MatchSource.WIKI,root/html528/TGLViewer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLViewer.html
https://root.cern/root/html528/TGLViewer.html:21795,Testability,log,logicals,21795,"CameraXOZ!; TGLPerspectiveCamerafPerspectiveCameraYOZ!; TStringfPictureFileName! default file-name for SavePicture(); Float_tfPointScale! size scale for points; TGLViewer::EPushActionfPushAction; TGLRedrawTimer*fRedrawTimer! timer for triggering redraws; Bool_tfReferenceOn! reference marker on?; TGLVertex3fReferencePos! reference position; Bool_tfResetCamerasOnNextUpdatereposition camera on next update; Bool_tfResetCamerasOnUpdatereposition camera on each update; Bool_tTGLViewerBase::fResetSceneInfosOnRenderRequest rebuild of view-specific scene data.; TGLRnrCtx*TGLViewerBase::fRnrCtx; list<TGLSceneInfo*>TGLViewerBase::fScenesRegistered scenes.; TGLSelectRecordfSecSelRec! select record from last secondary select (should go to context); TGLSelectRecordfSelRec! select record from last select (should go to context); TGLManipSet*fSelectedPShapeRef!; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; Bool_tfSmartRefresh! cache logicals during scene rebuilds; Bool_tfSmoothLines! smooth line edge rendering; Bool_tfSmoothPoints! smooth point edge rendering; Bool_tfStereo! use stereo rendering; Float_tfStereoEyeOffsetFac!; Float_tfStereoFrustumAsymFac!; Float_tfStereoZeroParallax! position of zero-parallax plane: 0 - near clipping plane, 1 - far clipping plane; Short_tTGLViewerBase::fStyleViewer-style for rendering.; TGLRectfViewport! viewport - drawn area; vector<TGLSceneInfo*>TGLViewerBase::fVisScenesVisible scenes.; Float_tTGLViewerBase::fWFLineWOptional override of scene wire-frame line-width; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static TGLColorSetfgDefaultColorSet! a shared, default color-set; static Bool_tfgUseDefaultColorSetForNewViewers! name says it all. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLViewer(TVirtualPad* pad, Int_t x, Int_t y, Int_t width, Int_t height); Construct the viewer object, with following arguments:; 'pad' - external pad viewer i",MatchSource.WIKI,root/html528/TGLViewer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLViewer.html
https://root.cern/root/html528/TGLViewer.html:34758,Testability,assert,assert,34758,"wer selection change. void OverlayDragFinished(); An overlay operation can result in change to an object.; Refresh geditor. void RefreshPadEditor(TObject* obj = 0); Update GED editor if it is set. void SetEventHandler(TGEventHandler* handler); Set the event-handler. The event-handler is owned by the viewer.; If GLWidget is set, the handler is propagated to it. If called with handler=0, the current handler will be deleted; (also from TGLWidget). void RemoveOverlayElement(TGLOverlayElement* el); Remove overlay element. void ClearCurrentOvlElm(); Reset current overlay-element to zero, eventually notifying the; old one that the mouse has left.; Usually called when mouse leaves the window. TGLViewer(const TGLViewer& ). TGLViewer & operator=(const TGLViewer& ). Bool_t CanLoopOnPrimitives() const; TVirtualViewer3D interface ... mostly a facade; Forward to TGLScenePad. { return kTRUE; }. Bool_t PreferLocalFrame() const; Only implemented because they're abstract ... should throw an; exception or assert they are not called. { return kTRUE; }. void BeginScene(); {}. Bool_t BuildingScene() const; { return kFALSE; }. void EndScene(); {}. Int_t AddObject(const TBuffer3D& , Bool_t* = 0); { return TBuffer3D::kNone; }. Int_t AddObject(UInt_t , const TBuffer3D& , Bool_t* = 0); { return TBuffer3D::kNone; }. Bool_t OpenComposite(const TBuffer3D& , Bool_t* = 0); { return kFALSE; }. void CloseComposite(); {}. void AddCompositeOp(UInt_t ); {}. void ResetCameras(); { SetupCameras(kTRUE); }. void ResetCamerasAfterNextUpdate(); { fResetCamerasOnNextUpdate = kTRUE; }. TGLWidget* GetGLWidget(); { return fGLWidget; }. void CreateGLWidget(); {}. void DestroyGLWidget(); {}. Int_t GetDev() const; { return fGLDevice; }. Bool_t GetSmartRefresh() const; { return fSmartRefresh; }. void SetSmartRefresh(Bool_t smart_ref); { fSmartRefresh = smart_ref; }. TGLColorSet& RefDarkColorSet(); { return fDarkColorSet; }. TGLColorSet& RefLightColorSet(); { return fLightColorSet; }. const TGLRect& RefViewport() con",MatchSource.WIKI,root/html528/TGLViewer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLViewer.html
https://root.cern/root/html528/TGLViewer.html:18593,Usability,guid,guides,18593,"se::SubRender_foo render_foo); voidSwapBuffers() const. private:. TGLViewer(const TGLViewer&); voidInitSecondaryObjects(); TGLViewer&operator=(const TGLViewer&). Data Members; public:. enum ECameraType { kCameraPerspXOZ; kCameraPerspYOZ; kCameraPerspXOY; kCameraOrthoXOY; kCameraOrthoXOZ; kCameraOrthoZOY; kCameraOrthoXnOY; kCameraOrthoXnOZ; kCameraOrthoZnOY; };; enum ESecSelType { kOnRequest; kOnKeyMod1; };; enum EPushAction { kPushStd; kPushCamCenter; kPushAnnotate; };; enum EDragAction { kDragNone; kDragCameraRotate; kDragCameraTruck; kDragCameraDolly; kDragOverlay; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };; enum TGLLockable::ELock { kUnlocked; kDrawLock; kSelectLock; kModifyLock; };. protected:. TGLAutoRotator*fAutoRotator!; Bool_tfAxesDepthTest! remove guides hidden-lines; Int_tfAxesType! axes type; TGLCamera*TGLViewerBase::fCameraCamera for rendering.; TGLCameraOverlay*fCameraOverlay! markup size of viewport in scene units; Bool_tTGLViewerBase::fChangedChange requiring redraw is pending.; TGLClip*TGLViewerBase::fClipViewer clipping-plane.; TGLClipSet*fClipSet!; TContextMenu*fContextMenu!; TGLCamera*fCurrentCamera!; TGLOverlayElement*fCurrentOvlElm! current overlay element; TGLSelectRecordfCurrentSelRec! select record in use as selected; TGLColorSetfDarkColorSet! color-set with dark background; Bool_tfDebugMode! debug mode (forced rebuild + draw scene/frustum/interest boxes); TGLViewer::EDragActionfDragAction; Bool_tfDrawCameraCenter! reference marker on?; TGEventHandler*fEventHandler! event handler; Float_tfFader! fade the view (0 - no fade/default, 1 - full fade/no rendering done); TGLContextIdentity*fGLCtxId!for embedded gl viewer; Int_tfGLDevice!for embedded gl viewer; TGLWidget*fGLWidget; TGedEditor*fGedEditor! GED editor; Bool_tfIgnoreSizesOnUpdate",MatchSource.WIKI,root/html528/TGLViewer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLViewer.html
https://root.cern/root/html528/TGLViewer.html:32035,Usability,guid,guides,32035,"e camera, Double_t fov, Double_t dolly, Double_t* center, Double_t hRotate, Double_t vRotate); Set a perspective camera to supplied configuration - note this; does not need to be the current camera - though you will not see; the effect if it is not. 'camera' defines the persp camera - one of kCameraPerspXOZ, kCameraPerspYOZ, kCameraPerspXOY; 'fov' - field of view (lens angle) in degrees (clamped to 0.1 - 170.0); 'dolly' - distance from 'center'; 'center' - world position from which dolly/hRotate/vRotate are measured; camera rotates round this, always facing in (in center of viewport); 'hRotate' - horizontal rotation from initial configuration in degrees; 'hRotate' - vertical rotation from initial configuration in degrees. TGLAutoRotator* GetAutoRotator(); Get the auto-rotator for this viewer. void SetAutoRotator(TGLAutoRotator* ar); Set the auto-rotator for this viewer. The old rotator is deleted. void GetGuideState(Int_t& axesType, Bool_t& axesDepthTest, Bool_t& referenceOn, Double_t* referencePos) const; Fetch the state of guides (axes & reference markers) into arguments. void SetGuideState(Int_t axesType, Bool_t axesDepthTest, Bool_t referenceOn, const Double_t* referencePos); Set the state of guides (axes & reference markers) from arguments. void SetDrawCameraCenter(Bool_t x); Draw camera look at and rotation point. const TGLPhysicalShape * GetSelected() const; Return selected physical shape. void MouseOver(TGLPhysicalShape* ); Emit MouseOver signal. void MouseOver(TGLPhysicalShape* , UInt_t state); Emit MouseOver signal. void MouseOver(TObject* obj, UInt_t state); Emit MouseOver signal. void ReMouseOver(TObject* obj, UInt_t state); Emit MouseOver signal. void UnMouseOver(TObject* obj, UInt_t state); Emit UnMouseOver signal. void Clicked(TObject* obj); Emit Clicked signal. void Clicked(TObject* obj, UInt_t button, UInt_t state); Emit Clicked signal with button id and modifier state. void ReClicked(TObject* obj, UInt_t button, UInt_t state); Emit ReClicked signal",MatchSource.WIKI,root/html528/TGLViewer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLViewer.html
https://root.cern/root/html528/TGLViewer.html:32210,Usability,guid,guides,32210,"e the current camera - though you will not see; the effect if it is not. 'camera' defines the persp camera - one of kCameraPerspXOZ, kCameraPerspYOZ, kCameraPerspXOY; 'fov' - field of view (lens angle) in degrees (clamped to 0.1 - 170.0); 'dolly' - distance from 'center'; 'center' - world position from which dolly/hRotate/vRotate are measured; camera rotates round this, always facing in (in center of viewport); 'hRotate' - horizontal rotation from initial configuration in degrees; 'hRotate' - vertical rotation from initial configuration in degrees. TGLAutoRotator* GetAutoRotator(); Get the auto-rotator for this viewer. void SetAutoRotator(TGLAutoRotator* ar); Set the auto-rotator for this viewer. The old rotator is deleted. void GetGuideState(Int_t& axesType, Bool_t& axesDepthTest, Bool_t& referenceOn, Double_t* referencePos) const; Fetch the state of guides (axes & reference markers) into arguments. void SetGuideState(Int_t axesType, Bool_t axesDepthTest, Bool_t referenceOn, const Double_t* referencePos); Set the state of guides (axes & reference markers) from arguments. void SetDrawCameraCenter(Bool_t x); Draw camera look at and rotation point. const TGLPhysicalShape * GetSelected() const; Return selected physical shape. void MouseOver(TGLPhysicalShape* ); Emit MouseOver signal. void MouseOver(TGLPhysicalShape* , UInt_t state); Emit MouseOver signal. void MouseOver(TObject* obj, UInt_t state); Emit MouseOver signal. void ReMouseOver(TObject* obj, UInt_t state); Emit MouseOver signal. void UnMouseOver(TObject* obj, UInt_t state); Emit UnMouseOver signal. void Clicked(TObject* obj); Emit Clicked signal. void Clicked(TObject* obj, UInt_t button, UInt_t state); Emit Clicked signal with button id and modifier state. void ReClicked(TObject* obj, UInt_t button, UInt_t state); Emit ReClicked signal with button id and modifier state. void UnClicked(TObject* obj, UInt_t button, UInt_t state); Emit UnClicked signal with button id and modifier state. void MouseIdle(TGLPhysical",MatchSource.WIKI,root/html528/TGLViewer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLViewer.html
https://root.cern/root/html528/TGLViewerBase.html:489,Availability,avail,available,489,". TGLViewerBase. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLViewerBase. class TGLViewerBase: public TGLLockable. Base class for GL viewers. Provides a basic scene management and a; small set of control variables (camera, LOD, style, clip) that are; used by the scene classes. Renering wrappers are available but; minimal. There is no concept of GL-context here ... we just draw; into whatever is set from outside. Development notes:. Each viewer automatically creates a TGLRnrCtx and passes it down; all render functions. Function Members (Methods); public:. TGLViewerBase(); virtual~TGLViewerBase(); virtual voidAddOverlayElement(TGLOverlayElement* el); TGLSceneInfo*AddScene(TGLSceneBase* scene); virtual voidChanged(); static TClass*Class(); TGLClip*Clip() const; TGLLockable::ELockTGLLockable::CurrentLock() const; virtual voidDeleteOverlayAnnotations(); virtual voidDeleteOverlayElements(TGLOverlayElement::ERole r); Bool_tFindClosestOpaqueRecord(TGLSelectRecord& rec, Int_t& recIdx); Bool_tFindClosestOverlayRecord(TGLOvlSelectRecord& rec, Int_t& recIdx); Bool_tFindClosestRecord(TGLSelectRecord& rec, Int_t& recIdx); TGLLogicalShape*FindLogicalInScenes(TObject* id); TGLRnrCtx*GetRnrCtx() const; TGLSceneInfo*GetSceneInfo(TGLSceneBase* scene); virtual TClass*IsA() const; virtual Bool_tIsChanged() const; Bool_tTGLLockable::IsDrawOrSelectLock() const; Bool_tTGLLockable::IsLocked() const; virtual const char*LockIdStr() const; static const char*TGLLockable::LockName(TGLLockable::ELock lock); static Bool_tTGLLockable::LockValid(TGLLockable::ELock lock); Short_tLOD() const; virtual voidMergeSceneBBoxes(TGLBoundingBox& bbox); Float_tOLLineW() const; virtual voidPostRender(); virtual voidPostRenderOverlaySelection(); virtual voidPreRender(); virtual voidPreRenderOverlaySelection(); Bool_tTGLLockable:",MatchSource.WIKI,root/html528/TGLViewerBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLViewerBase.html
https://root.cern/root/html528/TGLViewerBase.html:685,Availability,down,down,685,". TGLViewerBase. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLViewerBase. class TGLViewerBase: public TGLLockable. Base class for GL viewers. Provides a basic scene management and a; small set of control variables (camera, LOD, style, clip) that are; used by the scene classes. Renering wrappers are available but; minimal. There is no concept of GL-context here ... we just draw; into whatever is set from outside. Development notes:. Each viewer automatically creates a TGLRnrCtx and passes it down; all render functions. Function Members (Methods); public:. TGLViewerBase(); virtual~TGLViewerBase(); virtual voidAddOverlayElement(TGLOverlayElement* el); TGLSceneInfo*AddScene(TGLSceneBase* scene); virtual voidChanged(); static TClass*Class(); TGLClip*Clip() const; TGLLockable::ELockTGLLockable::CurrentLock() const; virtual voidDeleteOverlayAnnotations(); virtual voidDeleteOverlayElements(TGLOverlayElement::ERole r); Bool_tFindClosestOpaqueRecord(TGLSelectRecord& rec, Int_t& recIdx); Bool_tFindClosestOverlayRecord(TGLOvlSelectRecord& rec, Int_t& recIdx); Bool_tFindClosestRecord(TGLSelectRecord& rec, Int_t& recIdx); TGLLogicalShape*FindLogicalInScenes(TObject* id); TGLRnrCtx*GetRnrCtx() const; TGLSceneInfo*GetSceneInfo(TGLSceneBase* scene); virtual TClass*IsA() const; virtual Bool_tIsChanged() const; Bool_tTGLLockable::IsDrawOrSelectLock() const; Bool_tTGLLockable::IsLocked() const; virtual const char*LockIdStr() const; static const char*TGLLockable::LockName(TGLLockable::ELock lock); static Bool_tTGLLockable::LockValid(TGLLockable::ELock lock); Short_tLOD() const; virtual voidMergeSceneBBoxes(TGLBoundingBox& bbox); Float_tOLLineW() const; virtual voidPostRender(); virtual voidPostRenderOverlaySelection(); virtual voidPreRender(); virtual voidPreRenderOverlaySelection(); Bool_tTGLLockable:",MatchSource.WIKI,root/html528/TGLViewerBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLViewerBase.html
https://root.cern/root/html528/TGLViewerBase.html:476,Integrability,wrap,wrappers,476,". TGLViewerBase. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLViewerBase. class TGLViewerBase: public TGLLockable. Base class for GL viewers. Provides a basic scene management and a; small set of control variables (camera, LOD, style, clip) that are; used by the scene classes. Renering wrappers are available but; minimal. There is no concept of GL-context here ... we just draw; into whatever is set from outside. Development notes:. Each viewer automatically creates a TGLRnrCtx and passes it down; all render functions. Function Members (Methods); public:. TGLViewerBase(); virtual~TGLViewerBase(); virtual voidAddOverlayElement(TGLOverlayElement* el); TGLSceneInfo*AddScene(TGLSceneBase* scene); virtual voidChanged(); static TClass*Class(); TGLClip*Clip() const; TGLLockable::ELockTGLLockable::CurrentLock() const; virtual voidDeleteOverlayAnnotations(); virtual voidDeleteOverlayElements(TGLOverlayElement::ERole r); Bool_tFindClosestOpaqueRecord(TGLSelectRecord& rec, Int_t& recIdx); Bool_tFindClosestOverlayRecord(TGLOvlSelectRecord& rec, Int_t& recIdx); Bool_tFindClosestRecord(TGLSelectRecord& rec, Int_t& recIdx); TGLLogicalShape*FindLogicalInScenes(TObject* id); TGLRnrCtx*GetRnrCtx() const; TGLSceneInfo*GetSceneInfo(TGLSceneBase* scene); virtual TClass*IsA() const; virtual Bool_tIsChanged() const; Bool_tTGLLockable::IsDrawOrSelectLock() const; Bool_tTGLLockable::IsLocked() const; virtual const char*LockIdStr() const; static const char*TGLLockable::LockName(TGLLockable::ELock lock); static Bool_tTGLLockable::LockValid(TGLLockable::ELock lock); Short_tLOD() const; virtual voidMergeSceneBBoxes(TGLBoundingBox& bbox); Float_tOLLineW() const; virtual voidPostRender(); virtual voidPostRenderOverlaySelection(); virtual voidPreRender(); virtual voidPreRenderOverlaySelection(); Bool_tTGLLockable:",MatchSource.WIKI,root/html528/TGLViewerBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLViewerBase.html
https://root.cern/root/html528/TGLViewerBase.html:5189,Integrability,depend,dependent,5189,"cene(TGLSceneBase* scene); Add new scene, appropriate scene-info is created. void RemoveScene(TGLSceneBase* scene); Remove scene from the viewer, its scene-info is deleted. void RemoveAllScenes(); Remove all scenes from the viewer, their scene-infos are deleted. void SceneDestructing(TGLSceneBase* scene); Remove scene, its scene-info is deleted.; Called from scene that is being destroyed while still holding; viewer references. TGLSceneInfo* GetSceneInfo(TGLSceneBase* scene); Find scene-info corresponding to scene. TGLLogicalShape* FindLogicalInScenes(TObject* id); Find logical-shape representing object id in the list of scenes.; Return 0 if not found. void AddOverlayElement(TGLOverlayElement* el); Add overlay element. void RemoveOverlayElement(TGLOverlayElement* el); Remove overlay element. void DeleteOverlayAnnotations(); Delete overlay elements that are annotations. void DeleteOverlayElements(TGLOverlayElement::ERole r); Delete overlay elements. void ResetSceneInfos(); Force rebuild of view-dependent scene-info structures. This should be called before calling render (draw/select) if; something that affects camera interest has been changed. void MergeSceneBBoxes(TGLBoundingBox& bbox); Merge bounding-boxes of all active registered scenes. void SetupClipObject(); Setup clip-object. Protected virtual method. void PreRender(); Initialize render-context, setup camera, GL, render-area.; Check and lock scenes, determine their visibility. void SubRenderScenes(TGLViewerBase::SubRender_foo render_foo); Call sub-rendering function render_foo on all currently visible; scenes. void Render(); Render all scenes. This is done in four passes:; - render opaque objects from all scenes; - render transparent objects from all scenes; - clear depth buffer; - render opaque selected objects from all scenes (with highlight); - render transparent selected objects from all scenes (with highlight). void RenderNonSelected(); Render non-selected objects from all scenes. void RenderSelected(); Ren",MatchSource.WIKI,root/html528/TGLViewerBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLViewerBase.html
https://root.cern/root/html528/TGLViewerBase.html:393,Modifiability,variab,variables,393,". TGLViewerBase. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLViewerBase. class TGLViewerBase: public TGLLockable. Base class for GL viewers. Provides a basic scene management and a; small set of control variables (camera, LOD, style, clip) that are; used by the scene classes. Renering wrappers are available but; minimal. There is no concept of GL-context here ... we just draw; into whatever is set from outside. Development notes:. Each viewer automatically creates a TGLRnrCtx and passes it down; all render functions. Function Members (Methods); public:. TGLViewerBase(); virtual~TGLViewerBase(); virtual voidAddOverlayElement(TGLOverlayElement* el); TGLSceneInfo*AddScene(TGLSceneBase* scene); virtual voidChanged(); static TClass*Class(); TGLClip*Clip() const; TGLLockable::ELockTGLLockable::CurrentLock() const; virtual voidDeleteOverlayAnnotations(); virtual voidDeleteOverlayElements(TGLOverlayElement::ERole r); Bool_tFindClosestOpaqueRecord(TGLSelectRecord& rec, Int_t& recIdx); Bool_tFindClosestOverlayRecord(TGLOvlSelectRecord& rec, Int_t& recIdx); Bool_tFindClosestRecord(TGLSelectRecord& rec, Int_t& recIdx); TGLLogicalShape*FindLogicalInScenes(TObject* id); TGLRnrCtx*GetRnrCtx() const; TGLSceneInfo*GetSceneInfo(TGLSceneBase* scene); virtual TClass*IsA() const; virtual Bool_tIsChanged() const; Bool_tTGLLockable::IsDrawOrSelectLock() const; Bool_tTGLLockable::IsLocked() const; virtual const char*LockIdStr() const; static const char*TGLLockable::LockName(TGLLockable::ELock lock); static Bool_tTGLLockable::LockValid(TGLLockable::ELock lock); Short_tLOD() const; virtual voidMergeSceneBBoxes(TGLBoundingBox& bbox); Float_tOLLineW() const; virtual voidPostRender(); virtual voidPostRenderOverlaySelection(); virtual voidPreRender(); virtual voidPreRenderOverlaySelection(); Bool_tTGLLockable:",MatchSource.WIKI,root/html528/TGLViewerBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLViewerBase.html
https://root.cern/root/html528/TGLViewerBase.html:4757,Testability,log,logical-shape,4757,"ng.; vector<TGLSceneInfo*>fVisScenesVisible scenes.; Float_tfWFLineWOptional override of scene wire-frame line-width. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLViewerBase(); Constructor. ~TGLViewerBase(); Destructor. const char* LockIdStr() const; Name to print in locking output. FindScene(TGLSceneBase* scene); Find scene-info corresponding to scene. TGLSceneInfo* AddScene(TGLSceneBase* scene); Add new scene, appropriate scene-info is created. void RemoveScene(TGLSceneBase* scene); Remove scene from the viewer, its scene-info is deleted. void RemoveAllScenes(); Remove all scenes from the viewer, their scene-infos are deleted. void SceneDestructing(TGLSceneBase* scene); Remove scene, its scene-info is deleted.; Called from scene that is being destroyed while still holding; viewer references. TGLSceneInfo* GetSceneInfo(TGLSceneBase* scene); Find scene-info corresponding to scene. TGLLogicalShape* FindLogicalInScenes(TObject* id); Find logical-shape representing object id in the list of scenes.; Return 0 if not found. void AddOverlayElement(TGLOverlayElement* el); Add overlay element. void RemoveOverlayElement(TGLOverlayElement* el); Remove overlay element. void DeleteOverlayAnnotations(); Delete overlay elements that are annotations. void DeleteOverlayElements(TGLOverlayElement::ERole r); Delete overlay elements. void ResetSceneInfos(); Force rebuild of view-dependent scene-info structures. This should be called before calling render (draw/select) if; something that affects camera interest has been changed. void MergeSceneBBoxes(TGLBoundingBox& bbox); Merge bounding-boxes of all active registered scenes. void SetupClipObject(); Setup clip-object. Protected virtual method. void PreRender(); Initialize render-context, setup camera, GL, render-area.; Check and lock scenes, determine their visibility. void SubRenderScenes(TGLViewerBase::SubRender_foo render_foo); Call sub-rendering function render_foo on all currently vi",MatchSource.WIKI,root/html528/TGLViewerBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLViewerBase.html
https://root.cern/root/html528/TGLViewerBase.html:5926,Usability,clear,clear,5926,"Element* el); Remove overlay element. void DeleteOverlayAnnotations(); Delete overlay elements that are annotations. void DeleteOverlayElements(TGLOverlayElement::ERole r); Delete overlay elements. void ResetSceneInfos(); Force rebuild of view-dependent scene-info structures. This should be called before calling render (draw/select) if; something that affects camera interest has been changed. void MergeSceneBBoxes(TGLBoundingBox& bbox); Merge bounding-boxes of all active registered scenes. void SetupClipObject(); Setup clip-object. Protected virtual method. void PreRender(); Initialize render-context, setup camera, GL, render-area.; Check and lock scenes, determine their visibility. void SubRenderScenes(TGLViewerBase::SubRender_foo render_foo); Call sub-rendering function render_foo on all currently visible; scenes. void Render(); Render all scenes. This is done in four passes:; - render opaque objects from all scenes; - render transparent objects from all scenes; - clear depth buffer; - render opaque selected objects from all scenes (with highlight); - render transparent selected objects from all scenes (with highlight). void RenderNonSelected(); Render non-selected objects from all scenes. void RenderSelected(); Render selected objects from all scenes. void RenderOverlay(Int_t state, Bool_t selection); Render overlay objects. void PostRender(); Function called after rendering is finished.; Here we just unlock the scenes. void PreRenderOverlaySelection(); Perform minimal initialization for overlay selection.; Here we assume that scene has already been drawn and that; camera and overall bounding box are ok.; Scenes are not locked. void PostRenderOverlaySelection(); Perform cleanup after overlay selection. Bool_t ResolveSelectRecord(TGLSelectRecord& rec, Int_t recIdx); Process selection record on buffer-position 'recIdx' and; fill the data into 'rec'. Returns TRUE if scene was demangled and an object identified.; When FALSE is returned it is still possible that scene",MatchSource.WIKI,root/html528/TGLViewerBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLViewerBase.html
https://root.cern/root/html528/TGLViewerEditor.html:4777,Availability,error,error,4777,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const;",MatchSource.WIKI,root/html528/TGLViewerEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLViewerEditor.html
https://root.cern/root/html528/TGLViewerEditor.html:4861,Availability,error,error,4861,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType() c",MatchSource.WIKI,root/html528/TGLViewerEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLViewerEditor.html
https://root.cern/root/html528/TGLViewerEditor.html:18056,Availability,mask,mask,18056,,MatchSource.WIKI,root/html528/TGLViewerEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLViewerEditor.html
https://root.cern/root/html528/TGLViewerEditor.html:22386,Deployability,toggle,toggled,22386,"berEntry*fPointSizeScale; TGCheckButton*fPointSmooth; TGGroupFrame*fRefContainer; TGCheckButton*fReferenceOn; TGNumberEntry*fReferencePosX; TGNumberEntry*fReferencePosY; TGNumberEntry*fReferencePosZ; TGCheckButton*fResetCamerasOnUpdate; TGNumberEntry*fStereoEyeOffsetFac; TGCompositeFrame*fStereoFrame; TGNumberEntry*fStereoFrustumAsymFac; TGNumberEntry*fStereoZeroParallax; TGTextButton*fUpdateScene; TGLViewer*fViewer; TGNumberEntry*fWFLineWidth. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLViewerEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor. ~TGLViewerEditor(); Destructor. void ConnectSignals2Slots(); Connect signals to slots. void ViewerRedraw(); Initiate redraw of the viewer. void SetModel(TObject* obj); Sets model or disables/hides viewer. void DoClearColor(Pixel_t color); Clear-color was changed. void DoIgnoreSizesOnUpdate(); ResetCamerasOnUpdate was toggled. void DoResetCamerasOnUpdate(); ResetCamerasOnUpdate was toggled. void DoUpdateScene(); UpdateScene was clicked. void DoCameraHome(); CameraHome was clicked. void UpdateMaxDrawTimes(); Slot for fMaxSceneDrawTimeHQ and fMaxSceneDrawTimeLQ. void UpdatePointLineStuff(); Slot for point-sizes and line-widths. void DoCameraOverlay(); Update viewer with GUI state. void DoCameraCenterExt(); Set external camera center. void DoCaptureCenter(); Capture camera-center via picking. void DoDrawCameraCenter(); Draw camera center. void UpdateCameraCenter(); Update current camera with GUI state. void DoAnnotation(); Create annotation via picking. void UpdateViewerAxes(Int_t id); Update viewer with GUI state. void UpdateViewerReference(); Update viewer with GUI state. TGNumberEntry* MakeLabeledNEntry(TGCompositeFrame* p, const char* name, Int_t labelw, Int_t nd = 7, Int_t s = 5); Helper function to create fixed width TGLabel and TGNumberEntry in same row. void CreateStyleT",MatchSource.WIKI,root/html528/TGLViewerEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLViewerEditor.html
https://root.cern/root/html528/TGLViewerEditor.html:22451,Deployability,toggle,toggled,22451,"me*fRefContainer; TGCheckButton*fReferenceOn; TGNumberEntry*fReferencePosX; TGNumberEntry*fReferencePosY; TGNumberEntry*fReferencePosZ; TGCheckButton*fResetCamerasOnUpdate; TGNumberEntry*fStereoEyeOffsetFac; TGCompositeFrame*fStereoFrame; TGNumberEntry*fStereoFrustumAsymFac; TGNumberEntry*fStereoZeroParallax; TGTextButton*fUpdateScene; TGLViewer*fViewer; TGNumberEntry*fWFLineWidth. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLViewerEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor. ~TGLViewerEditor(); Destructor. void ConnectSignals2Slots(); Connect signals to slots. void ViewerRedraw(); Initiate redraw of the viewer. void SetModel(TObject* obj); Sets model or disables/hides viewer. void DoClearColor(Pixel_t color); Clear-color was changed. void DoIgnoreSizesOnUpdate(); ResetCamerasOnUpdate was toggled. void DoResetCamerasOnUpdate(); ResetCamerasOnUpdate was toggled. void DoUpdateScene(); UpdateScene was clicked. void DoCameraHome(); CameraHome was clicked. void UpdateMaxDrawTimes(); Slot for fMaxSceneDrawTimeHQ and fMaxSceneDrawTimeLQ. void UpdatePointLineStuff(); Slot for point-sizes and line-widths. void DoCameraOverlay(); Update viewer with GUI state. void DoCameraCenterExt(); Set external camera center. void DoCaptureCenter(); Capture camera-center via picking. void DoDrawCameraCenter(); Draw camera center. void UpdateCameraCenter(); Update current camera with GUI state. void DoAnnotation(); Create annotation via picking. void UpdateViewerAxes(Int_t id); Update viewer with GUI state. void UpdateViewerReference(); Update viewer with GUI state. TGNumberEntry* MakeLabeledNEntry(TGCompositeFrame* p, const char* name, Int_t labelw, Int_t nd = 7, Int_t s = 5); Helper function to create fixed width TGLabel and TGNumberEntry in same row. void CreateStyleTab(); Creates ""Style"" tab. void CreateGuidesTab(); Create ""Guides",MatchSource.WIKI,root/html528/TGLViewerEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLViewerEditor.html
https://root.cern/root/html528/TGLViewerEditor.html:23847,Modifiability,variab,variables,23847,"amerasOnUpdate was toggled. void DoUpdateScene(); UpdateScene was clicked. void DoCameraHome(); CameraHome was clicked. void UpdateMaxDrawTimes(); Slot for fMaxSceneDrawTimeHQ and fMaxSceneDrawTimeLQ. void UpdatePointLineStuff(); Slot for point-sizes and line-widths. void DoCameraOverlay(); Update viewer with GUI state. void DoCameraCenterExt(); Set external camera center. void DoCaptureCenter(); Capture camera-center via picking. void DoDrawCameraCenter(); Draw camera center. void UpdateCameraCenter(); Update current camera with GUI state. void DoAnnotation(); Create annotation via picking. void UpdateViewerAxes(Int_t id); Update viewer with GUI state. void UpdateViewerReference(); Update viewer with GUI state. TGNumberEntry* MakeLabeledNEntry(TGCompositeFrame* p, const char* name, Int_t labelw, Int_t nd = 7, Int_t s = 5); Helper function to create fixed width TGLabel and TGNumberEntry in same row. void CreateStyleTab(); Creates ""Style"" tab. void CreateGuidesTab(); Create ""Guides"" tab. void CreateClippingTab(); Create GUI controls - clip type (none/plane/box) and plane/box properties. void CreateExtrasTab(); Create Extra Tab controls - camera rotator and stereo. void UpdateReferencePosState(); Enable/disable reference position (x/y/z) number edits based on; reference check box. void SetGuides(); Configuration of guides GUI called from SetModel(). void UpdateRotator(); Update rotator related variables. void DoRotatorStart(); Start auto-rotator. void DoRotatorStop(); Stop auto-rotator. void UpdateStereo(); Update stereo related variables. TGLViewerEditor(const TGLViewerEditor& ). void DetachFromPad(); {fIsInPad = kFALSE;}. » Author: Alja Mrak-Tadel, Matevz Tadel, Timur Pocheptsov 08/03/2006 » Copyright (C) 1995-2006, Rene Brun and Fons Rademakers. *; » Last changed: root/gl:$Id$ » Last generated: 2010-10-20 08:46; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html528/TGLViewerEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLViewerEditor.html
https://root.cern/root/html528/TGLViewerEditor.html:23985,Modifiability,variab,variables,23985,"amerasOnUpdate was toggled. void DoUpdateScene(); UpdateScene was clicked. void DoCameraHome(); CameraHome was clicked. void UpdateMaxDrawTimes(); Slot for fMaxSceneDrawTimeHQ and fMaxSceneDrawTimeLQ. void UpdatePointLineStuff(); Slot for point-sizes and line-widths. void DoCameraOverlay(); Update viewer with GUI state. void DoCameraCenterExt(); Set external camera center. void DoCaptureCenter(); Capture camera-center via picking. void DoDrawCameraCenter(); Draw camera center. void UpdateCameraCenter(); Update current camera with GUI state. void DoAnnotation(); Create annotation via picking. void UpdateViewerAxes(Int_t id); Update viewer with GUI state. void UpdateViewerReference(); Update viewer with GUI state. TGNumberEntry* MakeLabeledNEntry(TGCompositeFrame* p, const char* name, Int_t labelw, Int_t nd = 7, Int_t s = 5); Helper function to create fixed width TGLabel and TGNumberEntry in same row. void CreateStyleTab(); Creates ""Style"" tab. void CreateGuidesTab(); Create ""Guides"" tab. void CreateClippingTab(); Create GUI controls - clip type (none/plane/box) and plane/box properties. void CreateExtrasTab(); Create Extra Tab controls - camera rotator and stereo. void UpdateReferencePosState(); Enable/disable reference position (x/y/z) number edits based on; reference check box. void SetGuides(); Configuration of guides GUI called from SetModel(). void UpdateRotator(); Update rotator related variables. void DoRotatorStart(); Start auto-rotator. void DoRotatorStop(); Stop auto-rotator. void UpdateStereo(); Update stereo related variables. TGLViewerEditor(const TGLViewerEditor& ). void DetachFromPad(); {fIsInPad = kFALSE;}. » Author: Alja Mrak-Tadel, Matevz Tadel, Timur Pocheptsov 08/03/2006 » Copyright (C) 1995-2006, Rene Brun and Fons Rademakers. *; » Last changed: root/gl:$Id$ » Last generated: 2010-10-20 08:46; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html528/TGLViewerEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLViewerEditor.html
https://root.cern/root/html528/TGLViewerEditor.html:23767,Usability,guid,guides,23767,"amerasOnUpdate was toggled. void DoUpdateScene(); UpdateScene was clicked. void DoCameraHome(); CameraHome was clicked. void UpdateMaxDrawTimes(); Slot for fMaxSceneDrawTimeHQ and fMaxSceneDrawTimeLQ. void UpdatePointLineStuff(); Slot for point-sizes and line-widths. void DoCameraOverlay(); Update viewer with GUI state. void DoCameraCenterExt(); Set external camera center. void DoCaptureCenter(); Capture camera-center via picking. void DoDrawCameraCenter(); Draw camera center. void UpdateCameraCenter(); Update current camera with GUI state. void DoAnnotation(); Create annotation via picking. void UpdateViewerAxes(Int_t id); Update viewer with GUI state. void UpdateViewerReference(); Update viewer with GUI state. TGNumberEntry* MakeLabeledNEntry(TGCompositeFrame* p, const char* name, Int_t labelw, Int_t nd = 7, Int_t s = 5); Helper function to create fixed width TGLabel and TGNumberEntry in same row. void CreateStyleTab(); Creates ""Style"" tab. void CreateGuidesTab(); Create ""Guides"" tab. void CreateClippingTab(); Create GUI controls - clip type (none/plane/box) and plane/box properties. void CreateExtrasTab(); Create Extra Tab controls - camera rotator and stereo. void UpdateReferencePosState(); Enable/disable reference position (x/y/z) number edits based on; reference check box. void SetGuides(); Configuration of guides GUI called from SetModel(). void UpdateRotator(); Update rotator related variables. void DoRotatorStart(); Start auto-rotator. void DoRotatorStop(); Stop auto-rotator. void UpdateStereo(); Update stereo related variables. TGLViewerEditor(const TGLViewerEditor& ). void DetachFromPad(); {fIsInPad = kFALSE;}. » Author: Alja Mrak-Tadel, Matevz Tadel, Timur Pocheptsov 08/03/2006 » Copyright (C) 1995-2006, Rene Brun and Fons Rademakers. *; » Last changed: root/gl:$Id$ » Last generated: 2010-10-20 08:46; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html528/TGLViewerEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLViewerEditor.html
https://root.cern/root/html528/TGLWidget.html:5691,Availability,error,error,5691,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidExtractViewport(Int_t* vp) const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; virtual const TGLContext*GetContext() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGFrame::GetDefaultSize() const; virtual UInt_tTGFrame::GetDefaultWidth() const; virtual TDND",MatchSource.WIKI,root/html528/TGLWidget.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLWidget.html
https://root.cern/root/html528/TGLWidget.html:5775,Availability,error,error,5775,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidExtractViewport(Int_t* vp) const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; virtual const TGLContext*GetContext() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGFrame::GetDefaultSize() const; virtual UInt_tTGFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType() const; virtual",MatchSource.WIKI,root/html528/TGLWidget.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLWidget.html
https://root.cern/root/html528/TGLWidget.html:17319,Availability,mask,mask,17319,"ngleKey; kOverwrite; kWriteDelete; };. protected:. Pixel_tTGFrame::fBackgroundframe background color; Int_tTGFrame::fBorderWidthframe border width; TGClient*TGObject::fClientConnection to display server; Int_tTGFrame::fDNDStateEDNDFlags; UInt_tTGWindow::fEditDisabledflags used for ""guibuilding""; UInt_tTGFrame::fEventMaskcurrenty active event mask; TGFrameElement*TGFrame::fFEpointer to frame element; UInt_tTGFrame::fHeightframe height; Handle_tTGObject::fIdX11/Win32 Window identifier; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; UInt_tTGFrame::fMaxHeightmaximal frame height; UInt_tTGFrame::fMaxWidthmaximal frame width; UInt_tTGFrame::fMinHeightminimal frame height; UInt_tTGFrame::fMinWidthminimal frame width; TStringTGWindow::fNamename of the window used in SavePrimitive(); Bool_tTGWindow::fNeedRedrawkTRUE if window needs to be redrawn; UInt_tTGFrame::fOptionsframe options; const TGWindow*TGWindow::fParentParent window; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; UInt_tTGFrame::fWidthframe width; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. private:. TGEventHandler*fEventHandler; Bool_tfFr",MatchSource.WIKI,root/html528/TGLWidget.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLWidget.html
https://root.cern/root/html528/TGLWidget.html:20987,Energy Efficiency,allocate,allocated,20987,"awing in overrider of PaintGL. Bool_t MakeCurrent(); Make the gl-context current. Bool_t ClearCurrent(); Clear the current gl-context. void SwapBuffers(); Swap buffers. const TGLContext * GetContext() const; Get gl context. const TGLFormat * GetPixelFormat() const; Pixel format. std::pair<void *, void *> GetInnerData() const; Dpy*, XVisualInfo *. void AddContext(TGLContext* ctx); Register gl-context created for this window. void RemoveContext(TGLContext* ctx); Remove context (no real deletion, done by TGLContex dtor). void ExtractViewport(Int_t* vp) const; For camera. Window_t CreateWindow(const TGWindow* parent, const TGLFormat& format, UInt_t width, UInt_t height, pair<void*,void*>& innerData); CreateWidget.; Static function called prior to widget construction,; I've extracted this code from ctors to make WIN32/X11; separation simpler and because of gInterpreter usage.; new, TGLContext can throw; std::bad_alloc and std::runtime_error. Before try block, the only; resource allocated is pointed by fWindowIndex (InitWindow cannot throw).; In try block (and after successful constraction); resources are controlled by std::auto_ptrs and dtor. void SetFormat(); Set pixel format.; Resource - hDC, owned and freed by guard object. void SetEventHandler(TGEventHandler* eh); Set event-handler. All events are passed to this object. Bool_t HandleCrossing(Event_t* ); Handle mouse crossing event. Bool_t HandleButton(Event_t* ev); Delegate call to the owner. Bool_t HandleDoubleClick(Event_t* ev); Delegate call to the owner. Bool_t HandleConfigureNotify(Event_t* ev); Delegate call to the owner. Bool_t HandleFocusChange(Event_t* ); Delegate call to the owner. Bool_t HandleKey(Event_t* ev); Delegate call to the owner. Bool_t HandleMotion(Event_t* ev); Delegate call to the owner. void DoRedraw(); Delegate call to the owner.; if (!gVirtualX->IsCmdThread()) {; gROOT->ProcessLineFast(Form(""((TGLWidget *)0x%lx)->DoRedraw()"", this));; return;; }. TGEventHandler * GetEventHandler() const; { re",MatchSource.WIKI,root/html528/TGLWidget.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLWidget.html
https://root.cern/root/html528/TGLWidget.html:421,Modifiability,inherit,inherits,421,". TGLWidget. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLWidget. class TGLWidget: public TGFrame, public TGLPaintDevice. GL window with context. _Must_ _have_ a parent window; (the 'parent' parameter of ctors). The current version inherits; TGCanvas (I'm not sure about future versions), probably, in future; multiple inheritance will be added - the second; base class will be TGLPaintDevice or something like this. Usage:; - Simply create TGLWidget as an embedded widget, and; connect your slots to signals you need: HandleExpose, HandleConfigureNotify, etc.; In your slots you can use gl API directly - under Win32 TGLWidget switches; between threads internally (look TGLPShapeObjEditor for such usage).; - You can write your own class, derived from TGLWidget, with PaintGL and InitGL; overriden. Resources (and invariants):; -fContainer (TGLWidgetContainer) - controlled by std::auto_ptr; -fWindowIndex - controlled manually (see CreateWidget and dtor); -fGLContext - controlled manually (see CreateWidget and dtor); -visual info for X11 version, controlled manually (see CreateGLContainer and dtor). Exceptions:; -can be thrown only during construction.; -under win32 class does not throw itself (but some internal operations can throw); -under X11 can throw std::runtime_error (from CreateGLContext).; -In case of exceptions resources will be freed. TGLWidget object is immutable as far as it was created. Boolean parameter defines, if you want to grab user's input or not.; By default you want, but for example when not - see TGLPShapeObjEditor. Non-copyable. Function Members (Methods); public:. virtual~TGLWidget(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); s",MatchSource.WIKI,root/html528/TGLWidget.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLWidget.html
https://root.cern/root/html528/TGLWidget.html:508,Modifiability,inherit,inheritance,508,". TGLWidget. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLWidget. class TGLWidget: public TGFrame, public TGLPaintDevice. GL window with context. _Must_ _have_ a parent window; (the 'parent' parameter of ctors). The current version inherits; TGCanvas (I'm not sure about future versions), probably, in future; multiple inheritance will be added - the second; base class will be TGLPaintDevice or something like this. Usage:; - Simply create TGLWidget as an embedded widget, and; connect your slots to signals you need: HandleExpose, HandleConfigureNotify, etc.; In your slots you can use gl API directly - under Win32 TGLWidget switches; between threads internally (look TGLPShapeObjEditor for such usage).; - You can write your own class, derived from TGLWidget, with PaintGL and InitGL; overriden. Resources (and invariants):; -fContainer (TGLWidgetContainer) - controlled by std::auto_ptr; -fWindowIndex - controlled manually (see CreateWidget and dtor); -fGLContext - controlled manually (see CreateWidget and dtor); -visual info for X11 version, controlled manually (see CreateGLContainer and dtor). Exceptions:; -can be thrown only during construction.; -under win32 class does not throw itself (but some internal operations can throw); -under X11 can throw std::runtime_error (from CreateGLContext).; -In case of exceptions resources will be freed. TGLWidget object is immutable as far as it was created. Boolean parameter defines, if you want to grab user's input or not.; By default you want, but for example when not - see TGLPShapeObjEditor. Non-copyable. Function Members (Methods); public:. virtual~TGLWidget(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); s",MatchSource.WIKI,root/html528/TGLWidget.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLWidget.html
https://root.cern/root/html528/TGLWidget.html:20840,Usability,simpl,simpler,20840,"tInput); Creates widget with default pixel format. ~TGLWidget(); Destructor. Deletes window ???? and XVisualInfo. void InitGL(); Call glEnable(... in overrider of InitGL. void PaintGL(); Do actual drawing in overrider of PaintGL. Bool_t MakeCurrent(); Make the gl-context current. Bool_t ClearCurrent(); Clear the current gl-context. void SwapBuffers(); Swap buffers. const TGLContext * GetContext() const; Get gl context. const TGLFormat * GetPixelFormat() const; Pixel format. std::pair<void *, void *> GetInnerData() const; Dpy*, XVisualInfo *. void AddContext(TGLContext* ctx); Register gl-context created for this window. void RemoveContext(TGLContext* ctx); Remove context (no real deletion, done by TGLContex dtor). void ExtractViewport(Int_t* vp) const; For camera. Window_t CreateWindow(const TGWindow* parent, const TGLFormat& format, UInt_t width, UInt_t height, pair<void*,void*>& innerData); CreateWidget.; Static function called prior to widget construction,; I've extracted this code from ctors to make WIN32/X11; separation simpler and because of gInterpreter usage.; new, TGLContext can throw; std::bad_alloc and std::runtime_error. Before try block, the only; resource allocated is pointed by fWindowIndex (InitWindow cannot throw).; In try block (and after successful constraction); resources are controlled by std::auto_ptrs and dtor. void SetFormat(); Set pixel format.; Resource - hDC, owned and freed by guard object. void SetEventHandler(TGEventHandler* eh); Set event-handler. All events are passed to this object. Bool_t HandleCrossing(Event_t* ); Handle mouse crossing event. Bool_t HandleButton(Event_t* ev); Delegate call to the owner. Bool_t HandleDoubleClick(Event_t* ev); Delegate call to the owner. Bool_t HandleConfigureNotify(Event_t* ev); Delegate call to the owner. Bool_t HandleFocusChange(Event_t* ); Delegate call to the owner. Bool_t HandleKey(Event_t* ev); Delegate call to the owner. Bool_t HandleMotion(Event_t* ev); Delegate call to the owner. void DoRedr",MatchSource.WIKI,root/html528/TGLWidget.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGLWidget.html
https://root.cern/root/html528/TGMainFrame.html:5364,Availability,error,error,5364,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); TList*GetBindList() const; static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; voidGetClassHints(const char*& className, const char*& resourceName) const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDime",MatchSource.WIKI,root/html528/TGMainFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGMainFrame.html
https://root.cern/root/html528/TGMainFrame.html:5448,Availability,error,error,5448,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); TList*GetBindList() const; static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; voidGetClassHints(const char*& className, const char*& resourceName) const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDe",MatchSource.WIKI,root/html528/TGMainFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGMainFrame.html
https://root.cern/root/html528/TGMainFrame.html:18927,Availability,mask,mask,18927,,MatchSource.WIKI,root/html528/TGMainFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGMainFrame.html
https://root.cern/root/html528/TGMainFrame.html:22408,Integrability,message,messages,22408,"::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGMainFrame(const TGWindow* p = 0, UInt_t w = 1, UInt_t h = 1, UInt_t options = kVerticalFrame); Create a top level main frame. A main frame interacts; with the window manager. ~TGMainFrame(); TGMainFrame destructor. Bool_t HandleKey(Event_t* event); Handle keyboard events. Bool_t BindKey(const TGWindow* w, Int_t keycode, Int_t modifier) const; Bind key to a window. void RemoveBind(const TGWindow* w, Int_t keycode, Int_t modifier) const; Remove key binding. Bool_t HandleButton(Event_t* event); Handle mouse button events. Bool_t HandleMotion(Event_t* event); Handle mouse motion events. Bool_t HandleSelection(Event_t* event); Handle primary selection event. Bool_t HandleSelectionRequest(Event_t* event); Handle selection request event. Bool_t HandleClientMessage(Event_t* event); Handle client messages sent to this frame. void SendCloseMessage(); Send close message to self. This method should be called from; a button to close this window. void CloseWindow(); Close and delete main frame. We get here in response to ALT+F4 or; a window manager close command. To terminate the application when this; happens override this method and call gApplication->Terminate(0) or; make a connection to this signal (if after the slot this method; should not be called call DontCallClose() in the slot).; By default the window will be deleted. void DontCallClose(); Typically call this method in the slot connected to the CloseWindow(); signal to prevent the calling of the default or any derived CloseWindow(); methods to prevent premature or double deletion of this window. void SetWindowName(const char* name = 0); Set window name. This is typically done via the window manager. void SetIconName(const char* name); Set window icon name. This is typically done via the window manager. const",MatchSource.WIKI,root/html528/TGMainFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGMainFrame.html
https://root.cern/root/html528/TGMainFrame.html:22473,Integrability,message,message,22473,"rame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGMainFrame(const TGWindow* p = 0, UInt_t w = 1, UInt_t h = 1, UInt_t options = kVerticalFrame); Create a top level main frame. A main frame interacts; with the window manager. ~TGMainFrame(); TGMainFrame destructor. Bool_t HandleKey(Event_t* event); Handle keyboard events. Bool_t BindKey(const TGWindow* w, Int_t keycode, Int_t modifier) const; Bind key to a window. void RemoveBind(const TGWindow* w, Int_t keycode, Int_t modifier) const; Remove key binding. Bool_t HandleButton(Event_t* event); Handle mouse button events. Bool_t HandleMotion(Event_t* event); Handle mouse motion events. Bool_t HandleSelection(Event_t* event); Handle primary selection event. Bool_t HandleSelectionRequest(Event_t* event); Handle selection request event. Bool_t HandleClientMessage(Event_t* event); Handle client messages sent to this frame. void SendCloseMessage(); Send close message to self. This method should be called from; a button to close this window. void CloseWindow(); Close and delete main frame. We get here in response to ALT+F4 or; a window manager close command. To terminate the application when this; happens override this method and call gApplication->Terminate(0) or; make a connection to this signal (if after the slot this method; should not be called call DontCallClose() in the slot).; By default the window will be deleted. void DontCallClose(); Typically call this method in the slot connected to the CloseWindow(); signal to prevent the calling of the default or any derived CloseWindow(); methods to prevent premature or double deletion of this window. void SetWindowName(const char* name = 0); Set window name. This is typically done via the window manager. void SetIconName(const char* name); Set window icon name. This is typically done via the window manager. const TGPicture * SetIconPixmap(const char* iconName); Set window icon pixm",MatchSource.WIKI,root/html528/TGMainFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGMainFrame.html
https://root.cern/root/html528/TGMainFrame.html:1358,Testability,log,logically,1358,"rame,; TGMainFrame, TGTransientFrame and TGGroupFrame. The frame classes describe the different ""dressed"" GUI windows. The TGFrame class is a subclasses of TGWindow, and is used as base; class for some simple widgets (buttons, labels, etc.).; It provides:; - position & dimension fields; - an 'options' attribute (see constant above); - a generic event handler; - a generic layout mechanism; - a generic border. The TGCompositeFrame class is the base class for composite widgets; (menu bars, list boxes, etc.).; It provides:; - a layout manager; - a frame container (TList *). The TGVerticalFrame and TGHorizontalFrame are composite frame that; layout their children in vertical or horizontal way. The TGMainFrame class defines top level windows that interact with; the system Window Manager. The TGTransientFrame class defines transient windows that typically; are used for dialogs windows. The TGGroupFrame is a composite frame with a border and a title.; It is typically used to group a number of logically related widgets; visually together. /*. */. Function Members (Methods); public:. TGMainFrame(const TGWindow* p = 0, UInt_t w = 1, UInt_t h = 1, UInt_t options = kVerticalFrame); virtual~TGMainFrame(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual Bool_tBindKey(const TGWindow* w, Int_t keycode, Int_t modifier) const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidTGCompositeFrame::ChangeSubframesBackground",MatchSource.WIKI,root/html528/TGMainFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGMainFrame.html
https://root.cern/root/html528/TGMainFrame.html:560,Usability,simpl,simple,560,". TGMainFrame. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGMainFrame. class TGMainFrame: public TGCompositeFrame. TGFrame, TGCompositeFrame, TGVerticalFrame, TGHorizontalFrame,; TGMainFrame, TGTransientFrame and TGGroupFrame. The frame classes describe the different ""dressed"" GUI windows. The TGFrame class is a subclasses of TGWindow, and is used as base; class for some simple widgets (buttons, labels, etc.).; It provides:; - position & dimension fields; - an 'options' attribute (see constant above); - a generic event handler; - a generic layout mechanism; - a generic border. The TGCompositeFrame class is the base class for composite widgets; (menu bars, list boxes, etc.).; It provides:; - a layout manager; - a frame container (TList *). The TGVerticalFrame and TGHorizontalFrame are composite frame that; layout their children in vertical or horizontal way. The TGMainFrame class defines top level windows that interact with; the system Window Manager. The TGTransientFrame class defines transient windows that typically; are used for dialogs windows. The TGGroupFrame is a composite frame with a border and a title.; It is typically used to group a number of logically related widgets; visually together. /*. */. Function Members (Methods); public:. TGMainFrame(const TGWindow* p = 0, UInt_t w = 1, UInt_t h = 1, UInt_t options = kVerticalFrame); virtual~TGMainFrame(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual Bool_tBindKey(const TGWindow* w, Int_t keycode, Int_t modifier) const; sta",MatchSource.WIKI,root/html528/TGMainFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGMainFrame.html
https://root.cern/root/html528/TGMatrixLayout.html:791,Availability,down,downward,791,". TGMatrixLayout. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGMatrixLayout. class TGMatrixLayout: public TGLayoutManager. A number of different layout classes (TGLayoutManager,; TGVerticalLayout, TGHorizontalLayout, TGLayoutHints, etc.). Concerning the TGMatrixLayout class:. It arranges frames in a matrix-like way.; This manager provides :; - a column number (0 means unlimited); - a row number (0 means unlimited); - horizontal & vertical separators. Notes : If both column and row are fixed values, any remaining; frames outside the count won't be managed.; Unlimited rows means the frame can expand downward; (the default behaviour in most UI).; Both unlimited rows and columns is undefined (read: will; crash the algorithm ;-).; With fixed dimensions, frames are always arranged in rows.; That is: 1st frame is at position (0,0), next one is at; row(0), column(1) and so on...; When specifying one dimension as unlimited (i.e. row=0 or; column=0) the frames are arranged according to the direction; of the fixed dimension. This layout manager does not make; use of TGLayoutHints. Function Members (Methods); public:. TGMatrixLayout(TGCompositeFrame* main, UInt_t r, UInt_t c, Int_t s = 0, Int_t h = 0); ~TGMatrixLayout(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Opt",MatchSource.WIKI,root/html528/TGMatrixLayout.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGMatrixLayout.html
https://root.cern/root/html528/TGMatrixLayout.html:2327,Availability,error,error,2327,"positeFrame* main, UInt_t r, UInt_t c, Int_t s = 0, Int_t h = 0); ~TGMatrixLayout(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TGDimensionGetDefaultSize() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObje",MatchSource.WIKI,root/html528/TGMatrixLayout.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGMatrixLayout.html
https://root.cern/root/html528/TGMatrixLayout.html:2411,Availability,error,error,2411," voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TGDimensionGetDefaultSize() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(c",MatchSource.WIKI,root/html528/TGMatrixLayout.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGMatrixLayout.html
https://root.cern/root/html528/TGMdiButtons.html:4308,Availability,error,error,4308,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGPictureButton*GetButton(Int_t no) const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_",MatchSource.WIKI,root/html528/TGMdiButtons.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGMdiButtons.html
https://root.cern/root/html528/TGMdiButtons.html:4392,Availability,error,error,4392,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGPictureButton*GetButton(Int_t no) const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Ato",MatchSource.WIKI,root/html528/TGMdiButtons.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGMdiButtons.html
https://root.cern/root/html528/TGMdiButtons.html:16724,Availability,mask,mask,16724,,MatchSource.WIKI,root/html528/TGMdiButtons.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGMdiButtons.html
https://root.cern/root/html528/TGMdiButtons.html:17490,Integrability,message,messages,17490,"tion to display server; TGLayoutHints*fCloseHintLayout hints; Int_tTGFrame::fDNDStateEDNDFlags; TGLayoutHints*fDefaultHint; UInt_tTGWindow::fEditDisabledflags used for ""guibuilding""; UInt_tTGFrame::fEventMaskcurrenty active event mask; TGFrameElement*TGFrame::fFEpointer to frame element; UInt_tTGFrame::fHeightframe height; Handle_tTGObject::fIdX11/Win32 Window identifier; Bool_tTGCompositeFrame::fLayoutBrokenno layout manager is used; TGLayoutManager*TGCompositeFrame::fLayoutManagerlayout manager; TList*TGCompositeFrame::fListcontainer of frame elements; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Bool_tTGCompositeFrame::fMapSubwindowskTRUE - map subwindows; UInt_tTGFrame::fMaxHeightmaximal frame height; UInt_tTGFrame::fMaxWidthmaximal frame width; UInt_tTGFrame::fMinHeightminimal frame height; UInt_tTGFrame::fMinWidthminimal frame width; const TGWindow*fMsgWindowwindow handling container messages; Int_tTGCompositeFrame::fMustCleanupcleanup mode (see EFrameCleanup); TStringTGWindow::fNamename of the window used in SavePrimitive(); Bool_tTGWindow::fNeedRedrawkTRUE if window needs to be redrawn; UInt_tTGFrame::fOptionsframe options; const TGWindow*TGWindow::fParentParent window; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; UInt_tTGFrame::fWidthframe width; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedB",MatchSource.WIKI,root/html528/TGMdiButtons.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGMdiButtons.html
https://root.cern/root/html528/TGMdiContainer.html:4007,Availability,error,error,4007,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionGetDefaultSize() const; virtual UInt_tTGFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType() const; virtual Option_t*TObjec",MatchSource.WIKI,root/html528/TGMdiContainer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGMdiContainer.html
https://root.cern/root/html528/TGMdiContainer.html:4091,Availability,error,error,4091,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionGetDefaultSize() const; virtual UInt_tTGFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType() const; virtual Option_t*TObject::GetDrawOption() const; virtual Int_tTGFrame::GetDropType() const; static Long_tTO",MatchSource.WIKI,root/html528/TGMdiContainer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGMdiContainer.html
https://root.cern/root/html528/TGMdiContainer.html:15009,Availability,mask,mask,15009,"eDelete; };. protected:. Pixel_tTGFrame::fBackgroundframe background color; Int_tTGFrame::fBorderWidthframe border width; TGClient*TGObject::fClientConnection to display server; Int_tTGFrame::fDNDStateEDNDFlags; UInt_tTGWindow::fEditDisabledflags used for ""guibuilding""; UInt_tTGFrame::fEventMaskcurrenty active event mask; TGFrameElement*TGFrame::fFEpointer to frame element; UInt_tTGFrame::fHeightframe height; Handle_tTGObject::fIdX11/Win32 Window identifier; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; const TGMdiMainFrame*fMainpointer to MDI main frame; UInt_tTGFrame::fMaxHeightmaximal frame height; UInt_tTGFrame::fMaxWidthmaximal frame width; UInt_tTGFrame::fMinHeightminimal frame height; UInt_tTGFrame::fMinWidthminimal frame width; TStringTGWindow::fNamename of the window used in SavePrimitive(); Bool_tTGWindow::fNeedRedrawkTRUE if window needs to be redrawn; UInt_tTGFrame::fOptionsframe options; const TGWindow*TGWindow::fParentParent window; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; UInt_tTGFrame::fWidthframe width; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritan",MatchSource.WIKI,root/html528/TGMdiContainer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGMdiContainer.html
https://root.cern/root/html528/TGMdiContainer.html:17035,Modifiability,config,configure,17035,"e::fMinHeightminimal frame height; UInt_tTGFrame::fMinWidthminimal frame width; TStringTGWindow::fNamename of the window used in SavePrimitive(); Bool_tTGWindow::fNeedRedrawkTRUE if window needs to be redrawn; UInt_tTGFrame::fOptionsframe options; const TGWindow*TGWindow::fParentParent window; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; UInt_tTGFrame::fWidthframe width; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGMdiContainer(const TGMdiMainFrame* p, Int_t w, Int_t h, UInt_t options = 0, ULong_t back = GetDefaultFrameBackground()); TGMdiContainer constructor. TGDimension GetDefaultSize() const; Return dimension of MDI container. Bool_t HandleConfigureNotify(Event_t* event); Handle configure notify events for MDI container. » Author: Bertrand Bellenot 20/08/2004 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id: TGMdiMainFrame.h 23115 2008-04-10 13:35:37Z rdm $ » Last generated: 2010-09-23 20:07; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html528/TGMdiContainer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGMdiContainer.html
https://root.cern/root/html528/TGMdiCornerWinResizer.html:4304,Availability,error,error,4304,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; const char*TGWidget::GetCommand() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGFrame::GetDefaultSize() const; virtual UInt_tTGFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGF",MatchSource.WIKI,root/html528/TGMdiCornerWinResizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGMdiCornerWinResizer.html
https://root.cern/root/html528/TGMdiCornerWinResizer.html:4388,Availability,error,error,4388,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; const char*TGWidget::GetCommand() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGFrame::GetDefaultSize() const; virtual UInt_tTGFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType() const; virtual Option_t*TObject::GetDrawOption() const; virtual ",MatchSource.WIKI,root/html528/TGMdiCornerWinResizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGMdiCornerWinResizer.html
https://root.cern/root/html528/TGMdiCornerWinResizer.html:15984,Availability,mask,mask,15984,,MatchSource.WIKI,root/html528/TGMdiCornerWinResizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGMdiCornerWinResizer.html
https://root.cern/root/html528/TGMdiDecorFrame.html:4448,Availability,error,error,4448,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const;",MatchSource.WIKI,root/html528/TGMdiDecorFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGMdiDecorFrame.html
https://root.cern/root/html528/TGMdiDecorFrame.html:4532,Availability,error,error,4532,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType() c",MatchSource.WIKI,root/html528/TGMdiDecorFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGMdiDecorFrame.html
https://root.cern/root/html528/TGMdiDecorFrame.html:18019,Availability,mask,mask,18019,,MatchSource.WIKI,root/html528/TGMdiDecorFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGMdiDecorFrame.html
https://root.cern/root/html528/TGMdiDecorFrame.html:22170,Modifiability,config,configure,22170," const TGGC* boxGC, UInt_t options = 0, Pixel_t back = GetDefaultFrameBackground()); TGMdiDecorFrame constructor.; The TGMdiDecorFrame is the frame containing MDI decorations like; title bar, minimize, maximize, restore and close buttons, and resizers. ~TGMdiDecorFrame(); TGMdiDecorFrame destructor. void SetDecorBorderWidth(Int_t bw); Set border width of the decor. void SetMdiButtons(ULong_t buttons); Set-up MDI buttons. void SetResizeMode(Int_t mode = kMdiDefaultResizeMode); Set resize mode (opaque or transparent). void Layout(); Recalculates the postion and the size of all decor frame components. void SetWindowName(const char* name); Set MDI Window name (appearing in the title bar). void SetWindowIcon(const TGPicture* pic); Set Window icon (appearing in the title bar). void Move(Int_t x, Int_t y); Move the MDI window at position x, y. void MoveResize(Int_t x, Int_t y, UInt_t w, UInt_t h); Move the MDI window at position x, y and set size to w, h. Bool_t HandleConfigureNotify(Event_t* event); Handle configure notify event. Bool_t HandleButton(Event_t* event); Handle mouse button events. Int_t CloseWindow(); { return fFrame->CloseWindow(); }. ULong_t GetMdiButtons() const; { return fButtonMask; }. const char * GetWindowName(). const TGPicture * GetWindowIcon(); { return fTitlebar->GetWinIcon()->GetPicture(); }. Bool_t IsCurrent() const; { return fIsCurrent; }. Bool_t IsMinimized() const; { return fIsMinimized; }. Bool_t IsMaximized() const; { return fIsMaximized; }. Int_t GetPreResizeX() const; { return fPreResizeX; }. Int_t GetPreResizeY() const; { return fPreResizeY; }. Int_t GetPreResizeWidth() const; { return fPreResizeWidth; }. Int_t GetPreResizeHeight() const; { return fPreResizeHeight; }. Int_t GetMinimizedX() const; { return fMinimizedX; }. Int_t GetMinimizedY() const; { return fMinimizedY; }. Bool_t GetMinUserPlacement() const; { return fMinimizedUserPlacement; }. void SetCurrent(Bool_t cur = kTRUE); {fIsCurrent = cur; }. void SetPreResizeX(Int_t x); { fPreR",MatchSource.WIKI,root/html528/TGMdiDecorFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGMdiDecorFrame.html
https://root.cern/root/html528/TGMdiFrame.html:4244,Availability,error,error,4244,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const;",MatchSource.WIKI,root/html528/TGMdiFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGMdiFrame.html
https://root.cern/root/html528/TGMdiFrame.html:4328,Availability,error,error,4328,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType() c",MatchSource.WIKI,root/html528/TGMdiFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGMdiFrame.html
https://root.cern/root/html528/TGMdiFrame.html:16719,Availability,mask,mask,16719,,MatchSource.WIKI,root/html528/TGMdiFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGMdiFrame.html
https://root.cern/root/html528/TGMdiGeometry.html:822,Availability,mask,mask,822,". TGMdiGeometry. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGMdiGeometry. class TGMdiGeometry. TGMdiMainFrame. This file contains the TGMdiMainFrame class. Function Members (Methods); public:. TGMdiGeometry(); TGMdiGeometry(const TGMdiGeometry&); virtual~TGMdiGeometry(); static TClass*Class(); virtual TClass*IsA() const; TGMdiGeometry&operator=(const TGMdiGeometry&); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Data Members; public:. TGRectanglefClient; TGRectanglefDecoration; TGRectanglefIconclient, decoration and icon rectangles; Int_tfValueMaskMDI hints mask. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~TGMdiGeometry(); { }. » Author: Bertrand Bellenot 20/08/2004 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id: TGMdiMainFrame.h 23115 2008-04-10 13:35:37Z rdm $ » Last generated: 2010-09-23 20:07; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html528/TGMdiGeometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGMdiGeometry.html
https://root.cern/root/html528/TGMdiHorizontalWinResizer.html:4322,Availability,error,error,4322,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; const char*TGWidget::GetCommand() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGFrame::GetDefaultSize() const; virtual UInt_tTGFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGF",MatchSource.WIKI,root/html528/TGMdiHorizontalWinResizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGMdiHorizontalWinResizer.html
https://root.cern/root/html528/TGMdiHorizontalWinResizer.html:4406,Availability,error,error,4406,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; const char*TGWidget::GetCommand() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGFrame::GetDefaultSize() const; virtual UInt_tTGFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType() const; virtual Option_t*TObject::GetDrawOption() const; virtual ",MatchSource.WIKI,root/html528/TGMdiHorizontalWinResizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGMdiHorizontalWinResizer.html
https://root.cern/root/html528/TGMdiHorizontalWinResizer.html:16002,Availability,mask,mask,16002,,MatchSource.WIKI,root/html528/TGMdiHorizontalWinResizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGMdiHorizontalWinResizer.html
https://root.cern/root/html528/TGMdiMainFrame.html:4450,Availability,error,error,4450,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidFrameClosed(Int_t id)SIGNAL ; virtual voidFrameCreated(Int_t id)SIGNAL ; virtual voidFrameMaximized(Int_t id)SIGNAL ; virtual voidFrameMinimized(Int_t id)SIGNAL ; virtual voidFrameRestored(Int_t id)SIGNAL ; virtual voidFramesArranged(Int_t mode)SIGNAL ; virtual voidFreeMove(TGMdiFrame* frame); virtual voidFreeSize(TGMdiFrame* frame); virtual Pixel_tTGFrame::GetBackground() const; TGRectangleGetBBox() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; TGFrame*GetContaine",MatchSource.WIKI,root/html528/TGMdiMainFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGMdiMainFrame.html
https://root.cern/root/html528/TGMdiMainFrame.html:4534,Availability,error,error,4534,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidFrameClosed(Int_t id)SIGNAL ; virtual voidFrameCreated(Int_t id)SIGNAL ; virtual voidFrameMaximized(Int_t id)SIGNAL ; virtual voidFrameMinimized(Int_t id)SIGNAL ; virtual voidFrameRestored(Int_t id)SIGNAL ; virtual voidFramesArranged(Int_t mode)SIGNAL ; virtual voidFreeMove(TGMdiFrame* frame); virtual voidFreeSize(TGMdiFrame* frame); virtual Pixel_tTGFrame::GetBackground() const; TGRectangleGetBBox() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; TGFrame*GetContainer() const; static Int_tTGWindow::GetCounter(); TGMdiFrame*GetCurrent() const; static",MatchSource.WIKI,root/html528/TGMdiMainFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGMdiMainFrame.html
https://root.cern/root/html528/TGMdiMainFrame.html:17736,Availability,mask,mask,17736,,MatchSource.WIKI,root/html528/TGMdiMainFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGMdiMainFrame.html
https://root.cern/root/html528/TGMdiMainFrame.html:21766,Integrability,depend,depending,21766,"ter). Bool_t SetCurrent(TGMdiFrameList* newcurrent); Set current (active) MDI child window (by frame list). void CirculateUp(); Bring the lowest window to the top. void CirculateDown(); Send the highest window to the bottom. TGMdiDecorFrame * GetDecorFrame(TGMdiFrame* frame) const; Return decor frame of MDI child window (by frame pointer). TGMdiDecorFrame * GetDecorFrame(UInt_t id) const; Return decor frame of MDI child window (by id). TGMdiFrame * GetMdiFrame(UInt_t id) const; Return frame of MDI child window (by id). TGRectangle GetBBox() const; Return resizing box (rectangle) for current MDI child. TGRectangle GetMinimizedBBox() const; Return minimized box (rectangle) for current MDI child. void UpdateWinListMenu(); Update MDI menu entries with current list of MDI child windows. void Layout(); Recalculates the postion and the size of all MDI child windows. void ArrangeFrames(Int_t mode); Automatic repositionning and resizing of every MDI child window.; depending on mode : tile horizontal, tile vertical, or cascade. void ArrangeMinimized(); This is an attempt to an ""smart"" minimized window re-arrangement. Bool_t ProcessMessage(Long_t msg, Long_t parm1, Long_t parm2); Process messages MDI main frame. void Maximize(TGMdiFrame* frame); Maximize MDI child window mdiframe. void Restore(TGMdiFrame* frame); Restore size of MDI child window mdiframe. void Minimize(TGMdiFrame* frame); Minimize MDI child window mdiframe. Int_t Close(TGMdiFrame* frame); Close MDI child window mdiframe. void FreeMove(TGMdiFrame* frame); Allow to move MDI child window mdiframe. void FreeSize(TGMdiFrame* frame); Allow to resize MDI child window mdiframe. Int_t ContextHelp(TGMdiFrame* frame); Calls Help() method of MDI child window mdiframe. TGMdiFrame * GetCurrent() const; Return pointer on current (active) MDI child window. TGMdiGeometry GetWindowGeometry(TGMdiFrame* f) const; Get MDI geometry of MDI child window f. void ConfigureWindow(TGMdiFrame* f, TGMdiGeometry& geom); Set MDI geometry for ",MatchSource.WIKI,root/html528/TGMdiMainFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGMdiMainFrame.html
https://root.cern/root/html528/TGMdiMainFrame.html:21992,Integrability,message,messages,21992,"culateDown(); Send the highest window to the bottom. TGMdiDecorFrame * GetDecorFrame(TGMdiFrame* frame) const; Return decor frame of MDI child window (by frame pointer). TGMdiDecorFrame * GetDecorFrame(UInt_t id) const; Return decor frame of MDI child window (by id). TGMdiFrame * GetMdiFrame(UInt_t id) const; Return frame of MDI child window (by id). TGRectangle GetBBox() const; Return resizing box (rectangle) for current MDI child. TGRectangle GetMinimizedBBox() const; Return minimized box (rectangle) for current MDI child. void UpdateWinListMenu(); Update MDI menu entries with current list of MDI child windows. void Layout(); Recalculates the postion and the size of all MDI child windows. void ArrangeFrames(Int_t mode); Automatic repositionning and resizing of every MDI child window.; depending on mode : tile horizontal, tile vertical, or cascade. void ArrangeMinimized(); This is an attempt to an ""smart"" minimized window re-arrangement. Bool_t ProcessMessage(Long_t msg, Long_t parm1, Long_t parm2); Process messages MDI main frame. void Maximize(TGMdiFrame* frame); Maximize MDI child window mdiframe. void Restore(TGMdiFrame* frame); Restore size of MDI child window mdiframe. void Minimize(TGMdiFrame* frame); Minimize MDI child window mdiframe. Int_t Close(TGMdiFrame* frame); Close MDI child window mdiframe. void FreeMove(TGMdiFrame* frame); Allow to move MDI child window mdiframe. void FreeSize(TGMdiFrame* frame); Allow to resize MDI child window mdiframe. Int_t ContextHelp(TGMdiFrame* frame); Calls Help() method of MDI child window mdiframe. TGMdiFrame * GetCurrent() const; Return pointer on current (active) MDI child window. TGMdiGeometry GetWindowGeometry(TGMdiFrame* f) const; Get MDI geometry of MDI child window f. void ConfigureWindow(TGMdiFrame* f, TGMdiGeometry& geom); Set MDI geometry for MDI child window f. void CloseAll(); Close all MDI child windows. Bool_t IsMaximized(TGMdiFrame* f); Check if MDI child window f is maximized;. Bool_t IsMinimized(TGMdiFra",MatchSource.WIKI,root/html528/TGMdiMainFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGMdiMainFrame.html
https://root.cern/root/html528/TGMdiMenuBar.html:4207,Availability,error,error,4207,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const;",MatchSource.WIKI,root/html528/TGMdiMenuBar.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGMdiMenuBar.html
https://root.cern/root/html528/TGMdiMenuBar.html:4291,Availability,error,error,4291,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType() c",MatchSource.WIKI,root/html528/TGMdiMenuBar.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGMdiMenuBar.html
https://root.cern/root/html528/TGMdiMenuBar.html:16799,Availability,mask,mask,16799,,MatchSource.WIKI,root/html528/TGMdiMenuBar.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGMdiMenuBar.html
https://root.cern/root/html528/TGMdiTitleBar.html:4253,Availability,error,error,4253,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGMdiButtons*GetButtons() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGComposi",MatchSource.WIKI,root/html528/TGMdiTitleBar.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGMdiTitleBar.html
https://root.cern/root/html528/TGMdiTitleBar.html:4337,Availability,error,error,4337,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGMdiButtons*GetButtons() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virt",MatchSource.WIKI,root/html528/TGMdiTitleBar.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGMdiTitleBar.html
https://root.cern/root/html528/TGMdiTitleBar.html:17238,Availability,mask,mask,17238,,MatchSource.WIKI,root/html528/TGMdiTitleBar.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGMdiTitleBar.html
https://root.cern/root/html528/TGMdiTitleBar.html:20362,Integrability,depend,depends,20362,"teFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGMdiTitleBar(const TGWindow* p, const TGWindow* mdiwin, const char* name = ""Untitled""); TGMdiTitleBar constructor.; the TGMdiTitleBar is the frame containing a title (window name); an icon and MDI picture buttons as minimize, maximize, restore,; close and help. ~TGMdiTitleBar(); TGMdiTitleBar destructor. void LayoutButtons(UInt_t buttonmask, Bool_t isMinimized, Bool_t isMaximized); Recalculates the position of every enabled (displayed) buttons. void SetTitleBarColors(UInt_t fore, UInt_t back, TGFont* f); Set title bar color (blue or grey, depends on active state). Bool_t HandleDoubleClick(Event_t* event); Handle double click in title bar (maximize window). Bool_t HandleButton(Event_t* event); Handle mouse click on title bar. Bool_t ProcessMessage(Long_t msg, Long_t parm1, Long_t parm2); Process messages for title bar. Bool_t HandleMotion(Event_t* event); Handle mouse motion events in title bar (used to move MDI window). void AddFrames(TGMdiTitleIcon* icon, TGMdiButtons* buttons); This is called from TGMdiMainFrame on Restore(). void RemoveFrames(TGMdiTitleIcon* icon, TGMdiButtons* buttons); This is called from TGMdiMainFrame on Maximize(). TGMdiButtons * GetButtons() const; { return fButtons; }. TGMdiTitleIcon * GetWinIcon() const; { return fWinIcon; }. TGLabel * GetWinName() const; { return fWinName; }. Int_t GetX0(); { return fX0; }. Int_t GetY0(); { return fY0; }. Bool_t IsLeftButPressed(); { return fLeftButPressed; }. Bool_t IsRightButPressed(); { return fRightButPressed; }. Bool_",MatchSource.WIKI,root/html528/TGMdiTitleBar.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGMdiTitleBar.html
https://root.cern/root/html528/TGMdiTitleBar.html:20623,Integrability,message,messages,20623,"ame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGMdiTitleBar(const TGWindow* p, const TGWindow* mdiwin, const char* name = ""Untitled""); TGMdiTitleBar constructor.; the TGMdiTitleBar is the frame containing a title (window name); an icon and MDI picture buttons as minimize, maximize, restore,; close and help. ~TGMdiTitleBar(); TGMdiTitleBar destructor. void LayoutButtons(UInt_t buttonmask, Bool_t isMinimized, Bool_t isMaximized); Recalculates the position of every enabled (displayed) buttons. void SetTitleBarColors(UInt_t fore, UInt_t back, TGFont* f); Set title bar color (blue or grey, depends on active state). Bool_t HandleDoubleClick(Event_t* event); Handle double click in title bar (maximize window). Bool_t HandleButton(Event_t* event); Handle mouse click on title bar. Bool_t ProcessMessage(Long_t msg, Long_t parm1, Long_t parm2); Process messages for title bar. Bool_t HandleMotion(Event_t* event); Handle mouse motion events in title bar (used to move MDI window). void AddFrames(TGMdiTitleIcon* icon, TGMdiButtons* buttons); This is called from TGMdiMainFrame on Restore(). void RemoveFrames(TGMdiTitleIcon* icon, TGMdiButtons* buttons); This is called from TGMdiMainFrame on Maximize(). TGMdiButtons * GetButtons() const; { return fButtons; }. TGMdiTitleIcon * GetWinIcon() const; { return fWinIcon; }. TGLabel * GetWinName() const; { return fWinName; }. Int_t GetX0(); { return fX0; }. Int_t GetY0(); { return fY0; }. Bool_t IsLeftButPressed(); { return fLeftButPressed; }. Bool_t IsRightButPressed(); { return fRightButPressed; }. Bool_t IsMidButPressed(); { return fMidButPressed; }. void SetX0(Int_t x0); { fX0 = x0; }. void SetY0(Int_t y0); { fY0 = y0; }. void SetLeftButPressed(Bool_t press = kTRUE); { fLeftButPressed = press; }. void SetRightButPressed(Bool_t press = kTRUE); { fRightButPressed= press; ",MatchSource.WIKI,root/html528/TGMdiTitleBar.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGMdiTitleBar.html
https://root.cern/root/html528/TGMdiTitleIcon.html:4198,Availability,error,error,4198,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGIcon::GetDefaultSize() const; virtual UInt_tTGFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType() const; virtual Option_",MatchSource.WIKI,root/html528/TGMdiTitleIcon.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGMdiTitleIcon.html
https://root.cern/root/html528/TGMdiTitleIcon.html:4282,Availability,error,error,4282,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGIcon::GetDefaultSize() const; virtual UInt_tTGFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType() const; virtual Option_t*TObject::GetDrawOption() const; virtual Int_tTGFrame::GetDropType() const; static ",MatchSource.WIKI,root/html528/TGMdiTitleIcon.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGMdiTitleIcon.html
https://root.cern/root/html528/TGMdiTitleIcon.html:15535,Availability,mask,mask,15535,,MatchSource.WIKI,root/html528/TGMdiTitleIcon.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGMdiTitleIcon.html
https://root.cern/root/html528/TGMdiTitleIcon.html:16081,Integrability,message,messages,16081,,MatchSource.WIKI,root/html528/TGMdiTitleIcon.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGMdiTitleIcon.html
https://root.cern/root/html528/TGMdiTitleIcon.html:17672,Security,access,access,17672,"ed to the title icon; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; UInt_tTGFrame::fWidthframe width; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGMdiTitleIcon(const TGWindow* p, const TGWindow* titlebar, const TGPicture* pic, Int_t w, Int_t h); TGMdiTitleIcon constructor.; the TGMdiTitleIcon is the left icon used also for the MDI; popup menu allowing access to MDI commands as : restore,; move, size, minimize and close. ~TGMdiTitleIcon(); TGMdiTitleIcon destructor. void DoRedraw(); Redraw icon. Bool_t HandleDoubleClick(Event_t* event); Handle double click event on MDI icon (close the window). Bool_t HandleButton(Event_t* event); Handle button event on MDI icon (popup menu). TGPopupMenu * GetPopup() const; { return fPopup; }. » Author: Bertrand Bellenot 20/08/2004 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id: TGMdiDecorFrame.h 23115 2008-04-10 13:35:37Z rdm $ » Last generated: 2010-09-23 20:07; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html528/TGMdiTitleIcon.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGMdiTitleIcon.html
https://root.cern/root/html528/TGMdiVerticalWinResizer.html:4312,Availability,error,error,4312,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; const char*TGWidget::GetCommand() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGFrame::GetDefaultSize() const; virtual UInt_tTGFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGF",MatchSource.WIKI,root/html528/TGMdiVerticalWinResizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGMdiVerticalWinResizer.html
https://root.cern/root/html528/TGMdiVerticalWinResizer.html:4396,Availability,error,error,4396,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; const char*TGWidget::GetCommand() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGFrame::GetDefaultSize() const; virtual UInt_tTGFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType() const; virtual Option_t*TObject::GetDrawOption() const; virtual ",MatchSource.WIKI,root/html528/TGMdiVerticalWinResizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGMdiVerticalWinResizer.html
https://root.cern/root/html528/TGMdiVerticalWinResizer.html:15992,Availability,mask,mask,15992,,MatchSource.WIKI,root/html528/TGMdiVerticalWinResizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGMdiVerticalWinResizer.html
https://root.cern/root/html528/TGMdiWinResizer.html:4314,Availability,error,error,4314,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; const char*TGWidget::GetCommand() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGFrame::GetDefaultSize() const; virtual UInt_tTGFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGF",MatchSource.WIKI,root/html528/TGMdiWinResizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGMdiWinResizer.html
https://root.cern/root/html528/TGMdiWinResizer.html:4398,Availability,error,error,4398,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; const char*TGWidget::GetCommand() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGFrame::GetDefaultSize() const; virtual UInt_tTGFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType() const; virtual Option_t*TObject::GetDrawOption() const; virtual ",MatchSource.WIKI,root/html528/TGMdiWinResizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGMdiWinResizer.html
https://root.cern/root/html528/TGMdiWinResizer.html:15895,Availability,mask,mask,15895,,MatchSource.WIKI,root/html528/TGMdiWinResizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGMdiWinResizer.html
https://root.cern/root/html528/TGMenuBar.html:6314,Availability,error,error,6314,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); virtual TGMenuTitle*GetCurrent() const; static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTG",MatchSource.WIKI,root/html528/TGMenuBar.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGMenuBar.html
https://root.cern/root/html528/TGMenuBar.html:6398,Availability,error,error,6398,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); virtual TGMenuTitle*GetCurrent() const; static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t",MatchSource.WIKI,root/html528/TGMenuBar.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGMenuBar.html
https://root.cern/root/html528/TGMenuBar.html:19068,Availability,mask,mask,19068,,MatchSource.WIKI,root/html528/TGMenuBar.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGMenuBar.html
https://root.cern/root/html528/TGMenuBar.html:1312,Integrability,interface,interfaces,1312,"enuBar. class TGMenuBar: public TGHorizontalFrame. TGMenuBar, TGPopupMenu, TGMenuTitle and TGMenuEntry. The TGMenu.h header contains all different menu classes. The TGMenuBar class implements a menu bar widget. It is used to; specify and provide access to common and frequently used application; actions grouped under menu titles (TGMenuTitle class). The menu bar; takes the highest-level of the menu system and it is a starting; point for many interactions. It is always visible and allows using; the keyboard equivalents. The geometry of the menu bar is; automatically set to the parent widget, i.e. the menu bar; automatically resizes itself so that it has the same width as its; parent (typically TGMainFrame). A menu bar contains one or more; popup menus and usually is placed along the top of the application; window. Any popup menu is invisible until the user invokes it by; using the mouse pointer or the keyboard. Popup menus implemented by TGPopupMenu class are unique in that,; by convention, they are not placed with the other GUI components in; the user interfaces. Instead, a popup menu usually appears either in; a menu bar or as a context menu on the TOP of the GUI. For that; reason it needs gClient->GetDefaultRoot() as a parent to get the; pointer to the root (i.e. desktop) window. This way a popup menu; will never be embedded.; NOTE: Using gClient->GetRoot() as a parent of TGPopupMenu will not; avoid the possibility of embedding the corresponding popup menu; because the current window hierarchy can be changed by using; gClient->SetRoot() method. As a context menus TGPopupMenu shows up after pressing the right; mouse button, over a popup-enabled component. The popup menu then; appears under the mouse pointer. Selecting a menu item will generate the event:; kC_COMMAND, kCM_MENU, menu id, user data. Function Members (Methods); public:. TGMenuBar(const TGWindow* p = 0, UInt_t w = 60, UInt_t h = 20, UInt_t options = kHorizontalFrame|kRaisedFrame); virtual~TGMenuBar(); vo",MatchSource.WIKI,root/html528/TGMenuBar.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGMenuBar.html
https://root.cern/root/html528/TGMenuBar.html:1663,Safety,avoid,avoid,1663,"It is always visible and allows using; the keyboard equivalents. The geometry of the menu bar is; automatically set to the parent widget, i.e. the menu bar; automatically resizes itself so that it has the same width as its; parent (typically TGMainFrame). A menu bar contains one or more; popup menus and usually is placed along the top of the application; window. Any popup menu is invisible until the user invokes it by; using the mouse pointer or the keyboard. Popup menus implemented by TGPopupMenu class are unique in that,; by convention, they are not placed with the other GUI components in; the user interfaces. Instead, a popup menu usually appears either in; a menu bar or as a context menu on the TOP of the GUI. For that; reason it needs gClient->GetDefaultRoot() as a parent to get the; pointer to the root (i.e. desktop) window. This way a popup menu; will never be embedded.; NOTE: Using gClient->GetRoot() as a parent of TGPopupMenu will not; avoid the possibility of embedding the corresponding popup menu; because the current window hierarchy can be changed by using; gClient->SetRoot() method. As a context menus TGPopupMenu shows up after pressing the right; mouse button, over a popup-enabled component. The popup menu then; appears under the mouse pointer. Selecting a menu item will generate the event:; kC_COMMAND, kCM_MENU, menu id, user data. Function Members (Methods); public:. TGMenuBar(const TGWindow* p = 0, UInt_t w = 60, UInt_t h = 20, UInt_t options = kHorizontalFrame|kRaisedFrame); virtual~TGMenuBar(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidAddPopup(TGHotString* s, TGPopupMenu* menu, TGLayoutHints* l, TGPopupMenu* before = 0); virtual voidAddPopup(const char* s, TGPopupMenu* menu, TGLayoutHints* l, TGPopupMenu* before = 0); virtual TGPopupMenu*AddPopup(const TString& s, Int_t padle",MatchSource.WIKI,root/html528/TGMenuBar.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGMenuBar.html
https://root.cern/root/html528/TGMenuBar.html:491,Security,access,access,491,". TGMenuBar. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGMenuBar. class TGMenuBar: public TGHorizontalFrame. TGMenuBar, TGPopupMenu, TGMenuTitle and TGMenuEntry. The TGMenu.h header contains all different menu classes. The TGMenuBar class implements a menu bar widget. It is used to; specify and provide access to common and frequently used application; actions grouped under menu titles (TGMenuTitle class). The menu bar; takes the highest-level of the menu system and it is a starting; point for many interactions. It is always visible and allows using; the keyboard equivalents. The geometry of the menu bar is; automatically set to the parent widget, i.e. the menu bar; automatically resizes itself so that it has the same width as its; parent (typically TGMainFrame). A menu bar contains one or more; popup menus and usually is placed along the top of the application; window. Any popup menu is invisible until the user invokes it by; using the mouse pointer or the keyboard. Popup menus implemented by TGPopupMenu class are unique in that,; by convention, they are not placed with the other GUI components in; the user interfaces. Instead, a popup menu usually appears either in; a menu bar or as a context menu on the TOP of the GUI. For that; reason it needs gClient->GetDefaultRoot() as a parent to get the; pointer to the root (i.e. desktop) window. This way a popup menu; will never be embedded.; NOTE: Using gClient->GetRoot() as a parent of TGPopupMenu will not; avoid the possibility of embedding the corresponding popup menu; because the current window hierarchy can be changed by using; gClient->SetRoot() method. As a context menus TGPopupMenu shows up after pressing the right; mouse button, over a popup-enabled component. The popup menu then; appears under the mouse pointer. Selecting a menu i",MatchSource.WIKI,root/html528/TGMenuBar.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGMenuBar.html
https://root.cern/root/html528/TGMenuEntry.html:1445,Availability,error,error,1445," TGMenuEntry(); virtual~TGMenuEntry(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); UInt_tGetEh() const; Int_tGetEntryId() const; UInt_tGetEw() const; Int_tGetEx() const; Int_tGetEy() const; v",MatchSource.WIKI,root/html528/TGMenuEntry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGMenuEntry.html
https://root.cern/root/html528/TGMenuEntry.html:1529,Availability,error,error,1529," voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); UInt_tGetEh() const; Int_tGetEntryId() const; UInt_tGetEw() const; Int_tGetEx() const; Int_tGetEy() const; virtual const char*TObject::GetIconName() const; TGHotString*GetLabel() const; virtual const char*GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; const TGPicture*GetPic() const; TGPopupMenu*GetPopup() const; TGString*GetShortcut() const; const char*GetShortcutText() const; virtual Int_tGetStatus() const; virtual const char*TObject::GetTitle() const; EMenuEntryTypeGetType() const; virtual UInt_tTObject::GetUniqueI",MatchSource.WIKI,root/html528/TGMenuEntry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGMenuEntry.html
https://root.cern/root/html528/TGMenuTitle.html:5803,Availability,error,error,5803,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static FontStruct_tGetDefaultFontStruct(); static Pixel_tTGFrame::GetDefaultFrameBackground(); static const TGGC&GetDefaultGC(); virtual UInt_tTGFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); static const TGGC&GetDefaultSelectedGC(); virtual TGDimensionTGFrame::GetDefaultSize() const; virtual UInt_tTGFrame::GetDefaul",MatchSource.WIKI,root/html528/TGMenuTitle.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGMenuTitle.html
https://root.cern/root/html528/TGMenuTitle.html:5887,Availability,error,error,5887,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static FontStruct_tGetDefaultFontStruct(); static Pixel_tTGFrame::GetDefaultFrameBackground(); static const TGGC&GetDefaultGC(); virtual UInt_tTGFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); static const TGGC&GetDefaultSelectedGC(); virtual TGDimensionTGFrame::GetDefaultSize() const; virtual UInt_tTGFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::",MatchSource.WIKI,root/html528/TGMenuTitle.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGMenuTitle.html
https://root.cern/root/html528/TGMenuTitle.html:17126,Availability,mask,mask,17126,,MatchSource.WIKI,root/html528/TGMenuTitle.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGMenuTitle.html
https://root.cern/root/html528/TGMenuTitle.html:1308,Integrability,interface,interfaces,1308," » TGMenuTitle. class TGMenuTitle: public TGFrame. TGMenuBar, TGPopupMenu, TGMenuTitle and TGMenuEntry. The TGMenu.h header contains all different menu classes. The TGMenuBar class implements a menu bar widget. It is used to; specify and provide access to common and frequently used application; actions grouped under menu titles (TGMenuTitle class). The menu bar; takes the highest-level of the menu system and it is a starting; point for many interactions. It is always visible and allows using; the keyboard equivalents. The geometry of the menu bar is; automatically set to the parent widget, i.e. the menu bar; automatically resizes itself so that it has the same width as its; parent (typically TGMainFrame). A menu bar contains one or more; popup menus and usually is placed along the top of the application; window. Any popup menu is invisible until the user invokes it by; using the mouse pointer or the keyboard. Popup menus implemented by TGPopupMenu class are unique in that,; by convention, they are not placed with the other GUI components in; the user interfaces. Instead, a popup menu usually appears either in; a menu bar or as a context menu on the TOP of the GUI. For that; reason it needs gClient->GetDefaultRoot() as a parent to get the; pointer to the root (i.e. desktop) window. This way a popup menu; will never be embedded.; NOTE: Using gClient->GetRoot() as a parent of TGPopupMenu will not; avoid the possibility of embedding the corresponding popup menu; because the current window hierarchy can be changed by using; gClient->SetRoot() method. As a context menus TGPopupMenu shows up after pressing the right; mouse button, over a popup-enabled component. The popup menu then; appears under the mouse pointer. Selecting a menu item will generate the event:; kC_COMMAND, kCM_MENU, menu id, user data. Function Members (Methods); public:. TGMenuTitle(const TGWindow* p = 0, TGHotString* s = 0, TGPopupMenu* menu = 0, GContext_t norm = GetDefaultGC()(), FontStruct_t font = G",MatchSource.WIKI,root/html528/TGMenuTitle.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGMenuTitle.html
https://root.cern/root/html528/TGMenuTitle.html:1659,Safety,avoid,avoid,1659,"It is always visible and allows using; the keyboard equivalents. The geometry of the menu bar is; automatically set to the parent widget, i.e. the menu bar; automatically resizes itself so that it has the same width as its; parent (typically TGMainFrame). A menu bar contains one or more; popup menus and usually is placed along the top of the application; window. Any popup menu is invisible until the user invokes it by; using the mouse pointer or the keyboard. Popup menus implemented by TGPopupMenu class are unique in that,; by convention, they are not placed with the other GUI components in; the user interfaces. Instead, a popup menu usually appears either in; a menu bar or as a context menu on the TOP of the GUI. For that; reason it needs gClient->GetDefaultRoot() as a parent to get the; pointer to the root (i.e. desktop) window. This way a popup menu; will never be embedded.; NOTE: Using gClient->GetRoot() as a parent of TGPopupMenu will not; avoid the possibility of embedding the corresponding popup menu; because the current window hierarchy can be changed by using; gClient->SetRoot() method. As a context menus TGPopupMenu shows up after pressing the right; mouse button, over a popup-enabled component. The popup menu then; appears under the mouse pointer. Selecting a menu item will generate the event:; kC_COMMAND, kCM_MENU, menu id, user data. Function Members (Methods); public:. TGMenuTitle(const TGWindow* p = 0, TGHotString* s = 0, TGPopupMenu* menu = 0, GContext_t norm = GetDefaultGC()(), FontStruct_t font = GetDefaultFontStruct(), UInt_t options = 0); virtual~TGMenuTitle(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse",MatchSource.WIKI,root/html528/TGMenuTitle.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGMenuTitle.html
https://root.cern/root/html528/TGMenuTitle.html:487,Security,access,access,487,". TGMenuTitle. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGMenuTitle. class TGMenuTitle: public TGFrame. TGMenuBar, TGPopupMenu, TGMenuTitle and TGMenuEntry. The TGMenu.h header contains all different menu classes. The TGMenuBar class implements a menu bar widget. It is used to; specify and provide access to common and frequently used application; actions grouped under menu titles (TGMenuTitle class). The menu bar; takes the highest-level of the menu system and it is a starting; point for many interactions. It is always visible and allows using; the keyboard equivalents. The geometry of the menu bar is; automatically set to the parent widget, i.e. the menu bar; automatically resizes itself so that it has the same width as its; parent (typically TGMainFrame). A menu bar contains one or more; popup menus and usually is placed along the top of the application; window. Any popup menu is invisible until the user invokes it by; using the mouse pointer or the keyboard. Popup menus implemented by TGPopupMenu class are unique in that,; by convention, they are not placed with the other GUI components in; the user interfaces. Instead, a popup menu usually appears either in; a menu bar or as a context menu on the TOP of the GUI. For that; reason it needs gClient->GetDefaultRoot() as a parent to get the; pointer to the root (i.e. desktop) window. This way a popup menu; will never be embedded.; NOTE: Using gClient->GetRoot() as a parent of TGPopupMenu will not; avoid the possibility of embedding the corresponding popup menu; because the current window hierarchy can be changed by using; gClient->SetRoot() method. As a context menus TGPopupMenu shows up after pressing the right; mouse button, over a popup-enabled component. The popup menu then; appears under the mouse pointer. Selecting a menu item ",MatchSource.WIKI,root/html528/TGMenuTitle.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGMenuTitle.html
https://root.cern/root/html528/TGMimeTypes.html:1577,Availability,error,error,1577,"tMethod(const char* method) const; voidAddType(const char* type, const char* pat, const char* icon, const char* sicon, const char* action); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Bool_tGetAction(const char* filename, char* action); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); const TGPicture*GetIcon(const char* filename, Bool_t small_icon); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; Bool_tGetType(const char* filename, char* type); virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); Bool_",MatchSource.WIKI,root/html528/TGMimeTypes.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGMimeTypes.html
https://root.cern/root/html528/TGMimeTypes.html:1661,Availability,error,error,1661,"nst char* icon, const char* sicon, const char* action); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Bool_tGetAction(const char* filename, char* action); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); const TGPicture*GetIcon(const char* filename, Bool_t small_icon); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; Bool_tGetType(const char* filename, char* type); virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); Bool_tHasChanged() const; virtual ULong_tTObject::Hash() const; virtual voidTObject::Info",MatchSource.WIKI,root/html528/TGMimeTypes.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGMimeTypes.html
https://root.cern/root/html528/TGMimeTypes.html:5898,Performance,cache,cache,5898,"char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. TGMimeTypes(const TGMimeTypes& gmt); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; TGMime*Find(const char* filename); voidTObject::MakeZombie(); TGMimeTypes&operator=(const TGMimeTypes& gmt). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Bool_tfChangedtrue if file has changed; TGClient*fClientclient to which mime types belong (display server); TStringfFilenamefile name of mime type file; TOrdCollection*fListlist of mime types. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGMimeTypes(TGClient* client, const char* file); Create a mime type cache. Read the mime types file ""filename"" and; built a list of mime types. ~TGMimeTypes(); Delete mime type pool. TGMimeTypes(const TGMimeTypes& gmt); Copy constructor. TGMimeTypes& operator=(const TGMimeTypes& gmt); Assignment operator. TGMime * Find(const char* filename); Given a filename find the matching mime type object. const TGPicture * GetIcon(const char* filename, Bool_t small_icon); Return icon belonging to mime type of filename. Bool_t GetAction(const char* filename, char* action); Return in action the mime action string belonging to filename. Bool_t GetType(const char* filename, char* type); Return in type the mime type belonging to filename. void Print(Option_t* option = """") const; Print list of mime types. void SaveMimes(); Save mime types in user's mime type file. void AddType(const char* type, const char* pat, const char* icon, const char* sicon, const char* action); Add a mime type to the list of mime types. Bool_t HasChanged",MatchSource.WIKI,root/html528/TGMimeTypes.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGMimeTypes.html
https://root.cern/root/html528/TGMsgBox.html:4797,Availability,error,error,4797,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); TList*TGMainFrame::GetBindList() const; static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; voidTGMainFrame::GetClassHints(const char*& className, const char*& resourceName) const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBa",MatchSource.WIKI,root/html528/TGMsgBox.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGMsgBox.html
https://root.cern/root/html528/TGMsgBox.html:4881,Availability,error,error,4881,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); TList*TGMainFrame::GetBindList() const; static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; voidTGMainFrame::GetClassHints(const char*& className, const char*& resourceName) const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UIn",MatchSource.WIKI,root/html528/TGMsgBox.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGMsgBox.html
https://root.cern/root/html528/TGMsgBox.html:19354,Availability,mask,mask,19354,,MatchSource.WIKI,root/html528/TGMsgBox.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGMsgBox.html
https://root.cern/root/html528/TGMsgBox.html:303,Integrability,message,message,303,". TGMsgBox. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGMsgBox. class TGMsgBox: public TGTransientFrame. TMsgBox. A message dialog box. Function Members (Methods); public:. TGMsgBox(const TGWindow* p = 0, const TGWindow* main = 0, const char* title = 0, const char* msg = 0, const TGPicture* icon = 0, Int_t buttons = kMBDismiss, Int_t* ret_code = 0, UInt_t options = kVerticalFrame, Int_t text_align = kTextCenterX|kTextCenterY); TGMsgBox(const TGWindow* p, const TGWindow* main, const char* title, const char* msg, EMsgBoxIcon icon, Int_t buttons = kMBDismiss, Int_t* ret_code = 0, UInt_t options = kVerticalFrame, Int_t text_align = kTextCenterX|kTextCenterY); virtual~TGMsgBox(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual Bool_tTGMainFrame::BindKey(const TGWindow* w, Int_t keycode, Int_t modifier) const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGTransientFrame::CenterOnParent(Bool_t croot = kTRUE, TGTransientFrame::EPlacement pos = kCenter); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidTGCompositeFrame::ChangeSubframesBackground(Pixel_t back); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTGCompositeFrame::Cleanup(); virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* n",MatchSource.WIKI,root/html528/TGMsgBox.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGMsgBox.html
https://root.cern/root/html528/TGMsgBox.html:23077,Integrability,message,message,23077,"ression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGMsgBox(const TGWindow* p = 0, const TGWindow* main = 0, const char* title = 0, const char* msg = 0, const TGPicture* icon = 0, Int_t buttons = kMBDismiss, Int_t* ret_code = 0, UInt_t options = kVerticalFrame, Int_t text_align = kTextCenterX|kTextCenterY); Create a message dialog box. TGMsgBox(const TGWindow* p, const TGWindow* main, const char* title, const char* msg, EMsgBoxIcon icon, Int_t buttons = kMBDismiss, Int_t* ret_code = 0, UInt_t options = kVerticalFrame, Int_t text_align = kTextCenterX|kTextCenterY); Create a message dialog box with the following parameters:.; title: Window title; msg: Message to be shown ('\n' may be used to split it in lines); icon: Picture to be shown at the left on the dialog window.; It might take any of the following values:; kMBIconStop, kMBIconQuestion,; kMBIconExclamation, kMBIconAsterisk; buttons: Buttons to be shown at the botton of the dialgo window.; Look at EMsgBoxButton for the different possible values.; ret_code: It will hold the value of the button pressed when the; dialog is closed; options: Frame options of this dialog window.; text_align: Align options for 'msg'.",MatchSource.WIKI,root/html528/TGMsgBox.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGMsgBox.html
https://root.cern/root/html528/TGMsgBox.html:23339,Integrability,message,message,23339,"tatic Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGMsgBox(const TGWindow* p = 0, const TGWindow* main = 0, const char* title = 0, const char* msg = 0, const TGPicture* icon = 0, Int_t buttons = kMBDismiss, Int_t* ret_code = 0, UInt_t options = kVerticalFrame, Int_t text_align = kTextCenterX|kTextCenterY); Create a message dialog box. TGMsgBox(const TGWindow* p, const TGWindow* main, const char* title, const char* msg, EMsgBoxIcon icon, Int_t buttons = kMBDismiss, Int_t* ret_code = 0, UInt_t options = kVerticalFrame, Int_t text_align = kTextCenterX|kTextCenterY); Create a message dialog box with the following parameters:.; title: Window title; msg: Message to be shown ('\n' may be used to split it in lines); icon: Picture to be shown at the left on the dialog window.; It might take any of the following values:; kMBIconStop, kMBIconQuestion,; kMBIconExclamation, kMBIconAsterisk; buttons: Buttons to be shown at the botton of the dialgo window.; Look at EMsgBoxButton for the different possible values.; ret_code: It will hold the value of the button pressed when the; dialog is closed; options: Frame options of this dialog window.; text_align: Align options for 'msg'. See ETextJustification for the values. void PMsgBox(const char* title, const char* msg, const TGPicture* icon, Int_t buttons, Int_t* ret_code, Int_t text_align); Protected, common message dialog box initialization. ~TGMsgBox(); Destroy message dialog box. void CloseWindow(); Close dialog box. Before ",MatchSource.WIKI,root/html528/TGMsgBox.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGMsgBox.html
https://root.cern/root/html528/TGMsgBox.html:24122,Integrability,message,message,24122,"st TGWindow* p = 0, const TGWindow* main = 0, const char* title = 0, const char* msg = 0, const TGPicture* icon = 0, Int_t buttons = kMBDismiss, Int_t* ret_code = 0, UInt_t options = kVerticalFrame, Int_t text_align = kTextCenterX|kTextCenterY); Create a message dialog box. TGMsgBox(const TGWindow* p, const TGWindow* main, const char* title, const char* msg, EMsgBoxIcon icon, Int_t buttons = kMBDismiss, Int_t* ret_code = 0, UInt_t options = kVerticalFrame, Int_t text_align = kTextCenterX|kTextCenterY); Create a message dialog box with the following parameters:.; title: Window title; msg: Message to be shown ('\n' may be used to split it in lines); icon: Picture to be shown at the left on the dialog window.; It might take any of the following values:; kMBIconStop, kMBIconQuestion,; kMBIconExclamation, kMBIconAsterisk; buttons: Buttons to be shown at the botton of the dialgo window.; Look at EMsgBoxButton for the different possible values.; ret_code: It will hold the value of the button pressed when the; dialog is closed; options: Frame options of this dialog window.; text_align: Align options for 'msg'. See ETextJustification for the values. void PMsgBox(const char* title, const char* msg, const TGPicture* icon, Int_t buttons, Int_t* ret_code, Int_t text_align); Protected, common message dialog box initialization. ~TGMsgBox(); Destroy message dialog box. void CloseWindow(); Close dialog box. Before deleting itself it sets the return code; to kMBClose. Bool_t ProcessMessage(Long_t msg, Long_t parm1, Long_t parm2); Process message dialog box event. TGMsgBox(const TGMsgBox& ). TGMsgBox& operator=(const TGMsgBox& ). » Author: Fons Rademakers 09/01/98 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id: TGMsgBox.h 23115 2008-04-10 13:35:37Z rdm $ » Last generated: 2010-09-23 20:07; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html528/TGMsgBox.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGMsgBox.html
https://root.cern/root/html528/TGMsgBox.html:24178,Integrability,message,message,24178,"st TGWindow* p = 0, const TGWindow* main = 0, const char* title = 0, const char* msg = 0, const TGPicture* icon = 0, Int_t buttons = kMBDismiss, Int_t* ret_code = 0, UInt_t options = kVerticalFrame, Int_t text_align = kTextCenterX|kTextCenterY); Create a message dialog box. TGMsgBox(const TGWindow* p, const TGWindow* main, const char* title, const char* msg, EMsgBoxIcon icon, Int_t buttons = kMBDismiss, Int_t* ret_code = 0, UInt_t options = kVerticalFrame, Int_t text_align = kTextCenterX|kTextCenterY); Create a message dialog box with the following parameters:.; title: Window title; msg: Message to be shown ('\n' may be used to split it in lines); icon: Picture to be shown at the left on the dialog window.; It might take any of the following values:; kMBIconStop, kMBIconQuestion,; kMBIconExclamation, kMBIconAsterisk; buttons: Buttons to be shown at the botton of the dialgo window.; Look at EMsgBoxButton for the different possible values.; ret_code: It will hold the value of the button pressed when the; dialog is closed; options: Frame options of this dialog window.; text_align: Align options for 'msg'. See ETextJustification for the values. void PMsgBox(const char* title, const char* msg, const TGPicture* icon, Int_t buttons, Int_t* ret_code, Int_t text_align); Protected, common message dialog box initialization. ~TGMsgBox(); Destroy message dialog box. void CloseWindow(); Close dialog box. Before deleting itself it sets the return code; to kMBClose. Bool_t ProcessMessage(Long_t msg, Long_t parm1, Long_t parm2); Process message dialog box event. TGMsgBox(const TGMsgBox& ). TGMsgBox& operator=(const TGMsgBox& ). » Author: Fons Rademakers 09/01/98 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id: TGMsgBox.h 23115 2008-04-10 13:35:37Z rdm $ » Last generated: 2010-09-23 20:07; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html528/TGMsgBox.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGMsgBox.html
https://root.cern/root/html528/TGMsgBox.html:24368,Integrability,message,message,24368,"st TGWindow* p = 0, const TGWindow* main = 0, const char* title = 0, const char* msg = 0, const TGPicture* icon = 0, Int_t buttons = kMBDismiss, Int_t* ret_code = 0, UInt_t options = kVerticalFrame, Int_t text_align = kTextCenterX|kTextCenterY); Create a message dialog box. TGMsgBox(const TGWindow* p, const TGWindow* main, const char* title, const char* msg, EMsgBoxIcon icon, Int_t buttons = kMBDismiss, Int_t* ret_code = 0, UInt_t options = kVerticalFrame, Int_t text_align = kTextCenterX|kTextCenterY); Create a message dialog box with the following parameters:.; title: Window title; msg: Message to be shown ('\n' may be used to split it in lines); icon: Picture to be shown at the left on the dialog window.; It might take any of the following values:; kMBIconStop, kMBIconQuestion,; kMBIconExclamation, kMBIconAsterisk; buttons: Buttons to be shown at the botton of the dialgo window.; Look at EMsgBoxButton for the different possible values.; ret_code: It will hold the value of the button pressed when the; dialog is closed; options: Frame options of this dialog window.; text_align: Align options for 'msg'. See ETextJustification for the values. void PMsgBox(const char* title, const char* msg, const TGPicture* icon, Int_t buttons, Int_t* ret_code, Int_t text_align); Protected, common message dialog box initialization. ~TGMsgBox(); Destroy message dialog box. void CloseWindow(); Close dialog box. Before deleting itself it sets the return code; to kMBClose. Bool_t ProcessMessage(Long_t msg, Long_t parm1, Long_t parm2); Process message dialog box event. TGMsgBox(const TGMsgBox& ). TGMsgBox& operator=(const TGMsgBox& ). » Author: Fons Rademakers 09/01/98 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id: TGMsgBox.h 23115 2008-04-10 13:35:37Z rdm $ » Last generated: 2010-09-23 20:07; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html528/TGMsgBox.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGMsgBox.html
https://root.cern/root/html528/TGNumberEntry.html:454,Availability,down,down,454,". TGNumberEntry. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGNumberEntry. class TGNumberEntry: public TGCompositeFrame, public TGWidget, public TGNumberFormat. TGNumberEntry, TGNumberEntryField and TGNumberFormat. TGNumberEntry is a number entry input widget with up/down buttons.; TGNumberEntryField is a number entry input widget.; TGNumberFormat contains enum types to specify the numeric format. The number entry widget is based on TGTextEntry but allows only; numerical input. The widget support numerous formats including; integers, hex numbers, real numbers, fixed fraction reals and; time/date formats. The widget also allows to restrict input values; to non-negative or positive numbers and to specify explicit limits. The following styles are supported:; kNESInteger: integer number; kNESRealOne: real number with one digit (no exponent); kNESRealTwo: real number with two digits (no exponent); kNESRealThree: real number with three digits (no exponent); kNESRealFour: real number with four digits (no exponent); kNESReal: arbitrary real number; kNESDegree: angle in degree:minutes:seconds format; kNESMinSec: time in minutes:seconds format; kNESHourMin: time in hour:minutes format; kNESHourMinSec: time in hour:minutes:seconds format; kNESDayMYear: date in day/month/year format; kNESMDayYear: date in month/day/year format; kNESHex: hex number. The following attributes can be specified:; kNEAAnyNumber: any number is allowed; kNEANonNegative: only non-negative numbers are allowed; kNEAPositive: only positive numbers are allowed. Explicit limits can be specified individually:; kNELNoLimits: no limits; kNELLimitMin: lower limit only; kNELLimitMax upper limit only; kNELLimitMinMax both lower and upper limits. TGNumberEntryField is a plain vanilla entry field, whereas; TGNumberEntry adds two small",MatchSource.WIKI,root/html528/TGNumberEntry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGNumberEntry.html
https://root.cern/root/html528/TGNumberEntry.html:2126,Availability,down,down,2126,"th three digits (no exponent); kNESRealFour: real number with four digits (no exponent); kNESReal: arbitrary real number; kNESDegree: angle in degree:minutes:seconds format; kNESMinSec: time in minutes:seconds format; kNESHourMin: time in hour:minutes format; kNESHourMinSec: time in hour:minutes:seconds format; kNESDayMYear: date in day/month/year format; kNESMDayYear: date in month/day/year format; kNESHex: hex number. The following attributes can be specified:; kNEAAnyNumber: any number is allowed; kNEANonNegative: only non-negative numbers are allowed; kNEAPositive: only positive numbers are allowed. Explicit limits can be specified individually:; kNELNoLimits: no limits; kNELLimitMin: lower limit only; kNELLimitMax upper limit only; kNELLimitMinMax both lower and upper limits. TGNumberEntryField is a plain vanilla entry field, whereas; TGNumberEntry adds two small buttons to increase and decrease the; numerical value in the field. The number entry widgets also support; using the up and down cursor keys to change the numerical values.; The step size can be selected with control and shift keys:; -- small step (1 unit/factor of 3); shift medium step (10 units/factor of 10); control large step (100 units/factor of 30); shift-control huge step (1000 units/factor of 100). The steps are either linear or logarithmic. The default behaviour; is set when the entry field is created, but it can be changed by; pressing the alt key at the same time. Changing the number in the widget will generate the event:; kC_TEXTENTRY, kTE_TEXTCHANGED, widget id, 0.; Hitting the enter key will generate:; kC_TEXTENTRY, kTE_ENTER, widget id, 0.; Hitting the tab key will generate:; kC_TEXTENTRY, kTE_TAB, widget id, 0. /*. */. Function Members (Methods); public:. TGNumberEntry(const TGWindow* parent = 0, Double_t val = 0, Int_t digitwidth = 5, Int_t id = -1, TGNumberFormat::EStyle style = kNESReal, TGNumberFormat::EAttribute attr = kNEAAnyNumber, TGNumberFormat::ELimit limits = kNELNoLimits, Dou",MatchSource.WIKI,root/html528/TGNumberEntry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGNumberEntry.html
https://root.cern/root/html528/TGNumberEntry.html:6884,Availability,error,error,6884,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGButton*GetButtonDown() const; TGButton*GetButtonUp() const; TGClient*TGObject::GetClient() const; const char*TGWidget::GetCommand() const; static Int_tTGWindow::GetCounter(); virtual voidGetDate(Int_t& year, Int_t& month, Int_t& day) const; static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tGetDefaultHeight() const; static Pixel_tTGFrame",MatchSource.WIKI,root/html528/TGNumberEntry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGNumberEntry.html
https://root.cern/root/html528/TGNumberEntry.html:6968,Availability,error,error,6968,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGButton*GetButtonDown() const; TGButton*GetButtonUp() const; TGClient*TGObject::GetClient() const; const char*TGWidget::GetCommand() const; static Int_tTGWindow::GetCounter(); virtual voidGetDate(Int_t& year, Int_t& month, Int_t& day) const; static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tGetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSiz",MatchSource.WIKI,root/html528/TGNumberEntry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGNumberEntry.html
https://root.cern/root/html528/TGNumberEntry.html:21790,Availability,mask,mask,21790,,MatchSource.WIKI,root/html528/TGNumberEntry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGNumberEntry.html
https://root.cern/root/html528/TGNumberEntry.html:25712,Availability,down,down,25712," Libraries. Function documentation; TGNumberEntry(const TGWindow* parent = 0, Double_t val = 0, Int_t digitwidth = 5, Int_t id = -1, TGNumberFormat::EStyle style = kNESReal, TGNumberFormat::EAttribute attr = kNEAAnyNumber, TGNumberFormat::ELimit limits = kNELNoLimits, Double_t min = 0, Double_t max = 1); Constructs a numeric entry widget. ~TGNumberEntry(); Destructs a numeric entry widget. void Associate(const TGWindow* w); Make w the window that will receive the generated messages. void SetLogStep(Bool_t on = kTRUE); Set log steps. void SetState(Bool_t enable = kTRUE); Set the active state. void SetButtonToNum(Bool_t state); Send button messages to the number field (true) or parent widget (false).; When the message is sent to the parent widget, it is responsible to change; the numerical value accordingly. This can be useful to implement cursors; which move from data point to data point. For the message being sent; see ProcessMessage(). Bool_t ProcessMessage(Long_t msg, Long_t parm1, Long_t parm2); Process the up/down button messages. If fButtonToNum is false the; following message is sent: kC_COMMAND, kCM_BUTTON, widget id, param; param % 100 is the step size; param % 10000 / 100 != 0 indicates log step; param / 10000 != 0 indicates button down. TGLayoutManager * GetLayoutManager() const; Return layout manager. void ValueChanged(Long_t val); Emit ValueChanged(Long_t) signal. This signal is emitted when; fButtonToNum is false. The val has the following meaning:; val % 100 is the step size; val % 10000 / 100 != 0 indicates log step; val / 10000 != 0 indicates button down. void ValueSet(Long_t val); Emit ValueSet(Long_t) signal. This signal is emitted when the; number entry value is changed. The val has the following meaning:; val % 100 is the step size; val % 10000 / 100 != 0 indicates log step; val / 10000 != 0 indicates button down. void SavePrimitive(ostream& out, Option_t* = """"); Save a number entry widget as a C++ statement(s) on output stream out. void SetNumbe",MatchSource.WIKI,root/html528/TGNumberEntry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGNumberEntry.html
https://root.cern/root/html528/TGNumberEntry.html:25944,Availability,down,down,25944,"yle = kNESReal, TGNumberFormat::EAttribute attr = kNEAAnyNumber, TGNumberFormat::ELimit limits = kNELNoLimits, Double_t min = 0, Double_t max = 1); Constructs a numeric entry widget. ~TGNumberEntry(); Destructs a numeric entry widget. void Associate(const TGWindow* w); Make w the window that will receive the generated messages. void SetLogStep(Bool_t on = kTRUE); Set log steps. void SetState(Bool_t enable = kTRUE); Set the active state. void SetButtonToNum(Bool_t state); Send button messages to the number field (true) or parent widget (false).; When the message is sent to the parent widget, it is responsible to change; the numerical value accordingly. This can be useful to implement cursors; which move from data point to data point. For the message being sent; see ProcessMessage(). Bool_t ProcessMessage(Long_t msg, Long_t parm1, Long_t parm2); Process the up/down button messages. If fButtonToNum is false the; following message is sent: kC_COMMAND, kCM_BUTTON, widget id, param; param % 100 is the step size; param % 10000 / 100 != 0 indicates log step; param / 10000 != 0 indicates button down. TGLayoutManager * GetLayoutManager() const; Return layout manager. void ValueChanged(Long_t val); Emit ValueChanged(Long_t) signal. This signal is emitted when; fButtonToNum is false. The val has the following meaning:; val % 100 is the step size; val % 10000 / 100 != 0 indicates log step; val / 10000 != 0 indicates button down. void ValueSet(Long_t val); Emit ValueSet(Long_t) signal. This signal is emitted when the; number entry value is changed. The val has the following meaning:; val % 100 is the step size; val % 10000 / 100 != 0 indicates log step; val / 10000 != 0 indicates button down. void SavePrimitive(ostream& out, Option_t* = """"); Save a number entry widget as a C++ statement(s) on output stream out. void SetNumber(Double_t val). void SetIntNumber(Long_t val). void SetTime(Int_t hour, Int_t min, Int_t sec). void SetDate(Int_t year, Int_t month, Int_t day). void SetHexN",MatchSource.WIKI,root/html528/TGNumberEntry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGNumberEntry.html
https://root.cern/root/html528/TGNumberEntry.html:26275,Availability,down,down,26275," Set log steps. void SetState(Bool_t enable = kTRUE); Set the active state. void SetButtonToNum(Bool_t state); Send button messages to the number field (true) or parent widget (false).; When the message is sent to the parent widget, it is responsible to change; the numerical value accordingly. This can be useful to implement cursors; which move from data point to data point. For the message being sent; see ProcessMessage(). Bool_t ProcessMessage(Long_t msg, Long_t parm1, Long_t parm2); Process the up/down button messages. If fButtonToNum is false the; following message is sent: kC_COMMAND, kCM_BUTTON, widget id, param; param % 100 is the step size; param % 10000 / 100 != 0 indicates log step; param / 10000 != 0 indicates button down. TGLayoutManager * GetLayoutManager() const; Return layout manager. void ValueChanged(Long_t val); Emit ValueChanged(Long_t) signal. This signal is emitted when; fButtonToNum is false. The val has the following meaning:; val % 100 is the step size; val % 10000 / 100 != 0 indicates log step; val / 10000 != 0 indicates button down. void ValueSet(Long_t val); Emit ValueSet(Long_t) signal. This signal is emitted when the; number entry value is changed. The val has the following meaning:; val % 100 is the step size; val % 10000 / 100 != 0 indicates log step; val / 10000 != 0 indicates button down. void SavePrimitive(ostream& out, Option_t* = """"); Save a number entry widget as a C++ statement(s) on output stream out. void SetNumber(Double_t val). void SetIntNumber(Long_t val). void SetTime(Int_t hour, Int_t min, Int_t sec). void SetDate(Int_t year, Int_t month, Int_t day). void SetHexNumber(ULong_t val). void SetText(const char* text, Bool_t emit = kTRUE). Double_t GetNumber() const. Long_t GetIntNumber() const. void GetTime(Int_t& hour, Int_t& min, Int_t& sec) const. void GetDate(Int_t& year, Int_t& month, Int_t& day) const. ULong_t GetHexNumber() const. void IncreaseNumber(TGNumberFormat::EStepSize step = kNSSSmall, Int_t sign = 1, Bool_t log",MatchSource.WIKI,root/html528/TGNumberEntry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGNumberEntry.html
https://root.cern/root/html528/TGNumberEntry.html:26543,Availability,down,down,26543,"merical value accordingly. This can be useful to implement cursors; which move from data point to data point. For the message being sent; see ProcessMessage(). Bool_t ProcessMessage(Long_t msg, Long_t parm1, Long_t parm2); Process the up/down button messages. If fButtonToNum is false the; following message is sent: kC_COMMAND, kCM_BUTTON, widget id, param; param % 100 is the step size; param % 10000 / 100 != 0 indicates log step; param / 10000 != 0 indicates button down. TGLayoutManager * GetLayoutManager() const; Return layout manager. void ValueChanged(Long_t val); Emit ValueChanged(Long_t) signal. This signal is emitted when; fButtonToNum is false. The val has the following meaning:; val % 100 is the step size; val % 10000 / 100 != 0 indicates log step; val / 10000 != 0 indicates button down. void ValueSet(Long_t val); Emit ValueSet(Long_t) signal. This signal is emitted when the; number entry value is changed. The val has the following meaning:; val % 100 is the step size; val % 10000 / 100 != 0 indicates log step; val / 10000 != 0 indicates button down. void SavePrimitive(ostream& out, Option_t* = """"); Save a number entry widget as a C++ statement(s) on output stream out. void SetNumber(Double_t val). void SetIntNumber(Long_t val). void SetTime(Int_t hour, Int_t min, Int_t sec). void SetDate(Int_t year, Int_t month, Int_t day). void SetHexNumber(ULong_t val). void SetText(const char* text, Bool_t emit = kTRUE). Double_t GetNumber() const. Long_t GetIntNumber() const. void GetTime(Int_t& hour, Int_t& min, Int_t& sec) const. void GetDate(Int_t& year, Int_t& month, Int_t& day) const. ULong_t GetHexNumber() const. void IncreaseNumber(TGNumberFormat::EStepSize step = kNSSSmall, Int_t sign = 1, Bool_t logstep = kFALSE). void SetLimits(TGNumberFormat::ELimit limits = TGNumberFormat::kNELNoLimits, Double_t min = 0, Double_t max = 1). EStyle GetNumStyle() const; Get the numerical style. EAttribute GetNumAttr() const; Get the numerical attribute. ELimit GetNumLimits() con",MatchSource.WIKI,root/html528/TGNumberEntry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGNumberEntry.html
https://root.cern/root/html528/TGNumberEntry.html:28333,Availability,down,down,28333,"_t year, Int_t month, Int_t day). void SetHexNumber(ULong_t val). void SetText(const char* text, Bool_t emit = kTRUE). Double_t GetNumber() const. Long_t GetIntNumber() const. void GetTime(Int_t& hour, Int_t& min, Int_t& sec) const. void GetDate(Int_t& year, Int_t& month, Int_t& day) const. ULong_t GetHexNumber() const. void IncreaseNumber(TGNumberFormat::EStepSize step = kNSSSmall, Int_t sign = 1, Bool_t logstep = kFALSE). void SetLimits(TGNumberFormat::ELimit limits = TGNumberFormat::kNELNoLimits, Double_t min = 0, Double_t max = 1). EStyle GetNumStyle() const; Get the numerical style. EAttribute GetNumAttr() const; Get the numerical attribute. ELimit GetNumLimits() const; Get the numerialc limit attribute. Double_t GetNumMin() const; Get the lower limit. Double_t GetNumMax() const; Get the upper limit. Bool_t IsLogStep() const; Is log step enabled?. Bool_t IsEditable() const; { return kFALSE; }. TGNumberEntry(const TGNumberEntry& ). TGNumberEntry& operator=(const TGNumberEntry& ). void SetFormat(TGNumberFormat::EStyle style, TGNumberFormat::EAttribute attr = TGNumberFormat::kNEAAnyNumber); Set the numerical format. void SetNumStyle(TGNumberFormat::EStyle style). void SetNumAttr(TGNumberFormat::EAttribute attr = kNEAAnyNumber). void SetNumLimits(TGNumberFormat::ELimit limits = kNELNoLimits). void SetLimitValues(Double_t min = 0, Double_t max = 1). TGNumberEntryField * GetNumberEntry() const; Get the number entry field. TGButton * GetButtonUp() const; Get the up button. TGButton * GetButtonDown() const; Get the down button. UInt_t GetDefaultHeight() const; { return fNumericEntry->GetDefaultHeight(); }. » Author: Daniel Sigg 03/09/2001 » Copyright (C) 1995-2001, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id: TGNumberEntry.h 25233 2008-08-25 16:48:47Z bellenot $ » Last generated: 2010-09-23 20:07; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html528/TGNumberEntry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGNumberEntry.html
https://root.cern/root/html528/TGNumberEntry.html:21447,Integrability,message,messages,21447,,MatchSource.WIKI,root/html528/TGNumberEntry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGNumberEntry.html
https://root.cern/root/html528/TGNumberEntry.html:25161,Integrability,message,messages,25161,"Method=""GetNumAttr"";SetMethod=""SetNumAttr"";Items=(0=""&AnyNumber"",1=""&Non negative"",2=""&Positive"")}*; TGNumberFormat::ELimitfNumLimits*OPTION={GetMethod=""GetNumLimits"";SetMethod=""SetNumLimits"";Items=(0=""&No Limits"",1=""Limit M&in"",2=""Limit M&ax"",2=""Min &and Max"")}*; TGNumberFormat::EStylefNumStyle*OPTION={GetMethod=""GetNumStyle"";SetMethod=""SetNumStyle"";Items=(0=""Int"",5=""Real"",6=""Degree"",9=""Hour:Min:Sec"",10=""Day/Month/Year"",12=""Hex"")}*; const TGPicture*fPicDownDown arrow; const TGPicture*fPicUpUp arrow. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGNumberEntry(const TGWindow* parent = 0, Double_t val = 0, Int_t digitwidth = 5, Int_t id = -1, TGNumberFormat::EStyle style = kNESReal, TGNumberFormat::EAttribute attr = kNEAAnyNumber, TGNumberFormat::ELimit limits = kNELNoLimits, Double_t min = 0, Double_t max = 1); Constructs a numeric entry widget. ~TGNumberEntry(); Destructs a numeric entry widget. void Associate(const TGWindow* w); Make w the window that will receive the generated messages. void SetLogStep(Bool_t on = kTRUE); Set log steps. void SetState(Bool_t enable = kTRUE); Set the active state. void SetButtonToNum(Bool_t state); Send button messages to the number field (true) or parent widget (false).; When the message is sent to the parent widget, it is responsible to change; the numerical value accordingly. This can be useful to implement cursors; which move from data point to data point. For the message being sent; see ProcessMessage(). Bool_t ProcessMessage(Long_t msg, Long_t parm1, Long_t parm2); Process the up/down button messages. If fButtonToNum is false the; following message is sent: kC_COMMAND, kCM_BUTTON, widget id, param; param % 100 is the step size; param % 10000 / 100 != 0 indicates log step; param / 10000 != 0 indicates button down. TGLayoutManager * GetLayoutManager() const; Return layout manager. void ValueChanged(Long_t val); Emit ValueChanged(Long_t) signal. This signal is emitted when; fButtonToNum",MatchSource.WIKI,root/html528/TGNumberEntry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGNumberEntry.html
https://root.cern/root/html528/TGNumberEntry.html:25329,Integrability,message,messages,25329,",1=""Limit M&in"",2=""Limit M&ax"",2=""Min &and Max"")}*; TGNumberFormat::EStylefNumStyle*OPTION={GetMethod=""GetNumStyle"";SetMethod=""SetNumStyle"";Items=(0=""Int"",5=""Real"",6=""Degree"",9=""Hour:Min:Sec"",10=""Day/Month/Year"",12=""Hex"")}*; const TGPicture*fPicDownDown arrow; const TGPicture*fPicUpUp arrow. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGNumberEntry(const TGWindow* parent = 0, Double_t val = 0, Int_t digitwidth = 5, Int_t id = -1, TGNumberFormat::EStyle style = kNESReal, TGNumberFormat::EAttribute attr = kNEAAnyNumber, TGNumberFormat::ELimit limits = kNELNoLimits, Double_t min = 0, Double_t max = 1); Constructs a numeric entry widget. ~TGNumberEntry(); Destructs a numeric entry widget. void Associate(const TGWindow* w); Make w the window that will receive the generated messages. void SetLogStep(Bool_t on = kTRUE); Set log steps. void SetState(Bool_t enable = kTRUE); Set the active state. void SetButtonToNum(Bool_t state); Send button messages to the number field (true) or parent widget (false).; When the message is sent to the parent widget, it is responsible to change; the numerical value accordingly. This can be useful to implement cursors; which move from data point to data point. For the message being sent; see ProcessMessage(). Bool_t ProcessMessage(Long_t msg, Long_t parm1, Long_t parm2); Process the up/down button messages. If fButtonToNum is false the; following message is sent: kC_COMMAND, kCM_BUTTON, widget id, param; param % 100 is the step size; param % 10000 / 100 != 0 indicates log step; param / 10000 != 0 indicates button down. TGLayoutManager * GetLayoutManager() const; Return layout manager. void ValueChanged(Long_t val); Emit ValueChanged(Long_t) signal. This signal is emitted when; fButtonToNum is false. The val has the following meaning:; val % 100 is the step size; val % 10000 / 100 != 0 indicates log step; val / 10000 != 0 indicates button down. void ValueSet(Long_t val); Emit ValueSet(Long_t) signal",MatchSource.WIKI,root/html528/TGNumberEntry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGNumberEntry.html
https://root.cern/root/html528/TGNumberEntry.html:25401,Integrability,message,message,25401,"tyle"";SetMethod=""SetNumStyle"";Items=(0=""Int"",5=""Real"",6=""Degree"",9=""Hour:Min:Sec"",10=""Day/Month/Year"",12=""Hex"")}*; const TGPicture*fPicDownDown arrow; const TGPicture*fPicUpUp arrow. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGNumberEntry(const TGWindow* parent = 0, Double_t val = 0, Int_t digitwidth = 5, Int_t id = -1, TGNumberFormat::EStyle style = kNESReal, TGNumberFormat::EAttribute attr = kNEAAnyNumber, TGNumberFormat::ELimit limits = kNELNoLimits, Double_t min = 0, Double_t max = 1); Constructs a numeric entry widget. ~TGNumberEntry(); Destructs a numeric entry widget. void Associate(const TGWindow* w); Make w the window that will receive the generated messages. void SetLogStep(Bool_t on = kTRUE); Set log steps. void SetState(Bool_t enable = kTRUE); Set the active state. void SetButtonToNum(Bool_t state); Send button messages to the number field (true) or parent widget (false).; When the message is sent to the parent widget, it is responsible to change; the numerical value accordingly. This can be useful to implement cursors; which move from data point to data point. For the message being sent; see ProcessMessage(). Bool_t ProcessMessage(Long_t msg, Long_t parm1, Long_t parm2); Process the up/down button messages. If fButtonToNum is false the; following message is sent: kC_COMMAND, kCM_BUTTON, widget id, param; param % 100 is the step size; param % 10000 / 100 != 0 indicates log step; param / 10000 != 0 indicates button down. TGLayoutManager * GetLayoutManager() const; Return layout manager. void ValueChanged(Long_t val); Emit ValueChanged(Long_t) signal. This signal is emitted when; fButtonToNum is false. The val has the following meaning:; val % 100 is the step size; val % 10000 / 100 != 0 indicates log step; val / 10000 != 0 indicates button down. void ValueSet(Long_t val); Emit ValueSet(Long_t) signal. This signal is emitted when the; number entry value is changed. The val has the following meaning:; val % 1",MatchSource.WIKI,root/html528/TGNumberEntry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGNumberEntry.html
https://root.cern/root/html528/TGNumberEntry.html:25592,Integrability,message,message,25592,"ure*fPicUpUp arrow. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGNumberEntry(const TGWindow* parent = 0, Double_t val = 0, Int_t digitwidth = 5, Int_t id = -1, TGNumberFormat::EStyle style = kNESReal, TGNumberFormat::EAttribute attr = kNEAAnyNumber, TGNumberFormat::ELimit limits = kNELNoLimits, Double_t min = 0, Double_t max = 1); Constructs a numeric entry widget. ~TGNumberEntry(); Destructs a numeric entry widget. void Associate(const TGWindow* w); Make w the window that will receive the generated messages. void SetLogStep(Bool_t on = kTRUE); Set log steps. void SetState(Bool_t enable = kTRUE); Set the active state. void SetButtonToNum(Bool_t state); Send button messages to the number field (true) or parent widget (false).; When the message is sent to the parent widget, it is responsible to change; the numerical value accordingly. This can be useful to implement cursors; which move from data point to data point. For the message being sent; see ProcessMessage(). Bool_t ProcessMessage(Long_t msg, Long_t parm1, Long_t parm2); Process the up/down button messages. If fButtonToNum is false the; following message is sent: kC_COMMAND, kCM_BUTTON, widget id, param; param % 100 is the step size; param % 10000 / 100 != 0 indicates log step; param / 10000 != 0 indicates button down. TGLayoutManager * GetLayoutManager() const; Return layout manager. void ValueChanged(Long_t val); Emit ValueChanged(Long_t) signal. This signal is emitted when; fButtonToNum is false. The val has the following meaning:; val % 100 is the step size; val % 10000 / 100 != 0 indicates log step; val / 10000 != 0 indicates button down. void ValueSet(Long_t val); Emit ValueSet(Long_t) signal. This signal is emitted when the; number entry value is changed. The val has the following meaning:; val % 100 is the step size; val % 10000 / 100 != 0 indicates log step; val / 10000 != 0 indicates button down. void SavePrimitive(ostream& out, Option_t* = """"); Save a nu",MatchSource.WIKI,root/html528/TGNumberEntry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGNumberEntry.html
https://root.cern/root/html528/TGNumberEntry.html:25724,Integrability,message,messages,25724," Libraries. Function documentation; TGNumberEntry(const TGWindow* parent = 0, Double_t val = 0, Int_t digitwidth = 5, Int_t id = -1, TGNumberFormat::EStyle style = kNESReal, TGNumberFormat::EAttribute attr = kNEAAnyNumber, TGNumberFormat::ELimit limits = kNELNoLimits, Double_t min = 0, Double_t max = 1); Constructs a numeric entry widget. ~TGNumberEntry(); Destructs a numeric entry widget. void Associate(const TGWindow* w); Make w the window that will receive the generated messages. void SetLogStep(Bool_t on = kTRUE); Set log steps. void SetState(Bool_t enable = kTRUE); Set the active state. void SetButtonToNum(Bool_t state); Send button messages to the number field (true) or parent widget (false).; When the message is sent to the parent widget, it is responsible to change; the numerical value accordingly. This can be useful to implement cursors; which move from data point to data point. For the message being sent; see ProcessMessage(). Bool_t ProcessMessage(Long_t msg, Long_t parm1, Long_t parm2); Process the up/down button messages. If fButtonToNum is false the; following message is sent: kC_COMMAND, kCM_BUTTON, widget id, param; param % 100 is the step size; param % 10000 / 100 != 0 indicates log step; param / 10000 != 0 indicates button down. TGLayoutManager * GetLayoutManager() const; Return layout manager. void ValueChanged(Long_t val); Emit ValueChanged(Long_t) signal. This signal is emitted when; fButtonToNum is false. The val has the following meaning:; val % 100 is the step size; val % 10000 / 100 != 0 indicates log step; val / 10000 != 0 indicates button down. void ValueSet(Long_t val); Emit ValueSet(Long_t) signal. This signal is emitted when the; number entry value is changed. The val has the following meaning:; val % 100 is the step size; val % 10000 / 100 != 0 indicates log step; val / 10000 != 0 indicates button down. void SavePrimitive(ostream& out, Option_t* = """"); Save a number entry widget as a C++ statement(s) on output stream out. void SetNumbe",MatchSource.WIKI,root/html528/TGNumberEntry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGNumberEntry.html
https://root.cern/root/html528/TGNumberEntry.html:25774,Integrability,message,message,25774,"yle = kNESReal, TGNumberFormat::EAttribute attr = kNEAAnyNumber, TGNumberFormat::ELimit limits = kNELNoLimits, Double_t min = 0, Double_t max = 1); Constructs a numeric entry widget. ~TGNumberEntry(); Destructs a numeric entry widget. void Associate(const TGWindow* w); Make w the window that will receive the generated messages. void SetLogStep(Bool_t on = kTRUE); Set log steps. void SetState(Bool_t enable = kTRUE); Set the active state. void SetButtonToNum(Bool_t state); Send button messages to the number field (true) or parent widget (false).; When the message is sent to the parent widget, it is responsible to change; the numerical value accordingly. This can be useful to implement cursors; which move from data point to data point. For the message being sent; see ProcessMessage(). Bool_t ProcessMessage(Long_t msg, Long_t parm1, Long_t parm2); Process the up/down button messages. If fButtonToNum is false the; following message is sent: kC_COMMAND, kCM_BUTTON, widget id, param; param % 100 is the step size; param % 10000 / 100 != 0 indicates log step; param / 10000 != 0 indicates button down. TGLayoutManager * GetLayoutManager() const; Return layout manager. void ValueChanged(Long_t val); Emit ValueChanged(Long_t) signal. This signal is emitted when; fButtonToNum is false. The val has the following meaning:; val % 100 is the step size; val % 10000 / 100 != 0 indicates log step; val / 10000 != 0 indicates button down. void ValueSet(Long_t val); Emit ValueSet(Long_t) signal. This signal is emitted when the; number entry value is changed. The val has the following meaning:; val % 100 is the step size; val % 10000 / 100 != 0 indicates log step; val / 10000 != 0 indicates button down. void SavePrimitive(ostream& out, Option_t* = """"); Save a number entry widget as a C++ statement(s) on output stream out. void SetNumber(Double_t val). void SetIntNumber(Long_t val). void SetTime(Int_t hour, Int_t min, Int_t sec). void SetDate(Int_t year, Int_t month, Int_t day). void SetHexN",MatchSource.WIKI,root/html528/TGNumberEntry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGNumberEntry.html
https://root.cern/root/html528/TGNumberEntry.html:2443,Testability,log,logarithmic,2443," kNESDayMYear: date in day/month/year format; kNESMDayYear: date in month/day/year format; kNESHex: hex number. The following attributes can be specified:; kNEAAnyNumber: any number is allowed; kNEANonNegative: only non-negative numbers are allowed; kNEAPositive: only positive numbers are allowed. Explicit limits can be specified individually:; kNELNoLimits: no limits; kNELLimitMin: lower limit only; kNELLimitMax upper limit only; kNELLimitMinMax both lower and upper limits. TGNumberEntryField is a plain vanilla entry field, whereas; TGNumberEntry adds two small buttons to increase and decrease the; numerical value in the field. The number entry widgets also support; using the up and down cursor keys to change the numerical values.; The step size can be selected with control and shift keys:; -- small step (1 unit/factor of 3); shift medium step (10 units/factor of 10); control large step (100 units/factor of 30); shift-control huge step (1000 units/factor of 100). The steps are either linear or logarithmic. The default behaviour; is set when the entry field is created, but it can be changed by; pressing the alt key at the same time. Changing the number in the widget will generate the event:; kC_TEXTENTRY, kTE_TEXTCHANGED, widget id, 0.; Hitting the enter key will generate:; kC_TEXTENTRY, kTE_ENTER, widget id, 0.; Hitting the tab key will generate:; kC_TEXTENTRY, kTE_TAB, widget id, 0. /*. */. Function Members (Methods); public:. TGNumberEntry(const TGWindow* parent = 0, Double_t val = 0, Int_t digitwidth = 5, Int_t id = -1, TGNumberFormat::EStyle style = kNESReal, TGNumberFormat::EAttribute attr = kNEAAnyNumber, TGNumberFormat::ELimit limits = kNELNoLimits, Double_t min = 0, Double_t max = 1); virtual~TGNumberEntry(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option",MatchSource.WIKI,root/html528/TGNumberEntry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGNumberEntry.html
https://root.cern/root/html528/TGNumberEntry.html:12074,Testability,log,logstep,12074,":HandleDragMotion(TGFrame*); virtual Bool_tTGFrame::HandleEvent(Event_t* event); virtual Bool_tTGWindow::HandleExpose(Event_t* event); virtual Bool_tTGCompositeFrame::HandleFocusChange(Event_t*); virtual Bool_tTGWindow::HandleIdleEvent(TGIdleHandler*); virtual Bool_tTGCompositeFrame::HandleKey(Event_t*); virtual Bool_tTGCompositeFrame::HandleMotion(Event_t*); virtual Bool_tTGCompositeFrame::HandleSelection(Event_t*); virtual Bool_tTGFrame::HandleSelectionClear(Event_t*); virtual Bool_tTGFrame::HandleSelectionRequest(Event_t*); virtual Bool_tTGWindow::HandleTimer(TTimer*); virtual Bool_tTQObject::HasConnection(const char* signal_name) const; Bool_tTGWidget::HasFocus() const; virtual ULong_tTGObject::Hash() const; virtual voidTGCompositeFrame::HideFrame(TGFrame* f); virtual voidTQObject::HighPriority(const char* signal_name, const char* slot_name = 0); virtual voidTGWindow::IconifyWindow(); virtual voidIncreaseNumber(TGNumberFormat::EStepSize step = kNSSSmall, Int_t sign = 1, Bool_t logstep = kFALSE); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTGFrame::Inspect() const; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTGFrame::IsActive() const; Bool_tTGCompositeFrame::IsArranged(TGFrame* f) const; Bool_tTGCompositeFrame::IsArranged(TGFrameElement* ptr) const; virtual Bool_tTGCompositeFrame::IsComposite() const; Bool_tTGFrame::IsDNDSource() const; Bool_tTGFrame::IsDNDTarget() const; virtual Bool_tIsEditable() const; Bool_tTGWidget::IsEnabled() const; virtual Bool_tTGObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; virtual Bool_tTGCompositeFrame::IsLayoutBroken() const; virtual Bool_tIsLogStep() const; virtual Bool_tTGWindow::IsMapped(); virtual Bool_tTGCompositeFrame::IsMapSubwindows() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObj",MatchSource.WIKI,root/html528/TGNumberEntry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGNumberEntry.html
https://root.cern/root/html528/TGNumberEntry.html:25211,Testability,log,log,25211,"negative"",2=""&Positive"")}*; TGNumberFormat::ELimitfNumLimits*OPTION={GetMethod=""GetNumLimits"";SetMethod=""SetNumLimits"";Items=(0=""&No Limits"",1=""Limit M&in"",2=""Limit M&ax"",2=""Min &and Max"")}*; TGNumberFormat::EStylefNumStyle*OPTION={GetMethod=""GetNumStyle"";SetMethod=""SetNumStyle"";Items=(0=""Int"",5=""Real"",6=""Degree"",9=""Hour:Min:Sec"",10=""Day/Month/Year"",12=""Hex"")}*; const TGPicture*fPicDownDown arrow; const TGPicture*fPicUpUp arrow. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGNumberEntry(const TGWindow* parent = 0, Double_t val = 0, Int_t digitwidth = 5, Int_t id = -1, TGNumberFormat::EStyle style = kNESReal, TGNumberFormat::EAttribute attr = kNEAAnyNumber, TGNumberFormat::ELimit limits = kNELNoLimits, Double_t min = 0, Double_t max = 1); Constructs a numeric entry widget. ~TGNumberEntry(); Destructs a numeric entry widget. void Associate(const TGWindow* w); Make w the window that will receive the generated messages. void SetLogStep(Bool_t on = kTRUE); Set log steps. void SetState(Bool_t enable = kTRUE); Set the active state. void SetButtonToNum(Bool_t state); Send button messages to the number field (true) or parent widget (false).; When the message is sent to the parent widget, it is responsible to change; the numerical value accordingly. This can be useful to implement cursors; which move from data point to data point. For the message being sent; see ProcessMessage(). Bool_t ProcessMessage(Long_t msg, Long_t parm1, Long_t parm2); Process the up/down button messages. If fButtonToNum is false the; following message is sent: kC_COMMAND, kCM_BUTTON, widget id, param; param % 100 is the step size; param % 10000 / 100 != 0 indicates log step; param / 10000 != 0 indicates button down. TGLayoutManager * GetLayoutManager() const; Return layout manager. void ValueChanged(Long_t val); Emit ValueChanged(Long_t) signal. This signal is emitted when; fButtonToNum is false. The val has the following meaning:; val % 100 is the step size",MatchSource.WIKI,root/html528/TGNumberEntry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGNumberEntry.html
https://root.cern/root/html528/TGNumberEntry.html:25898,Testability,log,log,25898,"yle = kNESReal, TGNumberFormat::EAttribute attr = kNEAAnyNumber, TGNumberFormat::ELimit limits = kNELNoLimits, Double_t min = 0, Double_t max = 1); Constructs a numeric entry widget. ~TGNumberEntry(); Destructs a numeric entry widget. void Associate(const TGWindow* w); Make w the window that will receive the generated messages. void SetLogStep(Bool_t on = kTRUE); Set log steps. void SetState(Bool_t enable = kTRUE); Set the active state. void SetButtonToNum(Bool_t state); Send button messages to the number field (true) or parent widget (false).; When the message is sent to the parent widget, it is responsible to change; the numerical value accordingly. This can be useful to implement cursors; which move from data point to data point. For the message being sent; see ProcessMessage(). Bool_t ProcessMessage(Long_t msg, Long_t parm1, Long_t parm2); Process the up/down button messages. If fButtonToNum is false the; following message is sent: kC_COMMAND, kCM_BUTTON, widget id, param; param % 100 is the step size; param % 10000 / 100 != 0 indicates log step; param / 10000 != 0 indicates button down. TGLayoutManager * GetLayoutManager() const; Return layout manager. void ValueChanged(Long_t val); Emit ValueChanged(Long_t) signal. This signal is emitted when; fButtonToNum is false. The val has the following meaning:; val % 100 is the step size; val % 10000 / 100 != 0 indicates log step; val / 10000 != 0 indicates button down. void ValueSet(Long_t val); Emit ValueSet(Long_t) signal. This signal is emitted when the; number entry value is changed. The val has the following meaning:; val % 100 is the step size; val % 10000 / 100 != 0 indicates log step; val / 10000 != 0 indicates button down. void SavePrimitive(ostream& out, Option_t* = """"); Save a number entry widget as a C++ statement(s) on output stream out. void SetNumber(Double_t val). void SetIntNumber(Long_t val). void SetTime(Int_t hour, Int_t min, Int_t sec). void SetDate(Int_t year, Int_t month, Int_t day). void SetHexN",MatchSource.WIKI,root/html528/TGNumberEntry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGNumberEntry.html
https://root.cern/root/html528/TGNumberEntry.html:26231,Testability,log,log,26231," Set log steps. void SetState(Bool_t enable = kTRUE); Set the active state. void SetButtonToNum(Bool_t state); Send button messages to the number field (true) or parent widget (false).; When the message is sent to the parent widget, it is responsible to change; the numerical value accordingly. This can be useful to implement cursors; which move from data point to data point. For the message being sent; see ProcessMessage(). Bool_t ProcessMessage(Long_t msg, Long_t parm1, Long_t parm2); Process the up/down button messages. If fButtonToNum is false the; following message is sent: kC_COMMAND, kCM_BUTTON, widget id, param; param % 100 is the step size; param % 10000 / 100 != 0 indicates log step; param / 10000 != 0 indicates button down. TGLayoutManager * GetLayoutManager() const; Return layout manager. void ValueChanged(Long_t val); Emit ValueChanged(Long_t) signal. This signal is emitted when; fButtonToNum is false. The val has the following meaning:; val % 100 is the step size; val % 10000 / 100 != 0 indicates log step; val / 10000 != 0 indicates button down. void ValueSet(Long_t val); Emit ValueSet(Long_t) signal. This signal is emitted when the; number entry value is changed. The val has the following meaning:; val % 100 is the step size; val % 10000 / 100 != 0 indicates log step; val / 10000 != 0 indicates button down. void SavePrimitive(ostream& out, Option_t* = """"); Save a number entry widget as a C++ statement(s) on output stream out. void SetNumber(Double_t val). void SetIntNumber(Long_t val). void SetTime(Int_t hour, Int_t min, Int_t sec). void SetDate(Int_t year, Int_t month, Int_t day). void SetHexNumber(ULong_t val). void SetText(const char* text, Bool_t emit = kTRUE). Double_t GetNumber() const. Long_t GetIntNumber() const. void GetTime(Int_t& hour, Int_t& min, Int_t& sec) const. void GetDate(Int_t& year, Int_t& month, Int_t& day) const. ULong_t GetHexNumber() const. void IncreaseNumber(TGNumberFormat::EStepSize step = kNSSSmall, Int_t sign = 1, Bool_t log",MatchSource.WIKI,root/html528/TGNumberEntry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGNumberEntry.html
https://root.cern/root/html528/TGNumberEntry.html:26499,Testability,log,log,26499,"merical value accordingly. This can be useful to implement cursors; which move from data point to data point. For the message being sent; see ProcessMessage(). Bool_t ProcessMessage(Long_t msg, Long_t parm1, Long_t parm2); Process the up/down button messages. If fButtonToNum is false the; following message is sent: kC_COMMAND, kCM_BUTTON, widget id, param; param % 100 is the step size; param % 10000 / 100 != 0 indicates log step; param / 10000 != 0 indicates button down. TGLayoutManager * GetLayoutManager() const; Return layout manager. void ValueChanged(Long_t val); Emit ValueChanged(Long_t) signal. This signal is emitted when; fButtonToNum is false. The val has the following meaning:; val % 100 is the step size; val % 10000 / 100 != 0 indicates log step; val / 10000 != 0 indicates button down. void ValueSet(Long_t val); Emit ValueSet(Long_t) signal. This signal is emitted when the; number entry value is changed. The val has the following meaning:; val % 100 is the step size; val % 10000 / 100 != 0 indicates log step; val / 10000 != 0 indicates button down. void SavePrimitive(ostream& out, Option_t* = """"); Save a number entry widget as a C++ statement(s) on output stream out. void SetNumber(Double_t val). void SetIntNumber(Long_t val). void SetTime(Int_t hour, Int_t min, Int_t sec). void SetDate(Int_t year, Int_t month, Int_t day). void SetHexNumber(ULong_t val). void SetText(const char* text, Bool_t emit = kTRUE). Double_t GetNumber() const. Long_t GetIntNumber() const. void GetTime(Int_t& hour, Int_t& min, Int_t& sec) const. void GetDate(Int_t& year, Int_t& month, Int_t& day) const. ULong_t GetHexNumber() const. void IncreaseNumber(TGNumberFormat::EStepSize step = kNSSSmall, Int_t sign = 1, Bool_t logstep = kFALSE). void SetLimits(TGNumberFormat::ELimit limits = TGNumberFormat::kNELNoLimits, Double_t min = 0, Double_t max = 1). EStyle GetNumStyle() const; Get the numerical style. EAttribute GetNumAttr() const; Get the numerical attribute. ELimit GetNumLimits() con",MatchSource.WIKI,root/html528/TGNumberEntry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGNumberEntry.html
https://root.cern/root/html528/TGNumberEntry.html:27204,Testability,log,logstep,27204," val % 100 is the step size; val % 10000 / 100 != 0 indicates log step; val / 10000 != 0 indicates button down. void ValueSet(Long_t val); Emit ValueSet(Long_t) signal. This signal is emitted when the; number entry value is changed. The val has the following meaning:; val % 100 is the step size; val % 10000 / 100 != 0 indicates log step; val / 10000 != 0 indicates button down. void SavePrimitive(ostream& out, Option_t* = """"); Save a number entry widget as a C++ statement(s) on output stream out. void SetNumber(Double_t val). void SetIntNumber(Long_t val). void SetTime(Int_t hour, Int_t min, Int_t sec). void SetDate(Int_t year, Int_t month, Int_t day). void SetHexNumber(ULong_t val). void SetText(const char* text, Bool_t emit = kTRUE). Double_t GetNumber() const. Long_t GetIntNumber() const. void GetTime(Int_t& hour, Int_t& min, Int_t& sec) const. void GetDate(Int_t& year, Int_t& month, Int_t& day) const. ULong_t GetHexNumber() const. void IncreaseNumber(TGNumberFormat::EStepSize step = kNSSSmall, Int_t sign = 1, Bool_t logstep = kFALSE). void SetLimits(TGNumberFormat::ELimit limits = TGNumberFormat::kNELNoLimits, Double_t min = 0, Double_t max = 1). EStyle GetNumStyle() const; Get the numerical style. EAttribute GetNumAttr() const; Get the numerical attribute. ELimit GetNumLimits() const; Get the numerialc limit attribute. Double_t GetNumMin() const; Get the lower limit. Double_t GetNumMax() const; Get the upper limit. Bool_t IsLogStep() const; Is log step enabled?. Bool_t IsEditable() const; { return kFALSE; }. TGNumberEntry(const TGNumberEntry& ). TGNumberEntry& operator=(const TGNumberEntry& ). void SetFormat(TGNumberFormat::EStyle style, TGNumberFormat::EAttribute attr = TGNumberFormat::kNEAAnyNumber); Set the numerical format. void SetNumStyle(TGNumberFormat::EStyle style). void SetNumAttr(TGNumberFormat::EAttribute attr = kNEAAnyNumber). void SetNumLimits(TGNumberFormat::ELimit limits = kNELNoLimits). void SetLimitValues(Double_t min = 0, Double_t max = 1). TG",MatchSource.WIKI,root/html528/TGNumberEntry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGNumberEntry.html
https://root.cern/root/html528/TGNumberEntry.html:27641,Testability,log,log,27641,"statement(s) on output stream out. void SetNumber(Double_t val). void SetIntNumber(Long_t val). void SetTime(Int_t hour, Int_t min, Int_t sec). void SetDate(Int_t year, Int_t month, Int_t day). void SetHexNumber(ULong_t val). void SetText(const char* text, Bool_t emit = kTRUE). Double_t GetNumber() const. Long_t GetIntNumber() const. void GetTime(Int_t& hour, Int_t& min, Int_t& sec) const. void GetDate(Int_t& year, Int_t& month, Int_t& day) const. ULong_t GetHexNumber() const. void IncreaseNumber(TGNumberFormat::EStepSize step = kNSSSmall, Int_t sign = 1, Bool_t logstep = kFALSE). void SetLimits(TGNumberFormat::ELimit limits = TGNumberFormat::kNELNoLimits, Double_t min = 0, Double_t max = 1). EStyle GetNumStyle() const; Get the numerical style. EAttribute GetNumAttr() const; Get the numerical attribute. ELimit GetNumLimits() const; Get the numerialc limit attribute. Double_t GetNumMin() const; Get the lower limit. Double_t GetNumMax() const; Get the upper limit. Bool_t IsLogStep() const; Is log step enabled?. Bool_t IsEditable() const; { return kFALSE; }. TGNumberEntry(const TGNumberEntry& ). TGNumberEntry& operator=(const TGNumberEntry& ). void SetFormat(TGNumberFormat::EStyle style, TGNumberFormat::EAttribute attr = TGNumberFormat::kNEAAnyNumber); Set the numerical format. void SetNumStyle(TGNumberFormat::EStyle style). void SetNumAttr(TGNumberFormat::EAttribute attr = kNEAAnyNumber). void SetNumLimits(TGNumberFormat::ELimit limits = kNELNoLimits). void SetLimitValues(Double_t min = 0, Double_t max = 1). TGNumberEntryField * GetNumberEntry() const; Get the number entry field. TGButton * GetButtonUp() const; Get the up button. TGButton * GetButtonDown() const; Get the down button. UInt_t GetDefaultHeight() const; { return fNumericEntry->GetDefaultHeight(); }. » Author: Daniel Sigg 03/09/2001 » Copyright (C) 1995-2001, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id: TGNumberEntry.h 25233 2008-08-25 16:48:47Z bellenot $ » Last generated: 2010-09-23 20",MatchSource.WIKI,root/html528/TGNumberEntry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGNumberEntry.html
https://root.cern/root/html528/TGNumberEntryField.html:447,Availability,down,down,447,". TGNumberEntryField. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGNumberEntryField. class TGNumberEntryField: public TGTextEntry, public TGNumberFormat. TGNumberEntry, TGNumberEntryField and TGNumberFormat. TGNumberEntry is a number entry input widget with up/down buttons.; TGNumberEntryField is a number entry input widget.; TGNumberFormat contains enum types to specify the numeric format. The number entry widget is based on TGTextEntry but allows only; numerical input. The widget support numerous formats including; integers, hex numbers, real numbers, fixed fraction reals and; time/date formats. The widget also allows to restrict input values; to non-negative or positive numbers and to specify explicit limits. The following styles are supported:; kNESInteger: integer number; kNESRealOne: real number with one digit (no exponent); kNESRealTwo: real number with two digits (no exponent); kNESRealThree: real number with three digits (no exponent); kNESRealFour: real number with four digits (no exponent); kNESReal: arbitrary real number; kNESDegree: angle in degree:minutes:seconds format; kNESMinSec: time in minutes:seconds format; kNESHourMin: time in hour:minutes format; kNESHourMinSec: time in hour:minutes:seconds format; kNESDayMYear: date in day/month/year format; kNESMDayYear: date in month/day/year format; kNESHex: hex number. The following attributes can be specified:; kNEAAnyNumber: any number is allowed; kNEANonNegative: only non-negative numbers are allowed; kNEAPositive: only positive numbers are allowed. Explicit limits can be specified individually:; kNELNoLimits: no limits; kNELLimitMin: lower limit only; kNELLimitMax upper limit only; kNELLimitMinMax both lower and upper limits. TGNumberEntryField is a plain vanilla entry field, whereas; TGNumberEntry adds two small button",MatchSource.WIKI,root/html528/TGNumberEntryField.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGNumberEntryField.html
https://root.cern/root/html528/TGNumberEntryField.html:2119,Availability,down,down,2119,"th three digits (no exponent); kNESRealFour: real number with four digits (no exponent); kNESReal: arbitrary real number; kNESDegree: angle in degree:minutes:seconds format; kNESMinSec: time in minutes:seconds format; kNESHourMin: time in hour:minutes format; kNESHourMinSec: time in hour:minutes:seconds format; kNESDayMYear: date in day/month/year format; kNESMDayYear: date in month/day/year format; kNESHex: hex number. The following attributes can be specified:; kNEAAnyNumber: any number is allowed; kNEANonNegative: only non-negative numbers are allowed; kNEAPositive: only positive numbers are allowed. Explicit limits can be specified individually:; kNELNoLimits: no limits; kNELLimitMin: lower limit only; kNELLimitMax upper limit only; kNELLimitMinMax both lower and upper limits. TGNumberEntryField is a plain vanilla entry field, whereas; TGNumberEntry adds two small buttons to increase and decrease the; numerical value in the field. The number entry widgets also support; using the up and down cursor keys to change the numerical values.; The step size can be selected with control and shift keys:; -- small step (1 unit/factor of 3); shift medium step (10 units/factor of 10); control large step (100 units/factor of 30); shift-control huge step (1000 units/factor of 100). The steps are either linear or logarithmic. The default behaviour; is set when the entry field is created, but it can be changed by; pressing the alt key at the same time. Changing the number in the widget will generate the event:; kC_TEXTENTRY, kTE_TEXTCHANGED, widget id, 0.; Hitting the enter key will generate:; kC_TEXTENTRY, kTE_ENTER, widget id, 0.; Hitting the tab key will generate:; kC_TEXTENTRY, kTE_TAB, widget id, 0. /*. */. Function Members (Methods); public:. TGNumberEntryField(const TGWindow* p, Int_t id, Double_t val, GContext_t norm, FontStruct_t font = GetDefaultFontStruct(), UInt_t option = kSunkenFrame|kDoubleBorder, Pixel_t back = GetWhitePixel()); TGNumberEntryField(const TGWindow* p",MatchSource.WIKI,root/html528/TGNumberEntryField.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGNumberEntryField.html
https://root.cern/root/html528/TGNumberEntryField.html:7592,Availability,error,error,7592,"gnal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTGTextEntry::End(Bool_t mark = kFALSE); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; ETextJustificationTGTextEntry::GetAlignment() const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGTextBuffer*TGTextEntry::GetBuffer() const; virtual Int_tGetCharWidth(const char* text = ""0"") const; TGClient*TGObject::GetClient() const; const char*TGWidget::GetCommand() const; static Int_tTGWindow::GetCounter(); Int_tTGTextEntry::GetCursorPosition() const; virtual voidGetDate(Int_t& year, Int_t& month, Int_t& day) const; static FontStruct_tTGTextEntry::GetDefaultFontStruct",MatchSource.WIKI,root/html528/TGNumberEntryField.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGNumberEntryField.html
https://root.cern/root/html528/TGNumberEntryField.html:7676,Availability,error,error,7676,"bject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTGTextEntry::End(Bool_t mark = kFALSE); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; ETextJustificationTGTextEntry::GetAlignment() const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGTextBuffer*TGTextEntry::GetBuffer() const; virtual Int_tGetCharWidth(const char* text = ""0"") const; TGClient*TGObject::GetClient() const; const char*TGWidget::GetCommand() const; static Int_tTGWindow::GetCounter(); Int_tTGTextEntry::GetCursorPosition() const; virtual voidGetDate(Int_t& year, Int_t& month, Int_t& day) const; static FontStruct_tTGTextEntry::GetDefaultFontStruct(); static Pixel_tTGFrame::GetDefaultFrameBackground(); static const TGGC&TGTextEntr",MatchSource.WIKI,root/html528/TGNumberEntryField.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGNumberEntryField.html
https://root.cern/root/html528/TGNumberEntryField.html:24849,Availability,mask,mask,24849,"thframe border width; TGClient*TGObject::fClientConnection to display server; Atom_tTGTextEntry::fClipboardclipboard property; TStringTGWidget::fCommandcommand to be executed; TBlinkTimer*TGTextEntry::fCurBlinkcursor blink timer; Int_tTGTextEntry::fCursorIXcursor position in characters; Bool_tTGTextEntry::fCursorOncursor status (on/off); Int_tTGTextEntry::fCursorXcursor position in pixels; Int_tTGFrame::fDNDStateEDNDFlags; UInt_tTGTextEntry::fDefHeightdefault height; UInt_tTGTextEntry::fDefWidthdefault width; TGTextEntry::EEchoModeTGTextEntry::fEchoMode*OPTION={GetMethod=""GetEchoMode"";SetMethod=""SetEchoMode"";Items=(kNormal=""Normal"",kNoEcho=""No Echo"",kPassword=""Password"")}*; UInt_tTGWindow::fEditDisabledflags used for ""guibuilding""; Bool_tTGTextEntry::fEditedkFALSE, if the line edit's contents have not been changed since the construction; Int_tTGTextEntry::fEndIXselection end in characters; Int_tTGTextEntry::fEndXselection end in pixels; UInt_tTGFrame::fEventMaskcurrenty active event mask; TGFrameElement*TGFrame::fFEpointer to frame element; FontStruct_tTGTextEntry::fFontStructtext font; Bool_tTGTextEntry::fFrameDrawnkTRUE draw itself inside a two-pixel frame, kFALSE draw without any frame; Bool_tTGTextEntry::fHasOwnFontkTRUE - font defined locally, kFALSE - globally; UInt_tTGFrame::fHeightframe height; Handle_tTGObject::fIdX11/Win32 Window identifier; TGTextEntry::EInsertModeTGTextEntry::fInsertMode*OPTION={GetMethod=""GetInsertMode"";SetMethod=""SetInsertMode"";Items=(kInsert=""Insert"",kReplace=""Replace"")}*; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; UInt_tTGFrame::fMaxHeightmaximal frame height; Int_tTGTextEntry::fMaxLenmaximum length of text; UInt_tTGFrame::fMaxWidthmaximal frame width; UInt_tTGFrame::fMinHeightminimal frame height; UInt_tTGFrame::fMinWidthminimal frame width; const TGWindow*TGWidget::fMsgWindowwindow which handles widget events; TStringTGWindow::fNamename of",MatchSource.WIKI,root/html528/TGNumberEntryField.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGNumberEntryField.html
https://root.cern/root/html528/TGNumberEntryField.html:30359,Integrability,message,message,30359,"epresentation). Long_t GetIntNumber() const; Get the numeric value (integer representation). void GetTime(Int_t& hour, Int_t& min, Int_t& sec) const; Get the numeric value (time format). void GetDate(Int_t& year, Int_t& month, Int_t& day) const; Get the numeric value (date format). ULong_t GetHexNumber() const; Get the numeric value (hex format). Int_t GetCharWidth(const char* text = ""0"") const; Get the text width in pixels. void IncreaseNumber(TGNumberFormat::EStepSize step = kNSSSmall, Int_t sign = 1, Bool_t logstep = kFALSE); Increase the number value. void SetFormat(TGNumberFormat::EStyle style, TGNumberFormat::EAttribute attr = kNEAAnyNumber); Set the numerical format. void SetLimits(TGNumberFormat::ELimit limits = kNELNoLimits, Double_t min = 0, Double_t max = 1); Set the numerical limits. void SetState(Bool_t state); Set the active state. Bool_t HandleKey(Event_t* event); Handle keys. Bool_t HandleFocusChange(Event_t* event); Handle focus change. void TextChanged(const char* text = 0); Text has changed message. void ReturnPressed(); Return was pressed. void Layout(); Layout. void SavePrimitive(ostream& out, Option_t* = """"); Save a number entry widget as a C++ statement(s) on output stream out. void SetLogStep(Bool_t on = kTRUE); Set logarithmic steps. EStyle GetNumStyle() const; Get the numerical style. EAttribute GetNumAttr() const; Get the numerical attribute. ELimit GetNumLimits() const; Get the numerialc limit attribute. Double_t GetNumMin() const; Get the lower limit. Double_t GetNumMax() const; Get the upper limit. Bool_t IsLogStep() const; Is log step enabled?. Bool_t IsEditable() const; { return kFALSE; }. void InvalidInput(const char* instr); { Emit(""InvalidInput(char*)"", instr); }. » Author: Daniel Sigg 03/09/2001 » Copyright (C) 1995-2001, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id: TGNumberEntry.h 25233 2008-08-25 16:48:47Z bellenot $ » Last generated: 2010-09-23 20:07; This page has been automatically generated. For comments o",MatchSource.WIKI,root/html528/TGNumberEntryField.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGNumberEntryField.html
https://root.cern/root/html528/TGNumberEntryField.html:2436,Testability,log,logarithmic,2436," kNESDayMYear: date in day/month/year format; kNESMDayYear: date in month/day/year format; kNESHex: hex number. The following attributes can be specified:; kNEAAnyNumber: any number is allowed; kNEANonNegative: only non-negative numbers are allowed; kNEAPositive: only positive numbers are allowed. Explicit limits can be specified individually:; kNELNoLimits: no limits; kNELLimitMin: lower limit only; kNELLimitMax upper limit only; kNELLimitMinMax both lower and upper limits. TGNumberEntryField is a plain vanilla entry field, whereas; TGNumberEntry adds two small buttons to increase and decrease the; numerical value in the field. The number entry widgets also support; using the up and down cursor keys to change the numerical values.; The step size can be selected with control and shift keys:; -- small step (1 unit/factor of 3); shift medium step (10 units/factor of 10); control large step (100 units/factor of 30); shift-control huge step (1000 units/factor of 100). The steps are either linear or logarithmic. The default behaviour; is set when the entry field is created, but it can be changed by; pressing the alt key at the same time. Changing the number in the widget will generate the event:; kC_TEXTENTRY, kTE_TEXTCHANGED, widget id, 0.; Hitting the enter key will generate:; kC_TEXTENTRY, kTE_ENTER, widget id, 0.; Hitting the tab key will generate:; kC_TEXTENTRY, kTE_TAB, widget id, 0. /*. */. Function Members (Methods); public:. TGNumberEntryField(const TGWindow* p, Int_t id, Double_t val, GContext_t norm, FontStruct_t font = GetDefaultFontStruct(), UInt_t option = kSunkenFrame|kDoubleBorder, Pixel_t back = GetWhitePixel()); TGNumberEntryField(const TGWindow* parent = 0, Int_t id = -1, Double_t val = 0, TGNumberFormat::EStyle style = kNESReal, TGNumberFormat::EAttribute attr = kNEAAnyNumber, TGNumberFormat::ELimit limits = kNELNoLimits, Double_t min = 0, Double_t max = 1); ~TGNumberEntryField(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFr",MatchSource.WIKI,root/html528/TGNumberEntryField.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGNumberEntryField.html
https://root.cern/root/html528/TGNumberEntryField.html:13206,Testability,log,logstep,13206,"nt); virtual Bool_tTGWindow::HandleExpose(Event_t* event); virtual Bool_tHandleFocusChange(Event_t* event); virtual Bool_tTGWindow::HandleIdleEvent(TGIdleHandler*); virtual Bool_tHandleKey(Event_t* event); virtual Bool_tTGTextEntry::HandleMotion(Event_t* event); virtual Bool_tTGTextEntry::HandleSelection(Event_t* event); virtual Bool_tTGTextEntry::HandleSelectionClear(Event_t* event); virtual Bool_tTGTextEntry::HandleSelectionRequest(Event_t* event); virtual Bool_tTGTextEntry::HandleTimer(TTimer* t); virtual Bool_tTQObject::HasConnection(const char* signal_name) const; Bool_tTGWidget::HasFocus() const; virtual ULong_tTGObject::Hash() const; Bool_tTGTextEntry::HasMarkedText() const; Bool_tTGTextEntry::HasOwnFont() const; virtual voidTQObject::HighPriority(const char* signal_name, const char* slot_name = 0); voidTGTextEntry::Home(Bool_t mark = kFALSE); virtual voidTGWindow::IconifyWindow(); virtual voidIncreaseNumber(TGNumberFormat::EStepSize step = kNSSSmall, Int_t sign = 1, Bool_t logstep = kFALSE); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTGTextEntry::Insert(const char*); virtual voidTGTextEntry::InsertText(const char* text, Int_t pos); virtual voidTGFrame::Inspect() const; virtual voidInvalidInput(const char* instr)SIGNAL ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTGFrame::IsActive() const; virtual Bool_tTGFrame::IsComposite() const; Bool_tTGFrame::IsDNDSource() const; Bool_tTGFrame::IsDNDTarget() const; virtual Bool_tIsEditable() const; Bool_tTGTextEntry::IsEdited() const; Bool_tTGWidget::IsEnabled() const; virtual Bool_tTGObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTGTextEntry::IsFrameDrawn() const; virtual Bool_tTGFrame::IsLayoutBroken() const; virtual Bool_tIsLogStep() const; virtual Bool_tTGWindow::IsMapped(); v",MatchSource.WIKI,root/html528/TGNumberEntryField.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGNumberEntryField.html
https://root.cern/root/html528/TGNumberEntryField.html:29850,Testability,log,logstep,29850,"alue (floating point representation). void SetIntNumber(Long_t val); Set the numeric value (integer representation). void SetTime(Int_t hour, Int_t min, Int_t sec); Set the numeric value (time format). void SetDate(Int_t year, Int_t month, Int_t day); Set the numeric value (date format). void SetHexNumber(ULong_t val); Set the numeric value (hex format). void SetText(const char* text, Bool_t emit = kTRUE); Set the value (text format). Double_t GetNumber() const; Get the numeric value (floating point representation). Long_t GetIntNumber() const; Get the numeric value (integer representation). void GetTime(Int_t& hour, Int_t& min, Int_t& sec) const; Get the numeric value (time format). void GetDate(Int_t& year, Int_t& month, Int_t& day) const; Get the numeric value (date format). ULong_t GetHexNumber() const; Get the numeric value (hex format). Int_t GetCharWidth(const char* text = ""0"") const; Get the text width in pixels. void IncreaseNumber(TGNumberFormat::EStepSize step = kNSSSmall, Int_t sign = 1, Bool_t logstep = kFALSE); Increase the number value. void SetFormat(TGNumberFormat::EStyle style, TGNumberFormat::EAttribute attr = kNEAAnyNumber); Set the numerical format. void SetLimits(TGNumberFormat::ELimit limits = kNELNoLimits, Double_t min = 0, Double_t max = 1); Set the numerical limits. void SetState(Bool_t state); Set the active state. Bool_t HandleKey(Event_t* event); Handle keys. Bool_t HandleFocusChange(Event_t* event); Handle focus change. void TextChanged(const char* text = 0); Text has changed message. void ReturnPressed(); Return was pressed. void Layout(); Layout. void SavePrimitive(ostream& out, Option_t* = """"); Save a number entry widget as a C++ statement(s) on output stream out. void SetLogStep(Bool_t on = kTRUE); Set logarithmic steps. EStyle GetNumStyle() const; Get the numerical style. EAttribute GetNumAttr() const; Get the numerical attribute. ELimit GetNumLimits() const; Get the numerialc limit attribute. Double_t GetNumMin() const; Get the low",MatchSource.WIKI,root/html528/TGNumberEntryField.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGNumberEntryField.html
https://root.cern/root/html528/TGNumberEntryField.html:30594,Testability,log,logarithmic,30594," GetTime(Int_t& hour, Int_t& min, Int_t& sec) const; Get the numeric value (time format). void GetDate(Int_t& year, Int_t& month, Int_t& day) const; Get the numeric value (date format). ULong_t GetHexNumber() const; Get the numeric value (hex format). Int_t GetCharWidth(const char* text = ""0"") const; Get the text width in pixels. void IncreaseNumber(TGNumberFormat::EStepSize step = kNSSSmall, Int_t sign = 1, Bool_t logstep = kFALSE); Increase the number value. void SetFormat(TGNumberFormat::EStyle style, TGNumberFormat::EAttribute attr = kNEAAnyNumber); Set the numerical format. void SetLimits(TGNumberFormat::ELimit limits = kNELNoLimits, Double_t min = 0, Double_t max = 1); Set the numerical limits. void SetState(Bool_t state); Set the active state. Bool_t HandleKey(Event_t* event); Handle keys. Bool_t HandleFocusChange(Event_t* event); Handle focus change. void TextChanged(const char* text = 0); Text has changed message. void ReturnPressed(); Return was pressed. void Layout(); Layout. void SavePrimitive(ostream& out, Option_t* = """"); Save a number entry widget as a C++ statement(s) on output stream out. void SetLogStep(Bool_t on = kTRUE); Set logarithmic steps. EStyle GetNumStyle() const; Get the numerical style. EAttribute GetNumAttr() const; Get the numerical attribute. ELimit GetNumLimits() const; Get the numerialc limit attribute. Double_t GetNumMin() const; Get the lower limit. Double_t GetNumMax() const; Get the upper limit. Bool_t IsLogStep() const; Is log step enabled?. Bool_t IsEditable() const; { return kFALSE; }. void InvalidInput(const char* instr); { Emit(""InvalidInput(char*)"", instr); }. » Author: Daniel Sigg 03/09/2001 » Copyright (C) 1995-2001, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id: TGNumberEntry.h 25233 2008-08-25 16:48:47Z bellenot $ » Last generated: 2010-09-23 20:07; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html528/TGNumberEntryField.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGNumberEntryField.html
https://root.cern/root/html528/TGNumberEntryField.html:30917,Testability,log,log,30917," GetTime(Int_t& hour, Int_t& min, Int_t& sec) const; Get the numeric value (time format). void GetDate(Int_t& year, Int_t& month, Int_t& day) const; Get the numeric value (date format). ULong_t GetHexNumber() const; Get the numeric value (hex format). Int_t GetCharWidth(const char* text = ""0"") const; Get the text width in pixels. void IncreaseNumber(TGNumberFormat::EStepSize step = kNSSSmall, Int_t sign = 1, Bool_t logstep = kFALSE); Increase the number value. void SetFormat(TGNumberFormat::EStyle style, TGNumberFormat::EAttribute attr = kNEAAnyNumber); Set the numerical format. void SetLimits(TGNumberFormat::ELimit limits = kNELNoLimits, Double_t min = 0, Double_t max = 1); Set the numerical limits. void SetState(Bool_t state); Set the active state. Bool_t HandleKey(Event_t* event); Handle keys. Bool_t HandleFocusChange(Event_t* event); Handle focus change. void TextChanged(const char* text = 0); Text has changed message. void ReturnPressed(); Return was pressed. void Layout(); Layout. void SavePrimitive(ostream& out, Option_t* = """"); Save a number entry widget as a C++ statement(s) on output stream out. void SetLogStep(Bool_t on = kTRUE); Set logarithmic steps. EStyle GetNumStyle() const; Get the numerical style. EAttribute GetNumAttr() const; Get the numerical attribute. ELimit GetNumLimits() const; Get the numerialc limit attribute. Double_t GetNumMin() const; Get the lower limit. Double_t GetNumMax() const; Get the upper limit. Bool_t IsLogStep() const; Is log step enabled?. Bool_t IsEditable() const; { return kFALSE; }. void InvalidInput(const char* instr); { Emit(""InvalidInput(char*)"", instr); }. » Author: Daniel Sigg 03/09/2001 » Copyright (C) 1995-2001, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id: TGNumberEntry.h 25233 2008-08-25 16:48:47Z bellenot $ » Last generated: 2010-09-23 20:07; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html528/TGNumberEntryField.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGNumberEntryField.html
https://root.cern/root/html528/TGNumberEntryLayout.html:431,Availability,down,down,431,". TGNumberEntryLayout. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGNumberEntryLayout. class TGNumberEntryLayout: public TGLayoutManager. TGNumberEntry, TGNumberEntryField and TGNumberFormat. TGNumberEntry is a number entry input widget with up/down buttons.; TGNumberEntryField is a number entry input widget.; TGNumberFormat contains enum types to specify the numeric format. The number entry widget is based on TGTextEntry but allows only; numerical input. The widget support numerous formats including; integers, hex numbers, real numbers, fixed fraction reals and; time/date formats. The widget also allows to restrict input values; to non-negative or positive numbers and to specify explicit limits. The following styles are supported:; kNESInteger: integer number; kNESRealOne: real number with one digit (no exponent); kNESRealTwo: real number with two digits (no exponent); kNESRealThree: real number with three digits (no exponent); kNESRealFour: real number with four digits (no exponent); kNESReal: arbitrary real number; kNESDegree: angle in degree:minutes:seconds format; kNESMinSec: time in minutes:seconds format; kNESHourMin: time in hour:minutes format; kNESHourMinSec: time in hour:minutes:seconds format; kNESDayMYear: date in day/month/year format; kNESMDayYear: date in month/day/year format; kNESHex: hex number. The following attributes can be specified:; kNEAAnyNumber: any number is allowed; kNEANonNegative: only non-negative numbers are allowed; kNEAPositive: only positive numbers are allowed. Explicit limits can be specified individually:; kNELNoLimits: no limits; kNELLimitMin: lower limit only; kNELLimitMax upper limit only; kNELLimitMinMax both lower and upper limits. TGNumberEntryField is a plain vanilla entry field, whereas; TGNumberEntry adds two small buttons to increase an",MatchSource.WIKI,root/html528/TGNumberEntryLayout.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGNumberEntryLayout.html
https://root.cern/root/html528/TGNumberEntryLayout.html:2103,Availability,down,down,2103,"th three digits (no exponent); kNESRealFour: real number with four digits (no exponent); kNESReal: arbitrary real number; kNESDegree: angle in degree:minutes:seconds format; kNESMinSec: time in minutes:seconds format; kNESHourMin: time in hour:minutes format; kNESHourMinSec: time in hour:minutes:seconds format; kNESDayMYear: date in day/month/year format; kNESMDayYear: date in month/day/year format; kNESHex: hex number. The following attributes can be specified:; kNEAAnyNumber: any number is allowed; kNEANonNegative: only non-negative numbers are allowed; kNEAPositive: only positive numbers are allowed. Explicit limits can be specified individually:; kNELNoLimits: no limits; kNELLimitMin: lower limit only; kNELLimitMax upper limit only; kNELLimitMinMax both lower and upper limits. TGNumberEntryField is a plain vanilla entry field, whereas; TGNumberEntry adds two small buttons to increase and decrease the; numerical value in the field. The number entry widgets also support; using the up and down cursor keys to change the numerical values.; The step size can be selected with control and shift keys:; -- small step (1 unit/factor of 3); shift medium step (10 units/factor of 10); control large step (100 units/factor of 30); shift-control huge step (1000 units/factor of 100). The steps are either linear or logarithmic. The default behaviour; is set when the entry field is created, but it can be changed by; pressing the alt key at the same time. Changing the number in the widget will generate the event:; kC_TEXTENTRY, kTE_TEXTCHANGED, widget id, 0.; Hitting the enter key will generate:; kC_TEXTENTRY, kTE_ENTER, widget id, 0.; Hitting the tab key will generate:; kC_TEXTENTRY, kTE_TAB, widget id, 0. /*. */. Function Members (Methods); public:. TGNumberEntryLayout(TGNumberEntry* box); ~TGNumberEntryLayout(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class",MatchSource.WIKI,root/html528/TGNumberEntryLayout.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGNumberEntryLayout.html
https://root.cern/root/html528/TGNumberEntryLayout.html:3840,Availability,error,error,3840,,MatchSource.WIKI,root/html528/TGNumberEntryLayout.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGNumberEntryLayout.html
https://root.cern/root/html528/TGNumberEntryLayout.html:3924,Availability,error,error,3924," voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TGDimensionGetDefaultSize() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(c",MatchSource.WIKI,root/html528/TGNumberEntryLayout.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGNumberEntryLayout.html
https://root.cern/root/html528/TGNumberEntryLayout.html:2420,Testability,log,logarithmic,2420," kNESDayMYear: date in day/month/year format; kNESMDayYear: date in month/day/year format; kNESHex: hex number. The following attributes can be specified:; kNEAAnyNumber: any number is allowed; kNEANonNegative: only non-negative numbers are allowed; kNEAPositive: only positive numbers are allowed. Explicit limits can be specified individually:; kNELNoLimits: no limits; kNELLimitMin: lower limit only; kNELLimitMax upper limit only; kNELLimitMinMax both lower and upper limits. TGNumberEntryField is a plain vanilla entry field, whereas; TGNumberEntry adds two small buttons to increase and decrease the; numerical value in the field. The number entry widgets also support; using the up and down cursor keys to change the numerical values.; The step size can be selected with control and shift keys:; -- small step (1 unit/factor of 3); shift medium step (10 units/factor of 10); control large step (100 units/factor of 30); shift-control huge step (1000 units/factor of 100). The steps are either linear or logarithmic. The default behaviour; is set when the entry field is created, but it can be changed by; pressing the alt key at the same time. Changing the number in the widget will generate the event:; kC_TEXTENTRY, kTE_TEXTCHANGED, widget id, 0.; Hitting the enter key will generate:; kC_TEXTENTRY, kTE_ENTER, widget id, 0.; Hitting the tab key will generate:; kC_TEXTENTRY, kTE_TAB, widget id, 0. /*. */. Function Members (Methods); public:. TGNumberEntryLayout(TGNumberEntry* box); ~TGNumberEntryLayout(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option ",MatchSource.WIKI,root/html528/TGNumberEntryLayout.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGNumberEntryLayout.html
https://root.cern/root/html528/TGNumberFormat.html:392,Availability,down,down,392,". TGNumberFormat. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGNumberFormat. class TGNumberFormat. TGNumberEntry, TGNumberEntryField and TGNumberFormat. TGNumberEntry is a number entry input widget with up/down buttons.; TGNumberEntryField is a number entry input widget.; TGNumberFormat contains enum types to specify the numeric format. The number entry widget is based on TGTextEntry but allows only; numerical input. The widget support numerous formats including; integers, hex numbers, real numbers, fixed fraction reals and; time/date formats. The widget also allows to restrict input values; to non-negative or positive numbers and to specify explicit limits. The following styles are supported:; kNESInteger: integer number; kNESRealOne: real number with one digit (no exponent); kNESRealTwo: real number with two digits (no exponent); kNESRealThree: real number with three digits (no exponent); kNESRealFour: real number with four digits (no exponent); kNESReal: arbitrary real number; kNESDegree: angle in degree:minutes:seconds format; kNESMinSec: time in minutes:seconds format; kNESHourMin: time in hour:minutes format; kNESHourMinSec: time in hour:minutes:seconds format; kNESDayMYear: date in day/month/year format; kNESMDayYear: date in month/day/year format; kNESHex: hex number. The following attributes can be specified:; kNEAAnyNumber: any number is allowed; kNEANonNegative: only non-negative numbers are allowed; kNEAPositive: only positive numbers are allowed. Explicit limits can be specified individually:; kNELNoLimits: no limits; kNELLimitMin: lower limit only; kNELLimitMax upper limit only; kNELLimitMinMax both lower and upper limits. TGNumberEntryField is a plain vanilla entry field, whereas; TGNumberEntry adds two small buttons to increase and decrease the; numerical value in the ",MatchSource.WIKI,root/html528/TGNumberFormat.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGNumberFormat.html
https://root.cern/root/html528/TGNumberFormat.html:2064,Availability,down,down,2064,"th three digits (no exponent); kNESRealFour: real number with four digits (no exponent); kNESReal: arbitrary real number; kNESDegree: angle in degree:minutes:seconds format; kNESMinSec: time in minutes:seconds format; kNESHourMin: time in hour:minutes format; kNESHourMinSec: time in hour:minutes:seconds format; kNESDayMYear: date in day/month/year format; kNESMDayYear: date in month/day/year format; kNESHex: hex number. The following attributes can be specified:; kNEAAnyNumber: any number is allowed; kNEANonNegative: only non-negative numbers are allowed; kNEAPositive: only positive numbers are allowed. Explicit limits can be specified individually:; kNELNoLimits: no limits; kNELLimitMin: lower limit only; kNELLimitMax upper limit only; kNELLimitMinMax both lower and upper limits. TGNumberEntryField is a plain vanilla entry field, whereas; TGNumberEntry adds two small buttons to increase and decrease the; numerical value in the field. The number entry widgets also support; using the up and down cursor keys to change the numerical values.; The step size can be selected with control and shift keys:; -- small step (1 unit/factor of 3); shift medium step (10 units/factor of 10); control large step (100 units/factor of 30); shift-control huge step (1000 units/factor of 100). The steps are either linear or logarithmic. The default behaviour; is set when the entry field is created, but it can be changed by; pressing the alt key at the same time. Changing the number in the widget will generate the event:; kC_TEXTENTRY, kTE_TEXTCHANGED, widget id, 0.; Hitting the enter key will generate:; kC_TEXTENTRY, kTE_ENTER, widget id, 0.; Hitting the tab key will generate:; kC_TEXTENTRY, kTE_TAB, widget id, 0. /*. */. Function Members (Methods); public:. TGNumberFormat(); TGNumberFormat(const TGNumberFormat&); virtual~TGNumberFormat(); static TClass*Class(); virtual TClass*IsA() const; TGNumberFormat&operator=(const TGNumberFormat&); virtual voidShowMembers(TMemberInspector& insp); virt",MatchSource.WIKI,root/html528/TGNumberFormat.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGNumberFormat.html
https://root.cern/root/html528/TGNumberFormat.html:2381,Testability,log,logarithmic,2381," kNESDayMYear: date in day/month/year format; kNESMDayYear: date in month/day/year format; kNESHex: hex number. The following attributes can be specified:; kNEAAnyNumber: any number is allowed; kNEANonNegative: only non-negative numbers are allowed; kNEAPositive: only positive numbers are allowed. Explicit limits can be specified individually:; kNELNoLimits: no limits; kNELLimitMin: lower limit only; kNELLimitMax upper limit only; kNELLimitMinMax both lower and upper limits. TGNumberEntryField is a plain vanilla entry field, whereas; TGNumberEntry adds two small buttons to increase and decrease the; numerical value in the field. The number entry widgets also support; using the up and down cursor keys to change the numerical values.; The step size can be selected with control and shift keys:; -- small step (1 unit/factor of 3); shift medium step (10 units/factor of 10); control large step (100 units/factor of 30); shift-control huge step (1000 units/factor of 100). The steps are either linear or logarithmic. The default behaviour; is set when the entry field is created, but it can be changed by; pressing the alt key at the same time. Changing the number in the widget will generate the event:; kC_TEXTENTRY, kTE_TEXTCHANGED, widget id, 0.; Hitting the enter key will generate:; kC_TEXTENTRY, kTE_ENTER, widget id, 0.; Hitting the tab key will generate:; kC_TEXTENTRY, kTE_TAB, widget id, 0. /*. */. Function Members (Methods); public:. TGNumberFormat(); TGNumberFormat(const TGNumberFormat&); virtual~TGNumberFormat(); static TClass*Class(); virtual TClass*IsA() const; TGNumberFormat&operator=(const TGNumberFormat&); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Data Members; public:. enum EStyle { kNESInteger; kNESRealOne; kNESRealTwo; kNESRealThree; kNESRealFour; kNESReal; kNESDegree; kNESMinSec; kNESHourMin; kNESHourMinSec; kNESDayMYear; kNESMDayYear; kNESHex; };; enum EAttribute { kNEAAnyNumber; kNEAN",MatchSource.WIKI,root/html528/TGNumberFormat.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TGNumberFormat.html
