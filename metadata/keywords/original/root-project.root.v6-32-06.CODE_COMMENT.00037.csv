id,quality_attribute,keyword,matched_word,match_idx,sentence,source,filename,author,repo,version,wiki,url
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp:15,Availability,mask,mask,15,// Fill in the mask bit derived from the shift constant.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp:304,Usability,clear,clear,304,"/// Match patterns that correspond to ""any-bits-set"" and ""all-bits-set"".; /// These will include a chain of 'or' or 'and'-shifted bits from a; /// common source value:; /// and (or (lshr X, C), ...), 1 --> (X & CMask) != 0; /// and (and (lshr X, C), ...), 1 --> (X & CMask) == CMask; /// Note: ""any-bits-clear"" and ""all-bits-clear"" are variations of these patterns; /// that differ only with a final 'not' of the result. We expect that final; /// 'not' to be folded with the compare that we create here (invert predicate).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp:325,Usability,clear,clear,325,"/// Match patterns that correspond to ""any-bits-set"" and ""all-bits-set"".; /// These will include a chain of 'or' or 'and'-shifted bits from a; /// common source value:; /// and (or (lshr X, C), ...), 1 --> (X & CMask) != 0; /// and (and (lshr X, C), ...), 1 --> (X & CMask) == CMask; /// Note: ""any-bits-clear"" and ""all-bits-clear"" are variations of these patterns; /// that differ only with a final 'not' of the result. We expect that final; /// 'not' to be folded with the compare that we create here (invert predicate).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp:46,Usability,simpl,simpler,46,"// The 'any-bits-set' ('or' chain) pattern is simpler to match because the; // final ""and X, 1"" instruction must be the final op in the sequence.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp:35,Availability,mask,masked,35,// The pattern was found. Create a masked compare that replaces all of the; // shift and logic ops.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp:89,Testability,log,logic,89,// The pattern was found. Create a masked compare that replaces all of the; // shift and logic ops.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp:72,Safety,avoid,avoids,72,/// Try to replace a mathlib call to sqrt with the LLVM intrinsic. This avoids; /// pessimistic codegen that has to account for setting errno and can enable; /// vectorization.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp:295,Safety,safe,safe,295,"// If (1) this is a sqrt libcall, (2) we can assume that NAN is not created; // (because NNAN or the operand arg must not be less than -0.0) and (2) we; // would not end up lowering to a libcall anyway (which could change the value; // of errno), then:; // (1) errno won't be set.; // (2) it is safe to convert this to an intrinsic call.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp:101,Security,access,accessed,101,"// Check if \p Element matches a concrete answer. It could fail for some; // elements that are never accessed, so we keep iterating over each element; // from the table. The number of matched elements should be equal to the; // number of potential right answers which is \p InputBits actually.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp:822,Performance,load,load,822,"// Try to recognize table-based ctz implementation.; // E.g., an example in C (for more cases please see the llvm/tests):; // int f(unsigned x) {; // static const char table[32] =; // {0, 1, 28, 2, 29, 14, 24, 3, 30,; // 22, 20, 15, 25, 17, 4, 8, 31, 27,; // 13, 23, 21, 19, 16, 7, 26, 12, 18, 6, 11, 5, 10, 9};; // return table[((unsigned)((x & -x) * 0x077CB531U)) >> 27];; // }; // this can be lowered to `cttz` instruction.; // There is also a special case when the element is 0.; //; // Here are some examples or LLVM IR for a 64-bit target:; //; // CASE 1:; // %sub = sub i32 0, %x; // %and = and i32 %sub, %x; // %mul = mul i32 %and, 125613361; // %shr = lshr i32 %mul, 27; // %idxprom = zext i32 %shr to i64; // %arrayidx = getelementptr inbounds [32 x i8], [32 x i8]* @ctz1.table, i64 0,; // i64 %idxprom; // %0 = load i8, i8* %arrayidx, align 1, !tbaa !8; //; // CASE 2:; // %sub = sub i32 0, %x; // %and = and i32 %sub, %x; // %mul = mul i32 %and, 72416175; // %shr = lshr i32 %mul, 26; // %idxprom = zext i32 %shr to i64; // %arrayidx = getelementptr inbounds [64 x i16], [64 x i16]* @ctz2.table,; // i64 0, i64 %idxprom; // %0 = load i16, i16* %arrayidx, align 2, !tbaa !8; //; // CASE 3:; // %sub = sub i32 0, %x; // %and = and i32 %sub, %x; // %mul = mul i32 %and, 81224991; // %shr = lshr i32 %mul, 27; // %idxprom = zext i32 %shr to i64; // %arrayidx = getelementptr inbounds [32 x i32], [32 x i32]* @ctz3.table,; // i64 0, i64 %idxprom; // %0 = load i32, i32* %arrayidx, align 4, !tbaa !8; //; // CASE 4:; // %sub = sub i64 0, %x; // %and = and i64 %sub, %x; // %mul = mul i64 %and, 283881067100198605; // %shr = lshr i64 %mul, 58; // %arrayidx = getelementptr inbounds [64 x i8], [64 x i8]* @table, i64 0,; // i64 %shr; // %0 = load i8, i8* %arrayidx, align 1, !tbaa !8; //; // All this can be lowered to @llvm.cttz.i32/64 intrinsic.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp:1141,Performance,load,load,1141,"// Try to recognize table-based ctz implementation.; // E.g., an example in C (for more cases please see the llvm/tests):; // int f(unsigned x) {; // static const char table[32] =; // {0, 1, 28, 2, 29, 14, 24, 3, 30,; // 22, 20, 15, 25, 17, 4, 8, 31, 27,; // 13, 23, 21, 19, 16, 7, 26, 12, 18, 6, 11, 5, 10, 9};; // return table[((unsigned)((x & -x) * 0x077CB531U)) >> 27];; // }; // this can be lowered to `cttz` instruction.; // There is also a special case when the element is 0.; //; // Here are some examples or LLVM IR for a 64-bit target:; //; // CASE 1:; // %sub = sub i32 0, %x; // %and = and i32 %sub, %x; // %mul = mul i32 %and, 125613361; // %shr = lshr i32 %mul, 27; // %idxprom = zext i32 %shr to i64; // %arrayidx = getelementptr inbounds [32 x i8], [32 x i8]* @ctz1.table, i64 0,; // i64 %idxprom; // %0 = load i8, i8* %arrayidx, align 1, !tbaa !8; //; // CASE 2:; // %sub = sub i32 0, %x; // %and = and i32 %sub, %x; // %mul = mul i32 %and, 72416175; // %shr = lshr i32 %mul, 26; // %idxprom = zext i32 %shr to i64; // %arrayidx = getelementptr inbounds [64 x i16], [64 x i16]* @ctz2.table,; // i64 0, i64 %idxprom; // %0 = load i16, i16* %arrayidx, align 2, !tbaa !8; //; // CASE 3:; // %sub = sub i32 0, %x; // %and = and i32 %sub, %x; // %mul = mul i32 %and, 81224991; // %shr = lshr i32 %mul, 27; // %idxprom = zext i32 %shr to i64; // %arrayidx = getelementptr inbounds [32 x i32], [32 x i32]* @ctz3.table,; // i64 0, i64 %idxprom; // %0 = load i32, i32* %arrayidx, align 4, !tbaa !8; //; // CASE 4:; // %sub = sub i64 0, %x; // %and = and i64 %sub, %x; // %mul = mul i64 %and, 283881067100198605; // %shr = lshr i64 %mul, 58; // %arrayidx = getelementptr inbounds [64 x i8], [64 x i8]* @table, i64 0,; // i64 %shr; // %0 = load i8, i8* %arrayidx, align 1, !tbaa !8; //; // All this can be lowered to @llvm.cttz.i32/64 intrinsic.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp:1462,Performance,load,load,1462,"// Try to recognize table-based ctz implementation.; // E.g., an example in C (for more cases please see the llvm/tests):; // int f(unsigned x) {; // static const char table[32] =; // {0, 1, 28, 2, 29, 14, 24, 3, 30,; // 22, 20, 15, 25, 17, 4, 8, 31, 27,; // 13, 23, 21, 19, 16, 7, 26, 12, 18, 6, 11, 5, 10, 9};; // return table[((unsigned)((x & -x) * 0x077CB531U)) >> 27];; // }; // this can be lowered to `cttz` instruction.; // There is also a special case when the element is 0.; //; // Here are some examples or LLVM IR for a 64-bit target:; //; // CASE 1:; // %sub = sub i32 0, %x; // %and = and i32 %sub, %x; // %mul = mul i32 %and, 125613361; // %shr = lshr i32 %mul, 27; // %idxprom = zext i32 %shr to i64; // %arrayidx = getelementptr inbounds [32 x i8], [32 x i8]* @ctz1.table, i64 0,; // i64 %idxprom; // %0 = load i8, i8* %arrayidx, align 1, !tbaa !8; //; // CASE 2:; // %sub = sub i32 0, %x; // %and = and i32 %sub, %x; // %mul = mul i32 %and, 72416175; // %shr = lshr i32 %mul, 26; // %idxprom = zext i32 %shr to i64; // %arrayidx = getelementptr inbounds [64 x i16], [64 x i16]* @ctz2.table,; // i64 0, i64 %idxprom; // %0 = load i16, i16* %arrayidx, align 2, !tbaa !8; //; // CASE 3:; // %sub = sub i32 0, %x; // %and = and i32 %sub, %x; // %mul = mul i32 %and, 81224991; // %shr = lshr i32 %mul, 27; // %idxprom = zext i32 %shr to i64; // %arrayidx = getelementptr inbounds [32 x i32], [32 x i32]* @ctz3.table,; // i64 0, i64 %idxprom; // %0 = load i32, i32* %arrayidx, align 4, !tbaa !8; //; // CASE 4:; // %sub = sub i64 0, %x; // %and = and i64 %sub, %x; // %mul = mul i64 %and, 283881067100198605; // %shr = lshr i64 %mul, 58; // %arrayidx = getelementptr inbounds [64 x i8], [64 x i8]* @table, i64 0,; // i64 %shr; // %0 = load i8, i8* %arrayidx, align 1, !tbaa !8; //; // All this can be lowered to @llvm.cttz.i32/64 intrinsic.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp:1746,Performance,load,load,1746,"// Try to recognize table-based ctz implementation.; // E.g., an example in C (for more cases please see the llvm/tests):; // int f(unsigned x) {; // static const char table[32] =; // {0, 1, 28, 2, 29, 14, 24, 3, 30,; // 22, 20, 15, 25, 17, 4, 8, 31, 27,; // 13, 23, 21, 19, 16, 7, 26, 12, 18, 6, 11, 5, 10, 9};; // return table[((unsigned)((x & -x) * 0x077CB531U)) >> 27];; // }; // this can be lowered to `cttz` instruction.; // There is also a special case when the element is 0.; //; // Here are some examples or LLVM IR for a 64-bit target:; //; // CASE 1:; // %sub = sub i32 0, %x; // %and = and i32 %sub, %x; // %mul = mul i32 %and, 125613361; // %shr = lshr i32 %mul, 27; // %idxprom = zext i32 %shr to i64; // %arrayidx = getelementptr inbounds [32 x i8], [32 x i8]* @ctz1.table, i64 0,; // i64 %idxprom; // %0 = load i8, i8* %arrayidx, align 1, !tbaa !8; //; // CASE 2:; // %sub = sub i32 0, %x; // %and = and i32 %sub, %x; // %mul = mul i32 %and, 72416175; // %shr = lshr i32 %mul, 26; // %idxprom = zext i32 %shr to i64; // %arrayidx = getelementptr inbounds [64 x i16], [64 x i16]* @ctz2.table,; // i64 0, i64 %idxprom; // %0 = load i16, i16* %arrayidx, align 2, !tbaa !8; //; // CASE 3:; // %sub = sub i32 0, %x; // %and = and i32 %sub, %x; // %mul = mul i32 %and, 81224991; // %shr = lshr i32 %mul, 27; // %idxprom = zext i32 %shr to i64; // %arrayidx = getelementptr inbounds [32 x i32], [32 x i32]* @ctz3.table,; // i64 0, i64 %idxprom; // %0 = load i32, i32* %arrayidx, align 4, !tbaa !8; //; // CASE 4:; // %sub = sub i64 0, %x; // %and = and i64 %sub, %x; // %mul = mul i64 %and, 283881067100198605; // %shr = lshr i64 %mul, 58; // %arrayidx = getelementptr inbounds [64 x i8], [64 x i8]* @table, i64 0,; // i64 %shr; // %0 = load i8, i8* %arrayidx, align 1, !tbaa !8; //; // All this can be lowered to @llvm.cttz.i32/64 intrinsic.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp:114,Testability,test,tests,114,"// Try to recognize table-based ctz implementation.; // E.g., an example in C (for more cases please see the llvm/tests):; // int f(unsigned x) {; // static const char table[32] =; // {0, 1, 28, 2, 29, 14, 24, 3, 30,; // 22, 20, 15, 25, 17, 4, 8, 31, 27,; // 13, 23, 21, 19, 16, 7, 26, 12, 18, 6, 11, 5, 10, 9};; // return table[((unsigned)((x & -x) * 0x077CB531U)) >> 27];; // }; // this can be lowered to `cttz` instruction.; // There is also a special case when the element is 0.; //; // Here are some examples or LLVM IR for a 64-bit target:; //; // CASE 1:; // %sub = sub i32 0, %x; // %and = and i32 %sub, %x; // %mul = mul i32 %and, 125613361; // %shr = lshr i32 %mul, 27; // %idxprom = zext i32 %shr to i64; // %arrayidx = getelementptr inbounds [32 x i8], [32 x i8]* @ctz1.table, i64 0,; // i64 %idxprom; // %0 = load i8, i8* %arrayidx, align 1, !tbaa !8; //; // CASE 2:; // %sub = sub i32 0, %x; // %and = and i32 %sub, %x; // %mul = mul i32 %and, 72416175; // %shr = lshr i32 %mul, 26; // %idxprom = zext i32 %shr to i64; // %arrayidx = getelementptr inbounds [64 x i16], [64 x i16]* @ctz2.table,; // i64 0, i64 %idxprom; // %0 = load i16, i16* %arrayidx, align 2, !tbaa !8; //; // CASE 3:; // %sub = sub i32 0, %x; // %and = and i32 %sub, %x; // %mul = mul i32 %and, 81224991; // %shr = lshr i32 %mul, 27; // %idxprom = zext i32 %shr to i64; // %arrayidx = getelementptr inbounds [32 x i32], [32 x i32]* @ctz3.table,; // i64 0, i64 %idxprom; // %0 = load i32, i32* %arrayidx, align 4, !tbaa !8; //; // CASE 4:; // %sub = sub i64 0, %x; // %and = and i64 %sub, %x; // %mul = mul i64 %and, 283881067100198605; // %shr = lshr i64 %mul, 58; // %arrayidx = getelementptr inbounds [64 x i8], [64 x i8]* @table, i64 0,; // i64 %shr; // %0 = load i8, i8* %arrayidx, align 1, !tbaa !8; //; // All this can be lowered to @llvm.cttz.i32/64 intrinsic.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp:184,Modifiability,extend,extend,184,"/// This is used by foldLoadsRecursive() to capture a Root Load node which is; /// of type or(load, load) and recursively build the wide load. Also capture the; /// shift amount, zero extend type and loadSize.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp:59,Performance,Load,Load,59,"/// This is used by foldLoadsRecursive() to capture a Root Load node which is; /// of type or(load, load) and recursively build the wide load. Also capture the; /// shift amount, zero extend type and loadSize.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp:94,Performance,load,load,94,"/// This is used by foldLoadsRecursive() to capture a Root Load node which is; /// of type or(load, load) and recursively build the wide load. Also capture the; /// shift amount, zero extend type and loadSize.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp:100,Performance,load,load,100,"/// This is used by foldLoadsRecursive() to capture a Root Load node which is; /// of type or(load, load) and recursively build the wide load. Also capture the; /// shift amount, zero extend type and loadSize.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp:137,Performance,load,load,137,"/// This is used by foldLoadsRecursive() to capture a Root Load node which is; /// of type or(load, load) and recursively build the wide load. Also capture the; /// shift amount, zero extend type and loadSize.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp:200,Performance,load,loadSize,200,"/// This is used by foldLoadsRecursive() to capture a Root Load node which is; /// of type or(load, load) and recursively build the wide load. Also capture the; /// shift amount, zero extend type and loadSize.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp:34,Performance,load,loads,34,// Identify and Merge consecutive loads recursively which is of the form; // (ZExt(L1) << shift1) | (ZExt(L2) << shift2) -> ZExt(L3) << shift1; // (ZExt(L1) << shift1) | ZExt(L2) -> ZExt(L3),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp:28,Performance,load,loads,28,// Go to the last node with loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp:3,Safety,Avoid,Avoid,3,// Avoid Partial chain merge.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp:28,Performance,load,loads,28,// Check if the pattern has loads,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp:12,Performance,load,loads,12,"// Check if loads are same, atomic, volatile and having same address space.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp:12,Performance,Load,Loads,12,// Check if Loads come from same BB.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp:12,Performance,load,loads,12,// Check if loads are consecutive and same size.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp:18,Performance,load,loads,18,// Verify if both loads have same base pointers and load sizes are same.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp:52,Performance,load,load,52,// Verify if both loads have same base pointers and load sizes are same.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp:56,Energy Efficiency,power,power,56,// Support Loadsizes greater or equal to 8bits and only power of 2.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp:11,Performance,Load,Loadsizes,11,// Support Loadsizes greater or equal to 8bits and only power of 2.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp:46,Performance,load,loads,46,// Alias Analysis to check for stores b/w the loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp:13,Performance,Load,Load,13,// Make sure Load with lower Offset is at LI1,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp:93,Availability,avail,available,93,// First load is always LI1. This is where we put the new load.; // Use the merged load size available from LI1 for forward loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp:9,Performance,load,load,9,// First load is always LI1. This is where we put the new load.; // Use the merged load size available from LI1 for forward loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp:58,Performance,load,load,58,// First load is always LI1. This is where we put the new load.; // Use the merged load size available from LI1 for forward loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp:83,Performance,load,load,83,// First load is always LI1. This is where we put the new load.; // Use the merged load size available from LI1 for forward loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp:124,Performance,load,loads,124,// First load is always LI1. This is where we put the new load.; // Use the merged load size available from LI1 for forward loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp:30,Performance,load,load,30,// Verify if shift amount and load index aligns and verifies that loads; // are consecutive.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp:66,Performance,load,loads,66,// Verify if shift amount and load index aligns and verifies that loads; // are consecutive.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp:3,Deployability,Update,Update,3,// Update LOps,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp:40,Performance,Load,Loads,40,// Concatenate the AATags of the Merged Loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp:44,Performance,load,loads,44,"// For a given BB instruction, evaluate all loads in the chain that form a; // pattern which suggests that the loads can be combined. The one and only use; // of the loads is to form a wider load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp:111,Performance,load,loads,111,"// For a given BB instruction, evaluate all loads in the chain that form a; // pattern which suggests that the loads can be combined. The one and only use; // of the loads is to form a wider load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp:166,Performance,load,loads,166,"// For a given BB instruction, evaluate all loads in the chain that form a; // pattern which suggests that the loads can be combined. The one and only use; // of the loads is to form a wider load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp:191,Performance,load,load,191,"// For a given BB instruction, evaluate all loads in the chain that form a; // pattern which suggests that the loads can be combined. The one and only use; // of the loads is to form a wider load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp:17,Performance,load,load,17,// Only consider load chains of scalar values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp:53,Performance,load,load,53,// TTI based checks if we want to proceed with wider load,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp:18,Performance,load,load,18,// Generate wider load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp:15,Performance,Load,Load,15,// Set the New Load AATags Metadata.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp:17,Modifiability,extend,extend,17,// Check if zero extend needed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp:15,Energy Efficiency,power,power,15,// Only keep a power of two factor for non-inbounds,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp:48,Modifiability,Variab,Variable,48,"// Check whether pointer arrives back at Global Variable via at least one GEP.; // Even if it doesn't, we can check by alignment.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp:53,Performance,load,loaded,53,"/// If C is a constant patterned array and all valid loaded results for given; /// alignment are same to a constant, return that constant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp:24,Performance,load,load,24,// We can only fold the load if it is from a constant global with definitive; // initializer. Skip expensive logic if this is not the case.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp:109,Testability,log,logic,109,// We can only fold the load if it is from a constant global with definitive; // initializer. Skip expensive logic if this is not the case.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp:50,Safety,avoid,avoid,50,// Bail for large initializers in excess of 4K to avoid too many scans.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp:96,Performance,load,load,96,"// Any possible offset could be multiple of GEP stride. And any valid; // offset is multiple of load alignment, so checking only multiples of bigger; // one is sufficient to say results' equality.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp:227,Energy Efficiency,efficient,efficient,227,"// Walk the block backwards for efficiency. We're matching a chain of; // use->defs, so we're more likely to succeed by starting from the bottom.; // Also, we want to avoid matching partial patterns.; // TODO: It would be more efficient if we removed dead instructions; // iteratively in this loop rather than waiting until the end.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp:167,Safety,avoid,avoid,167,"// Walk the block backwards for efficiency. We're matching a chain of; // use->defs, so we're more likely to succeed by starting from the bottom.; // Also, we want to avoid matching partial patterns.; // TODO: It would be more efficient if we removed dead instructions; // iteratively in this loop rather than waiting until the end.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp:42,Deployability,update,updates,42,// Mark all the analyses that instcombine updates as preserved.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombineInternal.h:214,Energy Efficiency,reduce,reduced,214,"//===----------------------------------------------------------------------===//; // TruncInstCombine - looks for expression graphs dominated by trunc; // instructions and for each eligible graph, it will create a reduced bit-width; // expression and replace the old expression with this new one and remove the; // old one. Eligible expression graph is such that:; // 1. Contains only supported instructions.; // 2. Supported leaves: ZExtInst, SExtInst, TruncInst and Constant value.; // 3. Can be evaluated into type with reduced legal bit-width (or Trunc type).; // 4. All instructions in the graph must not have users outside the graph.; // Only exception is for {ZExt, SExt}Inst with operand type equal to the; // new reduced type chosen in (3).; //; // The motivation for this optimization is that evaluating and expression using; // smaller bit-width is preferable, especially for vectorization where we can; // fit more values in one vectorized instruction. In addition, this optimization; // may decrease the number of cast instructions, but will not increase it.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombineInternal.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombineInternal.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombineInternal.h:523,Energy Efficiency,reduce,reduced,523,"//===----------------------------------------------------------------------===//; // TruncInstCombine - looks for expression graphs dominated by trunc; // instructions and for each eligible graph, it will create a reduced bit-width; // expression and replace the old expression with this new one and remove the; // old one. Eligible expression graph is such that:; // 1. Contains only supported instructions.; // 2. Supported leaves: ZExtInst, SExtInst, TruncInst and Constant value.; // 3. Can be evaluated into type with reduced legal bit-width (or Trunc type).; // 4. All instructions in the graph must not have users outside the graph.; // Only exception is for {ZExt, SExt}Inst with operand type equal to the; // new reduced type chosen in (3).; //; // The motivation for this optimization is that evaluating and expression using; // smaller bit-width is preferable, especially for vectorization where we can; // fit more values in one vectorized instruction. In addition, this optimization; // may decrease the number of cast instructions, but will not increase it.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombineInternal.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombineInternal.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombineInternal.h:722,Energy Efficiency,reduce,reduced,722,"//===----------------------------------------------------------------------===//; // TruncInstCombine - looks for expression graphs dominated by trunc; // instructions and for each eligible graph, it will create a reduced bit-width; // expression and replace the old expression with this new one and remove the; // old one. Eligible expression graph is such that:; // 1. Contains only supported instructions.; // 2. Supported leaves: ZExtInst, SExtInst, TruncInst and Constant value.; // 3. Can be evaluated into type with reduced legal bit-width (or Trunc type).; // 4. All instructions in the graph must not have users outside the graph.; // Only exception is for {ZExt, SExt}Inst with operand type equal to the; // new reduced type chosen in (3).; //; // The motivation for this optimization is that evaluating and expression using; // smaller bit-width is preferable, especially for vectorization where we can; // fit more values in one vectorized instruction. In addition, this optimization; // may decrease the number of cast instructions, but will not increase it.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombineInternal.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombineInternal.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombineInternal.h:782,Performance,optimiz,optimization,782,"//===----------------------------------------------------------------------===//; // TruncInstCombine - looks for expression graphs dominated by trunc; // instructions and for each eligible graph, it will create a reduced bit-width; // expression and replace the old expression with this new one and remove the; // old one. Eligible expression graph is such that:; // 1. Contains only supported instructions.; // 2. Supported leaves: ZExtInst, SExtInst, TruncInst and Constant value.; // 3. Can be evaluated into type with reduced legal bit-width (or Trunc type).; // 4. All instructions in the graph must not have users outside the graph.; // Only exception is for {ZExt, SExt}Inst with operand type equal to the; // new reduced type chosen in (3).; //; // The motivation for this optimization is that evaluating and expression using; // smaller bit-width is preferable, especially for vectorization where we can; // fit more values in one vectorized instruction. In addition, this optimization; // may decrease the number of cast instructions, but will not increase it.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombineInternal.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombineInternal.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombineInternal.h:983,Performance,optimiz,optimization,983,"//===----------------------------------------------------------------------===//; // TruncInstCombine - looks for expression graphs dominated by trunc; // instructions and for each eligible graph, it will create a reduced bit-width; // expression and replace the old expression with this new one and remove the; // old one. Eligible expression graph is such that:; // 1. Contains only supported instructions.; // 2. Supported leaves: ZExtInst, SExtInst, TruncInst and Constant value.; // 3. Can be evaluated into type with reduced legal bit-width (or Trunc type).; // 4. All instructions in the graph must not have users outside the graph.; // Only exception is for {ZExt, SExt}Inst with operand type equal to the; // new reduced type chosen in (3).; //; // The motivation for this optimization is that evaluating and expression using; // smaller bit-width is preferable, especially for vectorization where we can; // fit more values in one vectorized instruction. In addition, this optimization; // may decrease the number of cast instructions, but will not increase it.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombineInternal.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombineInternal.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombineInternal.h:8,Energy Efficiency,reduce,reduced,8,/// The reduced value generated to replace the old instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombineInternal.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombineInternal.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombineInternal.h:4,Performance,Perform,Perform,4,/// Perform TruncInst pattern optimization on given function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombineInternal.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombineInternal.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombineInternal.h:30,Performance,optimiz,optimization,30,/// Perform TruncInst pattern optimization on given function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombineInternal.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombineInternal.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombineInternal.h:114,Energy Efficiency,reduce,reduced,114,"/// Build an expression graph dominated by the current processed TruncInst and; /// Check if it is eligible to be reduced to a smaller type.; ///; /// \return the scalar version of the new type to be used for the reduced; /// expression graph, or nullptr if the expression graph is not; /// eligible to be reduced.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombineInternal.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombineInternal.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombineInternal.h:213,Energy Efficiency,reduce,reduced,213,"/// Build an expression graph dominated by the current processed TruncInst and; /// Check if it is eligible to be reduced to a smaller type.; ///; /// \return the scalar version of the new type to be used for the reduced; /// expression graph, or nullptr if the expression graph is not; /// eligible to be reduced.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombineInternal.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombineInternal.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombineInternal.h:306,Energy Efficiency,reduce,reduced,306,"/// Build an expression graph dominated by the current processed TruncInst and; /// Check if it is eligible to be reduced to a smaller type.; ///; /// \return the scalar version of the new type to be used for the reduced; /// expression graph, or nullptr if the expression graph is not; /// eligible to be reduced.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombineInternal.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombineInternal.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombineInternal.h:71,Energy Efficiency,reduce,reduced,71,/// Given a \p V value and a \p SclTy scalar type return the generated reduced; /// value of \p V based on the type \p SclTy.; ///; /// \param V value to be reduced.; /// \param SclTy scalar version of new type to reduce to.; /// \return the new reduced value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombineInternal.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombineInternal.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombineInternal.h:157,Energy Efficiency,reduce,reduced,157,/// Given a \p V value and a \p SclTy scalar type return the generated reduced; /// value of \p V based on the type \p SclTy.; ///; /// \param V value to be reduced.; /// \param SclTy scalar version of new type to reduce to.; /// \return the new reduced value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombineInternal.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombineInternal.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombineInternal.h:214,Energy Efficiency,reduce,reduce,214,/// Given a \p V value and a \p SclTy scalar type return the generated reduced; /// value of \p V based on the type \p SclTy.; ///; /// \param V value to be reduced.; /// \param SclTy scalar version of new type to reduce to.; /// \return the new reduced value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombineInternal.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombineInternal.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombineInternal.h:246,Energy Efficiency,reduce,reduced,246,/// Given a \p V value and a \p SclTy scalar type return the generated reduced; /// value of \p V based on the type \p SclTy.; ///; /// \param V value to be reduced.; /// \param SclTy scalar version of new type to reduce to.; /// \return the new reduced value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombineInternal.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombineInternal.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombineInternal.h:44,Energy Efficiency,reduce,reduced,44,"/// Create a new expression graph using the reduced /p SclTy type and replace; /// the old expression graph with it. Also erase all instructions in the old; /// graph, except those that are still needed outside the graph.; ///; /// \param SclTy scalar version of new type to reduce expression graph into.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombineInternal.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombineInternal.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombineInternal.h:275,Energy Efficiency,reduce,reduce,275,"/// Create a new expression graph using the reduced /p SclTy type and replace; /// the old expression graph with it. Also erase all instructions in the old; /// graph, except those that are still needed outside the graph.; ///; /// \param SclTy scalar version of new type to reduce expression graph into.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombineInternal.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombineInternal.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/TruncInstCombine.cpp:508,Energy Efficiency,reduce,reduced,508,"//===- TruncInstCombine.cpp -----------------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // TruncInstCombine - looks for expression graphs post-dominated by TruncInst; // and for each eligible graph, it will create a reduced bit-width expression,; // replace the old expression with this new one and remove the old expression.; // Eligible expression graph is such that:; // 1. Contains only supported instructions.; // 2. Supported leaves: ZExtInst, SExtInst, TruncInst and Constant value.; // 3. Can be evaluated into type with reduced legal bit-width.; // 4. All instructions in the graph must not have users outside the graph.; // The only exception is for {ZExt, SExt}Inst with operand type equal to; // the new reduced type evaluated in (3).; //; // The motivation for this optimization is that evaluating and expression using; // smaller bit-width is preferable, especially for vectorization where we can; // fit more values in one vectorized instruction. In addition, this optimization; // may decrease the number of cast instructions, but will not increase it.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/TruncInstCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/TruncInstCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/TruncInstCombine.cpp:821,Energy Efficiency,reduce,reduced,821,"//===- TruncInstCombine.cpp -----------------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // TruncInstCombine - looks for expression graphs post-dominated by TruncInst; // and for each eligible graph, it will create a reduced bit-width expression,; // replace the old expression with this new one and remove the old expression.; // Eligible expression graph is such that:; // 1. Contains only supported instructions.; // 2. Supported leaves: ZExtInst, SExtInst, TruncInst and Constant value.; // 3. Can be evaluated into type with reduced legal bit-width.; // 4. All instructions in the graph must not have users outside the graph.; // The only exception is for {ZExt, SExt}Inst with operand type equal to; // the new reduced type evaluated in (3).; //; // The motivation for this optimization is that evaluating and expression using; // smaller bit-width is preferable, especially for vectorization where we can; // fit more values in one vectorized instruction. In addition, this optimization; // may decrease the number of cast instructions, but will not increase it.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/TruncInstCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/TruncInstCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/TruncInstCombine.cpp:1008,Energy Efficiency,reduce,reduced,1008,"//===- TruncInstCombine.cpp -----------------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // TruncInstCombine - looks for expression graphs post-dominated by TruncInst; // and for each eligible graph, it will create a reduced bit-width expression,; // replace the old expression with this new one and remove the old expression.; // Eligible expression graph is such that:; // 1. Contains only supported instructions.; // 2. Supported leaves: ZExtInst, SExtInst, TruncInst and Constant value.; // 3. Can be evaluated into type with reduced legal bit-width.; // 4. All instructions in the graph must not have users outside the graph.; // The only exception is for {ZExt, SExt}Inst with operand type equal to; // the new reduced type evaluated in (3).; //; // The motivation for this optimization is that evaluating and expression using; // smaller bit-width is preferable, especially for vectorization where we can; // fit more values in one vectorized instruction. In addition, this optimization; // may decrease the number of cast instructions, but will not increase it.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/TruncInstCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/TruncInstCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/TruncInstCombine.cpp:1071,Performance,optimiz,optimization,1071,"//===- TruncInstCombine.cpp -----------------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // TruncInstCombine - looks for expression graphs post-dominated by TruncInst; // and for each eligible graph, it will create a reduced bit-width expression,; // replace the old expression with this new one and remove the old expression.; // Eligible expression graph is such that:; // 1. Contains only supported instructions.; // 2. Supported leaves: ZExtInst, SExtInst, TruncInst and Constant value.; // 3. Can be evaluated into type with reduced legal bit-width.; // 4. All instructions in the graph must not have users outside the graph.; // The only exception is for {ZExt, SExt}Inst with operand type equal to; // the new reduced type evaluated in (3).; //; // The motivation for this optimization is that evaluating and expression using; // smaller bit-width is preferable, especially for vectorization where we can; // fit more values in one vectorized instruction. In addition, this optimization; // may decrease the number of cast instructions, but will not increase it.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/TruncInstCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/TruncInstCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/TruncInstCombine.cpp:1272,Performance,optimiz,optimization,1272,"//===- TruncInstCombine.cpp -----------------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // TruncInstCombine - looks for expression graphs post-dominated by TruncInst; // and for each eligible graph, it will create a reduced bit-width expression,; // replace the old expression with this new one and remove the old expression.; // Eligible expression graph is such that:; // 1. Contains only supported instructions.; // 2. Supported leaves: ZExtInst, SExtInst, TruncInst and Constant value.; // 3. Can be evaluated into type with reduced legal bit-width.; // 4. All instructions in the graph must not have users outside the graph.; // The only exception is for {ZExt, SExt}Inst with operand type equal to; // the new reduced type evaluated in (3).; //; // The motivation for this optimization is that evaluating and expression using; // smaller bit-width is preferable, especially for vectorization where we can; // fit more values in one vectorized instruction. In addition, this optimization; // may decrease the number of cast instructions, but will not increase it.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/TruncInstCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/TruncInstCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/TruncInstCombine.cpp:146,Performance,optimiz,optimizaton,146,"/// Given an instruction and a container, it fills all the relevant operands of; /// that instruction, with respect to the Trunc expression graph optimizaton.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/TruncInstCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/TruncInstCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/TruncInstCombine.cpp:3,Usability,Clear,Clear,3,// Clear old instructions info.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/TruncInstCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/TruncInstCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/TruncInstCombine.cpp:106,Deployability,update,update,106,"// Already handled all instruction operands, can remove it from both, the; // Worklist and the Stack, and update MinBitWidth.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/TruncInstCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/TruncInstCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/TruncInstCombine.cpp:3,Deployability,Update,Update,3,// Update minimum bit-width before handling its operands. This is required; // when the instruction is part of a loop.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/TruncInstCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/TruncInstCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/TruncInstCombine.cpp:3,Deployability,Update,Update,3,"// Update minimum bit-width with the new destination type bit-width if; // succeeded to find such, otherwise, with original bit-width.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/TruncInstCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/TruncInstCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/TruncInstCombine.cpp:195,Performance,perform,perform,195,"// MinBitWidth == TruncBitWidth; // In this case the expression can be evaluated with the trunc instruction; // destination type, and trunc instruction can be omitted. However, we; // should not perform the evaluation if the original type is a legal scalar; // type and the target type is illegal.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/TruncInstCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/TruncInstCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/TruncInstCombine.cpp:109,Deployability,update,update,109,"// If this is an extension from the dest type, we can eliminate it,; // even if it has multiple users. Thus, update the DesiredBitWidth and; // validate all extension instructions agrees on same DesiredBitWidth.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/TruncInstCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/TruncInstCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/TruncInstCombine.cpp:144,Security,validat,validate,144,"// If this is an extension from the dest type, we can eliminate it,; // even if it has multiple users. Thus, update the DesiredBitWidth and; // validate all extension instructions agrees on same DesiredBitWidth.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/TruncInstCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/TruncInstCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/TruncInstCombine.cpp:12,Energy Efficiency,reduce,reduced,12,"/// Given a reduced scalar type \p Ty and a \p V value, return a reduced type; /// for \p V, according to its type, if it vector type, return the vector; /// version of \p Ty, otherwise return \p Ty.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/TruncInstCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/TruncInstCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/TruncInstCombine.cpp:65,Energy Efficiency,reduce,reduced,65,"/// Given a reduced scalar type \p Ty and a \p V value, return a reduced type; /// for \p V, according to its type, if it vector type, return the vector; /// version of \p Ty, otherwise return \p Ty.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/TruncInstCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/TruncInstCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/TruncInstCombine.cpp:41,Usability,simpl,simplify,41,"// If we got a constantexpr back, try to simplify it with DL info.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/TruncInstCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/TruncInstCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/TruncInstCombine.cpp:3,Deployability,Update,Update,3,// Update Worklist entries with new value if needed.; // There are three possible changes to the Worklist:; // 1. Update Old-TruncInst -> New-TruncInst.; // 2. Remove Old-TruncInst (if New node is not TruncInst).; // 3. Add New-TruncInst (if Old node was not TruncInst).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/TruncInstCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/TruncInstCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/TruncInstCombine.cpp:114,Deployability,Update,Update,114,// Update Worklist entries with new value if needed.; // There are three possible changes to the Worklist:; // 1. Update Old-TruncInst -> New-TruncInst.; // 2. Remove Old-TruncInst (if New node is not TruncInst).; // 3. Add New-TruncInst (if Old node was not TruncInst).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/TruncInstCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/TruncInstCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/TruncInstCombine.cpp:57,Energy Efficiency,reduce,reduced,57,"// Erase old expression graph, which was replaced by the reduced expression; // graph.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/TruncInstCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/TruncInstCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/TruncInstCombine.cpp:161,Energy Efficiency,reduce,reduced,161,"// We still need to check that the instruction has no users before we erase; // it, because {SExt, ZExt}Inst Instruction might have other users that was; // not reduced, in such case, we need to keep that instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/TruncInstCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/TruncInstCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/TruncInstCombine.cpp:128,Energy Efficiency,reduce,reduced,128,"// Process all TruncInst in the Worklist, for each instruction:; // 1. Check if it dominates an eligible expression graph to be reduced.; // 2. Create a reduced expression graph and replace the old one with it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/TruncInstCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/TruncInstCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/TruncInstCombine.cpp:153,Energy Efficiency,reduce,reduced,153,"// Process all TruncInst in the Worklist, for each instruction:; // 1. Check if it dominates an eligible expression graph to be reduced.; // 2. Create a reduced expression graph and replace the old one with it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/TruncInstCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/TruncInstCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/CFGuard/CFGuard.cpp:618,Availability,error,error,618,"/// Inserts a Control Flow Guard (CFG) check on an indirect call using the CFG; /// check mechanism. When the image is loaded, the loader puts the appropriate; /// guard check function pointer in the __guard_check_icall_fptr global; /// symbol. This checks that the target address is a valid address-taken; /// function. The address of the target function is passed to the guard check; /// function in an architecture-specific register (e.g. ECX on 32-bit X86,; /// X15 on Aarch64, and R0 on ARM). The guard check function has no return; /// value (if the target is invalid, the guard check funtion will raise an; /// error).; ///; /// For example, the following LLVM IR:; /// \code; /// %func_ptr = alloca i32 ()*, align 8; /// store i32 ()* @target_func, i32 ()** %func_ptr, align 8; /// %0 = load i32 ()*, i32 ()** %func_ptr, align 8; /// %1 = call i32 %0(); /// \endcode; ///; /// is transformed to:; /// \code; /// %func_ptr = alloca i32 ()*, align 8; /// store i32 ()* @target_func, i32 ()** %func_ptr, align 8; /// %0 = load i32 ()*, i32 ()** %func_ptr, align 8; /// %1 = load void (i8*)*, void (i8*)** @__guard_check_icall_fptr; /// %2 = bitcast i32 ()* %0 to i8*; /// call cfguard_checkcc void %1(i8* %2); /// %3 = call i32 %0(); /// \endcode; ///; /// For example, the following X86 assembly code:; /// \code; /// movl $_target_func, %eax; /// calll *%eax; /// \endcode; ///; /// is transformed to:; /// \code; /// 	movl	$_target_func, %ecx; /// 	calll	*___guard_check_icall_fptr; /// 	calll	*%ecx; /// \endcode; ///; /// \param CB indirect call to instrument.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/CFGuard/CFGuard.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/CFGuard/CFGuard.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/CFGuard/CFGuard.cpp:119,Performance,load,loaded,119,"/// Inserts a Control Flow Guard (CFG) check on an indirect call using the CFG; /// check mechanism. When the image is loaded, the loader puts the appropriate; /// guard check function pointer in the __guard_check_icall_fptr global; /// symbol. This checks that the target address is a valid address-taken; /// function. The address of the target function is passed to the guard check; /// function in an architecture-specific register (e.g. ECX on 32-bit X86,; /// X15 on Aarch64, and R0 on ARM). The guard check function has no return; /// value (if the target is invalid, the guard check funtion will raise an; /// error).; ///; /// For example, the following LLVM IR:; /// \code; /// %func_ptr = alloca i32 ()*, align 8; /// store i32 ()* @target_func, i32 ()** %func_ptr, align 8; /// %0 = load i32 ()*, i32 ()** %func_ptr, align 8; /// %1 = call i32 %0(); /// \endcode; ///; /// is transformed to:; /// \code; /// %func_ptr = alloca i32 ()*, align 8; /// store i32 ()* @target_func, i32 ()** %func_ptr, align 8; /// %0 = load i32 ()*, i32 ()** %func_ptr, align 8; /// %1 = load void (i8*)*, void (i8*)** @__guard_check_icall_fptr; /// %2 = bitcast i32 ()* %0 to i8*; /// call cfguard_checkcc void %1(i8* %2); /// %3 = call i32 %0(); /// \endcode; ///; /// For example, the following X86 assembly code:; /// \code; /// movl $_target_func, %eax; /// calll *%eax; /// \endcode; ///; /// is transformed to:; /// \code; /// 	movl	$_target_func, %ecx; /// 	calll	*___guard_check_icall_fptr; /// 	calll	*%ecx; /// \endcode; ///; /// \param CB indirect call to instrument.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/CFGuard/CFGuard.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/CFGuard/CFGuard.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/CFGuard/CFGuard.cpp:131,Performance,load,loader,131,"/// Inserts a Control Flow Guard (CFG) check on an indirect call using the CFG; /// check mechanism. When the image is loaded, the loader puts the appropriate; /// guard check function pointer in the __guard_check_icall_fptr global; /// symbol. This checks that the target address is a valid address-taken; /// function. The address of the target function is passed to the guard check; /// function in an architecture-specific register (e.g. ECX on 32-bit X86,; /// X15 on Aarch64, and R0 on ARM). The guard check function has no return; /// value (if the target is invalid, the guard check funtion will raise an; /// error).; ///; /// For example, the following LLVM IR:; /// \code; /// %func_ptr = alloca i32 ()*, align 8; /// store i32 ()* @target_func, i32 ()** %func_ptr, align 8; /// %0 = load i32 ()*, i32 ()** %func_ptr, align 8; /// %1 = call i32 %0(); /// \endcode; ///; /// is transformed to:; /// \code; /// %func_ptr = alloca i32 ()*, align 8; /// store i32 ()* @target_func, i32 ()** %func_ptr, align 8; /// %0 = load i32 ()*, i32 ()** %func_ptr, align 8; /// %1 = load void (i8*)*, void (i8*)** @__guard_check_icall_fptr; /// %2 = bitcast i32 ()* %0 to i8*; /// call cfguard_checkcc void %1(i8* %2); /// %3 = call i32 %0(); /// \endcode; ///; /// For example, the following X86 assembly code:; /// \code; /// movl $_target_func, %eax; /// calll *%eax; /// \endcode; ///; /// is transformed to:; /// \code; /// 	movl	$_target_func, %ecx; /// 	calll	*___guard_check_icall_fptr; /// 	calll	*%ecx; /// \endcode; ///; /// \param CB indirect call to instrument.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/CFGuard/CFGuard.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/CFGuard/CFGuard.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/CFGuard/CFGuard.cpp:795,Performance,load,load,795,"/// Inserts a Control Flow Guard (CFG) check on an indirect call using the CFG; /// check mechanism. When the image is loaded, the loader puts the appropriate; /// guard check function pointer in the __guard_check_icall_fptr global; /// symbol. This checks that the target address is a valid address-taken; /// function. The address of the target function is passed to the guard check; /// function in an architecture-specific register (e.g. ECX on 32-bit X86,; /// X15 on Aarch64, and R0 on ARM). The guard check function has no return; /// value (if the target is invalid, the guard check funtion will raise an; /// error).; ///; /// For example, the following LLVM IR:; /// \code; /// %func_ptr = alloca i32 ()*, align 8; /// store i32 ()* @target_func, i32 ()** %func_ptr, align 8; /// %0 = load i32 ()*, i32 ()** %func_ptr, align 8; /// %1 = call i32 %0(); /// \endcode; ///; /// is transformed to:; /// \code; /// %func_ptr = alloca i32 ()*, align 8; /// store i32 ()* @target_func, i32 ()** %func_ptr, align 8; /// %0 = load i32 ()*, i32 ()** %func_ptr, align 8; /// %1 = load void (i8*)*, void (i8*)** @__guard_check_icall_fptr; /// %2 = bitcast i32 ()* %0 to i8*; /// call cfguard_checkcc void %1(i8* %2); /// %3 = call i32 %0(); /// \endcode; ///; /// For example, the following X86 assembly code:; /// \code; /// movl $_target_func, %eax; /// calll *%eax; /// \endcode; ///; /// is transformed to:; /// \code; /// 	movl	$_target_func, %ecx; /// 	calll	*___guard_check_icall_fptr; /// 	calll	*%ecx; /// \endcode; ///; /// \param CB indirect call to instrument.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/CFGuard/CFGuard.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/CFGuard/CFGuard.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/CFGuard/CFGuard.cpp:1027,Performance,load,load,1027,"/// Inserts a Control Flow Guard (CFG) check on an indirect call using the CFG; /// check mechanism. When the image is loaded, the loader puts the appropriate; /// guard check function pointer in the __guard_check_icall_fptr global; /// symbol. This checks that the target address is a valid address-taken; /// function. The address of the target function is passed to the guard check; /// function in an architecture-specific register (e.g. ECX on 32-bit X86,; /// X15 on Aarch64, and R0 on ARM). The guard check function has no return; /// value (if the target is invalid, the guard check funtion will raise an; /// error).; ///; /// For example, the following LLVM IR:; /// \code; /// %func_ptr = alloca i32 ()*, align 8; /// store i32 ()* @target_func, i32 ()** %func_ptr, align 8; /// %0 = load i32 ()*, i32 ()** %func_ptr, align 8; /// %1 = call i32 %0(); /// \endcode; ///; /// is transformed to:; /// \code; /// %func_ptr = alloca i32 ()*, align 8; /// store i32 ()* @target_func, i32 ()** %func_ptr, align 8; /// %0 = load i32 ()*, i32 ()** %func_ptr, align 8; /// %1 = load void (i8*)*, void (i8*)** @__guard_check_icall_fptr; /// %2 = bitcast i32 ()* %0 to i8*; /// call cfguard_checkcc void %1(i8* %2); /// %3 = call i32 %0(); /// \endcode; ///; /// For example, the following X86 assembly code:; /// \code; /// movl $_target_func, %eax; /// calll *%eax; /// \endcode; ///; /// is transformed to:; /// \code; /// 	movl	$_target_func, %ecx; /// 	calll	*___guard_check_icall_fptr; /// 	calll	*%ecx; /// \endcode; ///; /// \param CB indirect call to instrument.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/CFGuard/CFGuard.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/CFGuard/CFGuard.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/CFGuard/CFGuard.cpp:1079,Performance,load,load,1079,"/// Inserts a Control Flow Guard (CFG) check on an indirect call using the CFG; /// check mechanism. When the image is loaded, the loader puts the appropriate; /// guard check function pointer in the __guard_check_icall_fptr global; /// symbol. This checks that the target address is a valid address-taken; /// function. The address of the target function is passed to the guard check; /// function in an architecture-specific register (e.g. ECX on 32-bit X86,; /// X15 on Aarch64, and R0 on ARM). The guard check function has no return; /// value (if the target is invalid, the guard check funtion will raise an; /// error).; ///; /// For example, the following LLVM IR:; /// \code; /// %func_ptr = alloca i32 ()*, align 8; /// store i32 ()* @target_func, i32 ()** %func_ptr, align 8; /// %0 = load i32 ()*, i32 ()** %func_ptr, align 8; /// %1 = call i32 %0(); /// \endcode; ///; /// is transformed to:; /// \code; /// %func_ptr = alloca i32 ()*, align 8; /// store i32 ()* @target_func, i32 ()** %func_ptr, align 8; /// %0 = load i32 ()*, i32 ()** %func_ptr, align 8; /// %1 = load void (i8*)*, void (i8*)** @__guard_check_icall_fptr; /// %2 = bitcast i32 ()* %0 to i8*; /// call cfguard_checkcc void %1(i8* %2); /// %3 = call i32 %0(); /// \endcode; ///; /// For example, the following X86 assembly code:; /// \code; /// movl $_target_func, %eax; /// calll *%eax; /// \endcode; ///; /// is transformed to:; /// \code; /// 	movl	$_target_func, %ecx; /// 	calll	*___guard_check_icall_fptr; /// 	calll	*%ecx; /// \endcode; ///; /// \param CB indirect call to instrument.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/CFGuard/CFGuard.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/CFGuard/CFGuard.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/CFGuard/CFGuard.cpp:122,Performance,load,loaded,122,"/// Inserts a Control Flow Guard (CFG) check on an indirect call using the CFG; /// dispatch mechanism. When the image is loaded, the loader puts the; /// appropriate guard check function pointer in the; /// __guard_dispatch_icall_fptr global symbol. This checks that the target; /// address is a valid address-taken function and, if so, tail calls the; /// target. The target address is passed in an architecture-specific register; /// (e.g. RAX on X86_64), with all other arguments for the target function; /// passed as usual.; ///; /// For example, the following LLVM IR:; /// \code; /// %func_ptr = alloca i32 ()*, align 8; /// store i32 ()* @target_func, i32 ()** %func_ptr, align 8; /// %0 = load i32 ()*, i32 ()** %func_ptr, align 8; /// %1 = call i32 %0(); /// \endcode; ///; /// is transformed to:; /// \code; /// %func_ptr = alloca i32 ()*, align 8; /// store i32 ()* @target_func, i32 ()** %func_ptr, align 8; /// %0 = load i32 ()*, i32 ()** %func_ptr, align 8; /// %1 = load i32 ()*, i32 ()** @__guard_dispatch_icall_fptr; /// %2 = call i32 %1() [ ""cfguardtarget""(i32 ()* %0) ]; /// \endcode; ///; /// For example, the following X86_64 assembly code:; /// \code; /// leaq target_func(%rip), %rax; ///	 callq *%rax; /// \endcode; ///; /// is transformed to:; /// \code; /// leaq target_func(%rip), %rax; /// callq *__guard_dispatch_icall_fptr(%rip); /// \endcode; ///; /// \param CB indirect call to instrument.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/CFGuard/CFGuard.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/CFGuard/CFGuard.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/CFGuard/CFGuard.cpp:134,Performance,load,loader,134,"/// Inserts a Control Flow Guard (CFG) check on an indirect call using the CFG; /// dispatch mechanism. When the image is loaded, the loader puts the; /// appropriate guard check function pointer in the; /// __guard_dispatch_icall_fptr global symbol. This checks that the target; /// address is a valid address-taken function and, if so, tail calls the; /// target. The target address is passed in an architecture-specific register; /// (e.g. RAX on X86_64), with all other arguments for the target function; /// passed as usual.; ///; /// For example, the following LLVM IR:; /// \code; /// %func_ptr = alloca i32 ()*, align 8; /// store i32 ()* @target_func, i32 ()** %func_ptr, align 8; /// %0 = load i32 ()*, i32 ()** %func_ptr, align 8; /// %1 = call i32 %0(); /// \endcode; ///; /// is transformed to:; /// \code; /// %func_ptr = alloca i32 ()*, align 8; /// store i32 ()* @target_func, i32 ()** %func_ptr, align 8; /// %0 = load i32 ()*, i32 ()** %func_ptr, align 8; /// %1 = load i32 ()*, i32 ()** @__guard_dispatch_icall_fptr; /// %2 = call i32 %1() [ ""cfguardtarget""(i32 ()* %0) ]; /// \endcode; ///; /// For example, the following X86_64 assembly code:; /// \code; /// leaq target_func(%rip), %rax; ///	 callq *%rax; /// \endcode; ///; /// is transformed to:; /// \code; /// leaq target_func(%rip), %rax; /// callq *__guard_dispatch_icall_fptr(%rip); /// \endcode; ///; /// \param CB indirect call to instrument.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/CFGuard/CFGuard.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/CFGuard/CFGuard.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/CFGuard/CFGuard.cpp:699,Performance,load,load,699,"/// Inserts a Control Flow Guard (CFG) check on an indirect call using the CFG; /// dispatch mechanism. When the image is loaded, the loader puts the; /// appropriate guard check function pointer in the; /// __guard_dispatch_icall_fptr global symbol. This checks that the target; /// address is a valid address-taken function and, if so, tail calls the; /// target. The target address is passed in an architecture-specific register; /// (e.g. RAX on X86_64), with all other arguments for the target function; /// passed as usual.; ///; /// For example, the following LLVM IR:; /// \code; /// %func_ptr = alloca i32 ()*, align 8; /// store i32 ()* @target_func, i32 ()** %func_ptr, align 8; /// %0 = load i32 ()*, i32 ()** %func_ptr, align 8; /// %1 = call i32 %0(); /// \endcode; ///; /// is transformed to:; /// \code; /// %func_ptr = alloca i32 ()*, align 8; /// store i32 ()* @target_func, i32 ()** %func_ptr, align 8; /// %0 = load i32 ()*, i32 ()** %func_ptr, align 8; /// %1 = load i32 ()*, i32 ()** @__guard_dispatch_icall_fptr; /// %2 = call i32 %1() [ ""cfguardtarget""(i32 ()* %0) ]; /// \endcode; ///; /// For example, the following X86_64 assembly code:; /// \code; /// leaq target_func(%rip), %rax; ///	 callq *%rax; /// \endcode; ///; /// is transformed to:; /// \code; /// leaq target_func(%rip), %rax; /// callq *__guard_dispatch_icall_fptr(%rip); /// \endcode; ///; /// \param CB indirect call to instrument.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/CFGuard/CFGuard.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/CFGuard/CFGuard.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/CFGuard/CFGuard.cpp:931,Performance,load,load,931,"/// Inserts a Control Flow Guard (CFG) check on an indirect call using the CFG; /// dispatch mechanism. When the image is loaded, the loader puts the; /// appropriate guard check function pointer in the; /// __guard_dispatch_icall_fptr global symbol. This checks that the target; /// address is a valid address-taken function and, if so, tail calls the; /// target. The target address is passed in an architecture-specific register; /// (e.g. RAX on X86_64), with all other arguments for the target function; /// passed as usual.; ///; /// For example, the following LLVM IR:; /// \code; /// %func_ptr = alloca i32 ()*, align 8; /// store i32 ()* @target_func, i32 ()** %func_ptr, align 8; /// %0 = load i32 ()*, i32 ()** %func_ptr, align 8; /// %1 = call i32 %0(); /// \endcode; ///; /// is transformed to:; /// \code; /// %func_ptr = alloca i32 ()*, align 8; /// store i32 ()* @target_func, i32 ()** %func_ptr, align 8; /// %0 = load i32 ()*, i32 ()** %func_ptr, align 8; /// %1 = load i32 ()*, i32 ()** @__guard_dispatch_icall_fptr; /// %2 = call i32 %1() [ ""cfguardtarget""(i32 ()* %0) ]; /// \endcode; ///; /// For example, the following X86_64 assembly code:; /// \code; /// leaq target_func(%rip), %rax; ///	 callq *%rax; /// \endcode; ///; /// is transformed to:; /// \code; /// leaq target_func(%rip), %rax; /// callq *__guard_dispatch_icall_fptr(%rip); /// \endcode; ///; /// \param CB indirect call to instrument.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/CFGuard/CFGuard.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/CFGuard/CFGuard.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/CFGuard/CFGuard.cpp:983,Performance,load,load,983,"/// Inserts a Control Flow Guard (CFG) check on an indirect call using the CFG; /// dispatch mechanism. When the image is loaded, the loader puts the; /// appropriate guard check function pointer in the; /// __guard_dispatch_icall_fptr global symbol. This checks that the target; /// address is a valid address-taken function and, if so, tail calls the; /// target. The target address is passed in an architecture-specific register; /// (e.g. RAX on X86_64), with all other arguments for the target function; /// passed as usual.; ///; /// For example, the following LLVM IR:; /// \code; /// %func_ptr = alloca i32 ()*, align 8; /// store i32 ()* @target_func, i32 ()** %func_ptr, align 8; /// %0 = load i32 ()*, i32 ()** %func_ptr, align 8; /// %1 = call i32 %0(); /// \endcode; ///; /// is transformed to:; /// \code; /// %func_ptr = alloca i32 ()*, align 8; /// store i32 ()* @target_func, i32 ()** %func_ptr, align 8; /// %0 = load i32 ()*, i32 ()** %func_ptr, align 8; /// %1 = load i32 ()*, i32 ()** @__guard_dispatch_icall_fptr; /// %2 = call i32 %1() [ ""cfguardtarget""(i32 ()* %0) ]; /// \endcode; ///; /// For example, the following X86_64 assembly code:; /// \code; /// leaq target_func(%rip), %rax; ///	 callq *%rax; /// \endcode; ///; /// is transformed to:; /// \code; /// leaq target_func(%rip), %rax; /// callq *__guard_dispatch_icall_fptr(%rip); /// \endcode; ///; /// \param CB indirect call to instrument.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/CFGuard/CFGuard.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/CFGuard/CFGuard.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/CFGuard/CFGuard.cpp:3,Performance,Load,Load,3,// Load the global symbol as a pointer to the check function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/CFGuard/CFGuard.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/CFGuard/CFGuard.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/CFGuard/CFGuard.cpp:3,Performance,Load,Load,3,// Load the global as a pointer to a function of the same type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/CFGuard/CFGuard.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/CFGuard/CFGuard.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroEarly.cpp:33,Usability,resume,resume,33,// Replace a direct call to coro.resume or coro.destroy with an indirect call to; // an address returned by coro.subfn.addr intrinsic. This is done so that; // CGPassManager recognizes devirtualization when CoroElide pass replaces a call; // to coro.subfn.addr with an appropriate function address.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroEarly.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroEarly.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroEarly.cpp:342,Testability,mock,mock,342,"// Coroutine promise field is always at the fixed offset from the beginning of; // the coroutine frame. i8* coro.promise(i8*, i1 from) intrinsic adds an offset; // to a passed pointer to move from coroutine frame to coroutine promise and; // vice versa. Since we don't know exactly which coroutine frame it is, we build; // a coroutine frame mock up starting with two function pointers, followed by a; // properly aligned coroutine promise field.; // TODO: Handle the case when coroutine promise alloca has align override.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroEarly.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroEarly.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroEarly.cpp:62,Usability,Resume,ResumeFnAddr,62,"// When a coroutine reaches final suspend point, it zeros out ResumeFnAddr in; // the coroutine frame (it is UB to resume from a final suspend point).; // The llvm.coro.done intrinsic is used to check whether a coroutine is; // suspended at the final suspend point or not.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroEarly.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroEarly.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroEarly.cpp:115,Usability,resume,resume,115,"// When a coroutine reaches final suspend point, it zeros out ResumeFnAddr in; // the coroutine frame (it is UB to resume from a final suspend point).; // The llvm.coro.done intrinsic is used to check whether a coroutine is; // suspended at the final suspend point or not.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroEarly.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroEarly.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroEarly.cpp:3,Usability,Resume,ResumeFnAddr,3,// ResumeFnAddr is the first pointer sized element of the coroutine frame.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroEarly.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroEarly.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroEarly.cpp:86,Security,expose,exposed,86,"// Make sure that all CoroFree reference the coro.id intrinsic.; // Token type is not exposed through coroutine C/C++ builtins to plain C, so; // we allow specifying none and fixing it up here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroEarly.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroEarly.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroElide.cpp:321,Safety,safe,safe,321,"// Look for any tail calls referencing the coroutine frame and remove tail; // attribute from them, since now coroutine frame resides on the stack and tail; // call implies that the function does not references anything on the stack.; // However if it's a musttail call, we cannot remove the tailcall attribute.; // It's safe to keep it there as the musttail call is for symmetric transfer,; // and by that point the frame should have been destroyed and hence not; // interfering with operands.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroElide.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroElide.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroElide.cpp:11,Usability,resume,resume,11,"// Given a resume function @f.resume(%f.frame* %frame), returns the size; // and expected alignment of %f.frame type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroElide.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroElide.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroElide.cpp:30,Usability,resume,resume,30,"// Given a resume function @f.resume(%f.frame* %frame), returns the size; // and expected alignment of %f.frame type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroElide.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroElide.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroElide.cpp:319,Performance,perform,performance,319,"// Think all other usages may be an escaping candidate conservatively.; //; // Note that the major user of switch ABI coroutine (the C++) will store; // resume.fn, destroy.fn and the index to the coroutine frame immediately.; // So the parent of the coro.begin in C++ will be always escaping.; // Then we can't get any performance benefits for C++ by improving the; // precision of the method.; //; // The reason why we still judge it is we want to make LLVM Coroutine in; // switch ABIs to be self contained as much as possible instead of a; // by-product of C++20 Coroutines.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroElide.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroElide.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroElide.cpp:153,Usability,resume,resume,153,"// Think all other usages may be an escaping candidate conservatively.; //; // Note that the major user of switch ABI coroutine (the C++) will store; // resume.fn, destroy.fn and the index to the coroutine frame immediately.; // So the parent of the coro.begin in C++ will be always escaping.; // Then we can't get any performance benefits for C++ by improving the; // precision of the method.; //; // The reason why we still judge it is we want to make LLVM Coroutine in; // switch ABIs to be self contained as much as possible instead of a; // by-product of C++20 Coroutines.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroElide.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroElide.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroElide.cpp:32,Testability,test,test,32,// A Path insensitive marker to test whether the coro.begin escapes.; // It is intentional to make it path insensitive while it may not be; // precise since we don't want the process to be too slow.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroElide.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroElide.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroElide.cpp:107,Deployability,release,released,107,"// If the function ends with the exceptional terminator, the memory used; // by the coroutine frame can be released by stack unwinding; // automatically. So we can think the coro.begin doesn't escape if it; // exits the function by exceptional terminator.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroElide.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroElide.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroElide.cpp:326,Safety,avoid,avoid,326,"// If every terminators is dominated by coro.destroy, we could know the; // corresponding coro.begin wouldn't escape.; //; // Otherwise hasEscapePath would decide whether there is any paths from; // coro.begin to Terminators which not pass through any of the; // coro.destroys.; //; // hasEscapePath is relatively slow, so we avoid to run it as much as; // possible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroElide.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroElide.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroElide.cpp:160,Performance,perform,perform,160,"// If size of the set is the same as total number of coro.begin, that means we; // found a coro.free or coro.destroy referencing each coro.begin, so we can; // perform heap elision.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroElide.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroElide.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroElide.cpp:111,Usability,resume,resume,111,"// Consider case like:; // %0 = call i8 @llvm.coro.suspend(...); // switch i8 %0, label %suspend [i8 0, label %resume; // i8 1, label %cleanup]; // and collect the SwitchInsts which are used by escape analysis later.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroElide.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroElide.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp:683,Performance,load,load,683,"//===- CoroFrame.cpp - Builds and manipulates coroutine frame -------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; // This file contains classes used to discover if for a particular value; // there from sue to definition that crosses a suspend block.; //; // Using the information discovered we form a Coroutine Frame structure to; // contain those values. All uses of those values are replaced with appropriate; // GEP + load from the coroutine frame. At the point of the definition we spill; // the value into the coroutine frame.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp:131,Performance,optimiz,optimize,131,"/// Compute the BlockData for the current function in one iteration.; /// Initialize - Whether this is the first iteration, we can optimize; /// the initial case a little bit by manual loop switch.; /// Returns whether the BlockData changes in this iteration.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp:188,Availability,avail,available,188,"// If block B is an end block, it should not propagate kills as the; // blocks following coro.end() are reached during initial invocation; // of the coroutine while all the data are still available on the; // stack or in the registers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp:192,Usability,resume,resume,192,"// Mark all suspend blocks and indicate that they kill everything they; // consume. Note, that crossing coro.save also requires a spill, as any code; // between coro.save and coro.suspend may resume the coroutine and all of the; // state needs to be saved by that time.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp:39,Safety,avoid,avoid,39,// LayoutIndexUpdateStarted is used to avoid updating the index of any field; // twice by mistake.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp:177,Deployability,update,updated,177,"// Map from values to their slot indexes on the frame. They will be first set; // with their original insertion field index. After the frame is built, their; // indexes will be updated into the final layout index.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp:499,Energy Efficiency,reduce,reduce,499,"/// We want to put the allocas whose lifetime-ranges are not overlapped; /// into one slot of coroutine frame.; /// Consider the example at:https://bugs.llvm.org/show_bug.cgi?id=45566; ///; /// cppcoro::task<void> alternative_paths(bool cond) {; /// if (cond) {; /// big_structure a;; /// process(a);; /// co_await something();; /// } else {; /// big_structure b;; /// process2(b);; /// co_await something();; /// }; /// }; ///; /// We want to put variable a and variable b in the same slot to; /// reduce the size of coroutine frame.; ///; /// This function use StackLifetime algorithm to partition the AllocaInsts in; /// Spills to non-overlapped sets in order to put Alloca in the same; /// non-overlapped set into the same slot in the Coroutine Frame. Then add; /// field for the allocas in the same non-overlapped set by using the largest; /// type as the field type.; ///; /// Side Effects: Because We sort the allocas, the order of allocas in the; /// frame may be different with the order in the source code.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp:448,Modifiability,variab,variable,448,"/// We want to put the allocas whose lifetime-ranges are not overlapped; /// into one slot of coroutine frame.; /// Consider the example at:https://bugs.llvm.org/show_bug.cgi?id=45566; ///; /// cppcoro::task<void> alternative_paths(bool cond) {; /// if (cond) {; /// big_structure a;; /// process(a);; /// co_await something();; /// } else {; /// big_structure b;; /// process2(b);; /// co_await something();; /// }; /// }; ///; /// We want to put variable a and variable b in the same slot to; /// reduce the size of coroutine frame.; ///; /// This function use StackLifetime algorithm to partition the AllocaInsts in; /// Spills to non-overlapped sets in order to put Alloca in the same; /// non-overlapped set into the same slot in the Coroutine Frame. Then add; /// field for the allocas in the same non-overlapped set by using the largest; /// type as the field type.; ///; /// Side Effects: Because We sort the allocas, the order of allocas in the; /// frame may be different with the order in the source code.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp:463,Modifiability,variab,variable,463,"/// We want to put the allocas whose lifetime-ranges are not overlapped; /// into one slot of coroutine frame.; /// Consider the example at:https://bugs.llvm.org/show_bug.cgi?id=45566; ///; /// cppcoro::task<void> alternative_paths(bool cond) {; /// if (cond) {; /// big_structure a;; /// process(a);; /// co_await something();; /// } else {; /// big_structure b;; /// process2(b);; /// co_await something();; /// }; /// }; ///; /// We want to put variable a and variable b in the same slot to; /// reduce the size of coroutine frame.; ///; /// This function use StackLifetime algorithm to partition the AllocaInsts in; /// Spills to non-overlapped sets in order to put Alloca in the same; /// non-overlapped set into the same slot in the Coroutine Frame. Then add; /// field for the allocas in the same non-overlapped set by using the largest; /// type as the field type.; ///; /// Side Effects: Because We sort the allocas, the order of allocas in the; /// frame may be different with the order in the source code.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp:25,Modifiability,flexible,flexible,25,// Everything else has a flexible offset.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp:3,Availability,Recover,Recover,3,// Recover the default target destination for each Switch statement; // reserved.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp:3,Safety,Recover,Recover,3,// Recover the default target destination for each Switch statement; // reserved.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp:3,Performance,Perform,Perform,3,// Perform layout.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp:79,Safety,avoid,avoid,79,/// Create name for Type. It uses MDString to store new created string to; /// avoid memory leak.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp:94,Safety,avoid,avoid,94,"// Construct PointerType points to null (aka void *) instead of exploring; // pointee type to avoid infinite search problem. For example, we would be; // in trouble if we traverse recursively:; //; // struct Node {; // Node* ptr;; // };",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp:425,Modifiability,variab,variables,425,"/// Build artificial debug info for C++ coroutine frames to allow users to; /// inspect the contents of the frame directly; ///; /// Create Debug information for coroutine frame with debug name ""__coro_frame"".; /// The debug information for the fields of coroutine frame is constructed from; /// the following way:; /// 1. For all the value in the Frame, we search the use of dbg.declare to find; /// the corresponding debug variables for the value. If we can find the; /// debug variable, we can get full and accurate debug information.; /// 2. If we can't get debug information in step 1 and 2, we could only try to; /// build the DIType by Type. We did this in solveDIType. We only handle; /// integer, float, double, integer type and struct type for now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp:480,Modifiability,variab,variable,480,"/// Build artificial debug info for C++ coroutine frames to allow users to; /// inspect the contents of the frame directly; ///; /// Create Debug information for coroutine frame with debug name ""__coro_frame"".; /// The debug information for the fields of coroutine frame is constructed from; /// the following way:; /// 1. For all the value in the Frame, we search the use of dbg.declare to find; /// the corresponding debug variables for the value. If we can find the; /// debug variable, we can get full and accurate debug information.; /// 2. If we can't get debug information in step 1 and 2, we could only try to; /// build the DIType by Type. We did this in solveDIType. We only handle; /// integer, float, double, integer type and struct type for now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp:3,Performance,Cache,Cache,3,"// Cache from index to (Align, Offset Pair)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp:27,Usability,Resume,Resume,27,// The Align and Offset of Resume function and Destroy function are fixed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp:27,Safety,avoid,avoid,27,"// This counter is used to avoid same type names. e.g., there would be; // many i32 and i64 types in one coroutine. And we would use i32_0 and; // i32_1 to avoid the same type. Since it makes no sense the name of the; // fields confilicts with each other.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp:156,Safety,avoid,avoid,156,"// This counter is used to avoid same type names. e.g., there would be; // many i32 and i64 types in one coroutine. And we would use i32_0 and; // i32_1 to avoid the same type. Since it makes no sense the name of the; // fields confilicts with each other.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp:74,Modifiability,variab,variables,74,"// Subprogram would have ContainedNodes field which records the debug; // variables it contained. So we need to add __coro_frame to the; // ContainedNodes of it.; //; // If we don't add __coro_frame to the RetainedNodes, user may get; // `no symbol __coro_frame in context` rather than `__coro_frame`; // is optimized out, which is more precise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp:308,Performance,optimiz,optimized,308,"// Subprogram would have ContainedNodes field which records the debug; // variables it contained. So we need to add __coro_frame to the; // ContainedNodes of it.; //; // If we don't add __coro_frame to the RetainedNodes, user may get; // `no symbol __coro_frame in context` rather than `__coro_frame`; // is optimized out, which is more precise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp:89,Usability,Resume,ResumeFnTy,89,// Build a struct that will keep state for an active coroutine.; // struct f.frame {; // ResumeFnTy ResumeFnAddr;; // ResumeFnTy DestroyFnAddr;; // ... promise (if present) ...; // int ResumeIndex;; // ... spills ...; // };,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp:100,Usability,Resume,ResumeFnAddr,100,// Build a struct that will keep state for an active coroutine.; // struct f.frame {; // ResumeFnTy ResumeFnAddr;; // ResumeFnTy DestroyFnAddr;; // ... promise (if present) ...; // int ResumeIndex;; // ... spills ...; // };,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp:118,Usability,Resume,ResumeFnTy,118,// Build a struct that will keep state for an active coroutine.; // struct f.frame {; // ResumeFnTy ResumeFnAddr;; // ResumeFnTy DestroyFnAddr;; // ... promise (if present) ...; // int ResumeIndex;; // ... spills ...; // };,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp:185,Usability,Resume,ResumeIndex,185,// Build a struct that will keep state for an active coroutine.; // struct f.frame {; // ResumeFnTy ResumeFnAddr;; // ResumeFnTy DestroyFnAddr;; // ... promise (if present) ...; // int ResumeIndex;; // ... spills ...; // };,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp:29,Usability,resume,resume,29,// Add header fields for the resume and destroy functions.; // We can rely on these being perfectly packed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp:52,Deployability,update,updateLayoutIndex,52,// Add PromiseAlloca to Allocas list so that; // 1. updateLayoutIndex could update its index after; // `performOptimizedStructLayout`; // 2. it is processed in insertSpills.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp:76,Deployability,update,update,76,// Add PromiseAlloca to Allocas list so that; // 1. updateLayoutIndex could update its index after; // `performOptimizedStructLayout`; // 2. it is processed in insertSpills.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp:104,Performance,perform,performOptimizedStructLayout,104,// Add PromiseAlloca to Allocas list so that; // 1. updateLayoutIndex could update its index after; // `performOptimizedStructLayout`; // 2. it is processed in insertSpills.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp:167,Energy Efficiency,allocate,allocated,167,"// We use a pointer use visitor to track how an alloca is being used.; // The goal is to be able to answer the following three questions:; // 1. Should this alloca be allocated on the frame instead.; // 2. Could the content of the alloca be modified prior to CoroBegn, which would; // require copying the data from alloca to the frame after CoroBegin.; // 3. Is there any alias created for this alloca prior to CoroBegin, but used; // after CoroBegin. In that case, we will need to recreate the alias after; // CoroBegin based off the frame. To answer question 1, we track two things:; // a. List of all BasicBlocks that use this alloca or any of the aliases of; // the alloca. In the end, we check if there exists any two basic blocks that; // cross suspension points. If so, this alloca must be put on the frame. b.; // Whether the alloca or any alias of the alloca is escaped at some point,; // either by storing the address somewhere, or the address is used in a; // function call that might capture. If it's ever escaped, this alloca must be; // put on the frame conservatively.; // To answer quetion 2, we track through the variable MayWriteBeforeCoroBegin.; // Whenever a potential write happens, either through a store instruction, a; // function call or any of the memory intrinsics, we check whether this; // instruction is prior to CoroBegin. To answer question 3, we track the offsets; // of all aliases created for the alloca prior to CoroBegin but used after; // CoroBegin. std::optional is used to be able to represent the case when the; // offset is unknown (e.g. when you have a PHINode that takes in different; // offset values). We cannot handle unknown offsets and will assert. This is the; // potential issue left out. An ideal solution would likely require a; // significant redesign.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp:1130,Modifiability,variab,variable,1130,"// We use a pointer use visitor to track how an alloca is being used.; // The goal is to be able to answer the following three questions:; // 1. Should this alloca be allocated on the frame instead.; // 2. Could the content of the alloca be modified prior to CoroBegn, which would; // require copying the data from alloca to the frame after CoroBegin.; // 3. Is there any alias created for this alloca prior to CoroBegin, but used; // after CoroBegin. In that case, we will need to recreate the alias after; // CoroBegin based off the frame. To answer question 1, we track two things:; // a. List of all BasicBlocks that use this alloca or any of the aliases of; // the alloca. In the end, we check if there exists any two basic blocks that; // cross suspension points. If so, this alloca must be put on the frame. b.; // Whether the alloca or any alias of the alloca is escaped at some point,; // either by storing the address somewhere, or the address is used in a; // function call that might capture. If it's ever escaped, this alloca must be; // put on the frame conservatively.; // To answer quetion 2, we track through the variable MayWriteBeforeCoroBegin.; // Whenever a potential write happens, either through a store instruction, a; // function call or any of the memory intrinsics, we check whether this; // instruction is prior to CoroBegin. To answer question 3, we track the offsets; // of all aliases created for the alloca prior to CoroBegin but used after; // CoroBegin. std::optional is used to be able to represent the case when the; // offset is unknown (e.g. when you have a PHINode that takes in different; // offset values). We cannot handle unknown offsets and will assert. This is the; // potential issue left out. An ideal solution would likely require a; // significant redesign.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp:1690,Testability,assert,assert,1690,"// We use a pointer use visitor to track how an alloca is being used.; // The goal is to be able to answer the following three questions:; // 1. Should this alloca be allocated on the frame instead.; // 2. Could the content of the alloca be modified prior to CoroBegn, which would; // require copying the data from alloca to the frame after CoroBegin.; // 3. Is there any alias created for this alloca prior to CoroBegin, but used; // after CoroBegin. In that case, we will need to recreate the alias after; // CoroBegin based off the frame. To answer question 1, we track two things:; // a. List of all BasicBlocks that use this alloca or any of the aliases of; // the alloca. In the end, we check if there exists any two basic blocks that; // cross suspension points. If so, this alloca must be put on the frame. b.; // Whether the alloca or any alias of the alloca is escaped at some point,; // either by storing the address somewhere, or the address is used in a; // function call that might capture. If it's ever escaped, this alloca must be; // put on the frame conservatively.; // To answer quetion 2, we track through the variable MayWriteBeforeCoroBegin.; // Whenever a potential write happens, either through a store instruction, a; // function call or any of the memory intrinsics, we check whether this; // instruction is prior to CoroBegin. To answer question 3, we track the offsets; // of all aliases created for the alloca prior to CoroBegin but used after; // CoroBegin. std::optional is used to be able to represent the case when the; // offset is unknown (e.g. when you have a PHINode that takes in different; // offset values). We cannot handle unknown offsets and will assert. This is the; // potential issue left out. An ideal solution would likely require a; // significant redesign.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp:86,Performance,optimiz,optimization,86,"// We are storing the pointer into a memory location, potentially escaping.; // As an optimization, we try to detect simple cases where it doesn't; // actually escape, for example:; // %ptr = alloca ..; // %addr = alloca ..; // store %ptr, %addr; // %x = load %addr; // ..; // If %addr is only used by loading from it, we could simply treat %x as; // another alias of %ptr, and not considering %ptr being escaped.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp:255,Performance,load,load,255,"// We are storing the pointer into a memory location, potentially escaping.; // As an optimization, we try to detect simple cases where it doesn't; // actually escape, for example:; // %ptr = alloca ..; // %addr = alloca ..; // store %ptr, %addr; // %x = load %addr; // ..; // If %addr is only used by loading from it, we could simply treat %x as; // another alias of %ptr, and not considering %ptr being escaped.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp:302,Performance,load,loading,302,"// We are storing the pointer into a memory location, potentially escaping.; // As an optimization, we try to detect simple cases where it doesn't; // actually escape, for example:; // %ptr = alloca ..; // %addr = alloca ..; // store %ptr, %addr; // %x = load %addr; // ..; // If %addr is only used by loading from it, we could simply treat %x as; // another alias of %ptr, and not considering %ptr being escaped.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp:110,Safety,detect,detect,110,"// We are storing the pointer into a memory location, potentially escaping.; // As an optimization, we try to detect simple cases where it doesn't; // actually escape, for example:; // %ptr = alloca ..; // %addr = alloca ..; // store %ptr, %addr; // %x = load %addr; // ..; // If %addr is only used by loading from it, we could simply treat %x as; // another alias of %ptr, and not considering %ptr being escaped.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp:117,Usability,simpl,simple,117,"// We are storing the pointer into a memory location, potentially escaping.; // As an optimization, we try to detect simple cases where it doesn't; // actually escape, for example:; // %ptr = alloca ..; // %addr = alloca ..; // store %ptr, %addr; // %x = load %addr; // ..; // If %addr is only used by loading from it, we could simply treat %x as; // another alias of %ptr, and not considering %ptr being escaped.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp:328,Usability,simpl,simply,328,"// We are storing the pointer into a memory location, potentially escaping.; // As an optimization, we try to detect simple cases where it doesn't; // actually escape, for example:; // %ptr = alloca ..; // %addr = alloca ..; // store %ptr, %addr; // %x = load %addr; // ..; // If %addr is only used by loading from it, we could simply treat %x as; // another alias of %ptr, and not considering %ptr being escaped.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp:13,Performance,load,loading,13,"// If we are loading from the memory location, we are creating an; // alias of the original pointer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp:122,Safety,avoid,avoid,122,"// When we found the lifetime markers refers to a; // subrange of the original alloca, ignore the lifetime; // markers to avoid misleading the analysis.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp:30,Availability,avail,available,30,"// If lifetime information is available, we check it first since it's; // more precise. We look at every pair of lifetime.start intrinsic and; // every basic block that uses the pointer to see if they cross suspension; // points. The uses cover both direct uses as well as indirect uses.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp:234,Security,access,accessed,234,"// FIXME: Ideally the isEscaped check should come at the beginning.; // However there are a few loose ends that need to be fixed first before; // we can do that. We need to make sure we are not over-conservative, so; // that the data accessed in-between await_suspend and symmetric transfer; // is always put on the stack, and also data accessed after coro.end is; // always put on the stack (esp the return object). To fix that, we need; // to:; // 1) Potentially treat sret as nocapture in calls; // 2) Special handle the return object and put it on the stack; // 3) Utilize lifetime.end intrinsic",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp:337,Security,access,accessed,337,"// FIXME: Ideally the isEscaped check should come at the beginning.; // However there are a few loose ends that need to be fixed first before; // we can do that. We need to make sure we are not over-conservative, so; // that the data accessed in-between await_suspend and symmetric transfer; // is always put on the stack, and also data accessed after coro.end is; // always put on the stack (esp the return object). To fix that, we need; // to:; // 1) Potentially treat sret as nocapture in calls; // 2) Special handle the return object and put it on the stack; // 3) Utilize lifetime.end intrinsic",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp:127,Performance,load,loads,127,// Replace all alloca and SSA values that are accessed across suspend points; // with GetElementPointer from coroutine frame + loads and stores. Create an; // AllocaSpillBB that will become the new entry block for the resume parts of; // the coroutine:; //; // %hdl = coro.begin(...); // whatever; //; // becomes:; //; // %hdl = coro.begin(...); // br label %AllocaSpillBB; //; // AllocaSpillBB:; // ; geps corresponding to allocas that were moved to coroutine frame; // br label PostSpill; //; // PostSpill:; // whatever; //; //,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp:46,Security,access,accessed,46,// Replace all alloca and SSA values that are accessed across suspend points; // with GetElementPointer from coroutine frame + loads and stores. Create an; // AllocaSpillBB that will become the new entry block for the resume parts of; // the coroutine:; //; // %hdl = coro.begin(...); // whatever; //; // becomes:; //; // %hdl = coro.begin(...); // br label %AllocaSpillBB; //; // AllocaSpillBB:; // ; geps corresponding to allocas that were moved to coroutine frame; // br label PostSpill; //; // PostSpill:; // whatever; //; //,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp:218,Usability,resume,resume,218,// Replace all alloca and SSA values that are accessed across suspend points; // with GetElementPointer from coroutine frame + loads and stores. Create an; // AllocaSpillBB that will become the new entry block for the resume parts of; // the coroutine:; //; // %hdl = coro.begin(...); // whatever; //; // becomes:; //; // %hdl = coro.begin(...); // br label %AllocaSpillBB; //; // AllocaSpillBB:; // ; geps corresponding to allocas that were moved to coroutine frame; // br label PostSpill; //; // PostSpill:; // whatever; //; //,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp:47,Usability,clear,clear,47,"// If we're spilling an Argument, make sure we clear 'nocapture'; // from the coroutine function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp:47,Performance,load,load,47,"// If we have not seen the use block, create a load instruction to reload; // the spilled value from the coroutine frame. Populates the Value pointer; // reference provided with the frame GEP.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp:112,Performance,load,load,112,"// Try best to find dbg.declare. If the spill is a temp, there may not; // be a direct dbg.declare. Walk up the load chain to find one from an; // alias.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp:38,Performance,load,load,38,// Only consider ptr to ptr same type load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp:180,Modifiability,rewrite,rewritePHIs,180,"// If we have a single edge PHINode, remove it and replace it with a; // reload from the coroutine frame. (We already took care of multi edge; // PHINodes by rewriting them in the rewritePHIs function).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp:88,Deployability,Update,Update,88,// Instructions are added to Def's user list if the attached; // debug records use Def. Update those now.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp:174,Performance,optimiz,optimizations,174,// It is meaningless to retain the lifetime intrinsics refer for the; // member of coroutine frames and the meaningless lifetime intrinsics; // are possible to block further optimizations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp:22,Security,access,accessing,22,// If there is memory accessing to promise alloca before CoroBegin;,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp:3,Modifiability,Rewrite,Rewrites,3,// Rewrites the PHI Nodes in a cleanuppad.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp:3,Deployability,Update,Update,3,// Update this Pred to the new unwind point.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp:374,Modifiability,rewrite,rewrite,374,"// For every incoming edge we will create a block holding all; // incoming values in a single PHI nodes.; //; // loop:; // %n.val = phi i32[%n, %entry], [%inc, %loop]; //; // It will create:; //; // loop.from.entry:; // %n.loop.pre = phi i32 [%n, %entry]; // br %label loop; // loop.from.loop:; // %inc.loop.pre = phi i32 [%inc, %loop]; // br %label loop; //; // After this rewrite, further analysis will ignore any phi nodes with more; // than one incoming edge.; // TODO: Simplify PHINodes in the basic block to remove duplicate; // predecessors.; // Special case for CleanupPad: all EH blocks must have the same unwind edge; // so we need to create an additional ""dispatcher"" block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp:474,Usability,Simpl,Simplify,474,"// For every incoming edge we will create a block holding all; // incoming values in a single PHI nodes.; //; // loop:; // %n.val = phi i32[%n, %entry], [%inc, %loop]; //; // It will create:; //; // loop.from.entry:; // %n.loop.pre = phi i32 [%n, %entry]; // br %label loop; // loop.from.loop:; // %inc.loop.pre = phi i32 [%inc, %loop]; // br %label loop; //; // After this rewrite, further analysis will ignore any phi nodes with more; // than one incoming edge.; // TODO: Simplify PHINodes in the basic block to remove duplicate; // predecessors.; // Special case for CleanupPad: all EH blocks must have the same unwind edge; // so we need to create an additional ""dispatcher"" block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp:87,Usability,resume,resume,87,/// Default materializable callback; // Check for instructions that we can recreate on resume as opposed to spill; // the result into a coroutine frame.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp:68,Safety,abort,abort,68,"// If none of the successors leads back in a loop, we're on an exit/abort.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp:32,Safety,avoid,avoid,32,// Save the stack depth. Try to avoid doing this if the stackrestore; // is going to immediately precede a return or something.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp:3,Energy Efficiency,Allocate,Allocate,3,// Allocate memory.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp:45,Safety,safe,safe,45,"// Replace frees with stackrestores. This is safe because; // alloca.alloc is required to obey a stack discipline, although we; // don't enforce that structurally.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp:3,Performance,Load,Load,3,// Load the current value from the alloca and set it as the; // swifterror value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp:26,Performance,load,loads,26,// All the uses should be loads and stores now.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp:86,Performance,load,loading,86,"/// ""Eliminate"" a swifterror argument by reducing it to the alloca case; /// and then loading and storing in the prologue and epilog.; ///; /// The argument keeps the swifterror flag.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp:3,Energy Efficiency,Reduce,Reduce,3,// Reduce to the alloca case:; // Create an alloca and replace all uses of the arg with it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp:58,Availability,error,error,58,// Find all the coro.ends in the function and restore the error value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp:29,Testability,log,logic,29,// Now we can use the alloca logic.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp:3,Usability,Clear,Clear,3,// Clear the swifterror flag.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp:19,Modifiability,variab,variable,19,"/// For each local variable that all of its user are only used inside one of; /// suspended region, we sink their lifetime.start markers to the place where; /// after the suspend block. Doing so minimizes the lifetime of each variable,; /// hence minimizing the amount of data we end up putting on the frame.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp:226,Modifiability,variab,variable,226,"/// For each local variable that all of its user are only used inside one of; /// suspended region, we sink their lifetime.start markers to the place where; /// after the suspend block. Doing so minimizes the lifetime of each variable,; /// hence minimizing the amount of data we end up putting on the frame.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp:269,Performance,load,load,269,// FIXME: This is a heuristic that works around the fact that; // LLVM IR debug intrinsics cannot yet distinguish between; // memory and value locations: Because a dbg.declare(alloca) is; // implicitly a memory location no DW_OP_deref operation for the; // last direct load from an alloca is necessary. This condition; // effectively drops the *last* DW_OP_deref in the expression.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp:83,Availability,avail,availability,83,"// If the coroutine frame is an Argument, store it in an alloca to improve; // its availability (e.g. registers may be clobbered).; // Avoid this if optimizations are enabled (they would remove the alloca) or; // if the value is guaranteed to be available through other means (e.g. swift; // ABI guarantees).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp:246,Availability,avail,available,246,"// If the coroutine frame is an Argument, store it in an alloca to improve; // its availability (e.g. registers may be clobbered).; // Avoid this if optimizations are enabled (they would remove the alloca) or; // if the value is guaranteed to be available through other means (e.g. swift; // ABI guarantees).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp:149,Performance,optimiz,optimizations,149,"// If the coroutine frame is an Argument, store it in an alloca to improve; // its availability (e.g. registers may be clobbered).; // Avoid this if optimizations are enabled (they would remove the alloca) or; // if the value is guaranteed to be available through other means (e.g. swift; // ABI guarantees).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp:135,Safety,Avoid,Avoid,135,"// If the coroutine frame is an Argument, store it in an alloca to improve; // its availability (e.g. registers may be clobbered).; // Avoid this if optimizations are enabled (they would remove the alloca) or; // if the value is guaranteed to be available through other means (e.g. swift; // ABI guarantees).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp:355,Performance,load,load,355,"// FIXME: LLVM lacks nuanced semantics to differentiate between; // memory and direct locations at the IR level. The backend will; // turn a dbg.declare(alloca, ..., DIExpression()) into a memory; // location. Thus, if there are deref and offset operations in the; // expression, we need to add a DW_OP_deref at the *start* of the; // expression to first load the contents of the alloca before; // adjusting it with the expression.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp:3,Deployability,Update,Update,3,// Update DILocation only in O0 since it is easy to get out of sync in; // optimizations. See https://github.com/llvm/llvm-project/pull/75104 for; // an example.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp:75,Performance,optimiz,optimizations,75,// Update DILocation only in O0 since it is easy to get out of sync in; // optimizations. See https://github.com/llvm/llvm-project/pull/75104 for; // an example.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp:3,Deployability,Update,Update,3,// Update DILocation only in O0 since it is easy to get out of sync in; // optimizations. See https://github.com/llvm/llvm-project/pull/75104 for; // an example.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp:75,Performance,optimiz,optimizations,75,// Update DILocation only in O0 since it is easy to get out of sync in; // optimizations. See https://github.com/llvm/llvm-project/pull/75104 for; // an example.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp:3,Modifiability,Rewrite,Rewrite,3,// Rewrite materializable instructions to be materialized at the use; // point.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp:130,Testability,log,logic,130,"// Make sure that all coro.save, coro.suspend and the fallthrough coro.end; // intrinsics are in their own blocks to simplify the logic of building up; // SuspendCrossing data.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp:117,Usability,simpl,simplify,117,"// Make sure that all coro.save, coro.suspend and the fallthrough coro.end; // intrinsics are in their own blocks to simplify the logic of building up; // SuspendCrossing data.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp:22,Modifiability,rewrite,rewrite,22,"// If not, do a quick rewrite of the alloca and then add spills of; // the rewritten value. The rewrite doesn't invalidate anything in; // Spills because the other alloca intrinsics have no other operands; // besides AI, and it doesn't invalidate the iteration because we delay; // erasing AI.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp:96,Modifiability,rewrite,rewrite,96,"// If not, do a quick rewrite of the alloca and then add spills of; // the rewritten value. The rewrite doesn't invalidate anything in; // Spills because the other alloca intrinsics have no other operands; // besides AI, and it doesn't invalidate the iteration because we delay; // erasing AI.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroInstr.h:55,Integrability,Wrap,Wrappers,55,"//===-- CoroInstr.h - Coroutine Intrinsics Instruction Wrappers -*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; // This file defines classes that make it really easy to deal with intrinsic; // functions with the isa/dyncast family of functions. In particular, this; // allows you to do things like:; //; // if (auto *SF = dyn_cast<CoroSubFnInst>(Inst)); // ... SF->getFrame() ...; //; // All intrinsic function calls are instances of the call instruction, so these; // are all subclasses of the CallInst class. Note that none of these classes; // has state or virtual methods, which is an important part of this gross/neat; // hack working.; //; // The helpful comment above is borrowed from llvm/IntrinsicInst.h, we keep; // coroutine intrinsic wrappers here since they are only used by the passes in; // the Coroutine library.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroInstr.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroInstr.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroInstr.h:1010,Integrability,wrap,wrappers,1010,"//===-- CoroInstr.h - Coroutine Intrinsics Instruction Wrappers -*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; // This file defines classes that make it really easy to deal with intrinsic; // functions with the isa/dyncast family of functions. In particular, this; // allows you to do things like:; //; // if (auto *SF = dyn_cast<CoroSubFnInst>(Inst)); // ... SF->getFrame() ...; //; // All intrinsic function calls are instances of the call instruction, so these; // are all subclasses of the CallInst class. Note that none of these classes; // has state or virtual methods, which is an important part of this gross/neat; // hack working.; //; // The helpful comment above is borrowed from llvm/IntrinsicInst.h, we keep; // coroutine intrinsic wrappers here since they are only used by the passes in; // the Coroutine library.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroInstr.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroInstr.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroInstr.h:137,Usability,resume,resume,137,"// Info argument of coro.id is; // fresh out of the frontend: null ;; // outlined : {Init, Return, Susp1, Susp2, ...} ;; // postsplit : [resume, destroy, cleanup] ;; //; // If parts of the coroutine were outlined to protect against undesirable; // code motion, these functions will be stored in a struct literal referred to; // by the Info parameter. Note: this is only needed before coroutine is split.; //; // After coroutine is split, resume functions are stored in an array; // referred to by this parameter.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroInstr.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroInstr.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroInstr.h:438,Usability,resume,resume,438,"// Info argument of coro.id is; // fresh out of the frontend: null ;; // outlined : {Init, Return, Susp1, Susp2, ...} ;; // postsplit : [resume, destroy, cleanup] ;; //; // If parts of the coroutine were outlined to protect against undesirable; // code motion, these functions will be stored in a struct literal referred to; // by the Info parameter. Note: this is only needed before coroutine is split.; //; // After coroutine is split, resume functions are stored in an array; // referred to by this parameter.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroInstr.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroInstr.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroInstr.h:126,Energy Efficiency,allocate,allocated,126,/// The initial async function context size. The fields of which are reserved; /// for use by the frontend. The frame will be allocated as a tail of this; /// context.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroInstr.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroInstr.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroInstr.h:40,Usability,resume,resume,40,/// This represents the llvm.coro.async.resume instruction.; /// During lowering this is replaced by the resume function of a suspend point; /// (the continuation function).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroInstr.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroInstr.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroInstr.h:105,Usability,resume,resume,105,/// This represents the llvm.coro.async.resume instruction.; /// During lowering this is replaced by the resume function of a suspend point; /// (the continuation function).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroInstr.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroInstr.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroInternal.h:43,Integrability,interface,interfaces,43,"//===- CoroInternal.h - Internal Coroutine interfaces ---------*- C++ -*---===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; // Common definitions/declarations used internally by coroutine lowering passes.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroInternal.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroInternal.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroInternal.h:16,Modifiability,rewrite,rewrite,16,"/// Attempts to rewrite the location operand of debug intrinsics in terms of; /// the coroutine frame pointer, folding pointer offsets into the DIExpression; /// of the intrinsic.; /// If the frame pointer is an Argument, store it into an alloca if; /// OptimizeFrame is false.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroInternal.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroInternal.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroInternal.h:254,Performance,Optimiz,OptimizeFrame,254,"/// Attempts to rewrite the location operand of debug intrinsics in terms of; /// the coroutine frame pointer, folding pointer offsets into the DIExpression; /// of the intrinsic.; /// If the frame pointer is an Argument, store it into an alloca if; /// OptimizeFrame is false.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroInternal.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroInternal.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroInternal.h:9,Usability,resume,resume-switch,9,"/// The ""resume-switch"" lowering, where there are separate resume and; /// destroy functions that are shared between all suspend points. The; /// coroutine frame implicitly stores the resume and destroy functions,; /// the current index, and any promise value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroInternal.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroInternal.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroInternal.h:59,Usability,resume,resume,59,"/// The ""resume-switch"" lowering, where there are separate resume and; /// destroy functions that are shared between all suspend points. The; /// coroutine frame implicitly stores the resume and destroy functions,; /// the current index, and any promise value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroInternal.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroInternal.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroInternal.h:184,Usability,resume,resume,184,"/// The ""resume-switch"" lowering, where there are separate resume and; /// destroy functions that are shared between all suspend points. The; /// coroutine frame implicitly stores the resume and destroy functions,; /// the current index, and any promise value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroInternal.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroInternal.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroInternal.h:138,Availability,avail,available,138,"/// The ""async continuation"" lowering, where each suspend point creates a; /// single continuation function. The continuation function is available as an; /// intrinsic.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroInternal.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroInternal.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroInternal.h:31,Performance,optimiz,optimization,31,/// This would only be true if optimization are enabled.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroInternal.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroInternal.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroInternal.h:31,Integrability,depend,depends,31,// Not used. The function type depends on the active suspend.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroInternal.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroInternal.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroInternal.h:7,Safety,safe,safety,7,// The safety of all this is checked by checkWFRetconPrototype.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroInternal.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroInternal.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroInternal.h:7,Safety,safe,safety,7,// The safety of all this is checked by checkWFRetconPrototype.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroInternal.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroInternal.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroInternal.h:110,Deployability,update,updated,110,"/// Allocate memory according to the rules of the active lowering.; ///; /// \param CG - if non-null, will be updated for the new call",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroInternal.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroInternal.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroInternal.h:4,Energy Efficiency,Allocate,Allocate,4,"/// Allocate memory according to the rules of the active lowering.; ///; /// \param CG - if non-null, will be updated for the new call",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroInternal.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroInternal.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroInternal.h:112,Deployability,update,updated,112,"/// Deallocate memory according to the rules of the active lowering.; ///; /// \param CG - if non-null, will be updated for the new call",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroInternal.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroInternal.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp:962,Deployability,pipeline,pipeline,962,"//===- CoroSplit.cpp - Converts a coroutine into a state machine ----------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; // This pass builds the coroutine frame and outlines resume and destroy parts; // of the coroutine into separate functions.; //; // We present a coroutine to an LLVM as an ordinary function with suspension; // points marked up with intrinsics. We let the optimizer party on the coroutine; // as a single function for as long as possible. Shortly before the coroutine is; // eligible to be inlined into its callers, we split up the coroutine into parts; // corresponding to an initial, resume and destroy invocations of the coroutine,; // add them to the current SCC and restart the IPO pipeline to optimize the; // coroutine subfunctions we extracted before proceeding to the caller of the; // coroutine.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp:631,Performance,optimiz,optimizer,631,"//===- CoroSplit.cpp - Converts a coroutine into a state machine ----------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; // This pass builds the coroutine frame and outlines resume and destroy parts; // of the coroutine into separate functions.; //; // We present a coroutine to an LLVM as an ordinary function with suspension; // points marked up with intrinsics. We let the optimizer party on the coroutine; // as a single function for as long as possible. Shortly before the coroutine is; // eligible to be inlined into its callers, we split up the coroutine into parts; // corresponding to an initial, resume and destroy invocations of the coroutine,; // add them to the current SCC and restart the IPO pipeline to optimize the; // coroutine subfunctions we extracted before proceeding to the caller of the; // coroutine.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp:974,Performance,optimiz,optimize,974,"//===- CoroSplit.cpp - Converts a coroutine into a state machine ----------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; // This pass builds the coroutine frame and outlines resume and destroy parts; // of the coroutine into separate functions.; //; // We present a coroutine to an LLVM as an ordinary function with suspension; // points marked up with intrinsics. We let the optimizer party on the coroutine; // as a single function for as long as possible. Shortly before the coroutine is; // eligible to be inlined into its callers, we split up the coroutine into parts; // corresponding to an initial, resume and destroy invocations of the coroutine,; // add them to the current SCC and restart the IPO pipeline to optimize the; // coroutine subfunctions we extracted before proceeding to the caller of the; // coroutine.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp:429,Usability,resume,resume,429,"//===- CoroSplit.cpp - Converts a coroutine into a state machine ----------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; // This pass builds the coroutine frame and outlines resume and destroy parts; // of the coroutine into separate functions.; //; // We present a coroutine to an LLVM as an ordinary function with suspension; // points marked up with intrinsics. We let the optimizer party on the coroutine; // as a single function for as long as possible. Shortly before the coroutine is; // eligible to be inlined into its callers, we split up the coroutine into parts; // corresponding to an initial, resume and destroy invocations of the coroutine,; // add them to the current SCC and restart the IPO pipeline to optimize the; // coroutine subfunctions we extracted before proceeding to the caller of the; // coroutine.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp:861,Usability,resume,resume,861,"//===- CoroSplit.cpp - Converts a coroutine into a state machine ----------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; // This pass builds the coroutine frame and outlines resume and destroy parts; // of the coroutine into separate functions.; //; // We present a coroutine to an LLVM as an ordinary function with suspension; // points marked up with intrinsics. We let the optimizer party on the coroutine; // as a single function for as long as possible. Shortly before the coroutine is; // eligible to be inlined into its callers, we split up the coroutine into parts; // corresponding to an initial, resume and destroy invocations of the coroutine,; // add them to the current SCC and restart the IPO pipeline to optimize the; // coroutine subfunctions we extracted before proceeding to the caller of the; // coroutine.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp:15,Usability,resume,resume,15,/// The shared resume function for a switch lowering.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp:13,Usability,resume,resume,13,/// An async resume function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp:105,Energy Efficiency,allocate,allocated,105,"// In unique continuation lowering, the continuations always return void.; // But we may have implicitly allocated storage.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp:92,Usability,resume,resumed,92,"// Mark a coroutine as done, which implies that the coroutine is finished and; // never get resumed.; //; // In resume-switched ABI, the done state is represented by storing zero in; // ResumeFnAddr.; //; // NOTE: We couldn't omit the argument `FramePtr`. It is necessary because the; // pointer to the frame in splitted function is not stored in `Shape`.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp:112,Usability,resume,resume-switched,112,"// Mark a coroutine as done, which implies that the coroutine is finished and; // never get resumed.; //; // In resume-switched ABI, the done state is represented by storing zero in; // ResumeFnAddr.; //; // NOTE: We couldn't omit the argument `FramePtr`. It is necessary because the; // pointer to the frame in splitted function is not stored in `Shape`.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp:186,Usability,Resume,ResumeFnAddr,186,"// Mark a coroutine as done, which implies that the coroutine is finished and; // never get resumed.; //; // In resume-switched ABI, the done state is represented by storing zero in; // ResumeFnAddr.; //; // NOTE: We couldn't omit the argument `FramePtr`. It is necessary because the; // pointer to the frame in splitted function is not stored in `Shape`.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp:201,Usability,Resume,ResumeFnAddr,201,"// If the coroutine don't have unwind coro end, we could omit the store to; // the final suspend point since we could infer the coroutine is suspended; // at the final suspend point by the nullness of ResumeFnAddr.; // However, we can't skip it if the coroutine have unwind coro end. Since; // the coroutine reaches unwind coro end is considered suspended at the; // final suspend point (the ResumeFnAddr is null) but in fact the coroutine; // didn't complete yet. We need the IndexVal for the final suspend point; // to make the states clear.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp:392,Usability,Resume,ResumeFnAddr,392,"// If the coroutine don't have unwind coro end, we could omit the store to; // the final suspend point since we could infer the coroutine is suspended; // at the final suspend point by the nullness of ResumeFnAddr.; // However, we can't skip it if the coroutine have unwind coro end. Since; // the coroutine reaches unwind coro end is considered suspended at the; // final suspend point (the ResumeFnAddr is null) but in fact the coroutine; // didn't complete yet. We need the IndexVal for the final suspend point; // to make the states clear.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp:537,Usability,clear,clear,537,"// If the coroutine don't have unwind coro end, we could omit the store to; // the final suspend point since we could infer the coroutine is suspended; // at the final suspend point by the nullness of ResumeFnAddr.; // However, we can't skip it if the coroutine have unwind coro end. Since; // the coroutine reaches unwind coro end is considered suspended at the; // final suspend point (the ResumeFnAddr is null) but in fact the coroutine; // didn't complete yet. We need the IndexVal for the final suspend point; // to make the states clear.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp:195,Modifiability,refactor,refactor,195,"// In C++'s specification, the coroutine should be marked as done; // if promise.unhandled_exception() throws. The frontend will; // call coro.end(true) along this path.; //; // FIXME: We should refactor this once there is other language; // which uses Switch-Resumed style other than C++.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp:260,Usability,Resume,Resumed,260,"// In C++'s specification, the coroutine should be marked as done; // if promise.unhandled_exception() throws. The frontend will; // call coro.end(true) along this path.; //; // FIXME: We should refactor this once there is other language; // which uses Switch-Resumed style other than C++.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp:31,Usability,resume,resume,31,// Create an entry block for a resume function with a switch that will jump to; // suspend points.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp:120,Performance,load,load,120,"// resume.entry:; // %index.addr = getelementptr inbounds %f.Frame, %f.Frame* %FramePtr, i32 0,; // i32 2; // % index = load i32, i32* %index.addr; // switch i32 %index, label %unreachable [; // i32 0, label %resume.0; // i32 1, label %resume.1; // ...; // ]",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp:3,Usability,resume,resume,3,"// resume.entry:; // %index.addr = getelementptr inbounds %f.Frame, %f.Frame* %FramePtr, i32 0,; // i32 2; // % index = load i32, i32* %index.addr; // switch i32 %index, label %unreachable [; // i32 0, label %resume.0; // i32 1, label %resume.1; // ...; // ]",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp:209,Usability,resume,resume,209,"// resume.entry:; // %index.addr = getelementptr inbounds %f.Frame, %f.Frame* %FramePtr, i32 0,; // i32 2; // % index = load i32, i32* %index.addr; // switch i32 %index, label %unreachable [; // i32 0, label %resume.0; // i32 1, label %resume.1; // ...; // ]",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp:236,Usability,resume,resume,236,"// resume.entry:; // %index.addr = getelementptr inbounds %f.Frame, %f.Frame* %FramePtr, i32 0,; // i32 2; // % index = load i32, i32* %index.addr; // switch i32 %index, label %unreachable [; // i32 0, label %resume.0; // i32 1, label %resume.1; // ...; // ]",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp:223,Usability,resume,resume,223,"// Split block before and after coro.suspend and add a jump from an entry; // switch:; //; // whateverBB:; // whatever; // %0 = call i8 @llvm.coro.suspend(token none, i1 false); // switch i8 %0, label %suspend[i8 0, label %resume; // i8 1, label %cleanup]; // becomes:; //; // whateverBB:; // whatever; // br label %resume.0.landing; //; // resume.0: ; <--- jump from the switch in the resume.entry; // %0 = tail call i8 @llvm.coro.suspend(token none, i1 false); // br label %resume.0.landing; //; // resume.0.landing:; // %1 = phi i8[-1, %whateverBB], [%0, %resume.0]; // switch i8 % 1, label %suspend [i8 0, label %resume; // i8 1, label %cleanup]",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp:316,Usability,resume,resume,316,"// Split block before and after coro.suspend and add a jump from an entry; // switch:; //; // whateverBB:; // whatever; // %0 = call i8 @llvm.coro.suspend(token none, i1 false); // switch i8 %0, label %suspend[i8 0, label %resume; // i8 1, label %cleanup]; // becomes:; //; // whateverBB:; // whatever; // br label %resume.0.landing; //; // resume.0: ; <--- jump from the switch in the resume.entry; // %0 = tail call i8 @llvm.coro.suspend(token none, i1 false); // br label %resume.0.landing; //; // resume.0.landing:; // %1 = phi i8[-1, %whateverBB], [%0, %resume.0]; // switch i8 % 1, label %suspend [i8 0, label %resume; // i8 1, label %cleanup]",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp:341,Usability,resume,resume,341,"// Split block before and after coro.suspend and add a jump from an entry; // switch:; //; // whateverBB:; // whatever; // %0 = call i8 @llvm.coro.suspend(token none, i1 false); // switch i8 %0, label %suspend[i8 0, label %resume; // i8 1, label %cleanup]; // becomes:; //; // whateverBB:; // whatever; // br label %resume.0.landing; //; // resume.0: ; <--- jump from the switch in the resume.entry; // %0 = tail call i8 @llvm.coro.suspend(token none, i1 false); // br label %resume.0.landing; //; // resume.0.landing:; // %1 = phi i8[-1, %whateverBB], [%0, %resume.0]; // switch i8 % 1, label %suspend [i8 0, label %resume; // i8 1, label %cleanup]",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp:386,Usability,resume,resume,386,"// Split block before and after coro.suspend and add a jump from an entry; // switch:; //; // whateverBB:; // whatever; // %0 = call i8 @llvm.coro.suspend(token none, i1 false); // switch i8 %0, label %suspend[i8 0, label %resume; // i8 1, label %cleanup]; // becomes:; //; // whateverBB:; // whatever; // br label %resume.0.landing; //; // resume.0: ; <--- jump from the switch in the resume.entry; // %0 = tail call i8 @llvm.coro.suspend(token none, i1 false); // br label %resume.0.landing; //; // resume.0.landing:; // %1 = phi i8[-1, %whateverBB], [%0, %resume.0]; // switch i8 % 1, label %suspend [i8 0, label %resume; // i8 1, label %cleanup]",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp:476,Usability,resume,resume,476,"// Split block before and after coro.suspend and add a jump from an entry; // switch:; //; // whateverBB:; // whatever; // %0 = call i8 @llvm.coro.suspend(token none, i1 false); // switch i8 %0, label %suspend[i8 0, label %resume; // i8 1, label %cleanup]; // becomes:; //; // whateverBB:; // whatever; // br label %resume.0.landing; //; // resume.0: ; <--- jump from the switch in the resume.entry; // %0 = tail call i8 @llvm.coro.suspend(token none, i1 false); // br label %resume.0.landing; //; // resume.0.landing:; // %1 = phi i8[-1, %whateverBB], [%0, %resume.0]; // switch i8 % 1, label %suspend [i8 0, label %resume; // i8 1, label %cleanup]",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp:501,Usability,resume,resume,501,"// Split block before and after coro.suspend and add a jump from an entry; // switch:; //; // whateverBB:; // whatever; // %0 = call i8 @llvm.coro.suspend(token none, i1 false); // switch i8 %0, label %suspend[i8 0, label %resume; // i8 1, label %cleanup]; // becomes:; //; // whateverBB:; // whatever; // br label %resume.0.landing; //; // resume.0: ; <--- jump from the switch in the resume.entry; // %0 = tail call i8 @llvm.coro.suspend(token none, i1 false); // br label %resume.0.landing; //; // resume.0.landing:; // %1 = phi i8[-1, %whateverBB], [%0, %resume.0]; // switch i8 % 1, label %suspend [i8 0, label %resume; // i8 1, label %cleanup]",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp:559,Usability,resume,resume,559,"// Split block before and after coro.suspend and add a jump from an entry; // switch:; //; // whateverBB:; // whatever; // %0 = call i8 @llvm.coro.suspend(token none, i1 false); // switch i8 %0, label %suspend[i8 0, label %resume; // i8 1, label %cleanup]; // becomes:; //; // whateverBB:; // whatever; // br label %resume.0.landing; //; // resume.0: ; <--- jump from the switch in the resume.entry; // %0 = tail call i8 @llvm.coro.suspend(token none, i1 false); // br label %resume.0.landing; //; // resume.0.landing:; // %1 = phi i8[-1, %whateverBB], [%0, %resume.0]; // switch i8 % 1, label %suspend [i8 0, label %resume; // i8 1, label %cleanup]",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp:617,Usability,resume,resume,617,"// Split block before and after coro.suspend and add a jump from an entry; // switch:; //; // whateverBB:; // whatever; // %0 = call i8 @llvm.coro.suspend(token none, i1 false); // switch i8 %0, label %suspend[i8 0, label %resume; // i8 1, label %cleanup]; // becomes:; //; // whateverBB:; // whatever; // br label %resume.0.landing; //; // resume.0: ; <--- jump from the switch in the resume.entry; // %0 = tail call i8 @llvm.coro.suspend(token none, i1 false); // br label %resume.0.landing; //; // resume.0.landing:; // %1 = phi i8[-1, %whateverBB], [%0, %resume.0]; // switch i8 % 1, label %suspend [i8 0, label %resume; // i8 1, label %cleanup]",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp:10,Usability,resume,resume,10,"// In the resume function, we remove the last case (when coro::Shape is built,; // the final suspend point (if present) is always the last element of; // CoroSuspends array) since it is an undefined behavior to resume a coroutine; // suspended at the final suspend point.; // In the destroy function, if it isn't possible that the ResumeFnAddr is NULL; // and the coroutine doesn't suspend at the final suspend point actually (this; // is possible since the coroutine is considered suspended at the final suspend; // point if promise.unhandled_exception() exits via an exception), we can; // remove the last case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp:211,Usability,resume,resume,211,"// In the resume function, we remove the last case (when coro::Shape is built,; // the final suspend point (if present) is always the last element of; // CoroSuspends array) since it is an undefined behavior to resume a coroutine; // suspended at the final suspend point.; // In the destroy function, if it isn't possible that the ResumeFnAddr is NULL; // and the coroutine doesn't suspend at the final suspend point actually (this; // is possible since the coroutine is considered suspended at the final suspend; // point if promise.unhandled_exception() exits via an exception), we can; // remove the last case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp:331,Usability,Resume,ResumeFnAddr,331,"// In the resume function, we remove the last case (when coro::Shape is built,; // the final suspend point (if present) is always the last element of; // CoroSuspends array) since it is an undefined behavior to resume a coroutine; // suspended at the final suspend point.; // In the destroy function, if it isn't possible that the ResumeFnAddr is NULL; // and the coroutine doesn't suspend at the final suspend point actually (this; // is possible since the coroutine is considered suspended at the final suspend; // point if promise.unhandled_exception() exits via an exception), we can; // remove the last case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp:66,Usability,simpl,simple,66,"// If the suspend returns a single scalar value, we can just do a simple; // replacement.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp:202,Usability,resume,resume,202,"// In switch lowering, replace coro.suspend with the appropriate value; // for the type of function we're extracting.; // Replacing coro.suspend with (0) will result in control flow proceeding to; // a resume label associated with a suspend point, replacing it with (1) will; // result in control flow proceeding to a cleanup label associated with this; // suspend point.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp:5,Usability,resume,resume,5,/*in resume*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp:3,Usability,Clear,Clear,3,"// Clear all predecessors of the new entry block. There should be; // exactly one predecessor, which we created when splitting out; // AllocaSpillBlock to begin with.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp:34,Usability,resume,resume-entry,34,"// In switch-lowering, we built a resume-entry block in the original; // function. Make the entry block branch to this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp:165,Usability,resume,resume,165,"// In async-lowering, one of the arguments is an async context as determined; // by the `llvm.coro.id.async` intrinsic. We can retrieve the async context of; // the resume function from the async context projection function associated; // with the active suspend. The frame is located as a tail to the async; // context header.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp:14,Performance,load,load,14,"// Otherwise, load the real frame from the opaque storage.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp:51,Usability,resume,resume,51,/// Clone the body of the original function into a resume function of; /// some sort.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp:272,Performance,load,loads,272,"// Replace all args with dummy instructions. If an argument is the old frame; // pointer, the dummy will be replaced by the new frame pointer once it is; // computed below. Uses of all other arguments should have already been; // rewritten by buildCoroutineFrame() to use loads/stores on the coroutine; // frame.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp:323,Safety,avoid,avoids,323,"// For async functions / continuations, adjust the scope line of the; // clone to the line number of the suspend point. However, only; // adjust the scope line when the files are the same. This ensures; // line number and file name belong together. The scope line is; // associated with all pre-prologue instructions. This avoids a jump; // in the linetable from the function declaration to the suspend point.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp:3,Deployability,Update,Update,3,"// Update the linkage name to reflect the modified symbol name. It; // is necessary to update the linkage name in Swift, since the; // mangling changes for resume functions. It might also be the; // right thing to do in C++, but due to a limitation in LLVM's; // AsmPrinter we can only do this if the function doesn't have an; // abstract specification, since the DWARF backend expects the; // abstract specification to contain the linkage name and asserts; // that they are identical.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp:87,Deployability,update,update,87,"// Update the linkage name to reflect the modified symbol name. It; // is necessary to update the linkage name in Swift, since the; // mangling changes for resume functions. It might also be the; // right thing to do in C++, but due to a limitation in LLVM's; // AsmPrinter we can only do this if the function doesn't have an; // abstract specification, since the DWARF backend expects the; // abstract specification to contain the linkage name and asserts; // that they are identical.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp:449,Testability,assert,asserts,449,"// Update the linkage name to reflect the modified symbol name. It; // is necessary to update the linkage name in Swift, since the; // mangling changes for resume functions. It might also be the; // right thing to do in C++, but due to a limitation in LLVM's; // AsmPrinter we can only do this if the function doesn't have an; // abstract specification, since the DWARF backend expects the; // abstract specification to contain the linkage name and asserts; // that they are identical.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp:156,Usability,resume,resume,156,"// Update the linkage name to reflect the modified symbol name. It; // is necessary to update the linkage name in Swift, since the; // mangling changes for resume functions. It might also be the; // right thing to do in C++, but due to a limitation in LLVM's; // AsmPrinter we can only do this if the function doesn't have an; // abstract specification, since the DWARF backend expects the; // abstract specification to contain the linkage name and asserts; // that they are identical.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp:16,Security,sanitiz,sanitizer,16,// The function sanitizer metadata needs to match the signature of the; // function it is being attached to. However this does not hold for split; // functions here. Thus remove the metadata for split functions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp:107,Performance,optimiz,optimization,107,// Bootstrap attributes by copying function attributes from the; // original function. This should include optimization settings and so on.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp:84,Safety,safe,safely,84,"// All uses of the arguments should have been resolved by this point,; // so we can safely remove the dummy values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp:3,Modifiability,Rewrite,Rewrite,3,"// Rewrite final suspend handling as it is not done via switch (allows to; // remove final case from the switch, since it is undefined behavior to; // resume the coroutine suspended at the final suspend point.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp:151,Usability,resume,resume,151,"// Rewrite final suspend handling as it is not done via switch (allows to; // remove final case from the switch, since it is undefined behavior to; // resume the coroutine suspended at the final suspend point.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp:12,Usability,resume,resume,12,"// Create a resume clone by cloning the body of the original function, setting; // new entry block and replacing coro.suspend an appropriate value to force; // resume or cleanup pass for every suspend point.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp:160,Usability,resume,resume,160,"// Create a resume clone by cloning the body of the original function, setting; // new entry block and replacing coro.suspend an appropriate value to force; // resume or cleanup pass for every suspend point.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp:163,Usability,resume,resumers,163,"// Create a global constant array containing pointers to functions provided and; // set Info parameter of CoroBegin to point at this constant. Example:; //; // @f.resumers = internal constant [2 x void(%f.frame*)*]; // [void(%f.frame*)* @f.resume, void(%f.frame*)* @f.destroy]; // define void @f() {; // ...; // call i8* @llvm.coro.begin(i8* null, i32 0, i8* null,; // i8* bitcast([2 x void(%f.frame*)*] * @f.resumers to i8*)); //; // Assumes that all the functions have the same signature.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp:240,Usability,resume,resume,240,"// Create a global constant array containing pointers to functions provided and; // set Info parameter of CoroBegin to point at this constant. Example:; //; // @f.resumers = internal constant [2 x void(%f.frame*)*]; // [void(%f.frame*)* @f.resume, void(%f.frame*)* @f.destroy]; // define void @f() {; // ...; // call i8* @llvm.coro.begin(i8* null, i32 0, i8* null,; // i8* bitcast([2 x void(%f.frame*)*] * @f.resumers to i8*)); //; // Assumes that all the functions have the same signature.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp:409,Usability,resume,resumers,409,"// Create a global constant array containing pointers to functions provided and; // set Info parameter of CoroBegin to point at this constant. Example:; //; // @f.resumers = internal constant [2 x void(%f.frame*)*]; // [void(%f.frame*)* @f.resume, void(%f.frame*)* @f.destroy]; // define void @f() {; // ...; // call i8* @llvm.coro.begin(i8* null, i32 0, i8* null,; // i8* bitcast([2 x void(%f.frame*)*] * @f.resumers to i8*)); //; // Assumes that all the functions have the same signature.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp:3,Deployability,Update,Update,3,// Update coro.begin instruction to refer to this constant.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp:22,Usability,Resume,Resume,22,// Store addresses of Resume/Destroy/Cleanup functions in the coroutine frame.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp:23,Usability,simpl,simplify,23,// There is nothing to simplify.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp:210,Usability,simpl,simplifying,210,"// Handle the case the condition of the conditional branch is constant.; // e.g.,; //; // br i1 false, label %cleanup, label %CoroEnd; //; // It is possible during the transformation. We could continue the; // simplifying in this case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp:57,Energy Efficiency,reduce,reduced,57,"// If the case number of suspended switch instruction is reduced to; // 1, then it is simplified to CmpInst in llvm::ConstantFoldTerminator.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp:86,Usability,simpl,simplified,86,"// If the case number of suspended switch instruction is reduced to; // 1, then it is simplified to CmpInst in llvm::ConstantFoldTerminator.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp:47,Usability,resume,resume,47,// Match prototypes and calling conventions of resume function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp:23,Usability,resume,resume,23,// Add musttail to any resume instructions that is immediately followed by a; // suspend (i.e. ret). We do this even in -O0 to support guaranteed tail call; // for symmetrical coroutine control transfer (C++ Coroutines TS extension).; // This transformation is done only in the resume part of the coroutine that has; // identical signature and calling convention as the coro.resume call.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp:278,Usability,resume,resume,278,// Add musttail to any resume instructions that is immediately followed by a; // suspend (i.e. ret). We do this even in -O0 to support guaranteed tail call; // for symmetrical coroutine control transfer (C++ Coroutines TS extension).; // This transformation is done only in the resume part of the coroutine that has; // identical signature and calling convention as the coro.resume call.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp:375,Usability,resume,resume,375,// Add musttail to any resume instructions that is immediately followed by a; // suspend (i.e. ret). We do this even in -O0 to support guaranteed tail call; // for symmetrical coroutine control transfer (C++ Coroutines TS extension).; // This transformation is done only in the resume part of the coroutine that has; // identical signature and calling convention as the coro.resume call.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp:21,Usability,resume,resume,21,// Collect potential resume instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp:3,Usability,Simpl,SimplifySuspendPoint,3,"// SimplifySuspendPoint needs to check that there is no calls between; // coro_save and coro_suspend, since any of the calls may potentially resume; // the coroutine and if that is the case we cannot eliminate the suspend point.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp:141,Usability,resume,resume,141,"// SimplifySuspendPoint needs to check that there is no calls between; // coro_save and coro_suspend, since any of the calls may potentially resume; // the coroutine and if that is the case we cannot eliminate the suspend point.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp:32,Usability,resume,resume,32,// Assume that no intrinsic can resume the coroutine.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp:45,Usability,Resume,ResumeOrDestroy,45,// Any calls from begging of the block up to ResumeOrDestroy?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp:53,Usability,Resume,ResumeOrDestroyBB,53,// Any calls in all of the blocks between SaveBB and ResumeOrDestroyBB?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp:37,Usability,Resume,Resume,37,"// If a SuspendIntrin is preceded by Resume or Destroy, we can eliminate the; // suspend point and replace it with nornal control flow.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp:175,Performance,optimiz,optimization,175,"// See if the transformation is safe. Specifically, see if there are any; // calls in between Save and CallInstr. They can potenitally resume the; // coroutine rendering this optimization unsafe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp:32,Safety,safe,safe,32,"// See if the transformation is safe. Specifically, see if there are any; // calls in between Save and CallInstr. They can potenitally resume the; // coroutine rendering this optimization unsafe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp:188,Safety,unsafe,unsafe,188,"// See if the transformation is safe. Specifically, see if there are any; // calls in between Save and CallInstr. They can potenitally resume the; // coroutine rendering this optimization unsafe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp:135,Usability,resume,resume,135,"// See if the transformation is safe. Specifically, see if there are any; // calls in between Save and CallInstr. They can potenitally resume the; // coroutine rendering this optimization unsafe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp:84,Usability,resume,resume,84,// Replace llvm.coro.suspend with the value that results in resumption over; // the resume or cleanup path.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp:33,Usability,resume,resume,33,// No longer need a call to coro.resume or coro.destroy.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp:34,Usability,simpl,simplified,34,// Remove suspend points that are simplified.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp:23,Usability,simpl,simplification,23,"// Currently, the only simplification we do is switch-lowering-specific.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp:83,Usability,resume,resume,83,// Leave final.suspend to handleFinalSuspend since it is undefined behavior; // to resume a coroutine suspended at the final suspend point.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp:19,Usability,resume,resume,19,// Store addresses resume/destroy/cleanup functions in the coroutine frame.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp:40,Usability,resume,resume,40,"// Create a constant array referring to resume/destroy/clone functions pointed; // by the last argument of @llvm.coro.info, so that CoroElide pass can; // determined correct function to call.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp:30,Performance,optimiz,optimizations,30,"// Coerce the arguments, llvm optimizations seem to ignore the types in; // vaarg functions and throws away casts in optimized mode.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp:117,Performance,optimiz,optimized,117,"// Coerce the arguments, llvm optimizations seem to ignore the types in; // vaarg functions and throws away casts in optimized mode.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp:33,Performance,optimiz,optimizer,33,"// Reset various things that the optimizer might have decided it; // ""knows"" about the coroutine function due to not seeing a return.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp:42,Energy Efficiency,allocate,allocated,42,// Map all uses of llvm.coro.begin to the allocated frame pointer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp:30,Usability,resume,resume,30,// Replace the lvm.coro.async.resume intrisic call.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp:33,Performance,optimiz,optimizer,33,"// Reset various things that the optimizer might have decided it; // ""knows"" about the coroutine function due to not seeing a return.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp:3,Energy Efficiency,Allocate,Allocate,3,// Allocate the frame.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp:30,Deployability,update,update,30,// Allocate. We don't need to update the call graph node because we're; // going to recompute it from scratch after splitting.; // FIXME: pass the required alignment,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp:3,Energy Efficiency,Allocate,Allocate,3,// Allocate. We don't need to update the call graph node because we're; // going to recompute it from scratch after splitting.; // FIXME: pass the required alignment,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp:13,Energy Efficiency,allocate,allocated,13,// Stash the allocated frame pointer in the continuation storage.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp:42,Energy Efficiency,allocate,allocated,42,// Map all uses of llvm.coro.begin to the allocated frame pointer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp:5,Usability,resume,resume,5,/*in resume*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp:120,Deployability,update,update,120,"// Replace any remaining uses with the function as an i8*.; // This can never directly be a callee, so we don't need to update CG.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp:17,Deployability,pipeline,pipeline,17,// Run the CGSCC pipeline on the original and newly split functions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/Coroutines.cpp:54,Usability,resume,resume,54,"// Creates a call to llvm.coro.subfn.addr to obtain a resume function address.; // It generates the following:; //; // call ptr @llvm.coro.subfn.addr(ptr %Arg, i8 %index)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/Coroutines.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/Coroutines.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/Coroutines.cpp:9,Performance,optimiz,optimizations,9,"// After optimizations, coro_suspends using this coro_save might have; // been removed, remember orphaned coro_saves to remove them later.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/Coroutines.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/Coroutines.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/Coroutines.cpp:7,Performance,optimiz,optimizer,7,"// The optimizer likes to eliminate bitcasts leading into variadic; // calls, but that messes with our invariants. Re-insert the; // bitcast and ignore this type mismatch.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/Coroutines.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/Coroutines.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/Coroutines.cpp:57,Usability,resume,resume,57,// Check that the result type of the suspend matches the resume types.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/Coroutines.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/Coroutines.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/Coroutines.cpp:17,Security,validat,validation,17,// No meaningful validation to do here for llvm.coro.id.unique.once.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/Coroutines.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/Coroutines.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/HipStdPar/HipStdPar.cpp:1945,Energy Efficiency,allocate,allocated,1945,"ion exists in the form of; // a compute kernel, we assume that only the kernel, and all functions; // reachable from it, constitute code that the user expects the accelerator; // to execute. Thus, we identify the set of all functions reachable from; // kernels, and then remove all unreachable ones. This last part is necessary; // because it is possible for code that the user did not expect to execute on; // an accelerator to contain constructs that cannot be handled by the target; // BE, which cannot be provably demonstrated to be dead code in general, and; // thus can lead to mis-compilation. The degenerate case of this is when a; // Module contains no kernels (the parent TU had no algorithm invocations fit; // for acceleration), which we handle by completely emptying said module.; // **NOTE**: The above does not handle indirectly reachable functions i.e.; // it is possible to obtain a case where the target of an indirect; // call is otherwise unreachable and thus is removed; this; // restriction is aligned with the current `-hipstdpar` limitations; // and will be relaxed in the future.; //; // 2. AllocationInterposition (required only when on-demand paging is; // unsupported): Some accelerators or operating systems might not support; // transparent on-demand paging. Thus, they would only be able to access; // memory that is allocated by an accelerator-aware mechanism. For such cases; // the user can opt into enabling allocation / deallocation interposition,; // whereby we replace calls to known allocation / deallocation functions with; // calls to runtime implemented equivalents that forward the requests to; // accelerator-aware interfaces. We also support freeing system allocated; // memory that ends up in one of the runtime equivalents, since this can; // happen if e.g. a library that was compiled without interposition returns; // an allocation that can be validly passed to `free`.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/HipStdPar/HipStdPar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/HipStdPar/HipStdPar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/HipStdPar/HipStdPar.cpp:2299,Energy Efficiency,allocate,allocated,2299,"ion exists in the form of; // a compute kernel, we assume that only the kernel, and all functions; // reachable from it, constitute code that the user expects the accelerator; // to execute. Thus, we identify the set of all functions reachable from; // kernels, and then remove all unreachable ones. This last part is necessary; // because it is possible for code that the user did not expect to execute on; // an accelerator to contain constructs that cannot be handled by the target; // BE, which cannot be provably demonstrated to be dead code in general, and; // thus can lead to mis-compilation. The degenerate case of this is when a; // Module contains no kernels (the parent TU had no algorithm invocations fit; // for acceleration), which we handle by completely emptying said module.; // **NOTE**: The above does not handle indirectly reachable functions i.e.; // it is possible to obtain a case where the target of an indirect; // call is otherwise unreachable and thus is removed; this; // restriction is aligned with the current `-hipstdpar` limitations; // and will be relaxed in the future.; //; // 2. AllocationInterposition (required only when on-demand paging is; // unsupported): Some accelerators or operating systems might not support; // transparent on-demand paging. Thus, they would only be able to access; // memory that is allocated by an accelerator-aware mechanism. For such cases; // the user can opt into enabling allocation / deallocation interposition,; // whereby we replace calls to known allocation / deallocation functions with; // calls to runtime implemented equivalents that forward the requests to; // accelerator-aware interfaces. We also support freeing system allocated; // memory that ends up in one of the runtime equivalents, since this can; // happen if e.g. a library that was compiled without interposition returns; // an allocation that can be validly passed to `free`.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/HipStdPar/HipStdPar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/HipStdPar/HipStdPar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/HipStdPar/HipStdPar.cpp:2256,Integrability,interface,interfaces,2256,"ion exists in the form of; // a compute kernel, we assume that only the kernel, and all functions; // reachable from it, constitute code that the user expects the accelerator; // to execute. Thus, we identify the set of all functions reachable from; // kernels, and then remove all unreachable ones. This last part is necessary; // because it is possible for code that the user did not expect to execute on; // an accelerator to contain constructs that cannot be handled by the target; // BE, which cannot be provably demonstrated to be dead code in general, and; // thus can lead to mis-compilation. The degenerate case of this is when a; // Module contains no kernels (the parent TU had no algorithm invocations fit; // for acceleration), which we handle by completely emptying said module.; // **NOTE**: The above does not handle indirectly reachable functions i.e.; // it is possible to obtain a case where the target of an indirect; // call is otherwise unreachable and thus is removed; this; // restriction is aligned with the current `-hipstdpar` limitations; // and will be relaxed in the future.; //; // 2. AllocationInterposition (required only when on-demand paging is; // unsupported): Some accelerators or operating systems might not support; // transparent on-demand paging. Thus, they would only be able to access; // memory that is allocated by an accelerator-aware mechanism. For such cases; // the user can opt into enabling allocation / deallocation interposition,; // whereby we replace calls to known allocation / deallocation functions with; // calls to runtime implemented equivalents that forward the requests to; // accelerator-aware interfaces. We also support freeing system allocated; // memory that ends up in one of the runtime equivalents, since this can; // happen if e.g. a library that was compiled without interposition returns; // an allocation that can be validly passed to `free`.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/HipStdPar/HipStdPar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/HipStdPar/HipStdPar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/HipStdPar/HipStdPar.cpp:1919,Security,access,access,1919,"ion exists in the form of; // a compute kernel, we assume that only the kernel, and all functions; // reachable from it, constitute code that the user expects the accelerator; // to execute. Thus, we identify the set of all functions reachable from; // kernels, and then remove all unreachable ones. This last part is necessary; // because it is possible for code that the user did not expect to execute on; // an accelerator to contain constructs that cannot be handled by the target; // BE, which cannot be provably demonstrated to be dead code in general, and; // thus can lead to mis-compilation. The degenerate case of this is when a; // Module contains no kernels (the parent TU had no algorithm invocations fit; // for acceleration), which we handle by completely emptying said module.; // **NOTE**: The above does not handle indirectly reachable functions i.e.; // it is possible to obtain a case where the target of an indirect; // call is otherwise unreachable and thus is removed; this; // restriction is aligned with the current `-hipstdpar` limitations; // and will be relaxed in the future.; //; // 2. AllocationInterposition (required only when on-demand paging is; // unsupported): Some accelerators or operating systems might not support; // transparent on-demand paging. Thus, they would only be able to access; // memory that is allocated by an accelerator-aware mechanism. For such cases; // the user can opt into enabling allocation / deallocation interposition,; // whereby we replace calls to known allocation / deallocation functions with; // calls to runtime implemented equivalents that forward the requests to; // accelerator-aware interfaces. We also support freeing system allocated; // memory that ends up in one of the runtime equivalents, since this can; // happen if e.g. a library that was compiled without interposition returns; // an allocation that can be validly passed to `free`.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/HipStdPar/HipStdPar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/HipStdPar/HipStdPar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/HipStdPar/HipStdPar.cpp:9,Usability,simpl,simplify,9,// TODO: simplify.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/HipStdPar/HipStdPar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/HipStdPar/HipStdPar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp:96,Energy Efficiency,efficient,efficient,96,"/// Class representing coefficient of floating-point addend.; /// This class needs to be highly efficient, which is especially true for; /// the constructor. As of I write this comment, the cost of the default; /// constructor is merely 4-byte-store-zero (Assuming compiler is able to; /// perform write-merging).; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp:290,Performance,perform,perform,290,"/// Class representing coefficient of floating-point addend.; /// This class needs to be highly efficient, which is especially true for; /// the constructor. As of I write this comment, the cost of the default; /// constructor is merely 4-byte-store-zero (Assuming compiler is able to; /// perform write-merging).; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp:179,Safety,avoid,avoid,179,"// The constructor has to initialize a APFloat, which is unnecessary for; // most addends which have coefficient either 1 or -1. So, the constructor; // is expensive. In order to avoid the cost of the constructor, we should; // reuse some instances whenever possible. The pre-created instances; // FAddCombine::Add[0-5] embodies this idea.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp:88,Usability,simpl,simplify,88,"// The integer coefficient of an individual addend is either 1 or -1,; // and we try to simplify at most 4 addends from neighboring at most; // two instructions. So the range of <IntVal> falls in [-4, 4]. APInt; // is overkill of this end.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp:10,Availability,down,down,10,"/// Drill down the U-D chain one step to find the definition of V, and; /// try to break the definition into one or two addends.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp:33,Performance,optimiz,optimizing,33,/// FAddCombine is the class for optimizing an unsafe fadd/fsub along; /// with its neighboring at most two instructions.; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp:47,Safety,unsafe,unsafe,47,/// FAddCombine is the class for optimizing an unsafe fadd/fsub along; /// with its neighboring at most two instructions.; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp:18,Performance,optimiz,optimize,18,// Step 3: Try to optimize Opnd0_0 + Opnd0_1 + Opnd1_0 + Opnd1_1,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp:156,Performance,optimiz,optimized,156,"// The input instruction is : ""I=0.0 +/- V"". If the ""V"" were able to be; // splitted into two addends, say ""V = X - Y"", the instruction would have; // been optimized into ""I = Y - X"" in the previous steps.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp:18,Performance,optimiz,optimize,18,// step 4: Try to optimize Opnd0 + Opnd1_0 [+ Opnd1_1],MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp:18,Performance,optimiz,optimize,18,// step 5: Try to optimize Opnd1 + Opnd0_0 [+ Opnd0_1],MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp:3,Usability,Simpl,Simplified,3,// Simplified addends are placed <SimpVect>.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp:216,Performance,optimiz,optimization,216,"// If the resulting expr has constant-addend, this constant-addend is; // desirable to reside at the top of the resulting expression tree. Placing; // constant close to super-expr(s) will potentially reveal some; // optimization opportunities in super-expr(s). Here we do not implement; // this logic intentionally and rely on SimplifyAssociativeOrCommutative; // call later.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp:295,Testability,log,logic,295,"// If the resulting expr has constant-addend, this constant-addend is; // desirable to reside at the top of the resulting expression tree. Placing; // constant close to super-expr(s) will potentially reveal some; // optimization opportunities in super-expr(s). Here we do not implement; // this logic intentionally and rely on SimplifyAssociativeOrCommutative; // call later.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp:327,Usability,Simpl,SimplifyAssociativeOrCommutative,327,"// If the resulting expr has constant-addend, this constant-addend is; // desirable to reside at the top of the resulting expression tree. Placing; // constant close to super-expr(s) will potentially reveal some; // optimization opportunities in super-expr(s). Here we do not implement; // this logic intentionally and rely on SimplifyAssociativeOrCommutative; // call later.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp:201,Performance,optimiz,optimized,201,"// step 2: Emit the N-ary addition.; // Note that at most three instructions are involved in Fadd-InstCombine: the; // addition in question, and at most two neighboring instructions.; // The resulting optimized addition should have at least one less instruction; // than the original addition expression tree. This implies that the resulting; // N-ary addition has at most two instructions, and we don't need to worry; // about tree-height when constructing the N-ary addition.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp:89,Availability,avail,available,89,"// Let the addend be ""c * x"". If ""c == +/-1"", the value of the addend; // is immediately available; otherwise, it needs exactly one instruction; // to evaluate the value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp:4,Integrability,Wrap,Wrapping,4,/// Wrapping flags may allow combining constants separated by an extend.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp:65,Modifiability,extend,extend,65,/// Wrapping flags may allow combining constants separated by an extend.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp:6,Integrability,wrap,wrapping,6,"// If wrapping is not allowed, then the addition must set the sign bit:; // X + (signmask) --> X | signmask",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp:6,Integrability,wrap,wrapping,6,"// If wrapping is allowed, then the addition flips the sign bit of LHS:; // X + (signmask) --> X ^ signmask",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp:42,Availability,mask,mask,42,"// If X has no high-bits set above an xor mask:; // add (xor X, LowMaskC), C --> sub (LowMaskC + C), X",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp:19,Testability,log,logic,19,"// Look for a math+logic pattern that corresponds to sext-in-register of a; // value with cleared high bits. Convert that into a pair of shifts:; // add (xor X, 0x80), 0xF..F80 --> (X << ShAmtC) >>s ShAmtC; // add (xor X, 0xF..F80), 0x80 --> (X << ShAmtC) >>s ShAmtC",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp:90,Usability,clear,cleared,90,"// Look for a math+logic pattern that corresponds to sext-in-register of a; // value with cleared high bits. Convert that into a pair of shifts:; // add (xor X, 0x80), 0xF..F80 --> (X << ShAmtC) >>s ShAmtC; // add (xor X, 0xF..F80), 0x80 --> (X << ShAmtC) >>s ShAmtC",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp:35,Availability,mask,mask,35,"// Shifts and add used to flip and mask off the low bit:; // add (ashr (shl i32 X, 31), 31), 1 --> and (not X), 1",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp:223,Performance,perform,perform,223,"// match variations of a^2 + 2*a*b + b^2; //; // to reuse the code between the FP and Int versions, the instruction OpCodes; // and constant types have been turned into template parameters.; //; // Mul2Rhs: The constant to perform the multiplicative equivalent of X*2 with;; // should be `m_SpecificFP(2.0)` for FP and `m_SpecificInt(1)` for Int; // (we're matching `X<<1` instead of `X*2` for Int)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp:3,Usability,Simpl,Simplifies,3,"// Simplifies X % C0 + (( X / C0 ) % C1) * C0 to X % (C0 * C1), where (C0 * C1); // does not overflow.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp:11,Energy Efficiency,reduce,reduce,11,/// Try to reduce signed division by power-of-2 to an arithmetic shift right.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp:37,Energy Efficiency,power,power-of-,37,/// Try to reduce signed division by power-of-2 to an arithmetic shift right.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp:23,Energy Efficiency,power,power-of-,23,"// Division must be by power-of-2, but not the minimum signed value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp:69,Testability,log,logical,69,"// We have a subtraction/addition between a (potentially truncated) *logical*; // right-shift of X and a ""select"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp:175,Modifiability,extend,extended,175,"// Extraction should extract high NBits bits, with shift amount calculated as:; // low bits to skip = shift bitwidth - high bits to extract; // The shift amount itself may be extended, and we need to look past zero-ext; // when matching NBits, that will matter for matching later.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp:8,Modifiability,extend,extending,8,"// Sign-extending value can be zero-extended if we `sub`tract it,; // or sign-extended otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp:36,Modifiability,extend,extended,36,"// Sign-extending value can be zero-extended if we `sub`tract it,; // or sign-extended otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp:78,Modifiability,extend,extended,78,"// Sign-extending value can be zero-extended if we `sub`tract it,; // or sign-extended otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp:34,Modifiability,extend,extending,34,"// Now, finally validate the sign-extending magic.; // `select` itself may be appropriately extended, look past that.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp:92,Modifiability,extend,extended,92,"// Now, finally validate the sign-extending magic.; // `select` itself may be appropriately extended, look past that.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp:16,Security,validat,validate,16,"// Now, finally validate the sign-extending magic.; // `select` itself may be appropriately extended, look past that.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp:83,Modifiability,extend,extending,83,// It must be a select between two values we will later establish to be a; // sign-extending value and a zero constant. The condition guarding the; // sign-extension must be based on a sign bit of the same X we had in `lshr`.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp:20,Performance,perform,perform,20,// If we should not perform sign-extension then we must add/or/subtract zero.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp:137,Modifiability,extend,extended,137,"// Otherwise, it should be some constant, left-shifted by the same NBits we; // had in `lshr`. Said left-shift can also be appropriately extended.; // Again, we must look past zero-ext when looking for NBits.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp:6,Integrability,wrap,wrap,6,// No-wrap propagates only when all ops have no-wrap.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp:48,Integrability,wrap,wrap,48,// No-wrap propagates only when all ops have no-wrap.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp:25,Availability,mask,masked,25,/// Reduce a sequence of masked half-width multiplies to a single multiply.; /// ((XLow * YHigh) + (YLow * XHigh)) << HalfBits) + (XLow * YLow) --> X * Y,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp:4,Energy Efficiency,Reduce,Reduce,4,/// Reduce a sequence of masked half-width multiplies to a single multiply.; /// ((XLow * YHigh) + (YLow * XHigh)) << HalfBits) + (XLow * YLow) --> X * Y,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp:38,Safety,avoid,avoid,38,// Require one-use on the multiply to avoid increasing the number of; // multiplications.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp:138,Availability,robust,robustness,138,// XLo = X & HalfMask; // YLo = Y & HalfMask; // TODO: Refactor with SimplifyDemandedBits or KnownBits known leading zeros; // to enhance robustness,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp:55,Modifiability,Refactor,Refactor,55,// XLo = X & HalfMask; // YLo = Y & HalfMask; // TODO: Refactor with SimplifyDemandedBits or KnownBits known leading zeros; // to enhance robustness,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp:130,Modifiability,enhance,enhance,130,// XLo = X & HalfMask; // YLo = Y & HalfMask; // TODO: Refactor with SimplifyDemandedBits or KnownBits known leading zeros; // to enhance robustness,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp:69,Usability,Simpl,SimplifyDemandedBits,69,// XLo = X & HalfMask; // YLo = Y & HalfMask; // TODO: Refactor with SimplifyDemandedBits or KnownBits known leading zeros; // to enhance robustness,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp:91,Usability,simpl,simplifies,91,"// Canonicalize ((A & -A) - 1) --> ((A - 1) & ~A); // Forms all commutable operations, and simplifies ctpop -> cttz folds.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp:90,Energy Efficiency,reduce,reduce,90,// TODO(jingyue): Consider willNotOverflowSignedAdd and; // willNotOverflowUnsignedAdd to reduce the number of invocations of; // computeKnownBits.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp:250,Performance,load,load,250,"// (fadd double (sitofp x), fpcst) --> (sitofp (add int x, intcst)); // ... if the constant fits in the integer value. This is useful for things; // like (double)(x & 1234) + 4.0 -> (double)((X & 1234)+4) which no longer; // requires a constant pool load, and generally allows the add to be better; // instcombined.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp:137,Performance,optimiz,optimized,137,"// We cannot preserve ninf if nnan flag is not set.; // If X is NaN and Y is Inf then in original program we had NaN + NaN,; // while in optimized version NaN + Inf and this is a poison with ninf flag.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp:4,Performance,Optimiz,Optimize,4,"/// Optimize pointer differences into the same array into a size. Consider:; /// &A[10] - &A[0]: we should compile this to ""10"". LHS/RHS are the pointer; /// operands to the ptrtoint instructions for the LHS/RHS of the subtract.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp:69,Performance,optimiz,optimize,69,"// If LHS is a gep based on RHS or RHS is a gep based on LHS, we can optimize; // this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp:39,Safety,Avoid,Avoid,39,"// (gep X, ...) - (gep X, ...); //; // Avoid duplicating the arithmetic if there are more than one non-constant; // indices between the two GEPs and either GEP has a non-constant index and; // multiple users. If zero non-constant index, the result is a constant and; // there is no duplication. If one non-constant index, the result is an add; // or sub with a constant, which is no larger than the original code, and; // there's no duplicated arithmetic, even if either GEP has multiple; // users. If more than one non-constant indices combined, as long as the GEP; // with at least one non-constant index doesn't have multiple users, there; // is no duplication.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp:73,Energy Efficiency,reduce,reduce,73,// Reassociate sub/add sequences to create more add instructions and; // reduce dependency chains:; // ((X - Y) + Z) - Op1 --> (X + Z) - (Y + Op1),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp:80,Integrability,depend,dependency,80,// Reassociate sub/add sequences to create more add instructions and; // reduce dependency chains:; // ((X - Y) + Z) - Op1 --> (X + Z) - (Y + Op1),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp:3,Performance,Optimiz,Optimize,3,"// Optimize pointer differences into the same array into a size. Consider:; // &A[10] - &A[0]: we should compile this to ""10"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp:35,Availability,mask,masked,35,"// If we are subtracting a low-bit masked subset of some value from an add; // of that same value with no low bits changed, that is clearing some low bits; // of the sum:; // sub (X + AddC), (X & AndC) --> and (X + AddC), ~AndC",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp:132,Usability,clear,clearing,132,"// If we are subtracting a low-bit masked subset of some value from an add; // of that same value with no low bits changed, that is clearing some low bits; // of the sum:; // sub (X + AddC), (X & AndC) --> and (X + AddC), ~AndC",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp:3,Energy Efficiency,Reduce,Reduce,3,// Reduce multiplies for difference-of-squares by factoring:; // (X * X) - (Y * Y) --> (X + Y) * (X - Y),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp:43,Safety,safe,safe,43,"// Unlike most transforms, this one is not safe to propagate nsz unless; // it is present on the original select. We union the flags from the select; // and fneg and then remove nsz if needed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp:76,Energy Efficiency,reduce,reduce,76,// Reassociate fsub/fadd sequences to create more fadd instructions and; // reduce dependency chains:; // ((X - Y) + Z) - Op1 --> (X + Z) - (Y + Op1),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp:83,Integrability,depend,dependency,83,// Reassociate fsub/fadd sequences to create more fadd instructions and; // reduce dependency chains:; // ((X - Y) + Z) - Op1 --> (X + Z) - (Y + Op1),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp:14,Performance,perform,performs,14,// TODO: This performs reassociative folds for FP ops. Some fraction of the; // functionality has been subsumed by simple pattern matching here and in; // InstSimplify. We should let a dedicated reassociation pass handle more; // complex pattern matching and remove this from InstCombine.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp:115,Usability,simpl,simple,115,// TODO: This performs reassociative folds for FP ops. Some fraction of the; // functionality has been subsumed by simple pattern matching here and in; // InstSimplify. We should let a dedicated reassociation pass handle more; // complex pattern matching and remove this from InstCombine.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:147,Availability,mask,mask,147,"/// Classify (icmp eq (A & B), C) and (icmp ne (A & B), C) as matching patterns; /// that can be simplified.; /// One of A and B is considered the mask. The other is the value. This is; /// described as the ""AMask"" or ""BMask"" part of the enum. If the enum contains; /// only ""Mask"", then both A and B can be considered masks. If A is the mask,; /// then it was proven that (A & C) == C. This is trivial if C == A or C == 0.; /// If both A and C are constants, this proof is also easy.; /// For the following explanations, we assume that A is the mask.; ///; /// ""AllOnes"" declares that the comparison is true only if (A & B) == A or all; /// bits of A are set in B.; /// Example: (icmp eq (A & 3), 3) -> AMask_AllOnes; ///; /// ""AllZeros"" declares that the comparison is true only if (A & B) == 0 or all; /// bits of A are cleared in B.; /// Example: (icmp eq (A & 3), 0) -> Mask_AllZeroes; ///; /// ""Mixed"" declares that (A & B) == C and C might or might not contain any; /// number of one bits and zero bits.; /// Example: (icmp eq (A & 3), 1) -> AMask_Mixed; ///; /// ""Not"" means that in above descriptions ""=="" should be replaced by ""!="".; /// Example: (icmp ne (A & 3), 3) -> AMask_NotAllOnes; ///; /// If the mask A contains a single bit, then the following is equivalent:; /// (icmp eq (A & B), A) equals (icmp ne (A & B), 0); /// (icmp ne (A & B), A) equals (icmp eq (A & B), 0)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:276,Availability,Mask,Mask,276,"/// Classify (icmp eq (A & B), C) and (icmp ne (A & B), C) as matching patterns; /// that can be simplified.; /// One of A and B is considered the mask. The other is the value. This is; /// described as the ""AMask"" or ""BMask"" part of the enum. If the enum contains; /// only ""Mask"", then both A and B can be considered masks. If A is the mask,; /// then it was proven that (A & C) == C. This is trivial if C == A or C == 0.; /// If both A and C are constants, this proof is also easy.; /// For the following explanations, we assume that A is the mask.; ///; /// ""AllOnes"" declares that the comparison is true only if (A & B) == A or all; /// bits of A are set in B.; /// Example: (icmp eq (A & 3), 3) -> AMask_AllOnes; ///; /// ""AllZeros"" declares that the comparison is true only if (A & B) == 0 or all; /// bits of A are cleared in B.; /// Example: (icmp eq (A & 3), 0) -> Mask_AllZeroes; ///; /// ""Mixed"" declares that (A & B) == C and C might or might not contain any; /// number of one bits and zero bits.; /// Example: (icmp eq (A & 3), 1) -> AMask_Mixed; ///; /// ""Not"" means that in above descriptions ""=="" should be replaced by ""!="".; /// Example: (icmp ne (A & 3), 3) -> AMask_NotAllOnes; ///; /// If the mask A contains a single bit, then the following is equivalent:; /// (icmp eq (A & B), A) equals (icmp ne (A & B), 0); /// (icmp ne (A & B), A) equals (icmp eq (A & B), 0)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:319,Availability,mask,masks,319,"/// Classify (icmp eq (A & B), C) and (icmp ne (A & B), C) as matching patterns; /// that can be simplified.; /// One of A and B is considered the mask. The other is the value. This is; /// described as the ""AMask"" or ""BMask"" part of the enum. If the enum contains; /// only ""Mask"", then both A and B can be considered masks. If A is the mask,; /// then it was proven that (A & C) == C. This is trivial if C == A or C == 0.; /// If both A and C are constants, this proof is also easy.; /// For the following explanations, we assume that A is the mask.; ///; /// ""AllOnes"" declares that the comparison is true only if (A & B) == A or all; /// bits of A are set in B.; /// Example: (icmp eq (A & 3), 3) -> AMask_AllOnes; ///; /// ""AllZeros"" declares that the comparison is true only if (A & B) == 0 or all; /// bits of A are cleared in B.; /// Example: (icmp eq (A & 3), 0) -> Mask_AllZeroes; ///; /// ""Mixed"" declares that (A & B) == C and C might or might not contain any; /// number of one bits and zero bits.; /// Example: (icmp eq (A & 3), 1) -> AMask_Mixed; ///; /// ""Not"" means that in above descriptions ""=="" should be replaced by ""!="".; /// Example: (icmp ne (A & 3), 3) -> AMask_NotAllOnes; ///; /// If the mask A contains a single bit, then the following is equivalent:; /// (icmp eq (A & B), A) equals (icmp ne (A & B), 0); /// (icmp ne (A & B), A) equals (icmp eq (A & B), 0)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:338,Availability,mask,mask,338,"/// Classify (icmp eq (A & B), C) and (icmp ne (A & B), C) as matching patterns; /// that can be simplified.; /// One of A and B is considered the mask. The other is the value. This is; /// described as the ""AMask"" or ""BMask"" part of the enum. If the enum contains; /// only ""Mask"", then both A and B can be considered masks. If A is the mask,; /// then it was proven that (A & C) == C. This is trivial if C == A or C == 0.; /// If both A and C are constants, this proof is also easy.; /// For the following explanations, we assume that A is the mask.; ///; /// ""AllOnes"" declares that the comparison is true only if (A & B) == A or all; /// bits of A are set in B.; /// Example: (icmp eq (A & 3), 3) -> AMask_AllOnes; ///; /// ""AllZeros"" declares that the comparison is true only if (A & B) == 0 or all; /// bits of A are cleared in B.; /// Example: (icmp eq (A & 3), 0) -> Mask_AllZeroes; ///; /// ""Mixed"" declares that (A & B) == C and C might or might not contain any; /// number of one bits and zero bits.; /// Example: (icmp eq (A & 3), 1) -> AMask_Mixed; ///; /// ""Not"" means that in above descriptions ""=="" should be replaced by ""!="".; /// Example: (icmp ne (A & 3), 3) -> AMask_NotAllOnes; ///; /// If the mask A contains a single bit, then the following is equivalent:; /// (icmp eq (A & B), A) equals (icmp ne (A & B), 0); /// (icmp ne (A & B), A) equals (icmp eq (A & B), 0)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:546,Availability,mask,mask,546,"/// Classify (icmp eq (A & B), C) and (icmp ne (A & B), C) as matching patterns; /// that can be simplified.; /// One of A and B is considered the mask. The other is the value. This is; /// described as the ""AMask"" or ""BMask"" part of the enum. If the enum contains; /// only ""Mask"", then both A and B can be considered masks. If A is the mask,; /// then it was proven that (A & C) == C. This is trivial if C == A or C == 0.; /// If both A and C are constants, this proof is also easy.; /// For the following explanations, we assume that A is the mask.; ///; /// ""AllOnes"" declares that the comparison is true only if (A & B) == A or all; /// bits of A are set in B.; /// Example: (icmp eq (A & 3), 3) -> AMask_AllOnes; ///; /// ""AllZeros"" declares that the comparison is true only if (A & B) == 0 or all; /// bits of A are cleared in B.; /// Example: (icmp eq (A & 3), 0) -> Mask_AllZeroes; ///; /// ""Mixed"" declares that (A & B) == C and C might or might not contain any; /// number of one bits and zero bits.; /// Example: (icmp eq (A & 3), 1) -> AMask_Mixed; ///; /// ""Not"" means that in above descriptions ""=="" should be replaced by ""!="".; /// Example: (icmp ne (A & 3), 3) -> AMask_NotAllOnes; ///; /// If the mask A contains a single bit, then the following is equivalent:; /// (icmp eq (A & B), A) equals (icmp ne (A & B), 0); /// (icmp ne (A & B), A) equals (icmp eq (A & B), 0)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:1215,Availability,mask,mask,1215,"/// Classify (icmp eq (A & B), C) and (icmp ne (A & B), C) as matching patterns; /// that can be simplified.; /// One of A and B is considered the mask. The other is the value. This is; /// described as the ""AMask"" or ""BMask"" part of the enum. If the enum contains; /// only ""Mask"", then both A and B can be considered masks. If A is the mask,; /// then it was proven that (A & C) == C. This is trivial if C == A or C == 0.; /// If both A and C are constants, this proof is also easy.; /// For the following explanations, we assume that A is the mask.; ///; /// ""AllOnes"" declares that the comparison is true only if (A & B) == A or all; /// bits of A are set in B.; /// Example: (icmp eq (A & 3), 3) -> AMask_AllOnes; ///; /// ""AllZeros"" declares that the comparison is true only if (A & B) == 0 or all; /// bits of A are cleared in B.; /// Example: (icmp eq (A & 3), 0) -> Mask_AllZeroes; ///; /// ""Mixed"" declares that (A & B) == C and C might or might not contain any; /// number of one bits and zero bits.; /// Example: (icmp eq (A & 3), 1) -> AMask_Mixed; ///; /// ""Not"" means that in above descriptions ""=="" should be replaced by ""!="".; /// Example: (icmp ne (A & 3), 3) -> AMask_NotAllOnes; ///; /// If the mask A contains a single bit, then the following is equivalent:; /// (icmp eq (A & B), A) equals (icmp ne (A & B), 0); /// (icmp ne (A & B), A) equals (icmp eq (A & B), 0)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:97,Usability,simpl,simplified,97,"/// Classify (icmp eq (A & B), C) and (icmp ne (A & B), C) as matching patterns; /// that can be simplified.; /// One of A and B is considered the mask. The other is the value. This is; /// described as the ""AMask"" or ""BMask"" part of the enum. If the enum contains; /// only ""Mask"", then both A and B can be considered masks. If A is the mask,; /// then it was proven that (A & C) == C. This is trivial if C == A or C == 0.; /// If both A and C are constants, this proof is also easy.; /// For the following explanations, we assume that A is the mask.; ///; /// ""AllOnes"" declares that the comparison is true only if (A & B) == A or all; /// bits of A are set in B.; /// Example: (icmp eq (A & 3), 3) -> AMask_AllOnes; ///; /// ""AllZeros"" declares that the comparison is true only if (A & B) == 0 or all; /// bits of A are cleared in B.; /// Example: (icmp eq (A & 3), 0) -> Mask_AllZeroes; ///; /// ""Mixed"" declares that (A & B) == C and C might or might not contain any; /// number of one bits and zero bits.; /// Example: (icmp eq (A & 3), 1) -> AMask_Mixed; ///; /// ""Not"" means that in above descriptions ""=="" should be replaced by ""!="".; /// Example: (icmp ne (A & 3), 3) -> AMask_NotAllOnes; ///; /// If the mask A contains a single bit, then the following is equivalent:; /// (icmp eq (A & B), A) equals (icmp ne (A & B), 0); /// (icmp ne (A & B), A) equals (icmp eq (A & B), 0)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:823,Usability,clear,cleared,823,"/// Classify (icmp eq (A & B), C) and (icmp ne (A & B), C) as matching patterns; /// that can be simplified.; /// One of A and B is considered the mask. The other is the value. This is; /// described as the ""AMask"" or ""BMask"" part of the enum. If the enum contains; /// only ""Mask"", then both A and B can be considered masks. If A is the mask,; /// then it was proven that (A & C) == C. This is trivial if C == A or C == 0.; /// If both A and C are constants, this proof is also easy.; /// For the following explanations, we assume that A is the mask.; ///; /// ""AllOnes"" declares that the comparison is true only if (A & B) == A or all; /// bits of A are set in B.; /// Example: (icmp eq (A & 3), 3) -> AMask_AllOnes; ///; /// ""AllZeros"" declares that the comparison is true only if (A & B) == 0 or all; /// bits of A are cleared in B.; /// Example: (icmp eq (A & 3), 0) -> Mask_AllZeroes; ///; /// ""Mixed"" declares that (A & B) == C and C might or might not contain any; /// number of one bits and zero bits.; /// Example: (icmp eq (A & 3), 1) -> AMask_Mixed; ///; /// ""Not"" means that in above descriptions ""=="" should be replaced by ""!="".; /// Example: (icmp ne (A & 3), 3) -> AMask_NotAllOnes; ///; /// If the mask A contains a single bit, then the following is equivalent:; /// (icmp eq (A & B), A) equals (icmp ne (A & B), 0); /// (icmp ne (A & B), A) equals (icmp eq (A & B), 0)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:37,Availability,Mask,MaskedICmpType,37,"/// Return the set of patterns (from MaskedICmpType) that (icmp SCC (A & B), C); /// satisfies.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:46,Availability,mask,mask,46,"// if C is zero, then both A and B qualify as mask",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:29,Availability,mask,masked,29,"/// Convert an analysis of a masked ICmp into its equivalent if all boolean; /// operations had the opposite sense. Since each ""NotXXX"" flag (recording !=); /// is adjacent to the corresponding normal flag (recording ==), this just; /// involves swapping those bits over.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:3,Energy Efficiency,Adapt,Adapts,3,// Adapts the external decomposeBitTestICmp for local use.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:3,Modifiability,Adapt,Adapts,3,// Adapts the external decomposeBitTestICmp for local use.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:98,Availability,Mask,MaskedICmpType,98,"/// Handle (icmp(A & B) ==/!= C) &/| (icmp(A & D) ==/!= E).; /// Return the pattern classes (from MaskedICmpType) for the left hand side and; /// the right hand side as a pair.; /// LHS and RHS are the left hand side and the right hand side ICmps and PredL; /// and PredR are their predicates, respectively.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:55,Testability,test,test,55,// Check whether the icmp can be decomposed into a bit test.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:45,Availability,mask,masked,45,"// Any icmp can be viewed as being trivially masked; if it allows us to; // remove one, it's worth it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:23,Availability,mask,mask,23,"// As before, model no mask as a trivial mask if it'll let us do an; // optimization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:41,Availability,mask,mask,41,"// As before, model no mask as a trivial mask if it'll let us do an; // optimization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:72,Performance,optimiz,optimization,72,"// As before, model no mask as a trivial mask if it'll let us do an; // optimization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:349,Safety,safe,safe,349,"/// Try to fold (icmp(A & B) ==/!= C) &/| (icmp(A & D) ==/!= E) into a single; /// (icmp(A & X) ==/!= Y), where the left-hand side is of type Mask_NotAllZeros; /// and the right hand side is of type BMask_Mixed. For example,; /// (icmp (A & 12) != 0) & (icmp (A & 15) == 8) -> (icmp (A & 15) == 8).; /// Also used for logical and/or, must be poison safe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:318,Testability,log,logical,318,"/// Try to fold (icmp(A & B) ==/!= C) &/| (icmp(A & D) ==/!= E) into a single; /// (icmp(A & X) ==/!= Y), where the left-hand side is of type Mask_NotAllZeros; /// and the right hand side is of type BMask_Mixed. For example,; /// (icmp (A & 12) != 0) & (icmp (A & 15) == 8) -> (icmp (A & 15) == 8).; /// Also used for logical and/or, must be poison safe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:3,Deployability,Update,Update,3,"// Update E to the canonical form when D is a power of two and RHS is; // canonicalized as,; // (icmp ne (A & D), 0) -> (icmp eq (A & D), D) or; // (icmp ne (A & D), D) -> (icmp eq (A & D), 0).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:46,Energy Efficiency,power,power,46,"// Update E to the canonical form when D is a power of two and RHS is; // canonicalized as,; // (icmp ne (A & D), 0) -> (icmp eq (A & D), D) or; // (icmp ne (A & D), D) -> (icmp eq (A & D), 0).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:55,Availability,mask,mask,55,"// If the following two conditions are met:; //; // 1. mask B covers only a single bit that's not covered by mask D, that is,; // (B & (B ^ D)) is a power of 2 (in other words, B minus the intersection of; // B and D has only one bit set) and,; //; // 2. RHS (and E) indicates that the rest of B's bits are zero (in other; // words, the intersection of B and D is zero), that is, ((B & D) & E) == 0; //; // then that single bit in B must be one and thus the whole expression can be; // folded to; // (A & (B | D)) == (B & (B ^ D)) | E.; //; // For example,; // (icmp ne (A & 12), 0) & (icmp eq (A & 7), 1) -> (icmp eq (A & 15), 9); // (icmp ne (A & 15), 0) & (icmp eq (A & 7), 0) -> (icmp eq (A & 15), 8)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:109,Availability,mask,mask,109,"// If the following two conditions are met:; //; // 1. mask B covers only a single bit that's not covered by mask D, that is,; // (B & (B ^ D)) is a power of 2 (in other words, B minus the intersection of; // B and D has only one bit set) and,; //; // 2. RHS (and E) indicates that the rest of B's bits are zero (in other; // words, the intersection of B and D is zero), that is, ((B & D) & E) == 0; //; // then that single bit in B must be one and thus the whole expression can be; // folded to; // (A & (B | D)) == (B & (B ^ D)) | E.; //; // For example,; // (icmp ne (A & 12), 0) & (icmp eq (A & 7), 1) -> (icmp eq (A & 15), 9); // (icmp ne (A & 15), 0) & (icmp eq (A & 7), 0) -> (icmp eq (A & 15), 8)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:149,Energy Efficiency,power,power,149,"// If the following two conditions are met:; //; // 1. mask B covers only a single bit that's not covered by mask D, that is,; // (B & (B ^ D)) is a power of 2 (in other words, B minus the intersection of; // B and D has only one bit set) and,; //; // 2. RHS (and E) indicates that the rest of B's bits are zero (in other; // words, the intersection of B and D is zero), that is, ((B & D) & E) == 0; //; // then that single bit in B must be one and thus the whole expression can be; // folded to; // (A & (B | D)) == (B & (B ^ D)) | E.; //; // For example,; // (icmp ne (A & 12), 0) & (icmp eq (A & 7), 1) -> (icmp eq (A & 15), 9); // (icmp ne (A & 15), 0) & (icmp eq (A & 7), 0) -> (icmp eq (A & 15), 8)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:181,Availability,mask,mask,181,"/// Try to fold (icmp(A & B) ==/!= 0) &/| (icmp(A & D) ==/!= E) into a single; /// (icmp(A & X) ==/!= Y), where the left-hand side and the right hand side; /// aren't of the common mask pattern type.; /// Also used for logical and/or, must be poison safe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:250,Safety,safe,safe,250,"/// Try to fold (icmp(A & B) ==/!= 0) &/| (icmp(A & D) ==/!= E) into a single; /// (icmp(A & X) ==/!= Y), where the left-hand side and the right hand side; /// aren't of the common mask pattern type.; /// Also used for logical and/or, must be poison safe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:219,Testability,log,logical,219,"/// Try to fold (icmp(A & B) ==/!= 0) &/| (icmp(A & D) ==/!= E) into a single; /// (icmp(A & X) ==/!= Y), where the left-hand side and the right hand side; /// aren't of the common mask pattern type.; /// Also used for logical and/or, must be poison safe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:15,Availability,mask,masking,15,// Convert the masking analysis into its equivalent with negated; // comparisons.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:66,Integrability,depend,depend,66,"// Remaining cases assume at least that B and D are constant, and depend on; // their actual values. This isn't strictly necessary, just a ""handle the; // easy cases for now"" decision.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:180,Availability,mask,masks,180,"// (icmp ne (A & B), 0) & (icmp ne (A & D), 0) and; // (icmp ne (A & B), B) & (icmp ne (A & D), D); // -> (icmp ne (A & B), 0) or (icmp ne (A & D), 0); // Only valid if one of the masks is a superset of the other (check ""B&D"" is; // the same as either B or D).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:128,Availability,mask,masks,128,"// (icmp ne (A & B), B) & (icmp ne (A & D), D); // -> (icmp ne (A & B), A) or (icmp ne (A & D), A); // Only valid if one of the masks is a superset of the other (check ""B|D"" is; // the same as either B or D).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:221,Availability,mask,mask,221,"// Mixed:; // (icmp eq (A & B), C) & (icmp eq (A & D), E); // We already know that B & C == C && D & E == E.; // If we can prove that (B & D) & (C ^ E) == 0, that is, the bits of; // C and E, which are shared by both the mask B and the mask D, don't; // contradict, then we can transform to; // -> (icmp eq (A & (B|D)), (C|E)); // Currently, we only handle the case of B, C, D, and E being constant.; // We can't simply use C and E because we might actually handle; // (icmp ne (A & B), B) & (icmp eq (A & D), D); // with B and D, having a single bit set.; // NotMixed:; // (icmp ne (A & B), C) & (icmp ne (A & D), E); // -> (icmp ne (A & (B & D)), (C & E)); // Check the intersection (B & D) for inequality.; // Assume that (B & D) == B || (B & D) == D, i.e B/D is a subset of D/B; // and (B & D) & (C ^ E) == 0, bits of C and E, which are shared by both the; // B and the D, don't contradict.; // Note that we can assume (~B & C) == 0 && (~D & E) == 0, previous; // operation should delete these icmps if it hadn't been met.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:236,Availability,mask,mask,236,"// Mixed:; // (icmp eq (A & B), C) & (icmp eq (A & D), E); // We already know that B & C == C && D & E == E.; // If we can prove that (B & D) & (C ^ E) == 0, that is, the bits of; // C and E, which are shared by both the mask B and the mask D, don't; // contradict, then we can transform to; // -> (icmp eq (A & (B|D)), (C|E)); // Currently, we only handle the case of B, C, D, and E being constant.; // We can't simply use C and E because we might actually handle; // (icmp ne (A & B), B) & (icmp eq (A & D), D); // with B and D, having a single bit set.; // NotMixed:; // (icmp ne (A & B), C) & (icmp ne (A & D), E); // -> (icmp ne (A & (B & D)), (C & E)); // Check the intersection (B & D) for inequality.; // Assume that (B & D) == B || (B & D) == D, i.e B/D is a subset of D/B; // and (B & D) & (C ^ E) == 0, bits of C and E, which are shared by both the; // B and the D, don't contradict.; // Note that we can assume (~B & C) == 0 && (~D & E) == 0, previous; // operation should delete these icmps if it hadn't been met.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:413,Usability,simpl,simply,413,"// Mixed:; // (icmp eq (A & B), C) & (icmp eq (A & D), E); // We already know that B & C == C && D & E == E.; // If we can prove that (B & D) & (C ^ E) == 0, that is, the bits of; // C and E, which are shared by both the mask B and the mask D, don't; // contradict, then we can transform to; // -> (icmp eq (A & (B|D)), (C|E)); // Currently, we only handle the case of B, C, D, and E being constant.; // We can't simply use C and E because we might actually handle; // (icmp ne (A & B), B) & (icmp eq (A & D), D); // with B and D, having a single bit set.; // NotMixed:; // (icmp ne (A & B), C) & (icmp ne (A & D), E); // -> (icmp ne (A & (B & D)), (C & E)); // Check the intersection (B & D) for inequality.; // Assume that (B & D) == B || (B & D) == D, i.e B/D is a subset of D/B; // and (B & D) & (C ^ E) == 0, bits of C and E, which are shared by both the; // B and the D, don't contradict.; // Note that we can assume (~B & C) == 0 && (~D & E) == 0, previous; // operation should delete these icmps if it hadn't been met.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:8,Usability,simpl,simplification,8,// This simplification is only valid if the upper range is not negative.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:16,Testability,log,logical,16,"// If this is a logical and/or, then we must prevent propagation of a; // poison value from the RHS by inserting freeze.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:99,Availability,mask,mask,99,"/// General pattern:; /// X & Y; ///; /// Where Y is checking that all the high bits (covered by a mask 4294967168); /// are uniform, i.e. %arg & 4294967168 can be either 4294967168 or 0; /// Pattern can be one of:; /// %t = add i32 %arg, 128; /// %r = icmp ult i32 %t, 256; /// Or; /// %t0 = shl i32 %arg, 24; /// %t1 = ashr i32 %t0, 24; /// %r = icmp eq i32 %t1, %arg; /// Or; /// %t0 = trunc i32 %arg to i8; /// %t1 = sext i8 %t0 to i32; /// %r = icmp eq i32 %t1, %arg; /// This pattern is a signed truncation check.; ///; /// And X is checking that some bit in that same mask is zero.; /// I.e. can be one of:; /// %r = icmp sgt i32 %arg, -1; /// Or; /// %t = and i32 %arg, 2147483648; /// %r = icmp eq i32 %t, 0; ///; /// Since we are checking that all the bits in that mask are the same,; /// and a particular bit is zero, what we are really checking is that all the; /// masked bits are zero.; /// So this should be transformed to:; /// %r = icmp ult i32 %arg, 128",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:575,Availability,mask,mask,575,"/// General pattern:; /// X & Y; ///; /// Where Y is checking that all the high bits (covered by a mask 4294967168); /// are uniform, i.e. %arg & 4294967168 can be either 4294967168 or 0; /// Pattern can be one of:; /// %t = add i32 %arg, 128; /// %r = icmp ult i32 %t, 256; /// Or; /// %t0 = shl i32 %arg, 24; /// %t1 = ashr i32 %t0, 24; /// %r = icmp eq i32 %t1, %arg; /// Or; /// %t0 = trunc i32 %arg to i8; /// %t1 = sext i8 %t0 to i32; /// %r = icmp eq i32 %t1, %arg; /// This pattern is a signed truncation check.; ///; /// And X is checking that some bit in that same mask is zero.; /// I.e. can be one of:; /// %r = icmp sgt i32 %arg, -1; /// Or; /// %t = and i32 %arg, 2147483648; /// %r = icmp eq i32 %t, 0; ///; /// Since we are checking that all the bits in that mask are the same,; /// and a particular bit is zero, what we are really checking is that all the; /// masked bits are zero.; /// So this should be transformed to:; /// %r = icmp ult i32 %arg, 128",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:775,Availability,mask,mask,775,"/// General pattern:; /// X & Y; ///; /// Where Y is checking that all the high bits (covered by a mask 4294967168); /// are uniform, i.e. %arg & 4294967168 can be either 4294967168 or 0; /// Pattern can be one of:; /// %t = add i32 %arg, 128; /// %r = icmp ult i32 %t, 256; /// Or; /// %t0 = shl i32 %arg, 24; /// %t1 = ashr i32 %t0, 24; /// %r = icmp eq i32 %t1, %arg; /// Or; /// %t0 = trunc i32 %arg to i8; /// %t1 = sext i8 %t0 to i32; /// %r = icmp eq i32 %t1, %arg; /// This pattern is a signed truncation check.; ///; /// And X is checking that some bit in that same mask is zero.; /// I.e. can be one of:; /// %r = icmp sgt i32 %arg, -1; /// Or; /// %t = and i32 %arg, 2147483648; /// %r = icmp eq i32 %t, 0; ///; /// Since we are checking that all the bits in that mask are the same,; /// and a particular bit is zero, what we are really checking is that all the; /// masked bits are zero.; /// So this should be transformed to:; /// %r = icmp ult i32 %arg, 128",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:878,Availability,mask,masked,878,"/// General pattern:; /// X & Y; ///; /// Where Y is checking that all the high bits (covered by a mask 4294967168); /// are uniform, i.e. %arg & 4294967168 can be either 4294967168 or 0; /// Pattern can be one of:; /// %t = add i32 %arg, 128; /// %r = icmp ult i32 %t, 256; /// Or; /// %t0 = shl i32 %arg, 24; /// %t1 = ashr i32 %t0, 24; /// %r = icmp eq i32 %t1, %arg; /// Or; /// %t0 = trunc i32 %arg to i8; /// %t1 = sext i8 %t0 to i32; /// %r = icmp eq i32 %t1, %arg; /// This pattern is a signed truncation check.; ///; /// And X is checking that some bit in that same mask is zero.; /// I.e. can be one of:; /// %r = icmp sgt i32 %arg, -1; /// Or; /// %t = and i32 %arg, 2147483648; /// %r = icmp eq i32 %t, 0; ///; /// Since we are checking that all the bits in that mask are the same,; /// and a particular bit is zero, what we are really checking is that all the; /// masked bits are zero.; /// So this should be transformed to:; /// %r = icmp ult i32 %arg, 128",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:55,Energy Efficiency,power,powers,55,"// Match icmp ult (add %arg, C01), C1 (C1 == C01 << 1; powers of two)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:3,Energy Efficiency,power,powers,3,// powers of two; I1 == I01 << 1,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:45,Availability,Mask,Mask,45,"// Try to match/decompose into: icmp eq (X & Mask), 0",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:42,Availability,Mask,Mask,42,"// Can it be decomposed into icmp eq (X & Mask), 0 ?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:22,Availability,Mask,Mask,22,"// Is it icmp eq (X & Mask), 0 already?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:58,Testability,test,test,58,// And the other icmp needs to be decomposable into a bit test.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:202,Safety,safe,safe,202,"/// Fold (icmp eq ctpop(X) 1) | (icmp eq X 0) into (icmp ult ctpop(X) 2) and; /// fold (icmp ne ctpop(X) 1) & (icmp ne X 0) into (icmp ugt ctpop(X) 1).; /// Also used for logical and/or, must be poison safe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:171,Testability,log,logical,171,"/// Fold (icmp eq ctpop(X) 1) | (icmp eq X 0) into (icmp ult ctpop(X) 2) and; /// fold (icmp ne ctpop(X) 1) & (icmp ne X 0) into (icmp ugt ctpop(X) 1).; /// Also used for logical and/or, must be poison safe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:4,Energy Efficiency,Reduce,Reduce,4,"/// Reduce a pair of compares that check if a value has exactly 1 bit set.; /// Also used for logical and/or, must be poison safe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:125,Safety,safe,safe,125,"/// Reduce a pair of compares that check if a value has exactly 1 bit set.; /// Also used for logical and/or, must be poison safe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:94,Testability,log,logical,94,"/// Reduce a pair of compares that check if a value has exactly 1 bit set.; /// Also used for logical and/or, must be poison safe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:308,Availability,mask,masking,308,"/// Try to fold (icmp(A & B) == 0) & (icmp(A & D) != E) into (icmp A u< D) iff; /// B is a contiguous set of ones starting from the most significant bit; /// (negative power of 2), D and E are equal, and D is a contiguous set of ones; /// starting at the most significant zero bit in B. Parameter B supports masking; /// using undef/poison in either scalar or vector values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:168,Energy Efficiency,power,power,168,"/// Try to fold (icmp(A & B) == 0) & (icmp(A & D) != E) into (icmp A u< D) iff; /// B is a contiguous set of ones starting from the most significant bit; /// (negative power of 2), D and E are equal, and D is a contiguous set of ones; /// starting at the most significant zero bit in B. Parameter B supports masking; /// using undef/poison in either scalar or vector values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:579,Availability,mask,mask,579,"// Test scalar arguments for conversion. B has been validated earlier to be a; // negative power of two and thus is guaranteed to have one or more contiguous; // ones starting from the MSB followed by zero or more contiguous zeros. D has; // been validated earlier to be a shifted set of one or more contiguous ones.; // In order to match, B leading ones and D leading zeros should be equal. The; // predicate that B be a negative power of 2 prevents the condition of there; // ever being zero leading ones. Thus 0 == 0 cannot occur. The predicate that; // D always be a shifted mask prevents the condition of D equaling 0. This; // prevents matching the condition where B contains the maximum number of; // leading one bits (-1) and D contains the maximum number of leading zero; // bits (0).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:91,Energy Efficiency,power,power,91,"// Test scalar arguments for conversion. B has been validated earlier to be a; // negative power of two and thus is guaranteed to have one or more contiguous; // ones starting from the MSB followed by zero or more contiguous zeros. D has; // been validated earlier to be a shifted set of one or more contiguous ones.; // In order to match, B leading ones and D leading zeros should be equal. The; // predicate that B be a negative power of 2 prevents the condition of there; // ever being zero leading ones. Thus 0 == 0 cannot occur. The predicate that; // D always be a shifted mask prevents the condition of D equaling 0. This; // prevents matching the condition where B contains the maximum number of; // leading one bits (-1) and D contains the maximum number of leading zero; // bits (0).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:431,Energy Efficiency,power,power,431,"// Test scalar arguments for conversion. B has been validated earlier to be a; // negative power of two and thus is guaranteed to have one or more contiguous; // ones starting from the MSB followed by zero or more contiguous zeros. D has; // been validated earlier to be a shifted set of one or more contiguous ones.; // In order to match, B leading ones and D leading zeros should be equal. The; // predicate that B be a negative power of 2 prevents the condition of there; // ever being zero leading ones. Thus 0 == 0 cannot occur. The predicate that; // D always be a shifted mask prevents the condition of D equaling 0. This; // prevents matching the condition where B contains the maximum number of; // leading one bits (-1) and D contains the maximum number of leading zero; // bits (0).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:52,Security,validat,validated,52,"// Test scalar arguments for conversion. B has been validated earlier to be a; // negative power of two and thus is guaranteed to have one or more contiguous; // ones starting from the MSB followed by zero or more contiguous zeros. D has; // been validated earlier to be a shifted set of one or more contiguous ones.; // In order to match, B leading ones and D leading zeros should be equal. The; // predicate that B be a negative power of 2 prevents the condition of there; // ever being zero leading ones. Thus 0 == 0 cannot occur. The predicate that; // D always be a shifted mask prevents the condition of D equaling 0. This; // prevents matching the condition where B contains the maximum number of; // leading one bits (-1) and D contains the maximum number of leading zero; // bits (0).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:247,Security,validat,validated,247,"// Test scalar arguments for conversion. B has been validated earlier to be a; // negative power of two and thus is guaranteed to have one or more contiguous; // ones starting from the MSB followed by zero or more contiguous zeros. D has; // been validated earlier to be a shifted set of one or more contiguous ones.; // In order to match, B leading ones and D leading zeros should be equal. The; // predicate that B be a negative power of 2 prevents the condition of there; // ever being zero leading ones. Thus 0 == 0 cannot occur. The predicate that; // D always be a shifted mask prevents the condition of D equaling 0. This; // prevents matching the condition where B contains the maximum number of; // leading one bits (-1) and D contains the maximum number of leading zero; // bits (0).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:3,Testability,Test,Test,3,"// Test scalar arguments for conversion. B has been validated earlier to be a; // negative power of two and thus is guaranteed to have one or more contiguous; // ones starting from the MSB followed by zero or more contiguous zeros. D has; // been validated earlier to be a shifted set of one or more contiguous ones.; // In order to match, B leading ones and D leading zeros should be equal. The; // predicate that B be a negative power of 2 prevents the condition of there; // ever being zero leading ones. Thus 0 == 0 cannot occur. The predicate that; // D always be a shifted mask prevents the condition of D equaling 0. This; // prevents matching the condition where B contains the maximum number of; // leading one bits (-1) and D contains the maximum number of leading zero; // bits (0).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:3,Testability,Test,Test,3,// Test vector type arguments for conversion.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:3,Testability,Test,Test,3,// Test scalar type arguments for conversion.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:186,Availability,mask,mask,186,"/// Try to fold ((icmp X u< P) & (icmp(X & M) != M)) or ((icmp X s> -1) &; /// (icmp(X & M) != M)) into (icmp X u< M). Where P is a power of 2, M < P, and; /// M is a contiguous shifted mask starting at the right most significant zero; /// bit in P. SGT is supported as when P is the largest representable power of; /// 2, an earlier optimization converts the expression into (icmp X s> -1).; /// Parameter P supports masking using undef/poison in either scalar or vector; /// values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:418,Availability,mask,masking,418,"/// Try to fold ((icmp X u< P) & (icmp(X & M) != M)) or ((icmp X s> -1) &; /// (icmp(X & M) != M)) into (icmp X u< M). Where P is a power of 2, M < P, and; /// M is a contiguous shifted mask starting at the right most significant zero; /// bit in P. SGT is supported as when P is the largest representable power of; /// 2, an earlier optimization converts the expression into (icmp X s> -1).; /// Parameter P supports masking using undef/poison in either scalar or vector; /// values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:132,Energy Efficiency,power,power,132,"/// Try to fold ((icmp X u< P) & (icmp(X & M) != M)) or ((icmp X s> -1) &; /// (icmp(X & M) != M)) into (icmp X u< M). Where P is a power of 2, M < P, and; /// M is a contiguous shifted mask starting at the right most significant zero; /// bit in P. SGT is supported as when P is the largest representable power of; /// 2, an earlier optimization converts the expression into (icmp X s> -1).; /// Parameter P supports masking using undef/poison in either scalar or vector; /// values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:306,Energy Efficiency,power,power,306,"/// Try to fold ((icmp X u< P) & (icmp(X & M) != M)) or ((icmp X s> -1) &; /// (icmp(X & M) != M)) into (icmp X u< M). Where P is a power of 2, M < P, and; /// M is a contiguous shifted mask starting at the right most significant zero; /// bit in P. SGT is supported as when P is the largest representable power of; /// 2, an earlier optimization converts the expression into (icmp X s> -1).; /// Parameter P supports masking using undef/poison in either scalar or vector; /// values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:334,Performance,optimiz,optimization,334,"/// Try to fold ((icmp X u< P) & (icmp(X & M) != M)) or ((icmp X s> -1) &; /// (icmp(X & M) != M)) into (icmp X u< M). Where P is a power of 2, M < P, and; /// M is a contiguous shifted mask starting at the right most significant zero; /// bit in P. SGT is supported as when P is the largest representable power of; /// 2, an earlier optimization converts the expression into (icmp X s> -1).; /// Parameter P supports masking using undef/poison in either scalar or vector; /// values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:167,Deployability,A/B,A/B,167,"// Given ZeroCmpOp = (A + B); // ZeroCmpOp < A && ZeroCmpOp != 0 --> (0-X) < Y iff; // ZeroCmpOp >= A || ZeroCmpOp == 0 --> (0-X) >= Y iff; // with X being the value (A/B) that is known to be non-zero,; // and Y being remaining value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:43,Performance,optimiz,optimized,43,"// (icmp eq (lshr x, C), (lshr y, C)) gets optimized to:; // (icmp ult (xor x, y), 1 << C) so also look for that.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:43,Performance,optimiz,optimized,43,"// (icmp ne (lshr x, C), (lshr y, C)) gets optimized to:; // (icmp ugt (xor x, y), (1 << C) - 1) so also look for that.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:10,Usability,simpl,simplify,10,// We can simplify to a comparison of these larger parts of the integers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:4,Energy Efficiency,Reduce,Reduce,4,/// Reduce logic-of-compares with equality to a constant by substituting a; /// common operand with the constant. Callers are expected to call this with; /// Cmp0/Cmp1 switched to handle logic op commutativity.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:11,Testability,log,logic-of-compares,11,/// Reduce logic-of-compares with equality to a constant by substituting a; /// common operand with the constant. Callers are expected to call this with; /// Cmp0/Cmp1 switched to handle logic op commutativity.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:187,Testability,log,logic,187,/// Reduce logic-of-compares with equality to a constant by substituting a; /// common operand with the constant. Callers are expected to call this with; /// Cmp0/Cmp1 switched to handle logic op commutativity.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:124,Safety,avoid,avoid,124,"// Match an equality compare with a non-poison constant as Cmp0.; // Also, give up if the compare can be constant-folded to avoid looping.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:11,Modifiability,variab,variable,11,// Replace variable with constant value equivalence to remove a variable use:; // (X == C) && (Y Pred1 X) --> (X == C) && (Y Pred1 C); // (X != C) || (Y Pred1 X) --> (X != C) || (Y Pred1 C); // Can think of the 'or' substitution with the 'and' bool equivalent:; // A || B --> A || (!A && B),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:64,Modifiability,variab,variable,64,// Replace variable with constant value equivalence to remove a variable use:; // (X == C) && (Y Pred1 X) --> (X == C) && (Y Pred1 C); // (X != C) || (Y Pred1 X) --> (X != C) || (Y Pred1 C); // Can think of the 'or' substitution with the 'and' bool equivalent:; // A || B --> A || (!A && B),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:224,Safety,safe,safe,224,"/// Fold (icmp Pred1 V1, C1) & (icmp Pred2 V2, C2); /// or (icmp Pred1 V1, C1) | (icmp Pred2 V2, C2); /// into a single comparison using range-based reasoning.; /// NOTE: This is also used for logical and/or, must be poison-safe!",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:193,Testability,log,logical,193,"/// Fold (icmp Pred1 V1, C1) & (icmp Pred2 V2, C2); /// or (icmp Pred1 V1, C1) | (icmp Pred2 V2, C2); /// into a single comparison using range-based reasoning.; /// NOTE: This is also used for logical and/or, must be poison-safe!",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:104,Availability,mask,mask,104,// Check whether we have equal-size ranges that only differ by one bit.; // In that case we can apply a mask to map one range onto the other.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:195,Testability,test,testing,195,"// Simplify (fcmp cc0 x, y) & (fcmp cc1 x, y).; // Suppose the relation between x and y is R, where R is one of; // U(1000), L(0100), G(0010) or E(0001), and CC0 and CC1 are the bitmasks for; // testing the desired relations.; //; // Since (R & CC0) and (R & CC1) are either R or 0, we actually have this:; // bool(R & CC0) && bool(R & CC1); // = bool((R & CC0) & (R & CC1)); // = bool(R & (CC0 & CC1)) <= by re-association, commutation, and idempotency; //; // Since (R & CC0) and (R & CC1) are either R or 0, we actually have this:; // bool(R & CC0) || bool(R & CC1); // = bool((R & CC0) | (R & CC1)); // = bool(R & (CC0 | CC1)) <= by reversed distribution (contribution? ;)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:3,Usability,Simpl,Simplify,3,"// Simplify (fcmp cc0 x, y) & (fcmp cc1 x, y).; // Suppose the relation between x and y is R, where R is one of; // U(1000), L(0100), G(0010) or E(0001), and CC0 and CC1 are the bitmasks for; // testing the desired relations.; //; // Since (R & CC0) and (R & CC1) are either R or 0, we actually have this:; // bool(R & CC0) && bool(R & CC1); // = bool((R & CC0) & (R & CC1)); // = bool(R & (CC0 & CC1)) <= by re-association, commutation, and idempotency; //; // Since (R & CC0) and (R & CC1) are either R or 0, we actually have this:; // bool(R & CC0) || bool(R & CC1); // = bool((R & CC0) | (R & CC1)); // = bool(R & (CC0 | CC1)) <= by reversed distribution (contribution? ;)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:94,Testability,log,logical,94,// Intersect the fast math flags.; // TODO: We can union the fast math flags unless this is a logical select.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:37,Testability,log,logical,37,// This transform is not valid for a logical select.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:109,Testability,test,test,109,"// Turn at least two fcmps with constants into llvm.is.fpclass.; //; // If we can represent a combined value test with one class call, we can; // potentially eliminate 4-6 instructions. If we can represent a test with a; // single fcmp with fneg and fabs, that's likely a better canonical form.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:208,Testability,test,test,208,"// Turn at least two fcmps with constants into llvm.is.fpclass.; //; // If we can represent a combined value test with one class call, we can; // potentially eliminate 4-6 instructions. If we can represent a test with a; // single fcmp with fneg and fabs, that's likely a better canonical form.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:47,Performance,perform,performs,47,/// Match an fcmp against a special value that performs a test possible by; /// llvm.is.fpclass.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:58,Testability,test,test,58,/// Match an fcmp against a special value that performs a test possible by; /// llvm.is.fpclass.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:181,Modifiability,rewrite,rewrite,181,"/// Look for the pattern that conditionally negates a value via math operations:; /// cond.splat = sext i1 cond; /// sub = add cond.splat, x; /// xor = xor sub, cond.splat; /// and rewrite it to do the same, but via logical operations:; /// value.neg = sub 0, value; /// cond = select i1 neg, value.neg, value",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:216,Testability,log,logical,216,"/// Look for the pattern that conditionally negates a value via math operations:; /// cond.splat = sext i1 cond; /// sub = add cond.splat, x; /// xor = xor sub, cond.splat; /// and rewrite it to do the same, but via logical operations:; /// value.neg = sub 0, value; /// cond = select i1 neg, value.neg, value",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:287,Testability,log,logic,287,"/// This a limited reassociation for a special case (see above) where we are; /// checking if two values are either both NAN (unordered) or not-NAN (ordered).; /// This could be handled more generally in '-reassociation', but it seems like; /// an unlikely pattern for a large number of logic ops and fcmps.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:83,Testability,log,logic,83,// There are 4 commuted variants of the pattern. Canonicalize operands of this; // logic op so an fcmp is operand 0 and a matching logic op is operand 1.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:131,Testability,log,logic,131,// There are 4 commuted variants of the pattern. Canonicalize operands of this; // logic op so an fcmp is operand 0 and a matching logic op is operand 1.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:13,Testability,log,logic,13,// The inner logic op must have a matching fcmp operand.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:12,Testability,log,logic,12,// Flip the logic operation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:113,Performance,Perform,Performing,113,"// Move the logic operation ahead of a zext or sext if the constant is; // unchanged in the smaller source type. Performing the logic in a smaller; // type may provide more information to later folds, and the smaller logic; // instruction may be cheaper (particularly in the case of vectors).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:12,Testability,log,logic,12,"// Move the logic operation ahead of a zext or sext if the constant is; // unchanged in the smaller source type. Performing the logic in a smaller; // type may provide more information to later folds, and the smaller logic; // instruction may be cheaper (particularly in the case of vectors).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:128,Testability,log,logic,128,"// Move the logic operation ahead of a zext or sext if the constant is; // unchanged in the smaller source type. Performing the logic in a smaller; // type may provide more information to later folds, and the smaller logic; // instruction may be cheaper (particularly in the case of vectors).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:217,Testability,log,logic,217,"// Move the logic operation ahead of a zext or sext if the constant is; // unchanged in the smaller source type. Performing the logic in a smaller; // type may provide more information to later folds, and the smaller logic; // instruction may be cheaper (particularly in the case of vectors).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:3,Testability,Log,LogicOpc,3,"// LogicOpc (zext X), C --> zext (LogicOpc X, C)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:34,Testability,Log,LogicOpc,34,"// LogicOpc (zext X), C --> zext (LogicOpc X, C)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:3,Testability,Log,LogicOpc,3,"// LogicOpc (sext X), C --> sext (LogicOpc X, C)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:34,Testability,Log,LogicOpc,34,"// LogicOpc (sext X), C --> sext (LogicOpc X, C)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:104,Testability,log,logic,104,// This must be a cast from an integer or integer vector source type to allow; // transformation of the logic operation to the source type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:24,Testability,log,logic,24,// Both operands of the logic operation are casts. The casts must be the; // same kind for reduction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:64,Modifiability,extend,extends,64,"// If the source types do not match, but the casts are matching extends, we; // can still narrow the logic op.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:101,Testability,log,logic,101,"// If the source types do not match, but the casts are matching extends, we; // can still narrow the logic op.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:10,Testability,log,logic,10,"// Do the logic op in the intermediate width, then widen more.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:8,Testability,log,logic,8,"// fold logic(cast(A), cast(B)) -> cast(logic(A, B))",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:40,Testability,log,logic,40,"// fold logic(cast(A), cast(B)) -> cast(logic(A, B))",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:56,Safety,safe,safe,56,"// If we're narrowing a shift, the shift amount must be safe (less than the; // width) in the narrower type. If the shift amount is greater, instsimplify; // usually handles that case, but we can't guarantee/assert it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:208,Testability,assert,assert,208,"// If we're narrowing a shift, the shift amount must be safe (less than the; // width) in the narrower type. If the shift amount is greater, instsimplify; // usually handles that case, but we can't guarantee/assert it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:12,Testability,log,logic,12,// Flip the logic operation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:94,Testability,log,logic,94,// Match; // (X + C2) | C; // (X + C2) ^ C; // (X + C2) & C; // and convert to do the bitwise logic first:; // (X | C) + C2; // (X ^ C) + C2; // (X & C) + C2; // iff bits affected by logic op are lower than last bit affected by math op,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:183,Testability,log,logic,183,// Match; // (X + C2) | C; // (X + C2) ^ C; // (X + C2) & C; // and convert to do the bitwise logic first:; // (X | C) + C2; // (X ^ C) + C2; // (X & C) + C2; // iff bits affected by logic op are lower than last bit affected by math op,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:3,Safety,Avoid,Avoid,3,// Avoid constant expressions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:17,Usability,simpl,simplify,17,// See if we can simplify any instructions used by the instruction whose sole; // purpose is to compute bits we don't care about.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:51,Usability,simpl,simple,51,// Do this before using distributive laws to catch simple and/or/not patterns.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:58,Energy Efficiency,power,power,58,// Canonicalize:; // (X +/- Y) & Y --> ~X & Y when Y is a power of 2.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:103,Availability,mask,mask,103,"// (X | C1) & C2 --> (X & C2^(C1&C2)) | (C1&C2); // NOTE: This reduces the number of bits set in the & mask, which; // can expose opportunities for store narrowing for scalars.; // NOTE: SimplifyDemandedBits should have already removed bits from C1; // that aren't set in C2. Meaning we can replace (C1&C2) with C1 in; // above, but this feels safer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:63,Energy Efficiency,reduce,reduces,63,"// (X | C1) & C2 --> (X & C2^(C1&C2)) | (C1&C2); // NOTE: This reduces the number of bits set in the & mask, which; // can expose opportunities for store narrowing for scalars.; // NOTE: SimplifyDemandedBits should have already removed bits from C1; // that aren't set in C2. Meaning we can replace (C1&C2) with C1 in; // above, but this feels safer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:344,Safety,safe,safer,344,"// (X | C1) & C2 --> (X & C2^(C1&C2)) | (C1&C2); // NOTE: This reduces the number of bits set in the & mask, which; // can expose opportunities for store narrowing for scalars.; // NOTE: SimplifyDemandedBits should have already removed bits from C1; // that aren't set in C2. Meaning we can replace (C1&C2) with C1 in; // above, but this feels safer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:123,Security,expose,expose,123,"// (X | C1) & C2 --> (X & C2^(C1&C2)) | (C1&C2); // NOTE: This reduces the number of bits set in the & mask, which; // can expose opportunities for store narrowing for scalars.; // NOTE: SimplifyDemandedBits should have already removed bits from C1; // that aren't set in C2. Meaning we can replace (C1&C2) with C1 in; // above, but this feels safer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:187,Usability,Simpl,SimplifyDemandedBits,187,"// (X | C1) & C2 --> (X & C2^(C1&C2)) | (C1&C2); // NOTE: This reduces the number of bits set in the & mask, which; // can expose opportunities for store narrowing for scalars.; // NOTE: SimplifyDemandedBits should have already removed bits from C1; // that aren't set in C2. Meaning we can replace (C1&C2) with C1 in; // above, but this feels safer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:10,Usability,clear,clearing,10,"// We are clearing high bits that were potentially set by sext+ashr:; // and (sext (ashr X, ShiftC)), C --> lshr (sext X), ShiftC",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:17,Usability,clear,clears,17,"// If this 'and' clears the sign-bits added by ashr, replace with lshr:; // and (ashr X, ShiftC), C --> lshr X, ShiftC",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:13,Availability,mask,masking,13,"// If we are masking the result of the add down to exactly one bit and; // the constant we are adding has no bits set below that bit, then the; // add is flipping a single bit. Example:; // (X + 4) & 4 --> (X & 4) ^ 4",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:43,Availability,down,down,43,"// If we are masking the result of the add down to exactly one bit and; // the constant we are adding has no bits set below that bit, then the; // add is flipping a single bit. Example:; // (X + 4) & 4 --> (X & 4) ^ 4",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:28,Availability,mask,mask,28,"// Similar to above: if the mask matches the zext input width, then the; // 'and' can be eliminated, so we can truncate the other variable op:; // and (bo (zext X), Y), C --> zext (bo X, (trunc Y))",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:130,Modifiability,variab,variable,130,"// Similar to above: if the mask matches the zext input width, then the; // 'and' can be eliminated, so we can truncate the other variable op:; // and (bo (zext X), Y), C --> zext (bo X, (trunc Y))",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:150,Availability,mask,mask,150,"// This is intentionally placed after the narrowing transforms for; // efficiency (transform directly to the narrow logic op if possible).; // If the mask is only needed on one incoming arm, push the 'and' op up.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:116,Testability,log,logic,116,"// This is intentionally placed after the narrowing transforms for; // efficiency (transform directly to the narrow logic op if possible).; // If the mask is only needed on one incoming arm, push the 'and' op up.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:7,Availability,mask,masking,7,"// Not masking anything out for the LHS, move mask to RHS.; // and ({x}or X, Y), C --> {x}or X, (and Y, C)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:46,Availability,mask,mask,46,"// Not masking anything out for the LHS, move mask to RHS.; // and ({x}or X, Y), C --> {x}or X, (and Y, C)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:7,Availability,mask,masking,7,"// Not masking anything out for the RHS, move mask to LHS.; // and ({x}or X, Y), C --> {x}or (and X, C), Y",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:46,Availability,mask,mask,46,"// Not masking anything out for the RHS, move mask to LHS.; // and ({x}or X, Y), C --> {x}or (and X, C), Y",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:12,Availability,mask,mask,12,"// When the mask is a power-of-2 constant and op0 is a shifted-power-of-2; // constant, test if the shift amount equals the offset bit index:; // (ShiftC << X) & C --> X == (log2(C) - log2(ShiftC)) ? C : 0; // (ShiftC >> X) & C --> X == (log2(ShiftC) - log2(C)) ? C : 0",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:22,Energy Efficiency,power,power-of-,22,"// When the mask is a power-of-2 constant and op0 is a shifted-power-of-2; // constant, test if the shift amount equals the offset bit index:; // (ShiftC << X) & C --> X == (log2(C) - log2(ShiftC)) ? C : 0; // (ShiftC >> X) & C --> X == (log2(ShiftC) - log2(C)) ? C : 0",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:63,Energy Efficiency,power,power-of-,63,"// When the mask is a power-of-2 constant and op0 is a shifted-power-of-2; // constant, test if the shift amount equals the offset bit index:; // (ShiftC << X) & C --> X == (log2(C) - log2(ShiftC)) ? C : 0; // (ShiftC >> X) & C --> X == (log2(ShiftC) - log2(C)) ? C : 0",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:88,Testability,test,test,88,"// When the mask is a power-of-2 constant and op0 is a shifted-power-of-2; // constant, test if the shift amount equals the offset bit index:; // (ShiftC << X) & C --> X == (log2(C) - log2(ShiftC)) ? C : 0; // (ShiftC >> X) & C --> X == (log2(ShiftC) - log2(C)) ? C : 0",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:13,Usability,clear,clearing,13,"// If we are clearing the sign bit of a floating-point value, convert this to; // fabs, then cast back to integer.; //; // This is a generous interpretation for noimplicitfloat, this is not a true; // floating-point operation.; //; // Assumes any IEEE-represented type has the sign bit in the high bit.; // TODO: Unify with APInt matcher. This version allows undef unlike m_APInt",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:62,Availability,mask,mask,62,"// We must be careful with the undef elements of the sign bit mask, however:; // the mask elt can be undef iff the shift amount for that lane was undef,; // otherwise we need to sanitize undef masks to zero.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:85,Availability,mask,mask,85,"// We must be careful with the undef elements of the sign bit mask, however:; // the mask elt can be undef iff the shift amount for that lane was undef,; // otherwise we need to sanitize undef masks to zero.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:193,Availability,mask,masks,193,"// We must be careful with the undef elements of the sign bit mask, however:; // the mask elt can be undef iff the shift amount for that lane was undef,; // otherwise we need to sanitize undef masks to zero.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:178,Security,sanitiz,sanitize,178,"// We must be careful with the undef elements of the sign bit mask, however:; // the mask elt can be undef iff the shift amount for that lane was undef,; // otherwise we need to sanitize undef masks to zero.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:13,Safety,safe,safe,13,/// Match UB-safe variants of the funnel shift intrinsic.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:16,Energy Efficiency,reduce,reduce,16,// TODO: Can we reduce the code duplication between this and the related; // rotate matching code under visitSelect and visitTrunc?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:58,Availability,mask,masks,58,// For non-constant cases we don't support non-pow2 shift masks.; // TODO: Is it worth matching urem as well?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:27,Availability,mask,masked,27,"// The shift amount may be masked with negation:; // (shl ShVal, (X & (Width - 1))) | (lshr ShVal, ((-X) & (Width - 1)))",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:64,Availability,mask,masking,64,"// Similar to above, but the shift amount may be extended after masking,; // so return the extended value as the parameter for the intrinsic.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:49,Modifiability,extend,extended,49,"// Similar to above, but the shift amount may be extended after masking,; // so return the extended value as the parameter for the intrinsic.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:91,Modifiability,extend,extended,91,"// Similar to above, but the shift amount may be extended after masking,; // so return the extended value as the parameter for the intrinsic.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:45,Modifiability,variab,variables,45,"// If there are two 'or' instructions concat variables in opposite order:; //; // Slot1 and Slot2 are all zero bits.; // | Slot1 | Low | Slot2 | High |; // LowHigh = or (shl (zext Low), ZextLowShlAmt), (zext High); // | Slot2 | High | Slot1 | Low |; // HighLow = or (shl (zext High), ZextHighShlAmt), (zext Low); //; // the latter 'or' can be safely convert to; // -> HighLow = fshl LowHigh, LowHigh, ZextHighShlAmt; // if ZextLowShlAmt + ZextHighShlAmt == Width.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:343,Safety,safe,safely,343,"// If there are two 'or' instructions concat variables in opposite order:; //; // Slot1 and Slot2 are all zero bits.; // | Slot1 | Low | Slot2 | High |; // LowHigh = or (shl (zext Low), ZextLowShlAmt), (zext High); // | Slot2 | High | Slot1 | Low |; // HighLow = or (shl (zext High), ZextHighShlAmt), (zext Low); //; // the latter 'or' can be safely convert to; // -> HighLow = fshl LowHigh, LowHigh, ZextHighShlAmt; // if ZextLowShlAmt + ZextHighShlAmt == Width.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:26,Availability,down,down,26,"// BSWAP: Push the concat down, swapping the lower/upper sources.; // concat(bswap(x),bswap(y)) -> bswap(concat(x,y))",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:31,Availability,down,down,31,"// BITREVERSE: Push the concat down, swapping the lower/upper sources.; // concat(bitreverse(x),bitreverse(y)) -> bitreverse(concat(x,y))",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:244,Safety,detect,detect,244,"/// We have an expression of the form (A & C) | (B & D). If A is a scalar or; /// vector composed of all-zeros or all-ones values and is the bitwise 'not' of; /// B, it can be used as the condition operand of a select instruction.; /// We will detect (A & C) | ~(B | D) when the flag ABIsTheSame enabled.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:155,Safety,safe,safe,155,"// If we look through a vector bitcast, the caller will bitcast the operands; // to match the condition's number of bits (N x i1).; // To make this poison-safe, disallow bitcast from wide element to narrow; // element. That could allow poison in lanes where it was not present in the; // original code.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:155,Testability,log,logic,155,"// A = sext i1 Cond; B = not ({bitcast} (sext (i1 Cond))); // TODO: The one-use checks are unnecessary or misplaced. If the caller; // checked for uses on logic ops/casts, that should be enough to; // make this transform worthwhile.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:64,Usability,simpl,simplify,64,"/// We have an expression of the form (A & C) | (B & D). Try to simplify this; /// to ""A' ? C : D"", where A' is a boolean or vector of booleans.; /// When InvertFalseVal is set to true, we try to match the pattern; /// where we have peeked through a 'not' op and A and B are the same:; /// (A & C) | ~(A | D) --> (A & C) | (~A & ~D) --> A' ? C : ~D",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:18,Performance,scalab,scalable,18,// For a fixed or scalable vector get N from <{vscale x} N x iM>,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:18,Performance,scalab,scalable,18,"// For a fixed or scalable vector, get the size in bits of N x iM; for a; // scalar this is just M.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:152,Safety,safe,safe,152,"/// Fold (icmp)&(icmp) or (icmp)|(icmp) if possible.; /// If IsLogical is true, then the and/or is in select form and the transform; /// must be poison-safe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:182,Availability,mask,mask,182,// Fold (iszero(A & K1) | iszero(A & K2)) -> (A & (K1 | K2)) != (K1 | K2); // Fold (!iszero(A & K1) & !iszero(A & K2)) -> (A & (K1 | K2)) == (K1 | K2); // if K1 and K2 are a one-bit mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:16,Testability,log,logical,16,"// We can treat logical like bitwise here, because both operands are used on; // the LHS, and as such poison from both will propagate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:46,Testability,log,logical,46,"// TODO: One of these directions is fine with logical and/or, the other could; // be supported by inserting freeze.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:53,Safety,safe,safe,53,"// TODO: Add conjugated or fold, check whether it is safe for logical and/or.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:62,Testability,log,logical,62,"// TODO: Add conjugated or fold, check whether it is safe for logical and/or.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:32,Safety,safe,safe,32,// TODO: Verify whether this is safe for logical and/or.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:41,Testability,log,logical,41,// TODO: Verify whether this is safe for logical and/or.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:17,Usability,simpl,simplify,17,// See if we can simplify any instructions used by the instruction whose sole; // purpose is to compute bits we don't care about.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:51,Usability,simpl,simple,51,// Do this before using distributive laws to catch simple and/or/not patterns.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:14,Availability,Mask,MaskC,14,// ((X | B) & MaskC) | (B & ~MaskC) -> (X & MaskC) | B,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:29,Availability,Mask,MaskC,29,// ((X | B) & MaskC) | (B & ~MaskC) -> (X & MaskC) | B,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:44,Availability,Mask,MaskC,44,// ((X | B) & MaskC) | (B & ~MaskC) -> (X & MaskC) | B,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:8,Availability,Mask,MaskC,8,// (A & MaskC) | ((X | A) & ~MaskC) -> (X & ~MaskC) | A,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:29,Availability,Mask,MaskC,29,// (A & MaskC) | ((X | A) & ~MaskC) -> (X & ~MaskC) | A,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:45,Availability,Mask,MaskC,45,// (A & MaskC) | ((X | A) & ~MaskC) -> (X & ~MaskC) | A,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:14,Availability,Mask,MaskC,14,// ((X ^ B) & MaskC) | (B & ~MaskC) -> (X & MaskC) ^ B,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:29,Availability,Mask,MaskC,29,// ((X ^ B) & MaskC) | (B & ~MaskC) -> (X & MaskC) ^ B,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:44,Availability,Mask,MaskC,44,// ((X ^ B) & MaskC) | (B & ~MaskC) -> (X & MaskC) ^ B,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:8,Availability,Mask,MaskC,8,// (A & MaskC) | ((X ^ A) & ~MaskC) -> (X & ~MaskC) ^ A,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:29,Availability,Mask,MaskC,29,// (A & MaskC) | ((X ^ A) & ~MaskC) -> (X & ~MaskC) ^ A,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:45,Availability,Mask,MaskC,45,// (A & MaskC) | ((X ^ A) & ~MaskC) -> (X & ~MaskC) ^ A,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:99,Usability,simpl,simplified,99,"// Note: If we've gotten to the point of visiting the outer OR, then the; // inner one couldn't be simplified. If it was a constant, then it won't; // be simplified by a later pass either, so we try swapping the inner/outer; // ORs in the hopes that we'll be able to simplify it this way.; // (X|C) | V --> (X|V) | C",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:154,Usability,simpl,simplified,154,"// Note: If we've gotten to the point of visiting the outer OR, then the; // inner one couldn't be simplified. If it was a constant, then it won't; // be simplified by a later pass either, so we try swapping the inner/outer; // ORs in the hopes that we'll be able to simplify it this way.; // (X|C) | V --> (X|V) | C",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:267,Usability,simpl,simplify,267,"// Note: If we've gotten to the point of visiting the outer OR, then the; // inner one couldn't be simplified. If it was a constant, then it won't; // be simplified by a later pass either, so we try swapping the inner/outer; // ORs in the hopes that we'll be able to simplify it this way.; // (X|C) | V --> (X|V) | C",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:106,Performance,optimiz,optimized,106,"// Change (or (bool?A:B),(bool?C:D)) --> (bool?(or A,C):(or B,D)); // Since this OR statement hasn't been optimized further yet, we hope; // that this transformation will allow the new ORs to be optimized.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:195,Performance,optimiz,optimized,195,"// Change (or (bool?A:B),(bool?C:D)) --> (bool?(or A,C):(or B,D)); // Since this OR statement hasn't been optimized further yet, we hope; // that this transformation will allow the new ORs to be optimized.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:24,Availability,mask,mask,24,"// Improve ""get low bit mask up to and including bit X"" pattern:; // (1 << X) | ((1 << X) + -1) --> -1 l>> (bitwidth(x) - 1 - X)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:84,Deployability,A/B,A/B,84,// (A & B) | (C | D) or (C | D) | (A & B); // Can be combined if C or D is of type (A/B & X),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:108,Energy Efficiency,efficient,efficiently,108,/// A ^ B can be specified using other logic ops in a variety of patterns. We; /// can fold these early and efficiently by morphing an existing instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:39,Testability,log,logic,39,/// A ^ B can be specified using other logic ops in a variety of patterns. We; /// can fold these early and efficiently by morphing an existing instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:107,Modifiability,enhance,enhanced,107,// TODO: This can be generalized to compares of non-signbits using; // decomposeBitTestICmp(). It could be enhanced more by using (something like); // foldLogOpOfMaskedICmps().,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:26,Testability,test,tests,26,// Convert xor of signbit tests to signbit test of xor'd values:; // (X > -1) ^ (Y > -1) --> (X ^ Y) < 0; // (X < 0) ^ (Y < 0) --> (X ^ Y) < 0; // (X > -1) ^ (Y < 0) --> (X ^ Y) > -1; // (X < 0) ^ (Y > -1) --> (X ^ Y) > -1,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:43,Testability,test,test,43,// Convert xor of signbit tests to signbit test of xor'd values:; // (X > -1) ^ (Y > -1) --> (X ^ Y) < 0; // (X < 0) ^ (Y < 0) --> (X ^ Y) < 0; // (X > -1) ^ (Y < 0) --> (X ^ Y) > -1; // (X < 0) ^ (Y > -1) --> (X ^ Y) > -1,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:90,Testability,log,logic,90,"// Instead of trying to imitate the folds for and/or, decompose this 'xor'; // into those logic ops. That is, try to turn this into an and-of-icmps; // because we have many folds for that pattern.; //; // This is based on a truth table definition of xor:; // X ^ Y --> (X | Y) & !(X & Y)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:55,Usability,simpl,simplifies,55,"// TODO: If OrICmp is true, then the definition of xor simplifies to !(X&Y).; // TODO: If OrICmp is false, the whole thing is false (InstSimplify?).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:14,Energy Efficiency,adapt,adapt,14,"// We need to adapt other uses of Y though. Get a value that matches; // the original value of Y before inversion. While this increases; // immediate instruction count, we have just ensured that all the; // users are freely-invertible, so that 'not' *will* get folded away.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:14,Modifiability,adapt,adapt,14,"// We need to adapt other uses of Y though. Get a value that matches; // the original value of Y before inversion. While this increases; // immediate instruction count, we have just ensured that all the; // users are freely-invertible, so that 'not' *will* get folded away.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:17,Availability,mask,masked,17,"/// If we have a masked merge, in the canonical form of:; /// (assuming that A only has one use.); /// | A | |B|; /// ((x ^ y) & M) ^ y; /// | D |; /// * If M is inverted:; /// | D |; /// ((x ^ y) & ~M) ^ y; /// We can canonicalize by swapping the final xor operand; /// to eliminate the 'not' of the mask.; /// ((x ^ y) & M) ^ x; /// * If M is a constant, and D has one use, we transform to 'and' / 'or' ops; /// because that shortens the dependency chain and improves analysis:; /// (x & M) | (y & ~M)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:301,Availability,mask,mask,301,"/// If we have a masked merge, in the canonical form of:; /// (assuming that A only has one use.); /// | A | |B|; /// ((x ^ y) & M) ^ y; /// | D |; /// * If M is inverted:; /// | D |; /// ((x ^ y) & ~M) ^ y; /// We can canonicalize by swapping the final xor operand; /// to eliminate the 'not' of the mask.; /// ((x ^ y) & M) ^ x; /// * If M is a constant, and D has one use, we transform to 'and' / 'or' ops; /// because that shortens the dependency chain and improves analysis:; /// (x & M) | (y & ~M)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:440,Integrability,depend,dependency,440,"/// If we have a masked merge, in the canonical form of:; /// (assuming that A only has one use.); /// | A | |B|; /// ((x ^ y) & M) ^ y; /// | D |; /// * If M is inverted:; /// | D |; /// ((x ^ y) & ~M) ^ y; /// We can canonicalize by swapping the final xor operand; /// to eliminate the 'not' of the mask.; /// ((x ^ y) & M) ^ x; /// * If M is a constant, and D has one use, we transform to 'and' / 'or' ops; /// because that shortens the dependency chain and improves analysis:; /// (x & M) | (y & ~M)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:17,Availability,mask,mask,17,// De-invert the mask and swap the value in B part.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:24,Safety,unsafe,unsafe,24,// Propagating undef is unsafe. Clamp undef elements to -1.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:138,Deployability,update,updated,138,// Transform; // z = ~(x &/| y); // into:; // z = ((~x) |/& (~y)); // iff both x and y are free to invert and all uses of z can be freely updated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:11,Testability,log,logic,11,"// If this logic op has not been simplified yet, just bail out and let that; // happen first. Otherwise, the code below may wrongly invert.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:33,Usability,simpl,simplified,33,"// If this logic op has not been simplified yet, just bail out and let that; // happen first. Otherwise, the code below may wrongly invert.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:20,Energy Efficiency,adapt,adapted,20,// Can our users be adapted?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:20,Modifiability,adapt,adapted,20,// Can our users be adapted?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:27,Energy Efficiency,adapt,adapted,27,// And can the operands be adapted?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:27,Modifiability,adapt,adapted,27,// And can the operands be adapted?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:124,Deployability,update,updated,124,// Transform; // z = (~x) &/| y; // into:; // z = ~(x |/& (~y)); // iff y is free to invert and all uses of z can be freely updated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:24,Energy Efficiency,adapt,adapted,24,// And can our users be adapted?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:24,Modifiability,adapt,adapted,24,// And can our users be adapted?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:43,Testability,log,logic,43,// Apply DeMorgan's Law for 'nand' / 'nor' logic with an inverted operand.; // We must eliminate the and/or (one-use) for these transforms to not increase; // the instruction count.; //; // ~(~X & Y) --> (X | ~Y); // ~(Y & ~X) --> (X | ~Y); //; // Note: The logical matches do not check for the commuted patterns because; // those are handled via SimplifySelectsFeedingBinaryOp().,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:258,Testability,log,logical,258,// Apply DeMorgan's Law for 'nand' / 'nor' logic with an inverted operand.; // We must eliminate the and/or (one-use) for these transforms to not increase; // the instruction count.; //; // ~(~X & Y) --> (X | ~Y); // ~(Y & ~X) --> (X | ~Y); //; // Note: The logical matches do not check for the commuted patterns because; // those are handled via SimplifySelectsFeedingBinaryOp().,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:347,Usability,Simpl,SimplifySelectsFeedingBinaryOp,347,// Apply DeMorgan's Law for 'nand' / 'nor' logic with an inverted operand.; // We must eliminate the and/or (one-use) for these transforms to not increase; // the instruction count.; //; // ~(~X & Y) --> (X | ~Y); // ~(Y & ~X) --> (X | ~Y); //; // Note: The logical matches do not check for the commuted patterns because; // those are handled via SimplifySelectsFeedingBinaryOp().,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:30,Testability,test,test,30,// Bit-hack form of a signbit test for iN type:; // ~(X >>s (N - 1)) --> sext i1 (X > -1) to iN,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:59,Safety,unsafe,unsafe,59,"// We matched a negative constant, so propagating undef is unsafe.; // Clamp undef elements to -1.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:63,Safety,unsafe,unsafe,63,"// We matched a non-negative constant, so propagating undef is unsafe.; // Clamp undef elements to 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:51,Testability,log,logic,51,// Move a 'not' ahead of casts of a bool to enable logic reduction:; // not (bitcast (sext i1 X)) --> bitcast (sext (not i1 X)),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:17,Usability,simpl,simplify,17,// See if we can simplify any instructions used by the instruction whose sole; // purpose is to compute bits we don't care about.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:163,Usability,Simpl,SimplifyDemandedInstructionBits,163,"// Fold (X & M) ^ (Y & ~M) -> (X & M) | (Y & ~M); // This it a special case in haveNoCommonBitsSet, but the computeKnownBits; // calls in there are unnecessary as SimplifyDemandedInstructionBits should; // have already taken care of those cases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:163,Integrability,depend,depending,163,"// Convert xor ([trunc] (ashr X, BW-1)), C =>; // select(X >s -1, C, ~C); // The ashr creates ""AllZeroOrAllOne's"", which then optionally inverses the; // constant depending on whether this input is less than 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:15,Energy Efficiency,power,power-of-two,15,// When X is a power-of-two or zero and zero input is poison:; // ctlz(i32 X) ^ 31 --> cttz(X); // cttz(i32 X) ^ 31 --> ctlz(X),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:151,Safety,avoid,avoid,151,"// Otherwise, if all else failed, try to hoist the xor-by-constant:; // (X ^ C) ^ Y --> (X ^ Y) ^ C; // Just like we do in other places, we completely avoid the fold; // for constantexprs, at least to avoid endless combine loop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:201,Safety,avoid,avoid,201,"// Otherwise, if all else failed, try to hoist the xor-by-constant:; // (X ^ C) ^ Y --> (X ^ Y) ^ C; // Just like we do in other places, we completely avoid the fold; // for constantexprs, at least to avoid endless combine loop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAtomicRMW.cpp:17,Performance,perform,perform,17,"// Volatile RMWs perform a load and a store, we cannot replace this by just a; // load or just a store. We chose not to canonicalize out of general paranoia; // about user expectations around volatile.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAtomicRMW.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAtomicRMW.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAtomicRMW.cpp:27,Performance,load,load,27,"// Volatile RMWs perform a load and a store, we cannot replace this by just a; // load or just a store. We chose not to canonicalize out of general paranoia; // about user expectations around volatile.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAtomicRMW.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAtomicRMW.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAtomicRMW.cpp:82,Performance,load,load,82,"// Volatile RMWs perform a load and a store, we cannot replace this by just a; // load or just a store. We chose not to canonicalize out of general paranoia; // about user expectations around volatile.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAtomicRMW.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAtomicRMW.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAtomicRMW.cpp:145,Performance,optimiz,optimizer,145,// We chose to canonicalize all idempotent operations to an single; // operation code and constant. This makes it easier for the rest of the; // optimizer to match easily. The choices of or w/0 and fadd w/-0.0 are; // arbitrary.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAtomicRMW.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAtomicRMW.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:108,Deployability,integrat,integrated,108,"/// Recognize a memcpy/memmove from a trivially otherwise unused alloca.; /// TODO: This should probably be integrated with visitAllocSites, but that; /// requires a deeper change to allow either unread or unwritten objects.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:108,Integrability,integrat,integrated,108,"/// Recognize a memcpy/memmove from a trivially otherwise unused alloca.; /// TODO: This should probably be integrated with visitAllocSites, but that; /// requires a deeper change to allow either unread or unwritten objects.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:70,Performance,load,load,70,// If MemCpyInst length is 1/2/4/8 bytes then replace memcpy with; // load/store.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:143,Performance,load,load,143,"// Source and destination pointer types are always ""i8*"" for intrinsic. See; // if the size is something we can handle with a single primitive load/store.; // A single load+store correctly handles overlapping memory in the memmove; // case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:168,Performance,load,load,168,"// Source and destination pointer types are always ""i8*"" for intrinsic. See; // if the size is something we can handle with a single primitive load/store.; // A single load+store correctly handles overlapping memory in the memmove; // case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:226,Performance,perform,performance,226,"// If not 1/2/4/8 bytes, exit.; // If it is an atomic and alignment is less than the size then we will; // introduce the unaligned memory access which will be later transformed; // into libcall in CodeGen. This is not evident performance gain so disable; // it now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:138,Security,access,access,138,"// If not 1/2/4/8 bytes, exit.; // If it is an atomic and alignment is less than the size then we will; // introduce the unaligned memory access which will be later transformed; // into libcall in CodeGen. This is not evident performance gain so disable; // it now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:18,Performance,load,load,18,// Use an integer load+store unless we can find something better.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:194,Performance,perform,performance,194,// If it is an atomic and alignment is less than the size then we will; // introduce the unaligned memory access which will be later transformed; // into libcall in CodeGen. This is not evident performance gain so disable; // it now.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:106,Security,access,access,106,// If it is an atomic and alignment is less than the size then we will; // introduce the unaligned memory access which will be later transformed; // into libcall in CodeGen. This is not evident performance gain so disable; // it now.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:10,Availability,mask,mask,10,"// If the mask is all ones or undefs, this is a plain vector load of the 1st; // argument.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:61,Performance,load,load,61,"// If the mask is all ones or undefs, this is a plain vector load of the 1st; // argument.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:29,Performance,load,load,29,"// If we can unconditionally load from this address, replace with a; // load/select idiom. TODO: use DT for context sensitive query",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:72,Performance,load,load,72,"// If we can unconditionally load from this address, replace with a; // load/select idiom. TODO: use DT for context sensitive query",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:10,Availability,mask,mask,10,"// If the mask is all zeros, this instruction does nothing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:10,Availability,mask,mask,10,"// If the mask is all ones, this is a plain vector store of the 1st argument.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:7,Availability,mask,masked,7,// Use masked off lanes to simplify operands via SimplifyDemandedVectorElts,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:27,Usability,simpl,simplify,27,// Use masked off lanes to simplify operands via SimplifyDemandedVectorElts,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:49,Usability,Simpl,SimplifyDemandedVectorElts,49,// Use masked off lanes to simplify operands via SimplifyDemandedVectorElts,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:199,Availability,mask,masked,199,"// TODO, Obvious Missing Transforms:; // * Single constant active lane load -> load; // * Dereferenceable address & few lanes -> scalarize speculative load/selects; // * Adjacent vector addresses -> masked.load; // * Narrow width by halfs excluding zero/undef lanes; // * Vector incrementing address -> vector masked load",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:310,Availability,mask,masked,310,"// TODO, Obvious Missing Transforms:; // * Single constant active lane load -> load; // * Dereferenceable address & few lanes -> scalarize speculative load/selects; // * Adjacent vector addresses -> masked.load; // * Narrow width by halfs excluding zero/undef lanes; // * Vector incrementing address -> vector masked load",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:71,Performance,load,load,71,"// TODO, Obvious Missing Transforms:; // * Single constant active lane load -> load; // * Dereferenceable address & few lanes -> scalarize speculative load/selects; // * Adjacent vector addresses -> masked.load; // * Narrow width by halfs excluding zero/undef lanes; // * Vector incrementing address -> vector masked load",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:79,Performance,load,load,79,"// TODO, Obvious Missing Transforms:; // * Single constant active lane load -> load; // * Dereferenceable address & few lanes -> scalarize speculative load/selects; // * Adjacent vector addresses -> masked.load; // * Narrow width by halfs excluding zero/undef lanes; // * Vector incrementing address -> vector masked load",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:151,Performance,load,load,151,"// TODO, Obvious Missing Transforms:; // * Single constant active lane load -> load; // * Dereferenceable address & few lanes -> scalarize speculative load/selects; // * Adjacent vector addresses -> masked.load; // * Narrow width by halfs excluding zero/undef lanes; // * Vector incrementing address -> vector masked load",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:206,Performance,load,load,206,"// TODO, Obvious Missing Transforms:; // * Single constant active lane load -> load; // * Dereferenceable address & few lanes -> scalarize speculative load/selects; // * Adjacent vector addresses -> masked.load; // * Narrow width by halfs excluding zero/undef lanes; // * Vector incrementing address -> vector masked load",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:317,Performance,load,load,317,"// TODO, Obvious Missing Transforms:; // * Single constant active lane load -> load; // * Dereferenceable address & few lanes -> scalarize speculative load/selects; // * Adjacent vector addresses -> masked.load; // * Narrow width by halfs excluding zero/undef lanes; // * Vector incrementing address -> vector masked load",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:32,Availability,mask,mask,32,// Vector splat address w/known mask -> scalar load; // Fold the gather to load the source vector first lane; // because it is reloading the same value each time,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:47,Performance,load,load,47,// Vector splat address w/known mask -> scalar load; // Fold the gather to load the source vector first lane; // because it is reloading the same value each time,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:75,Performance,load,load,75,// Vector splat address w/known mask -> scalar load; // Fold the gather to load the source vector first lane; // because it is reloading the same value each time,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:115,Availability,mask,masked,115,"// TODO, Obvious Missing Transforms:; // * Single constant active lane -> store; // * Adjacent vector addresses -> masked.store; // * Narrow store width by halfs excluding zero/undef lanes; // * Vector incrementing address -> vector masked store",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:233,Availability,mask,masked,233,"// TODO, Obvious Missing Transforms:; // * Single constant active lane -> store; // * Adjacent vector addresses -> masked.store; // * Narrow store width by halfs excluding zero/undef lanes; // * Vector incrementing address -> vector masked store",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:10,Availability,mask,mask,10,"// If the mask is all zeros, a scatter does nothing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:46,Availability,mask,mask,46,"// scatter(splat(value), splat(ptr), non-zero-mask) -> store value, ptr",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:7,Availability,mask,masked,7,// Use masked off lanes to simplify operands via SimplifyDemandedVectorElts,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:27,Usability,simpl,simplify,27,// Use masked off lanes to simplify operands via SimplifyDemandedVectorElts,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:49,Usability,Simpl,SimplifyDemandedVectorElts,49,// Use masked off lanes to simplify operands via SimplifyDemandedVectorElts,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:89,Usability,simpl,simplifies,89,"// If zero is poison, then the input can be assumed to be ""true"", so the; // instruction simplifies to ""false"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:12,Availability,mask,mask,12,// Create a mask for bits above (ctlz) or below (cttz) the first known one.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:50,Energy Efficiency,power,power,50,"// More generally we can also handle non-constant power of 2 patterns such as; // shl/shr(Pow2, X), (X & -X), etc... by transforming:; // ctpop(Pow2OrZero) --> icmp ne X, 0",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:51,Availability,mask,mask,51,"/// Convert a table lookup to shufflevector if the mask is constant.; /// This could benefit tbl1 if the mask is { 7,6,5,4,3,2,1,0 }, in; /// which case we could lower the shufflevector with rev64 instructions; /// as it's actually a byte reverse.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:105,Availability,mask,mask,105,"/// Convert a table lookup to shufflevector if the mask is constant.; /// This could benefit tbl1 if the mask is { 7,6,5,4,3,2,1,0 }, in; /// which case we could lower the shufflevector with rev64 instructions; /// as it's actually a byte reverse.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:19,Availability,mask,mask,19,// Bail out if the mask is not a constant.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:8,Performance,perform,perform,8,// Only perform this transformation for <8 x i8> vector types.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:17,Availability,mask,mask,17,// Make sure the mask indices are in range.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:92,Availability,Mask,Mask,92,"/// \returns the compare predicate type if the test performed by; /// llvm.is.fpclass(x, \p Mask) is equivalent to fcmp o__ x, 0.0 with the; /// floating-point environment assumed for \p F for type \p Ty",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:52,Performance,perform,performed,52,"/// \returns the compare predicate type if the test performed by; /// llvm.is.fpclass(x, \p Mask) is equivalent to fcmp o__ x, 0.0 with the; /// floating-point environment assumed for \p F for type \p Ty",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:47,Testability,test,test,47,"/// \returns the compare predicate type if the test performed by; /// llvm.is.fpclass(x, \p Mask) is equivalent to fcmp o__ x, 0.0 with the; /// floating-point environment assumed for \p F for type \p Ty",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:24,Availability,mask,mask,24,"// is.fpclass (fneg x), mask -> is.fpclass x, (fneg mask)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:52,Availability,mask,mask,52,"// is.fpclass (fneg x), mask -> is.fpclass x, (fneg mask)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:9,Testability,test,test,9,"// Clear test bits we know must be false from the source value.; // fp_class (nnan x), qnan|snan|other -> fp_class (nnan x), other; // fp_class (ninf x), ninf|pinf|other -> fp_class (ninf x), other",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:3,Usability,Clear,Clear,3,"// Clear test bits we know must be false from the source value.; // fp_class (nnan x), qnan|snan|other -> fp_class (nnan x), other; // fp_class (ninf x), ninf|pinf|other -> fp_class (ninf x), other",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:18,Testability,test,tests,18,"// If none of the tests which can return false are possible, fold to true.; // fp_class (nnan x), ~(qnan|snan) -> true; // fp_class (ninf x), ~(ninf|pinf) -> true",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:26,Integrability,wrap,wrap,26,// Check for necessary no-wrap and overflow constraints.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:66,Energy Efficiency,reduce,reduce,66,"// If the constant difference overflows, then instsimplify should reduce the; // min/max to the add or C1.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:51,Safety,avoid,avoid,51,// The inner op must match. Check for constants to avoid infinite loops.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:4,Energy Efficiency,Reduce,Reduce,4,/// Reduce a sequence of min/max intrinsics with a common operand.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:71,Availability,mask,mask,71,"/// If all arguments of the intrinsic are unary shuffles with the same mask,; /// try to shuffle after the intrinsic.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:24,Modifiability,extend,extended,24,"// TODO: This should be extended to handle other intrinsics like fshl, ctpop,; // etc. Use llvm::isTriviallyVectorizable() and related to determine; // which intrinsics are safe to shuffle?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:173,Safety,safe,safe,173,"// TODO: This should be extended to handle other intrinsics like fshl, ctpop,; // etc. Use llvm::isTriviallyVectorizable() and related to determine; // which intrinsics are safe to shuffle?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:51,Availability,mask,mask,51,// See if all arguments are shuffled with the same mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:16,Testability,log,logic,16,// Find bitwise logic op. Check that it is a BinaryOperator explicitly so we; // don't match ConstantExpr that aren't meaningful for this transform.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:55,Energy Efficiency,reduce,reduces,55,"// If both X and Y are bswap/bitreverse, the transform reduces the number; // of instructions even if there's multiuse.; // If only one operand is bswap/bitreverse, we need to ensure the operand; // have only one use.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:13,Usability,simpl,simplification,13,"/// CallInst simplification. This mostly only handles folding of intrinsic; /// instructions. For normal calls, it allows visitCallBase to do the heavy; /// lifting.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:16,Usability,simpl,simplify,16,"// Don't try to simplify calls without uses. It will not do anything useful,; // but will result in the following folds being skipped.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:82,Deployability,update,update,82,"// If we can determine a pointer alignment that is bigger than currently; // set, update the alignment.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:179,Safety,detect,detect,179,"// Unused constrained FP intrinsic calls may have declared side effect, which; // prevents it from being removed. In some cases however the side effect is; // actually absent. To detect this case, call SimplifyConstrainedFPCall. If it; // returns a replacement, the call may be removed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:202,Usability,Simpl,SimplifyConstrainedFPCall,202,"// Unused constrained FP intrinsic calls may have declared side effect, which; // prevents it from being removed. In some cases however the side effect is; // actually absent. To detect this case, call SimplifyConstrainedFPCall. If it; // returns a replacement, the call may be removed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:38,Usability,Clear,Clear,38,// abs (sext X) --> zext (abs X*); // Clear the IsIntMin (nsw) bit on the abs to allow narrowing.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:49,Modifiability,extend,extended,49,"// If both operands of unsigned min/max are sign-extended, it is still ok; // to narrow the operation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:12,Energy Efficiency,power,power,12,"// Negative power of 2 must be IntMin. It's possible to be able to; // prove negative / power of 2 without actually having known bits, so; // just get the value by hand.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:88,Energy Efficiency,power,power,88,"// Negative power of 2 must be IntMin. It's possible to be able to; // prove negative / power of 2 without actually having known bits, so; // just get the value by hand.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:32,Testability,log,logical-shift-by-,32,"// Try to canonicalize bswap-of-logical-shift-by-8-bit-multiple as; // inverse-shift-of-bswap:; // bswap (shl X, Y) --> lshr (bswap X), Y; // bswap (lshr X, Y) --> shl (bswap X), Y",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:6,Energy Efficiency,power,power,6,"// If power is even:; // powi(-x, p) -> powi(x, p); // powi(fabs(x), p) -> powi(x, p); // powi(copysign(x, y), p) -> powi(x, p)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:37,Energy Efficiency,reduce,reduce,37,"// fshl i16 X, X, 8 --> bswap i16 X (reduce to more-specific form)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:26,Availability,mask,masked,26,// Left or right might be masked.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:157,Energy Efficiency,power,power-of-,157,"// The shift amount (operand 2) of a funnel shift is modulo the bitwidth,; // so only the low bits of the shift amount are demanded if the bitwidth is; // a power-of-2.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:80,Usability,simpl,simplification,80,"// TODO: Conservatively intersecting FMF. If Res == C2, the transform; // was a simplification (so Arg0 and its original flags could; // propagate?)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:3,Performance,Optimiz,Optimize,3,// Optimize negation in matrix multiplication.; // -A * -B -> A * B,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:8,Performance,optimiz,optimize,8,// Only optimize if the negated operand has only one use.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:10,Usability,simpl,simplify,10,// Try to simplify the underlying FMul.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:10,Usability,simpl,simplify,10,// Try to simplify the underlying FMul. We can only apply simplifications; // that do not require rounding.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:58,Usability,simpl,simplifications,58,// Try to simplify the underlying FMul. We can only apply simplifications; // that do not require rounding.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:50,Energy Efficiency,reduce,reduce,50,"// If we know that the sign argument is positive, reduce to FABS:; // copysign Mag, +Sign --> fabs Mag",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:50,Energy Efficiency,reduce,reduce,50,"// If we know that the sign argument is negative, reduce to FNABS:; // copysign Mag, -Sign --> fneg (fabs Mag)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:59,Modifiability,rewrite,rewrites,59,"// Peek through changes of magnitude's sign-bit. This call rewrites those:; // copysign (fabs X), Sign --> copysign X, Sign; // copysign (fneg X), Sign --> copysign X, Sign",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:313,Availability,down,down,313,"// ldexp(ldexp(x, a), b) -> ldexp(x, a + b); //; // The danger is if the first ldexp would overflow to infinity or underflow; // to zero, but the combined exponent avoids it. We ignore this with; // reassoc.; //; // It's also safe to fold if we know both exponents are >= 0 or <= 0 since; // it would just double down on the overflow/underflow which would occur; // anyway.; //; // TODO: Could do better if we had range tracking for the input value; // exponent. Also could broaden sign check to cover == 0 case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:164,Safety,avoid,avoids,164,"// ldexp(ldexp(x, a), b) -> ldexp(x, a + b); //; // The danger is if the first ldexp would overflow to infinity or underflow; // to zero, but the combined exponent avoids it. We ignore this with; // reassoc.; //; // It's also safe to fold if we know both exponents are >= 0 or <= 0 since; // it would just double down on the overflow/underflow which would occur; // anyway.; //; // TODO: Could do better if we had range tracking for the input value; // exponent. Also could broaden sign check to cover == 0 case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:226,Safety,safe,safe,226,"// ldexp(ldexp(x, a), b) -> ldexp(x, a + b); //; // The danger is if the first ldexp would overflow to infinity or underflow; // to zero, but the combined exponent avoids it. We ignore this with; // reassoc.; //; // It's also safe to fold if we know both exponents are >= 0 or <= 0 since; // it would just double down on the overflow/underflow which would occur; // anyway.; //; // TODO: Could do better if we had range tracking for the input value; // exponent. Also could broaden sign check to cover == 0 case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:30,Safety,safe,safe,30,// TODO: Add nsw/nuw probably safe if integer type exceeds exponent; // width.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:45,Security,authenticat,authenticating,45,// AuthKey will be the key we need to end up authenticating against in; // whatever we replace this sequence with.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:55,Usability,simpl,simplify,55,// Check for constant LHS & RHS - in this case we just simplify.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:12,Usability,simpl,simplify,12,// Couldn't simplify - canonicalize constant to the RHS.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:3,Usability,Simpl,Simplify,3,// Simplify Q -> V -> Q conversion.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:52,Availability,Mask,Mask,52,// Check if every byte has common bits in Bytes and Mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:194,Modifiability,variab,variable,194,"// If the stacksave and the stackrestore are in the same BB, and there is; // no intervening call, alloca, or stackrestore of a different stacksave,; // remove the restore. This can happen when variable allocas are DCE'd.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:8,Availability,down,down,8,// Scan down this block to see if there is another stack restore in the; // same block without an intervening call/alloca.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:40,Usability,resume,resume,40,"// If the stack restore is in a return, resume, or unwind block and if there; // are no allocas or calls between the restore and the return, nuke the; // restore.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:34,Safety,detect,detect,34,// Asan needs to poison memory to detect invalid access which is possible; // even for empty lifetime range.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:49,Security,access,access,49,// Asan needs to poison memory to detect invalid access which is possible; // even for empty lifetime range.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:189,Availability,redundant,redundant,189,"// Remove an assume if it is followed by an identical assume.; // TODO: Do we need this? Unless there are conflicting assumptions, the; // computeKnownBits(IIOperand) below here eliminates redundant assumes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:189,Safety,redund,redundant,189,"// Remove an assume if it is followed by an identical assume.; // TODO: Do we need this? Unless there are conflicting assumptions, the; // computeKnownBits(IIOperand) below here eliminates redundant assumes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:12,Performance,load,load,12,// assume( (load addr) != null ) -> add 'nonnull' metadata to load; // (if assume is valid at the load),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:62,Performance,load,load,62,// assume( (load addr) != null ) -> add 'nonnull' metadata to load; // (if assume is valid at the load),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:98,Performance,load,load,98,// assume( (load addr) != null ) -> add 'nonnull' metadata to load; // (if assume is valid at the load),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:232,Safety,avoid,avoid,232,"// Separate storage assumptions apply to the underlying allocations, not any; // particular pointer within them. When evaluating the hints for AA purposes; // we getUnderlyingObject them; by precomputing the answers here we can; // avoid having to do so repeatedly there.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:25,Safety,safe,safe,25,// Not having a limit is safe because InstCombine removes unreachable; // code.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:93,Availability,redundant,redundant,93,"// If there is a dominating assume with the same condition as this one,; // then this one is redundant, and should be removed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:93,Safety,redund,redundant,93,"// If there is a dominating assume with the same condition as this one,; // then this one is redundant, and should be removed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:3,Deployability,Update,Update,3,// Update the cache of affected values for this assumption (we might be; // here because we just simplified the condition).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:14,Performance,cache,cache,14,// Update the cache of affected values for this assumption (we might be; // here because we just simplified the condition).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:97,Usability,simpl,simplified,97,// Update the cache of affected values for this assumption (we might be; // here because we just simplified the condition).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:36,Safety,avoid,avoid,36,// Note: Using context-free form to avoid compile time blow up,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:16,Testability,log,logical,16,"// Canonicalize logical or/and reductions:; // Or reduction for i1 is represented as:; // %val = bitcast <ReduxWidth x i1> to iReduxWidth; // %res = cmp ne iReduxWidth %val, 0; // And reduction for i1 is represented as:; // %val = bitcast <ReduxWidth x i1> to iReduxWidth; // %res = cmp eq iReduxWidth %val, 11111",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:73,Modifiability,extend,extended,73,// Exclusive disjunction reduction over the vector with; // (potentially-extended) i1 element type is actually a; // (potentially-extended) arithmetic `add` reduction over the original; // non-extended value:; // vector_reduce_xor(?ext(<n x i1>)); // -->; // ?ext(vector_reduce_add(<n x i1>)),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:130,Modifiability,extend,extended,130,// Exclusive disjunction reduction over the vector with; // (potentially-extended) i1 element type is actually a; // (potentially-extended) arithmetic `add` reduction over the original; // non-extended value:; // vector_reduce_xor(?ext(<n x i1>)); // -->; // ?ext(vector_reduce_add(<n x i1>)),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:193,Modifiability,extend,extended,193,// Exclusive disjunction reduction over the vector with; // (potentially-extended) i1 element type is actually a; // (potentially-extended) arithmetic `add` reduction over the original; // non-extended value:; // vector_reduce_xor(?ext(<n x i1>)); // -->; // ?ext(vector_reduce_add(<n x i1>)),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:62,Modifiability,extend,extended,62,// Multiplicative reduction over the vector with (potentially-extended); // i1 element type is actually a (potentially zero-extended); // logical `and` reduction over the original non-extended value:; // vector_reduce_mul(?ext(<n x i1>)); // -->; // zext(vector_reduce_and(<n x i1>)),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:124,Modifiability,extend,extended,124,// Multiplicative reduction over the vector with (potentially-extended); // i1 element type is actually a (potentially zero-extended); // logical `and` reduction over the original non-extended value:; // vector_reduce_mul(?ext(<n x i1>)); // -->; // zext(vector_reduce_and(<n x i1>)),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:184,Modifiability,extend,extended,184,// Multiplicative reduction over the vector with (potentially-extended); // i1 element type is actually a (potentially zero-extended); // logical `and` reduction over the original non-extended value:; // vector_reduce_mul(?ext(<n x i1>)); // -->; // zext(vector_reduce_and(<n x i1>)),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:138,Testability,log,logical,138,// Multiplicative reduction over the vector with (potentially-extended); // i1 element type is actually a (potentially zero-extended); // logical `and` reduction over the original non-extended value:; // vector_reduce_mul(?ext(<n x i1>)); // -->; // zext(vector_reduce_and(<n x i1>)),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:57,Modifiability,extend,extended,57,"// UMin/UMax reduction over the vector with (potentially-extended); // i1 element type is actually a (potentially-extended); // logical `and`/`or` reduction over the original non-extended value:; // vector_reduce_u{min,max}(?ext(<n x i1>)); // -->; // ?ext(vector_reduce_{and,or}(<n x i1>))",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:114,Modifiability,extend,extended,114,"// UMin/UMax reduction over the vector with (potentially-extended); // i1 element type is actually a (potentially-extended); // logical `and`/`or` reduction over the original non-extended value:; // vector_reduce_u{min,max}(?ext(<n x i1>)); // -->; // ?ext(vector_reduce_{and,or}(<n x i1>))",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:179,Modifiability,extend,extended,179,"// UMin/UMax reduction over the vector with (potentially-extended); // i1 element type is actually a (potentially-extended); // logical `and`/`or` reduction over the original non-extended value:; // vector_reduce_u{min,max}(?ext(<n x i1>)); // -->; // ?ext(vector_reduce_{and,or}(<n x i1>))",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:128,Testability,log,logical,128,"// UMin/UMax reduction over the vector with (potentially-extended); // i1 element type is actually a (potentially-extended); // logical `and`/`or` reduction over the original non-extended value:; // vector_reduce_u{min,max}(?ext(<n x i1>)); // -->; // ?ext(vector_reduce_{and,or}(<n x i1>))",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:57,Modifiability,extend,extended,57,"// SMin/SMax reduction over the vector with (potentially-extended); // i1 element type is actually a (potentially-extended); // logical `and`/`or` reduction over the original non-extended value:; // vector_reduce_s{min,max}(<n x i1>); // -->; // vector_reduce_{or,and}(<n x i1>); // and; // vector_reduce_s{min,max}(sext(<n x i1>)); // -->; // sext(vector_reduce_{or,and}(<n x i1>)); // and; // vector_reduce_s{min,max}(zext(<n x i1>)); // -->; // zext(vector_reduce_{and,or}(<n x i1>))",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:114,Modifiability,extend,extended,114,"// SMin/SMax reduction over the vector with (potentially-extended); // i1 element type is actually a (potentially-extended); // logical `and`/`or` reduction over the original non-extended value:; // vector_reduce_s{min,max}(<n x i1>); // -->; // vector_reduce_{or,and}(<n x i1>); // and; // vector_reduce_s{min,max}(sext(<n x i1>)); // -->; // sext(vector_reduce_{or,and}(<n x i1>)); // and; // vector_reduce_s{min,max}(zext(<n x i1>)); // -->; // zext(vector_reduce_{and,or}(<n x i1>))",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:179,Modifiability,extend,extended,179,"// SMin/SMax reduction over the vector with (potentially-extended); // i1 element type is actually a (potentially-extended); // logical `and`/`or` reduction over the original non-extended value:; // vector_reduce_s{min,max}(<n x i1>); // -->; // vector_reduce_{or,and}(<n x i1>); // and; // vector_reduce_s{min,max}(sext(<n x i1>)); // -->; // sext(vector_reduce_{or,and}(<n x i1>)); // and; // vector_reduce_s{min,max}(zext(<n x i1>)); // -->; // zext(vector_reduce_{and,or}(<n x i1>))",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:128,Testability,log,logical,128,"// SMin/SMax reduction over the vector with (potentially-extended); // i1 element type is actually a (potentially-extended); // logical `and`/`or` reduction over the original non-extended value:; // vector_reduce_s{min,max}(<n x i1>); // -->; // vector_reduce_{or,and}(<n x i1>); // and; // vector_reduce_s{min,max}(sext(<n x i1>)); // -->; // sext(vector_reduce_{or,and}(<n x i1>)); // and; // vector_reduce_s{min,max}(zext(<n x i1>)); // -->; // zext(vector_reduce_{and,or}(<n x i1>))",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:176,Performance,perform,perform,176,"// Try to fold intrinsic into select operands. This is legal if:; // * The intrinsic is speculatable.; // * The select condition is not a vector, or the intrinsic does not; // perform cross-lane operations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:21,Usability,simpl,simplification,21,// Fence instruction simplification,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:56,Integrability,depend,dependent,56,// This check is solely here to handle arbitrary target-dependent syncscopes.; // TODO: Can remove if does not matter in practice.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:14,Usability,simpl,simplification,14,// InvokeInst simplification,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:14,Usability,simpl,simplification,14,// CallBrInst simplification,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:8,Performance,optimiz,optimizing,8,// Skip optimizing notail and musttail calls so; // LibCallSimplifier::optimizeCall doesn't have to preserve those invariants.; // LibCallSimplifier::optimizeCall should try to preseve tail calls though.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:71,Performance,optimiz,optimizeCall,71,// Skip optimizing notail and musttail calls so; // LibCallSimplifier::optimizeCall doesn't have to preserve those invariants.; // LibCallSimplifier::optimizeCall should try to preseve tail calls though.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:150,Performance,optimiz,optimizeCall,150,// Skip optimizing notail and musttail calls so; // LibCallSimplifier::optimizeCall doesn't have to preserve those invariants.; // LibCallSimplifier::optimizeCall should try to preseve tail calls though.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:112,Usability,simpl,simpler,112,"// Strip off at most one level of pointer casts, looking for an alloca. This; // is good enough in practice and simpler than handling any number of casts.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:147,Performance,optimiz,optimized,147,"// Given a call to llvm.adjust.trampoline, find and return the corresponding; // call to llvm.init.trampoline if the call to the trampoline can be optimized; // to a direct call to a function. Otherwise return NULL.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:45,Energy Efficiency,power,power,45,// Add alignment attribute if alignment is a power of two constant.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:10,Performance,optimiz,optimize,10,"// Try to optimize the call if possible, we require DataLayout for most of; // this. None of these calls are seen as possibly dead so go ahead and; // delete the instruction now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:10,Energy Efficiency,reduce,reduce,10,// We can reduce the size of gc live bundle.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:3,Deployability,Update,Update,3,// Update all gc.relocates,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:232,Safety,avoid,avoid,232,"// Prevent us turning:; // declare void @takes_i32_inalloca(i32* inalloca); // call void bitcast (void (i32*)* @takes_i32_inalloca to void (i32)*)(i32 0); //; // into:; // call void @takes_i32_inalloca(i32* null); //; // Similarly, avoid folding away bitcasts of byval calls.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:108,Safety,safe,safely,108,// Cannot transform this parameter value.; // Check if there are any incompatible attributes we cannot drop safely.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:35,Safety,safe,safe,35,"// Okay, we decided that this is a safe thing to do: go ahead and start; // inserting cast instructions as necessary.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:133,Safety,safe,safe,133,// Add any parameter attributes except the ones incompatible with the new; // type. Note that we made sure all incompatible ones are safe to drop.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:220,Availability,Mask,Mask,220,"// Canonicalize a unary shuffle after the cast if neither operation changes; // the size or element size of the input vector.; // TODO: We could allow size-changing ops if that doesn't harm codegen.; // cast (shuffle X, Mask) --> shuffle (cast X), Mask",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:248,Availability,Mask,Mask,248,"// Canonicalize a unary shuffle after the cast if neither operation changes; // the size or element size of the input vector.; // TODO: We could allow size-changing ops if that doesn't harm codegen.; // cast (shuffle X, Mask) --> shuffle (cast X), Mask",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:15,Performance,scalab,scalable,15,// TODO: Allow scalable vectors?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:12,Modifiability,extend,extend,12,// We don't extend or shrink something that has multiple uses -- doing so; // would require duplicating the instruction which isn't profitable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:485,Energy Efficiency,efficient,efficiently,485,"/// Return true if we can evaluate the specified expression tree as type Ty; /// instead of its larger type, and arrive with the same value.; /// This is used by code that tries to eliminate truncates.; ///; /// Ty will always be a type smaller than V. We should return true if trunc(V); /// can be computed by computing V in the smaller type. If V is an instruction,; /// then trunc(inst(x,y)) can be computed as inst(trunc(x),trunc(y)), which only; /// makes sense if x and y can be efficiently truncated.; ///; /// This function works on both vectors and scalars.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:42,Modifiability,extend,extended,42,// These operators can all arbitrarily be extended or truncated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:108,Performance,perform,perform,108,"// If we are truncating the result of this SHL, and if it's a shift of an; // inrange amount, we can always perform a SHL in a smaller type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:30,Testability,log,logical,30,"// If this is a truncate of a logical shr, we can truncate it to a smaller; // lshr iff we know that the bits we would otherwise be shifting in are; // already zeros.; // TODO: It is enough to check that the bits we would be shifting in are; // zero - use AmtKnownBits.getMaxValue().",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:56,Safety,safe,safe,56,"// If the integer type can hold the max FP value, it is safe to cast; // directly to that type. Otherwise, we may create poison via overflow; // that did not exist in the original code.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:61,Testability,log,logically,61,"/// Given a vector that is bitcast to an integer, optionally logically; /// right-shifted, and truncated, convert it to an extractelement.; /// Example (big endian):; /// trunc (lshr (bitcast <4 x i32> %X to i128), 32) to i32; /// --->; /// extractelement <4 x i32> %X, 1",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:96,Energy Efficiency,power,power-of-,96,"// Bail out on strange types. It is possible to handle some of these patterns; // even with non-power-of-2 sizes, but it is not a likely scenario.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:27,Availability,mask,masked,27,"// The shift amount may be masked with negation:; // (shl ShVal0, (X & (Width - 1))) | (lshr ShVal1, ((-X) & (Width - 1)))",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:61,Availability,mask,masking,61,"// Same as above, but the shift amount may be extended after masking:",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:46,Modifiability,extend,extended,46,"// Same as above, but the shift amount may be extended after masking:",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:77,Modifiability,extend,extend,77,"// Adjust the width of ShAmt for narrowed funnel shift operation:; // - Zero-extend if ShAmt is narrower than the destination type.; // - Truncate if ShAmt is wider, discarding non-significant high-order bits.; // This prepares ShAmt for llvm.fshl.i8(trunc(ShVal), trunc(ShVal),; // zext/trunc(ShAmt)).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:47,Testability,log,logic,47,/// Try to narrow the width of math or bitwise logic instructions by pulling a; /// truncate ahead of binary operators.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:149,Safety,avoid,avoid,149,"/// Try to narrow the width of a splat shuffle. This could be generalized to any; /// shuffle with a constant operand, but we limit the transform to avoid; /// creating a shuffle type that targets may not be able to lower effectively.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:257,Modifiability,extend,extended,257,"/// Try to narrow the width of an insert element. This could be generalized for; /// any vector constant, but we limit the transform to insertion into undef to; /// avoid potential backend problems from unsupported insertion widths. This; /// could also be extended to handle the case of inserting a scalar constant; /// into a vector variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:335,Modifiability,variab,variable,335,"/// Try to narrow the width of an insert element. This could be generalized for; /// any vector constant, but we limit the transform to insertion into undef to; /// avoid potential backend problems from unsupported insertion widths. This; /// could also be extended to handle the case of inserting a scalar constant; /// into a vector variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:165,Safety,avoid,avoid,165,"/// Try to narrow the width of an insert element. This could be generalized for; /// any vector constant, but we limit the transform to insertion into undef to; /// avoid potential backend problems from unsupported insertion widths. This; /// could also be extended to handle the case of inserting a scalar constant; /// into a vector variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:120,Usability,simpl,simple,120,"// Attempt to truncate the entire input expression tree to the destination; // type. Only do this if the dest type is a simple type, don't convert the; // expression tree to something weird like i93 unless the source is also; // strange.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:183,Performance,optimiz,optimizations,183,"// For integer types, check if we can shorten the entire input expression to; // DestWidth * 2, which won't allow removing the truncate, but reducing the; // width may enable further optimizations, e.g. allowing for larger; // vectorization factors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:3,Testability,Test,Test,3,"// Test if the trunc is the user of a select which is part of a; // minimum or maximum operation. If so, don't do any more simplification.; // Even simplifying demanded bits can break the canonical form of a; // min/max.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:123,Usability,simpl,simplification,123,"// Test if the trunc is the user of a select which is part of a; // minimum or maximum operation. If so, don't do any more simplification.; // Even simplifying demanded bits can break the canonical form of a; // min/max.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:148,Usability,simpl,simplifying,148,"// Test if the trunc is the user of a select which is part of a; // minimum or maximum operation. If so, don't do any more simplification.; // Even simplifying demanded bits can break the canonical form of a; // min/max.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:17,Usability,simpl,simplify,17,// See if we can simplify any instructions used by the input whose sole; // purpose is to compute bits we don't care about.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:62,Performance,optimiz,optimize,62,"// For vectors, we do not canonicalize all truncs to icmp, so optimize; // patterns that would be covered within visitICmpInst.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:9,Availability,Mask,Mask,9,// TODO: Mask high bits with 'and'.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:96,Modifiability,extend,extend,96,// Skip shifts of shift by constants. It undoes a combine in; // FoldShiftByConstant and is the extend in reg pattern.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:41,Usability,undo,undoes,41,// Skip shifts of shift by constants. It undoes a combine in; // FoldShiftByConstant and is the extend in reg pattern.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:168,Safety,avoid,avoid,168,"// If we are just checking for a icmp eq of a single bit and zext'ing it; // to an integer, then shift the bit to the appropriate place and then; // cast to integer to avoid the comparison.; // FIXME: This set of transforms does not check for extra uses and/or creates; // an extra instruction (an optional final cast is not included; // in the transform comments). We may also want to favor icmp over; // shifts in cases of equal instructions because icmp has better; // analysis in general (invert the transform).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:3,Performance,Perform,Perform,3,// Perform a logical shr by shiftamt.; // Insert the shift to put the result in the low bit.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:13,Testability,log,logical,13,// Perform a logical shr by shiftamt.; // Insert the shift to put the result in the low bit.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:3,Deployability,Toggle,Toggle,3,"// Toggle the low bit for ""X == 0"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:50,Availability,mask,mask,50,"// Test if a bit is clear/set using a shifted-one mask:; // zext (icmp eq (and X, (1 << ShAmt)), 0) --> and (lshr (not X), ShAmt), 1; // zext (icmp ne (and X, (1 << ShAmt)), 0) --> and (lshr X, ShAmt), 1",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:3,Testability,Test,Test,3,"// Test if a bit is clear/set using a shifted-one mask:; // zext (icmp eq (and X, (1 << ShAmt)), 0) --> and (lshr (not X), ShAmt), 1; // zext (icmp ne (and X, (1 << ShAmt)), 0) --> and (lshr X, ShAmt), 1",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:20,Usability,clear,clear,20,"// Test if a bit is clear/set using a shifted-one mask:; // zext (icmp eq (and X, (1 << ShAmt)), 0) --> and (lshr (not X), ShAmt), 1; // zext (icmp ne (and X, (1 << ShAmt)), 0) --> and (lshr X, ShAmt), 1",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:319,Modifiability,extend,extend,319,"/// Determine if the specified value can be computed in the specified wider type; /// and produce the same low bits. If not, return false.; ///; /// If this function returns true, it can also return a non-zero number of bits; /// (in BitsToClear) which indicates that the value it computes is correct for; /// the zero extend, but that the additional BitsToClear bits need to be zero'd; /// out. For example, to promote something like:; ///; /// %B = trunc i64 %A to i32; /// %C = lshr i32 %B, 8; /// %E = zext i32 %C to i64; ///; /// CanEvaluateZExtd for the 'lshr' will return true, and BitsToClear will be; /// set to 8 to indicate that the promoted value needs to have bits 24-31; /// cleared in addition to bits 32-63. Since an 'and' will be generated to; /// clear the top bits anyway, doing this has no extra cost.; ///; /// This function works on both vectors and scalars.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:689,Usability,clear,cleared,689,"/// Determine if the specified value can be computed in the specified wider type; /// and produce the same low bits. If not, return false.; ///; /// If this function returns true, it can also return a non-zero number of bits; /// (in BitsToClear) which indicates that the value it computes is correct for; /// the zero extend, but that the additional BitsToClear bits need to be zero'd; /// out. For example, to promote something like:; ///; /// %B = trunc i64 %A to i32; /// %C = lshr i32 %B, 8; /// %E = zext i32 %C to i64; ///; /// CanEvaluateZExtd for the 'lshr' will return true, and BitsToClear will be; /// set to 8 to indicate that the promoted value needs to have bits 24-31; /// cleared in addition to bits 32-63. Since an 'and' will be generated to; /// clear the top bits anyway, doing this has no extra cost.; ///; /// This function works on both vectors and scalars.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:765,Usability,clear,clear,765,"/// Determine if the specified value can be computed in the specified wider type; /// and produce the same low bits. If not, return false.; ///; /// If this function returns true, it can also return a non-zero number of bits; /// (in BitsToClear) which indicates that the value it computes is correct for; /// the zero extend, but that the additional BitsToClear bits need to be zero'd; /// out. For example, to promote something like:; ///; /// %B = trunc i64 %A to i32; /// %C = lshr i32 %B, 8; /// %E = zext i32 %C to i64; ///; /// CanEvaluateZExtd for the 'lshr' will return true, and BitsToClear will be; /// set to 8 to indicate that the promoted value needs to have bits 24-31; /// cleared in addition to bits 32-63. Since an 'and' will be generated to; /// clear the top bits anyway, doing this has no extra cost.; ///; /// This function works on both vectors and scalars.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:61,Usability,clear,clear,61,// These can all be promoted if neither operand has 'bits to clear'.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:53,Usability,clear,clear,53,"// If the operation is an AND/OR/XOR and the bits to clear are zero in the; // other side, BitsToClear is ok.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:10,Availability,Mask,MaskedValueIsZero,10,"// We use MaskedValueIsZero here for generality, but the case we care; // about the most is constant RHS.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:98,Energy Efficiency,reduce,reduce,98,"// We can promote shl(x, cst) if we can promote x. Since shl overwrites the; // upper bits we can reduce BitsToClear by the shift amount.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:92,Usability,clear,clear,92,"// We can promote lshr(x, cst) if we can promote x. This requires the; // ultimate 'and' to clear out the high zero bits we're clearing out though.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:127,Usability,clear,clearing,127,"// We can promote lshr(x, cst) if we can promote x. This requires the; // ultimate 'and' to clear out the high zero bits we're clearing out though.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:18,Modifiability,variab,variable,18,// Cannot promote variable LSHR.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:100,Modifiability,extend,extended,100,"// llvm.vscale() can always be executed in larger type, because the; // value is automatically zero-extended.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:16,Modifiability,extend,extend,16,"// If this zero extend is only used by a truncate, let the truncate be; // eliminated before we try to optimize this zext.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:103,Performance,optimiz,optimize,103,"// If this zero extend is only used by a truncate, let the truncate be; // eliminated before we try to optimize this zext.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:10,Modifiability,extend,extend,10,// Try to extend the entire expression tree to the wide destination type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:29,Usability,clear,clear,29,// We need to emit an AND to clear the high bits.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:144,Testability,log,logical,144,// If this is a TRUNC followed by a ZEXT then we are dealing with integral; // types and if the sizes are just right we can convert this into a logical; // 'and' which will be much cheaper than the pair of casts.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:82,Availability,mask,mask,82,"// If we're actually extending zero bits, then if; // SrcSize < DstSize: zext(a & mask); // SrcSize == DstSize: a & mask; // SrcSize > DstSize: trunc(a) & mask",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:116,Availability,mask,mask,116,"// If we're actually extending zero bits, then if; // SrcSize < DstSize: zext(a & mask); // SrcSize == DstSize: a & mask; // SrcSize > DstSize: trunc(a) & mask",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:155,Availability,mask,mask,155,"// If we're actually extending zero bits, then if; // SrcSize < DstSize: zext(a & mask); // SrcSize == DstSize: a & mask; // SrcSize > DstSize: trunc(a) & mask",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:21,Modifiability,extend,extending,21,"// If we're actually extending zero bits, then if; // SrcSize < DstSize: zext(a & mask); // SrcSize == DstSize: a & mask; // SrcSize > DstSize: trunc(a) & mask",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:25,Availability,mask,masking,25,"// If we are truncating, masking, and then zexting back to the original type,; // that's just a mask. This is not handled by canEvaluateZextd if the; // intermediate values have extra uses. This could be generalized further for; // a non-constant mask operand.; // zext (and (trunc X), C) --> and X, (zext C)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:96,Availability,mask,mask,96,"// If we are truncating, masking, and then zexting back to the original type,; // that's just a mask. This is not handled by canEvaluateZextd if the; // intermediate values have extra uses. This could be generalized further for; // a non-constant mask operand.; // zext (and (trunc X), C) --> and X, (zext C)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:247,Availability,mask,mask,247,"// If we are truncating, masking, and then zexting back to the original type,; // that's just a mask. This is not handled by canEvaluateZextd if the; // intermediate values have extra uses. This could be generalized further for; // a non-constant mask operand.; // zext (and (trunc X), C) --> and X, (zext C)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:16,Modifiability,extend,extend,16,"// If this zero extend is only used by a shift, add nneg flag.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:120,Energy Efficiency,power,power,120,"// If we know that only one bit of the LHS of the icmp can be set and we; // have an equality comparison with zero or a power of 2, we can transform; // the icmp and sext into bitwise/integer operations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:15,Testability,test,tests,15,// If the icmp tests for a known zero bit we can constant fold it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:3,Performance,Perform,Perform,3,// Perform a right shift to place the desired bit in the LSB.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:3,Performance,Perform,Perform,3,// Perform a left shift to place the desired bit in the MSB.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:42,Modifiability,extend,extended,42,// These operators can all arbitrarily be extended if their inputs can.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:16,Modifiability,extend,extend,16,"// If this sign extend is only used by a truncate, let the truncate be; // eliminated before we try to optimize this sext.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:103,Performance,optimiz,optimize,103,"// If this sign extend is only used by a truncate, let the truncate be; // eliminated before we try to optimize this sext.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:22,Modifiability,extend,extended,22,"// If the value being extended is zero or positive, use a zext instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:10,Modifiability,extend,extend,10,// Try to extend the entire expression tree to the wide destination type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:47,Modifiability,extend,extend,47,// We need to emit a shl + ashr to do the sign extend.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:81,Testability,log,logic,81,"// If we are replacing shifted-in high zero bits with sign bits, convert; // the logic shift to arithmetic shift and eliminate the cast to; // intermediate type:; // sext (trunc (lshr Y, C)) --> sext/trunc (ashr Y, C)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:393,Modifiability,extend,extend,393,"// If the input is a shl/ashr pair of a same constant, then this is a sign; // extension from a smaller value. If we could trust arbitrary bitwidth; // integers, we could turn this into a truncate to the smaller bit and then; // use a sext for the whole extension. Since we don't, look deeper and check; // for a truncate. If the source and dest are the same type, eliminate the; // trunc and extend and just do shifts. For example, turn:; // %a = trunc i32 %i to i8; // %b = shl i8 %a, C; // %c = ashr i8 %b, C; // %d = sext i8 %c to i32; // into:; // %a = shl i32 %i, 32-(8-C); // %d = ashr i32 %a, 32-(8-C)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:94,Safety,safe,safely,94,"// Determine if this is a vector of ConstantFPs and if so, return the minimal; // type we can safely truncate all elements to.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:36,Safety,safe,safely,36,/// Find the minimum FP type we can safely truncate to.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:134,Integrability,wrap,wrapped,134,// We can only correctly find a minimum type for a scalable vector when it is; // a splat. For splats of constant values the fpext is wrapped up as a; // ConstantExpr.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:51,Performance,scalab,scalable,51,// We can only correctly find a minimum type for a scalable vector when it is; // a splat. For splats of constant values the fpext is wrapped up as a; // ConstantExpr.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:67,Performance,scalab,scalable,67,// Try to shrink a vector of FP constants. This returns nullptr on scalable; // vectors,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:66,Safety,avoid,avoid,66,"// If this is uitofp (fptosi F), the source needs an extra bit to avoid; // potential rounding of negative FP input values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:135,Modifiability,extend,extend,135,"// If we have fptrunc(OpI (fpextend x), (fpextend y)), we would like to; // simplify this expression to avoid one or more of the trunc/extend; // operations if we can do so without changing the numerical results.; //; // The exact manner in which the widths of the operands interact to limit; // what we can and cannot do safely varies from operation to operation, and; // is explained below in the various case statements.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:104,Safety,avoid,avoid,104,"// If we have fptrunc(OpI (fpextend x), (fpextend y)), we would like to; // simplify this expression to avoid one or more of the trunc/extend; // operations if we can do so without changing the numerical results.; //; // The exact manner in which the widths of the operands interact to limit; // what we can and cannot do safely varies from operation to operation, and; // is explained below in the various case statements.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:322,Safety,safe,safely,322,"// If we have fptrunc(OpI (fpextend x), (fpextend y)), we would like to; // simplify this expression to avoid one or more of the trunc/extend; // operations if we can do so without changing the numerical results.; //; // The exact manner in which the widths of the operands interact to limit; // what we can and cannot do safely varies from operation to operation, and; // is explained below in the various case statements.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:76,Usability,simpl,simplify,76,"// If we have fptrunc(OpI (fpextend x), (fpextend y)), we would like to; // simplify this expression to avoid one or more of the trunc/extend; // operations if we can do so without changing the numerical results.; //; // The exact manner in which the widths of the operands interact to limit; // what we can and cannot do safely varies from operation to operation, and; // is explained below in the various case statements.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:244,Performance,perform,perform,244,"// For multiplication, the infinitely precise result has at most; // LHSWidth + RHSWidth significant bits; if OpWidth is sufficient; // that such a value can be exactly represented, then no double; // rounding can possibly occur; we can safely perform the operation; // in the destination format if it can represent both sources.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:237,Safety,safe,safely,237,"// For multiplication, the infinitely precise result has at most; // LHSWidth + RHSWidth significant bits; if OpWidth is sufficient; // that such a value can be exactly represented, then no double; // rounding can possibly occur; we can safely perform the operation; // in the destination format if it can represent both sources.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:120,Usability,simpl,simply,120,"// Remainder is straightforward. Remainder is always exact, so the; // type of OpI doesn't enter into things at all. We simply evaluate; // in whichever source type is larger, then convert to the; // destination type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:45,Modifiability,extend,extended,45,"// If we are truncating a select that has an extended operand, we can; // narrow the other operand and do the select as a narrow op.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:83,Safety,safe,safe,83,"/// fpto{s/u}i({u/s}itofp(X)) --> X or zext(X) or sext(X) or trunc(X); /// This is safe if the intermediate type has enough bits in its mantissa to; /// accurately represent all values of X. For example, this won't work with; /// i64 -> float -> i64.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:124,Integrability,depend,depend,124,"// Since we can assume the conversion won't overflow, our decision as to; // whether the input will fit in the float should depend on the minimum; // of the input range and output range.; // This means this is also safe for a signed input and unsigned output, since; // a negative input would lead to undefined behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:215,Safety,safe,safe,215,"// Since we can assume the conversion won't overflow, our decision as to; // whether the input will fit in the float should depend on the minimum; // of the input range and output range.; // This means this is also safe for a signed input and unsigned output, since; // a negative input would lead to undefined behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:169,Security,expose,exposed,169,"// If the source integer type is not the intptr_t type for this target, do a; // trunc or zext to the intptr_t type, then inttoptr of it. This allows the; // cast to be exposed to other transforms.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:163,Security,expose,exposed,163,"// If the destination integer type is not the intptr_t type for this target,; // do a ptrtoint to intptr_t then do a trunc or zext. This allows the cast; // to be exposed to other transforms.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:72,Modifiability,extend,extended,72,"/// This input value (which is known to have vector type) is being zero extended; /// or truncated to the specified vector type. Since the zext/trunc is done; /// using an integer type, we have a (bitcast(cast(bitcast))) pattern,; /// endianness will impact which end of the vector that is extended or; /// truncated.; ///; /// A vector is always stored with index 0 at the lowest address, which; /// corresponds to the most significant bits for a big endian stored integer and; /// the least significant bits for little endian. A trunc/zext of an integer; /// impacts the big end of the integer. Thus, we need to add/remove elements at; /// the front of the vector for big endian targets, and the back of the vector; /// for little endian targets.; ///; /// Try to replace it with a shuffle (and vector/vector bitcast) if possible.; ///; /// The source and destination vector types may have different element types.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:290,Modifiability,extend,extended,290,"/// This input value (which is known to have vector type) is being zero extended; /// or truncated to the specified vector type. Since the zext/trunc is done; /// using an integer type, we have a (bitcast(cast(bitcast))) pattern,; /// endianness will impact which end of the vector that is extended or; /// truncated.; ///; /// A vector is always stored with index 0 at the lowest address, which; /// corresponds to the most significant bits for a big endian stored integer and; /// the least significant bits for little endian. A trunc/zext of an integer; /// impacts the big end of the integer. Thus, we need to add/remove elements at; /// the front of the vector for big endian targets, and the back of the vector; /// for little endian targets.; ///; /// Try to replace it with a shuffle (and vector/vector bitcast) if possible.; ///; /// The source and destination vector types may have different element types.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:23,Performance,optimiz,optimization,23,"// We can only do this optimization if the output is a multiple of the input; // element size, or the input is a multiple of the output element size.; // Convert the input type to have the same element type as the output.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:53,Availability,mask,mask,53,"// Now that the element types match, get the shuffle mask and RHS of the; // shuffle to use, which depends on whether we're increasing or decreasing the; // size of the input.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:99,Integrability,depend,depends,99,"// Now that the element types match, get the shuffle mask and RHS of the; // shuffle to use, which depends on whether we're increasing or decreasing the; // size of the input.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:25,Availability,mask,mask,25,"// Make sure the shuffle mask selects the ""least significant bits"" by; // keeping elements from back of the src vector for big endian, and from the; // front for little endian.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:61,Availability,mask,mask,61,// Use first elt from V2 when indicating zero in the shuffle mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:3,Modifiability,Extend,Extend,3,"// Extend with null values in the ""most significant bits"" by adding elements; // in front of the src vector for big endian, and at the back for little; // endian.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:198,Performance,Optimiz,OptimizeIntegerToVectorInsertions,198,"/// V is a value which is inserted into a vector of VecEltTy.; /// Look through the value to see if we can decompose it into; /// insertions into the vector. See the example in the comment for; /// OptimizeIntegerToVectorInsertions for the pattern this handles.; /// The type of V is always a non-zero multiple of VecEltTy's size.; /// Shift is the number of bits between the lsb of V and the lsb of; /// the vector.; ///; /// This returns false if the pattern can't be matched or true if it can,; /// filling in Elements with the elements found here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:13,Availability,down,down,13,"// If we got down to a value of the right type, we win, try inserting into the; // right element.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:207,Performance,optimiz,optimize,207,"/// If the input is an 'or' instruction, we may be doing shifts and ors to; /// assemble the elements of the vector manually.; /// Try to rip the code out and replace it with insertelements. This is to; /// optimize code like this:; ///; /// %tmp37 = bitcast float %inc to i32; /// %tmp38 = zext i32 %tmp37 to i64; /// %tmp31 = bitcast float %inc5 to i32; /// %tmp32 = zext i32 %tmp31 to i64; /// %tmp33 = shl i64 %tmp32, 32; /// %ins35 = or i64 %tmp33, %tmp38; /// %tmp43 = bitcast i64 %ins35 to <2 x float>; ///; /// Into two insertelements that do ""buildvector{%inc, %inc5}"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:36,Safety,avoid,avoid,36,"// Only solve DestType is vector to avoid inverse transform in visitBitCast.; // bitcast (extractelement <1 x elt>, dest) -> bitcast(<1 x elt>, dest)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:33,Testability,log,logic,33,/// Change the type of a bitwise logic operation if we can eliminate a bitcast.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:58,Safety,avoid,avoid,58,"// FIXME: This transform is restricted to vector types to avoid backend; // problems caused by creating potentially illegal operations. If a fix-up is; // added to handle that situation, we can remove this check.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:11,Testability,log,logic,11,"// bitcast(logic(bitcast(X), bitcast(Y))) -> bitcast'(logic(bitcast'(X), Y))",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:54,Testability,log,logic,54,"// bitcast(logic(bitcast(X), bitcast(Y))) -> bitcast'(logic(bitcast'(X), Y))",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:11,Testability,log,logic,11,"// bitcast(logic(bitcast(X), Y)) --> logic'(X, bitcast(Y))",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:37,Testability,log,logic,37,"// bitcast(logic(bitcast(X), Y)) --> logic'(X, bitcast(Y))",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:11,Testability,log,logic,11,"// bitcast(logic(Y, bitcast(X))) --> logic'(bitcast(Y), X)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:37,Testability,log,logic,37,"// bitcast(logic(Y, bitcast(X))) --> logic'(bitcast(Y), X)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:62,Testability,log,logic,62,"// Canonicalize vector bitcasts to come before vector bitwise logic with a; // constant. This eases recognition of special constants for later ops.; // Example:; // icmp u/s (a ^ signmask), (b ^ signmask) --> icmp s/u a, b",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:12,Testability,log,logic,12,"// bitcast (logic X, C) --> logic (bitcast X, C')",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:28,Testability,log,logic,28,"// bitcast (logic X, C) --> logic (bitcast X, C')",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:99,Safety,avoid,avoid,99,"// FIXME: This transform is restricted from changing the select between; // scalars and vectors to avoid backend problems caused by creating; // potentially illegal operations. If a fix-up is added to handle that; // situation, we can remove this check.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:41,Performance,load,load,41,"// If there is a sequence of one or more load instructions, each loaded; // value is used as address of later load instruction, bitcast is; // necessary to change the value type, don't optimize it. For; // simplicity we give up if the load address comes from another load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:65,Performance,load,loaded,65,"// If there is a sequence of one or more load instructions, each loaded; // value is used as address of later load instruction, bitcast is; // necessary to change the value type, don't optimize it. For; // simplicity we give up if the load address comes from another load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:110,Performance,load,load,110,"// If there is a sequence of one or more load instructions, each loaded; // value is used as address of later load instruction, bitcast is; // necessary to change the value type, don't optimize it. For; // simplicity we give up if the load address comes from another load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:185,Performance,optimiz,optimize,185,"// If there is a sequence of one or more load instructions, each loaded; // value is used as address of later load instruction, bitcast is; // necessary to change the value type, don't optimize it. For; // simplicity we give up if the load address comes from another load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:235,Performance,load,load,235,"// If there is a sequence of one or more load instructions, each loaded; // value is used as address of later load instruction, bitcast is; // necessary to change the value type, don't optimize it. For; // simplicity we give up if the load address comes from another load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:267,Performance,load,load,267,"// If there is a sequence of one or more load instructions, each loaded; // value is used as address of later load instruction, bitcast is; // necessary to change the value type, don't optimize it. For; // simplicity we give up if the load address comes from another load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:206,Usability,simpl,simplicity,206,"// If there is a sequence of one or more load instructions, each loaded; // value is used as address of later load instruction, bitcast is; // necessary to change the value type, don't optimize it. For; // simplicity we give up if the load address comes from another load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:19,Performance,load,load,19,"// Don't tranform ""load <256 x i32>, <256 x i32>*"" to; // ""load x86_amx, x86_amx*"", because x86_amx* is invalid.; // TODO: Remove this check when bitcast between vector and x86_amx; // is replaced with a specific intrinsic.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:59,Performance,load,load,59,"// Don't tranform ""load <256 x i32>, <256 x i32>*"" to; // ""load x86_amx, x86_amx*"", because x86_amx* is invalid.; // TODO: Remove this check when bitcast between vector and x86_amx; // is replaced with a specific intrinsic.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:8,Performance,Load,LoadInst,8,"// If a LoadInst has more than one use, changing the type of loaded; // value may create another bitcast.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:61,Performance,load,loaded,61,"// If a LoadInst has more than one use, changing the type of loaded; // value may create another bitcast.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:74,Modifiability,rewrite,rewrite,74,"// Check that each user of each old PHI node is something that we can; // rewrite, so that all of the old PHI nodes can be cleaned up afterwards.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:74,Modifiability,rewrite,rewrite,74,"// As long as the user is another old PHI node, then even if we don't; // rewrite it, the PHI web we're considering won't have any users; // outside itself, so it'll be dead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:14,Performance,perform,perform,14,// Explicitly perform load combine to make sure no opposing transform; // can remove the bitcast in the meantime and trigger an infinite loop.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:22,Performance,load,load,22,// Explicitly perform load combine to make sure no opposing transform; // can remove the bitcast in the meantime and trigger an infinite loop.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:18,Performance,load,load,18,"// Remove the old load and its use in the old phi, which itself becomes; // dead once the whole transform finishes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:68,Testability,log,logic,68,// Convert an artificial vector insert into more analyzable bitwise logic.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:53,Availability,Mask,MaskC,53,"// bitcast (inselt (bitcast X), Y, 0) --> or (and X, MaskC), (zext Y)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:95,Deployability,update,updates,95,/// Returns true if the exploded icmp can be expressed as a signed comparison; /// to zero and updates the predicate accordingly.; /// The signedness of the comparison is preserved.; /// TODO: Refactor with decomposeBitTestICmp()?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:193,Modifiability,Refactor,Refactor,193,/// Returns true if the exploded icmp can be expressed as a signed comparison; /// to zero and updates the predicate accordingly.; /// The signedness of the comparison is preserved.; /// TODO: Refactor with decomposeBitTestICmp()?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:386,Availability,mask,masked,386,"/// This is called when we see this pattern:; /// cmp pred (load (gep GV, ...)), cmpcst; /// where GV is a global variable with a constant initializer. Try to simplify; /// this into some simple computation that does not need the load. For example; /// we can optimize ""icmp eq (load (gep ""foo"", 0, i)), 0"" into ""icmp eq i, 3"".; ///; /// If AndCst is non-null, then the loaded value is masked with that constant; /// before doing the comparison. This handles cases like ""A[i]&4 == 0"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:114,Modifiability,variab,variable,114,"/// This is called when we see this pattern:; /// cmp pred (load (gep GV, ...)), cmpcst; /// where GV is a global variable with a constant initializer. Try to simplify; /// this into some simple computation that does not need the load. For example; /// we can optimize ""icmp eq (load (gep ""foo"", 0, i)), 0"" into ""icmp eq i, 3"".; ///; /// If AndCst is non-null, then the loaded value is masked with that constant; /// before doing the comparison. This handles cases like ""A[i]&4 == 0"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:60,Performance,load,load,60,"/// This is called when we see this pattern:; /// cmp pred (load (gep GV, ...)), cmpcst; /// where GV is a global variable with a constant initializer. Try to simplify; /// this into some simple computation that does not need the load. For example; /// we can optimize ""icmp eq (load (gep ""foo"", 0, i)), 0"" into ""icmp eq i, 3"".; ///; /// If AndCst is non-null, then the loaded value is masked with that constant; /// before doing the comparison. This handles cases like ""A[i]&4 == 0"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:230,Performance,load,load,230,"/// This is called when we see this pattern:; /// cmp pred (load (gep GV, ...)), cmpcst; /// where GV is a global variable with a constant initializer. Try to simplify; /// this into some simple computation that does not need the load. For example; /// we can optimize ""icmp eq (load (gep ""foo"", 0, i)), 0"" into ""icmp eq i, 3"".; ///; /// If AndCst is non-null, then the loaded value is masked with that constant; /// before doing the comparison. This handles cases like ""A[i]&4 == 0"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:260,Performance,optimiz,optimize,260,"/// This is called when we see this pattern:; /// cmp pred (load (gep GV, ...)), cmpcst; /// where GV is a global variable with a constant initializer. Try to simplify; /// this into some simple computation that does not need the load. For example; /// we can optimize ""icmp eq (load (gep ""foo"", 0, i)), 0"" into ""icmp eq i, 3"".; ///; /// If AndCst is non-null, then the loaded value is masked with that constant; /// before doing the comparison. This handles cases like ""A[i]&4 == 0"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:279,Performance,load,load,279,"/// This is called when we see this pattern:; /// cmp pred (load (gep GV, ...)), cmpcst; /// where GV is a global variable with a constant initializer. Try to simplify; /// this into some simple computation that does not need the load. For example; /// we can optimize ""icmp eq (load (gep ""foo"", 0, i)), 0"" into ""icmp eq i, 3"".; ///; /// If AndCst is non-null, then the loaded value is masked with that constant; /// before doing the comparison. This handles cases like ""A[i]&4 == 0"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:370,Performance,load,loaded,370,"/// This is called when we see this pattern:; /// cmp pred (load (gep GV, ...)), cmpcst; /// where GV is a global variable with a constant initializer. Try to simplify; /// this into some simple computation that does not need the load. For example; /// we can optimize ""icmp eq (load (gep ""foo"", 0, i)), 0"" into ""icmp eq i, 3"".; ///; /// If AndCst is non-null, then the loaded value is masked with that constant; /// before doing the comparison. This handles cases like ""A[i]&4 == 0"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:159,Usability,simpl,simplify,159,"/// This is called when we see this pattern:; /// cmp pred (load (gep GV, ...)), cmpcst; /// where GV is a global variable with a constant initializer. Try to simplify; /// this into some simple computation that does not need the load. For example; /// we can optimize ""icmp eq (load (gep ""foo"", 0, i)), 0"" into ""icmp eq i, 3"".; ///; /// If AndCst is non-null, then the loaded value is masked with that constant; /// before doing the comparison. This handles cases like ""A[i]&4 == 0"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:188,Usability,simpl,simple,188,"/// This is called when we see this pattern:; /// cmp pred (load (gep GV, ...)), cmpcst; /// where GV is a global variable with a constant initializer. Try to simplify; /// this into some simple computation that does not need the load. For example; /// we can optimize ""icmp eq (load (gep ""foo"", 0, i)), 0"" into ""icmp eq i, 3"".; ///; /// If AndCst is non-null, then the loaded value is masked with that constant; /// before doing the comparison. This handles cases like ""A[i]&4 == 0"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:32,Performance,optimiz,optimization,32,"// There are many forms of this optimization we can handle, for now, just do; // the simple index into a single-dimensional array.; //; // Require: GEP GV, 0, i {{, constant indices}}",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:85,Usability,simpl,simple,85,"// There are many forms of this optimization we can handle, for now, just do; // the simple index into a single-dimensional array.; //; // Require: GEP GV, 0, i {{, constant indices}}",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:32,Modifiability,variab,variable,32,// Check that indices after the variable are constants and in-range for the; // type they index. Collect the indices. This is typically for arrays of; // structs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:3,Modifiability,Variab,Variable,3,// Variable index.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:3,Modifiability,Variab,Variables,3,"// Variables for our state machines.; // FirstTrueElement/SecondTrueElement - Used to emit a comparison of the form; // ""i == 47 | i == 87"", where 47 is the first index the condition is true for,; // and 87 is the second (and last) index. FirstTrueElement is -2 when; // undefined, otherwise set to the first true element. SecondTrueElement is; // -2 when undefined, -3 when overdefined and >= 0 when that index is true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:21,Availability,mask,masked,21,"// If the element is masked, handle it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:3,Modifiability,Extend,Extend,3,// Extend range state machines to cover this element in case there is an; // undef in the middle of the range.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:79,Deployability,update,update,79,"// Otherwise, we know if the comparison is true or false for this element,; // update our state machines.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:3,Deployability,Update,Update,3,// Update the TrueElement state machine.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:3,Deployability,Update,Update,3,// Update double-compare state machine.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:3,Deployability,Update,Update,3,// Update range state machine.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:3,Deployability,Update,Update,3,// Update the FalseElement state machine.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:3,Deployability,Update,Update,3,// Update double-compare state machine.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:3,Deployability,Update,Update,3,// Update range state machine.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:32,Deployability,update,update,32,"// If this element is in range, update our magic bitvector.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:93,Availability,down,down,93,"// If the index is larger than the pointer offset size of the target, truncate; // the index down like the GEP would do implicitly. We don't have to do this; // for an inbounds GEP because the index can't be out of range.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:73,Performance,load,load,73,"// If a magic bitvector captures the entire comparison state; // of this load, replace it with computation that does:; // ((magic_cst >> i) & 1) != 0",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:27,Modifiability,rewrite,rewrite,27,/// Returns true if we can rewrite Start as a GEP with pointer Base; /// and some integer offset. The nodes that need to be re-written; /// for this transformation will be added to Explored.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:45,Modifiability,variab,variable,45,// Only allow inbounds GEPs with at most one variable offset.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:3,Performance,Perform,Perform,3,// Perform all the substitutions. This is a bit tricky because we can; // have cycles in our use-def chains.; // 1. Create the PHI nodes without any incoming values.; // 2. Create all the other values.; // 3. Add the edges for the PHI nodes.; // 4. Emit GEPs to get the original pointers.; // 5. Remove the original instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:46,Integrability,depend,dependencies,46,// Create empty phi nodes. This avoids cyclic dependencies when creating; // the remaining instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:32,Safety,avoid,avoids,32,// Create empty phi nodes. This avoids cyclic dependencies when creating; // the remaining instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:3,Modifiability,Rewrite,RewriteGEPAsOffset,3,"// RewriteGEPAsOffset has replaced RHS and all of its uses with a re-written; // GEP having PtrBase as the pointer base, and has returned in NewRHS the; // offset. Since Index is the offset of LHS to the base pointer, we will now; // compare the offsets instead of comparing the pointers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:600,Usability,simpl,simply,600,"// For most address spaces, an allocation can't be placed at null, but null; // itself is treated as a 0 size allocation in the in bounds rules. Thus,; // the only valid inbounds address derived from null, is null itself.; // Thus, we have four cases to consider:; // 1) Base == nullptr, Offset == 0 -> inbounds, null; // 2) Base == nullptr, Offset != 0 -> poison as the result is out of bounds; // 3) Base != nullptr, Offset == (-base) -> poison (crossing allocations); // 4) Base != nullptr, Offset != (-base) -> nonnull (and possibly poison); //; // (Note if we're indexing a type of size 0, that simply collapses into one; // of the buckets above.); //; // In general, we're allowed to make values less poison (i.e. remove; // sources of full UB), so in this case, we just select between the two; // non-poison cases (1 and 4 above).; //; // For vectors, we apply the same reasoning on a per-lane basis.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:34,Availability,mask,mask,34,/// The value of the map is a bit mask of which icmp operands the alloca is; /// used in.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:182,Energy Efficiency,reduce,reduces,182,"// We need to check that U is based *only* on the alloca, and doesn't; // have other contributions from a select/phi operand.; // TODO: We could check whether getUnderlyingObjects() reduces to one; // object, which would allow looking through phi nodes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:100,Energy Efficiency,power,power,100,// There are multiple solutions if we are comparing against -1 and the LHS; // of the ashr is not a power of two.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:80,Modifiability,extend,extended,80,"// This is only really a signed overflow check if the inputs have been; // sign-extended; check for that condition. For example, if CI2 is 2^31 and; // the operands of the add are 64 bits wide, we need at least 33 sign bits.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:128,Availability,down,downwards,128,"// Only accept truncates for now. We would really like a nice recursive; // predicate like SimplifyDemandedBits, but which goes downwards the use-def; // chain to see which bits of a value are actually demanded. If the; // original add had another add which was then immediately truncated, we; // could still do the transformation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:91,Usability,Simpl,SimplifyDemandedBits,91,"// Only accept truncates for now. We would really like a nice recursive; // predicate like SimplifyDemandedBits, but which goes downwards the use-def; // chain to see which bits of a value are actually demanded. If the; // original add had another add which was then immediately truncated, we; // could still do the transformation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:116,Energy Efficiency,efficient,efficiently,116,"// If the pattern matches, truncate the inputs to the narrower type and; // use the sadd_with_overflow intrinsic to efficiently compute both the; // result and the overflow bit.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:56,Modifiability,extend,extended,56,"// The inner add was the result of the narrow add, zero extended to the; // wider type. Replace it with the result computed by the intrinsic.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:71,Energy Efficiency,power,power-of-two,71,"/// If we have:; /// icmp eq/ne (urem/srem %x, %y), 0; /// iff %y is a power-of-two, we can replace this with a bit test:; /// icmp eq/ne (and %x, (add %y, -1)), 0",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:116,Testability,test,test,116,"/// If we have:; /// icmp eq/ne (urem/srem %x, %y), 0; /// iff %y is a power-of-two, we can replace this with a bit test:; /// icmp eq/ne (and %x, (add %y, -1)), 0",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:123,Testability,test,test,123,/// Fold equality-comparison between zero and any (maybe truncated) right-shift; /// by one-less-than-bitwidth into a sign test on the original value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:86,Safety,avoid,avoid,86,"// `isKnownNonZero` does more analysis than just `!KnownBits.One.isZero()`; // but to avoid unnecessary work, first just if this is an obvious case.; // if X non-zero and NoOverflow(X * Y); // (icmp eq/ne Y)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:171,Usability,simpl,simplified,171,"// Note, we are skipping cases:; // if Y % 2 != 0 AND X % 2 != 0; // (false/true); // if X non-zero and Y non-zero and NoOverflow(X * Y); // (false/true); // Those can be simplified later as we would have already replaced the (icmp; // eq/ne (mul X, Y)) with (icmp eq/ne X/Y) and if X/Y is known non-zero that; // will fold to a constant elsewhere.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:147,Modifiability,extend,extended,147,"/// Fold icmp Pred X, C.; /// TODO: This code structure does not make sense. The saturating add fold; /// should be moved to some other helper and extended as noted below (it is also; /// possible that code has been made unnecessary - do we canonicalize IR to; /// overflow/saturating intrinsics or not?).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:128,Performance,perform,performs,128,"// Match the following pattern, which is a common idiom when writing; // overflow-safe integer arithmetic functions. The source performs an addition; // in wider type and explicitly checks for overflow using comparisons against; // INT_MIN and INT_MAX. Simplify by using the sadd_with_overflow intrinsic.; //; // TODO: This could probably be generalized to handle other overflow-safe; // operations if we worked out the formulas to compute the appropriate magic; // constants.; //; // sum = a + b; // if (sum+128 >u 255) ... -> llvm.sadd.with.overflow.i8",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:82,Safety,safe,safe,82,"// Match the following pattern, which is a common idiom when writing; // overflow-safe integer arithmetic functions. The source performs an addition; // in wider type and explicitly checks for overflow using comparisons against; // INT_MIN and INT_MAX. Simplify by using the sadd_with_overflow intrinsic.; //; // TODO: This could probably be generalized to handle other overflow-safe; // operations if we worked out the formulas to compute the appropriate magic; // constants.; //; // sum = a + b; // if (sum+128 >u 255) ... -> llvm.sadd.with.overflow.i8",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:379,Safety,safe,safe,379,"// Match the following pattern, which is a common idiom when writing; // overflow-safe integer arithmetic functions. The source performs an addition; // in wider type and explicitly checks for overflow using comparisons against; // INT_MIN and INT_MAX. Simplify by using the sadd_with_overflow intrinsic.; //; // TODO: This could probably be generalized to handle other overflow-safe; // operations if we worked out the formulas to compute the appropriate magic; // constants.; //; // sum = a + b; // if (sum+128 >u 255) ... -> llvm.sadd.with.overflow.i8",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:253,Usability,Simpl,Simplify,253,"// Match the following pattern, which is a common idiom when writing; // overflow-safe integer arithmetic functions. The source performs an addition; // in wider type and explicitly checks for overflow using comparisons against; // INT_MIN and INT_MAX. Simplify by using the sadd_with_overflow intrinsic.; //; // TODO: This could probably be generalized to handle other overflow-safe; // operations if we worked out the formulas to compute the appropriate magic; // constants.; //; // sum = a + b; // if (sum+128 >u 255) ... -> llvm.sadd.with.overflow.i8",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:22,Usability,simpl,simple,22,"// We already checked simple implication in InstSimplify, only handle complex; // cases here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:27,Modifiability,variab,variable,27,"// We have 2 compares of a variable with constants. Calculate the constant; // ranges of those compares to see if we can transform the 2nd compare:; // DomBB:; // DomCond = icmp DomPred X, DomC; // br DomCond, CmpBB, FalseBB; // CmpBB:; // Cmp = icmp Pred X, C",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:172,Safety,avoid,avoid,172,"// Canonicalizing a sign bit comparison that gets used in a branch,; // pessimizes codegen by generating branch on zero instruction instead; // of a test and branch. So we avoid canonicalizing in such situations; // because test and branch instruction has better branch displacement; // than compare and branch instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:149,Testability,test,test,149,"// Canonicalizing a sign bit comparison that gets used in a branch,; // pessimizes codegen by generating branch on zero instruction instead; // of a test and branch. So we avoid canonicalizing in such situations; // because test and branch instruction has better branch displacement; // than compare and branch instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:224,Testability,test,test,224,"// Canonicalizing a sign bit comparison that gets used in a branch,; // pessimizes codegen by generating branch on zero instruction instead; // of a test and branch. So we avoid canonicalizing in such situations; // because test and branch instruction has better branch displacement; // than compare and branch instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:3,Safety,Avoid,Avoid,3,// Avoid an infinite loop with min/max canonicalization.; // TODO: This will be unnecessary if we canonicalize to min/max intrinsics.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:21,Availability,mask,mask,21,// Canonicalize to a mask and wider compare if the wide type is suitable:; // (trunc X to i8) == C --> (X & 0xff) == (zext C),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:3,Usability,Simpl,Simplify,3,"// Simplify icmp eq (trunc x to i8), 42 -> icmp eq x, 42|highbits if all; // of the high bits truncated out of x are known.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:32,Testability,test,tests,32,"// If this is a comparison that tests the signbit (X < 0) or (x > -1),; // fold the xor.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:3,Availability,Mask,Mask,3,// Mask constant magic can eliminate an 'xor' with unsigned compares.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:47,Energy Efficiency,power,power,47,"// (xor X, ~C) >u C --> X <u ~C (when C+1 is a power of 2)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:45,Energy Efficiency,power,power,45,"// (xor X, C) >u C --> X >u C (when C+1 is a power of 2)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:45,Energy Efficiency,power,power,45,"// (xor X, -C) <u C --> X >u ~C (when C is a power of 2)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:45,Energy Efficiency,power,power,45,"// (xor X, C) <u C --> X >u ~C (when -C is a power of 2)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:8,Energy Efficiency,power,power-of-,8,/// For power-of-2 C:; /// ((X s>> ShiftC) ^ X) u< C --> (X + C) u< (C << 1); /// ((X s>> ShiftC) ^ X) u> (C - 1) --> (X + C) u> ((C << 1) - 1),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:209,Security,access,access,209,"// If this is: (X >> C3) & C2 != C1 (where any shift and any compare could; // exist), turn it into (X & (C2 << C3)) != (C1 << C3). This happens a LOT in; // code produced by the clang front-end, for bitfield access.; // This seemingly simple opportunity to fold away a shift turns out to be; // rather complicated. See PR17827 for details.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:236,Usability,simpl,simple,236,"// If this is: (X >> C3) & C2 != C1 (where any shift and any compare could; // exist), turn it into (X & (C2 << C3)) != (C1 << C3). This happens a LOT in; // code produced by the clang front-end, for bitfield access.; // This seemingly simple opportunity to fold away a shift turns out to be; // rather complicated. See PR17827 for details.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:114,Availability,mask,mask,114,"// For a left shift, we can fold if the comparison is not signed. We can; // also fold a signed comparison if the mask value and comparison value; // are not negative. These constraints may not be obvious, but we can; // prove that they are correct using an SMT solver.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:131,Availability,mask,mask,131,"// For a logical right shift, we can fold if the comparison is not signed.; // We can also fold a signed comparison if the shifted mask value and the; // shifted comparison value are not negative. These constraints may not be; // obvious, but we can prove that they are correct using an SMT solver.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:9,Testability,log,logical,9,"// For a logical right shift, we can fold if the comparison is not signed.; // We can also fold a signed comparison if the shifted mask value and the; // shifted comparison value are not negative. These constraints may not be; // obvious, but we can prove that they are correct using an SMT solver.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:9,Performance,perform,perform,9,// Don't perform the following transforms if the AND has multiple uses,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:50,Energy Efficiency,power,power-of-,50,// Set high zeros of C2 to allow matching negated power-of-2.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:106,Energy Efficiency,power,power,106,// Restrict this fold only for single-use 'and' (PR10267).; // ((%x & C) == 0) --> %x u< (-C) iff (-C) is power of two.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:343,Modifiability,Extend,Extending,343,"// If the LHS is an 'and' of a truncate and we can widen the and/compare to; // the input width without changing the value produced, eliminate the cast:; //; // icmp (and (trunc W), C2), C1 -> icmp (and W, C2'), C1'; //; // We can do this transformation if the constants do not have their sign bits; // set or if it is an equality comparison. Extending a relational comparison; // when we're checking the sign bit would not work.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:63,Energy Efficiency,reduce,reduce,63,// TODO: Is this a good transform for vectors? Wider types may reduce; // throughput. Should this transform be limited (even for scalars) by using; // shouldChangeType()?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:74,Performance,throughput,throughput,74,// TODO: Is this a good transform for vectors? Wider types may reduce; // throughput. Should this transform be limited (even for scalars) by using; // shouldChangeType()?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:54,Modifiability,refactor,refactor,54,"// TODO: These all require that Y is constant too, so refactor with the above.; // Try to optimize things like ""A[i] & 42 == 0"" to index computations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:90,Performance,optimiz,optimize,90,"// TODO: These all require that Y is constant too, so refactor with the above.; // Try to optimize things like ""A[i] & 42 == 0"" to index computations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:73,Energy Efficiency,power,power,73,// X & -C == -C -> X > u ~C; // X & -C != -C -> X <= u ~C; // iff C is a power of 2,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:433,Modifiability,Extend,Extend,433,"// If we are testing the intersection of 2 select-of-nonzero-constants with no; // common bits set, it's the same as checking if exactly one select condition; // is set:; // ((A ? TC : FC) & (B ? TC : FC)) == 0 --> xor A, B; // ((A ? TC : FC) & (B ? TC : FC)) != 0 --> not(xor A, B); // TODO: Generalize for non-constant values.; // TODO: Handle signed/unsigned predicates.; // TODO: Handle other bitwise logic connectors.; // TODO: Extend to handle a non-zero compare constant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:13,Testability,test,testing,13,"// If we are testing the intersection of 2 select-of-nonzero-constants with no; // common bits set, it's the same as checking if exactly one select condition; // is set:; // ((A ? TC : FC) & (B ? TC : FC)) == 0 --> xor A, B; // ((A ? TC : FC) & (B ? TC : FC)) != 0 --> not(xor A, B); // TODO: Generalize for non-constant values.; // TODO: Handle signed/unsigned predicates.; // TODO: Handle other bitwise logic connectors.; // TODO: Extend to handle a non-zero compare constant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:405,Testability,log,logic,405,"// If we are testing the intersection of 2 select-of-nonzero-constants with no; // common bits set, it's the same as checking if exactly one select condition; // is set:; // ((A ? TC : FC) & (B ? TC : FC)) == 0 --> xor A, B; // ((A ? TC : FC) & (B ? TC : FC)) != 0 --> not(xor A, B); // TODO: Generalize for non-constant values.; // TODO: Handle signed/unsigned predicates.; // TODO: Handle other bitwise logic connectors.; // TODO: Extend to handle a non-zero compare constant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:69,Energy Efficiency,power,power,69,// X | C == C --> X <=u C; // X | C != C --> X >u C; // iff C+1 is a power of 2 (C is a bitmask of the low bits),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:54,Availability,mask,mask,54,// More general: canonicalize 'equality with set bits mask' to; // 'equality with clear bits mask'.; // (X | MaskC) == C --> (X & ~MaskC) == C ^ MaskC; // (X | MaskC) != C --> (X & ~MaskC) != C ^ MaskC,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:93,Availability,mask,mask,93,// More general: canonicalize 'equality with set bits mask' to; // 'equality with clear bits mask'.; // (X | MaskC) == C --> (X & ~MaskC) == C ^ MaskC; // (X | MaskC) != C --> (X & ~MaskC) != C ^ MaskC,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:109,Availability,Mask,MaskC,109,// More general: canonicalize 'equality with set bits mask' to; // 'equality with clear bits mask'.; // (X | MaskC) == C --> (X & ~MaskC) == C ^ MaskC; // (X | MaskC) != C --> (X & ~MaskC) != C ^ MaskC,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:131,Availability,Mask,MaskC,131,// More general: canonicalize 'equality with set bits mask' to; // 'equality with clear bits mask'.; // (X | MaskC) == C --> (X & ~MaskC) == C ^ MaskC; // (X | MaskC) != C --> (X & ~MaskC) != C ^ MaskC,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:145,Availability,Mask,MaskC,145,// More general: canonicalize 'equality with set bits mask' to; // 'equality with clear bits mask'.; // (X | MaskC) == C --> (X & ~MaskC) == C ^ MaskC; // (X | MaskC) != C --> (X & ~MaskC) != C ^ MaskC,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:160,Availability,Mask,MaskC,160,// More general: canonicalize 'equality with set bits mask' to; // 'equality with clear bits mask'.; // (X | MaskC) == C --> (X & ~MaskC) == C ^ MaskC; // (X | MaskC) != C --> (X & ~MaskC) != C ^ MaskC,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:182,Availability,Mask,MaskC,182,// More general: canonicalize 'equality with set bits mask' to; // 'equality with clear bits mask'.; // (X | MaskC) == C --> (X & ~MaskC) == C ^ MaskC; // (X | MaskC) != C --> (X & ~MaskC) != C ^ MaskC,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:196,Availability,Mask,MaskC,196,// More general: canonicalize 'equality with set bits mask' to; // 'equality with clear bits mask'.; // (X | MaskC) == C --> (X & ~MaskC) == C ^ MaskC; // (X | MaskC) != C --> (X & ~MaskC) != C ^ MaskC,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:82,Usability,clear,clear,82,// More general: canonicalize 'equality with set bits mask' to; // 'equality with clear bits mask'.; // (X | MaskC) == C --> (X & ~MaskC) == C ^ MaskC; // (X | MaskC) != C --> (X & ~MaskC) != C ^ MaskC,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:3,Usability,Simpl,Simplify,3,"// Simplify icmp eq (or (ptrtoint P), (ptrtoint Q)), 0; // -> and (icmp eq P, null), (icmp eq Q, null).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:16,Testability,test,test,16,"// If this is a test of the sign bit and the multiply is sign-preserving with; // a constant operand, use the multiply LHS operand instead:; // (X * +MulC) < 0 --> X < 0; // (X * -MulC) < 0 --> X > 0",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:28,Integrability,wrap,wrap,28,"// If the multiply does not wrap or the constant is odd, try to divide the; // compare constant by the multiplication factor.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:148,Testability,Assert,Assert,148,"// With a matching no-overflow guarantee, fold the constants:; // (X * MulC) < C --> X < (C / MulC); // (X * MulC) > C --> X > (C / MulC); // TODO: Assert that Pred is not equal to SGE, SLE, UGE, ULE?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:58,Performance,perform,perform,58,"// Check that the shift amount is in range. If not, don't perform undefined; // shifts. When the shift is visited, it will be simplified.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:126,Usability,simpl,simplified,126,"// Check that the shift amount is in range. If not, don't perform undefined; // shifts. When the shift is visited, it will be simplified.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:136,Availability,mask,mask,136,"// NSW guarantees that we are only shifting out sign bits from the high bits,; // so we can ASHR the compare constant without needing a mask and eliminate; // the shift.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:136,Availability,mask,mask,136,"// NUW guarantees that we are only shifting out zero bits from the high bits,; // so we can LSHR the compare constant without needing a mask and eliminate; // the shift.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:12,Energy Efficiency,reduce,reduce,12,// Strength-reduce the shift into an 'and'.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:71,Testability,test,test,71,"// Otherwise, if this is a comparison of the sign bit, simplify to and/test.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:55,Usability,simpl,simplify,55,"// Otherwise, if this is a comparison of the sign bit, simplify to and/test.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:29,Testability,test,test,29,// Simplify 'shl' inequality test into 'and' equality test.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:54,Testability,test,test,54,// Simplify 'shl' inequality test into 'and' equality test.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:3,Usability,Simpl,Simplify,3,// Simplify 'shl' inequality test into 'and' equality test.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:36,Energy Efficiency,power,power,36,// (X l<< C2) u<=/u> C1 iff C1+1 is power of two -> X & (~C1 l>> C2) ==/!= 0,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:34,Energy Efficiency,power,power,34,// (X l<< C2) u</u>= C1 iff C1 is power of two -> X & (-C1 l>> C2) ==/!= 0,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:32,Energy Efficiency,power,power-of-,32,"// If the shifted constant is a power-of-2, test the shift amount directly:; // (ShiftValC >> Y) >u C --> X <u (LZ(C) - LZ(ShiftValC)); // (ShiftValC >> Y) <u C --> X >=u (LZ(C-1) - LZ(ShiftValC))",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:44,Testability,test,test,44,"// If the shifted constant is a power-of-2, test the shift amount directly:; // (ShiftValC >> Y) >u C --> X <u (LZ(C) - LZ(ShiftValC)); // (ShiftValC >> Y) <u C --> X >=u (LZ(C-1) - LZ(ShiftValC))",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:58,Performance,perform,perform,58,"// Check that the shift amount is in range. If not, don't perform undefined; // shifts. When the shift is visited it will be simplified.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:125,Usability,simpl,simplified,125,"// Check that the shift amount is in range. If not, don't perform undefined; // shifts. When the shift is visited it will be simplified.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:146,Testability,assert,assert,146,"// TODO: If we could guarantee that InstSimplify would handle all of the; // constant-value-based preconditions in the folds below, then we could assert; // those conditions rather than checking them. This is difficult because of; // undef/poison (PR34838).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:113,Testability,test,test,113,"// If the compare constant has significant bits above the lowest sign-bit,; // then convert an unsigned cmp to a test of the sign-bit:; // (ashr X, ShiftC) u> C --> X s< 0; // (ashr X, ShiftC) u< C --> X s> -1",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:85,Energy Efficiency,power,power-of-,85,// Match an 'is positive' or 'is negative' comparison of remainder by a; // constant power-of-2 value:; // (X % pow2C) sgt/slt 0,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:3,Availability,Mask,Mask,3,// Mask off the sign bit and the modulo bits (low-bits).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:70,Availability,mask,masked,70,// For 'is positive?' check that the sign-bit is clear and at least 1 masked; // bit is set. Example:; // (i8 X % 32) s> 0 --> (X & 159) s> 0,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:49,Usability,clear,clear,49,// For 'is positive?' check that the sign-bit is clear and at least 1 masked; // bit is set. Example:; // (i8 X % 32) s> 0 --> (X & 159) s> 0,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:68,Availability,mask,masked,68,// For 'is negative?' check that the sign-bit is set and at least 1 masked; // bit is set. Example:; // (i16 X % 4) s< 0 --> (X & 32771) u> 32768,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:47,Testability,test,test,47,"// Fold: icmp pred ([us]div X, C2), C -> range test; // Fold this div into the comparison, producing a range check.; // Determine, based on the divide type, what the range is being; // checked. If there is an overflow on the low or high side, remember; // it, otherwise compute the range [low, hi) bounding the new value.; // See: InsertRangeTest above for the kinds of replacements possible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:141,Testability,log,logic,141,// FIXME: If the operand types don't match the type of the divide; // then don't attempt this transform. The code below doesn't have the; // logic to deal with a signed divide and an unsigned compare (and; // vice versa). This is because (x /s C2) <s C produces different; // results than (x /s C2) <u C or (x /u C2) <s C or even; // (x /u C2) <u C. Simply casting the operands and result won't; // work. :( The if statement below tests that condition and bails; // if it finds it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:431,Testability,test,tests,431,// FIXME: If the operand types don't match the type of the divide; // then don't attempt this transform. The code below doesn't have the; // logic to deal with a signed divide and an unsigned compare (and; // vice versa). This is because (x /s C2) <s C produces different; // results than (x /s C2) <u C or (x /u C2) <s C or even; // (x /u C2) <u C. Simply casting the operands and result won't; // work. :( The if statement below tests that condition and bails; // if it finds it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:350,Usability,Simpl,Simply,350,// FIXME: If the operand types don't match the type of the divide; // then don't attempt this transform. The code below doesn't have the; // logic to deal with a signed divide and an unsigned compare (and; // vice versa). This is because (x /s C2) <s C produces different; // results than (x /s C2) <u C or (x /u C2) <s C or even; // (x /u C2) <u C. Simply casting the operands and result won't; // work. :( The if statement below tests that condition and bails; // if it finds it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:213,Testability,assert,assert,213,"// The ProdOV computation fails on divide by 0 and divide by -1. Cases with; // INT_MIN will also fail if the divisor is 1. Although folds of all these; // division-by-constant cases should be present, we can not assert that they; // have happened before we reach this icmp instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:394,Modifiability,variab,variable,394,"// Figure out the interval that is being checked. For example, a comparison; // like ""X /u 5 == 0"" is really checking that X is in the interval [0, 5).; // Compute this interval based on the constants involved and the signedness of; // the compare/divide. This computes a half-open interval, keeping track of; // whether either value in the interval overflows. After analysis each; // overflow variable is set to 0 if it's corresponding bound variable is valid; // -1 if overflowed off the bottom end, or +1 if overflowed off the top end.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:443,Modifiability,variab,variable,443,"// Figure out the interval that is being checked. For example, a comparison; // like ""X /u 5 == 0"" is really checking that X is in the interval [0, 5).; // Compute this interval based on the constants involved and the signedness of; // the compare/divide. This computes a half-open interval, keeping track of; // whether either value in the interval overflows. After analysis each; // overflow variable is set to 0 if it's corresponding bound variable is valid; // -1 if overflowed off the bottom end, or +1 if overflowed off the top end.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:217,Testability,test,test,217,"// X - Y == 0 --> X == Y.; // X - Y != 0 --> X != Y.; // TODO: We allow this with multiple uses as long as the other uses are not; // in phis. The phi use check is guarding against a codegen regression; // for a loop test. If the backend could undo this (and possibly; // subsequent transforms), we would not need this hack.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:244,Usability,undo,undo,244,"// X - Y == 0 --> X == Y.; // X - Y != 0 --> X != Y.; // TODO: We allow this with multiple uses as long as the other uses are not; // in phis. The phi use check is guarding against a codegen regression; // for a loop test. If the backend could undo this (and possibly; // subsequent transforms), we would not need this hack.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:240,Testability,test,test,240,// The following transforms are only worth it if the only user of the subtract; // is the icmp.; // TODO: This is an artificial restriction for all of the transforms below; // that only need a single replacement icmp. Can these use the phi test; // like the transform above here?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:81,Energy Efficiency,power,power,81,// C2 - Y <u C -> (Y | (C - 1)) == C2; // iff (C2 & (C - 1)) == C - 1 and C is a power of 2,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:67,Energy Efficiency,power,power,67,// C2 - Y >u C -> (Y | C) != C2; // iff C2 & C == C and C + 1 is a power of 2,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:38,Energy Efficiency,reduce,reduce,38,// We have handled special cases that reduce.; // Canonicalize any remaining sub to add as:; // (C2 - Y) > C --> (Y + ~C2) < ~C,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:23,Integrability,wrap,wrap,23,"// If the add does not wrap, we can always adjust the compare by subtracting; // the constants. Equality comparisons are handled elsewhere. SGE/SLE/UGE/ULE; // are canonicalized to SGT/SLT/UGT/ULT.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:76,Testability,assert,assert,76,"// If there is overflow, the result must be true or false.; // TODO: Can we assert there is no overflow because InstSimplify always; // handles those cases?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:69,Integrability,wrap,wrapping,69,// This set of folds is intentionally placed after folds that use no-wrapping; // flags because those folds are likely better for later analysis/codegen.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:67,Energy Efficiency,power,power,67,// X+C <u C2 -> (X & -C2) == C; // iff C & (C2-1) == 0; // C2 is a power of 2,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:65,Energy Efficiency,power,power,65,// X+C >u C2 -> (X & ~C2) != C; // iff C & C2 == 0; // C2+1 is a power of 2,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:13,Testability,test,test,13,// The range test idiom can use either ult or ugt. Arbitrarily canonicalize; // to the ult form.; // X+C2 >u C -> X+(C2-C-1) <u ~C,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:15,Performance,perform,perform,15,// And kind-of perform the result swap.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:12,Testability,test,testing,12,"// If we're testing a constant value against the result of a three way; // comparison, the result can be expressed directly in terms of the; // original values being compared. Note: We could possibly be more; // aggressive here and remove the hasOneUse test. The original select is; // really likely to simplify or sink when we remove a test of the result.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:253,Testability,test,test,253,"// If we're testing a constant value against the result of a three way; // comparison, the result can be expressed directly in terms of the; // original values being compared. Note: We could possibly be more; // aggressive here and remove the hasOneUse test. The original select is; // really likely to simplify or sink when we remove a test of the result.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:337,Testability,test,test,337,"// If we're testing a constant value against the result of a three way; // comparison, the result can be expressed directly in terms of the; // original values being compared. Note: We could possibly be more; // aggressive here and remove the hasOneUse test. The original select is; // really likely to simplify or sink when we remove a test of the result.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:303,Usability,simpl,simplify,303,"// If we're testing a constant value against the result of a three way; // comparison, the result can be expressed directly in terms of the; // original values being compared. Note: We could possibly be more; // aggressive here and remove the hasOneUse test. The original select is; // really likely to simplify or sink when we remove a test of the result.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:297,Usability,simpl,simplify,297,"// This generates the new instruction that will replace the original Cmp; // Instruction. Instead of enumerating the various combinations when; // TrueWhenLessThan, TrueWhenEqual and TrueWhenGreaterThan are true versus; // false, we rely on chaining of ORs and future passes of InstCombine to; // simplify the OR further (i.e. a s< b || a == b becomes a s<= b).; // When none of the three constants satisfy the predicate for the RHS (C),; // the entire original Cmp can be simplified to a false.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:473,Usability,simpl,simplified,473,"// This generates the new instruction that will replace the original Cmp; // Instruction. Instead of enumerating the various combinations when; // TrueWhenLessThan, TrueWhenEqual and TrueWhenGreaterThan are true versus; // false, we rely on chaining of ORs and future passes of InstCombine to; // simplify the OR further (i.e. a s< b || a == b becomes a s<= b).; // When none of the three constants satisfy the predicate for the RHS (C),; // the entire original Cmp can be simplified to a false.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:86,Modifiability,extend,extend,86,"// If this is a sign-bit test of a bitcast of a casted FP value, eliminate; // the FP extend/truncate because that cast does not change the sign-bit.; // This is true for all standard IEEE-754 types and the X86 80-bit type.; // The sign-bit is always the most significant bit in those types.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:25,Testability,test,test,25,"// If this is a sign-bit test of a bitcast of a casted FP value, eliminate; // the FP extend/truncate because that cast does not change the sign-bit.; // This is true for all standard IEEE-754 types and the X86 80-bit type.; // The sign-bit is always the most significant bit in those types.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:29,Energy Efficiency,Power,Power,29,// We can't currently handle Power style floating point operations here.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:420,Energy Efficiency,reduce,reduce,420,"// If this is checking if all elements of a vector compare are set or not,; // invert the casted vector equality compare and test if all compare; // elements are clear or not. Compare against zero is generally easier for; // analysis and codegen.; // icmp eq/ne (bitcast (not X) to iN), -1 --> icmp eq/ne (bitcast X to iN), 0; // Example: are all elements equal? --> are zero elements not equal?; // TODO: Try harder to reduce compare of 2 freely invertible operands?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:125,Testability,test,test,125,"// If this is checking if all elements of a vector compare are set or not,; // invert the casted vector equality compare and test if all compare; // elements are clear or not. Compare against zero is generally easier for; // analysis and codegen.; // icmp eq/ne (bitcast (not X) to iN), -1 --> icmp eq/ne (bitcast X to iN), 0; // Example: are all elements equal? --> are zero elements not equal?; // TODO: Try harder to reduce compare of 2 freely invertible operands?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:162,Usability,clear,clear,162,"// If this is checking if all elements of a vector compare are set or not,; // invert the casted vector equality compare and test if all compare; // elements are clear or not. Compare against zero is generally easier for; // analysis and codegen.; // icmp eq/ne (bitcast (not X) to iN), -1 --> icmp eq/ne (bitcast X to iN), 0; // Example: are all elements equal? --> are zero elements not equal?; // TODO: Try harder to reduce compare of 2 freely invertible operands?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:45,Modifiability,extend,extended,45,"// If this is checking if all elements of an extended vector are clear or not,; // compare in a narrow type to eliminate the extend:; // icmp eq/ne (bitcast (ext X) to iN), 0 --> icmp eq/ne (bitcast X to iM), 0",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:125,Modifiability,extend,extend,125,"// If this is checking if all elements of an extended vector are clear or not,; // compare in a narrow type to eliminate the extend:; // icmp eq/ne (bitcast (ext X) to iN), 0 --> icmp eq/ne (bitcast X to iM), 0",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:65,Usability,clear,clear,65,"// If this is checking if all elements of an extended vector are clear or not,; // compare in a narrow type to eliminate the extend:; // icmp eq/ne (bitcast (ext X) to iN), 0 --> icmp eq/ne (bitcast X to iM), 0",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:34,Availability,Mask,Mask,34,// Check whether every element of Mask is the same constant,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:98,Modifiability,extend,extend,98,"// For now, we only support constant integers while folding the; // ICMP(SELECT)) pattern. We can extend this to support vector of integers; // similar to the cases handled by binary ops above.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:61,Energy Efficiency,efficient,efficiently,61,"// Replace ((add A, B) != 0) with (A != -B) if A or B is; // efficiently invertible, or if the add has just this one use.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:47,Availability,mask,mask,47,// Comparing if all bits outside of a constant mask are set?; // Replace (X | C) == -1 with (X & ~C) == ~C.; // This removes the -1 constant.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:3,Energy Efficiency,Power,Power,3,// Power of 2 test:; // isPow2OrZero : ctpop(X) u< 2; // isPow2 : ctpop(X) == 1; // NotPow2OrZero: ctpop(X) u> 1; // NotPow2 : ctpop(X) != 1; // If we know any bit of X can be folded to:; // IsPow2 : X & (~Bit) == 0; // NotPow2 : X & (~Bit) != 0,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:14,Testability,test,test,14,// Power of 2 test:; // isPow2OrZero : ctpop(X) u< 2; // isPow2 : ctpop(X) == 1; // NotPow2OrZero: ctpop(X) u> 1; // NotPow2 : ctpop(X) != 1; // If we know any bit of X can be folded to:; // IsPow2 : X & (~Bit) == 0; // NotPow2 : X & (~Bit) != 0,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:30,Modifiability,refactor,refactored,30,// TODO: These folds could be refactored to be part of the above calls.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:39,Usability,simpl,simple,39,/// Handle icmp with constant (but not simple integer constant) RHS.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:10,Performance,optimiz,optimize,10,"// Try to optimize things like ""A[i] > 4"" to index computations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:107,Testability,log,logical,107,"// Try to fold the comparison into the select arms, which will cause the; // select to be converted into a logical and/or.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:19,Performance,perform,perform,19,"// We only want to perform this transformation if it will not lead to; // additional code. This is true if either both sides of the select; // fold to a constant (in which case the icmp is replaced with a select; // which will usually simplify) or this is the only user of the; // select (in which case we are trading a select+icmp for a simpler; // select+icmp) or all uses of the select can be replaced based on; // dominance information (""Global cases"").",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:235,Usability,simpl,simplify,235,"// We only want to perform this transformation if it will not lead to; // additional code. This is true if either both sides of the select; // fold to a constant (in which case the icmp is replaced with a select; // which will usually simplify) or this is the only user of the; // select (in which case we are trading a select+icmp for a simpler; // select+icmp) or all uses of the select can be replaced based on; // dominance information (""Global cases"").",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:338,Usability,simpl,simpler,338,"// We only want to perform this transformation if it will not lead to; // additional code. This is true if either both sides of the select; // fold to a constant (in which case the icmp is replaced with a select; // which will usually simplify) or this is the only user of the; // select (in which case we are trading a select+icmp for a simpler; // select+icmp) or all uses of the select can be replaced based on; // dominance information (""Global cases"").",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:177,Availability,Mask,Mask,177,"/// Some comparisons can be simplified.; /// In this case, we are looking for comparisons that look like; /// a check for a lossy truncation.; /// Folds:; /// icmp SrcPred (x & Mask), x to icmp DstPred x, Mask; /// Where Mask is some pattern that produces all-ones in low bits:; /// (-1 >> y); /// ((-1 << y) >> y) <- non-canonical, has extra uses; /// ~(-1 << y); /// ((1 << y) + (-1)) <- non-canonical, has extra uses; /// The Mask can be a constant, too.; /// For some predicates, the operands are commutative.; /// For others, x can only be on a specific side.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:205,Availability,Mask,Mask,205,"/// Some comparisons can be simplified.; /// In this case, we are looking for comparisons that look like; /// a check for a lossy truncation.; /// Folds:; /// icmp SrcPred (x & Mask), x to icmp DstPred x, Mask; /// Where Mask is some pattern that produces all-ones in low bits:; /// (-1 >> y); /// ((-1 << y) >> y) <- non-canonical, has extra uses; /// ~(-1 << y); /// ((1 << y) + (-1)) <- non-canonical, has extra uses; /// The Mask can be a constant, too.; /// For some predicates, the operands are commutative.; /// For others, x can only be on a specific side.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:221,Availability,Mask,Mask,221,"/// Some comparisons can be simplified.; /// In this case, we are looking for comparisons that look like; /// a check for a lossy truncation.; /// Folds:; /// icmp SrcPred (x & Mask), x to icmp DstPred x, Mask; /// Where Mask is some pattern that produces all-ones in low bits:; /// (-1 >> y); /// ((-1 << y) >> y) <- non-canonical, has extra uses; /// ~(-1 << y); /// ((1 << y) + (-1)) <- non-canonical, has extra uses; /// The Mask can be a constant, too.; /// For some predicates, the operands are commutative.; /// For others, x can only be on a specific side.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:429,Availability,Mask,Mask,429,"/// Some comparisons can be simplified.; /// In this case, we are looking for comparisons that look like; /// a check for a lossy truncation.; /// Folds:; /// icmp SrcPred (x & Mask), x to icmp DstPred x, Mask; /// Where Mask is some pattern that produces all-ones in low bits:; /// (-1 >> y); /// ((-1 << y) >> y) <- non-canonical, has extra uses; /// ~(-1 << y); /// ((1 << y) + (-1)) <- non-canonical, has extra uses; /// The Mask can be a constant, too.; /// For some predicates, the operands are commutative.; /// For others, x can only be on a specific side.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:28,Usability,simpl,simplified,28,"/// Some comparisons can be simplified.; /// In this case, we are looking for comparisons that look like; /// a check for a lossy truncation.; /// Folds:; /// icmp SrcPred (x & Mask), x to icmp DstPred x, Mask; /// Where Mask is some pattern that produces all-ones in low bits:; /// (-1 >> y); /// ((-1 << y) >> y) <- non-canonical, has extra uses; /// ~(-1 << y); /// ((1 << y) + (-1)) <- non-canonical, has extra uses; /// The Mask can be a constant, too.; /// For some predicates, the operands are commutative.; /// For others, x can only be on a specific side.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:7,Availability,mask,mask,7,"// The mask value may be a vector constant that has undefined elements. But it; // may not be safe to propagate those undefs into the new compare, so replace; // those elements by copying an existing, defined, and safe scalar constant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:94,Safety,safe,safe,94,"// The mask value may be a vector constant that has undefined elements. But it; // may not be safe to propagate those undefs into the new compare, so replace; // those elements by copying an existing, defined, and safe scalar constant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:214,Safety,safe,safe,214,"// The mask value may be a vector constant that has undefined elements. But it; // may not be safe to propagate those undefs into the new compare, so replace; // those elements by copying an existing, defined, and safe scalar constant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:162,Availability,Mask,MaskedBits,162,"/// Some comparisons can be simplified.; /// In this case, we are looking for comparisons that look like; /// a check for a lossy signed truncation.; /// Folds: (MaskedBits is a constant.); /// ((%x << MaskedBits) a>> MaskedBits) SrcPred %x; /// Into:; /// (add %x, (1 << (KeptBits-1))) DstPred (1 << KeptBits); /// Where KeptBits = bitwidth(%x) - MaskedBits",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:202,Availability,Mask,MaskedBits,202,"/// Some comparisons can be simplified.; /// In this case, we are looking for comparisons that look like; /// a check for a lossy signed truncation.; /// Folds: (MaskedBits is a constant.); /// ((%x << MaskedBits) a>> MaskedBits) SrcPred %x; /// Into:; /// (add %x, (1 << (KeptBits-1))) DstPred (1 << KeptBits); /// Where KeptBits = bitwidth(%x) - MaskedBits",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:218,Availability,Mask,MaskedBits,218,"/// Some comparisons can be simplified.; /// In this case, we are looking for comparisons that look like; /// a check for a lossy signed truncation.; /// Folds: (MaskedBits is a constant.); /// ((%x << MaskedBits) a>> MaskedBits) SrcPred %x; /// Into:; /// (add %x, (1 << (KeptBits-1))) DstPred (1 << KeptBits); /// Where KeptBits = bitwidth(%x) - MaskedBits",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:348,Availability,Mask,MaskedBits,348,"/// Some comparisons can be simplified.; /// In this case, we are looking for comparisons that look like; /// a check for a lossy signed truncation.; /// Folds: (MaskedBits is a constant.); /// ((%x << MaskedBits) a>> MaskedBits) SrcPred %x; /// Into:; /// (add %x, (1 << (KeptBits-1))) DstPred (1 << KeptBits); /// Where KeptBits = bitwidth(%x) - MaskedBits",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:28,Usability,simpl,simplified,28,"/// Some comparisons can be simplified.; /// In this case, we are looking for comparisons that look like; /// a check for a lossy signed truncation.; /// Folds: (MaskedBits is a constant.); /// ((%x << MaskedBits) a>> MaskedBits) SrcPred %x; /// Into:; /// (add %x, (1 << (KeptBits-1))) DstPred (1 << KeptBits); /// Where KeptBits = bitwidth(%x) - MaskedBits",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:11,Availability,Mask,MaskedBits,11,"// ((%x << MaskedBits) a>> MaskedBits) == %x; // =>; // (add %x, (1 << (KeptBits-1))) u< (1 << KeptBits)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:27,Availability,Mask,MaskedBits,27,"// ((%x << MaskedBits) a>> MaskedBits) == %x; // =>; // (add %x, (1 << (KeptBits-1))) u< (1 << KeptBits)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:11,Availability,Mask,MaskedBits,11,"// ((%x << MaskedBits) a>> MaskedBits) != %x; // =>; // (add %x, (1 << (KeptBits-1))) u>= (1 << KeptBits)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:27,Availability,Mask,MaskedBits,27,"// ((%x << MaskedBits) a>> MaskedBits) != %x; // =>; // (add %x, (1 << (KeptBits-1))) u>= (1 << KeptBits)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:29,Availability,Mask,MaskedBits,29,// KeptBits = bitwidth(%x) - MaskedBits,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:135,Modifiability,rewrite,rewrite,135,"// Given pattern:; // icmp eq/ne (and ((x shift Q), (y oppositeshift K))), 0; // we should move shifts to the same hand of 'and', i.e. rewrite as; // icmp eq/ne (and (x shift (Q+K)), y), 0 iff (Q+K) u< bitwidth(x); // We are only interested in opposite logical shifts here.; // One of the shifts can be truncated.; // If we can, we want to end up creating 'lshr' shift.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:253,Testability,log,logical,253,"// Given pattern:; // icmp eq/ne (and ((x shift Q), (y oppositeshift K))), 0; // we should move shifts to the same hand of 'and', i.e. rewrite as; // icmp eq/ne (and (x shift (Q+K)), y), 0 iff (Q+K) u< bitwidth(x); // We are only interested in opposite logical shifts here.; // One of the shifts can be truncated.; // If we can, we want to end up creating 'lshr' shift.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:28,Testability,log,logical,28,"// Look for an 'and' of two logical shifts, one of which may be truncated.; // We use m_TruncOrSelf() on the RHS to correctly handle commutative case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:118,Modifiability,rewrite,rewrite,118,"// As input, we have the following pattern:; // icmp eq/ne (and ((x shift Q), (y oppositeshift K))), 0; // We want to rewrite that as:; // icmp eq/ne (and (x shift (Q+K)), y), 0 iff (Q+K) u< bitwidth(x); // While we know that originally (Q+K) would not overflow; // (because 2 * (N-1) u<= iN -1), we have looked past extensions of; // shift amounts. so it may now overflow in smaller bitwidth.; // To ensure that does not happen, we need to ensure that the total maximal; // shift amount is still representable in that smaller bit width.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:199,Performance,perform,perform,199,"// It isn't obvious whether it's worth it to analyze non-constants here.; // Also, let's basically give up on non-splat cases, pessimizing vectors.; // If *any* of these preconditions matches we can perform the fold.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:188,Safety,avoid,avoid,188,"/// Try to fold icmp (binop), X or icmp X, (binop).; /// TODO: A large part of this logic is duplicated in InstSimplify's; /// simplifyICmpWithBinOp(). We should be able to share that and avoid the code; /// duplication.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:84,Testability,log,logic,84,"/// Try to fold icmp (binop), X or icmp X, (binop).; /// TODO: A large part of this logic is duplicated in InstSimplify's; /// simplifyICmpWithBinOp(). We should be able to share that and avoid the code; /// duplication.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:127,Usability,simpl,simplifyICmpWithBinOp,127,"/// Try to fold icmp (binop), X or icmp X, (binop).; /// TODO: A large part of this logic is duplicated in InstSimplify's; /// simplifyICmpWithBinOp(). We should be able to share that and avoid the code; /// duplication.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:11,Testability,log,logic,11,// Special logic for binary operators.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:70,Availability,mask,mask,70,// Similar to above: an unsigned overflow comparison may use offset + mask:; // ((Op1 + C) & C) u< Op1 --> Op1 != 0; // ((Op1 + C) & C) u>= Op1 --> Op1 == 0; // Op0 u> ((Op0 + C) & C) --> Op0 != 0; // Op0 u<= ((Op0 + C) & C) --> Op0 == 0,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:31,Safety,avoid,avoid,31,// We don't check hasOneUse to avoid increasing register pressure because; // the value we use is the same value this instruction was already using.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:45,Availability,Mask,Mask,45,"// icmp eq/ne (X * C), (Y * C) --> icmp (X & Mask), (Y & Mask); // Mask = -1 >> count-trailing-zeros(C).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:57,Availability,Mask,Mask,57,"// icmp eq/ne (X * C), (Y * C) --> icmp (X & Mask), (Y & Mask); // Mask = -1 >> count-trailing-zeros(C).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:67,Availability,Mask,Mask,67,"// icmp eq/ne (X * C), (Y * C) --> icmp (X & Mask), (Y & Mask); // Mask = -1 >> count-trailing-zeros(C).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:31,Energy Efficiency,power,power-of-,31,// Canonicalize checking for a power-of-2-or-zero value:,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:72,Availability,mask,mask,72,"// Transform ""icmp eq (trunc (lshr(X, cst1)), cst"" to; // ""icmp (and X, mask), cst""",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:97,Performance,optimiz,optimizations,97,// Only do this when A has multiple uses. This is most important to do; // when it exposes other optimizations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:83,Security,expose,exposes,83,// Only do this when A has multiple uses. This is most important to do; // when it exposes other optimizations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:58,Availability,mask,mask,58,// Try to canonicalize trunc + compare-to-constant into a mask + cmp.; // The trunc masks high bits while the compare may effectively mask low bits.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:84,Availability,mask,masks,84,// Try to canonicalize trunc + compare-to-constant into a mask + cmp.; // The trunc masks high bits while the compare may effectively mask low bits.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:134,Availability,mask,mask,134,// Try to canonicalize trunc + compare-to-constant into a mask + cmp.; // The trunc masks high bits while the compare may effectively mask low bits.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:121,Availability,mask,masked-high-bits,121,// This matches patterns corresponding to tests of the signbit as well as:; // (trunc X) u< C --> (X & -C) == 0 (are all masked-high-bits clear?); // (trunc X) u> C --> (X & ~C) != 0 (are any masked-high-bits set?),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:192,Availability,mask,masked-high-bits,192,// This matches patterns corresponding to tests of the signbit as well as:; // (trunc X) u< C --> (X & -C) == 0 (are all masked-high-bits clear?); // (trunc X) u> C --> (X & ~C) != 0 (are any masked-high-bits set?),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:42,Testability,test,tests,42,// This matches patterns corresponding to tests of the signbit as well as:; // (trunc X) u< C --> (X & -C) == 0 (are all masked-high-bits clear?); // (trunc X) u> C --> (X & ~C) != 0 (are any masked-high-bits set?),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:138,Usability,clear,clear,138,// This matches patterns corresponding to tests of the signbit as well as:; // (trunc X) u< C --> (X & -C) == 0 (are all masked-high-bits clear?); // (trunc X) u> C --> (X & ~C) != 0 (are any masked-high-bits set?),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:43,Availability,mask,mask,43,// If C is a negative power-of-2 (high-bit mask):; // (trunc X) u< C --> (X & C) != C (are any masked-high-bits clear?),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:95,Availability,mask,masked-high-bits,95,// If C is a negative power-of-2 (high-bit mask):; // (trunc X) u< C --> (X & C) != C (are any masked-high-bits clear?),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:22,Energy Efficiency,power,power-of-,22,// If C is a negative power-of-2 (high-bit mask):; // (trunc X) u< C --> (X & C) != C (are any masked-high-bits clear?),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:112,Usability,clear,clear,112,// If C is a negative power-of-2 (high-bit mask):; // (trunc X) u< C --> (X & C) != C (are any masked-high-bits clear?),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:97,Availability,mask,masked-high-bits,97,// If C is not-of-power-of-2 (one clear bit):; // (trunc X) u> C --> (X & (C+1)) == C+1 (are all masked-high-bits set?),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:18,Energy Efficiency,power,power-of-,18,// If C is not-of-power-of-2 (one clear bit):; // (trunc X) u> C --> (X & (C+1)) == C+1 (are all masked-high-bits set?),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:34,Usability,clear,clear,34,// If C is not-of-power-of-2 (one clear bit):; // (trunc X) u> C --> (X & (C+1)) == C+1 (are all masked-high-bits set?),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:3,Modifiability,Extend,Extend,3,// Extend the narrower operand to the type of the wider operand.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:31,Modifiability,extend,extended,31,// A signed comparison of sign extended values simplifies into a; // signed comparison.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:47,Usability,simpl,simplifies,47,// A signed comparison of sign extended values simplifies into a; // signed comparison.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:31,Modifiability,extend,extended,31,// A signed comparison of sign extended values simplifies into a; // signed comparison.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:47,Usability,simpl,simplifies,47,// A signed comparison of sign extended values simplifies into a; // signed comparison.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:10,Modifiability,extend,extended,10,"// The re-extended constant changed, partly changed (in the case of a vector),; // or could not be determined to be equal (in the case of a constant; // expression), so the constant cannot be represented in the shorter type.; // All the cases that fold to true or false will have already been handled; // by simplifyICmpInst, so only deal with the tricky case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:308,Usability,simpl,simplifyICmpInst,308,"// The re-extended constant changed, partly changed (in the case of a vector),; // or could not be determined to be equal (in the case of a constant; // expression), so the constant cannot be represented in the shorter type.; // All the cases that fold to true or false will have already been handled; // by simplifyICmpInst, so only deal with the tricky case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:42,Testability,test,test,42,"/// Recognize and process idiom involving test for multiplication; /// overflow.; ///; /// The caller has matched a pattern of the form:; /// I = cmp u (mul(zext A, zext B), V; /// The function checks if this is a test for overflow and if so replaces; /// multiplication with call to 'mul.with.overflow' intrinsic.; ///; /// \param I Compare instruction.; /// \param MulVal Result of 'mult' instruction. It is one of the arguments of; /// the compare instruction. Must be of integer type.; /// \param OtherVal The other argument of compare instruction.; /// \returns Instruction which must replace the compare instruction, NULL if no; /// replacement required.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:214,Testability,test,test,214,"/// Recognize and process idiom involving test for multiplication; /// overflow.; ///; /// The caller has matched a pattern of the form:; /// I = cmp u (mul(zext A, zext B), V; /// The function checks if this is a test for overflow and if so replaces; /// multiplication with call to 'mul.with.overflow' intrinsic.; ///; /// \param I Compare instruction.; /// \param MulVal Result of 'mult' instruction. It is one of the arguments of; /// the compare instruction. Must be of integer type.; /// \param OtherVal The other argument of compare instruction.; /// \returns Instruction which must replace the compare instruction, NULL if no; /// replacement required.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:106,Performance,perform,performing,106,"// In this case we could have the operand of the binary operation; // being defined in another block, and performing the replacement; // could break the dominance relation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:185,Availability,mask,mask,185,"// If there are uses of mul result other than the comparison, we know that; // they are truncation or binary AND. Change them to use result of; // mul.with.overflow and adjust properly mask/size.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:18,Availability,mask,mask,18,// Replace (mul & mask) --> zext (mul.with.overflow & short_mask),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:79,Integrability,depend,depending,79,"// The original icmp gets replaced with the overflow value, maybe inverted; // depending on predicate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:152,Availability,mask,mask,152,"/// When performing a comparison against a constant, it is possible that not all; /// the bits in the LHS are demanded. This helper method computes the mask that; /// IS demanded.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:9,Performance,perform,performing,9,"/// When performing a comparison against a constant, it is possible that not all; /// the bits in the LHS are demanded. This helper method computes the mask that; /// IS demanded.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:1169,Performance,optimiz,optimization,1169,"/// True when a select result is replaced by one of its operands; /// in select-icmp sequence. This will eventually result in the elimination; /// of the select.; ///; /// \param SI Select instruction; /// \param Icmp Compare instruction; /// \param SIOpd Operand that replaces the select; ///; /// Notes:; /// - The replacement is global and requires dominator information; /// - The caller is responsible for the actual replacement; ///; /// Example:; ///; /// entry:; /// %4 = select i1 %3, %C* %0, %C* null; /// %5 = icmp eq %C* %4, null; /// br i1 %5, label %9, label %7; /// ...; /// ; <label>:7 ; preds = %entry; /// %8 = getelementptr inbounds %C* %4, i64 0, i32 0; /// ...; ///; /// can be transformed to; ///; /// %5 = icmp eq %C* %0, null; /// %6 = select i1 %3, i1 %5, i1 true; /// br i1 %6, label %9, label %7; /// ...; /// ; <label>:7 ; preds = %entry; /// %8 = getelementptr inbounds %C* %0, i64 0, i32 0 // replace by %0!; ///; /// Similar when the first operand of the select is a constant or/and; /// the compare is for not equal rather than equal.; ///; /// NOTE: The function is only called when the select and compare constants; /// are equal, the optimization can work only for EQ predicates. This is not a; /// major restriction since a NE compare should be 'normalized' to an equal; /// compare, which usually happens in the combiner and test case; /// select-cmp-br.ll checks for it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:1362,Testability,test,test,1362,"/// True when a select result is replaced by one of its operands; /// in select-icmp sequence. This will eventually result in the elimination; /// of the select.; ///; /// \param SI Select instruction; /// \param Icmp Compare instruction; /// \param SIOpd Operand that replaces the select; ///; /// Notes:; /// - The replacement is global and requires dominator information; /// - The caller is responsible for the actual replacement; ///; /// Example:; ///; /// entry:; /// %4 = select i1 %3, %C* %0, %C* null; /// %5 = icmp eq %C* %4, null; /// br i1 %5, label %9, label %7; /// ...; /// ; <label>:7 ; preds = %entry; /// %8 = getelementptr inbounds %C* %4, i64 0, i32 0; /// ...; ///; /// can be transformed to; ///; /// %5 = icmp eq %C* %0, null; /// %6 = select i1 %3, i1 %5, i1 true; /// br i1 %6, label %9, label %7; /// ...; /// ; <label>:7 ; preds = %entry; /// %8 = getelementptr inbounds %C* %0, i64 0, i32 0 // replace by %0!; ///; /// Similar when the first operand of the select is a constant or/and; /// the compare is for not equal rather than equal.; ///; /// NOTE: The function is only called when the select and compare constants; /// are equal, the optimization can work only for EQ predicates. This is not a; /// major restriction since a NE compare should be 'normalized' to an equal; /// compare, which usually happens in the combiner and test case; /// select-cmp-br.ll checks for it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:94,Energy Efficiency,efficient,efficiently,94,"// The check for the single predecessor is not the best that can be; // done. But it protects efficiently against cases like when SI's; // home block has two successors, Succ and Succ1, and Succ1 predecessor; // of Succ. Then SI can't be replaced by SIOpd because the use that gets; // replaced can be reached on either path. So the uniqueness check; // guarantees that the path all uses of SI (outside SI's parent) are on; // is disjoint from all other paths out of SI. But that information; // is more expensive to compute, and the trade-off here is in favor; // of compile-time. It should also be noticed that we check for a single; // predecessor and not only uniqueness. This to handle the situation when; // Succ and Succ1 points to the same basic block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:201,Availability,reliab,reliably,201,// Don't use dominating conditions when folding icmp using known bits. This; // may convert signed into unsigned predicates in ways that other passes; // (especially IndVarSimplify) may not be able to reliably undo.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:210,Usability,undo,undo,210,// Don't use dominating conditions when folding icmp using known bits. This; // may convert signed into unsigned predicates in ways that other passes; // (especially IndVarSimplify) may not be able to reliably undo.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:49,Usability,Simpl,SimplifyDemandedBits,49,"// If Min and Max are known to be the same, then SimplifyDemandedBits figured; // out that the LHS or RHS is a constant. Constant fold this now, so that; // code below can assume that Min != Max.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:75,Usability,simpl,simplify,75,"// Based on the range information we know about the LHS, see if we can; // simplify this comparison. For example, (x&4) < 8 is always true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:93,Energy Efficiency,reduce,reduce,93,"/// If one operand of an icmp is effectively a bool (value range of {0,1}),; /// then try to reduce patterns based on that limit.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:40,Safety,safe,safely,40,// Check if the constant operand can be safely incremented/decremented; // without overflowing/underflowing.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:37,Safety,safe,safely,37,// Bail out if the constant can't be safely incremented/decremented.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:10,Performance,scalab,scalable,10,// Handle scalable splat,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:37,Safety,safe,safely,37,// Bail out if the constant can't be safely incremented/decremented.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:17,Safety,safe,safe,17,"// It may not be safe to change a compare predicate in the presence of; // undefined elements, so replace those elements with the first safe constant; // that we found.; // TODO: in case of poison, it is safe; let's replace undefs only.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:136,Safety,safe,safe,136,"// It may not be safe to change a compare predicate in the presence of; // undefined elements, so replace those elements with the first safe constant; // that we found.; // TODO: in case of poison, it is safe; let's replace undefs only.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:204,Safety,safe,safe,204,"// It may not be safe to change a compare predicate in the presence of; // undefined elements, so replace those elements with the first safe constant; // that we found.; // TODO: in case of poison, it is safe; let's replace undefs only.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:70,Deployability,update,update,70,"/// If we have a comparison with a non-canonical predicate, if we can update; /// all the users, invert the predicate and adjust all the users.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:8,Energy Efficiency,adapt,adapt,8,"// And, adapt users.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:8,Modifiability,adapt,adapt,8,"// And, adapt users.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:43,Usability,simpl,simplified,43,// A boolean compared to true/false can be simplified to Op0/true/false in; // 14 out of the 20 (10 predicates * 2 constants) possible combinations.; // Cases not handled by InstSimplify are always 'not' of Op0.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:63,Availability,mask,mask,63,"// If both arguments of the cmp are shuffles that use the same mask and; // shuffle within a single vector, move the shuffle after the cmp:; // cmp (shuffle V1, M), (shuffle V2, M) --> shuffle (cmp V1, V2), M",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:126,Availability,recover,recover,126,"// We allow undefs in matching, but this transform removes those for safety.; // Demanded elements analysis should be able to recover some/all of that.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:69,Safety,safe,safety,69,"// We allow undefs in matching, but this transform removes those for safety.; // Demanded elements analysis should be able to recover some/all of that.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:126,Safety,recover,recover,126,"// We allow undefs in matching, but this transform removes those for safety.; // Demanded elements analysis should be able to recover some/all of that.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:57,Energy Efficiency,reduce,reduce,57,"/// This function folds patterns produced by lowering of reduce idioms, such as; /// llvm.vector.reduce.and which are lowered into instruction chains. This code; /// attempts to generate fewer number of scalar comparisons instead of vector; /// comparisons when possible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:97,Energy Efficiency,reduce,reduce,97,"/// This function folds patterns produced by lowering of reduce idioms, such as; /// llvm.vector.reduce.and which are lowered into instruction chains. This code; /// attempts to generate fewer number of scalar comparisons instead of vector; /// comparisons when possible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:34,Energy Efficiency,reduce,reduce,34,"// Match lowering of @llvm.vector.reduce.and. Turn; /// %vec_ne = icmp ne <8 x i8> %lhs, %rhs; /// %scalar_ne = bitcast <8 x i1> %vec_ne to i8; /// %res = icmp <pred> i8 %scalar_ne, 0; ///; /// into; ///; /// %lhs.scalar = bitcast <8 x i8> %lhs to i64; /// %rhs.scalar = bitcast <8 x i8> %rhs to i64; /// %res = icmp <pred> i64 %lhs.scalar, %rhs.scalar; ///; /// for <pred> in {ne, eq}.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:10,Performance,optimiz,optimize,10,"// Try to optimize 'icmp GEP, P' or 'icmp P, GEP'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:3,Testability,Test,Test,3,"// Test if the ICmpInst instruction is used exclusively by a select as; // part of a minimum or maximum operation. If so, refrain from doing; // any other folding. This helps out other analyses which understand; // non-obfuscated minimum and maximum idioms, such as ScalarEvolution; // and CodeGen. And in this case, at least one of the comparison; // operands has at least one user besides the compare (the select),; // which would often largely negate the benefit of folding anyway.; //; // Do the same for the other patterns recognized by matchSelectPattern.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:311,Availability,down,down,311,"// FIXME: We only do this after checking for min/max to prevent infinite; // looping caused by a reverse canonicalization of these patterns for min/max.; // FIXME: The organization of folds is a mess. These would naturally go into; // canonicalizeCmpWithConstant(), but we can't move all of the above folds; // down here after the min/max restriction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:59,Usability,clear,clear,59,// For i32: x <u 2147483648 -> x >s -1 -> true if sign bit clear,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:33,Integrability,wrap,wrapping,33,"// The folds in here may rely on wrapping flags and special constants, so; // they can break up min/max idioms in some cases but not seemingly similar; // patterns.; // FIXME: It may be possible to enhance select folding to make this; // unnecessary. It may also be moot if we canonicalize to min/max; // intrinsics.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:198,Modifiability,enhance,enhance,198,"// The folds in here may rely on wrapping flags and special constants, so; // they can break up min/max idioms in some cases but not seemingly similar; // patterns.; // FIXME: It may be possible to enhance select folding to make this; // unnecessary. It may also be moot if we canonicalize to min/max; // intrinsics.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:41,Testability,test,test,41,// Try to match comparison as a sign bit test. Intentionally do this after; // foldICmpInstWithConstant() to potentially let other folds to happen first.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:453,Integrability,depend,depend,453,"// In case of a comparison with two select instructions having the same; // condition, check whether one of the resulting branches can be simplified.; // If so, just compare the other branch and select the appropriate result.; // For example:; // %tmp1 = select i1 %cmp, i32 %y, i32 %x; // %tmp2 = select i1 %cmp, i32 %z, i32 %x; // %cmp2 = icmp slt i32 %tmp2, %tmp1; // The icmp will result false for the false value of selects and the result; // will depend upon the comparison of true values of selects if %cmp is; // true. Thus, transform this into:; // %cmp = icmp slt i32 %y, %z; // %sel = select i1 %cond, i1 %cmp, i1 false; // This handles similar cases to transform.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:138,Usability,simpl,simplified,138,"// In case of a comparison with two select instructions having the same; // condition, check whether one of the resulting branches can be simplified.; // If so, just compare the other branch and select the appropriate result.; // For example:; // %tmp1 = select i1 %cmp, i32 %y, i32 %x; // %tmp2 = select i1 %cmp, i32 %z, i32 %x; // %cmp2 = icmp slt i32 %tmp2, %tmp1; // The icmp will result false for the false value of selects and the result; // will depend upon the comparison of true values of selects if %cmp is; // true. Thus, transform this into:; // %cmp = icmp slt i32 %y, %z; // %sel = select i1 %cond, i1 %cmp, i1 false; // This handles similar cases to transform.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:49,Usability,simpl,simplified,49,// Check whether comparison of TrueValues can be simplified,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:50,Usability,simpl,simplified,50,// Check whether comparison of FalseValues can be simplified,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:10,Performance,optimiz,optimize,10,// Try to optimize equality comparisons against alloca-based pointers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:97,Energy Efficiency,power,power,97,// Transform (X & ~Y) == 0 --> (X & Y) != 0; // and (X & ~Y) != 0 --> (X & Y) == 0; // if A is a power of 2.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:11,Testability,test,test,11,// Signbit test folds; // Fold (X u>> BitWidth - 1 Pred ZExt(i1)) --> X s< 0 Pred i1; // Fold (X s>> BitWidth - 1 Pred SExt(i1)) --> X s< 0 Pred i1,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:44,Availability,down,downwards,44,"// Following test does NOT adjust InputSize downwards for signed inputs,; // because the most negative value still requires all the mantissa bits; // to distinguish it from one less than that value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:13,Testability,test,test,13,"// Following test does NOT adjust InputSize downwards for signed inputs,; // because the most negative value still requires all the mantissa bits; // to distinguish it from one less than that value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:33,Usability,simpl,simplify,33,"// Otherwise, we can potentially simplify the comparison. We know that it; // will always come through as an integer value and we know the constant is; // not a NAN (it would have been previously simplified).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:196,Usability,simpl,simplified,196,"// Otherwise, we can potentially simplify the comparison. We know that it; // will always come through as an integer value and we know the constant is; // not a NAN (it would have been previously simplified).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:85,Testability,test,test,85,"// When C is not 0.0 and infinities are not allowed:; // (C / X) < 0.0 is a sign-bit test of X; // (C / X) < 0.0 --> X < 0.0 (if C is positive); // (C / X) < 0.0 --> X > 0.0 (if C is negative, swap the predicate); //; // Proof:; // Multiply (C / X) < 0.0 by X * X / C.; // - X is non zero, if it is the flag 'ninf' is violated.; // - C defines the sign of X * X * C. Thus it also defines whether to swap; // the predicate. C is also non zero by definition.; //; // Thus X * X / C is non zero and the transformation is valid. [qed]",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:64,Safety,avoid,avoid,64,// Check the properties of the dividend. It must not be zero to avoid a; // division by zero (see Proof).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:4,Performance,Optimiz,Optimize,4,/// Optimize fabs(X) compared with zero.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:3,Usability,Simpl,Simplify,3,"// Simplify 'fcmp pred X, X'",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:3,Testability,Test,Test,3,"// Test if the FCmpInst instruction is used exclusively by a select as; // part of a minimum or maximum operation. If so, refrain from doing; // any other folding. This helps out other analyses which understand; // non-obfuscated minimum and maximum idioms, such as ScalarEvolution; // and CodeGen. And in this case, at least one of the comparison; // operands has at least one user besides the compare (the select),; // which would often largely negate the benefit of folding anyway.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:60,Energy Efficiency,reduce,reduce,60,"// X can't possibly equal the higher-precision constant, so reduce any; // equality comparison.; // TODO: Other predicates can be handled via getFCmpCode().",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:71,Safety,Avoid,Avoid,71,"// fcmp (fpext X), C -> fcmp X, (fptrunc C) if fptrunc is lossless; // Avoid lossy conversions and denormals.; // Zero is a special case that's OK to convert.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:22,Testability,test,test,22,// Convert a sign-bit test of an FP value into a cast and integer compare.; // TODO: Simplify if the copysign constant is 0.0 or NaN.; // TODO: Handle non-zero compare constants.; // TODO: Handle other predicates.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:85,Usability,Simpl,Simplify,85,// Convert a sign-bit test of an FP value into a cast and integer compare.; // TODO: Simplify if the copysign constant is 0.0 or NaN.; // TODO: Handle non-zero compare constants.; // TODO: Handle other predicates.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h:428,Integrability,interface,interfaces,428,"//===- InstCombineInternal.h - InstCombine pass internals -------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file; ///; /// This file provides internal interfaces used to implement the InstCombine.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h:4,Performance,Perform,Perform,4,/// Perform early cleanup and prepare the InstCombine worklist.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h:103,Integrability,rout,routine,103,/// True when DB dominates all uses of DI except UI.; /// UI must be in the same block as DI.; /// The routine checks that the DI parent and DB are different.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h:37,Performance,optimiz,optimizing,37,"/// Classify whether a cast is worth optimizing.; ///; /// This is a helper to decide whether the simplification of; /// logic(cast(A), cast(B)) to cast(logic(A, B)) should be performed.; ///; /// \param CI The cast we are interested in.; ///; /// \return true if this cast actually results in any code being generated and; /// if it cannot already be eliminated by some other transformation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h:176,Performance,perform,performed,176,"/// Classify whether a cast is worth optimizing.; ///; /// This is a helper to decide whether the simplification of; /// logic(cast(A), cast(B)) to cast(logic(A, B)) should be performed.; ///; /// \param CI The cast we are interested in.; ///; /// \return true if this cast actually results in any code being generated and; /// if it cannot already be eliminated by some other transformation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h:121,Testability,log,logic,121,"/// Classify whether a cast is worth optimizing.; ///; /// This is a helper to decide whether the simplification of; /// logic(cast(A), cast(B)) to cast(logic(A, B)) should be performed.; ///; /// \param CI The cast we are interested in.; ///; /// \return true if this cast actually results in any code being generated and; /// if it cannot already be eliminated by some other transformation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h:153,Testability,log,logic,153,"/// Classify whether a cast is worth optimizing.; ///; /// This is a helper to decide whether the simplification of; /// logic(cast(A), cast(B)) to cast(logic(A, B)) should be performed.; ///; /// \param CI The cast we are interested in.; ///; /// \return true if this cast actually results in any code being generated and; /// if it cannot already be eliminated by some other transformation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h:98,Usability,simpl,simplification,98,"/// Classify whether a cast is worth optimizing.; ///; /// This is a helper to decide whether the simplification of; /// logic(cast(A), cast(B)) to cast(logic(A, B)) should be performed.; ///; /// \param CI The cast we are interested in.; ///; /// \return true if this cast actually results in any code being generated and; /// if it cannot already be eliminated by some other transformation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h:11,Performance,optimiz,optimize,11,"/// Try to optimize a sequence of instructions checking if an operation; /// on LHS and RHS overflows.; ///; /// If this overflow check is done via one of the overflow check intrinsics,; /// then CtxI has to be the call instruction calling that intrinsic. If this; /// overflow check is done by arithmetic followed by a compare, then CtxI has; /// to be the arithmetic instruction.; ///; /// If a simplification is possible, stores the simplified result of the; /// operation in OperationResult and result of the overflow check in; /// OverflowResult, and return true. If no simplification is possible,; /// returns false.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h:397,Usability,simpl,simplification,397,"/// Try to optimize a sequence of instructions checking if an operation; /// on LHS and RHS overflows.; ///; /// If this overflow check is done via one of the overflow check intrinsics,; /// then CtxI has to be the call instruction calling that intrinsic. If this; /// overflow check is done by arithmetic followed by a compare, then CtxI has; /// to be the arithmetic instruction.; ///; /// If a simplification is possible, stores the simplified result of the; /// operation in OperationResult and result of the overflow check in; /// OverflowResult, and return true. If no simplification is possible,; /// returns false.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h:436,Usability,simpl,simplified,436,"/// Try to optimize a sequence of instructions checking if an operation; /// on LHS and RHS overflows.; ///; /// If this overflow check is done via one of the overflow check intrinsics,; /// then CtxI has to be the call instruction calling that intrinsic. If this; /// overflow check is done by arithmetic followed by a compare, then CtxI has; /// to be the arithmetic instruction.; ///; /// If a simplification is possible, stores the simplified result of the; /// operation in OperationResult and result of the overflow check in; /// OverflowResult, and return true. If no simplification is possible,; /// returns false.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h:575,Usability,simpl,simplification,575,"/// Try to optimize a sequence of instructions checking if an operation; /// on LHS and RHS overflows.; ///; /// If this overflow check is done via one of the overflow check intrinsics,; /// then CtxI has to be the call instruction calling that intrinsic. If this; /// overflow check is done by arithmetic followed by a compare, then CtxI has; /// to be the arithmetic instruction.; ///; /// If a simplification is possible, stores the simplified result of the; /// operation in OperationResult and result of the overflow check in; /// OverflowResult, and return true. If no simplification is possible,; /// returns false.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h:290,Performance,perform,performed,290,/// Transform (zext icmp) to bitwise / integer operations in order to; /// eliminate it.; ///; /// \param ICI The icmp of the (zext icmp) pair we are interested in.; /// \parem CI The zext of the (zext icmp) pair we are interested in.; ///; /// \return null if the transformation cannot be performed. If the; /// transformation can be performed the new instruction that replaces the; /// (zext icmp) pair will be returned.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h:335,Performance,perform,performed,335,/// Transform (zext icmp) to bitwise / integer operations in order to; /// eliminate it.; ///; /// \param ICI The icmp of the (zext icmp) pair we are interested in.; /// \parem CI The zext of the (zext icmp) pair we are interested in.; ///; /// \return null if the transformation cannot be performed. If the; /// transformation can be performed the new instruction that replaces the; /// (zext icmp) pair will be returned.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h:4,Performance,Optimiz,Optimize,4,"/// Optimize (fcmp)&(fcmp) or (fcmp)|(fcmp).; /// NOTE: Unlike most of instcombine, this returns a Value which should; /// already be inserted into the function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h:3,Performance,Optimiz,Optimize,3,"// Optimize one of these forms:; // and i1 Op, SI / select i1 Op, i1 SI, i1 false (if IsAnd = true); // or i1 Op, SI / select i1 Op, i1 true, i1 SI (if IsAnd = false); // into simplier select instruction using isImpliedCondition.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h:176,Usability,simpl,simplier,176,"// Optimize one of these forms:; // and i1 Op, SI / select i1 Op, i1 SI, i1 false (if IsAnd = true); // or i1 Op, SI / select i1 Op, i1 true, i1 SI (if IsAnd = false); // into simplier select instruction using isImpliedCondition.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h:97,Modifiability,rewrite,rewrite,97,/// Create and insert the idiom we use to indicate a block is unreachable; /// without having to rewrite the CFG from within InstCombine.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h:56,Energy Efficiency,reduce,reduced,56,// Make sure that we reprocess all operands now that we reduced their; // use counts.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h:4,Performance,Perform,Performs,4,/// Performs a few simplifications for operators which are associative; /// or commutative.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h:19,Usability,simpl,simplifications,19,/// Performs a few simplifications for operators which are associative; /// or commutative.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h:13,Usability,simpl,simplify,13,"/// Tries to simplify binary operations which some other binary; /// operation distributes over.; ///; /// It does this by either by factorizing out common terms (eg ""(A*B)+(A*C)""; /// -> ""A*(B+C)"") or expanding out if this results in simplifications (eg: ""A; /// & (B | C) -> (A&B) | (A&C)"" if this is a win). Returns the simplified; /// value, or null if it didn't simplify.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h:235,Usability,simpl,simplifications,235,"/// Tries to simplify binary operations which some other binary; /// operation distributes over.; ///; /// It does this by either by factorizing out common terms (eg ""(A*B)+(A*C)""; /// -> ""A*(B+C)"") or expanding out if this results in simplifications (eg: ""A; /// & (B | C) -> (A&B) | (A&C)"" if this is a win). Returns the simplified; /// value, or null if it didn't simplify.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h:323,Usability,simpl,simplified,323,"/// Tries to simplify binary operations which some other binary; /// operation distributes over.; ///; /// It does this by either by factorizing out common terms (eg ""(A*B)+(A*C)""; /// -> ""A*(B+C)"") or expanding out if this results in simplifications (eg: ""A; /// & (B | C) -> (A&B) | (A&C)"" if this is a win). Returns the simplified; /// value, or null if it didn't simplify.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h:367,Usability,simpl,simplify,367,"/// Tries to simplify binary operations which some other binary; /// operation distributes over.; ///; /// It does this by either by factorizing out common terms (eg ""(A*B)+(A*C)""; /// -> ""A*(B+C)"") or expanding out if this results in simplifications (eg: ""A; /// & (B | C) -> (A&B) | (A&C)"" if this is a win). Returns the simplified; /// value, or null if it didn't simplify.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h:13,Usability,simpl,simplify,13,/// Tries to simplify add operations using the definition of remainder.; ///; /// The definition of remainder is X % C = X - (X / C ) * C. The add; /// expression X % C0 + (( X / C0 ) % C1) * C0 can be simplified to; /// X % (C0 * C1),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h:202,Usability,simpl,simplified,202,/// Tries to simplify add operations using the definition of remainder.; ///; /// The definition of remainder is X % C = X - (X / C ) * C. The add; /// expression X % C0 + (( X / C0 ) % C1) * C0 can be simplified to; /// X % (C0 * C1),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h:74,Energy Efficiency,efficient,efficiently,74,// Binary Op helper for select operations where the expression can be; // efficiently reorganized.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h:177,Availability,Mask,Mask,177,"// (Binop1 (Binop2 (logic_shift X, C), C1), (logic_shift Y, C)); // -> (logic_shift (Binop1 (Binop2 X, inv_logic_shift(C1, C)), Y), C); // (Binop1 (Binop2 (logic_shift X, Amt), Mask), (logic_shift Y, Amt)); // -> (BinOp (logic_shift (BinOp X, Y)), Mask)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h:248,Availability,Mask,Mask,248,"// (Binop1 (Binop2 (logic_shift X, C), C1), (logic_shift Y, C)); // -> (logic_shift (Binop1 (Binop2 X, inv_logic_shift(C1, C)), Y), C); // (Binop1 (Binop2 (logic_shift X, Amt), Mask), (logic_shift Y, Amt)); // -> (BinOp (logic_shift (BinOp X, Y)), Mask)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h:13,Usability,simpl,simplify,13,"/// Tries to simplify binops of select and cast of the select condition.; ///; /// (Binop (cast C), (select C, T, F)); /// -> (select C, C0, C1)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h:18,Usability,simpl,simplify,18,"/// This tries to simplify binary operations by factorizing out common terms; /// (e. g. ""(A*B)+(A*C)"" -> ""A*(B+C)"").",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h:33,Usability,simpl,simpler,33,/// Attempts to replace V with a simpler value based on the demanded; /// bits.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h:11,Integrability,rout,routine,11,"/// Helper routine of SimplifyDemandedUseBits. It computes KnownZero/KnownOne; /// bits. It also tries to handle simplifications that can be done based on; /// DemandedMask, but without modifying the Instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h:22,Usability,Simpl,SimplifyDemandedUseBits,22,"/// Helper routine of SimplifyDemandedUseBits. It computes KnownZero/KnownOne; /// bits. It also tries to handle simplifications that can be done based on; /// DemandedMask, but without modifying the Instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h:113,Usability,simpl,simplifications,113,"/// Helper routine of SimplifyDemandedUseBits. It computes KnownZero/KnownOne; /// bits. It also tries to handle simplifications that can be done based on; /// DemandedMask, but without modifying the Instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h:11,Integrability,rout,routine,11,"/// Helper routine of SimplifyDemandedUseBits. It tries to simplify demanded; /// bit for ""r1 = shr x, c1; r2 = shl r1, c2"" instruction sequence.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h:22,Usability,Simpl,SimplifyDemandedUseBits,22,"/// Helper routine of SimplifyDemandedUseBits. It tries to simplify demanded; /// bit for ""r1 = shr x, c1; r2 = shl r1, c2"" instruction sequence.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h:59,Usability,simpl,simplify,59,"/// Helper routine of SimplifyDemandedUseBits. It tries to simplify demanded; /// bit for ""r1 = shr x, c1; r2 = shl r1, c2"" instruction sequence.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h:13,Usability,simpl,simplify,13,/// Tries to simplify operands to an integer instruction based on its; /// demanded bits.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h:196,Usability,simpl,simplifies,196,"/// For a binary operator with 2 phi operands, try to hoist the binary; /// operation before the phi. This can result in fewer instructions in; /// patterns where at least one set of phi operands simplifies.; /// Example:; /// BB3: binop (phi [X, BB1], [C1, BB2]), (phi [Y, BB1], [C2, BB2]); /// -->; /// BB1: BO = binop X, Y; /// BB3: phi [BO, BB1], [(binop C1, C2), BB2]",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h:26,Integrability,wrap,wrapper,26,/// This is a convenience wrapper function for the above two functions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h:67,Performance,perform,performed,67,"/// Attempt to negate \p Root. Retuns nullptr if negation can't be performed,; /// otherwise returns negated value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp:428,Performance,load,load,428,"//===- InstCombineLoadStoreAlloca.cpp -------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the visit functions for load, store and alloca.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp:496,Performance,optimiz,optimize,496,"/// isOnlyCopiedFromConstantMemory - Recursively walk the uses of a (derived); /// pointer to an alloca. Ignore any reads of the pointer, return false if we; /// see any stores or other unknown uses. If we see pointer arithmetic, keep; /// track of whether it moves the pointer (with IsOffset) but otherwise traverse; /// the uses. If we see a memcpy/memmove that targets an unoffseted pointer to; /// the alloca, and if the source pointer is a pointer to a constant memory; /// location, we can optimize this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp:23,Performance,load,loads,23,"// Ignore non-volatile loads, they are always ok.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp:64,Performance,load,load,64,// If this is the function being called then we treat it like a load and; // ignore it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp:78,Performance,load,load,78,"// If this call site doesn't modify the memory, then we know it is just; // a load (but one that potentially returns the value itself), so we can; // ignore it if we know that the value isn't captured.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp:101,Performance,load,load,101,"// If the transfer is using the alloca as a source of the transfer, then; // ignore it since it is a load (unless the transfer is volatile).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp:77,Safety,safe,safely,77,"// If the pointer has been offset from the start of the alloca, we can't; // safely handle this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp:31,Safety,safe,safe,31,"// Otherwise, the transform is safe. Remember the copy instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp:176,Security,expose,exposed,176,"// Ensure that the alloca array size argument has type equal to the offset; // size of the alloca() pointer, which, in the tyical case, is intptr_t,; // so that any casting is exposed early.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp:309,Availability,down,down,309,"// If I and V are pointers in different address space, it is not allowed to; // use replaceAllUsesWith since I and V have different types. A; // non-target-specific transformation should not use addrspacecast on V since; // the two address space may be disjoint depending on target.; //; // This class chases down uses of the old pointer until reaching the load; // instructions, then replaces the old pointer in the load instructions with; // the new pointer. If during the chasing it sees bitcast or GEP, it will; // create new bitcast or GEP with the new pointer and use them in the load; // instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp:262,Integrability,depend,depending,262,"// If I and V are pointers in different address space, it is not allowed to; // use replaceAllUsesWith since I and V have different types. A; // non-target-specific transformation should not use addrspacecast on V since; // the two address space may be disjoint depending on target.; //; // This class chases down uses of the old pointer until reaching the load; // instructions, then replaces the old pointer in the load instructions with; // the new pointer. If during the chasing it sees bitcast or GEP, it will; // create new bitcast or GEP with the new pointer and use them in the load; // instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp:357,Performance,load,load,357,"// If I and V are pointers in different address space, it is not allowed to; // use replaceAllUsesWith since I and V have different types. A; // non-target-specific transformation should not use addrspacecast on V since; // the two address space may be disjoint depending on target.; //; // This class chases down uses of the old pointer until reaching the load; // instructions, then replaces the old pointer in the load instructions with; // the new pointer. If during the chasing it sees bitcast or GEP, it will; // create new bitcast or GEP with the new pointer and use them in the load; // instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp:417,Performance,load,load,417,"// If I and V are pointers in different address space, it is not allowed to; // use replaceAllUsesWith since I and V have different types. A; // non-target-specific transformation should not use addrspacecast on V since; // the two address space may be disjoint depending on target.; //; // This class chases down uses of the old pointer until reaching the load; // instructions, then replaces the old pointer in the load instructions with; // the new pointer. If during the chasing it sees bitcast or GEP, it will; // create new bitcast or GEP with the new pointer and use them in the load; // instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp:586,Performance,load,load,586,"// If I and V are pointers in different address space, it is not allowed to; // use replaceAllUsesWith since I and V have different types. A; // non-target-specific transformation should not use addrspacecast on V since; // the two address space may be disjoint depending on target.; //; // This class chases down uses of the old pointer until reaching the load; // instructions, then replaces the old pointer in the load instructions with; // the new pointer. If during the chasing it sees bitcast or GEP, it will; // create new bitcast or GEP with the new pointer and use them in the load; // instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp:156,Energy Efficiency,allocate,allocate,156,"// Move all alloca's of zero byte objects to the entry block and merge them; // together. Note that we only do this for alloca's, because malloc should; // allocate and return a unique pointer, even for a zero byte allocation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp:35,Performance,load,load,35,// Are we allowed to form a atomic load or store of this type?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp:24,Performance,load,load,24,"/// Helper to combine a load to a new type.; ///; /// This just does the work of combining a load to a new type. It handles; /// metadata, etc., and returns the new instruction. The \c NewTy should be the; /// loaded *value* type. This will convert it to a pointer, cast the operand to; /// that pointer type, load it, etc.; ///; /// Note that this will create all of the instructions with whatever insert; /// point the \c InstCombinerImpl currently is using.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp:93,Performance,load,load,93,"/// Helper to combine a load to a new type.; ///; /// This just does the work of combining a load to a new type. It handles; /// metadata, etc., and returns the new instruction. The \c NewTy should be the; /// loaded *value* type. This will convert it to a pointer, cast the operand to; /// that pointer type, load it, etc.; ///; /// Note that this will create all of the instructions with whatever insert; /// point the \c InstCombinerImpl currently is using.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp:210,Performance,load,loaded,210,"/// Helper to combine a load to a new type.; ///; /// This just does the work of combining a load to a new type. It handles; /// metadata, etc., and returns the new instruction. The \c NewTy should be the; /// loaded *value* type. This will convert it to a pointer, cast the operand to; /// that pointer type, load it, etc.; ///; /// Note that this will create all of the instructions with whatever insert; /// point the \c InstCombinerImpl currently is using.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp:310,Performance,load,load,310,"/// Helper to combine a load to a new type.; ///; /// This just does the work of combining a load to a new type. It handles; /// metadata, etc., and returns the new instruction. The \c NewTy should be the; /// loaded *value* type. This will convert it to a pointer, cast the operand to; /// that pointer type, load it, etc.; ///; /// Note that this will create all of the instructions with whatever insert; /// point the \c InstCombinerImpl currently is using.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp:79,Integrability,rout,routine,79,"// Note, essentially every kind of metadata should be preserved here! This; // routine is supposed to clone a store instruction changing *only its; // type*. The only metadata it makes sense to drop is metadata which is; // invalidated when the pointer type changes. This should essentially; // never be the case in LLVM, but we explicitly switch over only known; // metadata to be conservatively correct. If you are adding metadata to; // LLVM which pertains to stores, you almost certainly want to add it; // here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp:415,Integrability,rout,routine,415,"/// Combine loads to match the type of their uses' value after looking; /// through intervening bitcasts.; ///; /// The core idea here is that if the result of a load is used in an operation,; /// we should load the type most conducive to that operation. For example, when; /// loading an integer and converting that immediately to a pointer, we should; /// instead directly load a pointer.; ///; /// However, this routine must never change the width of a load or the number of; /// loads as that would introduce a semantic change. This combine is expected to; /// be a semantic no-op which just allows loads to more closely model the types; /// of their consuming operations.; ///; /// Currently, we also refuse to change the precise type used for an atomic load; /// or a volatile load. This is debatable, and might be reasonable to change; /// later. However, it is risky in case some backend or other part of LLVM is; /// relying on the exact type loaded to select appropriate atomic operations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp:12,Performance,load,loads,12,"/// Combine loads to match the type of their uses' value after looking; /// through intervening bitcasts.; ///; /// The core idea here is that if the result of a load is used in an operation,; /// we should load the type most conducive to that operation. For example, when; /// loading an integer and converting that immediately to a pointer, we should; /// instead directly load a pointer.; ///; /// However, this routine must never change the width of a load or the number of; /// loads as that would introduce a semantic change. This combine is expected to; /// be a semantic no-op which just allows loads to more closely model the types; /// of their consuming operations.; ///; /// Currently, we also refuse to change the precise type used for an atomic load; /// or a volatile load. This is debatable, and might be reasonable to change; /// later. However, it is risky in case some backend or other part of LLVM is; /// relying on the exact type loaded to select appropriate atomic operations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp:162,Performance,load,load,162,"/// Combine loads to match the type of their uses' value after looking; /// through intervening bitcasts.; ///; /// The core idea here is that if the result of a load is used in an operation,; /// we should load the type most conducive to that operation. For example, when; /// loading an integer and converting that immediately to a pointer, we should; /// instead directly load a pointer.; ///; /// However, this routine must never change the width of a load or the number of; /// loads as that would introduce a semantic change. This combine is expected to; /// be a semantic no-op which just allows loads to more closely model the types; /// of their consuming operations.; ///; /// Currently, we also refuse to change the precise type used for an atomic load; /// or a volatile load. This is debatable, and might be reasonable to change; /// later. However, it is risky in case some backend or other part of LLVM is; /// relying on the exact type loaded to select appropriate atomic operations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp:207,Performance,load,load,207,"/// Combine loads to match the type of their uses' value after looking; /// through intervening bitcasts.; ///; /// The core idea here is that if the result of a load is used in an operation,; /// we should load the type most conducive to that operation. For example, when; /// loading an integer and converting that immediately to a pointer, we should; /// instead directly load a pointer.; ///; /// However, this routine must never change the width of a load or the number of; /// loads as that would introduce a semantic change. This combine is expected to; /// be a semantic no-op which just allows loads to more closely model the types; /// of their consuming operations.; ///; /// Currently, we also refuse to change the precise type used for an atomic load; /// or a volatile load. This is debatable, and might be reasonable to change; /// later. However, it is risky in case some backend or other part of LLVM is; /// relying on the exact type loaded to select appropriate atomic operations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp:278,Performance,load,loading,278,"/// Combine loads to match the type of their uses' value after looking; /// through intervening bitcasts.; ///; /// The core idea here is that if the result of a load is used in an operation,; /// we should load the type most conducive to that operation. For example, when; /// loading an integer and converting that immediately to a pointer, we should; /// instead directly load a pointer.; ///; /// However, this routine must never change the width of a load or the number of; /// loads as that would introduce a semantic change. This combine is expected to; /// be a semantic no-op which just allows loads to more closely model the types; /// of their consuming operations.; ///; /// Currently, we also refuse to change the precise type used for an atomic load; /// or a volatile load. This is debatable, and might be reasonable to change; /// later. However, it is risky in case some backend or other part of LLVM is; /// relying on the exact type loaded to select appropriate atomic operations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp:375,Performance,load,load,375,"/// Combine loads to match the type of their uses' value after looking; /// through intervening bitcasts.; ///; /// The core idea here is that if the result of a load is used in an operation,; /// we should load the type most conducive to that operation. For example, when; /// loading an integer and converting that immediately to a pointer, we should; /// instead directly load a pointer.; ///; /// However, this routine must never change the width of a load or the number of; /// loads as that would introduce a semantic change. This combine is expected to; /// be a semantic no-op which just allows loads to more closely model the types; /// of their consuming operations.; ///; /// Currently, we also refuse to change the precise type used for an atomic load; /// or a volatile load. This is debatable, and might be reasonable to change; /// later. However, it is risky in case some backend or other part of LLVM is; /// relying on the exact type loaded to select appropriate atomic operations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp:456,Performance,load,load,456,"/// Combine loads to match the type of their uses' value after looking; /// through intervening bitcasts.; ///; /// The core idea here is that if the result of a load is used in an operation,; /// we should load the type most conducive to that operation. For example, when; /// loading an integer and converting that immediately to a pointer, we should; /// instead directly load a pointer.; ///; /// However, this routine must never change the width of a load or the number of; /// loads as that would introduce a semantic change. This combine is expected to; /// be a semantic no-op which just allows loads to more closely model the types; /// of their consuming operations.; ///; /// Currently, we also refuse to change the precise type used for an atomic load; /// or a volatile load. This is debatable, and might be reasonable to change; /// later. However, it is risky in case some backend or other part of LLVM is; /// relying on the exact type loaded to select appropriate atomic operations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp:483,Performance,load,loads,483,"/// Combine loads to match the type of their uses' value after looking; /// through intervening bitcasts.; ///; /// The core idea here is that if the result of a load is used in an operation,; /// we should load the type most conducive to that operation. For example, when; /// loading an integer and converting that immediately to a pointer, we should; /// instead directly load a pointer.; ///; /// However, this routine must never change the width of a load or the number of; /// loads as that would introduce a semantic change. This combine is expected to; /// be a semantic no-op which just allows loads to more closely model the types; /// of their consuming operations.; ///; /// Currently, we also refuse to change the precise type used for an atomic load; /// or a volatile load. This is debatable, and might be reasonable to change; /// later. However, it is risky in case some backend or other part of LLVM is; /// relying on the exact type loaded to select appropriate atomic operations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp:603,Performance,load,loads,603,"/// Combine loads to match the type of their uses' value after looking; /// through intervening bitcasts.; ///; /// The core idea here is that if the result of a load is used in an operation,; /// we should load the type most conducive to that operation. For example, when; /// loading an integer and converting that immediately to a pointer, we should; /// instead directly load a pointer.; ///; /// However, this routine must never change the width of a load or the number of; /// loads as that would introduce a semantic change. This combine is expected to; /// be a semantic no-op which just allows loads to more closely model the types; /// of their consuming operations.; ///; /// Currently, we also refuse to change the precise type used for an atomic load; /// or a volatile load. This is debatable, and might be reasonable to change; /// later. However, it is risky in case some backend or other part of LLVM is; /// relying on the exact type loaded to select appropriate atomic operations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp:759,Performance,load,load,759,"/// Combine loads to match the type of their uses' value after looking; /// through intervening bitcasts.; ///; /// The core idea here is that if the result of a load is used in an operation,; /// we should load the type most conducive to that operation. For example, when; /// loading an integer and converting that immediately to a pointer, we should; /// instead directly load a pointer.; ///; /// However, this routine must never change the width of a load or the number of; /// loads as that would introduce a semantic change. This combine is expected to; /// be a semantic no-op which just allows loads to more closely model the types; /// of their consuming operations.; ///; /// Currently, we also refuse to change the precise type used for an atomic load; /// or a volatile load. This is debatable, and might be reasonable to change; /// later. However, it is risky in case some backend or other part of LLVM is; /// relying on the exact type loaded to select appropriate atomic operations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp:783,Performance,load,load,783,"/// Combine loads to match the type of their uses' value after looking; /// through intervening bitcasts.; ///; /// The core idea here is that if the result of a load is used in an operation,; /// we should load the type most conducive to that operation. For example, when; /// loading an integer and converting that immediately to a pointer, we should; /// instead directly load a pointer.; ///; /// However, this routine must never change the width of a load or the number of; /// loads as that would introduce a semantic change. This combine is expected to; /// be a semantic no-op which just allows loads to more closely model the types; /// of their consuming operations.; ///; /// Currently, we also refuse to change the precise type used for an atomic load; /// or a volatile load. This is debatable, and might be reasonable to change; /// later. However, it is risky in case some backend or other part of LLVM is; /// relying on the exact type loaded to select appropriate atomic operations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp:952,Performance,load,loaded,952,"/// Combine loads to match the type of their uses' value after looking; /// through intervening bitcasts.; ///; /// The core idea here is that if the result of a load is used in an operation,; /// we should load the type most conducive to that operation. For example, when; /// loading an integer and converting that immediately to a pointer, we should; /// instead directly load a pointer.; ///; /// However, this routine must never change the width of a load or the number of; /// loads as that would introduce a semantic change. This combine is expected to; /// be a semantic no-op which just allows loads to more closely model the types; /// of their consuming operations.; ///; /// Currently, we also refuse to change the precise type used for an atomic load; /// or a volatile load. This is debatable, and might be reasonable to change; /// later. However, it is risky in case some backend or other part of LLVM is; /// relying on the exact type loaded to select appropriate atomic operations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp:869,Safety,risk,risky,869,"/// Combine loads to match the type of their uses' value after looking; /// through intervening bitcasts.; ///; /// The core idea here is that if the result of a load is used in an operation,; /// we should load the type most conducive to that operation. For example, when; /// loading an integer and converting that immediately to a pointer, we should; /// instead directly load a pointer.; ///; /// However, this routine must never change the width of a load or the number of; /// loads as that would introduce a semantic change. This combine is expected to; /// be a semantic no-op which just allows loads to more closely model the types; /// of their consuming operations.; ///; /// Currently, we also refuse to change the precise type used for an atomic load; /// or a volatile load. This is debatable, and might be reasonable to change; /// later. However, it is risky in case some backend or other part of LLVM is; /// relying on the exact type loaded to select appropriate atomic operations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp:87,Performance,load,loads,87,// FIXME: We could probably with some care handle both volatile and ordered; // atomic loads here but it isn't clear that this is important.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp:111,Usability,clear,clear,111,// FIXME: We could probably with some care handle both volatile and ordered; // atomic loads here but it isn't clear that this is important.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp:30,Performance,load,loaded,30,"// Fold away bit casts of the loaded value by loading the desired type.; // Note that we should not do this for pointer<->integer casts,; // because that would result in type punning.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp:46,Performance,load,loading,46,"// Fold away bit casts of the loaded value by loading the desired type.; // Note that we should not do this for pointer<->integer casts,; // because that would result in type punning.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp:38,Performance,load,loads,38,// FIXME: We should also canonicalize loads of vectors when their elements are; // cast to other types.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp:104,Usability,clear,clear,104,// FIXME: We could probably with some care handle both volatile and atomic; // stores here but it isn't clear that this is important.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp:122,Deployability,pipeline,pipeline,122,// We don't want to break loads with padding here as we'd loose; // the knowledge that padding exists for the rest of the pipeline.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp:26,Performance,load,loads,26,// We don't want to break loads with padding here as we'd loose; // the knowledge that padding exists for the rest of the pipeline.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp:35,Performance,scalab,scalable,35,// Don't unpack for structure with scalable vector.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp:63,Performance,load,load,63,// Propagate AA metadata. It'll still be valid on the narrowed load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp:64,Performance,optimiz,optimize,64,"// Bail out if the array is too large. Ideally we would like to optimize; // arrays of arbitrary size but this has a terrible impact on compile time.; // The threshold here is chosen arbitrarily, maybe needs a little bit of; // tuning.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp:58,Integrability,wrap,wrap,58,"// Make sure that, even if the multiplication below would wrap as an; // uint64_t, we still do the right thing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp:376,Performance,load,load,376,"// If we're indexing into an object of a known size, and the outer index is; // not a constant, but having any value but zero would lead to undefined; // behavior, replace it with zero.; //; // For example, if we have:; // @f.a = private unnamed_addr constant [1 x i32] [i32 12], align 4; // ...; // %arrayidx = getelementptr inbounds [1 x i32]* @f.a, i64 0, i64 %x; // ... = load i32* %arrayidx, align 4; // Then we know that we can replace %x in the GEP with i64 0.; //; // FIXME: We could fold any GEP index to zero that would cause UB if it were; // not zero. Currently, we only handle the first such index. Also, we could; // also search through non-zero constant indices if we kept track of the; // offsets those indices implied.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp:50,Availability,avail,available,50,"// Size information about scalable vectors is not available, so we cannot; // deduce whether indexing at n is undefined behaviour or not. Bail out.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp:26,Performance,scalab,scalable,26,"// Size information about scalable vectors is not available, so we cannot; // deduce whether indexing at n is undefined behaviour or not. Bail out.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp:144,Integrability,wrap,wrap,144,"// FIXME: If the GEP is not inbounds, and there are extra indices after the; // one we'll replace, those could cause the address computation to wrap; // (rendering the IsAllNonNegative() check below insufficient). We can do; // better, ignoring zero indices (and other indices we can prove small; // enough not to wrap).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp:314,Integrability,wrap,wrap,314,"// FIXME: If the GEP is not inbounds, and there are extra indices after the; // one we'll replace, those could cause the address computation to wrap; // (rendering the IsAllNonNegative() check below insufficient). We can do; // better, ignoring zero indices (and other indices we can prove small; // enough not to wrap).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp:43,Modifiability,variab,variable,43,"// If we're indexing into an object with a variable index for the memory; // access, but the object has only one element, we can assume that the index; // will always be zero. If we replace the GEP, return it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp:77,Security,access,access,77,"// If we're indexing into an object with a variable index for the memory; // access, but the object has only one element, we can assume that the index; // will always be zero. If we replace the GEP, return it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp:27,Performance,load,loaded,27,// Try to canonicalize the loaded type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp:29,Performance,load,load,29,"// Do really simple store-to-load forwarding and load CSE, to catch cases; // where there are several consecutive memory accesses to the same location,; // separated by a few arithmetic operations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp:49,Performance,load,load,49,"// Do really simple store-to-load forwarding and load CSE, to catch cases; // where there are several consecutive memory accesses to the same location,; // separated by a few arithmetic operations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp:121,Security,access,accesses,121,"// Do really simple store-to-load forwarding and load CSE, to catch cases; // where there are several consecutive memory accesses to the same location,; // separated by a few arithmetic operations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp:13,Usability,simpl,simple,13,"// Do really simple store-to-load forwarding and load CSE, to catch cases; // where there are several consecutive memory accesses to the same location,; // separated by a few arithmetic operations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp:78,Performance,load,loads,78,// None of the following transforms are legal for volatile/ordered atomic; // loads. Most of them do apply for unordered atomics.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp:3,Performance,load,load,3,"// load(gep null, ...) -> unreachable; // load null/undef -> unreachable; // TODO: Consider a target hook for valid address spaces for this xforms.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp:42,Performance,load,load,42,"// load(gep null, ...) -> unreachable; // load null/undef -> unreachable; // TODO: Consider a target hook for valid address spaces for this xforms.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp:276,Performance,load,loads,276,"// Change select and PHI nodes to select values instead of addresses: this; // helps alias analysis out a lot, allows many others simplifications, and; // exposes redundancy in the code.; //; // Note that we cannot do the transformation unless we know that the; // introduced loads cannot trap! Something like this is valid as long as; // the condition is always false: load (select bool %C, int* null, int* %G),; // but it would not be valid if we transformed it to load from null; // unconditionally.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp:370,Performance,load,load,370,"// Change select and PHI nodes to select values instead of addresses: this; // helps alias analysis out a lot, allows many others simplifications, and; // exposes redundancy in the code.; //; // Note that we cannot do the transformation unless we know that the; // introduced loads cannot trap! Something like this is valid as long as; // the condition is always false: load (select bool %C, int* null, int* %G),; // but it would not be valid if we transformed it to load from null; // unconditionally.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp:467,Performance,load,load,467,"// Change select and PHI nodes to select values instead of addresses: this; // helps alias analysis out a lot, allows many others simplifications, and; // exposes redundancy in the code.; //; // Note that we cannot do the transformation unless we know that the; // introduced loads cannot trap! Something like this is valid as long as; // the condition is always false: load (select bool %C, int* null, int* %G),; // but it would not be valid if we transformed it to load from null; // unconditionally.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp:163,Safety,redund,redundancy,163,"// Change select and PHI nodes to select values instead of addresses: this; // helps alias analysis out a lot, allows many others simplifications, and; // exposes redundancy in the code.; //; // Note that we cannot do the transformation unless we know that the; // introduced loads cannot trap! Something like this is valid as long as; // the condition is always false: load (select bool %C, int* null, int* %G),; // but it would not be valid if we transformed it to load from null; // unconditionally.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp:155,Security,expose,exposes,155,"// Change select and PHI nodes to select values instead of addresses: this; // helps alias analysis out a lot, allows many others simplifications, and; // exposes redundancy in the code.; //; // Note that we cannot do the transformation unless we know that the; // introduced loads cannot trap! Something like this is valid as long as; // the condition is always false: load (select bool %C, int* null, int* %G),; // but it would not be valid if we transformed it to load from null; // unconditionally.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp:130,Usability,simpl,simplifications,130,"// Change select and PHI nodes to select values instead of addresses: this; // helps alias analysis out a lot, allows many others simplifications, and; // exposes redundancy in the code.; //; // Note that we cannot do the transformation unless we know that the; // introduced loads cannot trap! Something like this is valid as long as; // the condition is always false: load (select bool %C, int* null, int* %G),; // but it would not be valid if we transformed it to load from null; // unconditionally.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp:3,Performance,load,load,3,"// load (select (Cond, &V1, &V2)) --> select(Cond, load &V1, load &V2).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp:51,Performance,load,load,51,"// load (select (Cond, &V1, &V2)) --> select(Cond, load &V1, load &V2).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp:61,Performance,load,load,61,"// load (select (Cond, &V1, &V2)) --> select(Cond, load &V1, load &V2).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp:3,Performance,load,load,3,"// load (select (cond, null, P)) -> load P",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp:36,Performance,load,load,36,"// load (select (cond, null, P)) -> load P",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp:3,Performance,load,load,3,"// load (select (cond, P, null)) -> load P",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp:36,Performance,load,load,36,"// load (select (cond, P, null)) -> load P",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp:497,Safety,safe,safely,497,"/// Look for extractelement/insertvalue sequence that acts like a bitcast.; ///; /// \returns underlying value that was ""cast"", or nullptr otherwise.; ///; /// For example, if we have:; ///; /// %E0 = extractelement <2 x double> %U, i32 0; /// %V0 = insertvalue [2 x double] undef, double %E0, 0; /// %E1 = extractelement <2 x double> %U, i32 1; /// %V1 = insertvalue [2 x double] %V0, double %E1, 1; ///; /// and the layout of a <2 x double> is isomorphic to a [2 x double],; /// then %V1 can be safely approximated by a conceptual ""bitcast"" of %U.; /// Note that %U may contain non-undef values where %V1 has undef.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp:263,Integrability,rout,routine,263,"/// Combine stores to match the type of value being stored.; ///; /// The core idea here is that the memory does not have any intrinsic type and; /// where we can we should match the type of a store to the type of value being; /// stored.; ///; /// However, this routine must never change the width of a store or the number of; /// stores as that would introduce a semantic change. This combine is expected to; /// be a semantic no-op which just allows stores to more closely model the types; /// of their incoming values.; ///; /// Currently, we also refuse to change the precise type used for an atomic or; /// volatile store. This is debatable, and might be reasonable to change later.; /// However, it is risky in case some backend or other part of LLVM is relying; /// on the exact type stored to select appropriate atomic operations.; ///; /// \returns true if the store was successfully combined away. This indicates; /// the caller must erase the store instruction. We have to let the caller erase; /// the store instruction as otherwise there is no way to signal whether it was; /// combined or not: IC.EraseInstFromFunction returns a null pointer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp:709,Safety,risk,risky,709,"/// Combine stores to match the type of value being stored.; ///; /// The core idea here is that the memory does not have any intrinsic type and; /// where we can we should match the type of a store to the type of value being; /// stored.; ///; /// However, this routine must never change the width of a store or the number of; /// stores as that would introduce a semantic change. This combine is expected to; /// be a semantic no-op which just allows stores to more closely model the types; /// of their incoming values.; ///; /// Currently, we also refuse to change the precise type used for an atomic or; /// volatile store. This is debatable, and might be reasonable to change later.; /// However, it is risky in case some backend or other part of LLVM is relying; /// on the exact type stored to select appropriate atomic operations.; ///; /// \returns true if the store was successfully combined away. This indicates; /// the caller must erase the store instruction. We have to let the caller erase; /// the store instruction as otherwise there is no way to signal whether it was; /// combined or not: IC.EraseInstFromFunction returns a null pointer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp:112,Usability,clear,clear,112,// FIXME: We could probably with some care handle both volatile and ordered; // atomic stores here but it isn't clear that this is important.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp:104,Usability,clear,clear,104,// FIXME: We could probably with some care handle both volatile and atomic; // stores here but it isn't clear that this is important.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp:122,Deployability,pipeline,pipeline,122,// We don't want to break loads with padding here as we'd loose; // the knowledge that padding exists for the rest of the pipeline.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp:26,Performance,load,loads,26,// We don't want to break loads with padding here as we'd loose; // the knowledge that padding exists for the rest of the pipeline.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp:35,Performance,scalab,scalable,35,// Don't unpack for structure with scalable vector.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp:64,Performance,optimiz,optimize,64,"// Bail out if the array is too large. Ideally we would like to optimize; // arrays of arbitrary size but this has a terrible impact on compile time.; // The threshold here is chosen arbitrarily, maybe needs a little bit of; // tuning.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp:287,Performance,load,load,287,"/// equivalentAddressValues - Test if A and B will obviously have the same; /// value. This includes recognizing that %t0 and %t1 will have the same; /// value in code like this:; /// %t0 = getelementptr \@a, 0, 3; /// store i32 0, i32* %t0; /// %t1 = getelementptr \@a, 0, 3; /// %t2 = load i32* %t1; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp:30,Testability,Test,Test,30,"/// equivalentAddressValues - Test if A and B will obviously have the same; /// value. This includes recognizing that %t0 and %t1 will have the same; /// value in code like this:; /// %t0 = getelementptr \@a, 0, 3; /// store i32 0, i32* %t0; /// %t1 = getelementptr \@a, 0, 3; /// %t2 = load i32* %t1; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp:3,Testability,Test,Test,3,// Test if the values are trivially equivalent.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp:3,Testability,Test,Test,3,"// Test if the values come form identical arithmetic instructions.; // This uses isIdenticalToWhenDefined instead of isIdenticalTo because; // its only used to compare two uses within the same basic block, which; // means that they'll always either have the same value or one of them; // will have an undefined value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp:103,Modifiability,refactor,refactoring,103,// Don't hack volatile/ordered stores.; // FIXME: Some bits are legal for ordered atomic stores; needs refactoring.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp:197,Security,access,accesses,197,"// Do really simple DSE, to catch cases where there are several consecutive; // stores to the same location, separated by a few arithmetic operations. This; // situation often occurs with bitfield accesses.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp:13,Usability,simpl,simple,13,"// Do really simple DSE, to catch cases where there are several consecutive; // stores to the same location, separated by a few arithmetic operations. This; // situation often occurs with bitfield accesses.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp:146,Security,expose,expose,146,"// Manually add back the original store to the worklist now, so it will; // be processed after the operands of the removed store, as this may; // expose additional DSE opportunities.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp:16,Performance,load,load,16,"// If this is a load, we have to stop. However, if the loaded value is from; // the pointer we're loading and is producing the pointer we're storing,; // then *this* store is dead (X = load P; store X -> P).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp:55,Performance,load,loaded,55,"// If this is a load, we have to stop. However, if the loaded value is from; // the pointer we're loading and is producing the pointer we're storing,; // then *this* store is dead (X = load P; store X -> P).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp:98,Performance,load,loading,98,"// If this is a load, we have to stop. However, if the loaded value is from; // the pointer we're loading and is producing the pointer we're storing,; // then *this* store is dead (X = load P; store X -> P).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp:185,Performance,load,load,185,"// If this is a load, we have to stop. However, if the loaded value is from; // the pointer we're loading and is producing the pointer we're storing,; // then *this* store is dead (X = load P; store X -> P).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp:24,Performance,load,load,24,"// Otherwise, this is a load from some other location. Stores before it; // may not be dead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp:19,Performance,load,loads,19,"// Don't skip over loads, throws or things that can modify memory.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp:48,Usability,Simpl,SimplifyCFG,48,"// store X, null -> turns into 'unreachable' in SimplifyCFG; // store X, GEP(null, Y) -> turns into 'unreachable' in SimplifyCFG",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp:117,Usability,Simpl,SimplifyCFG,117,"// store X, null -> turns into 'unreachable' in SimplifyCFG; // store X, GEP(null, Y) -> turns into 'unreachable' in SimplifyCFG",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp:26,Security,audit,audited,26,// This code has not been audited for volatile/ordered case.; // Check if the successor block has exactly 2 incoming edges.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp:34,Safety,safe,safe,34,// Advance to a place where it is safe to insert the new store and insert it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp:112,Usability,simpl,simplify,112,"/// The specific integer value is used in a context where it is known to be; /// non-zero. If this allows us to simplify the computation, do so and return; /// the new operand, otherwise return null.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp:94,Safety,safe,safe,94,"// If V has multiple uses, then we would have to do more analysis to determine; // if this is safe. For example, the use could be in dynamically unreached; // code.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp:4,Energy Efficiency,Power,PowerOfTwo,4,// (PowerOfTwo >>u B) --> isExact since shifting out the result would make it; // inexact. Similarly for <<.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp:131,Usability,simpl,simplify,131,"// TODO: Lots more we could do here:; // If V is a phi node, we can call this on each of its operands.; // ""select cond, X, 0"" can simplify to ""X"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp:197,Energy Efficiency,reduce,reduces,197,"// TODO: This is a specific form of a much more general pattern.; // We could detect a select with any binop identity constant, or we; // could use SimplifyBinOp to see if either arm of the select reduces.; // But that needs to be done carefully and/or while removing potential; // reverse canonicalizations as in InstCombiner::foldSelectIntoOp().",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp:78,Safety,detect,detect,78,"// TODO: This is a specific form of a much more general pattern.; // We could detect a select with any binop identity constant, or we; // could use SimplifyBinOp to see if either arm of the select reduces.; // But that needs to be done carefully and/or while removing potential; // reverse canonicalizations as in InstCombiner::foldSelectIntoOp().",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp:148,Usability,Simpl,SimplifyBinOp,148,"// TODO: This is a specific form of a much more general pattern.; // We could detect a select with any binop identity constant, or we; // could use SimplifyBinOp to see if either arm of the select reduces.; // But that needs to be done carefully and/or while removing potential; // reverse canonicalizations as in InstCombiner::foldSelectIntoOp().",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp:4,Energy Efficiency,Reduce,Reduce,4,/// Reduce integer multiplication patterns that contain a (+/-1 << Z) factor.; /// Callers are expected to call this twice to handle commuted patterns.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp:30,Modifiability,extend,extended,30,// Try to convert multiply of extended operand to narrow negate and shift; // for better analysis.; // This is valid if the shift amount (trailing zeros in the multiplier; // constant) clears more high bits than the bitwidth difference between; // source and destination types:; // ({z/s}ext X) * (-1<<C) --> (zext (-X)) << C,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp:185,Usability,clear,clears,185,// Try to convert multiply of extended operand to narrow negate and shift; // for better analysis.; // This is valid if the shift amount (trailing zeros in the multiplier; // constant) clears more high bits than the bitwidth difference between; // source and destination types:; // ({z/s}ext X) * (-1<<C) --> (zext (-X)) << C,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp:3,Usability,Simpl,Simplify,3,// Simplify mul instructions with a constant RHS.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp:11,Usability,simpl,simplifies,11,// C1*MulC simplifies to a tidier constant.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp:147,Modifiability,extend,extends,147,"// (zext bool X) * (zext bool Y) --> zext (and X, Y); // (sext bool X) * (sext bool Y) --> zext (and X, Y); // Note: -1 * -1 == 1 * 1 == 1 (if the extends match, the result is the same)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp:218,Energy Efficiency,reduce,reduce,218,"// The following transforms are done irrespective of the number of uses; // for the expression ""1.0/sqrt(X)"".; // 1) 1.0/sqrt(X) * X -> X/sqrt(X); // 2) X * 1.0/sqrt(X) -> X/sqrt(X); // We always expect the backend to reduce X/sqrt(X) to sqrt(X), if it; // has the necessary (reassoc) fast-math-flags.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp:123,Usability,simpl,simplify,123,"// Like the similar transform in instsimplify, this requires 'nsz' because; // sqrt(-0.0) = -0.0, and -0.0 * -0.0 does not simplify to -0.0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp:85,Energy Efficiency,power,power,85,"// (X*Y) * X => (X*X) * Y where Y != X; // The purpose is two-fold:; // 1) to form a power expression (of X).; // 2) potentially shorten the critical path: After transformation, the; // latency of the instruction Y is amortized by the expression of X*X,; // and therefore Y is in a ""less critical"" position compared to what it; // was before the transformation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp:186,Performance,latency,latency,186,"// (X*Y) * X => (X*X) * Y where Y != X; // The purpose is two-fold:; // 1) to form a power expression (of X).; // 2) potentially shorten the critical path: After transformation, the; // latency of the instruction Y is amortized by the expression of X*X,; // and therefore Y is in a ""less critical"" position compared to what it; // was before the transformation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp:184,Safety,safe,safely,184,"// Simplify FMUL recurrences starting with 0.0 to 0.0 if nnan and nsz are set.; // Given a phi node with entry value as 0 and it used in fmul operation,; // we can replace fmul with 0 safely and eleminate loop operation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp:3,Usability,Simpl,Simplify,3,"// Simplify FMUL recurrences starting with 0.0 to 0.0 if nnan and nsz are set.; // Given a phi node with entry value as 0 and it used in fmul operation,; // we can replace fmul with 0 safely and eleminate loop operation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp:137,Performance,optimiz,optimized,137,"// We cannot preserve ninf if nnan flag is not set.; // If X is NaN and Y is Inf then in original program we had NaN * NaN,; // while in optimized version NaN * Inf and this is a poison with ninf flag.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp:23,Integrability,wrap,wrap,23,"// With appropriate no-wrap constraints, remove a common factor in the; // dividend and divisor that is disguised as a left-shifted value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp:43,Integrability,wrap,wrap,43,// Both operands must have the matching no-wrap for this kind of division.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp:23,Integrability,wrap,wrap,23,"// With appropriate no-wrap constraints, remove a common factor in the; // dividend and divisor that is disguised as a left-shift amount.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp:168,Energy Efficiency,Adapt,Adapt,168,"// If the divisor is a select-of-constants, try to constant fold all div ops:; // C / (select Cond, TrueC, FalseC) --> select Cond, (C / TrueC), (C / FalseC); // TODO: Adapt simplifyDivRemOfSelectWithZeroOp to allow this and other folds.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp:168,Modifiability,Adapt,Adapt,168,"// If the divisor is a select-of-constants, try to constant fold all div ops:; // C / (select Cond, TrueC, FalseC) --> select Cond, (C / TrueC), (C / FalseC); // TODO: Adapt simplifyDivRemOfSelectWithZeroOp to allow this and other folds.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp:174,Usability,simpl,simplifyDivRemOfSelectWithZeroOp,174,"// If the divisor is a select-of-constants, try to constant fold all div ops:; // C / (select Cond, TrueC, FalseC) --> select Cond, (C / TrueC), (C / FalseC); // TODO: Adapt simplifyDivRemOfSelectWithZeroOp to allow this and other folds.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp:3,Safety,avoid,avoid,3,// avoid X udiv 0,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp:27,Integrability,wrap,wrap,27,"// With the appropriate no-wrap constraint, remove a multiply by the divisor; // after peeking through another divide:; // ((Op1 * X) / Y) / Op1 --> X / Y",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp:163,Availability,failure,failure,163,"// Take the exact integer log2 of the value. If DoFold is true, create the; // actual instructions, otherwise return a non-null dummy value. Return nullptr; // on failure.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp:10,Testability,assert,assert,10,// FIXME: assert that Op1 isn't/doesn't contain undef.; // log2(2^C) -> C,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp:17,Testability,test,tests,17,"// The remaining tests are all recursive, so bail out if we hit the limit.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp:68,Performance,optimiz,optimization,68,"// log2(Cond ? X : Y) -> Cond ? log2(X) : log2(Y); // FIXME: missed optimization: if one of the hands of select is/contains; // undef, just directly pick the other one.; // FIXME: can both hands contain undef?; // FIXME: Require one use?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp:20,Modifiability,extend,extended,20,"/// If we have zero-extended operands of an unsigned div or rem, we may be able; /// to narrow the operation (sink the zext below the math).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp:27,Modifiability,extend,extended,27,"// If the dividend is sign-extended and the constant divisor is small enough; // to fit in the source type, shrink the division to the narrower type:; // (sext X) sdiv C --> sext (X sdiv C)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp:81,Modifiability,enhance,enhanced,81,// -X / C --> X / -C (if the negation doesn't overflow).; // TODO: This could be enhanced to handle arbitrary vector constants by; // checking if all elements are not the min-signed-val.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp:56,Safety,Safe,Safe,56,"// X sdiv (1 << Y) -> X udiv (1 << Y) ( -> X u>> Y); // Safe because the only negative value (1 << Y) can take on is; // INT_MIN, and X sdiv INT_MIN == X udiv INT_MIN == 0 if X doesn't have; // the sign bit set.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp:64,Safety,safe,safe,64,"// If the constant divisor has an exact inverse, this is always safe. If not,; // then we can still create a reciprocal if fast-math-flags allow it and the; // constant is a regular number (not zero, infinite, or denormal).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp:185,Performance,optimiz,optimization,185,"// Z / pow(X, Y) --> Z * pow(X, -Y); // Z / exp{2}(Y) --> Z * exp{2}(-Y); // In the general case, this creates an extra instruction, but fmul allows; // for better canonicalization and optimization than fdiv.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp:130,Safety,avoid,avoided,130,"// Z / (1.0 / Y) => (Y * Z); //; // This is a special case of Z / (X / Y) => (Y * Z) / X, with X = 1.0. The; // m_OneUse check is avoided because even in the case of the multiple uses; // for 1.0/Y, the number of instructions remain the same and a division is; // replaced by a multiplication.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp:72,Integrability,wrap,wraparound,72,"// powi(X, Y) / X --> powi(X, Y-1); // This is legal when (Y - 1) can't wraparound, in which case reassoc and nnan; // are required.; // TODO: Multi-use may be also better off creating Powi(x,y-1)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp:92,Integrability,depend,depending,92,"// Helper function to emit either (RemSimplificationC << X) or; // (RemSimplificationC * X) depending on whether we matched Op0/Op1 as; // (shl V, X) or (mul V, X) respectively.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp:168,Energy Efficiency,Adapt,Adapt,168,"// If the divisor is a select-of-constants, try to constant fold all rem ops:; // C % (select Cond, TrueC, FalseC) --> select Cond, (C % TrueC), (C % FalseC); // TODO: Adapt simplifyDivRemOfSelectWithZeroOp to allow this and other folds.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp:168,Modifiability,Adapt,Adapt,168,"// If the divisor is a select-of-constants, try to constant fold all rem ops:; // C % (select Cond, TrueC, FalseC) --> select Cond, (C % TrueC), (C % FalseC); // TODO: Adapt simplifyDivRemOfSelectWithZeroOp to allow this and other folds.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp:174,Usability,simpl,simplifyDivRemOfSelectWithZeroOp,174,"// If the divisor is a select-of-constants, try to constant fold all rem ops:; // C % (select Cond, TrueC, FalseC) --> select Cond, (C % TrueC), (C % FalseC); // TODO: Adapt simplifyDivRemOfSelectWithZeroOp to allow this and other folds.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp:150,Availability,fault,fault,150,"// foldOpIntoPhi will speculate instructions to the end of the PHI's; // predecessor blocks, so do this only if we know the srem or urem; // will not fault.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp:39,Energy Efficiency,power,power,39,"// X urem Y -> X and Y-1, where Y is a power of 2,",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineNegator.cpp:23,Usability,simpl,simply,23,"// In i1, negation can simply be ignored.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineNegator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineNegator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineNegator.cpp:15,Testability,log,logic,15,"// Rest of the logic is recursive, so if it's time to give up then it's time.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineNegator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineNegator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineNegator.cpp:21,Performance,cache,cached,21,"// We did not find a cached result for negation of V. While there,; // let's temporairly cache a placeholder value, with the idea that if later; // during negation we fetch it from cache, we'll know we're in a cycle.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineNegator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineNegator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineNegator.cpp:89,Performance,cache,cache,89,"// We did not find a cached result for negation of V. While there,; // let's temporairly cache a placeholder value, with the idea that if later; // during negation we fetch it from cache, we'll know we're in a cycle.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineNegator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineNegator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineNegator.cpp:181,Performance,cache,cache,181,"// We did not find a cached result for negation of V. While there,; // let's temporairly cache a placeholder value, with the idea that if later; // during negation we fetch it from cache, we'll know we're in a cycle.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineNegator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineNegator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineNegator.cpp:7,Performance,cache,cache,7,// And cache the (real) result for the future.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineNegator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineNegator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineNegator.cpp:51,Safety,avoid,avoid,51,"// We must cleanup newly-inserted instructions, to avoid any potential; // endless combine looping.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineNegator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineNegator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp:795,Performance,Load,Load,795,"// Replace Integer typed PHI PN if the PHI's value is used as a pointer value.; // If there is an existing pointer typed PHI that produces the same value as PN,; // replace PN and the IntToPtr operation with it. Otherwise, synthesize a new; // PHI node:; //; // Case-1:; // bb1:; // int_init = PtrToInt(ptr_init); // br label %bb2; // bb2:; // int_val = PHI([int_init, %bb1], [int_val_inc, %bb2]; // ptr_val = PHI([ptr_init, %bb1], [ptr_val_inc, %bb2]; // ptr_val2 = IntToPtr(int_val); // ...; // use(ptr_val2); // ptr_val_inc = ...; // inc_val_inc = PtrToInt(ptr_val_inc); //; // ==>; // bb1:; // br label %bb2; // bb2:; // ptr_val = PHI([ptr_init, %bb1], [ptr_val_inc, %bb2]; // ...; // use(ptr_val); // ptr_val_inc = ...; //; // Case-2:; // bb1:; // int_ptr = BitCast(ptr_ptr); // int_init = Load(int_ptr); // br label %bb2; // bb2:; // int_val = PHI([int_init, %bb1], [int_val_inc, %bb2]; // ptr_val2 = IntToPtr(int_val); // ...; // use(ptr_val2); // ptr_val_inc = ...; // inc_val_inc = PtrToInt(ptr_val_inc); // ==>; // bb1:; // ptr_init = Load(ptr_ptr); // br label %bb2; // bb2:; // ptr_val = PHI([ptr_init, %bb1], [ptr_val_inc, %bb2]; // ...; // use(ptr_val); // ptr_val_inc = ...; // ...; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp:1045,Performance,Load,Load,1045,"// Replace Integer typed PHI PN if the PHI's value is used as a pointer value.; // If there is an existing pointer typed PHI that produces the same value as PN,; // replace PN and the IntToPtr operation with it. Otherwise, synthesize a new; // PHI node:; //; // Case-1:; // bb1:; // int_init = PtrToInt(ptr_init); // br label %bb2; // bb2:; // int_val = PHI([int_init, %bb1], [int_val_inc, %bb2]; // ptr_val = PHI([ptr_init, %bb1], [ptr_val_inc, %bb2]; // ptr_val2 = IntToPtr(int_val); // ...; // use(ptr_val2); // ptr_val_inc = ...; // inc_val_inc = PtrToInt(ptr_val_inc); //; // ==>; // bb1:; // br label %bb2; // bb2:; // ptr_val = PHI([ptr_init, %bb1], [ptr_val_inc, %bb2]; // ...; // use(ptr_val); // ptr_val_inc = ...; //; // Case-2:; // bb1:; // int_ptr = BitCast(ptr_ptr); // int_init = Load(int_ptr); // br label %bb2; // bb2:; // int_val = PHI([int_init, %bb1], [int_val_inc, %bb2]; // ptr_val2 = IntToPtr(int_val); // ...; // use(ptr_val2); // ptr_val_inc = ...; // inc_val_inc = PtrToInt(ptr_val_inc); // ==>; // bb1:; // ptr_init = Load(ptr_ptr); // br label %bb2; // bb2:; // ptr_val = PHI([ptr_init, %bb1], [ptr_val_inc, %bb2]; // ...; // use(ptr_val); // ptr_val_inc = ...; // ...; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp:28,Performance,load,load,28,// For a single use integer load:,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp:52,Availability,avail,available,52,"// Push the integer typed Load instruction into the available; // value set, and fix it up later when the pointer typed PHI; // is synthesized.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp:26,Performance,Load,Load,26,"// Push the integer typed Load instruction into the available; // value set, and fix it up later when the pointer typed PHI; // is synthesized.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp:117,Usability,undo,undo,117,"// Explicitly replace the inttoptr (rather than inserting a ptrtoint) here,; // to make sure another transform can't undo it in the meantime.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp:48,Performance,Load,Load,48,"// Need to insert a BitCast.; // For an integer Load instruction with a single use, the load + IntToPtr; // cast will be simplified into a pointer load:; // %v = load i64, i64* %a.ip, align 8; // %v.cast = inttoptr i64 %v to float **; // ==>; // %v.ptrp = bitcast i64 * %a.ip to float **; // %v.cast = load float *, float ** %v.ptrp, align 8",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp:88,Performance,load,load,88,"// Need to insert a BitCast.; // For an integer Load instruction with a single use, the load + IntToPtr; // cast will be simplified into a pointer load:; // %v = load i64, i64* %a.ip, align 8; // %v.cast = inttoptr i64 %v to float **; // ==>; // %v.ptrp = bitcast i64 * %a.ip to float **; // %v.cast = load float *, float ** %v.ptrp, align 8",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp:147,Performance,load,load,147,"// Need to insert a BitCast.; // For an integer Load instruction with a single use, the load + IntToPtr; // cast will be simplified into a pointer load:; // %v = load i64, i64* %a.ip, align 8; // %v.cast = inttoptr i64 %v to float **; // ==>; // %v.ptrp = bitcast i64 * %a.ip to float **; // %v.cast = load float *, float ** %v.ptrp, align 8",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp:162,Performance,load,load,162,"// Need to insert a BitCast.; // For an integer Load instruction with a single use, the load + IntToPtr; // cast will be simplified into a pointer load:; // %v = load i64, i64* %a.ip, align 8; // %v.cast = inttoptr i64 %v to float **; // ==>; // %v.ptrp = bitcast i64 * %a.ip to float **; // %v.cast = load float *, float ** %v.ptrp, align 8",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp:302,Performance,load,load,302,"// Need to insert a BitCast.; // For an integer Load instruction with a single use, the load + IntToPtr; // cast will be simplified into a pointer load:; // %v = load i64, i64* %a.ip, align 8; // %v.cast = inttoptr i64 %v to float **; // ==>; // %v.ptrp = bitcast i64 * %a.ip to float **; // %v.cast = load float *, float ** %v.ptrp, align 8",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp:121,Usability,simpl,simplified,121,"// Need to insert a BitCast.; // For an integer Load instruction with a single use, the load + IntToPtr; // cast will be simplified into a pointer load:; // %v = load i64, i64* %a.ip, align 8; // %v.cast = inttoptr i64 %v to float **; // ==>; // %v.ptrp = bitcast i64 * %a.ip to float **; // %v.cast = load float *, float ** %v.ptrp, align 8",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp:117,Usability,undo,undo,117,"// Explicitly replace the inttoptr (rather than inserting a ptrtoint) here,; // to make sure another transform can't undo it in the meantime.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp:76,Performance,optimiz,optimization,76,// Iterating over all operands to check presence of target pointers for; // optimization.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp:63,Deployability,a/b,a/b,63,"/// If we have something like phi [add (a,b), add(a,c)] and if a/b/c and the; /// adds all have a single user, turn this into a phi and a single binop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp:22,Safety,safe,safe,22,"// Otherwise, this is safe to transform!",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp:218,Modifiability,variab,variable,218,"// Don't merge two GEPs when two operands differ (introducing phi nodes); // if one of the PHIs has a constant for the index. The index may be; // substantially cheaper to compute for the constants, so making it a; // variable index could pessimize the path. This also handles the case; // for struct indices, which must always be constant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp:306,Performance,load,load,306,"// If all of the base pointers of the PHI'd GEPs are from allocas, don't; // bother doing this transformation. At best, this will just save a bit of; // offset calculation, but all the predecessors will have to materialize the; // stack address into a register anyway. We'd actually rather *clone* the; // load up into the predecessors so that we have a load of a gep of an alloca,; // which can usually all be folded into the load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp:354,Performance,load,load,354,"// If all of the base pointers of the PHI'd GEPs are from allocas, don't; // bother doing this transformation. At best, this will just save a bit of; // offset calculation, but all the predecessors will have to materialize the; // stack address into a register anyway. We'd actually rather *clone* the; // load up into the predecessors so that we have a load of a gep of an alloca,; // which can usually all be folded into the load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp:427,Performance,load,load,427,"// If all of the base pointers of the PHI'd GEPs are from allocas, don't; // bother doing this transformation. At best, this will just save a bit of; // offset calculation, but all the predecessors will have to materialize the; // stack address into a register anyway. We'd actually rather *clone* the; // load up into the predecessors so that we have a load of a gep of an alloca,; // which can usually all be folded into the load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp:87,Modifiability,variab,variable,87,"// Otherwise, this is safe to transform. Insert PHI nodes for each operand; // that is variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp:22,Safety,safe,safe,22,"// Otherwise, this is safe to transform. Insert PHI nodes for each operand; // that is variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp:55,Performance,load,load,55,"/// Return true if we know that it is safe to sink the load out of the block; /// that defines it. This means that it must be obvious the value of the load is; /// not changed from the point of the load to the end of the block it is in.; ///; /// Finally, it is safe, but not profitable, to sink a load targeting a; /// non-address-taken alloca. Doing so will cause us to not promote the alloca; /// to a register.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp:151,Performance,load,load,151,"/// Return true if we know that it is safe to sink the load out of the block; /// that defines it. This means that it must be obvious the value of the load is; /// not changed from the point of the load to the end of the block it is in.; ///; /// Finally, it is safe, but not profitable, to sink a load targeting a; /// non-address-taken alloca. Doing so will cause us to not promote the alloca; /// to a register.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp:198,Performance,load,load,198,"/// Return true if we know that it is safe to sink the load out of the block; /// that defines it. This means that it must be obvious the value of the load is; /// not changed from the point of the load to the end of the block it is in.; ///; /// Finally, it is safe, but not profitable, to sink a load targeting a; /// non-address-taken alloca. Doing so will cause us to not promote the alloca; /// to a register.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp:298,Performance,load,load,298,"/// Return true if we know that it is safe to sink the load out of the block; /// that defines it. This means that it must be obvious the value of the load is; /// not changed from the point of the load to the end of the block it is in.; ///; /// Finally, it is safe, but not profitable, to sink a load targeting a; /// non-address-taken alloca. Doing so will cause us to not promote the alloca; /// to a register.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp:38,Safety,safe,safe,38,"/// Return true if we know that it is safe to sink the load out of the block; /// that defines it. This means that it must be obvious the value of the load is; /// not changed from the point of the load to the end of the block it is in.; ///; /// Finally, it is safe, but not profitable, to sink a load targeting a; /// non-address-taken alloca. Doing so will cause us to not promote the alloca; /// to a register.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp:262,Safety,safe,safe,262,"/// Return true if we know that it is safe to sink the load out of the block; /// that defines it. This means that it must be obvious the value of the load is; /// not changed from the point of the load to the end of the block it is in.; ///; /// Finally, it is safe, but not profitable, to sink a load targeting a; /// non-address-taken alloca. Doing so will cause us to not promote the alloca; /// to a register.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp:75,Performance,load,load,75,// Calls that only access inaccessible memory do not block sinking the; // load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp:19,Security,access,access,19,// Calls that only access inaccessible memory do not block sinking the; // load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp:11,Performance,load,load,11,"// If this load is a load from a GEP with a constant offset from an alloca,; // then we don't want to sink it. In its present form, it will be; // load [constant stack offset]. Sinking it will cause us to have to; // materialize the stack addresses in each predecessor in a register only to; // do a shared load from register in the successor.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp:21,Performance,load,load,21,"// If this load is a load from a GEP with a constant offset from an alloca,; // then we don't want to sink it. In its present form, it will be; // load [constant stack offset]. Sinking it will cause us to have to; // materialize the stack addresses in each predecessor in a register only to; // do a shared load from register in the successor.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp:147,Performance,load,load,147,"// If this load is a load from a GEP with a constant offset from an alloca,; // then we don't want to sink it. In its present form, it will be; // load [constant stack offset]. Sinking it will cause us to have to; // materialize the stack addresses in each predecessor in a register only to; // do a shared load from register in the successor.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp:307,Performance,load,load,307,"// If this load is a load from a GEP with a constant offset from an alloca,; // then we don't want to sink it. In its present form, it will be; // load [constant stack offset]. Sinking it will cause us to have to; // materialize the stack addresses in each predecessor in a register only to; // do a shared load from register in the successor.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp:19,Performance,load,loads,19,"// When processing loads, we need to propagate two bits of information to the; // sunk load: whether it is volatile, and what its alignment is.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp:87,Performance,load,load,87,"// When processing loads, we need to propagate two bits of information to the; // sunk load: whether it is volatile, and what its alignment is.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp:21,Performance,load,load,21,// We can't sink the load if the loaded value could be modified between the; // load and the PHI.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp:33,Performance,load,loaded,33,// We can't sink the load if the loaded value could be modified between the; // load and the PHI.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp:80,Performance,load,load,80,// We can't sink the load if the loaded value could be modified between the; // load and the PHI.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp:29,Performance,load,loads,29,"// If the PHI is of volatile loads and the load block has multiple; // successors, sinking it would remove a load of the volatile value from; // the path through the other successor.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp:43,Performance,load,load,43,"// If the PHI is of volatile loads and the load block has multiple; // successors, sinking it would remove a load of the volatile value from; // the path through the other successor.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp:109,Performance,load,load,109,"// If the PHI is of volatile loads and the load block has multiple; // successors, sinking it would remove a load of the volatile value from; // the path through the other successor.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp:21,Performance,load,load,21,// We can't sink the load if the loaded value could be modified between; // the load and the PHI.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp:33,Performance,load,loaded,33,// We can't sink the load if the loaded value could be modified between; // the load and the PHI.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp:80,Performance,load,load,80,// We can't sink the load if the loaded value could be modified between; // the load and the PHI.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp:29,Performance,load,loads,29,"// If the PHI is of volatile loads and the load block has multiple; // successors, sinking it would remove a load of the volatile value from; // the path through the other successor.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp:43,Performance,load,load,43,"// If the PHI is of volatile loads and the load block has multiple; // successors, sinking it would remove a load of the volatile value from; // the path through the other successor.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp:109,Performance,load,load,109,"// If the PHI is of volatile loads and the load block has multiple; // successors, sinking it would remove a load of the volatile value from; // the path through the other successor.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp:26,Performance,load,load,26,"// If this was a volatile load that we are merging, make sure to loop through; // and mark all the input loads as non-volatile. If we don't do this, we will; // insert a new volatile load and the old ones will not be deletable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp:105,Performance,load,loads,105,"// If this was a volatile load that we are merging, make sure to loop through; // and mark all the input loads as non-volatile. If we don't do this, we will; // insert a new volatile load and the old ones will not be deletable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp:183,Performance,load,load,183,"// If this was a volatile load that we are merging, make sure to loop through; // and mark all the input loads as non-volatile. If we don't do this, we will; // insert a new volatile load and the old ones will not be deletable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp:76,Modifiability,variab,variable,76,"// The more common cases of a phi with no constant operands or just one; // variable operand are handled by FoldPHIArgOpIntoPHI() and foldOpIntoPhi(); // respectively. foldOpIntoPhi() wants to do the opposite transform that is; // performed here. It tries to replicate a cast in the phi operand's basic; // block to expose other folding opportunities. Thus, InstCombine will; // infinite loop without this check.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp:231,Performance,perform,performed,231,"// The more common cases of a phi with no constant operands or just one; // variable operand are handled by FoldPHIArgOpIntoPHI() and foldOpIntoPhi(); // respectively. foldOpIntoPhi() wants to do the opposite transform that is; // performed here. It tries to replicate a cast in the phi operand's basic; // block to expose other folding opportunities. Thus, InstCombine will; // infinite loop without this check.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp:316,Security,expose,expose,316,"// The more common cases of a phi with no constant operands or just one; // variable operand are handled by FoldPHIArgOpIntoPHI() and foldOpIntoPhi(); // respectively. foldOpIntoPhi() wants to do the opposite transform that is; // performed here. It tries to replicate a cast in the phi operand's basic; // block to expose other folding opportunities. Thus, InstCombine will; // infinite loop without this check.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp:55,Safety,safe,safe,55,"// All incoming values are zexts or constants that are safe to truncate.; // Create a new phi node of the narrow type, phi together all of the new; // operands, and zext the result back to the original type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp:257,Usability,simpl,simplifying,257,"// Scan the instruction, looking for input operations that can be folded away.; // If all input operands to the phi are the same instruction (e.g. a cast from; // the same type or ""+42"") we can pull the operation through the PHI, reducing; // code size and simplifying code.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp:147,Modifiability,rewrite,rewrite,147,"// PHIUsers - Keep track of all of the truncated values extracted from a set; // of PHIs, along with their offset. These are the things we want to rewrite.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp:141,Safety,avoid,avoid,141,"// PHIs are often mutually cyclic, so we keep track of a whole set of PHI; // nodes which are extracted from. PHIsToSlice is a set we use to avoid; // revisiting PHIs, PHIsInspected is a ordered list of PHIs that we need to; // check the uses of (to ensure they are all extracts).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp:97,Safety,avoid,avoid,97,// PredValues - This is a temporary used when rewriting PHI nodes. It is; // hoisted out here to avoid construction/destruction thrashing.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp:85,Availability,redundant,redundant,85,// ExtractedVals - Each new PHI we introduce is saved here so we don't; // introduce redundant PHIs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp:85,Safety,redund,redundant,85,// ExtractedVals - Each new PHI we introduce is saved here so we don't; // introduce redundant PHIs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp:3,Usability,Simpl,Simplify,3,// Simplify the following patterns:; // if (cond); // / \; // ... ...; // \ /; // phi [true] [false]; // and; // switch (cond); // case v1: / \ case v2:; // ... ...; // \ /; // phi [v1] [v2]; // Make sure all inputs are constants.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp:3,Integrability,Depend,Depending,3,"// Depending on the constant, the condition may need to be inverted.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp:11,Usability,simpl,simplification,11,// PHINode simplification; //,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp:163,Modifiability,variab,variables,163,"// If this phi has a single use, and if that use just computes a value for; // the next iteration of a loop, delete the phi. This occurs with unused; // induction variables, e.g. ""for (int j = 0; ; ++j);"". Detecting this; // common case here is good because the only other things that catch this; // are induction variable analysis (sometimes) and ADCE, which is only run; // late.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp:314,Modifiability,variab,variable,314,"// If this phi has a single use, and if that use just computes a value for; // the next iteration of a loop, delete the phi. This occurs with unused; // induction variables, e.g. ""for (int j = 0; ; ++j);"". Detecting this; // common case here is good because the only other things that catch this; // are induction variable analysis (sometimes) and ADCE, which is only run; // late.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp:206,Safety,Detect,Detecting,206,"// If this phi has a single use, and if that use just computes a value for; // the next iteration of a loop, delete the phi. This occurs with unused; // induction variables, e.g. ""for (int j = 0; ; ++j);"". Detecting this; // common case here is good because the only other things that catch this; // are induction variable analysis (sometimes) and ADCE, which is only run; // late.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp:556,Availability,down,down,556,"// When a PHI is used only to be compared with zero, it is safe to replace; // an incoming value proved as known nonzero with any non-zero constant.; // For example, in the code below, the incoming value %v can be replaced; // with any non-zero constant based on the fact that the PHI is only used to; // be compared with zero and %v is a known non-zero value:; // %v = select %cond, 1, 2; // %p = phi [%v, BB] ...; // icmp eq, %p, 0; // FIXME: To be simple, handle only integer type for now.; // This handles a small number of uses to keep the complexity down, and an; // icmp(or(phi)) can equally be replaced with any non-zero constant as the; // ""or"" will only add bits.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp:59,Safety,safe,safe,59,"// When a PHI is used only to be compared with zero, it is safe to replace; // an incoming value proved as known nonzero with any non-zero constant.; // For example, in the code below, the incoming value %v can be replaced; // with any non-zero constant based on the fact that the PHI is only used to; // be compared with zero and %v is a known non-zero value:; // %v = select %cond, 1, 2; // %p = phi [%v, BB] ...; // icmp eq, %p, 0; // FIXME: To be simple, handle only integer type for now.; // This handles a small number of uses to keep the complexity down, and an; // icmp(or(phi)) can equally be replaced with any non-zero constant as the; // ""or"" will only add bits.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp:451,Usability,simpl,simple,451,"// When a PHI is used only to be compared with zero, it is safe to replace; // an incoming value proved as known nonzero with any non-zero constant.; // For example, in the code below, the incoming value %v can be replaced; // with any non-zero constant based on the fact that the PHI is only used to; // be compared with zero and %v is a known non-zero value:; // %v = select %cond, 1, 2; // %p = phi [%v, BB] ...; // icmp eq, %p, 0; // FIXME: To be simple, handle only integer type for now.; // This handles a small number of uses to keep the complexity down, and an; // icmp(or(phi)) can equally be replaced with any non-zero constant as the; // ""or"" will only add bits.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp:195,Integrability,depend,depend,195,"// If there are multiple PHIs, sort their operands so that they all list; // the blocks in the same order. This will help identical PHIs be eliminated; // by other passes. Other passes shouldn't depend on this for correctness; // however.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:27,Modifiability,variab,variable,27,"// Last, match the compare variable operand with a binop operand.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:75,Energy Efficiency,power,power,75,"/// This folds:; /// select (icmp eq (and X, C1)), TC, FC; /// iff C1 is a power 2 and the difference between TC and FC is a power-of-2.; /// To something like:; /// (shr (and (X, C1)), (log2(C1) - log2(TC-FC))) + FC; /// Or:; /// (shl (and (X, C1)), (log2(TC-FC) - log2(C1))) + FC; /// With some variations depending if FC is larger than TC, or the shift; /// isn't needed, or the bit widths don't match.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:125,Energy Efficiency,power,power-of-,125,"/// This folds:; /// select (icmp eq (and X, C1)), TC, FC; /// iff C1 is a power 2 and the difference between TC and FC is a power-of-2.; /// To something like:; /// (shr (and (X, C1)), (log2(C1) - log2(TC-FC))) + FC; /// Or:; /// (shl (and (X, C1)), (log2(TC-FC) - log2(C1))) + FC; /// With some variations depending if FC is larger than TC, or the shift; /// isn't needed, or the bit widths don't match.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:308,Integrability,depend,depending,308,"/// This folds:; /// select (icmp eq (and X, C1)), TC, FC; /// iff C1 is a power 2 and the difference between TC and FC is a power-of-2.; /// To something like:; /// (shr (and (X, C1)), (log2(C1) - log2(TC-FC))) + FC; /// Or:; /// (shl (and (X, C1)), (log2(TC-FC) - log2(C1))) + FC; /// With some variations depending if FC is larger than TC, or the shift; /// isn't needed, or the bit widths don't match.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:240,Energy Efficiency,reduce,reduce,240,"// In general, when both constants are non-zero, we would need an offset to; // replace the select. This would require more instructions than we started; // with. But there's one special-case that we handle here because it can; // simplify/reduce the instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:231,Usability,simpl,simplify,231,"// In general, when both constants are non-zero, we would need an offset to; // replace the select. This would require more instructions than we started; // with. But there's one special-case that we handle here because it can; // simplify/reduce the instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:89,Availability,mask,masked,89,"// If the select constants differ by exactly one bit and that's the same; // bit that is masked and checked by the select condition, the select can; // be replaced by bitwise logic to set/clear one bit of the constant result.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:175,Testability,log,logic,175,"// If the select constants differ by exactly one bit and that's the same; // bit that is masked and checked by the select condition, the select can; // be replaced by bitwise logic to set/clear one bit of the constant result.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:188,Usability,clear,clear,188,"// If the select constants differ by exactly one bit and that's the same; // bit that is masked and checked by the select condition, the select can; // be replaced by bitwise logic to set/clear one bit of the constant result.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:10,Availability,mask,masked,10,"// If the masked bit in V is clear, clear or set the bit in the result:; // (V & AndMaskC) == 0 ? TC : FC --> (V & AndMaskC) ^ TC; // (V & AndMaskC) == 0 ? TC : FC --> (V & AndMaskC) | TC",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:29,Usability,clear,clear,29,"// If the masked bit in V is clear, clear or set the bit in the result:; // (V & AndMaskC) == 0 ? TC : FC --> (V & AndMaskC) ^ TC; // (V & AndMaskC) == 0 ? TC : FC --> (V & AndMaskC) | TC",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:36,Usability,clear,clear,36,"// If the masked bit in V is clear, clear or set the bit in the result:; // (V & AndMaskC) == 0 ? TC : FC --> (V & AndMaskC) ^ TC; // (V & AndMaskC) == 0 ? TC : FC --> (V & AndMaskC) | TC",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:10,Availability,mask,masked,10,"// If the masked bit in V is set, set or clear the bit in the result:; // (V & AndMaskC) != 0 ? TC : FC --> (V & AndMaskC) | FC; // (V & AndMaskC) != 0 ? TC : FC --> (V & AndMaskC) ^ FC",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:41,Usability,clear,clear,41,"// If the masked bit in V is set, set or clear the bit in the result:; // (V & AndMaskC) != 0 ? TC : FC --> (V & AndMaskC) | FC; // (V & AndMaskC) != 0 ? TC : FC --> (V & AndMaskC) ^ FC",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:41,Energy Efficiency,power,power-of-,41,// Make sure one of the select arms is a power-of-2.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:120,Modifiability,enhance,enhanced,120,// TODO: The one-use restrictions for a scalar select could be eased if; // the fold of a select in visitLoadInst() was enhanced to match a pattern; // that includes a cast.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:236,Energy Efficiency,reduce,reduce,236,"// Only handle binary operators (including two-operand getelementptr) with; // one-use here. As with the cast case above, it may be possible to relax the; // one-use constraint, but that needs be examined carefully since it may not; // reduce the total number of instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:196,Safety,safe,safe,196,"// If we are sinking div/rem after a select, we may need to freeze the; // condition because div/rem may induce immediate UB with a poison operand.; // For example, the following transform is not safe if Cond can ever be poison; // because we can replace poison with zero and then we have div-by-zero that; // didn't exist in the original code:; // Cond ? x/y : x/z --> x / (Cond ? y : z)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:40,Safety,safe,safe,40,"// A udiv/urem with a common divisor is safe because UB can only occur with; // div-by-zero, and that would be present in the original code.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:74,Performance,optimiz,optimization,74,/// Try to fold the select into one of the operands to allow further; /// optimization.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:114,Testability,test,tests,114,// TODO: We probably ought to revisit cases where the select and FP; // instructions have different flags and add tests to ensure the; // behaviour is correct.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:3,Safety,Avoid,Avoid,3,"// Avoid creating select between 2 constants unless it's selecting; // between 0, 1 and -1.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:118,Modifiability,variab,variable,118,// The shift must be valid.; // TODO: This restricts the fold to constant shift amounts. Is there a way to; // handle variable shifts safely? PR47012,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:134,Safety,safe,safely,134,// The shift must be valid.; // TODO: This restricts the fold to constant shift amounts. Is there a way to; // handle variable shifts safely? PR47012,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:104,Availability,mask,mask,104,"/// We want to turn:; /// (select (icmp eq (and X, C1), 0), 0, (shl [nsw/nuw] X, C2));; /// iff C1 is a mask and the number of its leading zeros is equal to C2; /// into:; /// shl X, C2",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:296,Energy Efficiency,power,powers,296,"/// We want to turn:; /// (select (icmp eq (and X, C1), 0), Y, (BinOp Y, C2)); /// into:; /// IF C2 u>= C1; /// (BinOp Y, (shl (and X, C1), C3)); /// ELSE; /// (BinOp Y, (lshr (and X, C1), C3)); /// iff:; /// 0 on the RHS is the identity value (i.e add, xor, shl, etc...); /// C1 and C2 are both powers of 2; /// where:; /// IF C2 u>= C1; /// C3 = Log(C2) - Log(C1); /// ELSE; /// C3 = Log(C1) - Log(C2); ///; /// This transform handles cases where:; /// 1. The icmp predicate is inverted; /// 2. The select operands are reversed; /// 3. The magnitude of C2 and C1 are flipped",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:348,Testability,Log,Log,348,"/// We want to turn:; /// (select (icmp eq (and X, C1), 0), Y, (BinOp Y, C2)); /// into:; /// IF C2 u>= C1; /// (BinOp Y, (shl (and X, C1), C3)); /// ELSE; /// (BinOp Y, (lshr (and X, C1), C3)); /// iff:; /// 0 on the RHS is the identity value (i.e add, xor, shl, etc...); /// C1 and C2 are both powers of 2; /// where:; /// IF C2 u>= C1; /// C3 = Log(C2) - Log(C1); /// ELSE; /// C3 = Log(C1) - Log(C2); ///; /// This transform handles cases where:; /// 1. The icmp predicate is inverted; /// 2. The select operands are reversed; /// 3. The magnitude of C2 and C1 are flipped",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:358,Testability,Log,Log,358,"/// We want to turn:; /// (select (icmp eq (and X, C1), 0), Y, (BinOp Y, C2)); /// into:; /// IF C2 u>= C1; /// (BinOp Y, (shl (and X, C1), C3)); /// ELSE; /// (BinOp Y, (lshr (and X, C1), C3)); /// iff:; /// 0 on the RHS is the identity value (i.e add, xor, shl, etc...); /// C1 and C2 are both powers of 2; /// where:; /// IF C2 u>= C1; /// C3 = Log(C2) - Log(C1); /// ELSE; /// C3 = Log(C1) - Log(C2); ///; /// This transform handles cases where:; /// 1. The icmp predicate is inverted; /// 2. The select operands are reversed; /// 3. The magnitude of C2 and C1 are flipped",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:386,Testability,Log,Log,386,"/// We want to turn:; /// (select (icmp eq (and X, C1), 0), Y, (BinOp Y, C2)); /// into:; /// IF C2 u>= C1; /// (BinOp Y, (shl (and X, C1), C3)); /// ELSE; /// (BinOp Y, (lshr (and X, C1), C3)); /// iff:; /// 0 on the RHS is the identity value (i.e add, xor, shl, etc...); /// C1 and C2 are both powers of 2; /// where:; /// IF C2 u>= C1; /// C3 = Log(C2) - Log(C1); /// ELSE; /// C3 = Log(C1) - Log(C2); ///; /// This transform handles cases where:; /// 1. The icmp predicate is inverted; /// 2. The select operands are reversed; /// 3. The magnitude of C2 and C1 are flipped",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:396,Testability,Log,Log,396,"/// We want to turn:; /// (select (icmp eq (and X, C1), 0), Y, (BinOp Y, C2)); /// into:; /// IF C2 u>= C1; /// (BinOp Y, (shl (and X, C1), C3)); /// ELSE; /// (BinOp Y, (lshr (and X, C1), C3)); /// iff:; /// 0 on the RHS is the identity value (i.e add, xor, shl, etc...); /// C1 and C2 are both powers of 2; /// where:; /// IF C2 u>= C1; /// C3 = Log(C2) - Log(C1); /// ELSE; /// C3 = Log(C1) - Log(C2); ///; /// This transform handles cases where:; /// 1. The icmp predicate is inverted; /// 2. The select operands are reversed; /// 3. The magnitude of C2 and C1 are flipped",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:37,Availability,mask,masked,37,/// Canonicalize a set or clear of a masked set of constant bits to; /// select-of-constants form.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:26,Usability,clear,clear,26,/// Canonicalize a set or clear of a masked set of constant bits to; /// select-of-constants form.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:194,Usability,simpl,simplified,194,// Assuming that constant compared with zero is not undef (but it may be; // a vector with some undef elements). Otherwise (when a constant is undef); // the select expression should be already simplified.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:182,Availability,mask,masked,182,// Check that TrueVal is a constant instead of matching it with m_Zero(); // to handle the case when it is a scalar undef value or a vector containing; // non-zero elements that are masked by undef elements in the compare; // constant.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:37,Modifiability,variab,variables,37,// Match unsigned saturated add of 2 variables with an unnecessary 'not'.; // There are 8 commuted variants.; // Canonicalize -1 (saturated result) to true value of the select.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:37,Modifiability,variab,variables,37,// Match unsigned saturated add of 2 variables with an unnecessary 'not'.; // Strictness of the comparison is irrelevant.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:44,Integrability,wrap,wrapping,44,// The overflow may be detected via the add wrapping round.; // This is only valid for strict comparison!,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:23,Safety,detect,detected,23,// The overflow may be detected via the add wrapping round.; // This is only valid for strict comparison!,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:23,Integrability,wrap,wrap,23,// With any pair of no-wrap subtracts:; // (A > B) ? (A - B) : (B - A) --> abs(A - B),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:336,Safety,safe,safe,336,"// The remaining subtract is not ""nuw"" any more.; // If there's one use of the subtract (no other use than the use we are; // about to replace), then we know that the sub is ""nsw"" in this context; // even if it was only ""nuw"" before. If there's another use, then we can't; // add ""nsw"" to the existing instruction because it may not be safe in the; // other user's context.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:127,Usability,clear,cleared,127,"/// Attempt to fold a cttz/ctlz followed by a icmp plus select into a single; /// call to cttz/ctlz with flag 'is_zero_poison' cleared.; ///; /// For example, we can fold the following code sequence:; /// \code; /// %0 = tail call i32 @llvm.cttz.i32(i32 %x, i1 true); /// %1 = icmp ne i32 %x, 0; /// %2 = select i1 %1, i32 %0, i32 32; /// \code; ///; /// into:; /// %0 = tail call i32 @llvm.cttz.i32(i32 %x, i1 false)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:13,Modifiability,extend,extend,13,// Skip zero extend/truncate.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:14,Usability,clear,clear,14,"// Explicitly clear the 'is_zero_poison' flag. It's always valid to go from; // true to false on this flag, so we can replace it for all users.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:764,Integrability,Wrap,Wrapping,764,"/// If we have a select with an equality comparison, then we know the value in; /// one of the arms of the select. See if substituting this value into an arm; /// and simplifying the result yields the same value as the other arm.; ///; /// To make this transform safe, we must drop poison-generating flags; /// (nsw, etc) if we simplified to a binop because the select may be guarding; /// that poison from propagating. If the existing binop already had no; /// poison-generating flags, then this transform can be done by instsimplify.; ///; /// Consider:; /// %cmp = icmp eq i32 %x, 2147483647; /// %add = add nsw i32 %x, 1; /// %sel = select i1 %cmp, i32 -2147483648, i32 %add; ///; /// We can't replace %sel with %add unless we strip away the flags.; /// TODO: Wrapping flags could be preserved in some cases with better analysis.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:263,Safety,safe,safe,263,"/// If we have a select with an equality comparison, then we know the value in; /// one of the arms of the select. See if substituting this value into an arm; /// and simplifying the result yields the same value as the other arm.; ///; /// To make this transform safe, we must drop poison-generating flags; /// (nsw, etc) if we simplified to a binop because the select may be guarding; /// that poison from propagating. If the existing binop already had no; /// poison-generating flags, then this transform can be done by instsimplify.; ///; /// Consider:; /// %cmp = icmp eq i32 %x, 2147483647; /// %add = add nsw i32 %x, 1; /// %sel = select i1 %cmp, i32 -2147483648, i32 %add; ///; /// We can't replace %sel with %add unless we strip away the flags.; /// TODO: Wrapping flags could be preserved in some cases with better analysis.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:167,Usability,simpl,simplifying,167,"/// If we have a select with an equality comparison, then we know the value in; /// one of the arms of the select. See if substituting this value into an arm; /// and simplifying the result yields the same value as the other arm.; ///; /// To make this transform safe, we must drop poison-generating flags; /// (nsw, etc) if we simplified to a binop because the select may be guarding; /// that poison from propagating. If the existing binop already had no; /// poison-generating flags, then this transform can be done by instsimplify.; ///; /// Consider:; /// %cmp = icmp eq i32 %x, 2147483647; /// %add = add nsw i32 %x, 1; /// %sel = select i1 %cmp, i32 -2147483648, i32 %add; ///; /// We can't replace %sel with %add unless we strip away the flags.; /// TODO: Wrapping flags could be preserved in some cases with better analysis.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:328,Usability,simpl,simplified,328,"/// If we have a select with an equality comparison, then we know the value in; /// one of the arms of the select. See if substituting this value into an arm; /// and simplifying the result yields the same value as the other arm.; ///; /// To make this transform safe, we must drop poison-generating flags; /// (nsw, etc) if we simplified to a binop because the select may be guarding; /// that poison from propagating. If the existing binop already had no; /// poison-generating flags, then this transform can be done by instsimplify.; ///; /// Consider:; /// %cmp = icmp eq i32 %x, 2147483647; /// %add = add nsw i32 %x, 1; /// %sel = select i1 %cmp, i32 -2147483648, i32 %add; ///; /// We can't replace %sel with %add unless we strip away the flags.; /// TODO: Wrapping flags could be preserved in some cases with better analysis.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:211,Safety,avoid,avoid,211,"// In X == Y ? f(X) : Z, try to evaluate f(Y) and replace the operand.; // Make sure Y cannot be undef though, as we might pick different values for; // undef in the icmp and in f(Y). Additionally, take care to avoid replacing; // X == Y ? X : Z with X == Y ? Y : Z, as that would lead to an infinite; // replacement cycle.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:87,Safety,avoid,avoid,87,// Require either the replacement or the simplification result to be a; // constant to avoid infinite loops.; // FIXME: Make this check more precise.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:41,Usability,simpl,simplification,41,// Require either the replacement or the simplification result to be a; // constant to avoid infinite loops.; // FIXME: Make this check more precise.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:159,Safety,safe,safe,159,"// Even if TrueVal does not simplify, we can directly replace a use of; // CmpLHS with CmpRHS, as long as the instruction is not used anywhere; // else and is safe to speculatively execute (we may end up executing it; // with different operands, which should not cause side-effects or trigger; // undefined behavior). Only do this if CmpRHS is a constant, as; // profitability is not clear for other cases.; // FIXME: Support vectors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:28,Usability,simpl,simplify,28,"// Even if TrueVal does not simplify, we can directly replace a use of; // CmpLHS with CmpRHS, as long as the instruction is not used anywhere; // else and is safe to speculatively execute (we may end up executing it; // with different operands, which should not cause side-effects or trigger; // undefined behavior). Only do this if CmpRHS is a constant, as; // profitability is not clear for other cases.; // FIXME: Support vectors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:384,Usability,clear,clear,384,"// Even if TrueVal does not simplify, we can directly replace a use of; // CmpLHS with CmpRHS, as long as the instruction is not used anywhere; // else and is safe to speculatively execute (we may end up executing it; // with different operands, which should not cause side-effects or trigger; // undefined behavior). Only do this if CmpRHS is a constant, as; // profitability is not clear for other cases.; // FIXME: Support vectors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:24,Performance,perform,performed,24,"// InstSimplify already performed this fold if it was possible subject to; // current poison-generating flags. Check whether dropping poison-generating; // flags enables the transform.; // Try each equivalence substitution possibility.; // We have an 'EQ' comparison, so the select's false value will propagate.; // Example:; // (X == 42) ? 43 : (X + 1) --> (X == 42) ? (X + 1) : (X + 1) --> X + 1",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:89,Usability,simpl,simplified,89,"// Although icmp ult %x, 0 is an unusual thing to try and should generally; // have been simplified, it does not verify with undef inputs so ensure we; // are not in a strange state.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:159,Modifiability,extend,extend,159,"// If we are matching from a truncated input, we need to sext the; // ReplacementLow and ReplacementHigh values. Only do the transform if they; // are free to extend due to being constants.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:73,Safety,abort,abort,73,"// If the [input] type of comparison and select type are different, lets abort; // for now. We could try to compare constants with trunc/[zs]ext though.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:143,Safety,avoid,avoid,143,// ULT with 'add' of a constant is canonical. See foldICmpAddConstant().; // FIXME: Are there more magic icmp predicate+constant pairs we must avoid?; // Or should we just abandon this transform entirely?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:43,Safety,detect,detect,43,"// NOTE: if we wanted to, this is where to detect integer MIN/MAX",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:132,Safety,avoid,avoid,132,"// Canonicalize a signbit condition to use zero constant by swapping:; // (CmpLHS > -1) ? TV : FV --> (CmpLHS < 0) ? FV : TV; // To avoid conflicts (infinite loops) with other canonicalizations, this is; // not applied with any constant select arm.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:64,Modifiability,refactor,refactoring,64,// FIXME: This code is nearly duplicated in InstSimplify. Using/refactoring; // decomposeBitTestICmp() might help.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:13,Modifiability,extend,extending,13,"// If we are extending from a boolean type or if we can create a select that; // has the same size operands as its condition, try to narrow the select.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:115,Availability,mask,mask,115,"// Undef in a select condition (choose one of the operands) does not mean; // the same thing as undef in a shuffle mask (any value is acceptable), so; // give up.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:106,Energy Efficiency,reduce,reduces,106,"// select (extelt V, Index), T, F --> select (splat V, Index), T, F; // Splatting the extracted condition reduces code (we could directly create a; // splat shuffle of the source vector to eliminate the intermediate step).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:702,Deployability,update,update,702,"/// Try to eliminate select instructions that test the returned flag of cmpxchg; /// instructions.; ///; /// If a select instruction tests the returned flag of a cmpxchg instruction and; /// selects between the returned value of the cmpxchg instruction its compare; /// operand, the result of the select will always be equal to its false value.; /// For example:; ///; /// %0 = cmpxchg i64* %ptr, i64 %compare, i64 %new_value seq_cst seq_cst; /// %1 = extractvalue { i64, i1 } %0, 1; /// %2 = extractvalue { i64, i1 } %0, 0; /// %3 = select i1 %1, i64 %compare, i64 %2; /// ret i64 %3; ///; /// The returned value of the cmpxchg instruction (%2) is the original value; /// located at %ptr prior to any update. If the cmpxchg operation succeeds, %2; /// must have been equal to %compare. Thus, the result of the select is always; /// equal to %2, and the code can be simplified to:; ///; /// %0 = cmpxchg i64* %ptr, i64 %compare, i64 %new_value seq_cst seq_cst; /// %1 = extractvalue { i64, i1 } %0, 0; /// ret i64 %1; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:46,Testability,test,test,46,"/// Try to eliminate select instructions that test the returned flag of cmpxchg; /// instructions.; ///; /// If a select instruction tests the returned flag of a cmpxchg instruction and; /// selects between the returned value of the cmpxchg instruction its compare; /// operand, the result of the select will always be equal to its false value.; /// For example:; ///; /// %0 = cmpxchg i64* %ptr, i64 %compare, i64 %new_value seq_cst seq_cst; /// %1 = extractvalue { i64, i1 } %0, 1; /// %2 = extractvalue { i64, i1 } %0, 0; /// %3 = select i1 %1, i64 %compare, i64 %2; /// ret i64 %3; ///; /// The returned value of the cmpxchg instruction (%2) is the original value; /// located at %ptr prior to any update. If the cmpxchg operation succeeds, %2; /// must have been equal to %compare. Thus, the result of the select is always; /// equal to %2, and the code can be simplified to:; ///; /// %0 = cmpxchg i64* %ptr, i64 %compare, i64 %new_value seq_cst seq_cst; /// %1 = extractvalue { i64, i1 } %0, 0; /// ret i64 %1; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:133,Testability,test,tests,133,"/// Try to eliminate select instructions that test the returned flag of cmpxchg; /// instructions.; ///; /// If a select instruction tests the returned flag of a cmpxchg instruction and; /// selects between the returned value of the cmpxchg instruction its compare; /// operand, the result of the select will always be equal to its false value.; /// For example:; ///; /// %0 = cmpxchg i64* %ptr, i64 %compare, i64 %new_value seq_cst seq_cst; /// %1 = extractvalue { i64, i1 } %0, 1; /// %2 = extractvalue { i64, i1 } %0, 0; /// %3 = select i1 %1, i64 %compare, i64 %2; /// ret i64 %3; ///; /// The returned value of the cmpxchg instruction (%2) is the original value; /// located at %ptr prior to any update. If the cmpxchg operation succeeds, %2; /// must have been equal to %compare. Thus, the result of the select is always; /// equal to %2, and the code can be simplified to:; ///; /// %0 = cmpxchg i64* %ptr, i64 %compare, i64 %new_value seq_cst seq_cst; /// %1 = extractvalue { i64, i1 } %0, 0; /// ret i64 %1; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:866,Usability,simpl,simplified,866,"/// Try to eliminate select instructions that test the returned flag of cmpxchg; /// instructions.; ///; /// If a select instruction tests the returned flag of a cmpxchg instruction and; /// selects between the returned value of the cmpxchg instruction its compare; /// operand, the result of the select will always be equal to its false value.; /// For example:; ///; /// %0 = cmpxchg i64* %ptr, i64 %compare, i64 %new_value seq_cst seq_cst; /// %1 = extractvalue { i64, i1 } %0, 1; /// %2 = extractvalue { i64, i1 } %0, 0; /// %3 = select i1 %1, i64 %compare, i64 %2; /// ret i64 %3; ///; /// The returned value of the cmpxchg instruction (%2) is the original value; /// located at %ptr prior to any update. If the cmpxchg operation succeeds, %2; /// must have been equal to %compare. Thus, the result of the select is always; /// equal to %2, and the code can be simplified to:; ///; /// %0 = cmpxchg i64* %ptr, i64 %compare, i64 %new_value seq_cst seq_cst; /// %1 = extractvalue { i64, i1 } %0, 0; /// ret i64 %1; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:90,Usability,simpl,simplify,90,"// If the select has a single user, and this user is a select instruction that; // we can simplify, skip the cmpxchg simplification for now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:117,Usability,simpl,simplification,117,"// If the select has a single user, and this user is a select instruction that; // we can simplify, skip the cmpxchg simplification for now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:11,Energy Efficiency,reduce,reduce,11,"/// Try to reduce a funnel/rotate pattern that includes a compare and select; /// into a funnel shift intrinsic. Example:; /// rotl32(a, b) --> (b == 0 ? a : ((a >> (32 - b)) | (a << b))); /// --> call llvm.fshl.i32(a, a, b); /// fshl32(a, b, c) --> (c == 0 ? a : ((b >> (32 - c)) | (a << c))); /// --> call llvm.fshl.i32(a, b, c); /// fshr32(a, b, c) --> (c == 0 ? b : ((a >> (32 - c)) | (b << c))); /// --> call llvm.fshr.i32(a, b, c)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:18,Energy Efficiency,power,power-of-,18,// This must be a power-of-2 type for a bitmasking transform to be valid.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:32,Safety,avoid,avoids,32,// This is a funnel/rotate that avoids shift-by-bitwidth UB in a suboptimal way.; // Convert to funnel shift intrinsic.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:110,Modifiability,variab,variable,110,"// Match select ?, TC, FC where the constants are equal but negated.; // TODO: Generalize to handle a negated variable operand?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:200,Availability,mask,mask,200,"// A select of a ""select shuffle"" with a common operand can be rearranged; // to select followed by ""select shuffle"". Because of poison, this only works; // in the case of a shuffle with no undefined mask elements.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:9,Availability,avail,availability,9,// Check availability.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:13,Energy Efficiency,reduce,reduce,13,"/// Tries to reduce a pattern that arises when calculating the remainder of the; /// Euclidean division. When the divisor is a power of two and is guaranteed not; /// to be negative, a signed remainder can be folded with a bitwise and.; ///; /// (x % n) < 0 ? (x % n) + n : (x % n); /// -> x & (n - 1)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:127,Energy Efficiency,power,power,127,"/// Tries to reduce a pattern that arises when calculating the remainder of the; /// Euclidean division. When the divisor is a power of two and is guaranteed not; /// to be negative, a signed remainder can be folded with a bitwise and.; ///; /// (x % n) < 0 ? (x % n) + n : (x % n); /// -> x & (n - 1)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:419,Availability,mask,mask,419,"// Match the following IR pattern:; // %x.lowbits = and i8 %x, %lowbitmask; // %x.lowbits.are.zero = icmp eq i8 %x.lowbits, 0; // %x.biased = add i8 %x, %bias; // %x.biased.highbits = and i8 %x.biased, %highbitmask; // %x.roundedup = select i1 %x.lowbits.are.zero, i8 %x, i8 %x.biased.highbits; // Define:; // %alignment = add i8 %lowbitmask, 1; // Iff 1. an %alignment is a power-of-two (aka, %lowbitmask is a low bit mask); // and 2. %bias is equal to either %lowbitmask or %alignment,; // and 3. %highbitmask is equal to ~%lowbitmask (aka, to -%alignment); // then this pattern can be transformed into:; // %x.offset = add i8 %x, %lowbitmask; // %x.roundedup = and i8 %x.offset, %highbitmask",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:375,Energy Efficiency,power,power-of-two,375,"// Match the following IR pattern:; // %x.lowbits = and i8 %x, %lowbitmask; // %x.lowbits.are.zero = icmp eq i8 %x.lowbits, 0; // %x.biased = add i8 %x, %bias; // %x.biased.highbits = and i8 %x.biased, %highbitmask; // %x.roundedup = select i1 %x.lowbits.are.zero, i8 %x, i8 %x.biased.highbits; // Define:; // %alignment = add i8 %lowbitmask, 1; // Iff 1. an %alignment is a power-of-two (aka, %lowbitmask is a low bit mask); // and 2. %bias is equal to either %lowbitmask or %alignment,; // and 3. %highbitmask is equal to ~%lowbitmask (aka, to -%alignment); // then this pattern can be transformed into:; // %x.offset = add i8 %x, %lowbitmask; // %x.roundedup = and i8 %x.offset, %highbitmask",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:261,Modifiability,rewrite,rewrite,261,"// namespace; /// Look for patterns like; /// %outer.cond = select i1 %inner.cond, i1 %alt.cond, i1 false; /// %inner.sel = select i1 %inner.cond, i8 %inner.sel.t, i8 %inner.sel.f; /// %outer.sel = select i1 %outer.cond, i8 %outer.sel.t, i8 %inner.sel; /// and rewrite it as; /// %inner.sel = select i1 %cond.alternative, i8 %sel.outer.t, i8 %sel.inner.t; /// %sel.outer = select i1 %cond.inner, i8 %inner.sel, i8 %sel.inner.f",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:3,Integrability,Depend,Depending,3,"// Depending on the logical op, inner select might be in different hand.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:20,Testability,log,logical,20,"// Depending on the logical op, inner select might be in different hand.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:25,Safety,avoid,avoid,25,// Profitability check - avoid increasing instruction count.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:51,Testability,Log,LogicalAnd,51,"// An unsimplified select condition can match both LogicalAnd and LogicalOr; // (select true, true, false). Since below we assume that LogicalAnd implies; // InnerSel match the FVal and vice versa for LogicalOr, we can't match the; // alternative pattern here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:66,Testability,Log,LogicalOr,66,"// An unsimplified select condition can match both LogicalAnd and LogicalOr; // (select true, true, false). Since below we assume that LogicalAnd implies; // InnerSel match the FVal and vice versa for LogicalOr, we can't match the; // alternative pattern here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:135,Testability,Log,LogicalAnd,135,"// An unsimplified select condition can match both LogicalAnd and LogicalOr; // (select true, true, false). Since below we assume that LogicalAnd implies; // InnerSel match the FVal and vice versa for LogicalOr, we can't match the; // alternative pattern here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:201,Testability,Log,LogicalOr,201,"// An unsimplified select condition can match both LogicalAnd and LogicalOr; // (select true, true, false). Since below we assume that LogicalAnd implies; // InnerSel match the FVal and vice versa for LogicalOr, we can't match the; // alternative pattern here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:92,Testability,log,logical,92,"// Finally, match the condition that was driving the outermost `select`,; // it should be a logical operation between the condition that was driving; // the innermost `select` (after accounting for the possible inversions; // of the condition), and some other condition.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:3,Safety,Avoid,Avoid,3,// Avoid potential infinite loops by checking for non-constant condition.; // TODO: Can we assert instead by improving canonicalizeSelectToShuffle()?; // Scalar select must have simplified?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:91,Testability,assert,assert,91,// Avoid potential infinite loops by checking for non-constant condition.; // TODO: Can we assert instead by improving canonicalizeSelectToShuffle()?; // Scalar select must have simplified?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:178,Usability,simpl,simplified,178,// Avoid potential infinite loops by checking for non-constant condition.; // TODO: Can we assert instead by improving canonicalizeSelectToShuffle()?; // Scalar select must have simplified?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:44,Safety,safe,safe,44,// Folding select to and/or i1 isn't poison safe in general. impliesPoison; // checks whether folding it does not convert a well-defined value into; // poison.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:47,Safety,avoid,avoid,47,"// We match the ""full"" 0 or 1 constant here to avoid a potential infinite; // loop with vectors that may have undefined/poison elements.; // select a, false, b -> select !a, b, false",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:25,Safety,safe,safely,25,// Return true if we can safely remove the select instruction for std::bit_ceil; // pattern.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:200,Deployability,update,update,200,"// Match the operation that's used to compute CtlzOp from CommonAncestor. If; // CtlzOp == CommonAncestor, return true as no operation is needed. If a; // match is found, execute the operation on CR, update CR, and return true.; // Otherwise, return false.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:58,Deployability,update,updated,58,// Cond0 is either CtlzOp or CtlzOp's parent. CR has been updated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:67,Deployability,update,updated,67,// Cond0's parent is either CtlzOp or CtlzOp's parent. CR has been updated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:406,Availability,mask,masked,406,"// Transform the std::bit_ceil(X) pattern like:; //; // %dec = add i32 %x, -1; // %ctlz = tail call i32 @llvm.ctlz.i32(i32 %dec, i1 false); // %sub = sub i32 32, %ctlz; // %shl = shl i32 1, %sub; // %ugt = icmp ugt i32 %x, 1; // %sel = select i1 %ugt, i32 %shl, i32 1; //; // into:; //; // %dec = add i32 %x, -1; // %ctlz = tail call i32 @llvm.ctlz.i32(i32 %dec, i1 false); // %neg = sub i32 0, %ctlz; // %masked = and i32 %ctlz, 31; // %shl = shl i32 1, %sub; //; // Note that the select is optimized away while the shift count is masked with; // 31. We handle some variations of the input operand like std::bit_ceil(X +; // 1).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:532,Availability,mask,masked,532,"// Transform the std::bit_ceil(X) pattern like:; //; // %dec = add i32 %x, -1; // %ctlz = tail call i32 @llvm.ctlz.i32(i32 %dec, i1 false); // %sub = sub i32 32, %ctlz; // %shl = shl i32 1, %sub; // %ugt = icmp ugt i32 %x, 1; // %sel = select i1 %ugt, i32 %shl, i32 1; //; // into:; //; // %dec = add i32 %x, -1; // %ctlz = tail call i32 @llvm.ctlz.i32(i32 %dec, i1 false); // %neg = sub i32 0, %ctlz; // %masked = and i32 %ctlz, 31; // %shl = shl i32 1, %sub; //; // Note that the select is optimized away while the shift count is masked with; // 31. We handle some variations of the input operand like std::bit_ceil(X +; // 1).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:492,Performance,optimiz,optimized,492,"// Transform the std::bit_ceil(X) pattern like:; //; // %dec = add i32 %x, -1; // %ctlz = tail call i32 @llvm.ctlz.i32(i32 %dec, i1 false); // %sub = sub i32 32, %ctlz; // %shl = shl i32 1, %sub; // %ugt = icmp ugt i32 %x, 1; // %sel = select i1 %ugt, i32 %shl, i32 1; //; // into:; //; // %dec = add i32 %x, -1; // %ctlz = tail call i32 @llvm.ctlz.i32(i32 %dec, i1 false); // %neg = sub i32 0, %ctlz; // %masked = and i32 %ctlz, 31; // %shl = shl i32 1, %sub; //; // Note that the select is optimized away while the shift count is masked with; // 31. We handle some variations of the input operand like std::bit_ceil(X +; // 1).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:181,Availability,Mask,Masking,181,"// Build 1 << (-CTLZ & (BitWidth-1)). The negation likely corresponds to a; // single hardware instruction as opposed to BitWidth - CTLZ, where BitWidth; // is an integer constant. Masking with BitWidth-1 comes free on some; // hardware as part of the shift instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:256,Modifiability,extend,extend,256,"// Selecting between two integer or vector splat integer constants?; //; // Note that we don't handle a scalar select of vectors:; // select i1 %c, <2 x i8> <1, 1>, <2 x i8> <0, 0>; // because that may need 3 instructions to splat the condition value:; // extend, insertelement, shufflevector.; //; // Do not handle i1 TrueVal and FalseVal otherwise would result in; // zext/sext i1 to i1.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:229,Testability,log,logic,229,"// Fold out scale-if-equals-zero pattern.; //; // This pattern appears in code with denormal range checks after it's; // assumed denormals are treated as zero. This drops a canonicalization.; // TODO: Could relax the signed zero logic. We just need to know the sign; // of the result matches (fmul x, y has the same sign as x).; //; // TODO: Handle always-canonicalizing variant that selects some value or 1; // scaling factor in the fmul visitor.; // TODO: Handle ldexp too",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:10,Usability,simpl,simplify,10,"// Try to simplify a binop sandwiched between 2 selects with the same; // condition. This is not valid for div/rem because the select might be; // preventing a division-by-zero.; // TODO: A div/rem restriction is conservative; use something like; // isSafeToSpeculativelyExecute().; // select(C, binop(select(C, X, Y), W), Z) -> select(C, binop(X, W), Z)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:112,Energy Efficiency,reduce,reduce,112,"// If we can compute the condition, there's no need for a select.; // Like the above fold, we are attempting to reduce compile-time cost by; // putting this fold here with limitations rather than in InstSimplify.; // The motivation for this call into value tracking is to take advantage of; // the assumption cache, so make sure that is populated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:309,Performance,cache,cache,309,"// If we can compute the condition, there's no need for a select.; // Like the above fold, we are attempting to reduce compile-time cost by; // putting this fold here with limitations rather than in InstSimplify.; // The motivation for this call into value tracking is to take advantage of; // the assumption cache, so make sure that is populated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:25,Testability,test,test,25,// Simplify selects that test the returned flag of cmpxchg instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:3,Usability,Simpl,Simplify,3,// Simplify selects that test the returned flag of cmpxchg instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:10,Availability,mask,mask,10,"// select(mask, mload(,,mask,0), 0) -> mload(,,mask,0); // Load inst is intentionally not checked for hasOneUse()",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:24,Availability,mask,mask,24,"// select(mask, mload(,,mask,0), 0) -> mload(,,mask,0); // Load inst is intentionally not checked for hasOneUse()",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:47,Availability,mask,mask,47,"// select(mask, mload(,,mask,0), 0) -> mload(,,mask,0); // Load inst is intentionally not checked for hasOneUse()",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:59,Performance,Load,Load,59,"// select(mask, mload(,,mask,0), 0) -> mload(,,mask,0); // Load inst is intentionally not checked for hasOneUse()",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:173,Availability,mask,masks,173,// We can remove the select by ensuring the load zeros all lanes the; // select would have. We determine this by proving there is no overlap; // between the load and select masks.; // (i.e (load_mask & select_mask) == 0 == no overlap),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:44,Performance,load,load,44,// We can remove the select by ensuring the load zeros all lanes the; // select would have. We determine this by proving there is no overlap; // between the load and select masks.; // (i.e (load_mask & select_mask) == 0 == no overlap),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:157,Performance,load,load,157,// We can remove the select by ensuring the load zeros all lanes the; // select would have. We determine this by proving there is no overlap; // between the load and select masks.; // (i.e (load_mask & select_mask) == 0 == no overlap),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:9,Testability,log,logical,9,"// Match logical variants of the pattern,; // and transform them iff that gets rid of inversions.; // (~x) | y --> ~(x & (~y)); // (~x) & y --> ~(x | (~y))",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:34,Testability,log,logical,34,// We cannot swap the operands of logical and/or.; // TODO: Can we swap the operands by inserting a freeze?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp:81,Modifiability,rewrite,rewrite,81,"// As input, we have the following pattern:; // Sh0 (Sh1 X, Q), K; // We want to rewrite that as:; // Sh x, (Q+K) iff (Q+K) u< bitwidth(x); // While we know that originally (Q+K) would not overflow; // (because 2 * (N-1) u<= iN -1), we have looked past extensions of; // shift amounts. so it may now overflow in smaller bitwidth.; // To ensure that does not happen, we need to ensure that the total maximal; // shift amount is still representable in that smaller bit width.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp:68,Modifiability,rewrite,rewrite,68,"// Given pattern:; // (x shiftopcode Q) shiftopcode K; // we should rewrite it as; // x shiftopcode (Q+K) iff (Q+K) u< bitwidth(x) and; //; // This is valid for any shift, but they must be identical, and we must be; // careful in case we have (zext(Q)+zext(K)) and look past extensions,; // (Q+K) must not overflow or else (Q+K) u< bitwidth(x) is bogus.; //; // AnalyzeForSignBitExtraction indicates that we will only analyze whether this; // pattern has any 2 right-shifts that sum to 1 less than original bit width.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp:27,Safety,safe,safe,27,// Verify that it would be safe to try to add those two shift amounts.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp:11,Usability,simpl,simplify,11,// Did not simplify.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp:16,Performance,perform,perform,16,"// FIXME: could perform constant-folding.; // If there was a truncation, and we have a right-shift, we can only fold if; // we are left with the original sign bit. Likewise, if we were just checking; // that this is a sighbit extraction, this is the place to check it.; // FIXME: zero shift amount is also legal here, but we can't *easily* check; // more than one predicate so it's not really worth it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp:191,Availability,mask,mask,191,"// If we have some pattern that leaves only some low bits set, and then performs; // left-shift of those bits, if none of the bits that are left after the final; // shift are modified by the mask, we can omit the mask.; //; // There are many variants to this pattern:; // a) (x & ((1 << MaskShAmt) - 1)) << ShiftShAmt; // b) (x & (~(-1 << MaskShAmt))) << ShiftShAmt; // c) (x & (-1 l>> MaskShAmt)) << ShiftShAmt; // d) (x & ((-1 << MaskShAmt) l>> MaskShAmt)) << ShiftShAmt; // e) ((x << MaskShAmt) l>> MaskShAmt) << ShiftShAmt; // f) ((x << MaskShAmt) a>> MaskShAmt) << ShiftShAmt; // All these patterns can be simplified to just:; // x << ShiftShAmt; // iff:; // a,b) (MaskShAmt+ShiftShAmt) u>= bitwidth(x); // c,d,e,f) (ShiftShAmt-MaskShAmt) s>= 0 (i.e. ShiftShAmt u>= MaskShAmt)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp:213,Availability,mask,mask,213,"// If we have some pattern that leaves only some low bits set, and then performs; // left-shift of those bits, if none of the bits that are left after the final; // shift are modified by the mask, we can omit the mask.; //; // There are many variants to this pattern:; // a) (x & ((1 << MaskShAmt) - 1)) << ShiftShAmt; // b) (x & (~(-1 << MaskShAmt))) << ShiftShAmt; // c) (x & (-1 l>> MaskShAmt)) << ShiftShAmt; // d) (x & ((-1 << MaskShAmt) l>> MaskShAmt)) << ShiftShAmt; // e) ((x << MaskShAmt) l>> MaskShAmt) << ShiftShAmt; // f) ((x << MaskShAmt) a>> MaskShAmt) << ShiftShAmt; // All these patterns can be simplified to just:; // x << ShiftShAmt; // iff:; // a,b) (MaskShAmt+ShiftShAmt) u>= bitwidth(x); // c,d,e,f) (ShiftShAmt-MaskShAmt) s>= 0 (i.e. ShiftShAmt u>= MaskShAmt)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp:287,Availability,Mask,MaskShAmt,287,"// If we have some pattern that leaves only some low bits set, and then performs; // left-shift of those bits, if none of the bits that are left after the final; // shift are modified by the mask, we can omit the mask.; //; // There are many variants to this pattern:; // a) (x & ((1 << MaskShAmt) - 1)) << ShiftShAmt; // b) (x & (~(-1 << MaskShAmt))) << ShiftShAmt; // c) (x & (-1 l>> MaskShAmt)) << ShiftShAmt; // d) (x & ((-1 << MaskShAmt) l>> MaskShAmt)) << ShiftShAmt; // e) ((x << MaskShAmt) l>> MaskShAmt) << ShiftShAmt; // f) ((x << MaskShAmt) a>> MaskShAmt) << ShiftShAmt; // All these patterns can be simplified to just:; // x << ShiftShAmt; // iff:; // a,b) (MaskShAmt+ShiftShAmt) u>= bitwidth(x); // c,d,e,f) (ShiftShAmt-MaskShAmt) s>= 0 (i.e. ShiftShAmt u>= MaskShAmt)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp:339,Availability,Mask,MaskShAmt,339,"// If we have some pattern that leaves only some low bits set, and then performs; // left-shift of those bits, if none of the bits that are left after the final; // shift are modified by the mask, we can omit the mask.; //; // There are many variants to this pattern:; // a) (x & ((1 << MaskShAmt) - 1)) << ShiftShAmt; // b) (x & (~(-1 << MaskShAmt))) << ShiftShAmt; // c) (x & (-1 l>> MaskShAmt)) << ShiftShAmt; // d) (x & ((-1 << MaskShAmt) l>> MaskShAmt)) << ShiftShAmt; // e) ((x << MaskShAmt) l>> MaskShAmt) << ShiftShAmt; // f) ((x << MaskShAmt) a>> MaskShAmt) << ShiftShAmt; // All these patterns can be simplified to just:; // x << ShiftShAmt; // iff:; // a,b) (MaskShAmt+ShiftShAmt) u>= bitwidth(x); // c,d,e,f) (ShiftShAmt-MaskShAmt) s>= 0 (i.e. ShiftShAmt u>= MaskShAmt)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp:386,Availability,Mask,MaskShAmt,386,"// If we have some pattern that leaves only some low bits set, and then performs; // left-shift of those bits, if none of the bits that are left after the final; // shift are modified by the mask, we can omit the mask.; //; // There are many variants to this pattern:; // a) (x & ((1 << MaskShAmt) - 1)) << ShiftShAmt; // b) (x & (~(-1 << MaskShAmt))) << ShiftShAmt; // c) (x & (-1 l>> MaskShAmt)) << ShiftShAmt; // d) (x & ((-1 << MaskShAmt) l>> MaskShAmt)) << ShiftShAmt; // e) ((x << MaskShAmt) l>> MaskShAmt) << ShiftShAmt; // f) ((x << MaskShAmt) a>> MaskShAmt) << ShiftShAmt; // All these patterns can be simplified to just:; // x << ShiftShAmt; // iff:; // a,b) (MaskShAmt+ShiftShAmt) u>= bitwidth(x); // c,d,e,f) (ShiftShAmt-MaskShAmt) s>= 0 (i.e. ShiftShAmt u>= MaskShAmt)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp:432,Availability,Mask,MaskShAmt,432,"// If we have some pattern that leaves only some low bits set, and then performs; // left-shift of those bits, if none of the bits that are left after the final; // shift are modified by the mask, we can omit the mask.; //; // There are many variants to this pattern:; // a) (x & ((1 << MaskShAmt) - 1)) << ShiftShAmt; // b) (x & (~(-1 << MaskShAmt))) << ShiftShAmt; // c) (x & (-1 l>> MaskShAmt)) << ShiftShAmt; // d) (x & ((-1 << MaskShAmt) l>> MaskShAmt)) << ShiftShAmt; // e) ((x << MaskShAmt) l>> MaskShAmt) << ShiftShAmt; // f) ((x << MaskShAmt) a>> MaskShAmt) << ShiftShAmt; // All these patterns can be simplified to just:; // x << ShiftShAmt; // iff:; // a,b) (MaskShAmt+ShiftShAmt) u>= bitwidth(x); // c,d,e,f) (ShiftShAmt-MaskShAmt) s>= 0 (i.e. ShiftShAmt u>= MaskShAmt)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp:447,Availability,Mask,MaskShAmt,447,"// If we have some pattern that leaves only some low bits set, and then performs; // left-shift of those bits, if none of the bits that are left after the final; // shift are modified by the mask, we can omit the mask.; //; // There are many variants to this pattern:; // a) (x & ((1 << MaskShAmt) - 1)) << ShiftShAmt; // b) (x & (~(-1 << MaskShAmt))) << ShiftShAmt; // c) (x & (-1 l>> MaskShAmt)) << ShiftShAmt; // d) (x & ((-1 << MaskShAmt) l>> MaskShAmt)) << ShiftShAmt; // e) ((x << MaskShAmt) l>> MaskShAmt) << ShiftShAmt; // f) ((x << MaskShAmt) a>> MaskShAmt) << ShiftShAmt; // All these patterns can be simplified to just:; // x << ShiftShAmt; // iff:; // a,b) (MaskShAmt+ShiftShAmt) u>= bitwidth(x); // c,d,e,f) (ShiftShAmt-MaskShAmt) s>= 0 (i.e. ShiftShAmt u>= MaskShAmt)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp:487,Availability,Mask,MaskShAmt,487,"// If we have some pattern that leaves only some low bits set, and then performs; // left-shift of those bits, if none of the bits that are left after the final; // shift are modified by the mask, we can omit the mask.; //; // There are many variants to this pattern:; // a) (x & ((1 << MaskShAmt) - 1)) << ShiftShAmt; // b) (x & (~(-1 << MaskShAmt))) << ShiftShAmt; // c) (x & (-1 l>> MaskShAmt)) << ShiftShAmt; // d) (x & ((-1 << MaskShAmt) l>> MaskShAmt)) << ShiftShAmt; // e) ((x << MaskShAmt) l>> MaskShAmt) << ShiftShAmt; // f) ((x << MaskShAmt) a>> MaskShAmt) << ShiftShAmt; // All these patterns can be simplified to just:; // x << ShiftShAmt; // iff:; // a,b) (MaskShAmt+ShiftShAmt) u>= bitwidth(x); // c,d,e,f) (ShiftShAmt-MaskShAmt) s>= 0 (i.e. ShiftShAmt u>= MaskShAmt)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp:502,Availability,Mask,MaskShAmt,502,"// If we have some pattern that leaves only some low bits set, and then performs; // left-shift of those bits, if none of the bits that are left after the final; // shift are modified by the mask, we can omit the mask.; //; // There are many variants to this pattern:; // a) (x & ((1 << MaskShAmt) - 1)) << ShiftShAmt; // b) (x & (~(-1 << MaskShAmt))) << ShiftShAmt; // c) (x & (-1 l>> MaskShAmt)) << ShiftShAmt; // d) (x & ((-1 << MaskShAmt) l>> MaskShAmt)) << ShiftShAmt; // e) ((x << MaskShAmt) l>> MaskShAmt) << ShiftShAmt; // f) ((x << MaskShAmt) a>> MaskShAmt) << ShiftShAmt; // All these patterns can be simplified to just:; // x << ShiftShAmt; // iff:; // a,b) (MaskShAmt+ShiftShAmt) u>= bitwidth(x); // c,d,e,f) (ShiftShAmt-MaskShAmt) s>= 0 (i.e. ShiftShAmt u>= MaskShAmt)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp:541,Availability,Mask,MaskShAmt,541,"// If we have some pattern that leaves only some low bits set, and then performs; // left-shift of those bits, if none of the bits that are left after the final; // shift are modified by the mask, we can omit the mask.; //; // There are many variants to this pattern:; // a) (x & ((1 << MaskShAmt) - 1)) << ShiftShAmt; // b) (x & (~(-1 << MaskShAmt))) << ShiftShAmt; // c) (x & (-1 l>> MaskShAmt)) << ShiftShAmt; // d) (x & ((-1 << MaskShAmt) l>> MaskShAmt)) << ShiftShAmt; // e) ((x << MaskShAmt) l>> MaskShAmt) << ShiftShAmt; // f) ((x << MaskShAmt) a>> MaskShAmt) << ShiftShAmt; // All these patterns can be simplified to just:; // x << ShiftShAmt; // iff:; // a,b) (MaskShAmt+ShiftShAmt) u>= bitwidth(x); // c,d,e,f) (ShiftShAmt-MaskShAmt) s>= 0 (i.e. ShiftShAmt u>= MaskShAmt)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp:556,Availability,Mask,MaskShAmt,556,"// If we have some pattern that leaves only some low bits set, and then performs; // left-shift of those bits, if none of the bits that are left after the final; // shift are modified by the mask, we can omit the mask.; //; // There are many variants to this pattern:; // a) (x & ((1 << MaskShAmt) - 1)) << ShiftShAmt; // b) (x & (~(-1 << MaskShAmt))) << ShiftShAmt; // c) (x & (-1 l>> MaskShAmt)) << ShiftShAmt; // d) (x & ((-1 << MaskShAmt) l>> MaskShAmt)) << ShiftShAmt; // e) ((x << MaskShAmt) l>> MaskShAmt) << ShiftShAmt; // f) ((x << MaskShAmt) a>> MaskShAmt) << ShiftShAmt; // All these patterns can be simplified to just:; // x << ShiftShAmt; // iff:; // a,b) (MaskShAmt+ShiftShAmt) u>= bitwidth(x); // c,d,e,f) (ShiftShAmt-MaskShAmt) s>= 0 (i.e. ShiftShAmt u>= MaskShAmt)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp:670,Availability,Mask,MaskShAmt,670,"// If we have some pattern that leaves only some low bits set, and then performs; // left-shift of those bits, if none of the bits that are left after the final; // shift are modified by the mask, we can omit the mask.; //; // There are many variants to this pattern:; // a) (x & ((1 << MaskShAmt) - 1)) << ShiftShAmt; // b) (x & (~(-1 << MaskShAmt))) << ShiftShAmt; // c) (x & (-1 l>> MaskShAmt)) << ShiftShAmt; // d) (x & ((-1 << MaskShAmt) l>> MaskShAmt)) << ShiftShAmt; // e) ((x << MaskShAmt) l>> MaskShAmt) << ShiftShAmt; // f) ((x << MaskShAmt) a>> MaskShAmt) << ShiftShAmt; // All these patterns can be simplified to just:; // x << ShiftShAmt; // iff:; // a,b) (MaskShAmt+ShiftShAmt) u>= bitwidth(x); // c,d,e,f) (ShiftShAmt-MaskShAmt) s>= 0 (i.e. ShiftShAmt u>= MaskShAmt)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp:733,Availability,Mask,MaskShAmt,733,"// If we have some pattern that leaves only some low bits set, and then performs; // left-shift of those bits, if none of the bits that are left after the final; // shift are modified by the mask, we can omit the mask.; //; // There are many variants to this pattern:; // a) (x & ((1 << MaskShAmt) - 1)) << ShiftShAmt; // b) (x & (~(-1 << MaskShAmt))) << ShiftShAmt; // c) (x & (-1 l>> MaskShAmt)) << ShiftShAmt; // d) (x & ((-1 << MaskShAmt) l>> MaskShAmt)) << ShiftShAmt; // e) ((x << MaskShAmt) l>> MaskShAmt) << ShiftShAmt; // f) ((x << MaskShAmt) a>> MaskShAmt) << ShiftShAmt; // All these patterns can be simplified to just:; // x << ShiftShAmt; // iff:; // a,b) (MaskShAmt+ShiftShAmt) u>= bitwidth(x); // c,d,e,f) (ShiftShAmt-MaskShAmt) s>= 0 (i.e. ShiftShAmt u>= MaskShAmt)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp:771,Availability,Mask,MaskShAmt,771,"// If we have some pattern that leaves only some low bits set, and then performs; // left-shift of those bits, if none of the bits that are left after the final; // shift are modified by the mask, we can omit the mask.; //; // There are many variants to this pattern:; // a) (x & ((1 << MaskShAmt) - 1)) << ShiftShAmt; // b) (x & (~(-1 << MaskShAmt))) << ShiftShAmt; // c) (x & (-1 l>> MaskShAmt)) << ShiftShAmt; // d) (x & ((-1 << MaskShAmt) l>> MaskShAmt)) << ShiftShAmt; // e) ((x << MaskShAmt) l>> MaskShAmt) << ShiftShAmt; // f) ((x << MaskShAmt) a>> MaskShAmt) << ShiftShAmt; // All these patterns can be simplified to just:; // x << ShiftShAmt; // iff:; // a,b) (MaskShAmt+ShiftShAmt) u>= bitwidth(x); // c,d,e,f) (ShiftShAmt-MaskShAmt) s>= 0 (i.e. ShiftShAmt u>= MaskShAmt)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp:72,Performance,perform,performs,72,"// If we have some pattern that leaves only some low bits set, and then performs; // left-shift of those bits, if none of the bits that are left after the final; // shift are modified by the mask, we can omit the mask.; //; // There are many variants to this pattern:; // a) (x & ((1 << MaskShAmt) - 1)) << ShiftShAmt; // b) (x & (~(-1 << MaskShAmt))) << ShiftShAmt; // c) (x & (-1 l>> MaskShAmt)) << ShiftShAmt; // d) (x & ((-1 << MaskShAmt) l>> MaskShAmt)) << ShiftShAmt; // e) ((x << MaskShAmt) l>> MaskShAmt) << ShiftShAmt; // f) ((x << MaskShAmt) a>> MaskShAmt) << ShiftShAmt; // All these patterns can be simplified to just:; // x << ShiftShAmt; // iff:; // a,b) (MaskShAmt+ShiftShAmt) u>= bitwidth(x); // c,d,e,f) (ShiftShAmt-MaskShAmt) s>= 0 (i.e. ShiftShAmt u>= MaskShAmt)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp:611,Usability,simpl,simplified,611,"// If we have some pattern that leaves only some low bits set, and then performs; // left-shift of those bits, if none of the bits that are left after the final; // shift are modified by the mask, we can omit the mask.; //; // There are many variants to this pattern:; // a) (x & ((1 << MaskShAmt) - 1)) << ShiftShAmt; // b) (x & (~(-1 << MaskShAmt))) << ShiftShAmt; // c) (x & (-1 l>> MaskShAmt)) << ShiftShAmt; // d) (x & ((-1 << MaskShAmt) l>> MaskShAmt)) << ShiftShAmt; // e) ((x << MaskShAmt) l>> MaskShAmt) << ShiftShAmt; // f) ((x << MaskShAmt) a>> MaskShAmt) << ShiftShAmt; // All these patterns can be simplified to just:; // x << ShiftShAmt; // iff:; // a,b) (MaskShAmt+ShiftShAmt) u>= bitwidth(x); // c,d,e,f) (ShiftShAmt-MaskShAmt) s>= 0 (i.e. ShiftShAmt u>= MaskShAmt)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp:68,Availability,mask,mask,68,"// *If* there is a truncation between an outer shift and a possibly-mask,; // then said truncation *must* be one-use, else we can't perform the fold.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp:132,Performance,perform,perform,132,"// *If* there is a truncation between an outer shift and a possibly-mask,; // then said truncation *must* be one-use, else we can't perform the fold.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp:7,Availability,mask,mask,7,// The mask must be computed in a type twice as wide to ensure; // that no bits are lost if the sum-of-shifts is wider than the base type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp:10,Availability,Mask,MaskShAmt,10,// ((1 << MaskShAmt) - 1),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp:12,Availability,mask,maskNbits,12,// (~(-1 << maskNbits)),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp:11,Availability,Mask,MaskShAmt,11,// (-1 l>> MaskShAmt),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp:11,Availability,Mask,MaskShAmt,11,// ((-1 << MaskShAmt) l>> MaskShAmt),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp:26,Availability,Mask,MaskShAmt,26,// ((-1 << MaskShAmt) l>> MaskShAmt),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp:27,Safety,safe,safe,27,// Verify that it would be safe to try to add those two shift amounts.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp:20,Availability,Mask,MaskShAmt,20,// Can we simplify (MaskShAmt+ShiftShAmt) ?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp:10,Usability,simpl,simplify,10,// Can we simplify (MaskShAmt+ShiftShAmt) ?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp:153,Modifiability,extend,extend,153,// Did not simplify.; // In this pattern SumOfShAmts correlates with the number of low bits; // that shall remain in the root value (OuterShift).; // An extend of an undef value becomes zero because the high bits are never; // completely unknown. Replace the `undef` shift amounts with final; // shift bitwidth to ensure that the value remains undef when creating the; // subsequent shift op.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp:11,Usability,simpl,simplify,11,// Did not simplify.; // In this pattern SumOfShAmts correlates with the number of low bits; // that shall remain in the root value (OuterShift).; // An extend of an undef value becomes zero because the high bits are never; // completely unknown. Replace the `undef` shift amounts with final; // shift bitwidth to ensure that the value remains undef when creating the; // subsequent shift op.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp:19,Availability,mask,mask,19,// And compute the mask as usual: ~(-1 << (SumOfShAmts)),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp:27,Safety,safe,safe,27,// Verify that it would be safe to try to add those two shift amounts.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp:31,Availability,Mask,MaskShAmt,31,// Can we simplify (ShiftShAmt-MaskShAmt) ?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp:10,Usability,simpl,simplify,10,// Can we simplify (ShiftShAmt-MaskShAmt) ?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp:155,Modifiability,extend,extend,155,// Did not simplify.; // In this pattern ShAmtsDiff correlates with the number of high bits that; // shall be unset in the root value (OuterShift).; // An extend of an undef value becomes zero because the high bits are never; // completely unknown. Replace the `undef` shift amounts with negated; // bitwidth of innermost shift to ensure that the value remains undef when; // creating the subsequent shift op.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp:11,Usability,simpl,simplify,11,// Did not simplify.; // In this pattern ShAmtsDiff correlates with the number of high bits that; // shall be unset in the root value (OuterShift).; // An extend of an undef value becomes zero because the high bits are never; // completely unknown. Replace the `undef` shift amounts with negated; // bitwidth of innermost shift to ensure that the value remains undef when; // creating the subsequent shift op.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp:19,Availability,mask,mask,19,// And compute the mask as usual: (-1 l>> (NumHighBitsToClear)),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp:13,Availability,mask,mask,13,// Does this mask has any unset bits? If not then we can just not apply it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp:25,Availability,mask,mask,25,"// If we need to apply a mask, there are several more restrictions we have.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp:11,Availability,mask,masking,11,// The old masking instruction must go away.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp:17,Availability,mask,masking,17,"// The original ""masking"" instruction must not have been`ashr`.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp:297,Energy Efficiency,reduce,reduces,297,"/// If we have a shift-by-constant of a bin op (bitwise logic op or add/sub w/; /// shl) that itself has a shift-by-constant operand with identical opcode, we; /// may be able to convert that into 2 independent shifts followed by the logic; /// op. This eliminates a use of an intermediate value (reduces dependency; /// chain).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp:305,Integrability,depend,dependency,305,"/// If we have a shift-by-constant of a bin op (bitwise logic op or add/sub w/; /// shl) that itself has a shift-by-constant operand with identical opcode, we; /// may be able to convert that into 2 independent shifts followed by the logic; /// op. This eliminates a use of an intermediate value (reduces dependency; /// chain).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp:56,Testability,log,logic,56,"/// If we have a shift-by-constant of a bin op (bitwise logic op or add/sub w/; /// shl) that itself has a shift-by-constant operand with identical opcode, we; /// may be able to convert that into 2 independent shifts followed by the logic; /// op. This eliminates a use of an intermediate value (reduces dependency; /// chain).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp:234,Testability,log,logic,234,"/// If we have a shift-by-constant of a bin op (bitwise logic op or add/sub w/; /// shl) that itself has a shift-by-constant operand with identical opcode, we; /// may be able to convert that into 2 independent shifts followed by the logic; /// op. This eliminates a use of an intermediate value (reduces dependency; /// chain).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp:3,Testability,Log,Logic,3,"// Logic ops and Add are commutative, so check each operand for a match. Sub; // is not so we cannot reoder if we match operand(1) and need to keep the; // operands in their original positions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp:37,Modifiability,variab,variable,37,// Pre-shift a constant shifted by a variable amount with constant offset:; // C shift (A add nuw C1) --> (C shift C1) shift A,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp:44,Modifiability,variab,variable,44,// Try to pre-shift a constant shifted by a variable amount added with a; // negative number:; // C << (X - AddC) --> (C >> AddC) << X; // and; // C >> (X - AddC) --> (C << AddC) >> X,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp:60,Energy Efficiency,power,power,60,// X shift (A srem C) -> X shift (A and (C - 1)) iff C is a power of 2.; // Because shifts by negative values (which could occur if A were negative); // are undefined.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp:37,Usability,Simpl,SimplifyDemandedBits,37,// FIXME: Should this get moved into SimplifyDemandedBits by saying we don't; // demand the sign bit (and many others) here??,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp:39,Testability,log,logical,39,"/// Return true if we can simplify two logical (either left or right) shifts; /// that have constant shift amounts: OuterShift (InnerShift X, C1), C2.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp:26,Usability,simpl,simplify,26,"/// Return true if we can simplify two logical (either left or right) shifts; /// that have constant shift amounts: OuterShift (InnerShift X, C1), C2.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp:7,Testability,log,logical,7,"// Two logical shifts in the same direction:; // shl (shl X, C1), C2 --> shl X, C1 + C2; // lshr (lshr X, C1), C2 --> lshr X, C1 + C2",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp:364,Availability,mask,mask,364,"// If the 2nd shift is bigger than the 1st, we can fold:; // lshr (shl X, C1), C2 --> and (shl X, C1 - C2), C3; // shl (lshr X, C1), C2 --> and (lshr X, C1 - C2), C3; // but it isn't profitable unless we know the and'd out bits are already zero.; // Also, check that the inner shift is valid (less than the type width) or; // we'll crash trying to produce the bit mask for the 'and'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp:59,Testability,log,logically,59,"/// See if we can compute the specified value, but shifted logically to the left; /// or right by some number of bits. This should return true if the expression; /// can be computed for the same cost as the current expression tree. This is; /// used to eliminate extraneous shifting from things like:; /// %C = shl i128 %A, 64; /// %D = shl i128 %B, 96; /// %E = or i128 %C, %D; /// %F = lshr i128 %E, 64; /// where the client will ask if E can be computed shifted right by 64-bits. If; /// this succeeds, getShiftedValue() will be called to produce the value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp:31,Usability,clear,clear,31,// Change the shift amount and clear the appropriate IR flags.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp:7,Testability,log,logical,7,"// Two logical shifts in the same direction:; // shl (shl X, C1), C2 --> shl X, C1 + C2; // lshr (lshr X, C1), C2 --> lshr X, C1 + C2",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp:112,Availability,mask,masked-off,112,"// In general, we would need an 'and' for this transform, but; // canEvaluateShiftedShift() guarantees that the masked-off bits are not used.; // lshr (shl X, C1), C2 --> shl X, C1 - C2; // shl (lshr X, C1), C2 --> lshr X, C1 - C2",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp:10,Performance,perform,perform,10,// Do not perform transform!,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp:28,Testability,log,logical,28,"// Do not change a 'not' of logical shift because that would create a normal; // 'xor'. The 'not' is likely better for analysis, SCEV, and codegen.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp:12,Performance,perform,perform,12,"// Tries to perform; // (lshr (add (zext X), (zext Y)), K); // -> (icmp ult (add X, Y), X); // where; // - The add's operands are zexts from a K-bits integer to a bigger type.; // - The add is only used by the shr, or by iK (or narrower) truncates.; // - The lshr type has more than 2 bits (other types are boolean math).; // - K > 1; // note that; // - The resulting add cannot have nuw/nsw, else on overflow we get a; // poison value and the transform isn't legal anymore.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp:99,Safety,safe,safely,99,"// Since shift produces a poison value if RHS is equal to or larger than the; // bit width, we can safely assume that RHS is less than the bit width.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp:24,Usability,simpl,simplified,24,// Oversized shifts are simplified to zero in InstSimplify.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp:118,Testability,log,logic,118,"// If we have an opposite shift by the same amount, we may be able to; // reorder binops and shifts to eliminate math/logic.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp:24,Usability,simpl,simplified,24,// Oversized shifts are simplified to zero in InstSimplify.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp:113,Availability,Mask,MaskC,113,"// If the combined shift fits in the source width:; // (trunc (X >>u C1)) >>u C --> and (trunc (X >>u (C1 + C)), MaskC; //; // If the first shift covers the number of bits truncated, then the; // mask instruction is eliminated (and so the use check is relaxed).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp:196,Availability,mask,mask,196,"// If the combined shift fits in the source width:; // (trunc (X >>u C1)) >>u C --> and (trunc (X >>u (C1 + C)), MaskC; //; // If the first shift covers the number of bits truncated, then the; // mask instruction is eliminated (and so the use check is relaxed).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp:89,Availability,mask,mask,89,"// If the first shift does not cover the number of bits truncated, then; // we require a mask to get rid of high bits in the result.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp:115,Availability,mask,mask,115,"// Look for a ""splat"" mul pattern - it replicates bits across each half of; // a value, so a right shift is just a mask of the low bits:; // lshr i[2N] (mul nuw X, (2^N)+1), N --> and iN X, (2^N)-1; // TODO: Generalize to allow more than just half-width shifts?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp:3,Energy Efficiency,Reduce,Reduce,3,// Reduce add-carry of bools to logic:; // ((zext BoolX) + (zext BoolY)) >> 1 --> zext (BoolX && BoolY),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp:32,Testability,log,logic,32,// Reduce add-carry of bools to logic:; // ((zext BoolX) + (zext BoolY)) >> 1 --> zext (BoolX && BoolY),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp:23,Modifiability,variab,variable-length,23,// It should look like variable-length sign-extension on the outside:; // (Val << (bitwidth(Val)-Nbits)) a>> (bitwidth(Val)-Nbits),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp:131,Availability,redundant,redundant,131,"// Since the NBits is identical for all shifts, if the outermost and; // innermost shifts are identical, then outermost shifts are redundant.; // If we had truncation, do keep it though.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp:131,Safety,redund,redundant,131,"// Since the NBits is identical for all shifts, if the outermost and; // innermost shifts are identical, then outermost shifts are redundant.; // If we had truncation, do keep it though.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp:45,Performance,perform,perform,45,"// Finally, bypass two innermost shifts, and perform the outermost shift on; // the operands of the innermost shift.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp:143,Availability,mask,masked,143,"// Prefer `-(x & 1)` over `(x << (bitwidth(x)-1)) a>> (bitwidth(x)-1)`; // as the pattern to splat the lowest bit.; // FIXME: iff X is already masked, we don't need the one-use check.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp:402,Testability,log,logic,402,"//===- InstCombineSimplifyDemanded.cpp ------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains logic for simplifying instructions based on information; // about how they are used.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp:412,Usability,simpl,simplifying,412,"//===- InstCombineSimplifyDemanded.cpp ------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains logic for simplifying instructions based on information; // about how they are used.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp:40,Usability,Simpl,SimplifyDemandedBits,40,/// Inst is an integer instruction that SimplifyDemandedBits knows about. See if; /// the instruction has any properties that allow us to simplify its operands.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp:138,Usability,simpl,simplify,138,/// Inst is an integer instruction that SimplifyDemandedBits knows about. See if; /// the instruction has any properties that allow us to simplify its operands.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp:40,Usability,Simpl,SimplifyDemandedBits,40,/// Inst is an integer instruction that SimplifyDemandedBits knows about. See if; /// the instruction has any properties that allow us to simplify its operands.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp:138,Usability,simpl,simplify,138,/// Inst is an integer instruction that SimplifyDemandedBits knows about. See if; /// the instruction has any properties that allow us to simplify its operands.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp:17,Usability,Simpl,SimplifyDemandedBits,17,"/// This form of SimplifyDemandedBits simplifies the specified instruction; /// operand if possible, updating it in place. It returns true if it made any; /// change and false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp:38,Usability,simpl,simplifies,38,"/// This form of SimplifyDemandedBits simplifies the specified instruction; /// operand if possible, updating it in place. It returns true if it made any; /// change and false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp:213,Availability,down,downstream,213,"/// This function attempts to replace V with a simpler value based on the; /// demanded bits. When this function is called, it is known that only the bits; /// set in DemandedMask of the result of V are ever used downstream.; /// Consequently, depending on the mask and V, it may be possible to replace V; /// with a constant or one of its operands. In such cases, this function does; /// the replacement and returns true. In all other cases, it returns false after; /// analyzing the expression and setting KnownOne and known to be one in the; /// expression. Known.Zero contains all the bits that are known to be zero in; /// the expression. These are provided to potentially allow the caller (which; /// might recursively be SimplifyDemandedBits itself) to simplify the; /// expression.; /// Known.One and Known.Zero always follow the invariant that:; /// Known.One & Known.Zero == 0.; /// That is, a bit can't be both 1 and 0. The bits in Known.One and Known.Zero; /// are accurate even for bits not in DemandedMask. Note; /// also that the bitwidth of V, DemandedMask, Known.Zero and Known.One must all; /// be the same.; ///; /// This returns null if it did not change anything and it permits no; /// simplification. This returns V itself if it did some simplification of V's; /// operands based on the information about what bits are demanded. This returns; /// some other non-null value if it found out that V is equal to another value; /// in the context where the specified bits are demanded, but not for all users.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp:261,Availability,mask,mask,261,"/// This function attempts to replace V with a simpler value based on the; /// demanded bits. When this function is called, it is known that only the bits; /// set in DemandedMask of the result of V are ever used downstream.; /// Consequently, depending on the mask and V, it may be possible to replace V; /// with a constant or one of its operands. In such cases, this function does; /// the replacement and returns true. In all other cases, it returns false after; /// analyzing the expression and setting KnownOne and known to be one in the; /// expression. Known.Zero contains all the bits that are known to be zero in; /// the expression. These are provided to potentially allow the caller (which; /// might recursively be SimplifyDemandedBits itself) to simplify the; /// expression.; /// Known.One and Known.Zero always follow the invariant that:; /// Known.One & Known.Zero == 0.; /// That is, a bit can't be both 1 and 0. The bits in Known.One and Known.Zero; /// are accurate even for bits not in DemandedMask. Note; /// also that the bitwidth of V, DemandedMask, Known.Zero and Known.One must all; /// be the same.; ///; /// This returns null if it did not change anything and it permits no; /// simplification. This returns V itself if it did some simplification of V's; /// operands based on the information about what bits are demanded. This returns; /// some other non-null value if it found out that V is equal to another value; /// in the context where the specified bits are demanded, but not for all users.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp:244,Integrability,depend,depending,244,"/// This function attempts to replace V with a simpler value based on the; /// demanded bits. When this function is called, it is known that only the bits; /// set in DemandedMask of the result of V are ever used downstream.; /// Consequently, depending on the mask and V, it may be possible to replace V; /// with a constant or one of its operands. In such cases, this function does; /// the replacement and returns true. In all other cases, it returns false after; /// analyzing the expression and setting KnownOne and known to be one in the; /// expression. Known.Zero contains all the bits that are known to be zero in; /// the expression. These are provided to potentially allow the caller (which; /// might recursively be SimplifyDemandedBits itself) to simplify the; /// expression.; /// Known.One and Known.Zero always follow the invariant that:; /// Known.One & Known.Zero == 0.; /// That is, a bit can't be both 1 and 0. The bits in Known.One and Known.Zero; /// are accurate even for bits not in DemandedMask. Note; /// also that the bitwidth of V, DemandedMask, Known.Zero and Known.One must all; /// be the same.; ///; /// This returns null if it did not change anything and it permits no; /// simplification. This returns V itself if it did some simplification of V's; /// operands based on the information about what bits are demanded. This returns; /// some other non-null value if it found out that V is equal to another value; /// in the context where the specified bits are demanded, but not for all users.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp:47,Usability,simpl,simpler,47,"/// This function attempts to replace V with a simpler value based on the; /// demanded bits. When this function is called, it is known that only the bits; /// set in DemandedMask of the result of V are ever used downstream.; /// Consequently, depending on the mask and V, it may be possible to replace V; /// with a constant or one of its operands. In such cases, this function does; /// the replacement and returns true. In all other cases, it returns false after; /// analyzing the expression and setting KnownOne and known to be one in the; /// expression. Known.Zero contains all the bits that are known to be zero in; /// the expression. These are provided to potentially allow the caller (which; /// might recursively be SimplifyDemandedBits itself) to simplify the; /// expression.; /// Known.One and Known.Zero always follow the invariant that:; /// Known.One & Known.Zero == 0.; /// That is, a bit can't be both 1 and 0. The bits in Known.One and Known.Zero; /// are accurate even for bits not in DemandedMask. Note; /// also that the bitwidth of V, DemandedMask, Known.Zero and Known.One must all; /// be the same.; ///; /// This returns null if it did not change anything and it permits no; /// simplification. This returns V itself if it did some simplification of V's; /// operands based on the information about what bits are demanded. This returns; /// some other non-null value if it found out that V is equal to another value; /// in the context where the specified bits are demanded, but not for all users.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp:728,Usability,Simpl,SimplifyDemandedBits,728,"/// This function attempts to replace V with a simpler value based on the; /// demanded bits. When this function is called, it is known that only the bits; /// set in DemandedMask of the result of V are ever used downstream.; /// Consequently, depending on the mask and V, it may be possible to replace V; /// with a constant or one of its operands. In such cases, this function does; /// the replacement and returns true. In all other cases, it returns false after; /// analyzing the expression and setting KnownOne and known to be one in the; /// expression. Known.Zero contains all the bits that are known to be zero in; /// the expression. These are provided to potentially allow the caller (which; /// might recursively be SimplifyDemandedBits itself) to simplify the; /// expression.; /// Known.One and Known.Zero always follow the invariant that:; /// Known.One & Known.Zero == 0.; /// That is, a bit can't be both 1 and 0. The bits in Known.One and Known.Zero; /// are accurate even for bits not in DemandedMask. Note; /// also that the bitwidth of V, DemandedMask, Known.Zero and Known.One must all; /// be the same.; ///; /// This returns null if it did not change anything and it permits no; /// simplification. This returns V itself if it did some simplification of V's; /// operands based on the information about what bits are demanded. This returns; /// some other non-null value if it found out that V is equal to another value; /// in the context where the specified bits are demanded, but not for all users.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp:760,Usability,simpl,simplify,760,"/// This function attempts to replace V with a simpler value based on the; /// demanded bits. When this function is called, it is known that only the bits; /// set in DemandedMask of the result of V are ever used downstream.; /// Consequently, depending on the mask and V, it may be possible to replace V; /// with a constant or one of its operands. In such cases, this function does; /// the replacement and returns true. In all other cases, it returns false after; /// analyzing the expression and setting KnownOne and known to be one in the; /// expression. Known.Zero contains all the bits that are known to be zero in; /// the expression. These are provided to potentially allow the caller (which; /// might recursively be SimplifyDemandedBits itself) to simplify the; /// expression.; /// Known.One and Known.Zero always follow the invariant that:; /// Known.One & Known.Zero == 0.; /// That is, a bit can't be both 1 and 0. The bits in Known.One and Known.Zero; /// are accurate even for bits not in DemandedMask. Note; /// also that the bitwidth of V, DemandedMask, Known.Zero and Known.One must all; /// be the same.; ///; /// This returns null if it did not change anything and it permits no; /// simplification. This returns V itself if it did some simplification of V's; /// operands based on the information about what bits are demanded. This returns; /// some other non-null value if it found out that V is equal to another value; /// in the context where the specified bits are demanded, but not for all users.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp:1207,Usability,simpl,simplification,1207,"/// This function attempts to replace V with a simpler value based on the; /// demanded bits. When this function is called, it is known that only the bits; /// set in DemandedMask of the result of V are ever used downstream.; /// Consequently, depending on the mask and V, it may be possible to replace V; /// with a constant or one of its operands. In such cases, this function does; /// the replacement and returns true. In all other cases, it returns false after; /// analyzing the expression and setting KnownOne and known to be one in the; /// expression. Known.Zero contains all the bits that are known to be zero in; /// the expression. These are provided to potentially allow the caller (which; /// might recursively be SimplifyDemandedBits itself) to simplify the; /// expression.; /// Known.One and Known.Zero always follow the invariant that:; /// Known.One & Known.Zero == 0.; /// That is, a bit can't be both 1 and 0. The bits in Known.One and Known.Zero; /// are accurate even for bits not in DemandedMask. Note; /// also that the bitwidth of V, DemandedMask, Known.Zero and Known.One must all; /// be the same.; ///; /// This returns null if it did not change anything and it permits no; /// simplification. This returns V itself if it did some simplification of V's; /// operands based on the information about what bits are demanded. This returns; /// some other non-null value if it found out that V is equal to another value; /// in the context where the specified bits are demanded, but not for all users.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp:1260,Usability,simpl,simplification,1260,"/// This function attempts to replace V with a simpler value based on the; /// demanded bits. When this function is called, it is known that only the bits; /// set in DemandedMask of the result of V are ever used downstream.; /// Consequently, depending on the mask and V, it may be possible to replace V; /// with a constant or one of its operands. In such cases, this function does; /// the replacement and returns true. In all other cases, it returns false after; /// analyzing the expression and setting KnownOne and known to be one in the; /// expression. Known.Zero contains all the bits that are known to be zero in; /// the expression. These are provided to potentially allow the caller (which; /// might recursively be SimplifyDemandedBits itself) to simplify the; /// expression.; /// Known.One and Known.Zero always follow the invariant that:; /// Known.One & Known.Zero == 0.; /// That is, a bit can't be both 1 and 0. The bits in Known.One and Known.Zero; /// are accurate even for bits not in DemandedMask. Note; /// also that the bitwidth of V, DemandedMask, Known.Zero and Known.One must all; /// be the same.; ///; /// This returns null if it did not change anything and it permits no; /// simplification. This returns V itself if it did some simplification of V's; /// operands based on the information about what bits are demanded. This returns; /// some other non-null value if it found out that V is equal to another value; /// in the context where the specified bits are demanded, but not for all users.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp:96,Usability,simpl,simplifications,96,"// If there are multiple uses of this value and we aren't at the root, then; // we can't do any simplifications of the operands, because DemandedMask; // only reflects the bits demanded by *one* of the users.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp:272,Testability,log,logic,272,"// If this is the root being simplified, allow it to have multiple uses,; // just set the DemandedMask to all bits so that we can try to simplify the; // operands. This allows visitTruncInst (for example) to simplify the; // operand of a trunc without duplicating all the logic below.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp:29,Usability,simpl,simplified,29,"// If this is the root being simplified, allow it to have multiple uses,; // just set the DemandedMask to all bits so that we can try to simplify the; // operands. This allows visitTruncInst (for example) to simplify the; // operand of a trunc without duplicating all the logic below.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp:137,Usability,simpl,simplify,137,"// If this is the root being simplified, allow it to have multiple uses,; // just set the DemandedMask to all bits so that we can try to simplify the; // operands. This allows visitTruncInst (for example) to simplify the; // operand of a trunc without duplicating all the logic below.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp:208,Usability,simpl,simplify,208,"// If this is the root being simplified, allow it to have multiple uses,; // just set the DemandedMask to all bits so that we can try to simplify the; // operands. This allows visitTruncInst (for example) to simplify the; // operand of a trunc without duplicating all the logic below.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp:3,Deployability,Update,Update,3,// Update flags after simplifying an operand based on the fact that some high; // order bits are not demanded.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp:22,Usability,simpl,simplifying,22,// Update flags after simplifying an operand based on the fact that some high; // order bits are not demanded.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp:84,Integrability,wrap,wrap,84,// Disable the nsw and nuw flags here: We can no longer guarantee that; // we won't wrap after simplification. Removing the nsw/nuw flags is; // legal here because the top bit is not demanded.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp:95,Usability,simpl,simplification,95,// Disable the nsw and nuw flags here: We can no longer guarantee that; // we won't wrap after simplification. Removing the nsw/nuw flags is; // legal here because the top bit is not demanded.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp:18,Availability,mask,mask,18,// Right fill the mask of bits for the operands to demand the most; // significant bit and all those below it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp:43,Usability,simpl,simplify,43,"// If the RHS is a constant, see if we can simplify it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp:43,Usability,simpl,simplify,43,"// If the RHS is a constant, see if we can simplify it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp:194,Usability,clear,cleared,194,"// If all of the demanded bits on one side are known, and all of the set; // bits on that side are also known to be set on the other side, turn this; // into an AND, as we know the bits will be cleared.; // e.g. (X | C1) ^ C2 --> (X | C1) & ~C2 iff (C1&C2) == C2",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp:229,Usability,simpl,simplifying,229,"// If our LHS is an 'and' and if it has one use, and if any of the bits we; // are flipping are known to be set, then the xor is just resetting those; // bits to zero. We can just knock out bits from the 'and' and the 'xor',; // simplifying both of them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp:48,Usability,simpl,simplify,48,"// If the operands are constants, see if we can simplify them.; // This is similar to ShrinkDemandedConstant, but for a select we want to; // try to keep the selected constants the same as icmp value constants, if; // we can. This helps not break apart (or helps put back together); // canonical patterns like min and max.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp:231,Energy Efficiency,reduce,reduces,231,"// Get the constant out of the ICmp, if there is one.; // Only try this when exactly 1 operand is a constant (if both operands; // are constant, the icmp should eventually simplify). Otherwise, we may; // invert the transform that reduces set bits and infinite-loop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp:172,Usability,simpl,simplify,172,"// Get the constant out of the ICmp, if there is one.; // Only try this when exactly 1 operand is a constant (if both operands; // are constant, the icmp should eventually simplify). Otherwise, we may; // invert the transform that reduces set bits and infinite-loop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp:77,Availability,mask,mask,77,"// If the constants are not already the same, but can be with the demand; // mask, use the constant value from the ICmp.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp:22,Modifiability,extend,extended,22,"// If any of the sign extended bits are demanded, we know that the sign; // bit is demanded.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp:48,Usability,clear,clear,48,"// If the sign bit of the input is known set or clear, then we know the; // top bits of the result.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp:62,Testability,log,logic,62,"// If we do not need the low bit, try to convert bool math to logic:; // add iN (zext i1 X), (sext i1 Y) --> sext (~X & Y) to iN",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp:18,Availability,mask,mask,18,// Right fill the mask of bits for the operands to demand the most; // significant bit and all those below it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp:18,Availability,mask,mask,18,// Right fill the mask of bits for the operands to demand the most; // significant bit and all those below it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp:58,Availability,mask,mask,58,"// This is a variable shift, so we can't shift the demand mask by a known; // amount. But if we are not demanding high bits, then we are not; // demanding those bits from the pre-shifted operand either.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp:13,Modifiability,variab,variable,13,"// This is a variable shift, so we can't shift the demand mask by a known; // amount. But if we are not demanding high bits, then we are not; // demanding those bits from the pre-shifted operand either.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp:46,Usability,simpl,simplifying,46,// We can't guarantee that nsw/nuw hold after simplifying the operand.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp:152,Modifiability,variab,variable,152,"// If this is an arithmetic shift right and only the low-bit is set, we can; // always convert this into a logical shr, even if the shift amount is; // variable. The low bit of the shift cannot be an input sign bit unless; // the shift amount is >= the size of the datatype, which is undefined.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp:107,Testability,log,logical,107,"// If this is an arithmetic shift right and only the low-bit is set, we can; // always convert this into a logical shr, even if the shift amount is; // variable. The low bit of the shift cannot be an input sign bit unless; // the shift amount is >= the size of the datatype, which is undefined.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp:3,Performance,Perform,Perform,3,// Perform the logical shift right.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp:15,Testability,log,logical,15,// Perform the logical shift right.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp:62,Availability,Mask,Mask,62,// SignBits may be out-of-sync with Known.countMinSignBits(). Mask out; // high bits of Known.Zero to avoid conflicts.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp:102,Safety,avoid,avoid,102,// SignBits may be out-of-sync with Known.countMinSignBits(). Mask out; // high bits of Known.Zero to avoid conflicts.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp:27,Availability,mask,mask,27,// TODO: Take the demanded mask of the result into account.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp:29,Usability,clear,clear,29,"// Checking if the number of clear bits is odd (parity)? If the type has; // an even number of bits, that's the same as checking if the number of; // set bits is odd, so we can eliminate the 'not' op.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp:13,Availability,down,down,13,"// Round NTZ down to the next byte. If we have 11 trailing zeros, then; // we need all the bits down to bit 8. Likewise, round NLZ. If we; // have 14 leading zeros, round to 8.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp:96,Availability,down,down,96,"// Round NTZ down to the next byte. If we have 11 trailing zeros, then; // we need all the bits down to bit 8. Likewise, round NLZ. If we; // have 14 leading zeros, round to 8.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp:21,Modifiability,extend,extend,21,// TODO: Should be 1-extend,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp:167,Availability,mask,mask,167,"// If the client is only demanding bits we know to be zero, return; // `llvm.ptrmask(p, 0)`. We can't return `null` here due to pointer; // provenance, but making the mask zero will be easily optimizable in; // the backend.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp:192,Performance,optimiz,optimizable,192,"// If the client is only demanding bits we know to be zero, return; // `llvm.ptrmask(p, 0)`. We can't return `null` here due to pointer; // provenance, but making the mask zero will be easily optimizable in; // the backend.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp:3,Availability,Mask,Mask,3,// Mask in demanded space does nothing.; // NOTE: We may have attributes associated with the return value of the; // llvm.ptrmask intrinsic that will be lost when we just return the; // operand. We should try to preserve them.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp:43,Usability,simpl,simplify,43,"// If the RHS is a constant, see if we can simplify it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp:24,Safety,Avoid,Avoid,24,// fshl is a rotate; // Avoid converting rotate into funnel shift.; // Only simplify if one operand is constant.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp:76,Usability,simpl,simplify,76,// fshl is a rotate; // Avoid converting rotate into funnel shift.; // Only simplify if one operand is constant.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp:103,Usability,simpl,simplify,103,"// If the client is only demanding bits that we know, return the known; // constant. We can't directly simplify pointers as a constant because of; // pointer provenance.; // TODO: We could return `(inttoptr const)` for pointers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp:11,Integrability,rout,routine,11,"/// Helper routine of SimplifyDemandedUseBits. It computes Known; /// bits. It also tries to handle simplifications that can be done based on; /// DemandedMask, but without modifying the Instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp:22,Usability,Simpl,SimplifyDemandedUseBits,22,"/// Helper routine of SimplifyDemandedUseBits. It computes Known; /// bits. It also tries to handle simplifications that can be done based on; /// DemandedMask, but without modifying the Instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp:100,Usability,simpl,simplifications,100,"/// Helper routine of SimplifyDemandedUseBits. It computes Known; /// bits. It also tries to handle simplifications that can be done based on; /// DemandedMask, but without modifying the Instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp:34,Usability,simpl,simplify,34,"// Despite the fact that we can't simplify this instruction in all User's; // context, we can at least compute the known bits, and we can; // do simplifications that apply to *just* the one user if we know that; // this instruction has a simpler value in that context.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp:145,Usability,simpl,simplifications,145,"// Despite the fact that we can't simplify this instruction in all User's; // context, we can at least compute the known bits, and we can; // do simplifications that apply to *just* the one user if we know that; // this instruction has a simpler value in that context.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp:238,Usability,simpl,simpler,238,"// Despite the fact that we can't simplify this instruction in all User's; // context, we can at least compute the known bits, and we can; // do simplifications that apply to *just* the one user if we know that; // this instruction has a simpler value in that context.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp:10,Usability,simpl,simplify,10,"// We can simplify (X|Y) -> X or Y in the user's context if we know that; // only bits from X or Y are demanded.; // If all of the demanded bits are known zero on one side, return the other.; // These bits cannot contribute to the result of the 'or' in this context.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp:10,Usability,simpl,simplify,10,"// We can simplify (X^Y) -> X or Y in the user's context if we know that; // only bits from X or Y are demanded.; // If all of the demanded bits are known zero on one side, return the other.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp:45,Availability,down,downstream,45,// Compute the Known bits to simplify things downstream.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp:29,Usability,simpl,simplify,29,// Compute the Known bits to simplify things downstream.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp:45,Availability,down,downstream,45,// Compute the Known bits to simplify things downstream.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp:29,Usability,simpl,simplify,29,// Compute the Known bits to simplify things downstream.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp:11,Integrability,rout,routine,11,"/// Helper routine of SimplifyDemandedUseBits. It tries to simplify; /// ""E1 = (X lsr C1) << C2"", where the C1 and C2 are constant, into; /// ""E2 = X << (C2 - C1)"" or ""E2 = X >> (C1 - C2)"", depending on the sign; /// of ""C2-C1"".; ///; /// Suppose E1 and E2 are generally different in bits S={bm, bm+1,; /// ..., bn}, without considering the specific value X is holding.; /// This transformation is legal iff one of following conditions is hold:; /// 1) All the bit in S are 0, in this case E1 == E2.; /// 2) We don't care those bits in S, per the input DemandedMask.; /// 3) Combination of 1) and 2). Some bits in S are 0, and we don't care the; /// rest bits.; ///; /// Currently we only test condition 2).; ///; /// As with SimplifyDemandedUseBits, it returns NULL if the simplification was; /// not successful.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp:190,Integrability,depend,depending,190,"/// Helper routine of SimplifyDemandedUseBits. It tries to simplify; /// ""E1 = (X lsr C1) << C2"", where the C1 and C2 are constant, into; /// ""E2 = X << (C2 - C1)"" or ""E2 = X >> (C1 - C2)"", depending on the sign; /// of ""C2-C1"".; ///; /// Suppose E1 and E2 are generally different in bits S={bm, bm+1,; /// ..., bn}, without considering the specific value X is holding.; /// This transformation is legal iff one of following conditions is hold:; /// 1) All the bit in S are 0, in this case E1 == E2.; /// 2) We don't care those bits in S, per the input DemandedMask.; /// 3) Combination of 1) and 2). Some bits in S are 0, and we don't care the; /// rest bits.; ///; /// Currently we only test condition 2).; ///; /// As with SimplifyDemandedUseBits, it returns NULL if the simplification was; /// not successful.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp:689,Testability,test,test,689,"/// Helper routine of SimplifyDemandedUseBits. It tries to simplify; /// ""E1 = (X lsr C1) << C2"", where the C1 and C2 are constant, into; /// ""E2 = X << (C2 - C1)"" or ""E2 = X >> (C1 - C2)"", depending on the sign; /// of ""C2-C1"".; ///; /// Suppose E1 and E2 are generally different in bits S={bm, bm+1,; /// ..., bn}, without considering the specific value X is holding.; /// This transformation is legal iff one of following conditions is hold:; /// 1) All the bit in S are 0, in this case E1 == E2.; /// 2) We don't care those bits in S, per the input DemandedMask.; /// 3) Combination of 1) and 2). Some bits in S are 0, and we don't care the; /// rest bits.; ///; /// Currently we only test condition 2).; ///; /// As with SimplifyDemandedUseBits, it returns NULL if the simplification was; /// not successful.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp:22,Usability,Simpl,SimplifyDemandedUseBits,22,"/// Helper routine of SimplifyDemandedUseBits. It tries to simplify; /// ""E1 = (X lsr C1) << C2"", where the C1 and C2 are constant, into; /// ""E2 = X << (C2 - C1)"" or ""E2 = X >> (C1 - C2)"", depending on the sign; /// of ""C2-C1"".; ///; /// Suppose E1 and E2 are generally different in bits S={bm, bm+1,; /// ..., bn}, without considering the specific value X is holding.; /// This transformation is legal iff one of following conditions is hold:; /// 1) All the bit in S are 0, in this case E1 == E2.; /// 2) We don't care those bits in S, per the input DemandedMask.; /// 3) Combination of 1) and 2). Some bits in S are 0, and we don't care the; /// rest bits.; ///; /// Currently we only test condition 2).; ///; /// As with SimplifyDemandedUseBits, it returns NULL if the simplification was; /// not successful.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp:59,Usability,simpl,simplify,59,"/// Helper routine of SimplifyDemandedUseBits. It tries to simplify; /// ""E1 = (X lsr C1) << C2"", where the C1 and C2 are constant, into; /// ""E2 = X << (C2 - C1)"" or ""E2 = X >> (C1 - C2)"", depending on the sign; /// of ""C2-C1"".; ///; /// Suppose E1 and E2 are generally different in bits S={bm, bm+1,; /// ..., bn}, without considering the specific value X is holding.; /// This transformation is legal iff one of following conditions is hold:; /// 1) All the bit in S are 0, in this case E1 == E2.; /// 2) We don't care those bits in S, per the input DemandedMask.; /// 3) Combination of 1) and 2). Some bits in S are 0, and we don't care the; /// rest bits.; ///; /// Currently we only test condition 2).; ///; /// As with SimplifyDemandedUseBits, it returns NULL if the simplification was; /// not successful.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp:726,Usability,Simpl,SimplifyDemandedUseBits,726,"/// Helper routine of SimplifyDemandedUseBits. It tries to simplify; /// ""E1 = (X lsr C1) << C2"", where the C1 and C2 are constant, into; /// ""E2 = X << (C2 - C1)"" or ""E2 = X >> (C1 - C2)"", depending on the sign; /// of ""C2-C1"".; ///; /// Suppose E1 and E2 are generally different in bits S={bm, bm+1,; /// ..., bn}, without considering the specific value X is holding.; /// This transformation is legal iff one of following conditions is hold:; /// 1) All the bit in S are 0, in this case E1 == E2.; /// 2) We don't care those bits in S, per the input DemandedMask.; /// 3) Combination of 1) and 2). Some bits in S are 0, and we don't care the; /// rest bits.; ///; /// Currently we only test condition 2).; ///; /// As with SimplifyDemandedUseBits, it returns NULL if the simplification was; /// not successful.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp:774,Usability,simpl,simplification,774,"/// Helper routine of SimplifyDemandedUseBits. It tries to simplify; /// ""E1 = (X lsr C1) << C2"", where the C1 and C2 are constant, into; /// ""E2 = X << (C2 - C1)"" or ""E2 = X >> (C1 - C2)"", depending on the sign; /// of ""C2-C1"".; ///; /// Suppose E1 and E2 are generally different in bits S={bm, bm+1,; /// ..., bn}, without considering the specific value X is holding.; /// This transformation is legal iff one of following conditions is hold:; /// 1) All the bit in S are 0, in this case E1 == E2.; /// 2) We don't care those bits in S, per the input DemandedMask.; /// 3) Combination of 1) and 2). Some bits in S are 0, and we don't care the; /// rest bits.; ///; /// Currently we only test condition 2).; ///; /// As with SimplifyDemandedUseBits, it returns NULL if the simplification was; /// not successful.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp:349,Usability,simpl,simplified,349,"/// The specified value produces a vector with any number of elements.; /// This method analyzes which elements of the operand are poison and; /// returns that information in PoisonElts.; ///; /// DemandedElts contains the set of elements that are actually used by the; /// caller, and by default (AllowMultipleUsers equals false) the value is; /// simplified only if it has a single caller. If AllowMultipleUsers is set; /// to true, DemandedElts refers to the union of sets of elements that are; /// used by all callers.; ///; /// If the information about demanded elements can be used to simplify the; /// operation, the operation is simplified, then the resultant value is; /// returned. This returns null if no change was made.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp:591,Usability,simpl,simplify,591,"/// The specified value produces a vector with any number of elements.; /// This method analyzes which elements of the operand are poison and; /// returns that information in PoisonElts.; ///; /// DemandedElts contains the set of elements that are actually used by the; /// caller, and by default (AllowMultipleUsers equals false) the value is; /// simplified only if it has a single caller. If AllowMultipleUsers is set; /// to true, DemandedElts refers to the union of sets of elements that are; /// used by all callers.; ///; /// If the information about demanded elements can be used to simplify the; /// operation, the operation is simplified, then the resultant value is; /// returned. This returns null if no change was made.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp:637,Usability,simpl,simplified,637,"/// The specified value produces a vector with any number of elements.; /// This method analyzes which elements of the operand are poison and; /// returns that information in PoisonElts.; ///; /// DemandedElts contains the set of elements that are actually used by the; /// caller, and by default (AllowMultipleUsers equals false) the value is; /// simplified only if it has a single caller. If AllowMultipleUsers is set; /// to true, DemandedElts refers to the union of sets of elements that are; /// used by all callers.; ///; /// If the information about demanded elements can be used to simplify the; /// operation, the operation is simplified, then the resultant value is; /// returned. This returns null if no change was made.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp:18,Performance,scalab,scalable,18,// Cannot analyze scalable type. The number of vector elements is not a; // compile-time constant.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp:63,Usability,simpl,simplifying,63,"// Check if this is identity. If so, return 0 since we are not simplifying; // anything.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp:64,Usability,simpl,simplification,64,"// If multiple users are using the root value, proceed with; // simplification conservatively assuming that all elements; // are needed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp:16,Modifiability,variab,variable,16,"// If this is a variable index, we don't know which element it overwrites.; // demand exactly the same input as we produce.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp:95,Deployability,update,updated,95,"// Note that we can't propagate undef elt info, because we don't know; // which elt is getting updated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp:88,Usability,simpl,simpler,88,"// The element inserted overwrites whatever was there, so the input demanded; // set is simpler than the output set.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp:244,Usability,simpl,simplifyAndSetOp,244,"// If we only demand the element that is being inserted and that element; // was extracted from the same index in another vector with the same type,; // replace this insert with that other vector.; // Note: This is attempted before the call to simplifyAndSetOp because that; // may change PoisonElts to a value that does not match with Vec.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp:115,Availability,mask,mask,115,"// If this shuffle does not change the vector length and the elements; // demanded by this shuffle are an identity mask, then this shuffle is; // unnecessary.; //; // We are assuming canonical form for the mask, so the source vector is; // operand 0 and operand 1 is not used.; //; // Note that if an element is demanded and this shuffle mask is undefined; // for that element, then the shuffle is not considered an identity; // operation. The shuffle prevents poison from the operand vector from; // leaking to the result by replacing poison with an undefined value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp:206,Availability,mask,mask,206,"// If this shuffle does not change the vector length and the elements; // demanded by this shuffle are an identity mask, then this shuffle is; // unnecessary.; //; // We are assuming canonical form for the mask, so the source vector is; // operand 0 and operand 1 is not used.; //; // Note that if an element is demanded and this shuffle mask is undefined; // for that element, then the shuffle is not considered an identity; // operation. The shuffle prevents poison from the operand vector from; // leaking to the result by replacing poison with an undefined value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp:338,Availability,mask,mask,338,"// If this shuffle does not change the vector length and the elements; // demanded by this shuffle are an identity mask, then this shuffle is; // unnecessary.; //; // We are assuming canonical form for the mask, so the source vector is; // operand 0 and operand 1 is not used.; //; // Note that if an element is demanded and this shuffle mask is undefined; // for that element, then the shuffle is not considered an identity; // operation. The shuffle prevents poison from the operand vector from; // leaking to the result by replacing poison with an undefined value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp:102,Safety,avoid,avoid,102,// isNullValue() always returns false when called on a ConstantExpr.; // Skip constant expressions to avoid propagating incorrect information.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp:19,Performance,load,load,19,"// Subtlety: If we load from a pointer, the pointer must be valid; // regardless of whether the element is demanded. Doing otherwise risks; // segfaults which didn't exist in the original program.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp:133,Safety,risk,risks,133,"// Subtlety: If we load from a pointer, the pointer must be valid; // regardless of whether the element is demanded. Doing otherwise risks; // segfaults which didn't exist in the original program.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp:100,Availability,mask,mask,100,// Output elements are undefined if the element from both sources are.; // TODO: can strengthen via mask as well.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp:622,Safety,safe,safe,622,"// Look for an equivalent binop except that one operand has been shuffled.; // If the demand for this binop only includes elements that are the same as; // the other binop, then we may be able to replace this binop with a use of; // the earlier one.; //; // Example:; // %other_bo = bo (shuf X, {0}), Y; // %this_extracted_bo = extelt (bo X, Y), 0; // -->; // %other_bo = bo (shuf X, {0}), Y; // %this_extracted_bo = extelt %other_bo, 0; //; // TODO: Handle demand of an arbitrary single element or more than one; // element instead of just element 0.; // TODO: Unlike general demanded elements transforms, this should be safe; // for any (div/rem/shift) opcode too.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:80,Performance,scalab,scalable,80,"// Index needs to be lower than the minimum size of the vector, because; // for scalable vector, the vector size is known at run time.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:67,Usability,simpl,simplify,67,// An insertelement to the same constant index as our extract will simplify; // to the scalar inserted element. An insertelement to a different constant; // index is irrelevant to our extract.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:39,Modifiability,variab,variable,39,// If the operand is the PHI induction variable:,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:198,Usability,Simpl,SimplifyDemandedVectorElts,198,"// Remove insertelement, if we don't use the inserted element.; // extractelement (bitcast (insertelement (Vec, b)), a) ->; // extractelement (bitcast (Vec), a); // FIXME: this should be removed to SimplifyDemandedVectorElts,; // once scale vectors are supported.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:98,Integrability,depend,depends,98,"// We are extracting part of the original scalar. How that scalar is; // inserted into the vector depends on the endian-ness. Example:; // Vector Byte Elt Index: 0 1 2 3 4 5 6 7; // +--+--+--+--+--+--+--+--+; // inselt <2 x i32> V, <i32> S, 1: |V0|V1|V2|V3|S0|S1|S2|S3|; // extelt <4 x i16> V', 3: | |S2|S3|; // +--+--+--+--+--+--+--+--+; // If this is little-endian, S2|S3 are the MSB of the 32-bit 'S' value.; // If this is big-endian, S2|S3 are the LSB of the 32-bit 'S' value.; // In this example, we must right-shift little-endian. Big-endian is just a; // truncate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:278,Usability,simpl,simplify,278,"/// Given a constant index for a extractelement or insertelement instruction,; /// return it with the canonical type if it isn't already canonical. We; /// arbitrarily pick 64 bit as our canonical type. The actual bitwidth doesn't; /// matter, we just want a consistent type to simplify CSE.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:367,Performance,optimiz,optimized,367,"// extractelt (select %x, %vec1, %vec2), %const ->; // select %x, %vec1[%const], %vec2[%const]; // TODO: Support constant folding of multiple select operands:; // extractelt (select %x, %vec1, %vec2), (select %x, %c1, %c2); // If the extractelement will for instance try to do out of bounds accesses; // because of the values of %c1 and/or %c2, the sequence could be optimized; // early. This is currently not possible because constant folding will reach; // an unreachable assertion if it doesn't find a constant operand.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:291,Security,access,accesses,291,"// extractelt (select %x, %vec1, %vec2), %const ->; // select %x, %vec1[%const], %vec2[%const]; // TODO: Support constant folding of multiple select operands:; // extractelt (select %x, %vec1, %vec2), (select %x, %c1, %c2); // If the extractelement will for instance try to do out of bounds accesses; // because of the values of %c1 and/or %c2, the sequence could be optimized; // early. This is currently not possible because constant folding will reach; // an unreachable assertion if it doesn't find a constant operand.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:474,Testability,assert,assertion,474,"// extractelt (select %x, %vec1, %vec2), %const ->; // select %x, %vec1[%const], %vec2[%const]; // TODO: Support constant folding of multiple select operands:; // extractelt (select %x, %vec1, %vec2), (select %x, %c1, %c2); // If the extractelement will for instance try to do out of bounds accesses; // because of the values of %c1 and/or %c2, the sequence could be optimized; // early. This is currently not possible because constant folding will reach; // an unreachable assertion if it doesn't find a constant operand.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:51,Usability,simpl,simplify,51,// Canonicalize type of constant indices to i64 to simplify CSE,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:80,Performance,scalab,scalable,80,"// Index needs to be lower than the minimum size of the vector, because; // for scalable vector, the vector size is known at run time.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:345,Performance,optimiz,optimization,345,"// Find out why we have a vector result - these are a few examples:; // 1. We have a scalar pointer and a vector of indices, or; // 2. We have a vector of pointers and a scalar index, or; // 3. We have a vector of pointers and a vector of indices, etc.; // Here we only consider combining when there is exactly one vector; // operand, since the optimization is less obviously a win due to; // needing more than one extractelements.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:88,Performance,scalab,scalable,88,"// This instruction only demands the single element from the input vector.; // Skip for scalable type, the number of elements is unknown at; // compile-time.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:41,Usability,simpl,simplify,41,"// If the input vector has a single use, simplify it based on this use; // property.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:42,Usability,simpl,simplify,42,"// If the input vector has multiple uses, simplify it based on a union; // of all elements used.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:107,Availability,mask,mask,107,"/// If V is a shuffle of values that ONLY returns elements from either LHS or; /// RHS, return the shuffle mask and true. Otherwise, return false.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:21,Availability,mask,mask,21,"// If so, update the mask to reflect the inserted poison.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:10,Deployability,update,update,10,"// If so, update the mask to reflect the inserted poison.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:21,Availability,mask,mask,21,"// If so, update the mask to reflect the inserted value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:10,Deployability,update,update,10,"// If so, update the mask to reflect the inserted value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:20,Availability,mask,mask,20,// Create a shuffle mask to widen the extended-from vector using poison; // values. The mask selects all of the values of the original vector followed; // by as many poison values as needed to create a vector of the same length; // as the inserted-to vector.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:88,Availability,mask,mask,88,// Create a shuffle mask to widen the extended-from vector using poison; // values. The mask selects all of the values of the original vector followed; // by as many poison values as needed to create a vector of the same length; // as the inserted-to vector.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:38,Modifiability,extend,extended-from,38,// Create a shuffle mask to widen the extended-from vector using poison; // values. The mask selects all of the values of the original vector followed; // by as many poison values as needed to create a vector of the same length; // as the inserted-to vector.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:493,Performance,optimiz,optimization,493,"// TODO: This restriction matches the basic block check below when creating; // new extractelement instructions. If that limitation is removed, this one; // could also be removed. But for now, we just bail out to ensure that we; // will replace the extractelement instruction that is feeding our; // insertelement instruction. This allows the insertelement to then be; // replaced by a shufflevector. If the insertelement is not replaced, we can; // induce infinite looping because there's an optimization for extractelement; // that will delete our widening shuffle. This would trigger another attempt; // here to create that shuffle, and we spin forever.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:300,Availability,mask,masks,300,"// TODO: This restriction matches the check in visitInsertElementInst() and; // prevents an infinite loop caused by not turning the extract/insert pair; // into a shuffle. We really should not need either check, but we're lacking; // folds for shufflevectors because we're afraid to generate shuffle masks; // that the backend can't handle.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:311,Availability,Mask,Mask,311,"/// We are building a shuffle to create V, which is a sequence of insertelement,; /// extractelement pairs. If PermittedRHS is set, then we must either use it or; /// not rely on the second vector source. Return a std::pair containing the; /// left and right vectors of the proposed shuffle (or 0), and set the Mask; /// parameter as required.; ///; /// Note: we intentionally don't try to fold earlier shuffles since they have; /// often been chosen carefully to be efficiently implementable on the target.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:467,Energy Efficiency,efficient,efficiently,467,"/// We are building a shuffle to create V, which is a sequence of insertelement,; /// extractelement pairs. If PermittedRHS is set, then we must either use it or; /// not rely on the second vector source. Return a std::pair containing the; /// left and right vectors of the proposed shuffle (or 0), and set the Mask; /// parameter as required.; ///; /// Note: we intentionally don't try to fold earlier shuffles since they have; /// often been chosen carefully to be efficiently implementable on the target.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:3,Performance,Cache,Cache,3,"// Cache the (non-uniqified!) list of predecessors in a vector,; // checking the limit at the same time for efficiency.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:16,Availability,redundant,redundant,16,"/// Try to find redundant insertvalue instructions, like the following ones:; /// %0 = insertvalue { i8, i32 } undef, i8 %x, 0; /// %1 = insertvalue { i8, i32 } %0, i8 %y, 0; /// Here the second instruction inserts values at the same indices, as the; /// first one, making the first one redundant.; /// It should be transformed to:; /// %0 = insertvalue { i8, i32 } undef, i8 %y, 0",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:287,Availability,redundant,redundant,287,"/// Try to find redundant insertvalue instructions, like the following ones:; /// %0 = insertvalue { i8, i32 } undef, i8 %x, 0; /// %1 = insertvalue { i8, i32 } %0, i8 %y, 0; /// Here the second instruction inserts values at the same indices, as the; /// first one, making the first one redundant.; /// It should be transformed to:; /// %0 = insertvalue { i8, i32 } undef, i8 %y, 0",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:16,Safety,redund,redundant,16,"/// Try to find redundant insertvalue instructions, like the following ones:; /// %0 = insertvalue { i8, i32 } undef, i8 %x, 0; /// %1 = insertvalue { i8, i32 } %0, i8 %y, 0; /// Here the second instruction inserts values at the same indices, as the; /// first one, making the first one redundant.; /// It should be transformed to:; /// %0 = insertvalue { i8, i32 } undef, i8 %y, 0",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:287,Safety,redund,redundant,287,"/// Try to find redundant insertvalue instructions, like the following ones:; /// %0 = insertvalue { i8, i32 } undef, i8 %x, 0; /// %1 = insertvalue { i8, i32 } %0, i8 %y, 0; /// Here the second instruction inserts values at the same indices, as the; /// first one, making the first one redundant.; /// It should be transformed to:; /// %0 = insertvalue { i8, i32 } undef, i8 %y, 0",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:276,Availability,redundant,redundant,276,"// If there is a chain of insertvalue instructions (each of them except the; // last one has only one use and it's another insertvalue insn from this; // chain), check if any of the 'children' uses the same indices as the first; // instruction. In this case, the first one is redundant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:276,Safety,redund,redundant,276,"// If there is a chain of insertvalue instructions (each of them except the; // last one has only one use and it's another insertvalue insn from this; // chain), check if any of the 'children' uses the same indices as the first; // instruction. In this case, the first one is redundant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:19,Performance,scalab,scalable,19,"// Can not analyze scalable type, the number of elements is not a compile-time; // constant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:8,Availability,mask,mask,8,// Each mask element must be undefined or choose a vector element from one of; // the source operands without crossing vector lanes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:18,Performance,scalab,scalable,18,"// Can not handle scalable type, the number of elements is not a compile-time; // constant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:72,Availability,mask,mask,72,"// Splat from element 0, but replace absent elements with poison in the mask.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:96,Availability,mask,mask,96,/// Try to fold an insert element into an existing splat shuffle by changing; /// the shuffle's mask to include the index of this insert element.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:85,Availability,mask,mask,85,// Bail out early if shuffle is scalable type. The number of elements in; // shuffle mask is unknown at compile-time.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:32,Performance,scalab,scalable,32,// Bail out early if shuffle is scalable type. The number of elements in; // shuffle mask is unknown at compile-time.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:23,Availability,mask,mask,23,"// Replace the shuffle mask element at the index of this insert with a zero.; // For example:; // inselt (shuf (inselt undef, X, 0), _, <0,undef,0,undef>), X, 1; // --> shuf (inselt undef, X, 0), poison, <0,0,0,undef>",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:107,Availability,mask,mask,107,/// Try to fold an extract+insert element into an existing identity shuffle by; /// changing the shuffle's mask to include the index of this insert element.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:85,Availability,mask,mask,85,// Bail out early if shuffle is scalable type. The number of elements in; // shuffle mask is unknown at compile-time.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:32,Performance,scalab,scalable,32,// Bail out early if shuffle is scalable type. The number of elements in; // shuffle mask is unknown at compile-time.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:23,Availability,mask,mask,23,"// Replace the shuffle mask element at the index of this extract+insert with; // that same index value.; // For example:; // inselt (shuf X, IdMask), (extelt X, IdxC), IdxC --> shuf X, IdMask'",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:7,Availability,mask,mask,7,// All mask elements besides the inserted element remain the same.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:10,Availability,mask,mask,10,"// If the mask element was already set, there's nothing to do; // (demanded elements analysis may unset it later).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:205,Modifiability,variab,variable,205,"/// If we have an insertelement instruction feeding into another insertelement; /// and the 2nd is inserting a constant into the vector, canonicalize that; /// constant insertion before the insertion of a variable:; ///; /// insertelement (insertelement X, Y, IdxC1), ScalarC, IdxC2 -->; /// insertelement (insertelement X, ScalarC, IdxC2), Y, IdxC1; ///; /// This has the potential of eliminating the 2nd insertelement instruction; /// via constant folding of the scalar constant into a vector constant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:38,Availability,Mask,Mask,38,"/// insertelt (shufflevector X, CVec, Mask|insertelt X, C1, CIndex1), C, CIndex; /// --> shufflevector X, CVec', Mask'",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:113,Availability,Mask,Mask,113,"/// insertelt (shufflevector X, CVec, Mask|insertelt X, C1, CIndex1), C, CIndex; /// --> shufflevector X, CVec', Mask'",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:132,Usability,clear,clear,132,"// Bail out if the parent has more than one use. In that case, we'd be; // replacing the insertelt with a shuffle, and that's not a clear win.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:51,Availability,mask,mask,51,"// From the above 'select' check, we know that the mask has the same number; // of elements as the vector input operands. We also know that each constant; // input element is used in its lane and can not be used more than once by; // the shuffle. Therefore, replace the constant in the shuffle's constant; // vector with the insertelt constant. Replace the constant in the shuffle's; // mask vector with the insertelt index plus the length of the vector; // (because the constant vector operand of a shuffle is always the 2nd; // operand).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:387,Availability,mask,mask,387,"// From the above 'select' check, we know that the mask has the same number; // of elements as the vector input operands. We also know that each constant; // input element is used in its lane and can not be used more than once by; // the shuffle. Therefore, replace the constant in the shuffle's constant; // vector with the insertelt constant. Replace the constant in the shuffle's; // mask vector with the insertelt index plus the length of the vector; // (because the constant vector operand of a shuffle is always the 2nd; // operand).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:188,Availability,mask,mask,188,"// Transform sequences of insertelements ops with constant data/indexes into; // a single shuffle op.; // Can not handle scalable type, the number of elements needed to create; // shuffle mask is not a compile-time constant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:121,Performance,scalab,scalable,121,"// Transform sequences of insertelements ops with constant data/indexes into; // a single shuffle op.; // Can not handle scalable type, the number of elements needed to create; // shuffle mask is not a compile-time constant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:36,Availability,mask,mask,36,// Generate new constant vector and mask.; // We have 2 values/masks from the insertelements instructions. Insert them; // into new value/mask vectors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:63,Availability,mask,masks,63,// Generate new constant vector and mask.; // We have 2 values/masks from the insertelements instructions. Insert them; // into new value/mask vectors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:138,Availability,mask,mask,138,// Generate new constant vector and mask.; // We have 2 values/masks from the insertelements instructions. Insert them; // into new value/mask vectors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:57,Modifiability,extend,extended,57,"/// If both the base vector and the inserted element are extended from the same; /// type, do the insert element in the narrow source type followed by extend.; /// TODO: This can be extended to include other cast opcodes, but particularly; /// if we create a wider insertelement, make sure codegen is not harmed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:151,Modifiability,extend,extend,151,"/// If both the base vector and the inserted element are extended from the same; /// type, do the insert element in the narrow source type followed by extend.; /// TODO: This can be extended to include other cast opcodes, but particularly; /// if we create a wider insertelement, make sure codegen is not harmed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:182,Modifiability,extend,extended,182,"/// If both the base vector and the inserted element are extended from the same; /// type, do the insert element in the narrow source type followed by extend.; /// TODO: This can be extended to include other cast opcodes, but particularly; /// if we create a wider insertelement, make sure codegen is not harmed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:28,Modifiability,extend,extend,28,"// We are creating a vector extend. If the original vector extend has another; // use, that would mean we end up with 2 vector extends, so avoid that.; // TODO: We could ease the use-clause to ""if at least one op has one use""; // (assuming that the source types match - see next TODO comment).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:59,Modifiability,extend,extend,59,"// We are creating a vector extend. If the original vector extend has another; // use, that would mean we end up with 2 vector extends, so avoid that.; // TODO: We could ease the use-clause to ""if at least one op has one use""; // (assuming that the source types match - see next TODO comment).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:127,Modifiability,extend,extends,127,"// We are creating a vector extend. If the original vector extend has another; // use, that would mean we end up with 2 vector extends, so avoid that.; // TODO: We could ease the use-clause to ""if at least one op has one use""; // (assuming that the source types match - see next TODO comment).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:139,Safety,avoid,avoid,139,"// We are creating a vector extend. If the original vector extend has another; // use, that would mean we end up with 2 vector extends, so avoid that.; // TODO: We could ease the use-clause to ""if at least one op has one use""; // (assuming that the source types match - see next TODO comment).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:11,Integrability,depend,depends,11,"// Pattern depends on endian because we expect lower index is inserted first.; // Big endian:; // inselt (inselt BaseVec, (trunc (lshr X, BW/2), Index0), (trunc X), Index1; // Little endian:; // inselt (inselt BaseVec, (trunc X), Index0), (trunc (lshr X, BW/2)), Index1; // Note: It is not safe to do this transform with an arbitrary base vector; // because the bitcast of that vector to fewer/larger elements could; // allow poison to spill into an element that was not poison before.; // TODO: Detect smaller fractions of the scalar.; // TODO: One-use checks are conservative.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:290,Safety,safe,safe,290,"// Pattern depends on endian because we expect lower index is inserted first.; // Big endian:; // inselt (inselt BaseVec, (trunc (lshr X, BW/2), Index0), (trunc X), Index1; // Little endian:; // inselt (inselt BaseVec, (trunc X), Index0), (trunc (lshr X, BW/2)), Index1; // Note: It is not safe to do this transform with an arbitrary base vector; // because the bitcast of that vector to fewer/larger elements could; // allow poison to spill into an element that was not poison before.; // TODO: Detect smaller fractions of the scalar.; // TODO: One-use checks are conservative.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:496,Safety,Detect,Detect,496,"// Pattern depends on endian because we expect lower index is inserted first.; // Big endian:; // inselt (inselt BaseVec, (trunc (lshr X, BW/2), Index0), (trunc X), Index1; // Little endian:; // inselt (inselt BaseVec, (trunc X), Index0), (trunc (lshr X, BW/2)), Index1; // Note: It is not safe to do this transform with an arbitrary base vector; // because the bitcast of that vector to fewer/larger elements could; // allow poison to spill into an element that was not poison before.; // TODO: Detect smaller fractions of the scalar.; // TODO: One-use checks are conservative.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:51,Usability,simpl,simplify,51,// Canonicalize type of constant indices to i64 to simplify CSE,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:245,Availability,mask,mask,245,"// If the inserted element was extracted from some other fixed-length vector; // and both indexes are valid constants, try to turn this into a shuffle.; // Can not handle scalable vector type, the number of elements needed to; // create shuffle mask is not a compile-time constant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:171,Performance,scalab,scalable,171,"// If the inserted element was extracted from some other fixed-length vector; // and both indexes are valid constants, try to turn this into a shuffle.; // Can not handle scalable vector type, the number of elements needed to; // create shuffle mask is not a compile-time constant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:475,Availability,mask,masks,475,"// TODO: Looking at the user(s) to determine if this insert is a; // fold-to-shuffle opportunity does not match the usual instcombine; // constraints. We should decide if the transform is worthy based only; // on this instruction and its operands, but that may not work currently.; //; // Here, we are trying to avoid creating shuffles before reaching; // the end of a chain of extract-insert pairs. This is complicated because; // we do not generally form arbitrary shuffle masks in instcombine; // (because those may codegen poorly), but collectShuffleElements() does; // exactly that.; //; // The rules for determining what is an acceptable target-independent; // shuffle mask are fuzzy because they evolve based on the backend's; // capabilities and real-world impact.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:675,Availability,mask,mask,675,"// TODO: Looking at the user(s) to determine if this insert is a; // fold-to-shuffle opportunity does not match the usual instcombine; // constraints. We should decide if the transform is worthy based only; // on this instruction and its operands, but that may not work currently.; //; // Here, we are trying to avoid creating shuffles before reaching; // the end of a chain of extract-insert pairs. This is complicated because; // we do not generally form arbitrary shuffle masks in instcombine; // (because those may codegen poorly), but collectShuffleElements() does; // exactly that.; //; // The rules for determining what is an acceptable target-independent; // shuffle mask are fuzzy because they evolve based on the backend's; // capabilities and real-world impact.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:703,Modifiability,evolve,evolve,703,"// TODO: Looking at the user(s) to determine if this insert is a; // fold-to-shuffle opportunity does not match the usual instcombine; // constraints. We should decide if the transform is worthy based only; // on this instruction and its operands, but that may not work currently.; //; // Here, we are trying to avoid creating shuffles before reaching; // the end of a chain of extract-insert pairs. This is complicated because; // we do not generally form arbitrary shuffle masks in instcombine; // (because those may codegen poorly), but collectShuffleElements() does; // exactly that.; //; // The rules for determining what is an acceptable target-independent; // shuffle mask are fuzzy because they evolve based on the backend's; // capabilities and real-world impact.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:312,Safety,avoid,avoid,312,"// TODO: Looking at the user(s) to determine if this insert is a; // fold-to-shuffle opportunity does not match the usual instcombine; // constraints. We should decide if the transform is worthy based only; // on this instruction and its operands, but that may not work currently.; //; // Here, we are trying to avoid creating shuffles before reaching; // the end of a chain of extract-insert pairs. This is complicated because; // we do not generally form arbitrary shuffle masks in instcombine; // (because those may codegen poorly), but collectShuffleElements() does; // exactly that.; //; // The rules for determining what is an acceptable target-independent; // shuffle mask are fuzzy because they evolve based on the backend's; // capabilities and real-world impact.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:71,Performance,perform,perform,71,"// The proposed shuffle may be trivial, in which case we shouldn't; // perform the combine.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:38,Availability,Mask,Mask,38,"// We now have a shuffle of LHS, RHS, Mask.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:36,Availability,mask,mask,36,// Propagating an undefined shuffle mask element to integer div/rem is not; // allowed because those opcodes can create immediate undefined behavior; // from an undefined element in an operand.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:44,Availability,Mask,Mask,44,// Verify that 'CI' does not occur twice in Mask. A single 'insertelement'; // can't put an element into multiple indices.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:26,Availability,mask,mask,26,// It's possible that the mask has a different number of elements from; // the original cast. We recompute the destination type to match the mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:141,Availability,mask,mask,141,// It's possible that the mask has a different number of elements from; // the original cast. We recompute the destination type to match the mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:3,Availability,Mask,Mask,3,// Mask.size() does not need to be equal to the number of vector elements.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:24,Availability,Mask,Mask,24,"// If element is not in Mask, no need to handle the operand 1 (element to; // be inserted). Just evaluate values in operand 0 according to Mask.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:139,Availability,Mask,Mask,139,"// If element is not in Mask, no need to handle the operand 1 (element to; // be inserted). Just evaluate values in operand 0 according to Mask.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:70,Energy Efficiency,reduce,reduced,70,"/// A select shuffle of a select shuffle with a shared operand can be reduced; /// to a single select shuffle. This is an obvious improvement in IR, and the; /// backend is expected to lower select shuffles efficiently.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:207,Energy Efficiency,efficient,efficiently,207,"/// A select shuffle of a select shuffle with a shared operand can be reduced; /// to a single select shuffle. This is an obvious improvement in IR, and the; /// backend is expected to lower select shuffles efficiently.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:10,Availability,mask,mask,10,"// If the mask chooses from X (operand 0), it stays the same.; // If the mask chooses from the earlier shuffle, the other mask value is; // transferred to the combined select shuffle:; // shuf X, (shuf X, Y, M1), M --> shuf X, Y, M'",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:73,Availability,mask,mask,73,"// If the mask chooses from X (operand 0), it stays the same.; // If the mask chooses from the earlier shuffle, the other mask value is; // transferred to the combined select shuffle:; // shuf X, (shuf X, Y, M1), M --> shuf X, Y, M'",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:122,Availability,mask,mask,122,"// If the mask chooses from X (operand 0), it stays the same.; // If the mask chooses from the earlier shuffle, the other mask value is; // transferred to the combined select shuffle:; // shuf X, (shuf X, Y, M1), M --> shuf X, Y, M'",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:12,Availability,mask,mask,12,// A select mask with undef elements might look like an identity mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:65,Availability,mask,mask,65,// A select mask with undef elements might look like an identity mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:46,Modifiability,variab,variable,46,"// The identity constant for a binop leaves a variable operand unchanged. For; // a vector, this is a splat of something like 0, -1, or 1.; // If there's no identity constant for this binop, we're done.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:20,Availability,mask,mask,20,"// An undef shuffle mask element may propagate as an undef constant element in; // the new binop. That would produce poison where the original code might not.; // If we already made a safe constant, then there's no danger.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:184,Safety,safe,safe,184,"// An undef shuffle mask element may propagate as an undef constant element in; // the new binop. That would produce poison where the original code might not.; // If we already made a safe constant, then there's no danger.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:29,Availability,mask,mask,29,"// Splat from element 0. Any mask element that is undefined remains undefined.; // For example:; // shuf (inselt undef, X, 2), _, <2,2,undef>; // --> shuf (inselt undef, X, 0), poison, <0,0,undef>",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:16,Testability,assert,assert,16,"// TODO: Can we assert that both operands of a shuffle-select are not undef; // (otherwise, it would have been folded by instsimplify?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:195,Safety,safe,safe,195,"// TODO: We drop ""nsw"" if shift is converted into multiply because it may; // not be correct when the shift amount is BitWidth - 1. We could examine; // each vector element to determine if it is safe to keep that flag.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:61,Usability,clear,clear,61,// The opcodes must be the same. Use a new name to make that clear.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:78,Availability,mask,mask,78,"// We are moving a binop after a shuffle. When a shuffle has an undefined; // mask element, the result is undefined, but it is not poison or undefined; // behavior. That is not necessarily true for div/rem/shift.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:28,Modifiability,variab,variable,28,"// If there are 2 different variable operands, we must create a new shuffle; // (select) first, so check uses to ensure that we don't end up with more; // instructions than we started with.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:34,Availability,mask,mask,34,"// If we use the original shuffle mask and op1 is *variable*, we would be; // putting an undef into operand 1 of div/rem/shift. This is either UB or; // poison. We do not have to guard against UB when *constants* are op1; // because safe constants guarantee that we do not overflow sdiv/srem (and; // there's no danger for other opcodes).; // TODO: To allow this case, create a new shuffle mask with no undefs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:390,Availability,mask,mask,390,"// If we use the original shuffle mask and op1 is *variable*, we would be; // putting an undef into operand 1 of div/rem/shift. This is either UB or; // poison. We do not have to guard against UB when *constants* are op1; // because safe constants guarantee that we do not overflow sdiv/srem (and; // there's no danger for other opcodes).; // TODO: To allow this case, create a new shuffle mask with no undefs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:51,Modifiability,variab,variable,51,"// If we use the original shuffle mask and op1 is *variable*, we would be; // putting an undef into operand 1 of div/rem/shift. This is either UB or; // poison. We do not have to guard against UB when *constants* are op1; // because safe constants guarantee that we do not overflow sdiv/srem (and; // there's no danger for other opcodes).; // TODO: To allow this case, create a new shuffle mask with no undefs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:233,Safety,safe,safe,233,"// If we use the original shuffle mask and op1 is *variable*, we would be; // putting an undef into operand 1 of div/rem/shift. This is either UB or; // poison. We do not have to guard against UB when *constants* are op1; // because safe constants guarantee that we do not overflow sdiv/srem (and; // there's no danger for other opcodes).; // TODO: To allow this case, create a new shuffle mask with no undefs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:195,Availability,mask,mask,195,"// Note: In general, we do not create new shuffles in InstCombine because we; // do not know if a target can lower an arbitrary shuffle optimally. In this; // case, the shuffle uses the existing mask, so there is no additional risk.; // Select the variable vectors first, then perform the binop:; // shuffle (op X, C0), (op Y, C1), M --> op (shuffle X, Y, M), C'; // shuffle (op C0, X), (op C1, Y), M --> op C', (shuffle X, Y, M)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:248,Modifiability,variab,variable,248,"// Note: In general, we do not create new shuffles in InstCombine because we; // do not know if a target can lower an arbitrary shuffle optimally. In this; // case, the shuffle uses the existing mask, so there is no additional risk.; // Select the variable vectors first, then perform the binop:; // shuffle (op X, C0), (op Y, C1), M --> op (shuffle X, Y, M), C'; // shuffle (op C0, X), (op C1, Y), M --> op C', (shuffle X, Y, M)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:277,Performance,perform,perform,277,"// Note: In general, we do not create new shuffles in InstCombine because we; // do not know if a target can lower an arbitrary shuffle optimally. In this; // case, the shuffle uses the existing mask, so there is no additional risk.; // Select the variable vectors first, then perform the binop:; // shuffle (op X, C0), (op Y, C1), M --> op (shuffle X, Y, M), C'; // shuffle (op C0, X), (op C1, Y), M --> op C', (shuffle X, Y, M)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:227,Safety,risk,risk,227,"// Note: In general, we do not create new shuffles in InstCombine because we; // do not know if a target can lower an arbitrary shuffle optimally. In this; // case, the shuffle uses the existing mask, so there is no additional risk.; // Select the variable vectors first, then perform the binop:; // shuffle (op X, C0), (op Y, C1), M --> op (shuffle X, Y, M), C'; // shuffle (op C0, X), (op C1, Y), M --> op C', (shuffle X, Y, M)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:181,Availability,mask,mask,181,"// Flags are intersected from the 2 source binops. But there are 2 exceptions:; // 1. If we changed an opcode, poison conditions might have changed.; // 2. If the shuffle had undef mask elements, the new binop might have undefs; // where the original code did not. But if we already made a safe constant,; // then there's no danger.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:290,Safety,safe,safe,290,"// Flags are intersected from the 2 source binops. But there are 2 exceptions:; // 1. If we changed an opcode, poison conditions might have changed.; // 2. If the shuffle had undef mask elements, the new binop might have undefs; // where the original code did not. But if we already made a safe constant,; // then there's no danger.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:24,Availability,mask,mask,24,"// Last, check that the mask chooses the correct low bits for each narrow; // element in the result.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:48,Modifiability,extend,extended,48,// We need a narrow condition value. It must be extended with undef elements; // and have the same number of elements as this shuffle.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:61,Availability,Mask,Mask,61,"// Match 1-input (unary) shuffle.; // shuffle (fneg/fabs X), Mask --> fneg/fabs (shuffle X, Mask)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:92,Availability,Mask,Mask,92,"// Match 1-input (unary) shuffle.; // shuffle (fneg/fabs X), Mask --> fneg/fabs (shuffle X, Mask)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:38,Availability,Mask,Mask,38,"// shuf (fneg/fabs X), (fneg/fabs Y), Mask --> fneg/fabs (shuf X, Y, Mask)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:69,Availability,Mask,Mask,69,"// shuf (fneg/fabs X), (fneg/fabs Y), Mask --> fneg/fabs (shuf X, Y, Mask)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:31,Availability,Mask,Mask,31,"// shuffle (cast X), (cast Y), Mask --> cast (shuffle X, Y, Mask)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:60,Availability,Mask,Mask,60,"// shuffle (cast X), (cast Y), Mask --> cast (shuffle X, Y, Mask)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:71,Availability,mask,mask,71,// Try to combine 2 shuffles into 1 shuffle by concatenating a shuffle mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:97,Availability,mask,mask,97,"// We are extracting a subvector from a shuffle. Remove excess elements from; // the 1st shuffle mask to eliminate the extract.; //; // This transform is conservatively limited to identity extracts because we do; // not allow arbitrary shuffle mask creation as a target-independent transform; // (because we can't guarantee that will lower efficiently).; //; // If the extracting shuffle has an undef mask element, it transfers to the; // new shuffle mask. Otherwise, copy the original mask element. Example:; // shuf (shuf X, Y, <C0, C1, C2, undef, C4>), undef, <0, undef, 2, 3> -->; // shuf X, Y, <C0, undef, C2, undef>",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:244,Availability,mask,mask,244,"// We are extracting a subvector from a shuffle. Remove excess elements from; // the 1st shuffle mask to eliminate the extract.; //; // This transform is conservatively limited to identity extracts because we do; // not allow arbitrary shuffle mask creation as a target-independent transform; // (because we can't guarantee that will lower efficiently).; //; // If the extracting shuffle has an undef mask element, it transfers to the; // new shuffle mask. Otherwise, copy the original mask element. Example:; // shuf (shuf X, Y, <C0, C1, C2, undef, C4>), undef, <0, undef, 2, 3> -->; // shuf X, Y, <C0, undef, C2, undef>",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:401,Availability,mask,mask,401,"// We are extracting a subvector from a shuffle. Remove excess elements from; // the 1st shuffle mask to eliminate the extract.; //; // This transform is conservatively limited to identity extracts because we do; // not allow arbitrary shuffle mask creation as a target-independent transform; // (because we can't guarantee that will lower efficiently).; //; // If the extracting shuffle has an undef mask element, it transfers to the; // new shuffle mask. Otherwise, copy the original mask element. Example:; // shuf (shuf X, Y, <C0, C1, C2, undef, C4>), undef, <0, undef, 2, 3> -->; // shuf X, Y, <C0, undef, C2, undef>",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:451,Availability,mask,mask,451,"// We are extracting a subvector from a shuffle. Remove excess elements from; // the 1st shuffle mask to eliminate the extract.; //; // This transform is conservatively limited to identity extracts because we do; // not allow arbitrary shuffle mask creation as a target-independent transform; // (because we can't guarantee that will lower efficiently).; //; // If the extracting shuffle has an undef mask element, it transfers to the; // new shuffle mask. Otherwise, copy the original mask element. Example:; // shuf (shuf X, Y, <C0, C1, C2, undef, C4>), undef, <0, undef, 2, 3> -->; // shuf X, Y, <C0, undef, C2, undef>",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:486,Availability,mask,mask,486,"// We are extracting a subvector from a shuffle. Remove excess elements from; // the 1st shuffle mask to eliminate the extract.; //; // This transform is conservatively limited to identity extracts because we do; // not allow arbitrary shuffle mask creation as a target-independent transform; // (because we can't guarantee that will lower efficiently).; //; // If the extracting shuffle has an undef mask element, it transfers to the; // new shuffle mask. Otherwise, copy the original mask element. Example:; // shuf (shuf X, Y, <C0, C1, C2, undef, C4>), undef, <0, undef, 2, 3> -->; // shuf X, Y, <C0, undef, C2, undef>",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:340,Energy Efficiency,efficient,efficiently,340,"// We are extracting a subvector from a shuffle. Remove excess elements from; // the 1st shuffle mask to eliminate the extract.; //; // This transform is conservatively limited to identity extracts because we do; // not allow arbitrary shuffle mask creation as a target-independent transform; // (because we can't guarantee that will lower efficiently).; //; // If the extracting shuffle has an undef mask element, it transfers to the; // new shuffle mask. Otherwise, copy the original mask element. Example:; // shuf (shuf X, Y, <C0, C1, C2, undef, C4>), undef, <0, undef, 2, 3> -->; // shuf X, Y, <C0, undef, C2, undef>",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:41,Usability,Simpl,SimplifyDemandedVectorElts,41,"// This is a specialization of a fold in SimplifyDemandedVectorElts. We may; // not be able to handle it there if the insertelement has >1 use.; // If the shuffle has an insertelement operand but does not choose the; // inserted scalar element from that value, then we can replace that shuffle; // operand with the source vector of the insertelement.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:32,Availability,Mask,Mask,32,"// shuf (inselt X, ?, IdxC), ?, Mask --> shuf X, ?, Mask",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:52,Availability,Mask,Mask,52,"// shuf (inselt X, ?, IdxC), ?, Mask --> shuf X, ?, Mask",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:81,Security,access,accesses,81,// Offset the index constant by the vector width because we are checking for; // accesses to the 2nd vector input of the shuffle.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:32,Availability,Mask,Mask,32,"// shuf ?, (inselt X, ?, IdxC), Mask --> shuf ?, X, Mask",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:52,Availability,Mask,Mask,52,"// shuf ?, (inselt X, ?, IdxC), Mask --> shuf ?, X, Mask",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:43,Availability,Mask,Mask,43,"// shuffle (insert ?, Scalar, IndexC), V1, Mask --> insert V1, Scalar, IndexC'",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:20,Availability,mask,mask,20,// Test the shuffle mask to see if it splices the inserted scalar into the; // operand 1 vector of the shuffle.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:3,Testability,Test,Test,3,// Test the shuffle mask to see if it splices the inserted scalar into the; // operand 1 vector of the shuffle.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:16,Availability,mask,mask,16,// Ignore undef mask elements.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:12,Deployability,update,updated,12,// Index is updated to the potentially translated insertion lane.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:30,Energy Efficiency,power,power-of-,30,"// We limit this transform to power-of-2 types because we expect that the; // backend can convert the simplified IR patterns to identical nodes as the; // original IR.; // TODO: If we can verify the same behavior for arbitrary types, the; // power-of-2 checks can be removed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:242,Energy Efficiency,power,power-of-,242,"// We limit this transform to power-of-2 types because we expect that the; // backend can convert the simplified IR patterns to identical nodes as the; // original IR.; // TODO: If we can verify the same behavior for arbitrary types, the; // power-of-2 checks can be removed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:102,Usability,simpl,simplified,102,"// We limit this transform to power-of-2 types because we expect that the; // backend can convert the simplified IR patterns to identical nodes as the; // original IR.; // TODO: If we can verify the same behavior for arbitrary types, the; // power-of-2 checks can be removed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:125,Availability,mask,mask,125,"// This is a shuffle of 2 widening shuffles. We can shuffle the narrow source; // operands directly by adjusting the shuffle mask to account for the narrower; // types:; // shuf (widen X), (widen Y), Mask --> shuf X, Y, Mask'",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:200,Availability,Mask,Mask,200,"// This is a shuffle of 2 widening shuffles. We can shuffle the narrow source; // operands directly by adjusting the shuffle mask to account for the narrower; // types:; // shuf (widen X), (widen Y), Mask --> shuf X, Y, Mask'",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:220,Availability,Mask,Mask,220,"// This is a shuffle of 2 widening shuffles. We can shuffle the narrow source; // operands directly by adjusting the shuffle mask to account for the narrower; // types:; // shuf (widen X), (widen Y), Mask --> shuf X, Y, Mask'",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:59,Availability,mask,mask,59,"// If this shuffle is choosing from the 1st narrow op, the mask element is; // the same. If this shuffle is choosing from the 2nd narrow op, the mask; // element is offset down to adjust for the narrow vector widths.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:145,Availability,mask,mask,145,"// If this shuffle is choosing from the 1st narrow op, the mask element is; // the same. If this shuffle is choosing from the 2nd narrow op, the mask; // element is offset down to adjust for the narrow vector widths.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:172,Availability,down,down,172,"// If this shuffle is choosing from the 1st narrow op, the mask element is; // the same. If this shuffle is choosing from the 2nd narrow op, the mask; // element is offset down to adjust for the narrow vector widths.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:142,Usability,simpl,simplified,142,"// Splatting the first element of the result of a BinOp, where any of the; // BinOp's operands are the result of a first element splat can be simplified to; // splatting the first element of the result of the BinOp",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:96,Performance,scalab,scalable,96,// Canonicalize splat shuffle to use poison RHS. Handle this explicitly in; // order to support scalable vectors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:37,Availability,Mask,Mask,37,"// shuffle (bitcast X), (bitcast Y), Mask --> bitcast (shuffle X, Y, Mask); //; // if X and Y are of the same (vector) type, and the element size is not; // changed by the bitcasts, we can distribute the bitcasts through the; // shuffle, hopefully reducing the number of instructions. We make sure that; // at least one bitcast only has one use, so we don't *increase* the number of; // instructions here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:69,Availability,Mask,Mask,69,"// shuffle (bitcast X), (bitcast Y), Mask --> bitcast (shuffle X, Y, Mask); //; // if X and Y are of the same (vector) type, and the element size is not; // changed by the bitcasts, we can distribute the bitcasts through the; // shuffle, hopefully reducing the number of instructions. We make sure that; // at least one bitcast only has one use, so we don't *increase* the number of; // instructions here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:59,Availability,mask,mask,59,"// Peek through a bitcasted shuffle operand by scaling the mask. If the; // simulated shuffle can simplify, then this shuffle is unnecessary:; // shuf (bitcast X), undef, Mask --> bitcast X'; // TODO: This could be extended to allow length-changing shuffles.; // The transform might also be obsoleted if we allowed canonicalization; // of bitcasted shuffles.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:171,Availability,Mask,Mask,171,"// Peek through a bitcasted shuffle operand by scaling the mask. If the; // simulated shuffle can simplify, then this shuffle is unnecessary:; // shuf (bitcast X), undef, Mask --> bitcast X'; // TODO: This could be extended to allow length-changing shuffles.; // The transform might also be obsoleted if we allowed canonicalization; // of bitcasted shuffles.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:215,Modifiability,extend,extended,215,"// Peek through a bitcasted shuffle operand by scaling the mask. If the; // simulated shuffle can simplify, then this shuffle is unnecessary:; // shuf (bitcast X), undef, Mask --> bitcast X'; // TODO: This could be extended to allow length-changing shuffles.; // The transform might also be obsoleted if we allowed canonicalization; // of bitcasted shuffles.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:98,Usability,simpl,simplify,98,"// Peek through a bitcasted shuffle operand by scaling the mask. If the; // simulated shuffle can simplify, then this shuffle is unnecessary:; // shuf (bitcast X), undef, Mask --> bitcast X'; // TODO: This could be extended to allow length-changing shuffles.; // The transform might also be obsoleted if we allowed canonicalization; // of bitcasted shuffles.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:26,Availability,mask,mask,26,// Try to create a scaled mask constant.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:33,Usability,simpl,simplifies,33,"// If the shuffled source vector simplifies, cast that value to this; // shuffle's type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:17,Availability,mask,mask,17,"// shuffle x, x, mask --> shuffle x, undef, mask'",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:44,Availability,mask,mask,44,"// shuffle x, x, mask --> shuffle x, undef, mask'",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:21,Availability,mask,mask,21,"// shuffle undef, x, mask --> shuffle x, undef, mask'",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:48,Availability,mask,mask,48,"// shuffle undef, x, mask --> shuffle x, undef, mask'",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:107,Usability,Simpl,SimplifyDemandedVectorElts,107,"// These transforms have the potential to lose undef knowledge, so they are; // intentionally placed after SimplifyDemandedVectorElts().",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:216,Availability,mask,mask,216,"// If the LHS is a shufflevector itself, see if we can combine it with this; // one without producing an unusual shuffle.; // Cases that might be simplified:; // 1.; // x1=shuffle(v1,v2,mask1); // x=shuffle(x1,undef,mask); // ==>; // x=shuffle(v1,undef,newMask); // newMask[i] = (mask[i] < x1.size()) ? mask1[mask[i]] : -1; // 2.; // x1=shuffle(v1,undef,mask1); // x=shuffle(x1,x2,mask); // where v1.size() == mask1.size(); // ==>; // x=shuffle(v1,x2,newMask); // newMask[i] = (mask[i] < x1.size()) ? mask1[mask[i]] : mask[i]; // 3.; // x2=shuffle(v2,undef,mask2); // x=shuffle(x1,x2,mask); // where v2.size() == mask2.size(); // ==>; // x=shuffle(x1,v2,newMask); // newMask[i] = (mask[i] < x1.size()); // ? mask[i] : mask2[mask[i]-x1.size()]+x1.size(); // 4.; // x1=shuffle(v1,undef,mask1); // x2=shuffle(v2,undef,mask2); // x=shuffle(x1,x2,mask); // where v1.size() == v2.size(); // ==>; // x=shuffle(v1,v2,newMask); // newMask[i] = (mask[i] < x1.size()); // ? mask1[mask[i]] : mask2[mask[i]-x1.size()]+v1.size(); //; // Here we are really conservative:; // we are absolutely afraid of producing a shuffle mask not in the input; // program, because the code gen may not be smart enough to turn a merged; // shuffle into two specific shuffles: it may produce worse code. As such,; // we only merge two shuffles if the result is either a splat or one of the; // input shuffle masks. In this case, merging the shuffles just removes; // one instruction, which we know is safe. This is good for things like; // turning: (splat(splat)) -> splat, or; // merge(V[0..n], V[n+1..2n]) -> V[0..2n]",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:280,Availability,mask,mask,280,"// If the LHS is a shufflevector itself, see if we can combine it with this; // one without producing an unusual shuffle.; // Cases that might be simplified:; // 1.; // x1=shuffle(v1,v2,mask1); // x=shuffle(x1,undef,mask); // ==>; // x=shuffle(v1,undef,newMask); // newMask[i] = (mask[i] < x1.size()) ? mask1[mask[i]] : -1; // 2.; // x1=shuffle(v1,undef,mask1); // x=shuffle(x1,x2,mask); // where v1.size() == mask1.size(); // ==>; // x=shuffle(v1,x2,newMask); // newMask[i] = (mask[i] < x1.size()) ? mask1[mask[i]] : mask[i]; // 3.; // x2=shuffle(v2,undef,mask2); // x=shuffle(x1,x2,mask); // where v2.size() == mask2.size(); // ==>; // x=shuffle(x1,v2,newMask); // newMask[i] = (mask[i] < x1.size()); // ? mask[i] : mask2[mask[i]-x1.size()]+x1.size(); // 4.; // x1=shuffle(v1,undef,mask1); // x2=shuffle(v2,undef,mask2); // x=shuffle(x1,x2,mask); // where v1.size() == v2.size(); // ==>; // x=shuffle(v1,v2,newMask); // newMask[i] = (mask[i] < x1.size()); // ? mask1[mask[i]] : mask2[mask[i]-x1.size()]+v1.size(); //; // Here we are really conservative:; // we are absolutely afraid of producing a shuffle mask not in the input; // program, because the code gen may not be smart enough to turn a merged; // shuffle into two specific shuffles: it may produce worse code. As such,; // we only merge two shuffles if the result is either a splat or one of the; // input shuffle masks. In this case, merging the shuffles just removes; // one instruction, which we know is safe. This is good for things like; // turning: (splat(splat)) -> splat, or; // merge(V[0..n], V[n+1..2n]) -> V[0..2n]",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:309,Availability,mask,mask,309,"// If the LHS is a shufflevector itself, see if we can combine it with this; // one without producing an unusual shuffle.; // Cases that might be simplified:; // 1.; // x1=shuffle(v1,v2,mask1); // x=shuffle(x1,undef,mask); // ==>; // x=shuffle(v1,undef,newMask); // newMask[i] = (mask[i] < x1.size()) ? mask1[mask[i]] : -1; // 2.; // x1=shuffle(v1,undef,mask1); // x=shuffle(x1,x2,mask); // where v1.size() == mask1.size(); // ==>; // x=shuffle(v1,x2,newMask); // newMask[i] = (mask[i] < x1.size()) ? mask1[mask[i]] : mask[i]; // 3.; // x2=shuffle(v2,undef,mask2); // x=shuffle(x1,x2,mask); // where v2.size() == mask2.size(); // ==>; // x=shuffle(x1,v2,newMask); // newMask[i] = (mask[i] < x1.size()); // ? mask[i] : mask2[mask[i]-x1.size()]+x1.size(); // 4.; // x1=shuffle(v1,undef,mask1); // x2=shuffle(v2,undef,mask2); // x=shuffle(x1,x2,mask); // where v1.size() == v2.size(); // ==>; // x=shuffle(v1,v2,newMask); // newMask[i] = (mask[i] < x1.size()); // ? mask1[mask[i]] : mask2[mask[i]-x1.size()]+v1.size(); //; // Here we are really conservative:; // we are absolutely afraid of producing a shuffle mask not in the input; // program, because the code gen may not be smart enough to turn a merged; // shuffle into two specific shuffles: it may produce worse code. As such,; // we only merge two shuffles if the result is either a splat or one of the; // input shuffle masks. In this case, merging the shuffles just removes; // one instruction, which we know is safe. This is good for things like; // turning: (splat(splat)) -> splat, or; // merge(V[0..n], V[n+1..2n]) -> V[0..2n]",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:381,Availability,mask,mask,381,"// If the LHS is a shufflevector itself, see if we can combine it with this; // one without producing an unusual shuffle.; // Cases that might be simplified:; // 1.; // x1=shuffle(v1,v2,mask1); // x=shuffle(x1,undef,mask); // ==>; // x=shuffle(v1,undef,newMask); // newMask[i] = (mask[i] < x1.size()) ? mask1[mask[i]] : -1; // 2.; // x1=shuffle(v1,undef,mask1); // x=shuffle(x1,x2,mask); // where v1.size() == mask1.size(); // ==>; // x=shuffle(v1,x2,newMask); // newMask[i] = (mask[i] < x1.size()) ? mask1[mask[i]] : mask[i]; // 3.; // x2=shuffle(v2,undef,mask2); // x=shuffle(x1,x2,mask); // where v2.size() == mask2.size(); // ==>; // x=shuffle(x1,v2,newMask); // newMask[i] = (mask[i] < x1.size()); // ? mask[i] : mask2[mask[i]-x1.size()]+x1.size(); // 4.; // x1=shuffle(v1,undef,mask1); // x2=shuffle(v2,undef,mask2); // x=shuffle(x1,x2,mask); // where v1.size() == v2.size(); // ==>; // x=shuffle(v1,v2,newMask); // newMask[i] = (mask[i] < x1.size()); // ? mask1[mask[i]] : mask2[mask[i]-x1.size()]+v1.size(); //; // Here we are really conservative:; // we are absolutely afraid of producing a shuffle mask not in the input; // program, because the code gen may not be smart enough to turn a merged; // shuffle into two specific shuffles: it may produce worse code. As such,; // we only merge two shuffles if the result is either a splat or one of the; // input shuffle masks. In this case, merging the shuffles just removes; // one instruction, which we know is safe. This is good for things like; // turning: (splat(splat)) -> splat, or; // merge(V[0..n], V[n+1..2n]) -> V[0..2n]",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:478,Availability,mask,mask,478,"// If the LHS is a shufflevector itself, see if we can combine it with this; // one without producing an unusual shuffle.; // Cases that might be simplified:; // 1.; // x1=shuffle(v1,v2,mask1); // x=shuffle(x1,undef,mask); // ==>; // x=shuffle(v1,undef,newMask); // newMask[i] = (mask[i] < x1.size()) ? mask1[mask[i]] : -1; // 2.; // x1=shuffle(v1,undef,mask1); // x=shuffle(x1,x2,mask); // where v1.size() == mask1.size(); // ==>; // x=shuffle(v1,x2,newMask); // newMask[i] = (mask[i] < x1.size()) ? mask1[mask[i]] : mask[i]; // 3.; // x2=shuffle(v2,undef,mask2); // x=shuffle(x1,x2,mask); // where v2.size() == mask2.size(); // ==>; // x=shuffle(x1,v2,newMask); // newMask[i] = (mask[i] < x1.size()); // ? mask[i] : mask2[mask[i]-x1.size()]+x1.size(); // 4.; // x1=shuffle(v1,undef,mask1); // x2=shuffle(v2,undef,mask2); // x=shuffle(x1,x2,mask); // where v1.size() == v2.size(); // ==>; // x=shuffle(v1,v2,newMask); // newMask[i] = (mask[i] < x1.size()); // ? mask1[mask[i]] : mask2[mask[i]-x1.size()]+v1.size(); //; // Here we are really conservative:; // we are absolutely afraid of producing a shuffle mask not in the input; // program, because the code gen may not be smart enough to turn a merged; // shuffle into two specific shuffles: it may produce worse code. As such,; // we only merge two shuffles if the result is either a splat or one of the; // input shuffle masks. In this case, merging the shuffles just removes; // one instruction, which we know is safe. This is good for things like; // turning: (splat(splat)) -> splat, or; // merge(V[0..n], V[n+1..2n]) -> V[0..2n]",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:507,Availability,mask,mask,507,"// If the LHS is a shufflevector itself, see if we can combine it with this; // one without producing an unusual shuffle.; // Cases that might be simplified:; // 1.; // x1=shuffle(v1,v2,mask1); // x=shuffle(x1,undef,mask); // ==>; // x=shuffle(v1,undef,newMask); // newMask[i] = (mask[i] < x1.size()) ? mask1[mask[i]] : -1; // 2.; // x1=shuffle(v1,undef,mask1); // x=shuffle(x1,x2,mask); // where v1.size() == mask1.size(); // ==>; // x=shuffle(v1,x2,newMask); // newMask[i] = (mask[i] < x1.size()) ? mask1[mask[i]] : mask[i]; // 3.; // x2=shuffle(v2,undef,mask2); // x=shuffle(x1,x2,mask); // where v2.size() == mask2.size(); // ==>; // x=shuffle(x1,v2,newMask); // newMask[i] = (mask[i] < x1.size()); // ? mask[i] : mask2[mask[i]-x1.size()]+x1.size(); // 4.; // x1=shuffle(v1,undef,mask1); // x2=shuffle(v2,undef,mask2); // x=shuffle(x1,x2,mask); // where v1.size() == v2.size(); // ==>; // x=shuffle(v1,v2,newMask); // newMask[i] = (mask[i] < x1.size()); // ? mask1[mask[i]] : mask2[mask[i]-x1.size()]+v1.size(); //; // Here we are really conservative:; // we are absolutely afraid of producing a shuffle mask not in the input; // program, because the code gen may not be smart enough to turn a merged; // shuffle into two specific shuffles: it may produce worse code. As such,; // we only merge two shuffles if the result is either a splat or one of the; // input shuffle masks. In this case, merging the shuffles just removes; // one instruction, which we know is safe. This is good for things like; // turning: (splat(splat)) -> splat, or; // merge(V[0..n], V[n+1..2n]) -> V[0..2n]",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:518,Availability,mask,mask,518,"// If the LHS is a shufflevector itself, see if we can combine it with this; // one without producing an unusual shuffle.; // Cases that might be simplified:; // 1.; // x1=shuffle(v1,v2,mask1); // x=shuffle(x1,undef,mask); // ==>; // x=shuffle(v1,undef,newMask); // newMask[i] = (mask[i] < x1.size()) ? mask1[mask[i]] : -1; // 2.; // x1=shuffle(v1,undef,mask1); // x=shuffle(x1,x2,mask); // where v1.size() == mask1.size(); // ==>; // x=shuffle(v1,x2,newMask); // newMask[i] = (mask[i] < x1.size()) ? mask1[mask[i]] : mask[i]; // 3.; // x2=shuffle(v2,undef,mask2); // x=shuffle(x1,x2,mask); // where v2.size() == mask2.size(); // ==>; // x=shuffle(x1,v2,newMask); // newMask[i] = (mask[i] < x1.size()); // ? mask[i] : mask2[mask[i]-x1.size()]+x1.size(); // 4.; // x1=shuffle(v1,undef,mask1); // x2=shuffle(v2,undef,mask2); // x=shuffle(x1,x2,mask); // where v1.size() == v2.size(); // ==>; // x=shuffle(v1,v2,newMask); // newMask[i] = (mask[i] < x1.size()); // ? mask1[mask[i]] : mask2[mask[i]-x1.size()]+v1.size(); //; // Here we are really conservative:; // we are absolutely afraid of producing a shuffle mask not in the input; // program, because the code gen may not be smart enough to turn a merged; // shuffle into two specific shuffles: it may produce worse code. As such,; // we only merge two shuffles if the result is either a splat or one of the; // input shuffle masks. In this case, merging the shuffles just removes; // one instruction, which we know is safe. This is good for things like; // turning: (splat(splat)) -> splat, or; // merge(V[0..n], V[n+1..2n]) -> V[0..2n]",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:584,Availability,mask,mask,584,"// If the LHS is a shufflevector itself, see if we can combine it with this; // one without producing an unusual shuffle.; // Cases that might be simplified:; // 1.; // x1=shuffle(v1,v2,mask1); // x=shuffle(x1,undef,mask); // ==>; // x=shuffle(v1,undef,newMask); // newMask[i] = (mask[i] < x1.size()) ? mask1[mask[i]] : -1; // 2.; // x1=shuffle(v1,undef,mask1); // x=shuffle(x1,x2,mask); // where v1.size() == mask1.size(); // ==>; // x=shuffle(v1,x2,newMask); // newMask[i] = (mask[i] < x1.size()) ? mask1[mask[i]] : mask[i]; // 3.; // x2=shuffle(v2,undef,mask2); // x=shuffle(x1,x2,mask); // where v2.size() == mask2.size(); // ==>; // x=shuffle(x1,v2,newMask); // newMask[i] = (mask[i] < x1.size()); // ? mask[i] : mask2[mask[i]-x1.size()]+x1.size(); // 4.; // x1=shuffle(v1,undef,mask1); // x2=shuffle(v2,undef,mask2); // x=shuffle(x1,x2,mask); // where v1.size() == v2.size(); // ==>; // x=shuffle(v1,v2,newMask); // newMask[i] = (mask[i] < x1.size()); // ? mask1[mask[i]] : mask2[mask[i]-x1.size()]+v1.size(); //; // Here we are really conservative:; // we are absolutely afraid of producing a shuffle mask not in the input; // program, because the code gen may not be smart enough to turn a merged; // shuffle into two specific shuffles: it may produce worse code. As such,; // we only merge two shuffles if the result is either a splat or one of the; // input shuffle masks. In this case, merging the shuffles just removes; // one instruction, which we know is safe. This is good for things like; // turning: (splat(splat)) -> splat, or; // merge(V[0..n], V[n+1..2n]) -> V[0..2n]",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:681,Availability,mask,mask,681,"// If the LHS is a shufflevector itself, see if we can combine it with this; // one without producing an unusual shuffle.; // Cases that might be simplified:; // 1.; // x1=shuffle(v1,v2,mask1); // x=shuffle(x1,undef,mask); // ==>; // x=shuffle(v1,undef,newMask); // newMask[i] = (mask[i] < x1.size()) ? mask1[mask[i]] : -1; // 2.; // x1=shuffle(v1,undef,mask1); // x=shuffle(x1,x2,mask); // where v1.size() == mask1.size(); // ==>; // x=shuffle(v1,x2,newMask); // newMask[i] = (mask[i] < x1.size()) ? mask1[mask[i]] : mask[i]; // 3.; // x2=shuffle(v2,undef,mask2); // x=shuffle(x1,x2,mask); // where v2.size() == mask2.size(); // ==>; // x=shuffle(x1,v2,newMask); // newMask[i] = (mask[i] < x1.size()); // ? mask[i] : mask2[mask[i]-x1.size()]+x1.size(); // 4.; // x1=shuffle(v1,undef,mask1); // x2=shuffle(v2,undef,mask2); // x=shuffle(x1,x2,mask); // where v1.size() == v2.size(); // ==>; // x=shuffle(v1,v2,newMask); // newMask[i] = (mask[i] < x1.size()); // ? mask1[mask[i]] : mask2[mask[i]-x1.size()]+v1.size(); //; // Here we are really conservative:; // we are absolutely afraid of producing a shuffle mask not in the input; // program, because the code gen may not be smart enough to turn a merged; // shuffle into two specific shuffles: it may produce worse code. As such,; // we only merge two shuffles if the result is either a splat or one of the; // input shuffle masks. In this case, merging the shuffles just removes; // one instruction, which we know is safe. This is good for things like; // turning: (splat(splat)) -> splat, or; // merge(V[0..n], V[n+1..2n]) -> V[0..2n]",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:708,Availability,mask,mask,708,"// If the LHS is a shufflevector itself, see if we can combine it with this; // one without producing an unusual shuffle.; // Cases that might be simplified:; // 1.; // x1=shuffle(v1,v2,mask1); // x=shuffle(x1,undef,mask); // ==>; // x=shuffle(v1,undef,newMask); // newMask[i] = (mask[i] < x1.size()) ? mask1[mask[i]] : -1; // 2.; // x1=shuffle(v1,undef,mask1); // x=shuffle(x1,x2,mask); // where v1.size() == mask1.size(); // ==>; // x=shuffle(v1,x2,newMask); // newMask[i] = (mask[i] < x1.size()) ? mask1[mask[i]] : mask[i]; // 3.; // x2=shuffle(v2,undef,mask2); // x=shuffle(x1,x2,mask); // where v2.size() == mask2.size(); // ==>; // x=shuffle(x1,v2,newMask); // newMask[i] = (mask[i] < x1.size()); // ? mask[i] : mask2[mask[i]-x1.size()]+x1.size(); // 4.; // x1=shuffle(v1,undef,mask1); // x2=shuffle(v2,undef,mask2); // x=shuffle(x1,x2,mask); // where v1.size() == v2.size(); // ==>; // x=shuffle(v1,v2,newMask); // newMask[i] = (mask[i] < x1.size()); // ? mask1[mask[i]] : mask2[mask[i]-x1.size()]+v1.size(); //; // Here we are really conservative:; // we are absolutely afraid of producing a shuffle mask not in the input; // program, because the code gen may not be smart enough to turn a merged; // shuffle into two specific shuffles: it may produce worse code. As such,; // we only merge two shuffles if the result is either a splat or one of the; // input shuffle masks. In this case, merging the shuffles just removes; // one instruction, which we know is safe. This is good for things like; // turning: (splat(splat)) -> splat, or; // merge(V[0..n], V[n+1..2n]) -> V[0..2n]",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:724,Availability,mask,mask,724,"// If the LHS is a shufflevector itself, see if we can combine it with this; // one without producing an unusual shuffle.; // Cases that might be simplified:; // 1.; // x1=shuffle(v1,v2,mask1); // x=shuffle(x1,undef,mask); // ==>; // x=shuffle(v1,undef,newMask); // newMask[i] = (mask[i] < x1.size()) ? mask1[mask[i]] : -1; // 2.; // x1=shuffle(v1,undef,mask1); // x=shuffle(x1,x2,mask); // where v1.size() == mask1.size(); // ==>; // x=shuffle(v1,x2,newMask); // newMask[i] = (mask[i] < x1.size()) ? mask1[mask[i]] : mask[i]; // 3.; // x2=shuffle(v2,undef,mask2); // x=shuffle(x1,x2,mask); // where v2.size() == mask2.size(); // ==>; // x=shuffle(x1,v2,newMask); // newMask[i] = (mask[i] < x1.size()); // ? mask[i] : mask2[mask[i]-x1.size()]+x1.size(); // 4.; // x1=shuffle(v1,undef,mask1); // x2=shuffle(v2,undef,mask2); // x=shuffle(x1,x2,mask); // where v1.size() == v2.size(); // ==>; // x=shuffle(v1,v2,newMask); // newMask[i] = (mask[i] < x1.size()); // ? mask1[mask[i]] : mask2[mask[i]-x1.size()]+v1.size(); //; // Here we are really conservative:; // we are absolutely afraid of producing a shuffle mask not in the input; // program, because the code gen may not be smart enough to turn a merged; // shuffle into two specific shuffles: it may produce worse code. As such,; // we only merge two shuffles if the result is either a splat or one of the; // input shuffle masks. In this case, merging the shuffles just removes; // one instruction, which we know is safe. This is good for things like; // turning: (splat(splat)) -> splat, or; // merge(V[0..n], V[n+1..2n]) -> V[0..2n]",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:842,Availability,mask,mask,842,"// If the LHS is a shufflevector itself, see if we can combine it with this; // one without producing an unusual shuffle.; // Cases that might be simplified:; // 1.; // x1=shuffle(v1,v2,mask1); // x=shuffle(x1,undef,mask); // ==>; // x=shuffle(v1,undef,newMask); // newMask[i] = (mask[i] < x1.size()) ? mask1[mask[i]] : -1; // 2.; // x1=shuffle(v1,undef,mask1); // x=shuffle(x1,x2,mask); // where v1.size() == mask1.size(); // ==>; // x=shuffle(v1,x2,newMask); // newMask[i] = (mask[i] < x1.size()) ? mask1[mask[i]] : mask[i]; // 3.; // x2=shuffle(v2,undef,mask2); // x=shuffle(x1,x2,mask); // where v2.size() == mask2.size(); // ==>; // x=shuffle(x1,v2,newMask); // newMask[i] = (mask[i] < x1.size()); // ? mask[i] : mask2[mask[i]-x1.size()]+x1.size(); // 4.; // x1=shuffle(v1,undef,mask1); // x2=shuffle(v2,undef,mask2); // x=shuffle(x1,x2,mask); // where v1.size() == v2.size(); // ==>; // x=shuffle(v1,v2,newMask); // newMask[i] = (mask[i] < x1.size()); // ? mask1[mask[i]] : mask2[mask[i]-x1.size()]+v1.size(); //; // Here we are really conservative:; // we are absolutely afraid of producing a shuffle mask not in the input; // program, because the code gen may not be smart enough to turn a merged; // shuffle into two specific shuffles: it may produce worse code. As such,; // we only merge two shuffles if the result is either a splat or one of the; // input shuffle masks. In this case, merging the shuffles just removes; // one instruction, which we know is safe. This is good for things like; // turning: (splat(splat)) -> splat, or; // merge(V[0..n], V[n+1..2n]) -> V[0..2n]",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:936,Availability,mask,mask,936,"// If the LHS is a shufflevector itself, see if we can combine it with this; // one without producing an unusual shuffle.; // Cases that might be simplified:; // 1.; // x1=shuffle(v1,v2,mask1); // x=shuffle(x1,undef,mask); // ==>; // x=shuffle(v1,undef,newMask); // newMask[i] = (mask[i] < x1.size()) ? mask1[mask[i]] : -1; // 2.; // x1=shuffle(v1,undef,mask1); // x=shuffle(x1,x2,mask); // where v1.size() == mask1.size(); // ==>; // x=shuffle(v1,x2,newMask); // newMask[i] = (mask[i] < x1.size()) ? mask1[mask[i]] : mask[i]; // 3.; // x2=shuffle(v2,undef,mask2); // x=shuffle(x1,x2,mask); // where v2.size() == mask2.size(); // ==>; // x=shuffle(x1,v2,newMask); // newMask[i] = (mask[i] < x1.size()); // ? mask[i] : mask2[mask[i]-x1.size()]+x1.size(); // 4.; // x1=shuffle(v1,undef,mask1); // x2=shuffle(v2,undef,mask2); // x=shuffle(x1,x2,mask); // where v1.size() == v2.size(); // ==>; // x=shuffle(v1,v2,newMask); // newMask[i] = (mask[i] < x1.size()); // ? mask1[mask[i]] : mask2[mask[i]-x1.size()]+v1.size(); //; // Here we are really conservative:; // we are absolutely afraid of producing a shuffle mask not in the input; // program, because the code gen may not be smart enough to turn a merged; // shuffle into two specific shuffles: it may produce worse code. As such,; // we only merge two shuffles if the result is either a splat or one of the; // input shuffle masks. In this case, merging the shuffles just removes; // one instruction, which we know is safe. This is good for things like; // turning: (splat(splat)) -> splat, or; // merge(V[0..n], V[n+1..2n]) -> V[0..2n]",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:969,Availability,mask,mask,969,"// If the LHS is a shufflevector itself, see if we can combine it with this; // one without producing an unusual shuffle.; // Cases that might be simplified:; // 1.; // x1=shuffle(v1,v2,mask1); // x=shuffle(x1,undef,mask); // ==>; // x=shuffle(v1,undef,newMask); // newMask[i] = (mask[i] < x1.size()) ? mask1[mask[i]] : -1; // 2.; // x1=shuffle(v1,undef,mask1); // x=shuffle(x1,x2,mask); // where v1.size() == mask1.size(); // ==>; // x=shuffle(v1,x2,newMask); // newMask[i] = (mask[i] < x1.size()) ? mask1[mask[i]] : mask[i]; // 3.; // x2=shuffle(v2,undef,mask2); // x=shuffle(x1,x2,mask); // where v2.size() == mask2.size(); // ==>; // x=shuffle(x1,v2,newMask); // newMask[i] = (mask[i] < x1.size()); // ? mask[i] : mask2[mask[i]-x1.size()]+x1.size(); // 4.; // x1=shuffle(v1,undef,mask1); // x2=shuffle(v2,undef,mask2); // x=shuffle(x1,x2,mask); // where v1.size() == v2.size(); // ==>; // x=shuffle(v1,v2,newMask); // newMask[i] = (mask[i] < x1.size()); // ? mask1[mask[i]] : mask2[mask[i]-x1.size()]+v1.size(); //; // Here we are really conservative:; // we are absolutely afraid of producing a shuffle mask not in the input; // program, because the code gen may not be smart enough to turn a merged; // shuffle into two specific shuffles: it may produce worse code. As such,; // we only merge two shuffles if the result is either a splat or one of the; // input shuffle masks. In this case, merging the shuffles just removes; // one instruction, which we know is safe. This is good for things like; // turning: (splat(splat)) -> splat, or; // merge(V[0..n], V[n+1..2n]) -> V[0..2n]",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:986,Availability,mask,mask,986,"// If the LHS is a shufflevector itself, see if we can combine it with this; // one without producing an unusual shuffle.; // Cases that might be simplified:; // 1.; // x1=shuffle(v1,v2,mask1); // x=shuffle(x1,undef,mask); // ==>; // x=shuffle(v1,undef,newMask); // newMask[i] = (mask[i] < x1.size()) ? mask1[mask[i]] : -1; // 2.; // x1=shuffle(v1,undef,mask1); // x=shuffle(x1,x2,mask); // where v1.size() == mask1.size(); // ==>; // x=shuffle(v1,x2,newMask); // newMask[i] = (mask[i] < x1.size()) ? mask1[mask[i]] : mask[i]; // 3.; // x2=shuffle(v2,undef,mask2); // x=shuffle(x1,x2,mask); // where v2.size() == mask2.size(); // ==>; // x=shuffle(x1,v2,newMask); // newMask[i] = (mask[i] < x1.size()); // ? mask[i] : mask2[mask[i]-x1.size()]+x1.size(); // 4.; // x1=shuffle(v1,undef,mask1); // x2=shuffle(v2,undef,mask2); // x=shuffle(x1,x2,mask); // where v1.size() == v2.size(); // ==>; // x=shuffle(v1,v2,newMask); // newMask[i] = (mask[i] < x1.size()); // ? mask1[mask[i]] : mask2[mask[i]-x1.size()]+v1.size(); //; // Here we are really conservative:; // we are absolutely afraid of producing a shuffle mask not in the input; // program, because the code gen may not be smart enough to turn a merged; // shuffle into two specific shuffles: it may produce worse code. As such,; // we only merge two shuffles if the result is either a splat or one of the; // input shuffle masks. In this case, merging the shuffles just removes; // one instruction, which we know is safe. This is good for things like; // turning: (splat(splat)) -> splat, or; // merge(V[0..n], V[n+1..2n]) -> V[0..2n]",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:1108,Availability,mask,mask,1108,"// If the LHS is a shufflevector itself, see if we can combine it with this; // one without producing an unusual shuffle.; // Cases that might be simplified:; // 1.; // x1=shuffle(v1,v2,mask1); // x=shuffle(x1,undef,mask); // ==>; // x=shuffle(v1,undef,newMask); // newMask[i] = (mask[i] < x1.size()) ? mask1[mask[i]] : -1; // 2.; // x1=shuffle(v1,undef,mask1); // x=shuffle(x1,x2,mask); // where v1.size() == mask1.size(); // ==>; // x=shuffle(v1,x2,newMask); // newMask[i] = (mask[i] < x1.size()) ? mask1[mask[i]] : mask[i]; // 3.; // x2=shuffle(v2,undef,mask2); // x=shuffle(x1,x2,mask); // where v2.size() == mask2.size(); // ==>; // x=shuffle(x1,v2,newMask); // newMask[i] = (mask[i] < x1.size()); // ? mask[i] : mask2[mask[i]-x1.size()]+x1.size(); // 4.; // x1=shuffle(v1,undef,mask1); // x2=shuffle(v2,undef,mask2); // x=shuffle(x1,x2,mask); // where v1.size() == v2.size(); // ==>; // x=shuffle(v1,v2,newMask); // newMask[i] = (mask[i] < x1.size()); // ? mask1[mask[i]] : mask2[mask[i]-x1.size()]+v1.size(); //; // Here we are really conservative:; // we are absolutely afraid of producing a shuffle mask not in the input; // program, because the code gen may not be smart enough to turn a merged; // shuffle into two specific shuffles: it may produce worse code. As such,; // we only merge two shuffles if the result is either a splat or one of the; // input shuffle masks. In this case, merging the shuffles just removes; // one instruction, which we know is safe. This is good for things like; // turning: (splat(splat)) -> splat, or; // merge(V[0..n], V[n+1..2n]) -> V[0..2n]",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:1376,Availability,mask,masks,1376,"// If the LHS is a shufflevector itself, see if we can combine it with this; // one without producing an unusual shuffle.; // Cases that might be simplified:; // 1.; // x1=shuffle(v1,v2,mask1); // x=shuffle(x1,undef,mask); // ==>; // x=shuffle(v1,undef,newMask); // newMask[i] = (mask[i] < x1.size()) ? mask1[mask[i]] : -1; // 2.; // x1=shuffle(v1,undef,mask1); // x=shuffle(x1,x2,mask); // where v1.size() == mask1.size(); // ==>; // x=shuffle(v1,x2,newMask); // newMask[i] = (mask[i] < x1.size()) ? mask1[mask[i]] : mask[i]; // 3.; // x2=shuffle(v2,undef,mask2); // x=shuffle(x1,x2,mask); // where v2.size() == mask2.size(); // ==>; // x=shuffle(x1,v2,newMask); // newMask[i] = (mask[i] < x1.size()); // ? mask[i] : mask2[mask[i]-x1.size()]+x1.size(); // 4.; // x1=shuffle(v1,undef,mask1); // x2=shuffle(v2,undef,mask2); // x=shuffle(x1,x2,mask); // where v1.size() == v2.size(); // ==>; // x=shuffle(v1,v2,newMask); // newMask[i] = (mask[i] < x1.size()); // ? mask1[mask[i]] : mask2[mask[i]-x1.size()]+v1.size(); //; // Here we are really conservative:; // we are absolutely afraid of producing a shuffle mask not in the input; // program, because the code gen may not be smart enough to turn a merged; // shuffle into two specific shuffles: it may produce worse code. As such,; // we only merge two shuffles if the result is either a splat or one of the; // input shuffle masks. In this case, merging the shuffles just removes; // one instruction, which we know is safe. This is good for things like; // turning: (splat(splat)) -> splat, or; // merge(V[0..n], V[n+1..2n]) -> V[0..2n]",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:1469,Safety,safe,safe,1469,"// If the LHS is a shufflevector itself, see if we can combine it with this; // one without producing an unusual shuffle.; // Cases that might be simplified:; // 1.; // x1=shuffle(v1,v2,mask1); // x=shuffle(x1,undef,mask); // ==>; // x=shuffle(v1,undef,newMask); // newMask[i] = (mask[i] < x1.size()) ? mask1[mask[i]] : -1; // 2.; // x1=shuffle(v1,undef,mask1); // x=shuffle(x1,x2,mask); // where v1.size() == mask1.size(); // ==>; // x=shuffle(v1,x2,newMask); // newMask[i] = (mask[i] < x1.size()) ? mask1[mask[i]] : mask[i]; // 3.; // x2=shuffle(v2,undef,mask2); // x=shuffle(x1,x2,mask); // where v2.size() == mask2.size(); // ==>; // x=shuffle(x1,v2,newMask); // newMask[i] = (mask[i] < x1.size()); // ? mask[i] : mask2[mask[i]-x1.size()]+x1.size(); // 4.; // x1=shuffle(v1,undef,mask1); // x2=shuffle(v2,undef,mask2); // x=shuffle(x1,x2,mask); // where v1.size() == v2.size(); // ==>; // x=shuffle(v1,v2,newMask); // newMask[i] = (mask[i] < x1.size()); // ? mask1[mask[i]] : mask2[mask[i]-x1.size()]+v1.size(); //; // Here we are really conservative:; // we are absolutely afraid of producing a shuffle mask not in the input; // program, because the code gen may not be smart enough to turn a merged; // shuffle into two specific shuffles: it may produce worse code. As such,; // we only merge two shuffles if the result is either a splat or one of the; // input shuffle masks. In this case, merging the shuffles just removes; // one instruction, which we know is safe. This is good for things like; // turning: (splat(splat)) -> splat, or; // merge(V[0..n], V[n+1..2n]) -> V[0..2n]",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:146,Usability,simpl,simplified,146,"// If the LHS is a shufflevector itself, see if we can combine it with this; // one without producing an unusual shuffle.; // Cases that might be simplified:; // 1.; // x1=shuffle(v1,v2,mask1); // x=shuffle(x1,undef,mask); // ==>; // x=shuffle(v1,undef,newMask); // newMask[i] = (mask[i] < x1.size()) ? mask1[mask[i]] : -1; // 2.; // x1=shuffle(v1,undef,mask1); // x=shuffle(x1,x2,mask); // where v1.size() == mask1.size(); // ==>; // x=shuffle(v1,x2,newMask); // newMask[i] = (mask[i] < x1.size()) ? mask1[mask[i]] : mask[i]; // 3.; // x2=shuffle(v2,undef,mask2); // x=shuffle(x1,x2,mask); // where v2.size() == mask2.size(); // ==>; // x=shuffle(x1,v2,newMask); // newMask[i] = (mask[i] < x1.size()); // ? mask[i] : mask2[mask[i]-x1.size()]+x1.size(); // 4.; // x1=shuffle(v1,undef,mask1); // x2=shuffle(v2,undef,mask2); // x=shuffle(x1,x2,mask); // where v1.size() == v2.size(); // ==>; // x=shuffle(v1,v2,newMask); // newMask[i] = (mask[i] < x1.size()); // ? mask1[mask[i]] : mask2[mask[i]-x1.size()]+v1.size(); //; // Here we are really conservative:; // we are absolutely afraid of producing a shuffle mask not in the input; // program, because the code gen may not be smart enough to turn a merged; // shuffle into two specific shuffles: it may produce worse code. As such,; // we only merge two shuffles if the result is either a splat or one of the; // input shuffle masks. In this case, merging the shuffles just removes; // one instruction, which we know is safe. This is good for things like; // turning: (splat(splat)) -> splat, or; // merge(V[0..n], V[n+1..2n]) -> V[0..2n]",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:16,Availability,mask,mask,16,// Create a new mask for the new ShuffleVectorInst so that the new; // ShuffleVectorInst is equivalent to the original one.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:135,Availability,mask,mask,135,"// This element is from left hand side vector operand.; //; // If LHS is going to be replaced (case 1, 2, or 4), calculate the; // new mask value for the element.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:81,Availability,mask,mask,81,"// If the value selected is an poison value, explicitly specify it; // with a -1 mask value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:140,Availability,mask,mask,140,"// This element is from right hand side vector operand; //; // If the value selected is a poison value, explicitly specify it; // with a -1 mask value. (case 1)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:71,Availability,mask,mask,71,"// If RHS is going to be replaced (case 3 or 4), calculate the; // new mask value for the element.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:81,Availability,mask,mask,81,"// If the value selected is an poison value, explicitly specify it; // with a -1 mask value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:40,Availability,mask,mask,40,"// If LHS's width is changed, shift the mask value accordingly.; // If newRHS == nullptr, i.e. LHSOp0 == RHSOp0, we want to remap any; // references from RHSOp0 to LHSOp0, so we don't need to shift the mask.; // If newRHS == newLHS, we want to remap any references from newRHS to; // newLHS so that we can properly identify splats that may occur due to; // obfuscation across the two vectors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:202,Availability,mask,mask,202,"// If LHS's width is changed, shift the mask value accordingly.; // If newRHS == nullptr, i.e. LHSOp0 == RHSOp0, we want to remap any; // references from RHSOp0 to LHSOp0, so we don't need to shift the mask.; // If newRHS == newLHS, we want to remap any references from newRHS to; // newLHS so that we can properly identify splats that may occur due to; // obfuscation across the two vectors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:17,Availability,mask,mask,17,"// If the result mask is equal to one of the original shuffle masks,; // or is a splat, do the replacement.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:62,Availability,mask,masks,62,"// If the result mask is equal to one of the original shuffle masks,; // or is a splat, do the replacement.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:1278,Energy Efficiency,power,power-of-two,1278,"//===- InstructionCombining.cpp - Combine multiple instructions -----------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // InstructionCombining - Combine instructions to form fewer, simple; // instructions. This pass does not modify the CFG. This pass is where; // algebraic simplification happens.; //; // This pass combines things like:; // %Y = add i32 %X, 1; // %Z = add i32 %Y, 1; // into:; // %Z = add i32 %X, 2; //; // This is a simple worklist driven algorithm.; //; // This pass guarantees that the following canonicalizations are performed on; // the program:; // 1. If a binary operator has a constant operand, it is moved to the RHS; // 2. Bitwise operators with constant operands are always grouped so that; // shifts are performed first, then or's, then and's, then xor's.; // 3. Compare instructions are converted from <,>,<=,>= to ==,!= if possible; // 4. All cmp instructions on boolean values are replaced with logical ops; // 5. add X, X is represented as (X*2) => (X << 1); // 6. Multiplies with a power-of-two constant argument are transformed into; // shifts.; // ... etc.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:800,Performance,perform,performed,800,"//===- InstructionCombining.cpp - Combine multiple instructions -----------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // InstructionCombining - Combine instructions to form fewer, simple; // instructions. This pass does not modify the CFG. This pass is where; // algebraic simplification happens.; //; // This pass combines things like:; // %Y = add i32 %X, 1; // %Z = add i32 %Y, 1; // into:; // %Z = add i32 %X, 2; //; // This is a simple worklist driven algorithm.; //; // This pass guarantees that the following canonicalizations are performed on; // the program:; // 1. If a binary operator has a constant operand, it is moved to the RHS; // 2. Bitwise operators with constant operands are always grouped so that; // shifts are performed first, then or's, then and's, then xor's.; // 3. Compare instructions are converted from <,>,<=,>= to ==,!= if possible; // 4. All cmp instructions on boolean values are replaced with logical ops; // 5. add X, X is represented as (X*2) => (X << 1); // 6. Multiplies with a power-of-two constant argument are transformed into; // shifts.; // ... etc.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:995,Performance,perform,performed,995,"//===- InstructionCombining.cpp - Combine multiple instructions -----------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // InstructionCombining - Combine instructions to form fewer, simple; // instructions. This pass does not modify the CFG. This pass is where; // algebraic simplification happens.; //; // This pass combines things like:; // %Y = add i32 %X, 1; // %Z = add i32 %Y, 1; // into:; // %Z = add i32 %X, 2; //; // This is a simple worklist driven algorithm.; //; // This pass guarantees that the following canonicalizations are performed on; // the program:; // 1. If a binary operator has a constant operand, it is moved to the RHS; // 2. Bitwise operators with constant operands are always grouped so that; // shifts are performed first, then or's, then and's, then xor's.; // 3. Compare instructions are converted from <,>,<=,>= to ==,!= if possible; // 4. All cmp instructions on boolean values are replaced with logical ops; // 5. add X, X is represented as (X*2) => (X << 1); // 6. Multiplies with a power-of-two constant argument are transformed into; // shifts.; // ... etc.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:1189,Testability,log,logical,1189,"//===- InstructionCombining.cpp - Combine multiple instructions -----------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // InstructionCombining - Combine instructions to form fewer, simple; // instructions. This pass does not modify the CFG. This pass is where; // algebraic simplification happens.; //; // This pass combines things like:; // %Y = add i32 %X, 1; // %Z = add i32 %Y, 1; // into:; // %Z = add i32 %X, 2; //; // This is a simple worklist driven algorithm.; //; // This pass guarantees that the following canonicalizations are performed on; // the program:; // 1. If a binary operator has a constant operand, it is moved to the RHS; // 2. Bitwise operators with constant operands are always grouped so that; // shifts are performed first, then or's, then and's, then xor's.; // 3. Compare instructions are converted from <,>,<=,>= to ==,!= if possible; // 4. All cmp instructions on boolean values are replaced with logical ops; // 5. add X, X is represented as (X*2) => (X << 1); // 6. Multiplies with a power-of-two constant argument are transformed into; // shifts.; // ... etc.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:442,Usability,simpl,simple,442,"//===- InstructionCombining.cpp - Combine multiple instructions -----------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // InstructionCombining - Combine instructions to form fewer, simple; // instructions. This pass does not modify the CFG. This pass is where; // algebraic simplification happens.; //; // This pass combines things like:; // %Y = add i32 %X, 1; // %Z = add i32 %Y, 1; // into:; // %Z = add i32 %X, 2; //; // This is a simple worklist driven algorithm.; //; // This pass guarantees that the following canonicalizations are performed on; // the program:; // 1. If a binary operator has a constant operand, it is moved to the RHS; // 2. Bitwise operators with constant operands are always grouped so that; // shifts are performed first, then or's, then and's, then xor's.; // 3. Compare instructions are converted from <,>,<=,>= to ==,!= if possible; // 4. All cmp instructions on boolean values are replaced with logical ops; // 5. add X, X is represented as (X*2) => (X << 1); // 6. Multiplies with a power-of-two constant argument are transformed into; // shifts.; // ... etc.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:535,Usability,simpl,simplification,535,"//===- InstructionCombining.cpp - Combine multiple instructions -----------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // InstructionCombining - Combine instructions to form fewer, simple; // instructions. This pass does not modify the CFG. This pass is where; // algebraic simplification happens.; //; // This pass combines things like:; // %Y = add i32 %X, 1; // %Z = add i32 %Y, 1; // into:; // %Z = add i32 %X, 2; //; // This is a simple worklist driven algorithm.; //; // This pass guarantees that the following canonicalizations are performed on; // the program:; // 1. If a binary operator has a constant operand, it is moved to the RHS; // 2. Bitwise operators with constant operands are always grouped so that; // shifts are performed first, then or's, then and's, then xor's.; // 3. Compare instructions are converted from <,>,<=,>= to ==,!= if possible; // 4. All cmp instructions on boolean values are replaced with logical ops; // 5. add X, X is represented as (X*2) => (X << 1); // 6. Multiplies with a power-of-two constant argument are transformed into; // shifts.; // ... etc.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:696,Usability,simpl,simple,696,"//===- InstructionCombining.cpp - Combine multiple instructions -----------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // InstructionCombining - Combine instructions to form fewer, simple; // instructions. This pass does not modify the CFG. This pass is where; // algebraic simplification happens.; //; // This pass combines things like:; // %Y = add i32 %X, 1; // %Z = add i32 %Y, 1; // into:; // %Z = add i32 %X, 2; //; // This is a simple worklist driven algorithm.; //; // This pass guarantees that the following canonicalizations are performed on; // the program:; // 1. If a binary operator has a constant operand, it is moved to the RHS; // 2. Bitwise operators with constant operands are always grouped so that; // shifts are performed first, then or's, then and's, then xor's.; // 3. Compare instructions are converted from <,>,<=,>= to ==,!= if possible; // 4. All cmp instructions on boolean values are replaced with logical ops; // 5. add X, X is represented as (X*2) => (X << 1); // 6. Multiplies with a power-of-two constant argument are transformed into; // shifts.; // ... etc.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:167,Availability,avail,availability,167,"// FIXME: Remove this flag when it is no longer necessary to convert; // llvm.dbg.declare to avoid inaccurate debug info. Setting this to false; // increases variable availability at the cost of accuracy. Variables that; // cannot be promoted by mem2reg or SROA will be described as living in memory; // for their entire lifetime. However, passes like DSE and instcombine can; // delete stores to the alloca, leading to misleading and inaccurate debug; // information. This flag can be removed when those passes are fixed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:158,Modifiability,variab,variable,158,"// FIXME: Remove this flag when it is no longer necessary to convert; // llvm.dbg.declare to avoid inaccurate debug info. Setting this to false; // increases variable availability at the cost of accuracy. Variables that; // cannot be promoted by mem2reg or SROA will be described as living in memory; // for their entire lifetime. However, passes like DSE and instcombine can; // delete stores to the alloca, leading to misleading and inaccurate debug; // information. This flag can be removed when those passes are fixed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:205,Modifiability,Variab,Variables,205,"// FIXME: Remove this flag when it is no longer necessary to convert; // llvm.dbg.declare to avoid inaccurate debug info. Setting this to false; // increases variable availability at the cost of accuracy. Variables that; // cannot be promoted by mem2reg or SROA will be described as living in memory; // for their entire lifetime. However, passes like DSE and instcombine can; // delete stores to the alloca, leading to misleading and inaccurate debug; // information. This flag can be removed when those passes are fixed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:93,Safety,avoid,avoid,93,"// FIXME: Remove this flag when it is no longer necessary to convert; // llvm.dbg.declare to avoid inaccurate debug info. Setting this to false; // increases variable availability at the cost of accuracy. Variables that; // cannot be promoted by mem2reg or SROA will be described as living in memory; // for their entire lifetime. However, passes like DSE and instcombine can; // delete stores to the alloca, leading to misleading and inaccurate debug; // information. This flag can be removed when those passes are fixed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:83,Safety,avoid,avoid,83,"/// Legal integers and common types are considered desirable. This is used to; /// avoid creating instructions with types that may not be supported well by the; /// the backend.; /// NOTE: This treats i8, i16 and i32 specially because they are common; /// types in frontend languages.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:390,Performance,optimiz,optimizations,390,"/// Return true if it is desirable to convert an integer computation from a; /// given bit width to a new bit width.; /// We don't want to convert from a legal or desirable type (like i8) to an; /// illegal type or from a smaller to a larger illegal type. A width of '1'; /// is always treated as a desirable type because i1 is a fundamental type in; /// IR, and there are many specialized optimizations for i1 types.; /// Common/desirable widths are equally treated as legal to convert to, in; /// order to open up more combining opportunities.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:305,Performance,optimiz,optimizations,305,"/// Return true if it is desirable to convert a computation from 'From' to 'To'.; /// We don't want to convert from a legal to an illegal type or from a smaller; /// to a larger illegal type. i1 is always treated as a legal type because it is; /// a fundamental type in IR, and there are many specialized optimizations for; /// i1 types.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:23,Modifiability,extend,extended,23,// TODO: This could be extended to allow vectors. Datalayout changes might be; // needed to properly support that.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:29,Integrability,Wrap,Wrap,29,"// Return true, if No Signed Wrap should be maintained for I.; // The No Signed Wrap flag can be kept if the operation ""B (I.getOpcode) C"",; // where both B and C should be ConstantInts, results in a constant that does; // not overflow. This function only handles the Add and Sub opcodes. For; // all other opcodes, the function conservatively returns false.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:80,Integrability,Wrap,Wrap,80,"// Return true, if No Signed Wrap should be maintained for I.; // The No Signed Wrap flag can be kept if the operation ""B (I.getOpcode) C"",; // where both B and C should be ConstantInts, results in a constant that does; // not overflow. This function only handles the Add and Sub opcodes. For; // all other opcodes, the function conservatively returns false.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:19,Usability,clear,clears,19,/// Conservatively clears subclassOptionalData after a reassociation or; /// commutation. We preserve fast-math flags when applicable as they can be; /// preserved.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:9,Modifiability,Enhance,Enhance,9,// TODO: Enhance logic for other casts and remove this check.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:17,Testability,log,logic,17,// TODO: Enhance logic for other casts and remove this check.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:9,Modifiability,Enhance,Enhance,9,// TODO: Enhance logic for other BinOps and remove this check.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:17,Testability,log,logic,17,// TODO: Enhance logic for other BinOps and remove this check.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:3,Usability,Simpl,Simplifies,3,// Simplifies IntToPtr/PtrToInt RoundTrip Cast.; // inttoptr ( ptrtoint (x) ) --> x,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:9,Performance,perform,performs,9,"/// This performs a few simplifications for operators that are associative or; /// commutative:; ///; /// Commutative operators:; ///; /// 1. Order operands such that they are listed from right (least complex) to; /// left (most complex). This puts constants before unary operators before; /// binary operators.; ///; /// Associative operators:; ///; /// 2. Transform: ""(A op B) op C"" ==> ""A op (B op C)"" if ""B op C"" simplifies.; /// 3. Transform: ""A op (B op C)"" ==> ""(A op B) op C"" if ""A op B"" simplifies.; ///; /// Associative and commutative operators:; ///; /// 4. Transform: ""(A op B) op C"" ==> ""(C op A) op B"" if ""C op A"" simplifies.; /// 5. Transform: ""A op (B op C)"" ==> ""B op (C op A)"" if ""C op A"" simplifies.; /// 6. Transform: ""(A op C1) op (B op C2)"" ==> ""(A op B) op (C1 op C2)""; /// if C1 and C2 are constants.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:24,Usability,simpl,simplifications,24,"/// This performs a few simplifications for operators that are associative or; /// commutative:; ///; /// Commutative operators:; ///; /// 1. Order operands such that they are listed from right (least complex) to; /// left (most complex). This puts constants before unary operators before; /// binary operators.; ///; /// Associative operators:; ///; /// 2. Transform: ""(A op B) op C"" ==> ""A op (B op C)"" if ""B op C"" simplifies.; /// 3. Transform: ""A op (B op C)"" ==> ""(A op B) op C"" if ""A op B"" simplifies.; ///; /// Associative and commutative operators:; ///; /// 4. Transform: ""(A op B) op C"" ==> ""(C op A) op B"" if ""C op A"" simplifies.; /// 5. Transform: ""A op (B op C)"" ==> ""B op (C op A)"" if ""C op A"" simplifies.; /// 6. Transform: ""(A op C1) op (B op C2)"" ==> ""(A op B) op (C1 op C2)""; /// if C1 and C2 are constants.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:417,Usability,simpl,simplifies,417,"/// This performs a few simplifications for operators that are associative or; /// commutative:; ///; /// Commutative operators:; ///; /// 1. Order operands such that they are listed from right (least complex) to; /// left (most complex). This puts constants before unary operators before; /// binary operators.; ///; /// Associative operators:; ///; /// 2. Transform: ""(A op B) op C"" ==> ""A op (B op C)"" if ""B op C"" simplifies.; /// 3. Transform: ""A op (B op C)"" ==> ""(A op B) op C"" if ""A op B"" simplifies.; ///; /// Associative and commutative operators:; ///; /// 4. Transform: ""(A op B) op C"" ==> ""(C op A) op B"" if ""C op A"" simplifies.; /// 5. Transform: ""A op (B op C)"" ==> ""B op (C op A)"" if ""C op A"" simplifies.; /// 6. Transform: ""(A op C1) op (B op C2)"" ==> ""(A op B) op (C1 op C2)""; /// if C1 and C2 are constants.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:496,Usability,simpl,simplifies,496,"/// This performs a few simplifications for operators that are associative or; /// commutative:; ///; /// Commutative operators:; ///; /// 1. Order operands such that they are listed from right (least complex) to; /// left (most complex). This puts constants before unary operators before; /// binary operators.; ///; /// Associative operators:; ///; /// 2. Transform: ""(A op B) op C"" ==> ""A op (B op C)"" if ""B op C"" simplifies.; /// 3. Transform: ""A op (B op C)"" ==> ""(A op B) op C"" if ""A op B"" simplifies.; ///; /// Associative and commutative operators:; ///; /// 4. Transform: ""(A op B) op C"" ==> ""(C op A) op B"" if ""C op A"" simplifies.; /// 5. Transform: ""A op (B op C)"" ==> ""B op (C op A)"" if ""C op A"" simplifies.; /// 6. Transform: ""(A op C1) op (B op C2)"" ==> ""(A op B) op (C1 op C2)""; /// if C1 and C2 are constants.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:629,Usability,simpl,simplifies,629,"/// This performs a few simplifications for operators that are associative or; /// commutative:; ///; /// Commutative operators:; ///; /// 1. Order operands such that they are listed from right (least complex) to; /// left (most complex). This puts constants before unary operators before; /// binary operators.; ///; /// Associative operators:; ///; /// 2. Transform: ""(A op B) op C"" ==> ""A op (B op C)"" if ""B op C"" simplifies.; /// 3. Transform: ""A op (B op C)"" ==> ""(A op B) op C"" if ""A op B"" simplifies.; ///; /// Associative and commutative operators:; ///; /// 4. Transform: ""(A op B) op C"" ==> ""(C op A) op B"" if ""C op A"" simplifies.; /// 5. Transform: ""A op (B op C)"" ==> ""B op (C op A)"" if ""C op A"" simplifies.; /// 6. Transform: ""(A op C1) op (B op C2)"" ==> ""(A op B) op (C1 op C2)""; /// if C1 and C2 are constants.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:708,Usability,simpl,simplifies,708,"/// This performs a few simplifications for operators that are associative or; /// commutative:; ///; /// Commutative operators:; ///; /// 1. Order operands such that they are listed from right (least complex) to; /// left (most complex). This puts constants before unary operators before; /// binary operators.; ///; /// Associative operators:; ///; /// 2. Transform: ""(A op B) op C"" ==> ""A op (B op C)"" if ""B op C"" simplifies.; /// 3. Transform: ""A op (B op C)"" ==> ""(A op B) op C"" if ""A op B"" simplifies.; ///; /// Associative and commutative operators:; ///; /// 4. Transform: ""(A op B) op C"" ==> ""(C op A) op B"" if ""C op A"" simplifies.; /// 5. Transform: ""A op (B op C)"" ==> ""B op (C op A)"" if ""C op A"" simplifies.; /// 6. Transform: ""(A op C1) op (B op C2)"" ==> ""(A op B) op (C1 op C2)""; /// if C1 and C2 are constants.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:62,Usability,simpl,simplifies,62,"// Transform: ""(A op B) op C"" ==> ""A op (B op C)"" if ""B op C"" simplifies.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:17,Usability,simpl,simplify,17,"// Does ""B op C"" simplify?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:6,Usability,simpl,simplifies,6,"// It simplifies to V. Form ""A op V"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:18,Usability,clear,clear,18,// Conservatively clear all optional flags since they may not be; // preserved by the reassociation. Reset nsw/nuw based on the above; // analysis.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:36,Usability,Simpl,SimplifyBinOp,36,// Note: this is only valid because SimplifyBinOp doesn't look at; // the operands to Op0.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:62,Usability,simpl,simplifies,62,"// Transform: ""A op (B op C)"" ==> ""(A op B) op C"" if ""A op B"" simplifies.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:17,Usability,simpl,simplify,17,"// Does ""A op B"" simplify?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:6,Usability,simpl,simplifies,6,"// It simplifies to V. Form ""V op C"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:18,Usability,clear,clear,18,"// Conservatively clear the optional flags, since they may not be; // preserved by the reassociation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:62,Usability,simpl,simplifies,62,"// Transform: ""(A op B) op C"" ==> ""(C op A) op B"" if ""C op A"" simplifies.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:17,Usability,simpl,simplify,17,"// Does ""C op A"" simplify?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:6,Usability,simpl,simplifies,6,"// It simplifies to V. Form ""V op B"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:18,Usability,clear,clear,18,"// Conservatively clear the optional flags, since they may not be; // preserved by the reassociation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:62,Usability,simpl,simplifies,62,"// Transform: ""A op (B op C)"" ==> ""B op (C op A)"" if ""C op A"" simplifies.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:17,Usability,simpl,simplify,17,"// Does ""C op A"" simplify?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:6,Usability,simpl,simplifies,6,"// It simplifies to V. Form ""B op V"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:18,Usability,clear,clear,18,"// Conservatively clear the optional flags, since they may not be; // preserved by the reassociation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:18,Usability,clear,clear,18,"// Conservatively clear the optional flags, since they may not be; // preserved by the reassociation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:14,Usability,simpl,simplifications,14,// No further simplifications.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:18,Usability,simpl,simplify,18,"/// This tries to simplify binary operations by factorizing out common terms; /// (e. g. ""(A*B)+(A*C)"" -> ""A*(B+C)"").",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:54,Usability,simpl,simplifies,54,"// Consider forming ""A op' (B op D)"".; // If ""B op D"" simplifies then it can be formed with no cost.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:23,Usability,simpl,simplify,23,"// If ""B op D"" doesn't simplify then only go on if one of the existing; // operations ""A op' B"" and ""C op' D"" will be zapped as no longer used.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:54,Usability,simpl,simplifies,54,"// Consider forming ""(A op C) op' B"".; // If ""A op C"" simplifies then it can be formed with no cost.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:23,Usability,simpl,simplify,23,"// If ""A op C"" doesn't simplify then only go on if one of the existing; // operations ""A op' B"" and ""C op' D"" will be zapped as no longer used.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:183,Usability,simpl,simplfied,183,"// Signed predicates aren't correct in some edge cases like for i2 types, as; // well since (ctpop x) is known [0, log2(BitWidth(x))] almost all signed; // comparisons against it are simplfied to unsigned.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:95,Usability,simpl,simplify,95,"// Need extra check for icmp. Note if this check is true, it generally means; // the icmp will simplify to true/false.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:33,Safety,avoid,avoid,33,// Do the transformation here to avoid potentially introducing an infinite; // loop.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:354,Availability,Mask,Mask,354,"// (Binop1 (Binop2 (logic_shift X, C), C1), (logic_shift Y, C)); // IFF; // 1) the logic_shifts match; // 2) either both binops are binops and one is `and` or; // BinOp1 is `and`; // (logic_shift (inv_logic_shift C1, C), C) == C1 or; //; // -> (logic_shift (Binop1 (Binop2 X, inv_logic_shift(C1, C)), Y), C); //; // (Binop1 (Binop2 (logic_shift X, Amt), Mask), (logic_shift Y, Amt)); // IFF; // 1) the logic_shifts match; // 2) BinOp1 == BinOp2 (if BinOp == `add`, then also requires `shl`).; //; // -> (BinOp (logic_shift (BinOp X, Y)), Mask); //; // (Binop1 (Binop2 (arithmetic_shift X, Amt), Mask), (arithmetic_shift Y, Amt)); // IFF; // 1) Binop1 is bitwise logical operator `and`, `or` or `xor`; // 2) Binop2 is `not`; //; // -> (arithmetic_shift Binop1((not X), Y), Amt)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:538,Availability,Mask,Mask,538,"// (Binop1 (Binop2 (logic_shift X, C), C1), (logic_shift Y, C)); // IFF; // 1) the logic_shifts match; // 2) either both binops are binops and one is `and` or; // BinOp1 is `and`; // (logic_shift (inv_logic_shift C1, C), C) == C1 or; //; // -> (logic_shift (Binop1 (Binop2 X, inv_logic_shift(C1, C)), Y), C); //; // (Binop1 (Binop2 (logic_shift X, Amt), Mask), (logic_shift Y, Amt)); // IFF; // 1) the logic_shifts match; // 2) BinOp1 == BinOp2 (if BinOp == `add`, then also requires `shl`).; //; // -> (BinOp (logic_shift (BinOp X, Y)), Mask); //; // (Binop1 (Binop2 (arithmetic_shift X, Amt), Mask), (arithmetic_shift Y, Amt)); // IFF; // 1) Binop1 is bitwise logical operator `and`, `or` or `xor`; // 2) Binop2 is `not`; //; // -> (arithmetic_shift Binop1((not X), Y), Amt)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:595,Availability,Mask,Mask,595,"// (Binop1 (Binop2 (logic_shift X, C), C1), (logic_shift Y, C)); // IFF; // 1) the logic_shifts match; // 2) either both binops are binops and one is `and` or; // BinOp1 is `and`; // (logic_shift (inv_logic_shift C1, C), C) == C1 or; //; // -> (logic_shift (Binop1 (Binop2 X, inv_logic_shift(C1, C)), Y), C); //; // (Binop1 (Binop2 (logic_shift X, Amt), Mask), (logic_shift Y, Amt)); // IFF; // 1) the logic_shifts match; // 2) BinOp1 == BinOp2 (if BinOp == `add`, then also requires `shl`).; //; // -> (BinOp (logic_shift (BinOp X, Y)), Mask); //; // (Binop1 (Binop2 (arithmetic_shift X, Amt), Mask), (arithmetic_shift Y, Amt)); // IFF; // 1) Binop1 is bitwise logical operator `and`, `or` or `xor`; // 2) Binop2 is `not`; //; // -> (arithmetic_shift Binop1((not X), Y), Amt)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:662,Testability,log,logical,662,"// (Binop1 (Binop2 (logic_shift X, C), C1), (logic_shift Y, C)); // IFF; // 1) the logic_shifts match; // 2) either both binops are binops and one is `and` or; // BinOp1 is `and`; // (logic_shift (inv_logic_shift C1, C), C) == C1 or; //; // -> (logic_shift (Binop1 (Binop2 X, inv_logic_shift(C1, C)), Y), C); //; // (Binop1 (Binop2 (logic_shift X, Amt), Mask), (logic_shift Y, Amt)); // IFF; // 1) the logic_shifts match; // 2) BinOp1 == BinOp2 (if BinOp == `add`, then also requires `shl`).; //; // -> (BinOp (logic_shift (BinOp X, Y)), Mask); //; // (Binop1 (Binop2 (arithmetic_shift X, Amt), Mask), (arithmetic_shift Y, Amt)); // IFF; // 1) Binop1 is bitwise logical operator `and`, `or` or `xor`; // 2) Binop2 is `not`; //; // -> (arithmetic_shift Binop1((not X), Y), Amt)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:38,Availability,mask,masks,38,// Skip Sub as we only match constant masks which will canonicalize to use; // add.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:53,Availability,mask,mask,53,// If the BinOp1 is `and` we don't need to check the mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:27,Availability,mask,mask,27,"// If BinOp2 is `and`, any mask works (this only really helps for non-splat; // vecs, otherwise the mask will be simplified and the following check will; // handle it).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:100,Availability,mask,mask,100,"// If BinOp2 is `and`, any mask works (this only really helps for non-splat; // vecs, otherwise the mask will be simplified and the following check will; // handle it).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:113,Usability,simpl,simplified,113,"// If BinOp2 is `and`, any mask works (this only really helps for non-splat; // vecs, otherwise the mask will be simplified and the following check will; // handle it).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:19,Availability,mask,mask,19,"// Otherwise, need mask that meets the below requirement.; // (logic_shift (inv_logic_shift Mask, ShAmt), ShAmt) == Mask",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:92,Availability,Mask,Mask,92,"// Otherwise, need mask that meets the below requirement.; // (logic_shift (inv_logic_shift Mask, ShAmt), ShAmt) == Mask",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:116,Availability,Mask,Mask,116,"// Otherwise, need mask that meets the below requirement.; // (logic_shift (inv_logic_shift Mask, ShAmt), ShAmt) == Mask",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:61,Availability,mask,mask,61,"// Otherwise we can only distribute by constant shifting the mask, so; // ensure we have constants.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:193,Usability,simpl,simplify,193,"// (Binop (zext C), (select C, T, F)); // -> (select C, (binop 1, T), (binop 0, F)); //; // (Binop (sext C), (select C, T, F)); // -> (select C, (binop -1, T), (binop 0, F)); //; // Attempt to simplify binary operations into a select with folded args, when; // one operand of the binop is a select instruction and the other operand is a; // zext/sext extension, whose value is the select condition.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:36,Modifiability,extend,extended,36,"// TODO: this simplification may be extended to any speculatable instruction,; // not just binops, and would possibly be handled better in FoldOpIntoSelect.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:14,Usability,simpl,simplification,14,"// TODO: this simplification may be extended to any speculatable instruction,; // not just binops, and would possibly be handled better in FoldOpIntoSelect.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:124,Usability,simpl,simplified,124,"// If the value used in the zext/sext is the select condition, or the negated; // of the select condition, the binop can be simplified.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:18,Usability,simpl,simplify,18,"/// This tries to simplify binary operations which some other binary operation; /// distributes over either by factorizing out common terms; /// (eg ""(A*B)+(A*C)"" -> ""A*(B+C)"") or expanding out if this results in; /// simplifications (eg: ""A & (B | C) -> (A&B) | (A&C)"" if this is a win).; /// Returns the simplified value, or null if it didn't simplify.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:218,Usability,simpl,simplifications,218,"/// This tries to simplify binary operations which some other binary operation; /// distributes over either by factorizing out common terms; /// (eg ""(A*B)+(A*C)"" -> ""A*(B+C)"") or expanding out if this results in; /// simplifications (eg: ""A & (B | C) -> (A&B) | (A&C)"" if this is a win).; /// Returns the simplified value, or null if it didn't simplify.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:306,Usability,simpl,simplified,306,"/// This tries to simplify binary operations which some other binary operation; /// distributes over either by factorizing out common terms; /// (eg ""(A*B)+(A*C)"" -> ""A*(B+C)"") or expanding out if this results in; /// simplifications (eg: ""A & (B | C) -> (A&B) | (A&C)"" if this is a win).; /// Returns the simplified value, or null if it didn't simplify.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:345,Usability,simpl,simplify,345,"/// This tries to simplify binary operations which some other binary operation; /// distributes over either by factorizing out common terms; /// (eg ""(A*B)+(A*C)"" -> ""A*(B+C)"") or expanding out if this results in; /// simplifications (eg: ""A & (B | C) -> (A&B) | (A&C)"" if this is a win).; /// Returns the simplified value, or null if it didn't simplify.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:116,Usability,simpl,simplifications,116,"// The instruction has the form ""(A op' B) op C"". See if expanding it out; // to ""(A op C) op' (B op C)"" results in simplifications.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:53,Safety,safe,safe,53,// op'; // Disable the use of undef because it's not safe to distribute undef.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:33,Usability,simpl,simplify,33,"// Do ""A op C"" and ""B op C"" both simplify?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:17,Usability,simpl,simplify,17,"// Does ""A op C"" simplify to the identity value for the inner opcode?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:17,Usability,simpl,simplify,17,"// Does ""B op C"" simplify to the identity value for the inner opcode?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:116,Usability,simpl,simplifications,116,"// The instruction has the form ""A op (B op' C)"". See if expanding it out; // to ""(A op B) op' (A op C)"" results in simplifications.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:53,Safety,safe,safe,53,// op'; // Disable the use of undef because it's not safe to distribute undef.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:33,Usability,simpl,simplify,33,"// Do ""A op B"" and ""A op C"" both simplify?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:17,Usability,simpl,simplify,17,"// Does ""A op B"" simplify to the identity value for the inner opcode?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:17,Usability,simpl,simplify,17,"// Does ""A op C"" simplify to the identity value for the inner opcode?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:65,Usability,simpl,simplified,65,// We need an 'add' and exactly 1 arm of the select to have been simplified.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:11,Energy Efficiency,adapt,adapt,11,/// Freely adapt every user of V as-if V was changed to !V.; /// WARNING: only if canFreelyInvertAllUsersOf() said this can be done.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:11,Modifiability,adapt,adapt,11,/// Freely adapt every user of V as-if V was changed to !V.; /// WARNING: only if canFreelyInvertAllUsersOf() said this can be done.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:47,Modifiability,extend,extended,47,/// A binop with a constant operand and a sign-extended boolean operand may be; /// converted into a select of constants by applying the binary operation to; /// the constant with the two possible values of the extended boolean (0 or -1).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:211,Modifiability,extend,extended,211,/// A binop with a constant operand and a sign-extended boolean operand may be; /// converted into a select of constants by applying the binary operation to; /// the constant with the two possible values of the extended boolean (0 or -1).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:56,Testability,log,logical,56,// Bool selects with constant operands can be folded to logical ops.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:3,Testability,Test,Test,3,"// Test if a FCmpInst instruction is used exclusively by a select as; // part of a minimum or maximum operation. If so, refrain from doing; // any other folding. This helps out other analyses which understand; // non-obfuscated minimum and maximum idioms. And in this case, at; // least one of the comparison operands has at least one user besides; // the compare (the select), which would often largely negate the; // benefit of folding anyway.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:22,Usability,simpl,simplification,22,// Don't consider the simplification successful if we get back a constant; // expression. That's just an instruction in hiding.; // Also reject the case where we simplify back to the phi node. We wouldn't; // be able to remove it in that case.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:162,Usability,simpl,simplify,162,// Don't consider the simplification successful if we get back a constant; // expression. That's just an instruction in hiding.; // Also reject the case where we simplify back to the phi node. We wouldn't; // be able to remove it in that case.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:21,Usability,simpl,simplified,21,// More than one non-simplified value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:31,Usability,simpl,simplified,31,"// If there is exactly one non-simplified value, we can insert a copy of the; // operation in that block. However, if this is a critical edge, we would be; // inserting the computation on some other paths (e.g. inside a loop). Only; // do this if the pred block is unconditionally branching into the phi block.; // Also, make sure that the pred block is not dead code.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:181,Performance,optimiz,optimization,181,"// Fold if there is at least one specific constant value in phi0 or phi1's; // incoming values that comes from the same block and this specific constant; // value can be used to do optimization for specific binary operator.; // For example:; // %phi0 = phi i32 [0, %bb0], [%i, %bb1]; // %phi1 = phi i32 [%j, %bb0], [0, %bb1]; // %add = add i32 %phi0, %phi1; // ==>; // %add = phi i32 [%j, %bb0], [%i, %bb1]",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:90,Safety,safe,safe,90,// TODO: This check could be tightened to only apply to binops (div/rem) that; // are not safe to speculatively execute. But that could allow hoisting; // potentially expensive instructions (fdiv for example).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:65,Performance,perform,perform,65,"// If both operands of the binop are vector concatenations, then perform the; // narrow binop on each pair of the source operands followed by concatenation; // of the results.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:235,Availability,mask,mask,235,"// This transform does not have the speculative execution constraint as; // below because the shuffle is a concatenation. The new binops are; // operating on exactly the same elements as the existing binop.; // TODO: We could ease the mask requirement to allow different undef lanes,; // but that requires an analysis of the binop-with-undef output value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:17,Safety,safe,safe,17,"// It may not be safe to reorder shuffles and things like div, urem, etc.; // because we may trap when executing those ops on unknown vector elements.; // See PR20059.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:80,Availability,mask,mask,80,"// If both arguments of the binary operation are shuffles that use the same; // mask and shuffle within a single vector, move the shuffle after the binop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:18,Availability,Mask,Mask,18,"// Op(shuffle(V1, Mask), shuffle(V2, Mask)) -> shuffle(Op(V1, V2), Mask)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:37,Availability,Mask,Mask,37,"// Op(shuffle(V1, Mask), shuffle(V2, Mask)) -> shuffle(Op(V1, V2), Mask)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:67,Availability,Mask,Mask,67,"// Op(shuffle(V1, Mask), shuffle(V2, Mask)) -> shuffle(Op(V1, V2), Mask)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:86,Availability,mask,mask,86,"// If both arguments of a commutative binop are select-shuffles that use the; // same mask with commuted operands, the shuffles are unnecessary.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:51,Availability,mask,mask,51,"// TODO: Allow shuffles that contain undefs in the mask?; // That is legal, but it reduces undef knowledge.; // TODO: Allow arbitrary shuffles by shuffling after binop?; // That might be legal, but we have to deal with poison.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:83,Energy Efficiency,reduce,reduces,83,"// TODO: Allow shuffles that contain undefs in the mask?; // That is legal, but it reduces undef knowledge.; // TODO: Allow arbitrary shuffles by shuffling after binop?; // That might be legal, but we have to deal with poison.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:259,Modifiability,extend,extended,259,// Bail out if:; // 1. The constant vector contains a constant expression.; // 2. The shuffle needs an element of the constant vector that can't; // be mapped to a new constant vector.; // 3. This is a widening shuffle that copies elements of V1 into the; // extended elements (extending with poison is allowed).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:278,Modifiability,extend,extending,278,// Bail out if:; // 1. The constant vector contains a constant expression.; // 2. The shuffle needs an element of the constant vector that can't; // be mapped to a new constant vector.; // 3. This is a widening shuffle that copies elements of V1 into the; // extended elements (extending with poison is allowed).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:240,Availability,mask,mask,240,"// If this is a widening shuffle, we must be able to extend with poison; // elements. If the original binop does not produce a poison in the high; // lanes, then this transform is not safe.; // Similarly for poison lanes due to the shuffle mask, we can only; // transform binops that preserve poison.; // TODO: We could shuffle those non-poison constant values into the; // result by using a constant vector (rather than an poison vector); // as operand 1 of the new binop, but that might be too aggressive; // for target-independent shuffle creation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:53,Modifiability,extend,extend,53,"// If this is a widening shuffle, we must be able to extend with poison; // elements. If the original binop does not produce a poison in the high; // lanes, then this transform is not safe.; // Similarly for poison lanes due to the shuffle mask, we can only; // transform binops that preserve poison.; // TODO: We could shuffle those non-poison constant values into the; // result by using a constant vector (rather than an poison vector); // as operand 1 of the new binop, but that might be too aggressive; // for target-independent shuffle creation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:184,Safety,safe,safe,184,"// If this is a widening shuffle, we must be able to extend with poison; // elements. If the original binop does not produce a poison in the high; // lanes, then this transform is not safe.; // Similarly for poison lanes due to the shuffle mask, we can only; // transform binops that preserve poison.; // TODO: We could shuffle those non-poison constant values into the; // result by using a constant vector (rather than an poison vector); // as operand 1 of the new binop, but that might be too aggressive; // for target-independent shuffle creation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:17,Safety,safe,safe,17,// It may not be safe to execute a binop on a vector with poison elements; // because the entire instruction can be folded to undef or create poison; // that did not exist in the original code.; // TODO: The shift case should not be necessary.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:18,Availability,Mask,Mask,18,"// Op(shuffle(V1, Mask), C) -> shuffle(Op(V1, NewC), Mask); // Op(C, shuffle(V1, Mask)) -> shuffle(Op(NewC, V1), Mask)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:53,Availability,Mask,Mask,53,"// Op(shuffle(V1, Mask), C) -> shuffle(Op(V1, NewC), Mask); // Op(C, shuffle(V1, Mask)) -> shuffle(Op(NewC, V1), Mask)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:81,Availability,Mask,Mask,81,"// Op(shuffle(V1, Mask), C) -> shuffle(Op(V1, NewC), Mask); // Op(C, shuffle(V1, Mask)) -> shuffle(Op(NewC, V1), Mask)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:113,Availability,Mask,Mask,113,"// Op(shuffle(V1, Mask), C) -> shuffle(Op(V1, NewC), Mask); // Op(C, shuffle(V1, Mask)) -> shuffle(Op(NewC, V1), Mask)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:26,Safety,safe,safe,26,"// FIXME: This may not be safe if the analysis allows undef elements. By; // moving 'Y' before the splat shuffle, we are implicitly assuming; // that it is not undef/poison at the splat index.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:35,Performance,perform,perform,35,"// X and Y are splatted values, so perform the binary operation on those; // values followed by a splat followed by the 2nd binary operation:; // bo (splat X), (bo Y, OtherOp) --> bo (splat (bo X, Y)), OtherOp",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:91,Safety,safe,safe,91,// Intersect FMF on both new binops. Other (poison-generating) flags are; // dropped to be safe.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:67,Modifiability,extend,extend,67,/// Try to narrow the width of a binop if at least 1 operand is an extend of; /// of a value. This requires a potentially expensive known bits check to make; /// sure the narrow op does not overflow.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:24,Modifiability,extend,extended,24,// We need at least one extended operand.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:89,Modifiability,extend,extending,89,"// If that did not match, see if we have a suitable constant operand.; // Truncating and extending must produce the same constant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:20,Modifiability,variab,variable,20,// Split Src into a variable part and a constant suffix.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:52,Performance,scalab,scalable,52,// FIXME: getIndexedOffsetInType() does not handled scalable vectors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:84,Performance,perform,performing,84,"// Even if the total offset is inbounds, we may end up representing it; // by first performing a larger negative offset, and then a smaller; // positive one. The large negative offset might go out of bounds. Only; // preserve inbounds if all signs are the same.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:163,Safety,avoid,avoid,163,"// If they aren't the same type, then the input hasn't been processed; // by the loop above yet (which canonicalizes sequential index types to; // intptr_t). Just avoid transforming this until the input has been; // normalized.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:3,Deployability,Update,Update,3,// Update the GEP in place if possible.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:3,Testability,Log,LogicOps,3,// LogicOps are special in that we canonicalize them at the cost of an; // instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:92,Performance,scalab,scalable,92,"// For vector geps, use the generic demanded vector support.; // Skip if GEP return type is scalable. The number of elements is unknown at; // compile-time.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:113,Modifiability,extend,extend,113,"// If we are using a wider index than needed for this platform, shrink; // it to what we need. If narrower, sign-extend it to what we need.; // This explicit cast can make subsequent optimizations more obvious.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:183,Performance,optimiz,optimizations,183,"// If we are using a wider index than needed for this platform, shrink; // it to what we need. If narrower, sign-extend it to what we need.; // This explicit cast can make subsequent optimizations more obvious.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:265,Modifiability,variab,variable,265,"// Don't fold a GEP into itself through a PHI node. This can only happen; // through the back-edge of a loop. Folding a GEP into itself means that; // the value of the previous iteration needs to be stored in the meantime,; // thus requiring an additional register variable to be live, but not; // actually achieving anything (the GEP still needs to be executed once per; // loop iteration).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:128,Modifiability,variab,variable,128,"// We have not seen any differences yet in the GEPs feeding the; // PHI yet, so we record this one if it is allowed to be a; // variable.; // The first two arguments can vary for any GEP, the rest have to be; // static for struct slots",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:72,Modifiability,extend,extended,72,// The GEP is different by more than one input. While this could be; // extended to support GEPs that vary by more than one variable it; // doesn't make sense since it greatly increases the complexity and; // would result in an R+R+R addressing mode which no backend; // directly supports and would need to be broken into several; // simpler instructions anyway.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:124,Modifiability,variab,variable,124,// The GEP is different by more than one input. While this could be; // extended to support GEPs that vary by more than one variable it; // doesn't make sense since it greatly increases the complexity and; // would result in an R+R+R addressing mode which no backend; // directly supports and would need to be broken into several; // simpler instructions anyway.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:334,Usability,simpl,simpler,334,// The GEP is different by more than one input. While this could be; // extended to support GEPs that vary by more than one variable it; // doesn't make sense since it greatly increases the complexity and; // would result in an R+R+R addressing mode which no backend; // directly supports and would need to be broken into several; // simpler instructions anyway.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:8,Availability,down,down,8,// Sink down a layer of the type for the next iteration.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:57,Availability,down,down,57,// All the GEPs feeding the PHI are identical. Clone one down into our; // BB so that it can be merged with the current GEP.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:38,Performance,scalab,scalable,38,// Skip if GEP source element type is scalable. The type alloc size is unknown; // at compile-time.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:112,Safety,safe,safely,112,"// If the only possible side effect of the call is writing to the alloca,; // and the result isn't used, we can safely remove any reads implied by the; // call including those which might read the alloca itself.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:95,Energy Efficiency,power,power-of-,95,"// Check if alignment and size of a call to aligned_alloc is valid,; // that is alignment is a power-of-2 and the size is a multiple of the; // alignment.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:993,Availability,redundant,redundant,993,"// Remove debug intrinsics which describe the value contained within the; // alloca. In addition to removing dbg.{declare,addr} which simply point to; // the alloca, remove dbg.value(<alloca>, ..., DW_OP_deref)'s as well, e.g.:; //; // ```; // define void @foo(i32 %0) {; // %a = alloca i32 ; Deleted.; // store i32 %0, i32* %a; // dbg.value(i32 %0, ""arg0"") ; Not deleted.; // dbg.value(i32* %a, ""arg0"", DW_OP_deref) ; Deleted.; // call void @trivially_inlinable_no_op(i32* %a); // ret void; // }; // ```; //; // This may not be required if we stop describing the contents of allocas; // using dbg.value(<alloca>, ..., DW_OP_deref), but we currently do this in; // the LowerDbgDeclare utility.; //; // If there is a dead store to `%a` in @trivially_inlinable_no_op, the; // ""arg0"" dbg.value may be stale after the call. However, failing to remove; // the DW_OP_deref dbg.value causes large gaps in location coverage.; //; // FIXME: the Assignment Tracking project has now likely made this; // redundant (and it's sometimes harmful).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:993,Safety,redund,redundant,993,"// Remove debug intrinsics which describe the value contained within the; // alloca. In addition to removing dbg.{declare,addr} which simply point to; // the alloca, remove dbg.value(<alloca>, ..., DW_OP_deref)'s as well, e.g.:; //; // ```; // define void @foo(i32 %0) {; // %a = alloca i32 ; Deleted.; // store i32 %0, i32* %a; // dbg.value(i32 %0, ""arg0"") ; Not deleted.; // dbg.value(i32* %a, ""arg0"", DW_OP_deref) ; Deleted.; // call void @trivially_inlinable_no_op(i32* %a); // ret void; // }; // ```; //; // This may not be required if we stop describing the contents of allocas; // using dbg.value(<alloca>, ..., DW_OP_deref), but we currently do this in; // the LowerDbgDeclare utility.; //; // If there is a dead store to `%a` in @trivially_inlinable_no_op, the; // ""arg0"" dbg.value may be stale after the call. However, failing to remove; // the DW_OP_deref dbg.value causes large gaps in location coverage.; //; // FIXME: the Assignment Tracking project has now likely made this; // redundant (and it's sometimes harmful).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:134,Usability,simpl,simply,134,"// Remove debug intrinsics which describe the value contained within the; // alloca. In addition to removing dbg.{declare,addr} which simply point to; // the alloca, remove dbg.value(<alloca>, ..., DW_OP_deref)'s as well, e.g.:; //; // ```; // define void @foo(i32 %0) {; // %a = alloca i32 ; Deleted.; // store i32 %0, i32* %a; // dbg.value(i32 %0, ""arg0"") ; Not deleted.; // dbg.value(i32* %a, ""arg0"", DW_OP_deref) ; Deleted.; // call void @trivially_inlinable_no_op(i32* %a); // ret void; // }; // ```; //; // This may not be required if we stop describing the contents of allocas; // using dbg.value(<alloca>, ..., DW_OP_deref), but we currently do this in; // the LowerDbgDeclare utility.; //; // If there is a dead store to `%a` in @trivially_inlinable_no_op, the; // ""arg0"" dbg.value may be stale after the call. However, failing to remove; // the DW_OP_deref dbg.value causes large gaps in location coverage.; //; // FIXME: the Assignment Tracking project has now likely made this; // redundant (and it's sometimes harmful).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:243,Performance,perform,performed,243,"/// Move the call to free before a NULL test.; ///; /// Check if this free is accessed after its argument has been test; /// against NULL (property 0).; /// If yes, it is legal to move this call in its predecessor block.; ///; /// The move is performed only if the block containing the call to free; /// will be removed, i.e.:; /// 1. it has only one predecessor P, and P has two successors; /// 2. it contains the call, noops, and an unconditional branch; /// 3. its successor is the same as its predecessor's successor; ///; /// The profitability is out-of concern here and this function should; /// be called only if the caller knows this transformation would be; /// profitable (e.g., for code size).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:78,Security,access,accessed,78,"/// Move the call to free before a NULL test.; ///; /// Check if this free is accessed after its argument has been test; /// against NULL (property 0).; /// If yes, it is legal to move this call in its predecessor block.; ///; /// The move is performed only if the block containing the call to free; /// will be removed, i.e.:; /// 1. it has only one predecessor P, and P has two successors; /// 2. it contains the call, noops, and an unconditional branch; /// 3. its successor is the same as its predecessor's successor; ///; /// The profitability is out-of concern here and this function should; /// be called only if the caller knows this transformation would be; /// profitable (e.g., for code size).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:40,Testability,test,test,40,"/// Move the call to free before a NULL test.; ///; /// Check if this free is accessed after its argument has been test; /// against NULL (property 0).; /// If yes, it is legal to move this call in its predecessor block.; ///; /// The move is performed only if the block containing the call to free; /// will be removed, i.e.:; /// 1. it has only one predecessor P, and P has two successors; /// 2. it contains the call, noops, and an unconditional branch; /// 3. its successor is the same as its predecessor's successor; ///; /// The profitability is out-of concern here and this function should; /// be called only if the caller knows this transformation would be; /// profitable (e.g., for code size).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:115,Testability,test,test,115,"/// Move the call to free before a NULL test.; ///; /// Check if this free is accessed after its argument has been test; /// against NULL (property 0).; /// If yes, it is legal to move this call in its predecessor block.; ///; /// The move is performed only if the block containing the call to free; /// will be removed, i.e.:; /// 1. it has only one predecessor P, and P has two successors; /// 2. it contains the call, noops, and an unconditional branch; /// 3. its successor is the same as its predecessor's successor; ///; /// The profitability is out-of concern here and this function should; /// be called only if the caller knows this transformation would be; /// profitable (e.g., for code size).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:74,Modifiability,extend,extend,74,"// Validate part of constraint #1: Only one predecessor; // FIXME: We can extend the number of predecessor, but in that case, we; // would duplicate the call to free in each predecessor and it may; // not be profitable even for code size.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:3,Security,Validat,Validate,3,"// Validate part of constraint #1: Only one predecessor; // FIXME: We can extend the number of predecessor, but in that case, we; // would duplicate the call to free in each predecessor and it may; // not be profitable even for code size.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:3,Security,Validat,Validate,3,"// Validate constraint #2: Does this block contains only the call to; // free, noops, and an unconditional branch?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:212,Performance,perform,performance,212,"// If there are only 2 instructions in the block, at this point,; // this is the call to free and unconditional.; // If there are more than 2 instructions, check that they are noops; // i.e., they won't hurt the performance of the generated code.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:3,Security,Validat,Validate,3,// Validate the rest of constraint #1 by matching on the pred branch.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:3,Security,Validat,Validate,3,// Validate constraint #3: Ensure the null case just falls through.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:9,Performance,optimiz,optimize,9,"// If we optimize for code size, try to move the call to free before the null; // test so that simplify cfg can remove the empty block and dead code; // elimination the branch. I.e., helps to turn something like:; // if (foo) free(foo);; // into; // free(foo);; //; // Note that we can only do this for 'free' and not for any flavor of; // 'operator delete'; there is no 'operator delete' symbol for which we are; // permitted to invent a call, even if we're passing in a null pointer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:82,Testability,test,test,82,"// If we optimize for code size, try to move the call to free before the null; // test so that simplify cfg can remove the empty block and dead code; // elimination the branch. I.e., helps to turn something like:; // if (foo) free(foo);; // into; // free(foo);; //; // Note that we can only do this for 'free' and not for any flavor of; // 'operator delete'; there is no 'operator delete' symbol for which we are; // permitted to invent a call, even if we're passing in a null pointer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:95,Usability,simpl,simplify,95,"// If we optimize for code size, try to move the call to free before the null; // test so that simplify cfg can remove the empty block and dead code; // elimination the branch. I.e., helps to turn something like:; // if (foo) free(foo);; // into; // free(foo);; //; // Note that we can only do this for 'free' and not for any flavor of; // 'operator delete'; there is no 'operator delete' symbol for which we are; // permitted to invent a call, even if we're passing in a null pointer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:30,Usability,Simpl,SimplifyCFGOpt,30,// WARNING: keep in sync with SimplifyCFGOpt::simplifyUnreachable()!,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:46,Usability,simpl,simplifyUnreachable,46,// WARNING: keep in sync with SimplifyCFGOpt::simplifyUnreachable()!,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:167,Usability,simpl,simple,167,"// Try to remove the previous instruction if it must lead to unreachable.; // This includes instructions like stores and ""llvm.assume"" that may not get; // removed by simple dead code elimination.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:16,Testability,log,logical-and-with-invert,16,"// Canonicalize logical-and-with-invert as logical-or-with-invert.; // This is done by inverting the condition and swapping successors:; // br (X && !Y), T, F --> br !(X && !Y), F, T --> br (!X || Y), F, T",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:43,Testability,log,logical-or-with-invert,43,"// Canonicalize logical-and-with-invert as logical-or-with-invert.; // This is done by inverting the condition and swapping successors:; // br (X && !Y), T, F --> br !(X && !Y), F, T --> br (!X || Y), F, T",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:37,Availability,mask,mask,37,"// If the shift may wrap, we need to mask off the shifted bits.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:20,Integrability,wrap,wrap,20,"// If the shift may wrap, we need to mask off the shifted bits.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:98,Usability,simpl,simplify,98,// We're extracting from an overflow intrinsic. See if we're the only user.; // That allows us to simplify multiple result intrinsics to simpler things; // that just get one value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:137,Usability,simpl,simpler,137,// We're extracting from an overflow intrinsic. See if we're the only user.; // That allows us to simplify multiple result intrinsics to simpler things; // that just get one value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:18,Integrability,wrap,wrap,18,"// Compute the no-wrap range for LHS given RHS=C, then construct an; // equivalent icmp, potentially using an offset.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:62,Usability,simpl,simply,62,"// The insert list is a prefix of the extract list; // We can simply remove the common indices from the extract and make it; // operate on the inserted value instead of the insertvalue result.; // i.e., replace; // %I = insertvalue { i32, { i32 } } %A, { i32 } { i32 42 }, 1; // %E = extractvalue { i32, { i32 } } %I, 1, 0; // with; // %E extractvalue { i32 } { i32 42 }, 0",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:38,Performance,scalab,scalable,38,// Bail out if the aggregate contains scalable vector type,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:99,Energy Efficiency,reduce,reduces,99,"// If the (non-volatile) load only has one use, we can rewrite this to a; // load from a GEP. This reduces the size of the load. If a load is used; // only by extractvalue instructions then this either must have been; // optimized before, or it is a struct with padding, in which case we; // don't want to do the transformation as it loses padding knowledge.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:55,Modifiability,rewrite,rewrite,55,"// If the (non-volatile) load only has one use, we can rewrite this to a; // load from a GEP. This reduces the size of the load. If a load is used; // only by extractvalue instructions then this either must have been; // optimized before, or it is a struct with padding, in which case we; // don't want to do the transformation as it loses padding knowledge.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:25,Performance,load,load,25,"// If the (non-volatile) load only has one use, we can rewrite this to a; // load from a GEP. This reduces the size of the load. If a load is used; // only by extractvalue instructions then this either must have been; // optimized before, or it is a struct with padding, in which case we; // don't want to do the transformation as it loses padding knowledge.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:77,Performance,load,load,77,"// If the (non-volatile) load only has one use, we can rewrite this to a; // load from a GEP. This reduces the size of the load. If a load is used; // only by extractvalue instructions then this either must have been; // optimized before, or it is a struct with padding, in which case we; // don't want to do the transformation as it loses padding knowledge.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:123,Performance,load,load,123,"// If the (non-volatile) load only has one use, we can rewrite this to a; // load from a GEP. This reduces the size of the load. If a load is used; // only by extractvalue instructions then this either must have been; // optimized before, or it is a struct with padding, in which case we; // don't want to do the transformation as it loses padding knowledge.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:134,Performance,load,load,134,"// If the (non-volatile) load only has one use, we can rewrite this to a; // load from a GEP. This reduces the size of the load. If a load is used; // only by extractvalue instructions then this either must have been; // optimized before, or it is a struct with padding, in which case we; // don't want to do the transformation as it loses padding knowledge.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:221,Performance,optimiz,optimized,221,"// If the (non-volatile) load only has one use, we can rewrite this to a; // load from a GEP. This reduces the size of the load. If a load is used; // only by extractvalue instructions then this either must have been; // optimized before, or it is a struct with padding, in which case we; // don't want to do the transformation as it loses padding knowledge.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:54,Performance,load,load,54,"// We need to insert these at the location of the old load, not at that of; // the extractvalue.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:56,Performance,load,load,56,"// Whatever aliasing information we had for the orignal load must also; // hold for the smaller load, so propagate the annotations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:96,Performance,load,load,96,"// Whatever aliasing information we had for the orignal load must also; // hold for the smaller load, so propagate the annotations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:17,Performance,load,load,17,"// Returning the load directly will cause the main loop to insert it in; // the wrong spot, so use replaceInstUsesWith().",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:320,Performance,load,loads,320,"// We could simplify extracts from other values. Note that nested extracts may; // already be simplified implicitly by the above: extract (extract (insert) ); // will be translated into extract ( insert ( extract ) ) first and then just; // the value inserted, if appropriate. Similarly for extracts from single-use; // loads: extract (extract (load)) will be translated to extract (load (gep)); // and if again single-use then via load (gep (gep)) to load (gep).; // However, double extracts from e.g. function arguments or return values; // aren't handled yet.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:345,Performance,load,load,345,"// We could simplify extracts from other values. Note that nested extracts may; // already be simplified implicitly by the above: extract (extract (insert) ); // will be translated into extract ( insert ( extract ) ) first and then just; // the value inserted, if appropriate. Similarly for extracts from single-use; // loads: extract (extract (load)) will be translated to extract (load (gep)); // and if again single-use then via load (gep (gep)) to load (gep).; // However, double extracts from e.g. function arguments or return values; // aren't handled yet.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:383,Performance,load,load,383,"// We could simplify extracts from other values. Note that nested extracts may; // already be simplified implicitly by the above: extract (extract (insert) ); // will be translated into extract ( insert ( extract ) ) first and then just; // the value inserted, if appropriate. Similarly for extracts from single-use; // loads: extract (extract (load)) will be translated to extract (load (gep)); // and if again single-use then via load (gep (gep)) to load (gep).; // However, double extracts from e.g. function arguments or return values; // aren't handled yet.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:432,Performance,load,load,432,"// We could simplify extracts from other values. Note that nested extracts may; // already be simplified implicitly by the above: extract (extract (insert) ); // will be translated into extract ( insert ( extract ) ) first and then just; // the value inserted, if appropriate. Similarly for extracts from single-use; // loads: extract (extract (load)) will be translated to extract (load (gep)); // and if again single-use then via load (gep (gep)) to load (gep).; // However, double extracts from e.g. function arguments or return values; // aren't handled yet.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:452,Performance,load,load,452,"// We could simplify extracts from other values. Note that nested extracts may; // already be simplified implicitly by the above: extract (extract (insert) ); // will be translated into extract ( insert ( extract ) ) first and then just; // the value inserted, if appropriate. Similarly for extracts from single-use; // loads: extract (extract (load)) will be translated to extract (load (gep)); // and if again single-use then via load (gep (gep)) to load (gep).; // However, double extracts from e.g. function arguments or return values; // aren't handled yet.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:12,Usability,simpl,simplify,12,"// We could simplify extracts from other values. Note that nested extracts may; // already be simplified implicitly by the above: extract (extract (insert) ); // will be translated into extract ( insert ( extract ) ) first and then just; // the value inserted, if appropriate. Similarly for extracts from single-use; // loads: extract (extract (load)) will be translated to extract (load (gep)); // and if again single-use then via load (gep (gep)) to load (gep).; // However, double extracts from e.g. function arguments or return values; // aren't handled yet.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:94,Usability,simpl,simplified,94,"// We could simplify extracts from other values. Note that nested extracts may; // already be simplified implicitly by the above: extract (extract (insert) ); // will be translated into extract ( insert ( extract ) ) first and then just; // the value inserted, if appropriate. Similarly for extracts from single-use; // loads: extract (extract (load)) will be translated to extract (load (gep)); // and if again single-use then via load (gep (gep)) to load (gep).; // However, double extracts from e.g. function arguments or return values; // aren't handled yet.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:86,Usability,clear,clear,86,"// The GCC C EH and Rust personality only exists to support cleanups, so; // it's not clear what the semantics of catch clauses are.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:7,Testability,log,logic,7,"// The logic here should be correct for any real-world personality function.; // However if that turns out not to be true, the offending logic can always; // be conditioned on the personality function, like the catch-all logic is.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:137,Testability,log,logic,137,"// The logic here should be correct for any real-world personality function.; // However if that turns out not to be true, the offending logic can always; // be conditioned on the personality function, like the catch-all logic is.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:221,Testability,log,logic,221,"// The logic here should be correct for any real-world personality function.; // However if that turns out not to be true, the offending logic can always; // be conditioned on the personality function, like the catch-all logic is.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:3,Usability,Simpl,Simplify,3,"// Simplify the list of clauses, eg by removing repeated catch clauses; // (these are often created by inlining).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:36,Availability,redundant,redundant,36,// Repeated catch clause - drop the redundant copy.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:36,Safety,redund,redundant,36,// Repeated catch clause - drop the redundant copy.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:212,Usability,simpl,simpler,212,"// An empty filter catches everything, so there is no point in keeping any; // following clauses or marking the landingpad as having a cleanup. By; // dealing with this case here the following code is made a bit simpler.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:321,Performance,optimiz,optimizations,321,"// If several filters occur in a row then reorder them so that the shortest; // filters come first (those with the smallest number of elements). This is; // advantageous because shorter filters are more likely to match, speeding up; // unwinding, but mostly because it increases the effectiveness of the other; // filter optimizations below.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:359,Performance,perform,perform,359,"// If typeinfos matched if and only if equal, then the elements of a filter L; // that occurs later than a filter F could be replaced by the intersection of; // the elements of F and L. In reality two typeinfos can match without being; // equal (for example if one represents a C++ class, and the other some class; // derived from it) so it would be wrong to perform this transform in general.; // However the transform is correct and useful if F is a subset of L. In that; // case L can be replaced by F, and thus removed altogether since repeating a; // filter is pointless. So here we look at all pairs of filters F and L where; // L follows F in the list of clauses, and remove L if every element of F is; // an element of L. This can occur when inlining C++ functions with exception; // specifications.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:115,Usability,Clear,Clear,115,"// Even if none of the clauses changed, we may nonetheless have understood; // that the cleanup flag is pointless. Clear it if so.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:95,Energy Efficiency,reduce,reduces,95,"// While we could change the other users of OrigOp to use freeze(OrigOp), that; // potentially reduces their optimization potential, so let's only do this iff; // the OrigOp is only used by the freeze.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:109,Performance,optimiz,optimization,109,"// While we could change the other users of OrigOp to use freeze(OrigOp), that; // potentially reduces their optimization potential, so let's only do this iff; // the OrigOp is only used by the freeze.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:137,Usability,simpl,simply,137,"// We can't push the freeze through an instruction which can itself create; // poison. If the only source of new poison is flags, we can simply; // strip them (since we know the only use is the freeze and nothing can; // benefit from them.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:3,Safety,Detect,Detect,3,"// Detect whether this is a recurrence with a start value and some number of; // backedge values. We'll check whether we can push the freeze through the; // backedge values (possibly dropping poison flags along the way) until we; // reach the phi again. In that case, we can move the freeze to the start; // value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:541,Safety,avoid,avoid,541,"// If I is freeze(undef), check its uses and fold it to a fixed constant.; // - or: pick -1; // - select's condition: if the true value is constant, choose it by making; // the condition true.; // - default: pick 0; //; // Note that this transform is intentionally done here rather than; // via an analysis in InstSimplify or at individual user sites. That is; // because we must produce the same value for all uses of the freeze -; // it's the reason ""freeze"" exists!; //; // TODO: This could use getBinopAbsorber() / getBinopIdentity() to avoid; // duplicating logic for binops at least.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:563,Testability,log,logic,563,"// If I is freeze(undef), check its uses and fold it to a fixed constant.; // - or: pick -1; // - select's condition: if the true value is constant, choose it by making; // the condition true.; // - default: pick 0; //; // Note that this transform is intentionally done here rather than; // via an analysis in InstSimplify or at individual user sites. That is; // because we must produce the same value for all uses of the freeze -; // it's the reason ""freeze"" exists!; //; // TODO: This could use getBinopAbsorber() / getBinopIdentity() to avoid; // duplicating logic for binops at least.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:67,Modifiability,extend,extend,67,"// TODO: handle e.g. store to alloca here - only worth doing if we extend; // to allow reload along used path as described below. Otherwise, this; // is simply a store to a dead allocation which will be removed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:153,Usability,simpl,simply,153,"// TODO: handle e.g. store to alloca here - only worth doing if we extend; // to allow reload along used path as described below. Otherwise, this; // is simply a store to a dead allocation which will be removed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:22,Security,access,access,22,"// TODO: allow memory access dominated by move point? Note that since AI; // could have a reference to itself captured by the call, we would need to; // account for cycles in doing so.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:133,Safety,safe,safe,133,"/// Try to move the specified instruction from its current block into the; /// beginning of DestBlock, which can only happen if it's safe to move the; /// instruction past all of the instructions between it and the end of its; /// block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:48,Performance,load,loads,48,"// Cannot move control-flow-involving, volatile loads, vaarg, etc.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:20,Performance,load,load,20,// We can only sink load instructions if there is nothing between the load and; // the end of block that could change the value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:70,Performance,load,load,70,// We can only sink load instructions if there is nothing between the load and; // the end of block that could change the value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:175,Modifiability,variab,variables,175,"// Also sink all related debug uses from the source basic block. Otherwise we; // get debug use before the def. Attempt to salvage debug uses first, to; // maximise the range variables have location for. If we cannot salvage, then; // mark the location undef: we know it was supposed to receive a new location; // here, but that computation has been sunk.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:89,Availability,avail,available,89,"// For all debug values in the destination block, the sunk instruction; // will still be available, so they do not need to be dropped.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:138,Modifiability,variab,variable,138,"// Process the sinking DbgUsersToSalvage in reverse order, as we only want; // to clone the last appearing debug intrinsic for each given variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:87,Modifiability,variab,variable,87,"// A dbg.declare instruction should not be cloned, since there can only be; // one per variable fragment. It should be left in the original place; // because the sunk instruction is not an alloca (otherwise we could not be; // here).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:3,Performance,Perform,Perform,3,"// Perform salvaging without the clones, then sink the clones.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:78,Energy Efficiency,reduce,reduce,78,"// Check to see if we can DCE the instruction. We do this already here to; // reduce the number of uses and thus allow other folds to trigger.; // Note that eraseInstFromFunction() may push additional instructions on; // the deferred worklist, so this will DCE whole instruction chains.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:87,Usability,Simpl,SimplifyCFG,87,"// Try sinking to another block. If that block is unreachable, then do; // not bother. SimplifyCFG should handle it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:417,Availability,down,down,417,"// See if the user is one of our successors that has only one; // predecessor, so that we don't have to split the critical edge.; // Another option where we can sink is a block that ends with a; // terminator that does not pass control to other block (such as; // return or unreachable or resume). In this case:; // - I dominates the User (by SSA form);; // - the User will be executed at most once.; // So sinking I down to User is always profitable or neutral.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:289,Usability,resume,resume,289,"// See if the user is one of our successors that has only one; // predecessor, so that we don't have to split the critical edge.; // Another option where we can sink is a block that ends with a; // terminator that does not pass control to other block (such as; // return or unreachable or resume). In this case:; // - I dominates the User (by SSA form);; // - the User will be executed at most once.; // So sinking I down to User is always profitable or neutral.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:20,Usability,simpl,simple,20,"// Okay, the CFG is simple enough, try to sink this instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:75,Security,expose,expose,75,"// We'll add uses of the sunk instruction below, but since; // sinking can expose opportunities for it's *operands* add; // them to the worklist",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:56,Usability,simpl,simplify,56,"// Now that we have an instruction, try combining it to simplify it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:213,Safety,safe,safely,213,"// Track the scopes used by !alias.scope and !noalias. In a function, a; // @llvm.experimental.noalias.scope.decl is only useful if that scope is used; // by both sets. If not, the declaration of the scope can be safely omitted.; // The MDNode of the scope can be omitted as well for the instructions that are; // part of this function. We do not do that at this point, as this might become; // too time consuming to do.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:205,Energy Efficiency,power,powerful,205,"/// Populate the IC worklist from a function, by walking it in reverse; /// post-order and adding all reachable code to the worklist.; ///; /// This has a couple of tricks to make the code faster and more powerful. In; /// particular, we constant fold and DCE instructions as we go, to avoid adding; /// them to the worklist (this significantly speeds up instcombine on code where; /// many instructions are dead or constant). Additionally, if we find a branch; /// whose condition is a known constant, we only visit the reachable successors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:286,Safety,avoid,avoid,286,"/// Populate the IC worklist from a function, by walking it in reverse; /// post-order and adding all reachable code to the worklist.; ///; /// This has a couple of tricks to make the code faster and more powerful. In; /// particular, we constant fold and DCE instructions as we go, to avoid adding; /// them to the worklist (this significantly speeds up instcombine on code where; /// many instructions are dead or constant). Additionally, if we find a branch; /// whose condition is a known constant, we only visit the reachable successors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:172,Performance,optimiz,optimization,172,// Skip processing debug and pseudo intrinsics in InstCombine. Processing; // these call instructions consumes non-trivial amount of time and; // provides no value for the optimization.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:146,Energy Efficiency,reduce,reduces,146,"// Remove instructions inside unreachable blocks. This prevents the; // instcombine code from having to deal with some bad special cases, and; // reduces use counts of instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:174,Availability,down,down,174,"// Once we've found all of the instructions to add to instcombine's worklist,; // add them in reverse order. This way instcombine will visit from the top; // of the function down. This jives well with the way that it adds all uses; // of instructions to the worklist after doing a transformation, thus avoiding; // some N^2 behavior in pathological cases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:302,Safety,avoid,avoiding,302,"// Once we've found all of the instructions to add to instcombine's worklist,; // add them in reverse order. This way instcombine will visit from the top; // of the function down. This jives well with the way that it adds all uses; // of instructions to the worklist after doing a transformation, thus avoiding; // some N^2 behavior in pathological cases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:98,Deployability,pipeline,pipeline,98,// TODO: Only use LoopInfo when the option is set. This requires that the; // callers in the pass pipeline explicitly set the option.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:42,Deployability,update,updates,42,// Mark all the analyses that instcombine updates as preserved.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:18,Integrability,Rout,Routines,18,// Initialization Routines,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:37,Availability,error,error,37,"//===- AddressSanitizer.cpp - memory error detector -----------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file is a part of AddressSanitizer, an address basic correctness; // checker.; // Details of the algorithm:; // https://github.com/google/sanitizers/wiki/AddressSanitizerAlgorithm; //; // FIXME: This sanitizer does not yet handle scalable vectors; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:618,Performance,scalab,scalable,618,"//===- AddressSanitizer.cpp - memory error detector -----------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file is a part of AddressSanitizer, an address basic correctness; // checker.; // Details of the algorithm:; // https://github.com/google/sanitizers/wiki/AddressSanitizerAlgorithm; //; // FIXME: This sanitizer does not yet handle scalable vectors; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:43,Safety,detect,detector,43,"//===- AddressSanitizer.cpp - memory error detector -----------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file is a part of AddressSanitizer, an address basic correctness; // checker.; // Details of the algorithm:; // https://github.com/google/sanitizers/wiki/AddressSanitizerAlgorithm; //; // FIXME: This sanitizer does not yet handle scalable vectors; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:526,Security,sanitiz,sanitizers,526,"//===- AddressSanitizer.cpp - memory error detector -----------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file is a part of AddressSanitizer, an address basic correctness; // checker.; // Details of the algorithm:; // https://github.com/google/sanitizers/wiki/AddressSanitizerAlgorithm; //; // FIXME: This sanitizer does not yet handle scalable vectors; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:588,Security,sanitiz,sanitizer,588,"//===- AddressSanitizer.cpp - memory error detector -----------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file is a part of AddressSanitizer, an address basic correctness; // checker.; // Details of the algorithm:; // https://github.com/google/sanitizers/wiki/AddressSanitizerAlgorithm; //; // FIXME: This sanitizer does not yet handle scalable vectors; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:42,Energy Efficiency,allocate,allocated,42,// The shadow memory space is dynamically allocated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:22,Energy Efficiency,power,powers,22,"// Accesses sizes are powers of two: 1, 2, 4, 8, 16.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:3,Security,Access,Accesses,3,"// Accesses sizes are powers of two: 1, 2, 4, 8, 16.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:3,Performance,Optimiz,Optimization,3,"// Optimization flags. Not user visible, used mostly for testing; // and benchmarking the tool.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:57,Testability,test,testing,57,"// Optimization flags. Not user visible, used mostly for testing; // and benchmarking the tool.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:73,Testability,benchmark,benchmarking,73,"// Optimization flags. Not user visible, used mostly for testing; // and benchmarking the tool.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:111,Availability,avail,available,111,"// LongSize == 64; // Fuchsia is always PIE, which means that the beginning of the address; // space is always available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:32,Energy Efficiency,efficient,efficient,32,"// OR-ing shadow offset if more efficient (at least on x86) if the offset; // is a power of two, but on ppc64 and loongarch64 we have to use add since; // the shadow offset is not necessarily 1/8-th of the address space. On; // SystemZ, we could OR the constant in a single instruction, but it's more; // efficient to load it once and use indexed addressing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:83,Energy Efficiency,power,power,83,"// OR-ing shadow offset if more efficient (at least on x86) if the offset; // is a power of two, but on ppc64 and loongarch64 we have to use add since; // the shadow offset is not necessarily 1/8-th of the address space. On; // SystemZ, we could OR the constant in a single instruction, but it's more; // efficient to load it once and use indexed addressing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:305,Energy Efficiency,efficient,efficient,305,"// OR-ing shadow offset if more efficient (at least on x86) if the offset; // is a power of two, but on ppc64 and loongarch64 we have to use add since; // the shadow offset is not necessarily 1/8-th of the address space. On; // SystemZ, we could OR the constant in a single instruction, but it's more; // efficient to load it once and use indexed addressing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:318,Performance,load,load,318,"// OR-ing shadow offset if more efficient (at least on x86) if the offset; // is a power of two, but on ppc64 and loongarch64 we have to use add since; // the shadow offset is not necessarily 1/8-th of the address space. On; // SystemZ, we could OR the constant in a single instruction, but it's more; // efficient to load it once and use indexed addressing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:30,Security,Access,AccessIsWrite,30,"// These arrays is indexed by AccessIsWrite, Experiment and log2(AccessSize).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:65,Security,Access,AccessSize,65,"// These arrays is indexed by AccessIsWrite, Experiment and log2(AccessSize).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:30,Security,Access,AccessIsWrite,30,// These arrays is indexed by AccessIsWrite and Experiment.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:41,Availability,down,downside,41,// Enable aliases as they should have no downside with ODR indicators.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:439,Performance,load,load,439,"// Stack poisoning does not play well with exception handling.; // When an exception is thrown, we essentially bypass the code; // that unpoisones the stack. This is why the run-time library has; // to intercept __cxa_throw (as well as longjmp, etc) and unpoison the entire; // stack in the interceptor. This however does not work inside the; // actual function which catches the exception. Most likely because the; // compiler hoists the load of the shadow value somewhere too high.; // This causes asan to report a non-existing bug on 453.povray.; // It sounds like an LLVM bug.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:115,Modifiability,variab,variable,115,"// If there are lifetime intrinsics which couldn't be traced back to an; // alloca, we may not know exactly when a variable enters scope, and; // therefore should ""fail safe"" by not poisoning them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:169,Safety,safe,safe,169,"// If there are lifetime intrinsics which couldn't be traced back to an; // alloca, we may not know exactly when a variable enters scope, and; // therefore should ""fail safe"" by not poisoning them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:194,Energy Efficiency,allocate,allocated,194,"// Arguments marked with the ""byval"" attribute are implicitly copied without; // using an alloca instruction. To produce redzones for those arguments, we; // copy them a second time into memory allocated with an alloca instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:16,Usability,Resume,Resume,16,/// Collect all Resume instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:3,Deployability,Deploy,Deploy,3,"// Deploy and poison redzones around dynamic alloca call. To do this, we; // should replace this call with another one with changed parameters and; // replace all its uses with new address, so; // addr = alloca type, old_size, align; // is replaced by; // new_size = (old_size + additional_size) * sizeof(type); // tmp = alloca i8, new_size, max(align, 32); // addr = tmp + 32 (first 32 bytes are for the left redzone).; // Additional_size is added to make new memory allocation contain not only; // requested memory, but also left, partial and right redzones.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:17,Performance,scalab,scalable,17,// FIXME: Handle scalable vectors instead of ignoring them.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:71,Availability,error,errors,71,/// Collect lifetime intrinsic calls to check for use-after-scope; /// errors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:142,Security,Sanitiz,Sanitizers,142,// GlobalsAA is considered stateless and does not get invalidated unless; // explicitly invalidated; PreservedAnalyses::none() is not enough. Sanitizers; // make changes that require GlobalsAA to be invalidated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:53,Security,sanitiz,sanitizer,53,// Do not instrument rtti proxy symbols for function sanitizer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:3,Safety,safe,safe,3,// safe allocas are not interesting,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:14,Security,access,accesses,14,// Instrument accesses from different address spaces only for AMDGPU.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:16,Security,access,accesses,16,// Treat memory accesses to promotable allocas as non-interesting since they; // will not cause memory violations. This greatly speeds up the instrumented; // executable at -O0.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:25,Performance,load,load,25,// Do not instrument the load fetching the dynamic shadow address.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:3,Availability,Mask,Masked,3,// Masked store has an initial operand for the value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:23,Availability,Mask,Mask,23,// Use the popcount of Mask as the effective vector length.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:15,Modifiability,variab,variable,15,"// If a global variable does not have dynamic initialization we don't; // have to instrument it. However, if a global does not have initializer; // at all, we assume it has dynamic initializer (in other TU).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:44,Security,access,access,44,"// Instrument a 1-, 2-, 4-, 8-, or 16- byte access with one check; // if the data is properly aligned.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:6,Safety,avoid,avoid,6,"// To avoid undefined behavior for extracting with out of range index, use; // the minimum of evl and element count as trip count.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:245,Availability,mask,mask,245,"// Optimization experiments.; // The experiments can be used to evaluate potential optimizations that remove; // instrumentation (assess false negatives). Instead of completely removing; // some instrumentation, you set Exp to a non-zero value (mask of optimization; // experiments that want to remove instrumentation of this instruction).; // If Exp is non-zero, this pass will emit special calls into runtime; // (e.g. __asan_report_exp_load1 instead of __asan_report_load1). These calls; // make runtime terminate the program in a special way (with a different; // exit status). Then you run the new compiler on a buggy corpus, collect; // the special terminations (ideally, you don't see them at all -- no false; // negatives) and make the decision on the optimization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:3,Performance,Optimiz,Optimization,3,"// Optimization experiments.; // The experiments can be used to evaluate potential optimizations that remove; // instrumentation (assess false negatives). Instead of completely removing; // some instrumentation, you set Exp to a non-zero value (mask of optimization; // experiments that want to remove instrumentation of this instruction).; // If Exp is non-zero, this pass will emit special calls into runtime; // (e.g. __asan_report_exp_load1 instead of __asan_report_load1). These calls; // make runtime terminate the program in a special way (with a different; // exit status). Then you run the new compiler on a buggy corpus, collect; // the special terminations (ideally, you don't see them at all -- no false; // negatives) and make the decision on the optimization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:83,Performance,optimiz,optimizations,83,"// Optimization experiments.; // The experiments can be used to evaluate potential optimizations that remove; // instrumentation (assess false negatives). Instead of completely removing; // some instrumentation, you set Exp to a non-zero value (mask of optimization; // experiments that want to remove instrumentation of this instruction).; // If Exp is non-zero, this pass will emit special calls into runtime; // (e.g. __asan_report_exp_load1 instead of __asan_report_load1). These calls; // make runtime terminate the program in a special way (with a different; // exit status). Then you run the new compiler on a buggy corpus, collect; // the special terminations (ideally, you don't see them at all -- no false; // negatives) and make the decision on the optimization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:253,Performance,optimiz,optimization,253,"// Optimization experiments.; // The experiments can be used to evaluate potential optimizations that remove; // instrumentation (assess false negatives). Instead of completely removing; // some instrumentation, you set Exp to a non-zero value (mask of optimization; // experiments that want to remove instrumentation of this instruction).; // If Exp is non-zero, this pass will emit special calls into runtime; // (e.g. __asan_report_exp_load1 instead of __asan_report_load1). These calls; // make runtime terminate the program in a special way (with a different; // exit status). Then you run the new compiler on a buggy corpus, collect; // the special terminations (ideally, you don't see them at all -- no false; // negatives) and make the decision on the optimization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:760,Performance,optimiz,optimization,760,"// Optimization experiments.; // The experiments can be used to evaluate potential optimizations that remove; // instrumentation (assess false negatives). Instead of completely removing; // some instrumentation, you set Exp to a non-zero value (mask of optimization; // experiments that want to remove instrumentation of this instruction).; // If Exp is non-zero, this pass will emit special calls into runtime; // (e.g. __asan_report_exp_load1 instead of __asan_report_load1). These calls; // make runtime terminate the program in a special way (with a different; // exit status). Then you run the new compiler on a buggy corpus, collect; // the special terminations (ideally, you don't see them at all -- no false; // negatives) and make the decision on the optimization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:58,Security,access,access,58,"// If initialization order checking is disabled, a simple access to a; // dynamically initialized global is always valid.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:51,Usability,simpl,simple,51,"// If initialization order checking is disabled, a simple access to a; // dynamically initialized global is always valid.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:39,Modifiability,variab,variable,39,// A direct inbounds access to a stack variable is always valid.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:21,Security,access,access,21,// A direct inbounds access to a stack variable is always valid.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:137,Testability,benchmark,benchmarks,137,"// We use branch weights for the slow path check, to indicate that the slow; // path is rarely taken. This seems to be the case for SPEC benchmarks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:230,Security,access,access,230,"// Instrument unusual size or unusual alignment.; // We can not do it with a single check, so we do 1-byte check for the first; // and the last bytes. We call __asan_report_*_n(addr, real_size) to be able; // to report the actual access size.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:63,Modifiability,variab,variables,63,"// The kernel uses explicit sections for mostly special global variables; // that we should not instrument. E.g. the kernel may rely on their layout; // without redzones, or remove them at link time (""discard.*""), etc.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:77,Integrability,rout,routines,77,// Do not instrument function pointers to initialization and termination; // routines: dynamic linker will not properly handle redzones.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:414,Security,access,accesses,414,"// On COFF, if the section name contains '$', it is highly likely that the; // user is using section sorting to create an array of globals similar to; // the way initialization callbacks are registered in .init_array and; // .CRT$XCU. The ATL also registers things in .ATL$__[azm]. Adding redzones; // to such globals is counterproductive, because the intent is that they; // will form an array, and out-of-bounds accesses are expected.; // See https://github.com/google/sanitizers/issues/305; // and http://msdn.microsoft.com/en-US/en-en/library/bb918180(v=vs.120).aspx",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:471,Security,sanitiz,sanitizers,471,"// On COFF, if the section name contains '$', it is highly likely that the; // user is using section sorting to create an array of globals similar to; // the way initialization callbacks are registered in .init_array and; // .CRT$XCU. The ATL also registers things in .ATL$__[azm]. Adding redzones; // to such globals is counterproductive, because the intent is that they; // will form an array, and out-of-bounds accesses are expected.; // See https://github.com/google/sanitizers/issues/305; // and http://msdn.microsoft.com/en-US/en-en/library/bb918180(v=vs.120).aspx",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:33,Security,sanitiz,sanitizers,33,"// See https://github.com/google/sanitizers/issues/32; // Constant CFString instances are compiled in the following way:; // -- the string buffer is emitted into; // __TEXT,__cstring,cstring_literals; // -- the constant NSConstantString structure referencing that buffer; // is placed into __DATA,__cfstring; // Therefore there's no point in placing redzones into __DATA,__cfstring.; // Moreover, it causes the linker to crash on OS X 10.7",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:60,Deployability,upgrade,upgrade,60,// Make this IMAGE_COMDAT_SELECT_NODUPLICATES on COFF. Also upgrade private; // linkage to internal linkage so that a symbol table entry is emitted. This; // is necessary in order to create the comdat group.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:145,Energy Efficiency,power,power,145,"// The MSVC linker always inserts padding when linking incrementally. We; // cope with that by aligning each struct to its size, which must be a power; // of two.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:122,Availability,alive,alive,122,"// Update llvm.compiler.used, adding the new metadata globals. This is; // needed so that during LTO these variables stay alive.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:3,Deployability,Update,Update,3,"// Update llvm.compiler.used, adding the new metadata globals. This is; // needed so that during LTO these variables stay alive.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:107,Modifiability,variab,variables,107,"// Update llvm.compiler.used, adding the new metadata globals. This is; // needed so that during LTO these variables stay alive.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:122,Availability,alive,alive,122,"// Update llvm.compiler.used, adding the new metadata globals. This is; // needed so that during LTO these variables stay alive.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:3,Deployability,Update,Update,3,"// Update llvm.compiler.used, adding the new metadata globals. This is; // needed so that during LTO these variables stay alive.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:107,Modifiability,variab,variables,107,"// Update llvm.compiler.used, adding the new metadata globals. This is; // needed so that during LTO these variables stay alive.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:92,Performance,load,loaded,92,"// RegisteredFlag serves two purposes. First, we can pass it to dladdr(); // to look up the loaded image that contains it. Second, we can store in it; // whether registration has already occurred, to prevent duplicate; // registration.; //; // Common linkage ensures that there is only one global per shared library.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:90,Modifiability,variab,variable,90,"// On recent Mach-O platforms, use a structure which binds the liveness of; // the global variable to the metadata struct. Keep the list of ""Liveness"" GV; // created to be added to llvm.compiler.used",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:122,Availability,alive,alive,122,"// Update llvm.compiler.used, adding the new liveness globals. This is; // needed so that during LTO these variables stay alive. The alternative; // would be to have the linker handling the LTO symbols, but libLTO; // current API does not expose access to the section for each symbol.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:3,Deployability,Update,Update,3,"// Update llvm.compiler.used, adding the new liveness globals. This is; // needed so that during LTO these variables stay alive. The alternative; // would be to have the linker handling the LTO symbols, but libLTO; // current API does not expose access to the section for each symbol.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:107,Modifiability,variab,variables,107,"// Update llvm.compiler.used, adding the new liveness globals. This is; // needed so that during LTO these variables stay alive. The alternative; // would be to have the linker handling the LTO symbols, but libLTO; // current API does not expose access to the section for each symbol.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:239,Security,expose,expose,239,"// Update llvm.compiler.used, adding the new liveness globals. This is; // needed so that during LTO these variables stay alive. The alternative; // would be to have the linker handling the LTO symbols, but libLTO; // current API does not expose access to the section for each symbol.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:246,Security,access,access,246,"// Update llvm.compiler.used, adding the new liveness globals. This is; // needed so that during LTO these variables stay alive. The alternative; // would be to have the linker handling the LTO symbols, but libLTO; // current API does not expose access to the section for each symbol.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:92,Performance,load,loaded,92,"// RegisteredFlag serves two purposes. First, we can pass it to dladdr(); // to look up the loaded image that contains it. Second, we can store in it; // whether registration has already occurred, to prevent duplicate; // registration.; //; // common linkage ensures that there is only one global per shared library.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:37,Modifiability,variab,variables,37,// This function replaces all global variables with new variables that have; // trailing redzones. It also creates a function that poisons; // redzones and inserts this function into llvm.global_ctors.; // Sets *CtorComdat to true if the global registration code emitted into the; // asan constructor is comdat-compatible.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:56,Modifiability,variab,variables,56,// This function replaces all global variables with new variables that have; // trailing redzones. It also creates a function that poisons; // redzones and inserts this function into llvm.global_ctors.; // Sets *CtorComdat to true if the global registration code emitted into the; // asan constructor is comdat-compatible.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:23,Modifiability,variab,variable,23,// Create a new global variable with enough space for a redzone.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:107,Integrability,depend,dependence,107,"// Don't fold globals with redzones. ODR violation detector and redzone; // poisoning implicitly creates a dependence on the global's address, so it; // is no longer valid for it to be marked unnamed_addr.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:51,Safety,detect,detector,51,"// Don't fold globals with redzones. ODR violation detector and redzone; // poisoning implicitly creates a dependence on the global's address, so it; // is no longer valid for it to be marked unnamed_addr.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:39,Safety,avoid,avoid,39,// Create local alias for NewGlobal to avoid crash on ODR between; // instrumented and non-instrumented libraries.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:98,Safety,detect,detect,98,"// With local aliases, we need to provide another externally visible; // symbol __odr_asan_XXX to detect ODR violation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:58,Safety,avoid,avoid,58,// Add instrumented globals to llvm.compiler.used list to avoid LTO from; // ConstantMerge'ing them.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:3,Energy Efficiency,Reduce,Reduce,3,"// Reduce redzone size for small size objects, e.g. int, char[1]. MinRZ is; // at least 32 bytes, optimize when SizeInBytes is less than or equal to; // half of MinRZ.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:98,Performance,optimiz,optimize,98,"// Reduce redzone size for small size objects, e.g. int, char[1]. MinRZ is; // at least 32 bytes, optimize when SizeInBytes is less than or equal to; // half of MinRZ.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:42,Performance,load,load,42,"// For each NSObject descendant having a +load method, this method is invoked; // by the ObjC runtime before any of the static constructors is called.; // Therefore we need to instrument such methods with a call to __asan_init; // at the beginning in order to initialize our runtime before any access to; // the shadow memory.; // We cannot just ignore these methods, because they may call other; // instrumented functions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:294,Security,access,access,294,"// For each NSObject descendant having a +load method, this method is invoked; // by the ObjC runtime before any of the static constructors is called.; // Therefore we need to instrument such methods with a call to __asan_init; // at the beginning in order to initialize our runtime before any access to; // the shadow memory.; // We cannot just ignore these methods, because they may call other; // instrumented functions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:53,Security,Sanitiz,SanitizeAddress,53,"// If needed, insert __asan_init before checking for SanitizeAddress attr.; // This function needs to be called even if the function body is not; // instrumented.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:16,Availability,mask,mask,16,"// If we have a mask, skip instrumentation if we've already; // instrumented the full object. But don't add to TempsToInstrument; // because we might get another load/store with a different mask.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:190,Availability,mask,mask,190,"// If we have a mask, skip instrumentation if we've already; // instrumented the full object. But don't add to TempsToInstrument; // because we might get another load/store with a different mask.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:162,Performance,load,load,162,"// If we have a mask, skip instrumentation if we've already; // instrumented the full object. But don't add to TempsToInstrument; // because we might get another load/store with a different mask.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:112,Security,sanitiz,sanitizers,112,"// We must unpoison the stack before NoReturn calls (throw, _exit, etc).; // See e.g. https://github.com/google/sanitizers/issues/37",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:78,Energy Efficiency,power,power,78,// Fake stack allocator (asan_fake_stack.h) has 11 size classes; // for every power of 2 from kMinStackMallocSize to kMaxAsanStackMallocSizeClass,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:3,Deployability,Update,Update,3,// Update SVD with information from lifetime intrinsics.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:133,Availability,avail,available,133,"// Don't do dynamic alloca or stack malloc if:; // 1) There is inline asm: too often it makes assumptions on which registers; // are available.; // 2) There is a returns_twice call (typically setjmp), which is; // optimization-hostile, and doesn't play well with introduced indirect; // register-relative calculation of local variable addresses.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:326,Modifiability,variab,variable,326,"// Don't do dynamic alloca or stack malloc if:; // 1) There is inline asm: too often it makes assumptions on which registers; // are available.; // 2) There is a returns_twice call (typically setjmp), which is; // optimization-hostile, and doesn't play well with introduced indirect; // register-relative calculation of local variable addresses.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:214,Performance,optimiz,optimization-hostile,214,"// Don't do dynamic alloca or stack malloc if:; // 1) There is inline asm: too often it makes assumptions on which registers; // are available.; // 2) There is a returns_twice call (typically setjmp), which is; // optimization-hostile, and doesn't play well with introduced indirect; // register-relative calculation of local variable addresses.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:3,Testability,assert,assert,3,// assert(ASan.UseAfterReturn == AsanDetectStackUseAfterReturnMode:Always); // void *FakeStack = __asan_stack_malloc_N(LocalStackSize);; // void *LocalStackBase = (FakeStack) ? FakeStack :; // alloca(LocalStackSize);,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:193,Modifiability,variab,variable,193,"// It shouldn't matter whether we pass an `alloca` or a `ptrtoint` as the; // dbg.declare address opereand, but passing a `ptrtoint` seems to confuse; // later passes and can result in dropped variable coverage in debug info.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:6,Availability,mask,mask,6,// As mask we must use most poisoned case: red zones and after scope.; // As bytes we can use either the same or just red zones only.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:361,Modifiability,variab,variable,361,"// Handling llvm.lifetime intrinsics for a given %alloca:; // (1) collect all llvm.lifetime.xxx(%size, %value) describing the alloca.; // (2) if %size is constant, poison memory for llvm.lifetime.end (to detect; // invalid accesses) and unpoison it for llvm.lifetime.start (the memory; // could be poisoned by previous llvm.lifetime.end instruction, as the; // variable may go in and out of scope several times, e.g. in loops).; // (3) if we poisoned at least one %alloca in a function,; // unpoison the whole stack frame at function exit.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:204,Safety,detect,detect,204,"// Handling llvm.lifetime intrinsics for a given %alloca:; // (1) collect all llvm.lifetime.xxx(%size, %value) describing the alloca.; // (2) if %size is constant, poison memory for llvm.lifetime.end (to detect; // invalid accesses) and unpoison it for llvm.lifetime.start (the memory; // could be poisoned by previous llvm.lifetime.end instruction, as the; // variable may go in and out of scope several times, e.g. in loops).; // (3) if we poisoned at least one %alloca in a function,; // unpoison the whole stack frame at function exit.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:223,Security,access,accesses,223,"// Handling llvm.lifetime intrinsics for a given %alloca:; // (1) collect all llvm.lifetime.xxx(%size, %value) describing the alloca.; // (2) if %size is constant, poison memory for llvm.lifetime.end (to detect; // invalid accesses) and unpoison it for llvm.lifetime.start (the memory; // could be poisoned by previous llvm.lifetime.end instruction, as the; // variable may go in and out of scope several times, e.g. in loops).; // (3) if we poisoned at least one %alloca in a function,; // unpoison the whole stack frame at function exit.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:106,Energy Efficiency,allocate,allocated,106,"// Since we need to extend alloca with additional memory to locate; // redzones, and OldSize is number of allocated blocks with; // ElementSize size, get allocated memory size in bytes by; // OldSize * ElementSize.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:154,Energy Efficiency,allocate,allocated,154,"// Since we need to extend alloca with additional memory to locate; // redzones, and OldSize is number of allocated blocks with; // ElementSize size, get allocated memory size in bytes by; // OldSize * ElementSize.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:20,Modifiability,extend,extend,20,"// Since we need to extend alloca with additional memory to locate; // redzones, and OldSize is number of allocated blocks with; // ElementSize size, get allocated memory size in bytes by; // OldSize * ElementSize.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:120,Security,access,access,120,"// isSafeAccess returns true if Addr is always inbounds with respect to its; // base object. For example, it is a field access or an array access with; // constant inbounds index.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:139,Security,access,access,139,"// isSafeAccess returns true if Addr is always inbounds with respect to its; // base object. For example, it is a field access or an array access with; // constant inbounds index.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:46,Performance,scalab,scalable,46,// TODO: We can use vscale_range to convert a scalable value to an; // upper bound on the access size.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:90,Security,access,access,90,// TODO: We can use vscale_range to convert a scalable value to an; // upper bound on the access size.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:39,Safety,safe,safety,39,// Three checks are required to ensure safety:; // . Offset >= 0 (since the offset is given from the base ptr); // . Size >= Offset (unsigned); // . Size - Offset >= NeededSize (unsigned),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/BlockCoverageInference.cpp:46,Safety,avoid,avoiding,46,// The set of blocks that are reachable while avoiding BB.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/BlockCoverageInference.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/BlockCoverageInference.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/BlockCoverageInference.cpp:47,Usability,clear,clearing,47,// Force the entry block to be instrumented by clearing the blocks it can; // infer coverage from.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/BlockCoverageInference.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/BlockCoverageInference.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/BlockCoverageInference.cpp:73,Integrability,depend,dependency,73,// Construct a graph where blocks are connected if there is a mutual; // dependency between them. This graph has a special property that it contains; // only paths.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/BlockCoverageInference.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/BlockCoverageInference.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/BoundsChecking.cpp:190,Performance,load,load,190,"/// Gets the conditions under which memory accessing instructions will overflow.; ///; /// \p Ptr is the pointer that will be read/written, and \p InstVal is either; /// the result from the load or the value being stored. It is used to determine; /// the size of memory block that is touched.; ///; /// Returns the condition under which the access will overflow.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/BoundsChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/BoundsChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/BoundsChecking.cpp:43,Security,access,accessing,43,"/// Gets the conditions under which memory accessing instructions will overflow.; ///; /// \p Ptr is the pointer that will be read/written, and \p InstVal is either; /// the result from the load or the value being stored. It is used to determine; /// the size of memory block that is touched.; ///; /// Returns the condition under which the access will overflow.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/BoundsChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/BoundsChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/BoundsChecking.cpp:341,Security,access,access,341,"/// Gets the conditions under which memory accessing instructions will overflow.; ///; /// \p Ptr is the pointer that will be read/written, and \p InstVal is either; /// the result from the load or the value being stored. It is used to determine; /// the size of memory block that is touched.; ///; /// Returns the condition under which the access will overflow.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/BoundsChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/BoundsChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/BoundsChecking.cpp:196,Performance,optimiz,optimization,196,"// three checks are required to ensure safety:; // . Offset >= 0 (since the offset is given from the base ptr); // . Size >= Offset (unsigned); // . Size - Offset >= NeededSize (unsigned); //; // optimization: if Size >= 0 (signed), skip 1st check; // FIXME: add NSW/NUW here? -- we dont care if the subtraction overflows",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/BoundsChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/BoundsChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/BoundsChecking.cpp:39,Safety,safe,safety,39,"// three checks are required to ensure safety:; // . Offset >= 0 (since the offset is given from the base ptr); // . Size >= Offset (unsigned); // . Size - Offset >= NeededSize (unsigned); //; // optimization: if Size >= 0 (signed), skip 1st check; // FIXME: add NSW/NUW here? -- we dont care if the subtraction overflows",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/BoundsChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/BoundsChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/BoundsChecking.cpp:199,Availability,failure,failure,199,/// Adds run-time bounds checks to memory accessing instructions.; ///; /// \p Or is the condition that should guard the trap.; ///; /// \p GetTrapBB is a callable that returns the trap BB to use on failure.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/BoundsChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/BoundsChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/BoundsChecking.cpp:42,Security,access,accessing,42,/// Adds run-time bounds checks to memory accessing instructions.; ///; /// \p Or is the condition that should guard the trap.; ///; /// \p GetTrapBB is a callable that returns the trap BB to use on failure.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/BoundsChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/BoundsChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/BoundsChecking.cpp:61,Integrability,Depend,Depending,61,"// Create a trapping basic block on demand using a callback. Depending on; // flags, this will either create a single block for the entire function or; // will create a fresh block every time it is called.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/BoundsChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/BoundsChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/CGProfile.cpp:10,Availability,error,error,10,// Ignore error here. Indirect calls are ignored if this fails.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/CGProfile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/CGProfile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/CGProfile.cpp:3,Safety,Avoid,Avoid,3,// Avoid extra cost of running passes for BFI when the function doesn't have; // entry count.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/CGProfile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/CGProfile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp:431,Energy Efficiency,reduce,reduces,431,"//===-- ControlHeightReduction.cpp - Control Height Reduction -------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass merges conditional blocks of code and reduces the number of; // conditional branches in the hot paths based on profiles.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp:99,Integrability,depend,dependent,99,// Subscopes.; // The instruction at which to insert the CHR conditional branch (and hoist; // the dependent condition values).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp:136,Deployability,update,updated,136,"// Find out how many times region R is cloned. Note that if the parent; // of R is cloned, R is also cloned, but R's clone count is not updated; // from the clone of the parent. We need to accumlate all the counts; // from the ancestors to get the clone count.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp:13,Deployability,release,release,13,// Unused in release build.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp:13,Deployability,release,release,13,// Unused in release build.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp:42,Safety,avoid,avoid,42,// Guard against 0-to-0 branch weights to avoid a division-by-zero crash.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp:49,Integrability,depend,dependent,49,"// Returns the instruction at which to hoist the dependent condition values and; // insert the CHR branch for a region. This is the terminator branch in the; // entry block or the first select in the entry block, if any.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp:124,Testability,assert,asserted,124,// Pick the first select in Selects in the entry block. Note Selects is; // sorted in the instruction order within a block (asserted below).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp:769,Integrability,depend,dependent,769,"// Check that any of the branch and the selects in the region could be; // hoisted above the the CHR branch insert point (the most dominating of; // them, either the branch (at the end of the first block) or the first; // select in the first block). If the branch can't be hoisted, drop the; // selects in the first blocks.; //; // For example, for the following scope/region with selects, we want to insert; // the merged branch right before the first select in the first/entry block by; // hoisting c1, c2, c3, and c4.; //; // // Branch insert point here.; // a = c1 ? b : c; // Select 1; // d = c2 ? e : f; // Select 2; // if (c3) { // Branch; // ...; // c4 = foo() // A call.; // g = c4 ? h : i; // Select 3; // }; //; // But suppose we can't hoist c4 because it's dependent on the preceding; // call. Then, we drop Select 3. Furthermore, if we can't hoist c2, we also drop; // Select 2. If we can't hoist c3, we drop Selects 1 & 2.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp:16,Integrability,depend,dependence,16,// Avoid a data dependence from a select or a branch to a(nother); // select. Note no instruction can't data-depend on a branch (a branch; // instruction doesn't produce a value).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp:109,Integrability,depend,depend,109,// Avoid a data dependence from a select or a branch to a(nother); // select. Note no instruction can't data-depend on a branch (a branch; // instruction doesn't produce a value).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp:3,Safety,Avoid,Avoid,3,// Avoid a data dependence from a select or a branch to a(nother); // select. Note no instruction can't data-depend on a branch (a branch; // instruction doesn't produce a value).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp:3,Deployability,Update,Update,3,// Update InsertPoint after potentially removing selects.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp:38,Integrability,depend,depending,38,"// Determine whether to split a scope depending on the sets of the branch; // condition values of the previous region and the current region. We split; // (return true) it if 1) the condition values of the inner/lower scope can't be; // hoisted up to the outer/upper scope, or 2) the two sets of the condition; // values have an empty intersection (because the combined branch conditions; // won't probably lead to a simpler combined condition).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp:417,Usability,simpl,simpler,417,"// Determine whether to split a scope depending on the sets of the branch; // condition values of the previous region and the current region. We split; // (return true) it if 1) the condition values of the inner/lower scope can't be; // hoisted up to the outer/upper scope, or 2) the two sets of the condition; // values have an empty intersection (because the combined branch conditions; // won't probably lead to a simpler combined condition).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp:70,Safety,avoid,avoid,70,"// If PrevConditionValues or ConditionValues is empty, don't split to avoid; // unnecessary splits at scopes with no branch/selects. If; // PrevConditionValues and ConditionValues don't intersect at all, split.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp:163,Integrability,depend,depend,163,// Put the biased selects in Unhoistables because they should stay where they; // are and constant-folded after CHR (in case one biased select or a branch; // can depend on another biased select.),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp:13,Deployability,release,release,13,// Unused in release build,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp:13,Deployability,release,release,13,// Unused in release build,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp:199,Safety,safe,safe,199,"// The trivial phi inserted by the previous CHR scope could replace a; // non-phi in HoistStops. Note that since this phi is at the exit of a; // previous CHR scope, which dominates this scope, it's safe to stop; // hoisting there.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp:456,Safety,safe,safe,456,"// We are already above the hoist point. Stop here. This may be necessary; // when multiple scopes would independently hoist the same; // instruction. Since an outer (dominating) scope would hoist it to its; // entry before an inner (dominated) scope would to its entry, the inner; // scope may see the instruction already hoisted, in which case it; // potentially wrong for the inner scope to hoist it and could cause bad; // IR (non-dominating def), but safe to skip hoisting it instead because; // it's already in a block that dominates the inner scope.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp:13,Integrability,depend,dependent,13,// Hoist the dependent condition values of the branches and the selects in the; // scope to the insert point.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp:160,Availability,alive,alive,160,// A helper for transformScopes. Insert a trivial phi at the scope exit block; // for a value that's defined in the scope but used outside it (meaning it's; // alive at the exit block).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp:3,Testability,Assert,Assert,3,// Assert that all the CHR regions of the scope have a biased branch or select.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp:3,Testability,Assert,Assert,3,// Assert that all the condition values of the biased branches and selects have; // been hoisted to the pre-entry block or outside of the scope.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp:13,Deployability,release,release,13,// Unused in release build.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp:13,Deployability,release,release,13,// Unused in release build.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp:174,Availability,alive,alive,174,"// Insert a trivial phi at the exit block (where the CHR hot path and the; // cold path merges) for a value that's defined in the scope but used; // outside it (meaning it's alive at the exit block). We will add the; // incoming values for the CHR cold paths to it below. Without this, we'd; // miss updating phi's for such values unless there happens to already be a; // phi for that value there.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp:199,Deployability,update,updated,199,"// Split the entry block of the first region. The new block becomes the new; // entry block of the first region. The old entry block becomes the block to; // insert the CHR branch into. Note DT gets updated. Since DT gets updated; // through the split, we update the entry of the first region after the split,; // and Region only points to the entry and the exit blocks, rather than; // keeping everything in a list or set, the blocks membership and the; // entry/exit blocks of the region are still valid after the split.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp:222,Deployability,update,updated,222,"// Split the entry block of the first region. The new block becomes the new; // entry block of the first region. The old entry block becomes the block to; // insert the CHR branch into. Note DT gets updated. Since DT gets updated; // through the split, we update the entry of the first region after the split,; // and Region only points to the entry and the exit blocks, rather than; // keeping everything in a list or set, the blocks membership and the; // entry/exit blocks of the region are still valid after the split.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp:256,Deployability,update,update,256,"// Split the entry block of the first region. The new block becomes the new; // entry block of the first region. The old entry block becomes the block to; // insert the CHR branch into. Note DT gets updated. Since DT gets updated; // through the split, we update the entry of the first region after the split,; // and Region only points to the entry and the exit blocks, rather than; // keeping everything in a list or set, the blocks membership and the; // entry/exit blocks of the region are still valid after the split.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp:133,Deployability,update,update,133,// Clone the blocks in the scope (excluding the PreEntryBlock) to split into a; // hot path (originals) and a cold path (clones) and update the PHIs at the; // exit block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp:142,Deployability,update,update,142,// A helper for transformScopes. Clone the blocks in the scope (excluding the; // PreEntryBlock) to split into a hot path and a cold path and update the PHIs; // at the exit block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp:74,Performance,optimiz,optimized,74,// Clone all the blocks. The original blocks will be the hot-path; // CHR-optimized code and the cloned blocks will be the original unoptimized; // code. This is so that the block pointers from the; // CHRScope/Region/RegionInfo can stay valid in pointing to the hot-path code; // which CHR should apply to.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp:3,Deployability,Update,Update,3,// Update the cloned blocks/instructions to refer to themselves.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp:179,Deployability,update,updated,179,// Add the cloned blocks to the PHIs of the exit blocks. ExitBlock is null for; // the top-level region but we don't need to add PHIs. The trivial PHIs; // inserted above will be updated here.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp:142,Safety,avoid,avoid,142,"// If Cond is an icmp and all users of V except for BranchOrSelect is a; // branch, negate the icmp predicate and swap the branch targets and avoid; // inserting an Xor to negate Cond.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp:22,Safety,avoid,avoid,22,// Use logical and to avoid propagating poison from later conditions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp:7,Testability,log,logical,7,// Use logical and to avoid propagating poison from later conditions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp:991,Modifiability,variab,variables,991,"//===- DataFlowSanitizer.cpp - dynamic data flow analysis -----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file; /// This file is a part of DataFlowSanitizer, a generalised dynamic data flow; /// analysis.; ///; /// Unlike other Sanitizer tools, this tool is not designed to detect a specific; /// class of bugs on its own. Instead, it provides a generic dynamic data flow; /// analysis framework to be used by clients to help detect application-specific; /// issues within their own code.; ///; /// The analysis is based on automatic propagation of data flow labels (also; /// known as taint labels) through a program as it performs computation.; ///; /// Argument and return value labels are passed through TLS variables; /// __dfsan_arg_tls and __dfsan_retval_tls.; ///; /// Each byte of application memory is backed by a shadow memory byte. The; /// shadow byte can represent up to 8 labels. On Linux/x86_64, memory is then; /// laid out as follows:; ///; /// +--------------------+ 0x800000000000 (top of memory); /// | application 3 |; /// +--------------------+ 0x700000000000; /// | invalid |; /// +--------------------+ 0x610000000000; /// | origin 1 |; /// +--------------------+ 0x600000000000; /// | application 2 |; /// +--------------------+ 0x510000000000; /// | shadow 1 |; /// +--------------------+ 0x500000000000; /// | invalid |; /// +--------------------+ 0x400000000000; /// | origin 3 |; /// +--------------------+ 0x300000000000; /// | shadow 3 |; /// +--------------------+ 0x200000000000; /// | origin 2 |; /// +--------------------+ 0x110000000000; /// | invalid |; /// +--------------------+ 0x100000000000; /// | shadow 2 |; /// +--------------------+ 0x010000000000; /// | application 1 |; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp:903,Performance,perform,performs,903,"//===- DataFlowSanitizer.cpp - dynamic data flow analysis -----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file; /// This file is a part of DataFlowSanitizer, a generalised dynamic data flow; /// analysis.; ///; /// Unlike other Sanitizer tools, this tool is not designed to detect a specific; /// class of bugs on its own. Instead, it provides a generic dynamic data flow; /// analysis framework to be used by clients to help detect application-specific; /// issues within their own code.; ///; /// The analysis is based on automatic propagation of data flow labels (also; /// known as taint labels) through a program as it performs computation.; ///; /// Argument and return value labels are passed through TLS variables; /// __dfsan_arg_tls and __dfsan_retval_tls.; ///; /// Each byte of application memory is backed by a shadow memory byte. The; /// shadow byte can represent up to 8 labels. On Linux/x86_64, memory is then; /// laid out as follows:; ///; /// +--------------------+ 0x800000000000 (top of memory); /// | application 3 |; /// +--------------------+ 0x700000000000; /// | invalid |; /// +--------------------+ 0x610000000000; /// | origin 1 |; /// +--------------------+ 0x600000000000; /// | application 2 |; /// +--------------------+ 0x510000000000; /// | shadow 1 |; /// +--------------------+ 0x500000000000; /// | invalid |; /// +--------------------+ 0x400000000000; /// | origin 3 |; /// +--------------------+ 0x300000000000; /// | shadow 3 |; /// +--------------------+ 0x200000000000; /// | origin 2 |; /// +--------------------+ 0x110000000000; /// | invalid |; /// +--------------------+ 0x100000000000; /// | shadow 2 |; /// +--------------------+ 0x010000000000; /// | application 1 |; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp:553,Safety,detect,detect,553,"//===- DataFlowSanitizer.cpp - dynamic data flow analysis -----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file; /// This file is a part of DataFlowSanitizer, a generalised dynamic data flow; /// analysis.; ///; /// Unlike other Sanitizer tools, this tool is not designed to detect a specific; /// class of bugs on its own. Instead, it provides a generic dynamic data flow; /// analysis framework to be used by clients to help detect application-specific; /// issues within their own code.; ///; /// The analysis is based on automatic propagation of data flow labels (also; /// known as taint labels) through a program as it performs computation.; ///; /// Argument and return value labels are passed through TLS variables; /// __dfsan_arg_tls and __dfsan_retval_tls.; ///; /// Each byte of application memory is backed by a shadow memory byte. The; /// shadow byte can represent up to 8 labels. On Linux/x86_64, memory is then; /// laid out as follows:; ///; /// +--------------------+ 0x800000000000 (top of memory); /// | application 3 |; /// +--------------------+ 0x700000000000; /// | invalid |; /// +--------------------+ 0x610000000000; /// | origin 1 |; /// +--------------------+ 0x600000000000; /// | application 2 |; /// +--------------------+ 0x510000000000; /// | shadow 1 |; /// +--------------------+ 0x500000000000; /// | invalid |; /// +--------------------+ 0x400000000000; /// | origin 3 |; /// +--------------------+ 0x300000000000; /// | shadow 3 |; /// +--------------------+ 0x200000000000; /// | origin 2 |; /// +--------------------+ 0x110000000000; /// | invalid |; /// +--------------------+ 0x100000000000; /// | shadow 2 |; /// +--------------------+ 0x010000000000; /// | application 1 |; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp:705,Safety,detect,detect,705,"//===- DataFlowSanitizer.cpp - dynamic data flow analysis -----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file; /// This file is a part of DataFlowSanitizer, a generalised dynamic data flow; /// analysis.; ///; /// Unlike other Sanitizer tools, this tool is not designed to detect a specific; /// class of bugs on its own. Instead, it provides a generic dynamic data flow; /// analysis framework to be used by clients to help detect application-specific; /// issues within their own code.; ///; /// The analysis is based on automatic propagation of data flow labels (also; /// known as taint labels) through a program as it performs computation.; ///; /// Argument and return value labels are passed through TLS variables; /// __dfsan_arg_tls and __dfsan_retval_tls.; ///; /// Each byte of application memory is backed by a shadow memory byte. The; /// shadow byte can represent up to 8 labels. On Linux/x86_64, memory is then; /// laid out as follows:; ///; /// +--------------------+ 0x800000000000 (top of memory); /// | application 3 |; /// +--------------------+ 0x700000000000; /// | invalid |; /// +--------------------+ 0x610000000000; /// | origin 1 |; /// +--------------------+ 0x600000000000; /// | application 2 |; /// +--------------------+ 0x510000000000; /// | shadow 1 |; /// +--------------------+ 0x500000000000; /// | invalid |; /// +--------------------+ 0x400000000000; /// | origin 3 |; /// +--------------------+ 0x300000000000; /// | shadow 3 |; /// +--------------------+ 0x200000000000; /// | origin 2 |; /// +--------------------+ 0x110000000000; /// | invalid |; /// +--------------------+ 0x100000000000; /// | shadow 2 |; /// +--------------------+ 0x010000000000; /// | application 1 |; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp:507,Security,Sanitiz,Sanitizer,507,"//===- DataFlowSanitizer.cpp - dynamic data flow analysis -----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file; /// This file is a part of DataFlowSanitizer, a generalised dynamic data flow; /// analysis.; ///; /// Unlike other Sanitizer tools, this tool is not designed to detect a specific; /// class of bugs on its own. Instead, it provides a generic dynamic data flow; /// analysis framework to be used by clients to help detect application-specific; /// issues within their own code.; ///; /// The analysis is based on automatic propagation of data flow labels (also; /// known as taint labels) through a program as it performs computation.; ///; /// Argument and return value labels are passed through TLS variables; /// __dfsan_arg_tls and __dfsan_retval_tls.; ///; /// Each byte of application memory is backed by a shadow memory byte. The; /// shadow byte can represent up to 8 labels. On Linux/x86_64, memory is then; /// laid out as follows:; ///; /// +--------------------+ 0x800000000000 (top of memory); /// | application 3 |; /// +--------------------+ 0x700000000000; /// | invalid |; /// +--------------------+ 0x610000000000; /// | origin 1 |; /// +--------------------+ 0x600000000000; /// | application 2 |; /// +--------------------+ 0x510000000000; /// | shadow 1 |; /// +--------------------+ 0x500000000000; /// | invalid |; /// +--------------------+ 0x400000000000; /// | origin 3 |; /// +--------------------+ 0x300000000000; /// | shadow 3 |; /// +--------------------+ 0x200000000000; /// | origin 2 |; /// +--------------------+ 0x110000000000; /// | invalid |; /// +--------------------+ 0x100000000000; /// | shadow 2 |; /// +--------------------+ 0x010000000000; /// | application 1 |; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp:19,Modifiability,variab,variables,19,// The size of TLS variables. These constants must be kept in sync with the ones; // in dfsan.cpp.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp:187,Performance,load,load,187,"// The -dfsan-preserve-alignment flag controls whether this pass assumes that; // alignment requirements provided by the input IR are correct. For example,; // if the input IR contains a load with alignment 8, this flag will cause; // the shadow load to have alignment 16. This flag is disabled by default as; // we have unfortunately encountered too much code (including Clang itself;; // see PR14291) which performs misaligned access.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp:246,Performance,load,load,246,"// The -dfsan-preserve-alignment flag controls whether this pass assumes that; // alignment requirements provided by the input IR are correct. For example,; // if the input IR contains a load with alignment 8, this flag will cause; // the shadow load to have alignment 16. This flag is disabled by default as; // we have unfortunately encountered too much code (including Clang itself;; // see PR14291) which performs misaligned access.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp:409,Performance,perform,performs,409,"// The -dfsan-preserve-alignment flag controls whether this pass assumes that; // alignment requirements provided by the input IR are correct. For example,; // if the input IR contains a load with alignment 8, this flag will cause; // the shadow load to have alignment 16. This flag is disabled by default as; // we have unfortunately encountered too much code (including Clang itself;; // see PR14291) which performs misaligned access.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp:429,Security,access,access,429,"// The -dfsan-preserve-alignment flag controls whether this pass assumes that; // alignment requirements provided by the input IR are correct. For example,; // if the input IR contains a load with alignment 8, this flag will cause; // the shadow load to have alignment 16. This flag is disabled by default as; // we have unfortunately encountered too much code (including Clang itself;; // see PR14291) which performs misaligned access.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp:341,Integrability,message,message,341,"// The ABI list files control how shadow parameters are passed. The pass treats; // every function labelled ""uninstrumented"" in the ABI list file as conforming; // to the ""native"" (i.e. unsanitized) ABI. Unless the ABI list contains; // additional annotations for those functions, a call to one of those functions; // will produce a warning message, as the labelling behaviour of the function is; // unknown. The other supported annotations for uninstrumented functions are; // ""functional"" and ""discard"", which are described below under; // DataFlowSanitizer::WrapperKind.; // Functions will often be labelled with both ""uninstrumented"" and one of; // ""functional"" or ""discard"". This will leave the function unchanged by this; // pass, and create a wrapper function that will call the original.; //; // Instrumented functions can also be annotated as ""force_zero_labels"", which; // will make all shadow and return values set zero labels.; // Functions should never be labelled with both ""force_zero_labels"" and; // ""uninstrumented"" or any of the unistrumented wrapper kinds.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp:561,Integrability,Wrap,WrapperKind,561,"// The ABI list files control how shadow parameters are passed. The pass treats; // every function labelled ""uninstrumented"" in the ABI list file as conforming; // to the ""native"" (i.e. unsanitized) ABI. Unless the ABI list contains; // additional annotations for those functions, a call to one of those functions; // will produce a warning message, as the labelling behaviour of the function is; // unknown. The other supported annotations for uninstrumented functions are; // ""functional"" and ""discard"", which are described below under; // DataFlowSanitizer::WrapperKind.; // Functions will often be labelled with both ""uninstrumented"" and one of; // ""functional"" or ""discard"". This will leave the function unchanged by this; // pass, and create a wrapper function that will call the original.; //; // Instrumented functions can also be annotated as ""force_zero_labels"", which; // will make all shadow and return values set zero labels.; // Functions should never be labelled with both ""force_zero_labels"" and; // ""uninstrumented"" or any of the unistrumented wrapper kinds.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp:750,Integrability,wrap,wrapper,750,"// The ABI list files control how shadow parameters are passed. The pass treats; // every function labelled ""uninstrumented"" in the ABI list file as conforming; // to the ""native"" (i.e. unsanitized) ABI. Unless the ABI list contains; // additional annotations for those functions, a call to one of those functions; // will produce a warning message, as the labelling behaviour of the function is; // unknown. The other supported annotations for uninstrumented functions are; // ""functional"" and ""discard"", which are described below under; // DataFlowSanitizer::WrapperKind.; // Functions will often be labelled with both ""uninstrumented"" and one of; // ""functional"" or ""discard"". This will leave the function unchanged by this; // pass, and create a wrapper function that will call the original.; //; // Instrumented functions can also be annotated as ""force_zero_labels"", which; // will make all shadow and return values set zero labels.; // Functions should never be labelled with both ""force_zero_labels"" and; // ""uninstrumented"" or any of the unistrumented wrapper kinds.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp:1061,Integrability,wrap,wrapper,1061,"// The ABI list files control how shadow parameters are passed. The pass treats; // every function labelled ""uninstrumented"" in the ABI list file as conforming; // to the ""native"" (i.e. unsanitized) ABI. Unless the ABI list contains; // additional annotations for those functions, a call to one of those functions; // will produce a warning message, as the labelling behaviour of the function is; // unknown. The other supported annotations for uninstrumented functions are; // ""functional"" and ""discard"", which are described below under; // DataFlowSanitizer::WrapperKind.; // Functions will often be labelled with both ""uninstrumented"" and one of; // ""functional"" or ""discard"". This will leave the function unchanged by this; // pass, and create a wrapper function that will call the original.; //; // Instrumented functions can also be annotated as ""force_zero_labels"", which; // will make all shadow and return values set zero labels.; // Functions should never be labelled with both ""force_zero_labels"" and; // ""uninstrumented"" or any of the unistrumented wrapper kinds.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp:75,Performance,load,load,75,// Controls whether the pass includes or ignores the labels of pointers in load; // instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp:118,Performance,load,loads,118,"// Experimental feature that inserts callbacks for certain data events.; // Currently callbacks are only inserted for loads, stores, memory transfers; // (i.e. memcpy and memmove), and comparisons.; //; // If this flag is set to true, the user must provide definitions for the; // following callback functions:; // void __dfsan_load_callback(dfsan_label Label, void* addr);; // void __dfsan_store_callback(dfsan_label Label, void* addr);; // void __dfsan_mem_transfer_callback(dfsan_label *Start, size_t Len);; // void __dfsan_cmp_callback(dfsan_label CombinedLabel);",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp:115,Performance,load,loads,115,"// Experimental feature that inserts callbacks for data reaching a function,; // either via function arguments and loads.; // This must be true for dfsan_set_reaches_function_callback() to have effect.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp:149,Performance,load,load,149,// Controls how to track origins.; // * 0: do not track origins.; // * 1: track origins at memory store operations.; // * 2: track origins at memory load and store operations.; // TODO: track callsites.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp:42,Security,access,accessible,42,"/// This function does not write to (user-accessible) memory, and its return; /// value is unlabelled.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp:42,Security,access,accessible,42,"/// This function does not write to (user-accessible) memory, and the label; /// of its return value is the union of the label of its arguments.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp:46,Integrability,wrap,wrapper,46,"/// Instead of calling the function, a custom wrapper __dfsw_F is called,; /// where F is the name of the function. This function may wrap the; /// original function or provide its own implementation. WK_Custom uses an; /// extra pointer argument to return the shadow. This allows the wrapped; /// form of the function type to be expressed in C.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp:134,Integrability,wrap,wrap,134,"/// Instead of calling the function, a custom wrapper __dfsw_F is called,; /// where F is the name of the function. This function may wrap the; /// original function or provide its own implementation. WK_Custom uses an; /// extra pointer argument to return the shadow. This allows the wrapped; /// form of the function type to be expressed in C.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp:285,Integrability,wrap,wrapped,285,"/// Instead of calling the function, a custom wrapper __dfsw_F is called,; /// where F is the name of the function. This function may wrap the; /// original function or provide its own implementation. WK_Custom uses an; /// extra pointer argument to return the shadow. This allows the wrapped; /// form of the function type to be expressed in C.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp:71,Performance,load,loads,71,/// Advances \p OriginAddr to point to the next 32-bit origin and then loads; /// from it. Returns the origin's loaded value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp:112,Performance,load,loaded,112,/// Advances \p OriginAddr to point to the next 32-bit origin and then loads; /// from it. Returns the origin's loaded value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp:30,Performance,load,load,30,/// Returns whether the given load byte size is amenable to inlined; /// optimization patterns.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp:73,Performance,optimiz,optimization,73,/// Returns whether the given load byte size is amenable to inlined; /// optimization patterns.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp:146,Performance,cache,cache,146,"/// Maps a value to its latest collapsed shadow value it was converted to in; /// terms of domination tree. When ClDebugNonzeroLabels is on, this cache is; /// used at a post process where CFG blocks are split. So it does not cache; /// BasicBlock like CachedShadows, but uses domination between values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp:226,Performance,cache,cache,226,"/// Maps a value to its latest collapsed shadow value it was converted to in; /// terms of domination tree. When ClDebugNonzeroLabels is on, this cache is; /// used at a post process where CFG blocks are split. So it does not cache; /// BasicBlock like CachedShadows, but uses domination between values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp:253,Performance,Cache,CachedShadows,253,"/// Maps a value to its latest collapsed shadow value it was converted to in; /// terms of domination tree. When ClDebugNonzeroLabels is on, this cache is; /// used at a post process where CFG blocks are split. So it does not cache; /// BasicBlock like CachedShadows, but uses domination between values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp:20,Performance,load,load,20,"/// Generates IR to load shadow and origin corresponding to bytes [\p; /// Addr, \p Addr + \p Size), where addr has alignment \p; /// InstAlignment, and take the union of each of those shadows. The returned; /// shadow always has primitive type.; ///; /// When tracking loads is enabled, the returned origin is a chain at the; /// current stack if the returned shadow is tainted.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp:270,Performance,load,loads,270,"/// Generates IR to load shadow and origin corresponding to bytes [\p; /// Addr, \p Addr + \p Size), where addr has alignment \p; /// InstAlignment, and take the union of each of those shadows. The returned; /// shadow always has primitive type.; ///; /// When tracking loads is enabled, the returned origin is a chain at the; /// current stack if the returned shadow is tainted.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp:89,Performance,load,load,89,"// If ClReachesFunctionCallbacks is enabled, insert a callback for each; // argument and load instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp:21,Performance,load,loading,21,/// The fast path of loading shadows.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp:510,Energy Efficiency,reduce,reduce,510,"/// Because 4 contiguous bytes share one 4-byte origin, the most accurate load; /// is __dfsan_load_label_and_origin. This function returns the union of all; /// labels and the origin of the first taint label. However this is an; /// additional call with many instructions. To ensure common cases are fast,; /// checks if it is possible to load labels and origins without using the; /// callback function.; ///; /// When enabling tracking load instructions, we always use; /// __dfsan_load_label_and_origin to reduce code size.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp:74,Performance,load,load,74,"/// Because 4 contiguous bytes share one 4-byte origin, the most accurate load; /// is __dfsan_load_label_and_origin. This function returns the union of all; /// labels and the origin of the first taint label. However this is an; /// additional call with many instructions. To ensure common cases are fast,; /// checks if it is possible to load labels and origins without using the; /// callback function.; ///; /// When enabling tracking load instructions, we always use; /// __dfsan_load_label_and_origin to reduce code size.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp:340,Performance,load,load,340,"/// Because 4 contiguous bytes share one 4-byte origin, the most accurate load; /// is __dfsan_load_label_and_origin. This function returns the union of all; /// labels and the origin of the first taint label. However this is an; /// additional call with many instructions. To ensure common cases are fast,; /// checks if it is possible to load labels and origins without using the; /// callback function.; ///; /// When enabling tracking load instructions, we always use; /// __dfsan_load_label_and_origin to reduce code size.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp:439,Performance,load,load,439,"/// Because 4 contiguous bytes share one 4-byte origin, the most accurate load; /// is __dfsan_load_label_and_origin. This function returns the union of all; /// labels and the origin of the first taint label. However this is an; /// additional call with many instructions. To ensure common cases are fast,; /// checks if it is possible to load labels and origins without using the; /// callback function.; ///; /// When enabling tracking load instructions, we always use; /// __dfsan_load_label_and_origin to reduce code size.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp:20,Performance,load,load,20,"/// Generates IR to load shadow and origin corresponding to bytes [\p; /// Addr, \p Addr + \p Size), where addr has alignment \p; /// InstAlignment, and take the union of each of those shadows. The returned; /// shadow always has primitive type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp:291,Integrability,wrap,wrapped,291,"// This is a bit of a hack because TargetLibraryInfo is a function pass.; // The DFSan pass would need to be refactored to be function pass oriented; // (like MSan is) in order to fit together nicely with TargetLibraryInfo.; // We need this check to prevent them from being instrumented, or wrapped.; // Match on name and number of arguments.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp:109,Modifiability,refactor,refactored,109,"// This is a bit of a hack because TargetLibraryInfo is a function pass.; // The DFSan pass would need to be refactored to be function pass oriented; // (like MSan is) in order to fit together nicely with TargetLibraryInfo.; // We need this check to prevent them from being instrumented, or wrapped.; // Match on name and number of arguments.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp:221,Deployability,update,updated,221,"// Some parameters of the custom function being constructed are; // parameters of T. Record the mapping from parameters of T to; // parameters of the custom function, so that parameter attributes; // at call sites can be updated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp:3,Performance,Cache,Caches,3,// Caches the primitive shadow value that built the shadow value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp:17,Performance,cache,cached,17,// Checks if the cached collapsed shadow value dominates Pos.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp:3,Performance,Cache,Caches,3,// Caches the converted primitive shadow value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp:149,Safety,avoid,avoid,149,"// Try to change the name of the function in module inline asm. We only do; // this for specific asm directives, currently only "".symver"", to try to avoid; // corrupting asm which happens to contain the symbol name as a substring.; // Note that the substitution for .symver assumes that the versioned symbol; // also has an instrumented name.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp:26,Integrability,wrap,wrapping,26,"// If the function we are wrapping was ExternWeak, it may be null.; // The original code before calling this wrapper may have checked for null,; // but replacing with a known-to-not-be-null wrapper can break this check.; // When replacing uses of the extern weak function with the wrapper we try; // to avoid replacing uses in conditionals, but this is not perfect.; // In the case where we fail, and accidentally optimize out a null check; // for a extern weak function, add a check here to help identify the issue.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp:109,Integrability,wrap,wrapper,109,"// If the function we are wrapping was ExternWeak, it may be null.; // The original code before calling this wrapper may have checked for null,; // but replacing with a known-to-not-be-null wrapper can break this check.; // When replacing uses of the extern weak function with the wrapper we try; // to avoid replacing uses in conditionals, but this is not perfect.; // In the case where we fail, and accidentally optimize out a null check; // for a extern weak function, add a check here to help identify the issue.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp:190,Integrability,wrap,wrapper,190,"// If the function we are wrapping was ExternWeak, it may be null.; // The original code before calling this wrapper may have checked for null,; // but replacing with a known-to-not-be-null wrapper can break this check.; // When replacing uses of the extern weak function with the wrapper we try; // to avoid replacing uses in conditionals, but this is not perfect.; // In the case where we fail, and accidentally optimize out a null check; // for a extern weak function, add a check here to help identify the issue.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp:281,Integrability,wrap,wrapper,281,"// If the function we are wrapping was ExternWeak, it may be null.; // The original code before calling this wrapper may have checked for null,; // but replacing with a known-to-not-be-null wrapper can break this check.; // When replacing uses of the extern weak function with the wrapper we try; // to avoid replacing uses in conditionals, but this is not perfect.; // In the case where we fail, and accidentally optimize out a null check; // for a extern weak function, add a check here to help identify the issue.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp:414,Performance,optimiz,optimize,414,"// If the function we are wrapping was ExternWeak, it may be null.; // The original code before calling this wrapper may have checked for null,; // but replacing with a known-to-not-be-null wrapper can break this check.; // When replacing uses of the extern weak function with the wrapper we try; // to avoid replacing uses in conditionals, but this is not perfect.; // In the case where we fail, and accidentally optimize out a null check; // for a extern weak function, add a check here to help identify the issue.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp:303,Safety,avoid,avoid,303,"// If the function we are wrapping was ExternWeak, it may be null.; // The original code before calling this wrapper may have checked for null,; // but replacing with a known-to-not-be-null wrapper can break this check.; // When replacing uses of the extern weak function with the wrapper we try; // to avoid replacing uses in conditionals, but this is not perfect.; // In the case where we fail, and accidentally optimize out a null check; // for a extern weak function, add a check here to help identify the issue.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp:60,Integrability,wrap,wrappers,60,"// Give function aliases prefixes when necessary, and build wrappers where the; // instrumentedness is inconsistent.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp:110,Integrability,wrap,wrapper,110,"// Non-instrumented alias of an instrumented function, or vice versa.; // Replace the alias with a native-ABI wrapper of the aliasee. The pass; // below will take care of instrumenting it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp:117,Integrability,wrap,wrapper,117,"// First, change the ABI of every function in the module. ABI-listed; // functions keep their original ABI and get a wrapper function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp:11,Integrability,wrap,wrapper,11,"// Build a wrapper function for F. The wrapper simply calls F, and is; // added to FnsToInstrument so that any instrumentation according to its; // WrapperKind is done in the second pass below.; // If the function being wrapped has local linkage, then preserve the; // function's linkage in the wrapper function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp:39,Integrability,wrap,wrapper,39,"// Build a wrapper function for F. The wrapper simply calls F, and is; // added to FnsToInstrument so that any instrumentation according to its; // WrapperKind is done in the second pass below.; // If the function being wrapped has local linkage, then preserve the; // function's linkage in the wrapper function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp:148,Integrability,Wrap,WrapperKind,148,"// Build a wrapper function for F. The wrapper simply calls F, and is; // added to FnsToInstrument so that any instrumentation according to its; // WrapperKind is done in the second pass below.; // If the function being wrapped has local linkage, then preserve the; // function's linkage in the wrapper function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp:220,Integrability,wrap,wrapped,220,"// Build a wrapper function for F. The wrapper simply calls F, and is; // added to FnsToInstrument so that any instrumentation according to its; // WrapperKind is done in the second pass below.; // If the function being wrapped has local linkage, then preserve the; // function's linkage in the wrapper function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp:295,Integrability,wrap,wrapper,295,"// Build a wrapper function for F. The wrapper simply calls F, and is; // added to FnsToInstrument so that any instrumentation according to its; // WrapperKind is done in the second pass below.; // If the function being wrapped has local linkage, then preserve the; // function's linkage in the wrapper function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp:47,Usability,simpl,simply,47,"// Build a wrapper function for F. The wrapper simply calls F, and is; // added to FnsToInstrument so that any instrumentation according to its; // WrapperKind is done in the second pass below.; // If the function being wrapped has local linkage, then preserve the; // function's linkage in the wrapper function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp:331,Integrability,wrap,wrapper,331,"// Extern weak functions can sometimes be null at execution time.; // Code will sometimes check if an extern weak function is null.; // This could look something like:; // declare extern_weak i8 @my_func(i8); // br i1 icmp ne (i8 (i8)* @my_func, i8 (i8)* null), label %use_my_func,; // label %avoid_my_func; // The @""dfsw$my_func"" wrapper is never null, so if we replace this use; // in the comparison, the icmp will simplify to false and we have; // accidentally optimized away a null check that is necessary.; // This can lead to a crash when the null extern_weak my_func is called.; //; // To prevent (the most common pattern of) this problem,; // do not replace uses in comparisons with the wrapper.; // We definitely want to replace uses in call instructions.; // Other uses (e.g. store the function address somewhere) might be; // called or compared or both - this case may not be handled correctly.; // We will default to replacing with wrapper in cases we are unsure.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp:695,Integrability,wrap,wrapper,695,"// Extern weak functions can sometimes be null at execution time.; // Code will sometimes check if an extern weak function is null.; // This could look something like:; // declare extern_weak i8 @my_func(i8); // br i1 icmp ne (i8 (i8)* @my_func, i8 (i8)* null), label %use_my_func,; // label %avoid_my_func; // The @""dfsw$my_func"" wrapper is never null, so if we replace this use; // in the comparison, the icmp will simplify to false and we have; // accidentally optimized away a null check that is necessary.; // This can lead to a crash when the null extern_weak my_func is called.; //; // To prevent (the most common pattern of) this problem,; // do not replace uses in comparisons with the wrapper.; // We definitely want to replace uses in call instructions.; // Other uses (e.g. store the function address somewhere) might be; // called or compared or both - this case may not be handled correctly.; // We will default to replacing with wrapper in cases we are unsure.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp:944,Integrability,wrap,wrapper,944,"// Extern weak functions can sometimes be null at execution time.; // Code will sometimes check if an extern weak function is null.; // This could look something like:; // declare extern_weak i8 @my_func(i8); // br i1 icmp ne (i8 (i8)* @my_func, i8 (i8)* null), label %use_my_func,; // label %avoid_my_func; // The @""dfsw$my_func"" wrapper is never null, so if we replace this use; // in the comparison, the icmp will simplify to false and we have; // accidentally optimized away a null check that is necessary.; // This can lead to a crash when the null extern_weak my_func is called.; //; // To prevent (the most common pattern of) this problem,; // do not replace uses in comparisons with the wrapper.; // We definitely want to replace uses in call instructions.; // Other uses (e.g. store the function address somewhere) might be; // called or compared or both - this case may not be handled correctly.; // We will default to replacing with wrapper in cases we are unsure.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp:464,Performance,optimiz,optimized,464,"// Extern weak functions can sometimes be null at execution time.; // Code will sometimes check if an extern weak function is null.; // This could look something like:; // declare extern_weak i8 @my_func(i8); // br i1 icmp ne (i8 (i8)* @my_func, i8 (i8)* null), label %use_my_func,; // label %avoid_my_func; // The @""dfsw$my_func"" wrapper is never null, so if we replace this use; // in the comparison, the icmp will simplify to false and we have; // accidentally optimized away a null check that is necessary.; // This can lead to a crash when the null extern_weak my_func is called.; //; // To prevent (the most common pattern of) this problem,; // do not replace uses in comparisons with the wrapper.; // We definitely want to replace uses in call instructions.; // Other uses (e.g. store the function address somewhere) might be; // called or compared or both - this case may not be handled correctly.; // We will default to replacing with wrapper in cases we are unsure.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp:417,Usability,simpl,simplify,417,"// Extern weak functions can sometimes be null at execution time.; // Code will sometimes check if an extern weak function is null.; // This could look something like:; // declare extern_weak i8 @my_func(i8); // br i1 icmp ne (i8 (i8)* @my_func, i8 (i8)* null), label %use_my_func,; // label %avoid_my_func; // The @""dfsw$my_func"" wrapper is never null, so if we replace this use; // in the comparison, the icmp will simplify to false and we have; // accidentally optimized away a null check that is necessary.; // This can lead to a crash when the null extern_weak my_func is called.; //; // To prevent (the most common pattern of) this problem,; // do not replace uses in comparisons with the wrapper.; // We definitely want to replace uses in call instructions.; // Other uses (e.g. store the function address somewhere) might be; // called or compared or both - this case may not be handled correctly.; // We will default to replacing with wrapper in cases we are unsure.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp:39,Performance,load,loads,39,// Ensure IRB insertion point is after loads for shadow and origin.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp:81,Availability,Mask,Mask,81,"// When alignment is >= 4, Addr must be aligned to 4, otherwise it is UB.; // So Mask is unnecessary.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp:96,Energy Efficiency,reduce,reduce,96,"// When enabling tracking load instructions, we always use; // __dfsan_load_label_and_origin to reduce code size.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp:26,Performance,load,load,26,"// When enabling tracking load instructions, we always use; // __dfsan_load_label_and_origin to reduce code size.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp:360,Energy Efficiency,efficient,efficient,360,"// * if Size == 1, it is sufficient to load its origin aligned at 4.; // * if Size == 2, we assume most cases Addr % 2 == 0, so it is sufficient to; // load its origin aligned at 4. If not, although origins may be lost, it; // should not happen very often.; // * if align >= 4, Addr must be aligned to 4, otherwise it is UB. When; // Size % 4 == 0, it is more efficient to load origins without callbacks.; // * Otherwise we use __dfsan_load_label_and_origin.; // This should ensure that common cases run efficiently.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp:504,Energy Efficiency,efficient,efficiently,504,"// * if Size == 1, it is sufficient to load its origin aligned at 4.; // * if Size == 2, we assume most cases Addr % 2 == 0, so it is sufficient to; // load its origin aligned at 4. If not, although origins may be lost, it; // should not happen very often.; // * if align >= 4, Addr must be aligned to 4, otherwise it is UB. When; // Size % 4 == 0, it is more efficient to load origins without callbacks.; // * Otherwise we use __dfsan_load_label_and_origin.; // This should ensure that common cases run efficiently.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp:39,Performance,load,load,39,"// * if Size == 1, it is sufficient to load its origin aligned at 4.; // * if Size == 2, we assume most cases Addr % 2 == 0, so it is sufficient to; // load its origin aligned at 4. If not, although origins may be lost, it; // should not happen very often.; // * if align >= 4, Addr must be aligned to 4, otherwise it is UB. When; // Size % 4 == 0, it is more efficient to load origins without callbacks.; // * Otherwise we use __dfsan_load_label_and_origin.; // This should ensure that common cases run efficiently.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp:152,Performance,load,load,152,"// * if Size == 1, it is sufficient to load its origin aligned at 4.; // * if Size == 2, we assume most cases Addr % 2 == 0, so it is sufficient to; // load its origin aligned at 4. If not, although origins may be lost, it; // should not happen very often.; // * if align >= 4, Addr must be aligned to 4, otherwise it is UB. When; // Size % 4 == 0, it is more efficient to load origins without callbacks.; // * Otherwise we use __dfsan_load_label_and_origin.; // This should ensure that common cases run efficiently.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp:373,Performance,load,load,373,"// * if Size == 1, it is sufficient to load its origin aligned at 4.; // * if Size == 2, we assume most cases Addr % 2 == 0, so it is sufficient to; // load its origin aligned at 4. If not, although origins may be lost, it; // should not happen very often.; // * if align >= 4, Addr must be aligned to 4, otherwise it is UB. When; // Size % 4 == 0, it is more efficient to load origins without callbacks.; // * Otherwise we use __dfsan_load_label_and_origin.; // This should ensure that common cases run efficiently.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp:3,Performance,Load,Load,3,"// Load instructions in LLVM can have arbitrary byte sizes (e.g., 3, 12, 20); // but this function is only used in a subset of cases that make it possible; // to optimize the instrumentation.; //; // Specifically, when the shadow size in bytes (i.e., loaded bytes x shadow; // per byte) is either:; // - a multiple of 8 (common); // - equal to 4 (only for load32); //; // For the second case, we can fit the wide shadow in a 32-bit integer. In all; // other cases, we use a 64-bit integer to hold the wide shadow.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp:162,Performance,optimiz,optimize,162,"// Load instructions in LLVM can have arbitrary byte sizes (e.g., 3, 12, 20); // but this function is only used in a subset of cases that make it possible; // to optimize the instrumentation.; //; // Specifically, when the shadow size in bytes (i.e., loaded bytes x shadow; // per byte) is either:; // - a multiple of 8 (common); // - equal to 4 (only for load32); //; // For the second case, we can fit the wide shadow in a 32-bit integer. In all; // other cases, we use a 64-bit integer to hold the wide shadow.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp:251,Performance,load,loaded,251,"// Load instructions in LLVM can have arbitrary byte sizes (e.g., 3, 12, 20); // but this function is only used in a subset of cases that make it possible; // to optimize the instrumentation.; //; // Specifically, when the shadow size in bytes (i.e., loaded bytes x shadow; // per byte) is either:; // - a multiple of 8 (common); // - equal to 4 (only for load32); //; // For the second case, we can fit the wide shadow in a 32-bit integer. In all; // other cases, we use a 64-bit integer to hold the wide shadow.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp:241,Testability,log,logN,241,"// First OR all the WideShadows (i.e., 64bit or 32bit shadow chunks) linearly;; // then OR individual shadows within the combined WideShadow by binary ORing.; // This is fewer instructions than ORing shadows individually, since it; // needs logN shift/or instructions (N being the bytes of the combined wide; // shadow).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp:15,Performance,load,loads,15,// Non-escaped loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp:3,Performance,Load,Load,3,// Load from constant addresses.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp:19,Performance,load,load,19,// Use callback to load if this is not an optimizable case for origin; // tracking.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp:42,Performance,optimiz,optimizable,42,// Use callback to load if this is not an optimizable case for origin; // tracking.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp:28,Performance,load,loading,28,// Other cases that support loading shadows or origins in a fast way.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp:46,Performance,load,load,46,"// When the byte size is small enough, we can load the shadow directly with; // just a few instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp:23,Performance,load,load,23,"// When an application load is atomic, increase atomic ordering between; // atomic application loads and stores to ensure happen-before order; load; // shadow data after application data; store zero shadow data before; // application data. This ensure shadow loads return either labels of the; // initial application data or zeros.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp:95,Performance,load,loads,95,"// When an application load is atomic, increase atomic ordering between; // atomic application loads and stores to ensure happen-before order; load; // shadow data after application data; store zero shadow data before; // application data. This ensure shadow loads return either labels of the; // initial application data or zeros.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp:143,Performance,load,load,143,"// When an application load is atomic, increase atomic ordering between; // atomic application loads and stores to ensure happen-before order; load; // shadow data after application data; store zero shadow data before; // application data. This ensure shadow loads return either labels of the; // initial application data or zeros.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp:259,Performance,load,loads,259,"// When an application load is atomic, increase atomic ordering between; // atomic application loads and stores to ensure happen-before order; load; // shadow data after application data; store zero shadow data before; // application data. This ensure shadow loads return either labels of the; // initial application data or zeros.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp:96,Performance,load,loads,96,"// When an application store is atomic, increase atomic ordering between; // atomic application loads and stores to ensure happen-before order; load; // shadow data after application data; store zero shadow data before; // application data. This ensure shadow loads return either labels of the; // initial application data or zeros.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp:144,Performance,load,load,144,"// When an application store is atomic, increase atomic ordering between; // atomic application loads and stores to ensure happen-before order; load; // shadow data after application data; store zero shadow data before; // application data. This ensure shadow loads return either labels of the; // initial application data or zeros.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp:260,Performance,load,loads,260,"// When an application store is atomic, increase atomic ordering between; // atomic application loads and stores to ensure happen-before order; load; // shadow data after application data; store zero shadow data before; // application data. This ensure shadow loads return either labels of the; // initial application data or zeros.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp:322,Performance,load,loads,322,"// We do not need to track data through LandingPadInst.; //; // For the C++ exceptions, if a value is thrown, this value will be stored; // in a memory location provided by __cxa_allocate_exception(...) (on the; // throw side) or __cxa_begin_catch(...) (on the catch side).; // This memory will have a shadow, so with the loads and stores we will be; // able to propagate labels on data thrown through exceptions, without any; // special handling of the LandingPadInst.; //; // The second element in the pair result of the LandingPadInst is a; // register value, but it is for a type ID and should never be tainted.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp:12,Modifiability,variab,variable,12,// Adds non-variable argument shadows.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp:8,Modifiability,variab,variable,8,// Adds variable argument shadows.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp:11,Modifiability,variab,variable,11,// Add non-variable argument origins.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp:7,Modifiability,variab,variable,7,// Add variable argument origins.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp:104,Integrability,wrap,wrapper,104,"// Don't try to handle invokes of custom functions, it's too complicated.; // Instead, invoke the dfsw$ wrapper, which will in turn call the __dfsw_; // wrapper.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp:153,Integrability,wrap,wrapper,153,"// Don't try to handle invokes of custom functions, it's too complicated.; // Instead, invoke the dfsw$ wrapper, which will in turn call the __dfsw_; // wrapper.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp:12,Modifiability,variab,variable,12,// Adds non-variable arguments.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp:8,Modifiability,variab,variable,8,// Adds variable arguments.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp:3,Deployability,Update,Update,3,// Update the parameter attributes of the custom call instruction to; // zero extend the shadow parameters. This is required for targets; // which consider PrimitiveShadowTy an illegal type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp:78,Modifiability,extend,extend,78,// Update the parameter attributes of the custom call instruction to; // zero extend the shadow parameters. This is required for targets; // which consider PrimitiveShadowTy an illegal type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp:3,Performance,Load,Loads,3,// Loads the return value shadow and origin.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp:37,Deployability,Release,Release,37,// Convert the call to have at least Release ordering to make sure; // the shadow operations aren't reordered after it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp:45,Integrability,wrap,wrappers,45,"// Calls to this function are synthesized in wrappers, and we shouldn't; // instrument them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp:3,Performance,Load,Loads,3,// Loads the return value shadow.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp:142,Security,Sanitiz,Sanitizers,142,// GlobalsAA is considered stateless and does not get invalidated unless; // explicitly invalidated; PreservedAnalyses::none() is not enough. Sanitizers; // make changes that require GlobalsAA to be invalidated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/GCOVProfiling.cpp:3,Security,Checksum,Checksum,3,"// Checksum, produced by hash of EdgeDestinations",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/GCOVProfiling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/GCOVProfiling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/GCOVProfiling.cpp:25,Security,hash,hash,25,"// Checksum, produced by hash of EdgeDestinations",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/GCOVProfiling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/GCOVProfiling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/GCOVProfiling.cpp:41,Security,checksum,checksum,41,"// A function has a unique identifier, a checksum (we leave as zero) and a; // set of blocks and a map of edges between blocks. This is the only GCOV; // object users can construct, the blocks and lines will be rooted here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/GCOVProfiling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/GCOVProfiling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/GCOVProfiling.cpp:103,Safety,avoid,avoid,103,// back() is a br instruction with a debug location; // equals to the one from NextAfterFork; // So to avoid to have two debug locs on two blocks just change it,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/GCOVProfiling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/GCOVProfiling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/GCOVProfiling.cpp:106,Safety,avoid,avoid,106,// Split indirectbr critical edges here before computing the MST rather; // than later in getInstrBB() to avoid invalidating it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/GCOVProfiling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/GCOVProfiling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/GCOVProfiling.cpp:34,Performance,optimiz,optimization,34,"// For now, disable spanning tree optimization when fork or exec* is; // used.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/GCOVProfiling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/GCOVProfiling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/GCOVProfiling.cpp:11,Security,sanitiz,sanitizers,11,// Disable sanitizers to decrease size bloat. We don't expect; // sanitizers to catch interesting issues.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/GCOVProfiling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/GCOVProfiling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/GCOVProfiling.cpp:66,Security,sanitiz,sanitizers,66,// Disable sanitizers to decrease size bloat. We don't expect; // sanitizers to catch interesting issues.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/GCOVProfiling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/GCOVProfiling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/GCOVProfiling.cpp:12,Security,checksum,checksum,12,// uint32_t checksum,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/GCOVProfiling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/GCOVProfiling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/GCOVProfiling.cpp:6,Usability,simpl,simplify,6,"// To simplify code, we cap the number of file infos we write out to fit; // easily in a 32-bit signed integer. This gives consistent behavior between; // 32-bit and 64-bit systems without requiring (potentially very slow) 64-bit; // operations on 32-bit systems. It also seems unreasonable to try to handle; // more than 2 billion files.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/GCOVProfiling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/GCOVProfiling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/GCOVProfiling.cpp:60,Modifiability,variab,variable,60,// The index into the files structure is our loop induction variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/GCOVProfiling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/GCOVProfiling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp:46,Availability,error,error,46,"//===- HWAddressSanitizer.cpp - memory access error detector --------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file; /// This file is a part of HWAddressSanitizer, an address basic correctness; /// checker based on tagged addressing.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp:52,Safety,detect,detector,52,"//===- HWAddressSanitizer.cpp - memory access error detector --------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file; /// This file is a part of HWAddressSanitizer, an address basic correctness; /// checker based on tagged addressing.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp:39,Security,access,access,39,"//===- HWAddressSanitizer.cpp - memory access error detector --------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file; /// This file is a part of HWAddressSanitizer, an address basic correctness; /// checker based on tagged addressing.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp:22,Energy Efficiency,power,powers,22,"// Accesses sizes are powers of two: 1, 2, 4, 8, 16.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp:3,Security,Access,Accesses,3,"// Accesses sizes are powers of two: 1, 2, 4, 8, 16.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp:87,Security,access,accessed,87,// These flags allow to change the shadow mapping and control how shadow memory; // is accessed. The shadow mapping looks like:; // Shadow = (Mem >> scale) + offset,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp:41,Safety,detect,detection,41,/// An instrumentation pass implementing detection of addressability bugs; /// using tagged pointers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp:422,Security,access,access,422,"/// This struct defines the shadow mapping using the rule:; /// shadow = (mem >> Scale) + Offset.; /// If InGlobal is true, then; /// extern char __hwasan_shadow[];; /// shadow = (mem >> Scale) + &__hwasan_shadow; /// If InTls is true, then; /// extern char *__hwasan_tls;; /// shadow = (mem>>Scale) + align_up(__hwasan_shadow, kShadowBaseAlignment); ///; /// If WithFrameRecord is true, then __hwasan_tls will be used to access the; /// ring buffer for storing stack allocations on targets that support it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp:92,Deployability,update,updated,92,"// DominatorTreeAnalysis, PostDominatorTreeAnalysis, and LoopAnalysis; // are incrementally updated throughout this pass whenever; // SplitBlockAndInsertIfThen is called.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp:142,Security,Sanitiz,Sanitizers,142,// GlobalsAA is considered stateless and does not get invalidated unless; // explicitly invalidated; PreservedAnalyses::none() is not enough. Sanitizers; // make changes that require GlobalsAA to be invalidated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp:1064,Availability,failure,failure,1064,"// Create a note that contains pointers to the list of global; // descriptors. Adding a note to the output file will cause the linker to; // create a PT_NOTE program header pointing to the note that we can use to; // find the descriptor list starting from the program headers. A function; // provided by the runtime initializes the shadow memory for the globals by; // accessing the descriptor list via the note. The dynamic loader needs to; // call this function whenever a library is loaded.; //; // The reason why we use a note for this instead of a more conventional; // approach of having a global constructor pass a descriptor list pointer to; // the runtime is because of an order of initialization problem. With; // constructors we can encounter the following problematic scenario:; //; // 1) library A depends on library B and also interposes one of B's symbols; // 2) B's constructors are called before A's (as required for correctness); // 3) during construction, B accesses one of its ""own"" globals (actually; // interposed by A) and triggers a HWASAN failure due to the initialization; // for A not having happened yet; //; // Even without interposition it is possible to run into similar situations in; // cases where two libraries mutually depend on each other.; //; // We only need one note per binary, so put everything for the note in a; // comdat. This needs to be a comdat with an .init_array section to prevent; // newer versions of lld from discarding the note.; //; // Create the note even if we aren't instrumenting globals. This ensures that; // binaries linked from object files with both instrumented and; // non-instrumented globals will end up with a note, even if a comdat from an; // object file with non-instrumented globals is selected. The note is harmless; // if the runtime doesn't support it, since it will just be ignored.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp:811,Integrability,depend,depends,811,"// Create a note that contains pointers to the list of global; // descriptors. Adding a note to the output file will cause the linker to; // create a PT_NOTE program header pointing to the note that we can use to; // find the descriptor list starting from the program headers. A function; // provided by the runtime initializes the shadow memory for the globals by; // accessing the descriptor list via the note. The dynamic loader needs to; // call this function whenever a library is loaded.; //; // The reason why we use a note for this instead of a more conventional; // approach of having a global constructor pass a descriptor list pointer to; // the runtime is because of an order of initialization problem. With; // constructors we can encounter the following problematic scenario:; //; // 1) library A depends on library B and also interposes one of B's symbols; // 2) B's constructors are called before A's (as required for correctness); // 3) during construction, B accesses one of its ""own"" globals (actually; // interposed by A) and triggers a HWASAN failure due to the initialization; // for A not having happened yet; //; // Even without interposition it is possible to run into similar situations in; // cases where two libraries mutually depend on each other.; //; // We only need one note per binary, so put everything for the note in a; // comdat. This needs to be a comdat with an .init_array section to prevent; // newer versions of lld from discarding the note.; //; // Create the note even if we aren't instrumenting globals. This ensures that; // binaries linked from object files with both instrumented and; // non-instrumented globals will end up with a note, even if a comdat from an; // object file with non-instrumented globals is selected. The note is harmless; // if the runtime doesn't support it, since it will just be ignored.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp:1255,Integrability,depend,depend,1255,"// Create a note that contains pointers to the list of global; // descriptors. Adding a note to the output file will cause the linker to; // create a PT_NOTE program header pointing to the note that we can use to; // find the descriptor list starting from the program headers. A function; // provided by the runtime initializes the shadow memory for the globals by; // accessing the descriptor list via the note. The dynamic loader needs to; // call this function whenever a library is loaded.; //; // The reason why we use a note for this instead of a more conventional; // approach of having a global constructor pass a descriptor list pointer to; // the runtime is because of an order of initialization problem. With; // constructors we can encounter the following problematic scenario:; //; // 1) library A depends on library B and also interposes one of B's symbols; // 2) B's constructors are called before A's (as required for correctness); // 3) during construction, B accesses one of its ""own"" globals (actually; // interposed by A) and triggers a HWASAN failure due to the initialization; // for A not having happened yet; //; // Even without interposition it is possible to run into similar situations in; // cases where two libraries mutually depend on each other.; //; // We only need one note per binary, so put everything for the note in a; // comdat. This needs to be a comdat with an .init_array section to prevent; // newer versions of lld from discarding the note.; //; // Create the note even if we aren't instrumenting globals. This ensures that; // binaries linked from object files with both instrumented and; // non-instrumented globals will end up with a note, even if a comdat from an; // object file with non-instrumented globals is selected. The note is harmless; // if the runtime doesn't support it, since it will just be ignored.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp:425,Performance,load,loader,425,"// Create a note that contains pointers to the list of global; // descriptors. Adding a note to the output file will cause the linker to; // create a PT_NOTE program header pointing to the note that we can use to; // find the descriptor list starting from the program headers. A function; // provided by the runtime initializes the shadow memory for the globals by; // accessing the descriptor list via the note. The dynamic loader needs to; // call this function whenever a library is loaded.; //; // The reason why we use a note for this instead of a more conventional; // approach of having a global constructor pass a descriptor list pointer to; // the runtime is because of an order of initialization problem. With; // constructors we can encounter the following problematic scenario:; //; // 1) library A depends on library B and also interposes one of B's symbols; // 2) B's constructors are called before A's (as required for correctness); // 3) during construction, B accesses one of its ""own"" globals (actually; // interposed by A) and triggers a HWASAN failure due to the initialization; // for A not having happened yet; //; // Even without interposition it is possible to run into similar situations in; // cases where two libraries mutually depend on each other.; //; // We only need one note per binary, so put everything for the note in a; // comdat. This needs to be a comdat with an .init_array section to prevent; // newer versions of lld from discarding the note.; //; // Create the note even if we aren't instrumenting globals. This ensures that; // binaries linked from object files with both instrumented and; // non-instrumented globals will end up with a note, even if a comdat from an; // object file with non-instrumented globals is selected. The note is harmless; // if the runtime doesn't support it, since it will just be ignored.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp:486,Performance,load,loaded,486,"// Create a note that contains pointers to the list of global; // descriptors. Adding a note to the output file will cause the linker to; // create a PT_NOTE program header pointing to the note that we can use to; // find the descriptor list starting from the program headers. A function; // provided by the runtime initializes the shadow memory for the globals by; // accessing the descriptor list via the note. The dynamic loader needs to; // call this function whenever a library is loaded.; //; // The reason why we use a note for this instead of a more conventional; // approach of having a global constructor pass a descriptor list pointer to; // the runtime is because of an order of initialization problem. With; // constructors we can encounter the following problematic scenario:; //; // 1) library A depends on library B and also interposes one of B's symbols; // 2) B's constructors are called before A's (as required for correctness); // 3) during construction, B accesses one of its ""own"" globals (actually; // interposed by A) and triggers a HWASAN failure due to the initialization; // for A not having happened yet; //; // Even without interposition it is possible to run into similar situations in; // cases where two libraries mutually depend on each other.; //; // We only need one note per binary, so put everything for the note in a; // comdat. This needs to be a comdat with an .init_array section to prevent; // newer versions of lld from discarding the note.; //; // Create the note even if we aren't instrumenting globals. This ensures that; // binaries linked from object files with both instrumented and; // non-instrumented globals will end up with a note, even if a comdat from an; // object file with non-instrumented globals is selected. The note is harmless; // if the runtime doesn't support it, since it will just be ignored.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp:369,Security,access,accessing,369,"// Create a note that contains pointers to the list of global; // descriptors. Adding a note to the output file will cause the linker to; // create a PT_NOTE program header pointing to the note that we can use to; // find the descriptor list starting from the program headers. A function; // provided by the runtime initializes the shadow memory for the globals by; // accessing the descriptor list via the note. The dynamic loader needs to; // call this function whenever a library is loaded.; //; // The reason why we use a note for this instead of a more conventional; // approach of having a global constructor pass a descriptor list pointer to; // the runtime is because of an order of initialization problem. With; // constructors we can encounter the following problematic scenario:; //; // 1) library A depends on library B and also interposes one of B's symbols; // 2) B's constructors are called before A's (as required for correctness); // 3) during construction, B accesses one of its ""own"" globals (actually; // interposed by A) and triggers a HWASAN failure due to the initialization; // for A not having happened yet; //; // Even without interposition it is possible to run into similar situations in; // cases where two libraries mutually depend on each other.; //; // We only need one note per binary, so put everything for the note in a; // comdat. This needs to be a comdat with an .init_array section to prevent; // newer versions of lld from discarding the note.; //; // Create the note even if we aren't instrumenting globals. This ensures that; // binaries linked from object files with both instrumented and; // non-instrumented globals will end up with a note, even if a comdat from an; // object file with non-instrumented globals is selected. The note is harmless; // if the runtime doesn't support it, since it will just be ignored.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp:977,Security,access,accesses,977,"// Create a note that contains pointers to the list of global; // descriptors. Adding a note to the output file will cause the linker to; // create a PT_NOTE program header pointing to the note that we can use to; // find the descriptor list starting from the program headers. A function; // provided by the runtime initializes the shadow memory for the globals by; // accessing the descriptor list via the note. The dynamic loader needs to; // call this function whenever a library is loaded.; //; // The reason why we use a note for this instead of a more conventional; // approach of having a global constructor pass a descriptor list pointer to; // the runtime is because of an order of initialization problem. With; // constructors we can encounter the following problematic scenario:; //; // 1) library A depends on library B and also interposes one of B's symbols; // 2) B's constructors are called before A's (as required for correctness); // 3) during construction, B accesses one of its ""own"" globals (actually; // interposed by A) and triggers a HWASAN failure due to the initialization; // for A not having happened yet; //; // Even without interposition it is possible to run into similar situations in; // cases where two libraries mutually depend on each other.; //; // We only need one note per binary, so put everything for the note in a; // comdat. This needs to be a comdat with an .init_array section to prevent; // newer versions of lld from discarding the note.; //; // Create the note even if we aren't instrumenting globals. This ensures that; // binaries linked from object files with both instrumented and; // non-instrumented globals will end up with a note, even if a comdat from an; // object file with non-instrumented globals is selected. The note is harmless; // if the runtime doesn't support it, since it will just be ignored.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp:51,Energy Efficiency,reduce,reduce,51,// These platforms may prefer less; // inlining to reduce binary size.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp:221,Performance,load,load,221,"// An empty inline asm with input reg == output reg.; // An opaque no-op cast, basically.; // This prevents code bloat as a result of rematerializing trivial definitions; // such as constants or global addresses at every load and store.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp:21,Security,access,accesses,21,// Do not instrument accesses from different address spaces; we cannot deal; // with them.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp:15,Security,access,accesses,15,// Skip memory accesses inserted by another instrumentation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp:25,Performance,load,load,25,// Do not instrument the load fetching the dynamic shadow address.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp:84,Availability,mask,mask,84,"// A list of 8-bit numbers that have at most one run of non-zero bits.; // x = x ^ (mask << 56) can be encoded as a single armv8 instruction for these; // masks.; // The list does not include the value 255, which is used for UAR.; //; // Because we are more likely to use earlier elements of this list than later; // ones, it is sorted in increasing order of probability of collision with a; // mask allocated (temporally) nearby. The program that generated this list; // can be found at:; // https://github.com/google/sanitizers/blob/master/hwaddress-sanitizer/sort_masks.py",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp:155,Availability,mask,masks,155,"// A list of 8-bit numbers that have at most one run of non-zero bits.; // x = x ^ (mask << 56) can be encoded as a single armv8 instruction for these; // masks.; // The list does not include the value 255, which is used for UAR.; //; // Because we are more likely to use earlier elements of this list than later; // ones, it is sorted in increasing order of probability of collision with a; // mask allocated (temporally) nearby. The program that generated this list; // can be found at:; // https://github.com/google/sanitizers/blob/master/hwaddress-sanitizer/sort_masks.py",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp:395,Availability,mask,mask,395,"// A list of 8-bit numbers that have at most one run of non-zero bits.; // x = x ^ (mask << 56) can be encoded as a single armv8 instruction for these; // masks.; // The list does not include the value 255, which is used for UAR.; //; // Because we are more likely to use earlier elements of this list than later; // ones, it is sorted in increasing order of probability of collision with a; // mask allocated (temporally) nearby. The program that generated this list; // can be found at:; // https://github.com/google/sanitizers/blob/master/hwaddress-sanitizer/sort_masks.py",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp:400,Energy Efficiency,allocate,allocated,400,"// A list of 8-bit numbers that have at most one run of non-zero bits.; // x = x ^ (mask << 56) can be encoded as a single armv8 instruction for these; // masks.; // The list does not include the value 255, which is used for UAR.; //; // Because we are more likely to use earlier elements of this list than later; // ones, it is sorted in increasing order of probability of collision with a; // mask allocated (temporally) nearby. The program that generated this list; // can be found at:; // https://github.com/google/sanitizers/blob/master/hwaddress-sanitizer/sort_masks.py",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp:519,Security,sanitiz,sanitizers,519,"// A list of 8-bit numbers that have at most one run of non-zero bits.; // x = x ^ (mask << 56) can be encoded as a single armv8 instruction for these; // masks.; // The list does not include the value 255, which is used for UAR.; //; // Because we are more likely to use earlier elements of this list than later; // ones, it is sorted in increasing order of probability of collision with a; // mask allocated (temporally) nearby. The program that generated this list; // can be found at:; // https://github.com/google/sanitizers/blob/master/hwaddress-sanitizer/sort_masks.py",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp:552,Security,sanitiz,sanitizer,552,"// A list of 8-bit numbers that have at most one run of non-zero bits.; // x = x ^ (mask << 56) can be encoded as a single armv8 instruction for these; // masks.; // The list does not include the value 255, which is used for UAR.; //; // Because we are more likely to use earlier elements of this list than later; // ones, it is sorted in increasing order of probability of collision with a; // mask allocated (temporally) nearby. The program that generated this list; // can be found at:; // https://github.com/google/sanitizers/blob/master/hwaddress-sanitizer/sort_masks.py",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp:14,Usability,clear,clear,14,// No need to clear the tag byte.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp:17,Usability,simpl,simply,17,// Userspace can simply do OR (tag << PointerTagShift);,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp:41,Security,sanitiz,sanitizers,41,// Android provides a fixed TLS slot for sanitizers. See TLS_SLOT_SANITIZER; // in Bionic's libc/private/bionic_tls.h.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp:3,Deployability,Update,Update,3,"// Update the ring buffer. Top byte of ThreadLong defines the size of the; // buffer in pages, it must be a power of two, and the start of the buffer; // must be aligned by twice that much. Therefore wrap around of the ring; // buffer is simply Addr &= ~((ThreadLong >> 56) << 12).; // The use of AShr instead of LShr is due to; // https://bugs.llvm.org/show_bug.cgi?id=39030; // Runtime library makes sure not to use the highest bit.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp:108,Energy Efficiency,power,power,108,"// Update the ring buffer. Top byte of ThreadLong defines the size of the; // buffer in pages, it must be a power of two, and the start of the buffer; // must be aligned by twice that much. Therefore wrap around of the ring; // buffer is simply Addr &= ~((ThreadLong >> 56) << 12).; // The use of AShr instead of LShr is due to; // https://bugs.llvm.org/show_bug.cgi?id=39030; // Runtime library makes sure not to use the highest bit.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp:200,Integrability,wrap,wrap,200,"// Update the ring buffer. Top byte of ThreadLong defines the size of the; // buffer in pages, it must be a power of two, and the start of the buffer; // must be aligned by twice that much. Therefore wrap around of the ring; // buffer is simply Addr &= ~((ThreadLong >> 56) << 12).; // The use of AShr instead of LShr is due to; // https://bugs.llvm.org/show_bug.cgi?id=39030; // Runtime library makes sure not to use the highest bit.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp:238,Usability,simpl,simply,238,"// Update the ring buffer. Top byte of ThreadLong defines the size of the; // buffer in pages, it must be a power of two, and the start of the buffer; // must be aligned by twice that much. Therefore wrap around of the ring; // buffer is simply Addr &= ~((ThreadLong >> 56) << 12).; // The use of AShr instead of LShr is due to; // https://bugs.llvm.org/show_bug.cgi?id=39030; // Runtime library makes sure not to use the highest bit.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp:298,Availability,mask,mask,298,"// Ideally, we want to calculate tagged stack base pointer, and rewrite all; // alloca addresses using that. Unfortunately, offsets are not known yet; // (unless we use ASan-style mega-alloca). Instead we keep the base tag in a; // temp, shift-OR it into each alloca address and xor with the retag mask.; // This generates one extra instruction per alloca use.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp:64,Modifiability,rewrite,rewrite,64,"// Ideally, we want to calculate tagged stack base pointer, and rewrite all; // alloca addresses using that. Unfortunately, offsets are not known yet; // (unless we use ASan-style mega-alloca). Instead we keep the base tag in a; // temp, shift-OR it into each alloca address and xor with the retag mask.; // This generates one extra instruction per alloca use.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp:62,Energy Efficiency,reduce,reduces,62,"// Set the lifetime intrinsic to cover the whole alloca. This reduces the; // set of assumptions we need to make about the lifetime. Without this we; // would need to ensure that we can track the lifetime pointer to a; // constant offset from the alloca, and would still need to change the; // size to include the extra alignment we use for the untagging to make; // the size consistent.; //; // The check for standard lifetime below makes sure that we have exactly; // one set of start / end in any execution (i.e. the ends are not; // reachable from each other), so this will not cause any problems.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp:67,Testability,log,logically,67,"// Prepend ""tag_offset, N"" to the dwarf expression.; // Tag offset logically applies to the alloca pointer, and it makes sense; // to put it at the beginning of the expression.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp:133,Safety,detect,detection,133,"// Don't allow globals to be tagged with something that looks like a; // short-granule tag, otherwise we lose inter-granule overflow detection, as; // the fast path shadow-vs-address check succeeds.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp:105,Integrability,wrap,wrapper,105,"// We need to untag stack frames as we unwind past them. That is the job of; // the personality function wrapper, which either wraps an existing; // personality function or acts as a personality function on its own. Each; // function that has a personality function or that can be unwound past has; // its personality function changed to a thunk that calls the personality; // function wrapper in the runtime.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp:127,Integrability,wrap,wraps,127,"// We need to untag stack frames as we unwind past them. That is the job of; // the personality function wrapper, which either wraps an existing; // personality function or acts as a personality function on its own. Each; // function that has a personality function or that can be unwound past has; // its personality function changed to a thunk that calls the personality; // function wrapper in the runtime.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp:386,Integrability,wrap,wrapper,386,"// We need to untag stack frames as we unwind past them. That is the job of; // the personality function wrapper, which either wraps an existing; // personality function or acts as a personality function on its own. Each; // function that has a personality function or that can be unwound past has; // its personality function changed to a thunk that calls the personality; // function wrapper in the runtime.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp:92,Availability,avail,available,92,"// Fuchsia is always PIE, which means that the beginning of the address; // space is always available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/IndirectCallPromotion.cpp:537,Availability,avail,available,537,"//===- IndirectCallPromotion.cpp - Optimizations based on value profiling -===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the transformation that promotes indirect calls to; // conditional direct calls when the indirect-call value profile metadata is; // available.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/IndirectCallPromotion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/IndirectCallPromotion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/IndirectCallPromotion.cpp:35,Performance,Optimiz,Optimizations,35,"//===- IndirectCallPromotion.cpp - Optimizations based on value profiling -===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the transformation that promotes indirect calls to; // conditional direct calls when the indirect-call value profile metadata is; // available.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/IndirectCallPromotion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/IndirectCallPromotion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/IndirectCallPromotion.cpp:36,Performance,optimiz,optimization,36,// Set if the pass is called in LTO optimization. The difference for LTO mode; // is the pass won't prefix the source module name to the internal linkage; // symbols.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/IndirectCallPromotion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/IndirectCallPromotion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/IndirectCallPromotion.cpp:66,Safety,avoid,avoids,66,"// Don't promote if the symbol is not defined in the module. This avoids; // creating a reference to a symbol that doesn't exist in the module; // This can happen when we compile with a sample profile collected from; // one binary but used for another, which may have profiled targets that; // aren't used in the new binary. We might have a declaration initially in; // the case where the symbol is globally dead in the binary and removed by; // ThinLTO.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/IndirectCallPromotion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/IndirectCallPromotion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/IndirectCallPromotion.cpp:87,Performance,perform,perform,87,// Traverse all the indirect-call callsite and get the value profile; // annotation to perform indirect-call promotion.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/IndirectCallPromotion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/IndirectCallPromotion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/IndirectCallPromotion.cpp:21,Deployability,update,update,21,// Otherwise we need update with the un-promoted records back.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/IndirectCallPromotion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/IndirectCallPromotion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/IndirectCallPromotion.cpp:5,Integrability,wrap,wrapper,5,// A wrapper function that does the actual work.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/IndirectCallPromotion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/IndirectCallPromotion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrOrderFile.cpp:88,Modifiability,variab,variable,88,// We need a global bitmap to tell if a function is executed. We also; // need a global variable to save the order of functions. We can use a; // fixed-size buffer that saves the MD5 hash of the function. We need; // a global variable to save the index into the buffer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrOrderFile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrOrderFile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrOrderFile.cpp:226,Modifiability,variab,variable,226,// We need a global bitmap to tell if a function is executed. We also; // need a global variable to save the order of functions. We can use a; // fixed-size buffer that saves the MD5 hash of the function. We need; // a global variable to save the index into the buffer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrOrderFile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrOrderFile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrOrderFile.cpp:183,Security,hash,hash,183,// We need a global bitmap to tell if a function is executed. We also; // need a global variable to save the order of functions. We can use a; // fixed-size buffer that saves the MD5 hash of the function. We need; // a global variable to save the index into the buffer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrOrderFile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrOrderFile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrOrderFile.cpp:21,Modifiability,variab,variables,21,// Create the global variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrOrderFile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrOrderFile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrOrderFile.cpp:73,Deployability,update,update,73,// Generate the code sequence in the entry block of each function to; // update the buffer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrOrderFile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrOrderFile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrOrderFile.cpp:97,Deployability,update,update,97,"// Check the bitmap, if it is already 1, do nothing.; // Otherwise, set the bit, grab the index, update the buffer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrOrderFile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrOrderFile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrOrderFile.cpp:11,Deployability,Update,UpdateOrderFileBB,11,"// Fill up UpdateOrderFileBB: grab the index, update the buffer!",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrOrderFile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrOrderFile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrOrderFile.cpp:46,Deployability,update,update,46,"// Fill up UpdateOrderFileBB: grab the index, update the buffer!",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrOrderFile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrOrderFile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrOrderFile.cpp:14,Integrability,wrap,wrap,14,// We need to wrap around the index to fit it inside the buffer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrOrderFile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrOrderFile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp:51,Deployability,release,release,51,"// TODO: Remove -debug-info-correlate in next LLVM release, in favor of; // -profile-correlate=debug-info.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp:144,Deployability,pipeline,pipeline,144,"// If the option is not specified, the default behavior about whether; // counter promotion is done depends on how instrumentaiton lowering; // pipeline is setup, i.e., the default value of true of this option; // does not mean the promotion will be done by default. Explicitly; // setting this option can override the default behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp:100,Integrability,depend,depends,100,"// If the option is not specified, the default behavior about whether; // counter promotion is done depends on how instrumentaiton lowering; // pipeline is setup, i.e., the default value of true of this option; // does not mean the promotion will be done by default. Explicitly; // setting this option can override the default behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp:65,Performance,load,load,65,"/// If runtime relocation is enabled, this maps functions to the load; /// instruction that produces the profile relocation bias.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp:21,Performance,load,load,21,// vector of counter load/store pairs to be register promoted.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp:29,Performance,load,loads,29,/// Register-promote counter loads and stores in loops.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp:36,Deployability,update,update,36,/// Returns true if profile counter update register promotion is enabled.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp:37,Deployability,update,update,37,/// Replace instrprof.mcdc.tvbitmask.update with a shift and or instruction; /// using the index represented by the a temp value into a bitmap.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp:32,Deployability,update,update,32,/// Replace instrprof.mcdc.temp.update with a shift and or instruction using; /// the corresponding condition ID.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp:141,Modifiability,variab,variables,141,"/// Get the region counters for an increment, creating them if necessary.; ///; /// If the counter array doesn't yet exist, the profile data variables; /// referring to them will also be created.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp:31,Testability,test,test,31,/// Compute the address of the test vector bitmap that this profiling; /// instruction acts on.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp:139,Modifiability,variab,variables,139,"/// Get the region bitmaps for an increment, creating them if necessary.; ///; /// If the bitmap array doesn't yet exist, the profile data variables; /// referring to them will also be created.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp:59,Energy Efficiency,allocate,allocated,59,/// Setup the sections into which counters and bitmaps are allocated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp:27,Modifiability,variab,variable,27,/// Create INSTR_PROF_DATA variable for counters and bitmaps.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp:62,Modifiability,variab,variable,62,/// Emit runtime registration functions for each profile data variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp:25,Modifiability,variab,variables,25,/// Add uses of our data variables and runtime hook.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp:92,Deployability,update,update,92,///; /// A helper class to promote one counter RMW operation in the loop; /// into register update.; ///; /// RWM update for the counter will be sinked out of the loop after; /// the transformation.; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp:114,Deployability,update,update,114,///; /// A helper class to promote one counter RMW operation in the loop; /// into register update.; ///; /// RWM update for the counter will be sinked out of the loop after; /// the transformation.; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp:11,Deployability,update,update,11,"// automic update currently can only be promoted across the current; // loop, not the whole loop nest.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp:7,Deployability,update,update,7,// Now update the parent loop's candidate list:,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp:73,Deployability,update,updates,73,/// A helper class to do register promotion for all profile counter; /// updates in a loop.; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp:279,Safety,detect,detect,279,"// Skip if any of the ExitBlocks contains a ret instruction.; // This is to prevent dumping of incomplete profile -- if the; // the loop is a long running loop and dump is called in the middle; // of the loop, the result profile is incomplete.; // FIXME: add other heuristics to detect long running loops.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp:36,Usability,guid,guide,36,"// If BFI is set, we will use it to guide the promotions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp:67,Performance,perform,perform,67,// Check whether the loop satisfies the basic conditions needed to perform; // Counter Promotions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp:58,Deployability,update,updates,58,// Do a post-order traversal of the loops so that counter updates can be; // iteratively hoisted outside the loop nest.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp:27,Safety,avoid,avoiding,27,// Improve compile time by avoiding linear scans when there is no work.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp:201,Modifiability,variab,variable,201,// We did not know how many value sites there would be inside; // the instrumented function. This is counting the number of instrumented; // target value sites to enter it as field in the profile data variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp:66,Modifiability,variab,variable,66,// Use a profile intrinsic to create the region counters and data variable.; // Also create the data variable based on the MCDCParams.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp:101,Modifiability,variab,variable,101,// Use a profile intrinsic to create the region counters and data variable.; // Also create the data variable based on the MCDCParams.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp:33,Integrability,depend,depends,33,// TODO: Value profiling heavily depends on the data section which is omitted; // in lightweight mode. We need to move the value profile pointer to the; // Counter struct to get this working.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp:29,Modifiability,variab,variable,29,// Compiler must define this variable when runtime counter relocation; // is being used. Runtime has a weak external reference that is used; // to check whether that's the case or not.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp:103,Availability,error,errors,103,"// A definition that's weak (linkonce_odr) without being in a COMDAT; // section wouldn't lead to link errors, but it would lead to a dead; // data word from every TU but one. Putting it in COMDAT ensures there; // will be exactly one data slot in the link.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp:3,Performance,Load,Load,3,"// Load Temp Val.; // %mcdc.temp = load i32, ptr %mcdc.addr, align 4",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp:35,Performance,load,load,35,"// Load Temp Val.; // %mcdc.temp = load i32, ptr %mcdc.addr, align 4",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp:3,Performance,Load,Load,3,"// Load profile bitmap byte.; // %mcdc.bits = load i8, ptr %4, align 1",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp:46,Performance,load,load,46,"// Load profile bitmap byte.; // %mcdc.bits = load i8, ptr %4, align 1",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp:3,Performance,Perform,Perform,3,"// Perform logical OR of profile bitmap byte and shifted bit offset.; // %8 = or i8 %mcdc.bits, %7",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp:11,Testability,log,logical,11,"// Perform logical OR of profile bitmap byte and shifted bit offset.; // %8 = or i8 %mcdc.bits, %7",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp:13,Deployability,update,updated,13,"// Store the updated profile bitmap byte.; // store i8 %8, ptr %3, align 1",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp:3,Performance,Load,Load,3,"// Load the MCDC temporary value from the stack.; // %mcdc.temp = load i32, ptr %mcdc.addr, align 4",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp:66,Performance,load,load,66,"// Load the MCDC temporary value from the stack.; // %mcdc.temp = load i32, ptr %mcdc.addr, align 4",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp:8,Modifiability,extend,extend,8,// Zero-extend the evaluated condition boolean value (0 or 1) by 32bits.; // %1 = zext i1 %tobool to i32,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp:96,Deployability,Update,Update,96,"// Shift the boolean value left (by the condition's ID) to form a bitmap.; // %2 = shl i32 %1, <Update->getCondID()>",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp:3,Performance,Perform,Perform,3,"// Perform logical OR of the bitmap against the loaded MCDC temporary value.; // %3 = or i32 %mcdc.temp, %2",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp:48,Performance,load,loaded,48,"// Perform logical OR of the bitmap against the loaded MCDC temporary value.; // %3 = or i32 %mcdc.temp, %2",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp:11,Testability,log,logical,11,"// Perform logical OR of the bitmap against the loaded MCDC temporary value.; // %3 = or i32 %mcdc.temp, %2",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp:13,Deployability,update,updated,13,"// Store the updated temporary value back to the stack.; // store i32 %3, ptr %mcdc.addr, align 4",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp:32,Modifiability,variab,variable,32,/// Get the name of a profiling variable for a particular function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp:39,Modifiability,variab,variables,39,// Conservatively returns true if data variables may be referenced by code.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp:117,Modifiability,variab,variable,117,// Prohibit function address recording if the function is both internal and; // COMDAT. This avoids the profile data variable referencing internal symbols; // in COMDAT.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp:93,Safety,avoid,avoids,93,// Prohibit function address recording if the function is both internal and; // COMDAT. This avoids the profile data variable referencing internal symbols; // in COMDAT.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp:270,Availability,avail,available,270,"// Check uses of this function for other than direct calls or invokes to it.; // Inline virtual functions have linkeOnceODR linkage. When a key method; // exists, the vtable will only be emitted in the TU where the key method; // is defined. In a TU where vtable is not available, the function won't; // be 'addresstaken'. If its address is not recorded here, the profile data; // with missing address may be picked by the linker leading to missing; // indirect call target info.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp:418,Deployability,update,update,418,"// PGO + ThinLTO + CFI cause duplicate symbols to be introduced due to some; // unfavorable interaction between the new alias and the alias renaming done; // in LowerTypeTests under ThinLTO. For comdat functions that would normally; // be deduplicated, but the renaming scheme ends up preventing renaming, since; // it creates unique names for each alias, resulting in duplicated symbols. In; // the future, we should update the CFI related passes to migrate these; // aliases to the same module as the jump-table they refer to will be defined.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp:195,Safety,avoid,avoid,195,"// For comdat functions, an alias would need the same linkage as the original; // function and hidden visibility. There is no point in adding an alias with; // identical linkage an visibility to avoid introducing symbolic relocations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp:40,Safety,avoid,avoid,40,// When possible use a private alias to avoid symbolic relocations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp:415,Safety,avoid,avoids,415,"// When the instrumented function is a COMDAT function, we cannot use a; // private alias. If we did, we would create reference to a local label in; // this function's section. If this version of the function isn't selected by; // the linker, then the metadata would introduce a reference to a discarded; // section. So, for COMDAT functions, we need to adjust the linkage of the; // alias. Using hidden visibility avoids a dynamic relocation and an entry in; // the dynamic symbol table.; //; // Note that this handles COMDAT functions with visibility other than Hidden,; // since that case is covered in shouldUsePublicSymbol()",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp:78,Deployability,upgrade,upgrade,78,"// COFF doesn't allow the comdat group leader to have private linkage, so; // upgrade private linkage to internal linkage to produce a symbol table; // entry.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp:59,Modifiability,variab,variable,59,// Use internal rather than private linkage so the counter variable shows up; // in the symbol table when using debug info for correlation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp:662,Availability,error,errors,662,"// Move the name variable to the right section. Place them in a COMDAT group; // if the associated function is a COMDAT. This will make sure that only one; // copy of counters of the COMDAT function will be emitted after linking. Keep; // in mind that this pass may run before the inliner, so we need to create a; // new comdat group for the counters and profiling data. If we use the comdat; // of the parent function, that will result in relocations against discarded; // sections.; //; // If the data variable is referenced by code, counters and data have to be; // in different comdats for COFF because the Visual C++ linker will report; // duplicate symbol errors if there are multiple external symbols with the; // same name marked IMAGE_COMDAT_SELECT_ASSOCIATIVE.; //; // For ELF, when not using COMDAT, put counters, data and values into a; // nodeduplicate COMDAT which is lowered to a zero-flag section group. This; // allows -z start-stop-gc to discard the entire group when the function is; // discarded.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp:17,Modifiability,variab,variable,17,"// Move the name variable to the right section. Place them in a COMDAT group; // if the associated function is a COMDAT. This will make sure that only one; // copy of counters of the COMDAT function will be emitted after linking. Keep; // in mind that this pass may run before the inliner, so we need to create a; // new comdat group for the counters and profiling data. If we use the comdat; // of the parent function, that will result in relocations against discarded; // sections.; //; // If the data variable is referenced by code, counters and data have to be; // in different comdats for COFF because the Visual C++ linker will report; // duplicate symbol errors if there are multiple external symbols with the; // same name marked IMAGE_COMDAT_SELECT_ASSOCIATIVE.; //; // For ELF, when not using COMDAT, put counters, data and values into a; // nodeduplicate COMDAT which is lowered to a zero-flag section group. This; // allows -z start-stop-gc to discard the entire group when the function is; // discarded.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp:504,Modifiability,variab,variable,504,"// Move the name variable to the right section. Place them in a COMDAT group; // if the associated function is a COMDAT. This will make sure that only one; // copy of counters of the COMDAT function will be emitted after linking. Keep; // in mind that this pass may run before the inliner, so we need to create a; // new comdat group for the counters and profiling data. If we use the comdat; // of the parent function, that will result in relocations against discarded; // sections.; //; // If the data variable is referenced by code, counters and data have to be; // in different comdats for COFF because the Visual C++ linker will report; // duplicate symbol errors if there are multiple external symbols with the; // same name marked IMAGE_COMDAT_SELECT_ASSOCIATIVE.; //; // For ELF, when not using COMDAT, put counters, data and values into a; // nodeduplicate COMDAT which is lowered to a zero-flag section group. This; // allows -z start-stop-gc to discard the entire group when the function is; // discarded.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp:20,Modifiability,variab,variable,20,// Mark the counter variable as used so that it isn't optimized out.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp:54,Performance,optimiz,optimized,54,// Mark the counter variable as used so that it isn't optimized out.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp:19,Modifiability,variab,variable,19,// Create the data variable (if it doesn't already exist).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp:64,Modifiability,variab,variable,64,"// When debug information is correlated to profile data, a data variable; // is not needed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp:18,Modifiability,variab,variable,18,// Return if data variable was already created.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp:12,Modifiability,Variab,Variable,12,// The Data Variable section is anchored to profile counters.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp:3,Energy Efficiency,Allocate,Allocate,3,// Allocate statically the array of pointers to value profile nodes for; // the current function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp:15,Modifiability,variab,variable,15,// Create data variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp:15,Modifiability,variab,variable,15,"// If the data variable is not referenced by code (if we don't emit; // @llvm.instrprof.value.profile, NS will be 0), and the counter keeps the; // data variable live under linker GC, the data variable can be private. This; // optimization applies to ELF.; //; // On COFF, a comdat leader cannot be local so we require DataReferencedByCode; // to be false.; //; // If profd is in a deduplicate comdat, NS==0 with a hash suffix guarantees; // that other copies must have the same CFG and cannot have value profiling.; // If no hash suffix, other profd copies may be referenced by code.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp:153,Modifiability,variab,variable,153,"// If the data variable is not referenced by code (if we don't emit; // @llvm.instrprof.value.profile, NS will be 0), and the counter keeps the; // data variable live under linker GC, the data variable can be private. This; // optimization applies to ELF.; //; // On COFF, a comdat leader cannot be local so we require DataReferencedByCode; // to be false.; //; // If profd is in a deduplicate comdat, NS==0 with a hash suffix guarantees; // that other copies must have the same CFG and cannot have value profiling.; // If no hash suffix, other profd copies may be referenced by code.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp:193,Modifiability,variab,variable,193,"// If the data variable is not referenced by code (if we don't emit; // @llvm.instrprof.value.profile, NS will be 0), and the counter keeps the; // data variable live under linker GC, the data variable can be private. This; // optimization applies to ELF.; //; // On COFF, a comdat leader cannot be local so we require DataReferencedByCode; // to be false.; //; // If profd is in a deduplicate comdat, NS==0 with a hash suffix guarantees; // that other copies must have the same CFG and cannot have value profiling.; // If no hash suffix, other profd copies may be referenced by code.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp:227,Performance,optimiz,optimization,227,"// If the data variable is not referenced by code (if we don't emit; // @llvm.instrprof.value.profile, NS will be 0), and the counter keeps the; // data variable live under linker GC, the data variable can be private. This; // optimization applies to ELF.; //; // On COFF, a comdat leader cannot be local so we require DataReferencedByCode; // to be false.; //; // If profd is in a deduplicate comdat, NS==0 with a hash suffix guarantees; // that other copies must have the same CFG and cannot have value profiling.; // If no hash suffix, other profd copies may be referenced by code.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp:415,Security,hash,hash,415,"// If the data variable is not referenced by code (if we don't emit; // @llvm.instrprof.value.profile, NS will be 0), and the counter keeps the; // data variable live under linker GC, the data variable can be private. This; // optimization applies to ELF.; //; // On COFF, a comdat leader cannot be local so we require DataReferencedByCode; // to be false.; //; // If profd is in a deduplicate comdat, NS==0 with a hash suffix guarantees; // that other copies must have the same CFG and cannot have value profiling.; // If no hash suffix, other profd copies may be referenced by code.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp:526,Security,hash,hash,526,"// If the data variable is not referenced by code (if we don't emit; // @llvm.instrprof.value.profile, NS will be 0), and the counter keeps the; // data variable live under linker GC, the data variable can be private. This; // optimization applies to ELF.; //; // On COFF, a comdat leader cannot be local so we require DataReferencedByCode; // to be false.; //; // If profd is in a deduplicate comdat, NS==0 with a hash suffix guarantees; // that other copies must have the same CFG and cannot have value profiling.; // If no hash suffix, other profd copies may be referenced by code.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp:56,Performance,load,loaded,56,"// With binary profile correlation, profile data is not loaded into memory.; // profile data must reference profile counter with an absolute relocation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp:25,Modifiability,variab,variable,25,// Reference the counter variable with a label difference (link-time; // constant).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp:17,Modifiability,variab,variable,17,// Mark the data variable as used so that it isn't stripped out.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp:82,Modifiability,variab,variables,82,"// Now that the linkage set by the FE has been passed to the data and counter; // variables, reset Name variable's linkage and visibility to private so that; // it can be removed later by the compiler.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp:104,Modifiability,variab,variable,104,"// Now that the linkage set by the FE has been passed to the data and counter; // variables, reset Name variable's linkage and visibility to private so that; // it can be removed later by the compiler.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp:51,Availability,down,down,51,"// On COFF, it's important to reduce the alignment down to 1 to prevent the; // linker from inserting padding before the start of the names section or; // between names entries.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp:30,Energy Efficiency,reduce,reduce,30,"// On COFF, it's important to reduce the alignment down to 1 to prevent the; // linker from inserting padding before the start of the names section or; // between names entries.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp:127,Modifiability,variab,variable,127,// We expect the linker to be invoked with -u<hook_var> flag for Linux; // in which case there is no need to emit the external variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp:23,Modifiability,variab,variable,23,// Declare an external variable that will pull in the runtime initialization.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp:17,Modifiability,variab,variable,17,// Mark the user variable as used so that it isn't stripped out.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp:46,Performance,Optimiz,Optimizers,46,"// The metadata sections are parallel arrays. Optimizers (e.g.; // GlobalOpt/ConstantMerge) may not discard associated sections as a unit, so; // we conservatively retain all unconditionally in the compiler.; //; // On ELF and Mach-O, the linker can guarantee the associated sections will be; // retained or discarded as a unit, so llvm.compiler.used is sufficient.; // Similarly on COFF, if prof data is not referenced by code we use one comdat; // and ensure this GC property as well. Otherwise, we have to conservatively; // make all of the sections retained by the linker.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp:26,Modifiability,variab,variable,26,// Create ProfileFileName variable. Don't don't this for the; // context-sensitive instrumentation lowering: This lowering is after; // LTO/ThinLTO linking. Pass PGOInstrumentationGenCreateVar should; // have already create the variable before LTO/ThinLTO linking.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp:228,Modifiability,variab,variable,228,// Create ProfileFileName variable. Don't don't this for the; // context-sensitive instrumentation lowering: This lowering is after; // LTO/ThinLTO linking. Pass PGOInstrumentationGenCreateVar should; // have already create the variable before LTO/ThinLTO linking.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/Instrumentation.cpp:37,Availability,down,down,37,"// If I is IP, move the insert point down.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/Instrumentation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/Instrumentation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/KCFI.cpp:3,Deployability,patch,patchable-function-prefix,3,"// patchable-function-prefix emits nops between the KCFI type identifier; // and the function start. As we don't know the size of the emitted nops,; // don't allow this attribute with generic lowering.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/KCFI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/KCFI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/KCFI.cpp:20,Security,hash,hash,20,// Get the expected hash value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/KCFI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/KCFI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/KCFI.cpp:39,Security,hash,hash,39,// Emit a check and trap if the target hash doesn't match.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/KCFI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/KCFI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/KCFI.cpp:212,Security,hash,hash,212,"// ARM uses the least significant bit of the function pointer to select; // between ARM and Thumb modes for the callee. Instructions are always; // at least 16-bit aligned, so clear the LSB before we compute the hash; // location.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/KCFI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/KCFI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/KCFI.cpp:176,Usability,clear,clear,176,"// ARM uses the least significant bit of the function pointer to select; // between ARM and Thumb modes for the callee. Instructions are always; // at least 16-bit aligned, so clear the LSB before we compute the hash; // location.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/KCFI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/KCFI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:2115,Availability,error,error,2115," gives us much better register allocation, possible compiler; /// optimizations and a fast start-up. But this brings the major issue; /// as well: msan needs to see all program events, including system; /// calls and reads/writes in system libraries, so we either need to; /// compile *everything* with msan or use a binary translation; /// component (e.g. DynamoRIO) to instrument pre-built libraries.; /// Another difference from Memcheck is that we use 8 shadow bits per; /// byte of application memory and use a direct shadow mapping. This; /// greatly simplifies the instrumentation code and avoids races on; /// shadow updates (Memcheck is single-threaded so races are not a; /// concern there. Memcheck uses 2 shadow bits per byte with a slow; /// path storage that uses 8 bits per byte).; ///; /// The default value of shadow is 0, which means ""clean"" (not poisoned).; ///; /// Every module initializer should call __msan_init to ensure that the; /// shadow memory is ready. On error, __msan_warning is called. Since; /// parameters and return values may be passed via registers, we have a; /// specialized thread-local shadow for return values; /// (__msan_retval_tls) and parameters (__msan_param_tls).; ///; /// Origin tracking.; ///; /// MemorySanitizer can track origins (allocation points) of all uninitialized; /// values. This behavior is controlled with a flag (msan-track-origins) and is; /// disabled by default.; ///; /// Origins are 4-byte values created and interpreted by the runtime library.; /// They are stored in a second shadow mapping, one 4-byte value for 4 bytes; /// of application memory. Propagation of origins is basically a bunch of; /// ""select"" instructions that pick the origin of a dirty argument, if an; /// instruction has one.; ///; /// Every 4 aligned, consecutive bytes of application memory have one origin; /// value associated with them. If these bytes contain uninitialized data; /// coming from 2 different allocations, the last store wins. Because o",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:1754,Deployability,update,updates,1754,"/ propagate the shadow bits through some of the arithmetic; /// instruction (including MOV), store the shadow bits on every memory; /// write, report a bug on some other instructions (e.g. JMP) if the; /// associated shadow is poisoned.; ///; /// But there are differences too. The first and the major one:; /// compiler instrumentation instead of binary instrumentation. This; /// gives us much better register allocation, possible compiler; /// optimizations and a fast start-up. But this brings the major issue; /// as well: msan needs to see all program events, including system; /// calls and reads/writes in system libraries, so we either need to; /// compile *everything* with msan or use a binary translation; /// component (e.g. DynamoRIO) to instrument pre-built libraries.; /// Another difference from Memcheck is that we use 8 shadow bits per; /// byte of application memory and use a direct shadow mapping. This; /// greatly simplifies the instrumentation code and avoids races on; /// shadow updates (Memcheck is single-threaded so races are not a; /// concern there. Memcheck uses 2 shadow bits per byte with a slow; /// path storage that uses 8 bits per byte).; ///; /// The default value of shadow is 0, which means ""clean"" (not poisoned).; ///; /// Every module initializer should call __msan_init to ensure that the; /// shadow memory is ready. On error, __msan_warning is called. Since; /// parameters and return values may be passed via registers, we have a; /// specialized thread-local shadow for return values; /// (__msan_retval_tls) and parameters (__msan_param_tls).; ///; /// Origin tracking.; ///; /// MemorySanitizer can track origins (allocation points) of all uninitialized; /// values. This behavior is controlled with a flag (msan-track-origins) and is; /// disabled by default.; ///; /// Origins are 4-byte values created and interpreted by the runtime library.; /// They are stored in a second shadow mapping, one 4-byte value for 4 bytes; /// of application memor",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:3641,Deployability,update,update,3641,"rary.; /// They are stored in a second shadow mapping, one 4-byte value for 4 bytes; /// of application memory. Propagation of origins is basically a bunch of; /// ""select"" instructions that pick the origin of a dirty argument, if an; /// instruction has one.; ///; /// Every 4 aligned, consecutive bytes of application memory have one origin; /// value associated with them. If these bytes contain uninitialized data; /// coming from 2 different allocations, the last store wins. Because of this,; /// MemorySanitizer reports can show unrelated origins, but this is unlikely in; /// practice.; ///; /// Origins are meaningless for fully initialized values, so MemorySanitizer; /// avoids storing origin to memory when a fully initialized value is stored.; /// This way it avoids needless overwriting origin of the 4-byte region on; /// a short (i.e. 1 byte) clean store, and it is also good for performance.; ///; /// Atomic handling.; ///; /// Ideally, every atomic store of application value should update the; /// corresponding shadow location in an atomic way. Unfortunately, atomic store; /// of two disjoint locations can not be done without severe slowdown.; ///; /// Therefore, we implement an approximation that may err on the safe side.; /// In this implementation, every atomically accessed location in the program; /// may only change from (partially) uninitialized to fully initialized, but; /// not the other way around. We load the shadow _after_ the application load,; /// and we store the shadow _before_ the app store. Also, we always store clean; /// shadow (if the application store is atomic). This way, if the store-load; /// pair constitutes a happens-before arc, shadow store and load are correctly; /// ordered such that the load will get either the value that was stored, or; /// some later value (which is always clean).; ///; /// This does not work very well with Compare-And-Swap (CAS) and; /// Read-Modify-Write (RMW) operations. To follow the above logic, CAS and RMW;",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:6218,Energy Efficiency,allocate,allocates,6218,"int to inputs and outputs, but the; /// actual semantics can be only visible at runtime. In the Linux kernel it's; /// also possible that the arguments only indicate the offset for a base taken; /// from a segment register, so it's dangerous to treat any asm() arguments as; /// pointers. We take a conservative approach generating calls to; /// __msan_instrument_asm_store(ptr, size); /// , which defer the memory unpoisoning to the runtime library.; /// The latter can perform more complex address checks to figure out whether; /// it's safe to touch the shadow memory.; /// Like with atomic operations, we call __msan_instrument_asm_store() before; /// the assembly call, so that changes to the shadow memory will be seen by; /// other threads together with main memory initialization.; ///; /// KernelMemorySanitizer (KMSAN) implementation.; ///; /// The major differences between KMSAN and MSan instrumentation are:; /// - KMSAN always tracks the origins and implies msan-keep-going=true;; /// - KMSAN allocates shadow and origin memory for each page separately, so; /// there are no explicit accesses to shadow and origin in the; /// instrumentation.; /// Shadow and origin values for a particular X-byte memory location; /// (X=1,2,4,8) are accessed through pointers obtained via the; /// __msan_metadata_ptr_for_load_X(ptr); /// __msan_metadata_ptr_for_store_X(ptr); /// functions. The corresponding functions check that the X-byte accesses; /// are possible and returns the pointers to shadow and origin memory.; /// Arbitrary sized accesses are handled with:; /// __msan_metadata_ptr_for_load_n(ptr, size); /// __msan_metadata_ptr_for_store_n(ptr, size);; /// Note that the sanitizer code has to deal with how shadow/origin pairs; /// returned by the these functions are represented in different ABIs. In; /// the X86_64 ABI they are returned in RDX:RAX, and in the SystemZ ABI they; /// are written to memory pointed to by a hidden parameter.; /// - TLS variables are stored in a single pe",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:5114,Integrability,depend,depending,5114,"d. We load the shadow _after_ the application load,; /// and we store the shadow _before_ the app store. Also, we always store clean; /// shadow (if the application store is atomic). This way, if the store-load; /// pair constitutes a happens-before arc, shadow store and load are correctly; /// ordered such that the load will get either the value that was stored, or; /// some later value (which is always clean).; ///; /// This does not work very well with Compare-And-Swap (CAS) and; /// Read-Modify-Write (RMW) operations. To follow the above logic, CAS and RMW; /// must store the new shadow before the app operation, and load the shadow; /// after the app operation. Computers don't work this way. Current; /// implementation ignores the load aspect of CAS/RMW, always returning a clean; /// value. It implements the store part as a simple atomic store by storing a; /// clean shadow.; ///; /// Instrumenting inline assembly.; ///; /// For inline assembly code LLVM has little idea about which memory locations; /// become initialized depending on the arguments. It can be possible to figure; /// out which arguments are meant to point to inputs and outputs, but the; /// actual semantics can be only visible at runtime. In the Linux kernel it's; /// also possible that the arguments only indicate the offset for a base taken; /// from a segment register, so it's dangerous to treat any asm() arguments as; /// pointers. We take a conservative approach generating calls to; /// __msan_instrument_asm_store(ptr, size); /// , which defer the memory unpoisoning to the runtime library.; /// The latter can perform more complex address checks to figure out whether; /// it's safe to touch the shadow memory.; /// Like with atomic operations, we call __msan_instrument_asm_store() before; /// the assembly call, so that changes to the shadow memory will be seen by; /// other threads together with main memory initialization.; ///; /// KernelMemorySanitizer (KMSAN) implementation.; ///; /// The maj",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:7176,Modifiability,variab,variables,7176,"tion are:; /// - KMSAN always tracks the origins and implies msan-keep-going=true;; /// - KMSAN allocates shadow and origin memory for each page separately, so; /// there are no explicit accesses to shadow and origin in the; /// instrumentation.; /// Shadow and origin values for a particular X-byte memory location; /// (X=1,2,4,8) are accessed through pointers obtained via the; /// __msan_metadata_ptr_for_load_X(ptr); /// __msan_metadata_ptr_for_store_X(ptr); /// functions. The corresponding functions check that the X-byte accesses; /// are possible and returns the pointers to shadow and origin memory.; /// Arbitrary sized accesses are handled with:; /// __msan_metadata_ptr_for_load_n(ptr, size); /// __msan_metadata_ptr_for_store_n(ptr, size);; /// Note that the sanitizer code has to deal with how shadow/origin pairs; /// returned by the these functions are represented in different ABIs. In; /// the X86_64 ABI they are returned in RDX:RAX, and in the SystemZ ABI they; /// are written to memory pointed to by a hidden parameter.; /// - TLS variables are stored in a single per-task struct. A call to a; /// function __msan_get_context_state() returning a pointer to that struct; /// is inserted into every instrumented function before the entry block;; /// - __msan_warning() takes a 32-bit origin parameter;; /// - local variables are poisoned with __msan_poison_alloca() upon function; /// entry and unpoisoned with __msan_unpoison_alloca() before leaving the; /// function;; /// - the pass doesn't declare any global variables or add global constructors; /// to the translation unit.; ///; /// Also, KMSAN currently ignores uninitialized memory passed into inline asm; /// calls, making sure we're on the safe side wrt. possible false positives.; ///; /// KernelMemorySanitizer only supports X86_64 and SystemZ at the moment.; ///; //; // FIXME: This sanitizer does not yet handle scalable vectors; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:7458,Modifiability,variab,variables,7458,"tion are:; /// - KMSAN always tracks the origins and implies msan-keep-going=true;; /// - KMSAN allocates shadow and origin memory for each page separately, so; /// there are no explicit accesses to shadow and origin in the; /// instrumentation.; /// Shadow and origin values for a particular X-byte memory location; /// (X=1,2,4,8) are accessed through pointers obtained via the; /// __msan_metadata_ptr_for_load_X(ptr); /// __msan_metadata_ptr_for_store_X(ptr); /// functions. The corresponding functions check that the X-byte accesses; /// are possible and returns the pointers to shadow and origin memory.; /// Arbitrary sized accesses are handled with:; /// __msan_metadata_ptr_for_load_n(ptr, size); /// __msan_metadata_ptr_for_store_n(ptr, size);; /// Note that the sanitizer code has to deal with how shadow/origin pairs; /// returned by the these functions are represented in different ABIs. In; /// the X86_64 ABI they are returned in RDX:RAX, and in the SystemZ ABI they; /// are written to memory pointed to by a hidden parameter.; /// - TLS variables are stored in a single per-task struct. A call to a; /// function __msan_get_context_state() returning a pointer to that struct; /// is inserted into every instrumented function before the entry block;; /// - __msan_warning() takes a 32-bit origin parameter;; /// - local variables are poisoned with __msan_poison_alloca() upon function; /// entry and unpoisoned with __msan_unpoison_alloca() before leaving the; /// function;; /// - the pass doesn't declare any global variables or add global constructors; /// to the translation unit.; ///; /// Also, KMSAN currently ignores uninitialized memory passed into inline asm; /// calls, making sure we're on the safe side wrt. possible false positives.; ///; /// KernelMemorySanitizer only supports X86_64 and SystemZ at the moment.; ///; //; // FIXME: This sanitizer does not yet handle scalable vectors; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:7656,Modifiability,variab,variables,7656,"tion are:; /// - KMSAN always tracks the origins and implies msan-keep-going=true;; /// - KMSAN allocates shadow and origin memory for each page separately, so; /// there are no explicit accesses to shadow and origin in the; /// instrumentation.; /// Shadow and origin values for a particular X-byte memory location; /// (X=1,2,4,8) are accessed through pointers obtained via the; /// __msan_metadata_ptr_for_load_X(ptr); /// __msan_metadata_ptr_for_store_X(ptr); /// functions. The corresponding functions check that the X-byte accesses; /// are possible and returns the pointers to shadow and origin memory.; /// Arbitrary sized accesses are handled with:; /// __msan_metadata_ptr_for_load_n(ptr, size); /// __msan_metadata_ptr_for_store_n(ptr, size);; /// Note that the sanitizer code has to deal with how shadow/origin pairs; /// returned by the these functions are represented in different ABIs. In; /// the X86_64 ABI they are returned in RDX:RAX, and in the SystemZ ABI they; /// are written to memory pointed to by a hidden parameter.; /// - TLS variables are stored in a single per-task struct. A call to a; /// function __msan_get_context_state() returning a pointer to that struct; /// is inserted into every instrumented function before the entry block;; /// - __msan_warning() takes a 32-bit origin parameter;; /// - local variables are poisoned with __msan_poison_alloca() upon function; /// entry and unpoisoned with __msan_unpoison_alloca() before leaving the; /// function;; /// - the pass doesn't declare any global variables or add global constructors; /// to the translation unit.; ///; /// Also, KMSAN currently ignores uninitialized memory passed into inline asm; /// calls, making sure we're on the safe side wrt. possible false positives.; ///; /// KernelMemorySanitizer only supports X86_64 and SystemZ at the moment.; ///; //; // FIXME: This sanitizer does not yet handle scalable vectors; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:702,Performance,load,load,702,"//===- MemorySanitizer.cpp - detector of uninitialized reads --------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file; /// This file is a part of MemorySanitizer, a detector of uninitialized; /// reads.; ///; /// The algorithm of the tool is similar to Memcheck; /// (http://goo.gl/QKbem). We associate a few shadow bits with every; /// byte of the application memory, poison the shadow of the malloc-ed; /// or alloca-ed memory, load the shadow bits on every memory read,; /// propagate the shadow bits through some of the arithmetic; /// instruction (including MOV), store the shadow bits on every memory; /// write, report a bug on some other instructions (e.g. JMP) if the; /// associated shadow is poisoned.; ///; /// But there are differences too. The first and the major one:; /// compiler instrumentation instead of binary instrumentation. This; /// gives us much better register allocation, possible compiler; /// optimizations and a fast start-up. But this brings the major issue; /// as well: msan needs to see all program events, including system; /// calls and reads/writes in system libraries, so we either need to; /// compile *everything* with msan or use a binary translation; /// component (e.g. DynamoRIO) to instrument pre-built libraries.; /// Another difference from Memcheck is that we use 8 shadow bits per; /// byte of application memory and use a direct shadow mapping. This; /// greatly simplifies the instrumentation code and avoids races on; /// shadow updates (Memcheck is single-threaded so races are not a; /// concern there. Memcheck uses 2 shadow bits per byte with a slow; /// path storage that uses 8 bits per byte).; ///; /// The default value of shadow is 0, which means ""clean"" (not poisone",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:1195,Performance,optimiz,optimizations,1195," https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file; /// This file is a part of MemorySanitizer, a detector of uninitialized; /// reads.; ///; /// The algorithm of the tool is similar to Memcheck; /// (http://goo.gl/QKbem). We associate a few shadow bits with every; /// byte of the application memory, poison the shadow of the malloc-ed; /// or alloca-ed memory, load the shadow bits on every memory read,; /// propagate the shadow bits through some of the arithmetic; /// instruction (including MOV), store the shadow bits on every memory; /// write, report a bug on some other instructions (e.g. JMP) if the; /// associated shadow is poisoned.; ///; /// But there are differences too. The first and the major one:; /// compiler instrumentation instead of binary instrumentation. This; /// gives us much better register allocation, possible compiler; /// optimizations and a fast start-up. But this brings the major issue; /// as well: msan needs to see all program events, including system; /// calls and reads/writes in system libraries, so we either need to; /// compile *everything* with msan or use a binary translation; /// component (e.g. DynamoRIO) to instrument pre-built libraries.; /// Another difference from Memcheck is that we use 8 shadow bits per; /// byte of application memory and use a direct shadow mapping. This; /// greatly simplifies the instrumentation code and avoids races on; /// shadow updates (Memcheck is single-threaded so races are not a; /// concern there. Memcheck uses 2 shadow bits per byte with a slow; /// path storage that uses 8 bits per byte).; ///; /// The default value of shadow is 0, which means ""clean"" (not poisoned).; ///; /// Every module initializer should call __msan_init to ensure that the; /// shadow memory is ready. On error, __msan_warning is called. Since; /// parameters and ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:3535,Performance,perform,performance,3535,"-origins) and is; /// disabled by default.; ///; /// Origins are 4-byte values created and interpreted by the runtime library.; /// They are stored in a second shadow mapping, one 4-byte value for 4 bytes; /// of application memory. Propagation of origins is basically a bunch of; /// ""select"" instructions that pick the origin of a dirty argument, if an; /// instruction has one.; ///; /// Every 4 aligned, consecutive bytes of application memory have one origin; /// value associated with them. If these bytes contain uninitialized data; /// coming from 2 different allocations, the last store wins. Because of this,; /// MemorySanitizer reports can show unrelated origins, but this is unlikely in; /// practice.; ///; /// Origins are meaningless for fully initialized values, so MemorySanitizer; /// avoids storing origin to memory when a fully initialized value is stored.; /// This way it avoids needless overwriting origin of the 4-byte region on; /// a short (i.e. 1 byte) clean store, and it is also good for performance.; ///; /// Atomic handling.; ///; /// Ideally, every atomic store of application value should update the; /// corresponding shadow location in an atomic way. Unfortunately, atomic store; /// of two disjoint locations can not be done without severe slowdown.; ///; /// Therefore, we implement an approximation that may err on the safe side.; /// In this implementation, every atomically accessed location in the program; /// may only change from (partially) uninitialized to fully initialized, but; /// not the other way around. We load the shadow _after_ the application load,; /// and we store the shadow _before_ the app store. Also, we always store clean; /// shadow (if the application store is atomic). This way, if the store-load; /// pair constitutes a happens-before arc, shadow store and load are correctly; /// ordered such that the load will get either the value that was stored, or; /// some later value (which is always clean).; ///; /// This does not work v",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:4078,Performance,load,load,4078,"se of this,; /// MemorySanitizer reports can show unrelated origins, but this is unlikely in; /// practice.; ///; /// Origins are meaningless for fully initialized values, so MemorySanitizer; /// avoids storing origin to memory when a fully initialized value is stored.; /// This way it avoids needless overwriting origin of the 4-byte region on; /// a short (i.e. 1 byte) clean store, and it is also good for performance.; ///; /// Atomic handling.; ///; /// Ideally, every atomic store of application value should update the; /// corresponding shadow location in an atomic way. Unfortunately, atomic store; /// of two disjoint locations can not be done without severe slowdown.; ///; /// Therefore, we implement an approximation that may err on the safe side.; /// In this implementation, every atomically accessed location in the program; /// may only change from (partially) uninitialized to fully initialized, but; /// not the other way around. We load the shadow _after_ the application load,; /// and we store the shadow _before_ the app store. Also, we always store clean; /// shadow (if the application store is atomic). This way, if the store-load; /// pair constitutes a happens-before arc, shadow store and load are correctly; /// ordered such that the load will get either the value that was stored, or; /// some later value (which is always clean).; ///; /// This does not work very well with Compare-And-Swap (CAS) and; /// Read-Modify-Write (RMW) operations. To follow the above logic, CAS and RMW; /// must store the new shadow before the app operation, and load the shadow; /// after the app operation. Computers don't work this way. Current; /// implementation ignores the load aspect of CAS/RMW, always returning a clean; /// value. It implements the store part as a simple atomic store by storing a; /// clean shadow.; ///; /// Instrumenting inline assembly.; ///; /// For inline assembly code LLVM has little idea about which memory locations; /// become initialized depending o",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:4118,Performance,load,load,4118,"se of this,; /// MemorySanitizer reports can show unrelated origins, but this is unlikely in; /// practice.; ///; /// Origins are meaningless for fully initialized values, so MemorySanitizer; /// avoids storing origin to memory when a fully initialized value is stored.; /// This way it avoids needless overwriting origin of the 4-byte region on; /// a short (i.e. 1 byte) clean store, and it is also good for performance.; ///; /// Atomic handling.; ///; /// Ideally, every atomic store of application value should update the; /// corresponding shadow location in an atomic way. Unfortunately, atomic store; /// of two disjoint locations can not be done without severe slowdown.; ///; /// Therefore, we implement an approximation that may err on the safe side.; /// In this implementation, every atomically accessed location in the program; /// may only change from (partially) uninitialized to fully initialized, but; /// not the other way around. We load the shadow _after_ the application load,; /// and we store the shadow _before_ the app store. Also, we always store clean; /// shadow (if the application store is atomic). This way, if the store-load; /// pair constitutes a happens-before arc, shadow store and load are correctly; /// ordered such that the load will get either the value that was stored, or; /// some later value (which is always clean).; ///; /// This does not work very well with Compare-And-Swap (CAS) and; /// Read-Modify-Write (RMW) operations. To follow the above logic, CAS and RMW; /// must store the new shadow before the app operation, and load the shadow; /// after the app operation. Computers don't work this way. Current; /// implementation ignores the load aspect of CAS/RMW, always returning a clean; /// value. It implements the store part as a simple atomic store by storing a; /// clean shadow.; ///; /// Instrumenting inline assembly.; ///; /// For inline assembly code LLVM has little idea about which memory locations; /// become initialized depending o",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:4278,Performance,load,load,4278,"ialized value is stored.; /// This way it avoids needless overwriting origin of the 4-byte region on; /// a short (i.e. 1 byte) clean store, and it is also good for performance.; ///; /// Atomic handling.; ///; /// Ideally, every atomic store of application value should update the; /// corresponding shadow location in an atomic way. Unfortunately, atomic store; /// of two disjoint locations can not be done without severe slowdown.; ///; /// Therefore, we implement an approximation that may err on the safe side.; /// In this implementation, every atomically accessed location in the program; /// may only change from (partially) uninitialized to fully initialized, but; /// not the other way around. We load the shadow _after_ the application load,; /// and we store the shadow _before_ the app store. Also, we always store clean; /// shadow (if the application store is atomic). This way, if the store-load; /// pair constitutes a happens-before arc, shadow store and load are correctly; /// ordered such that the load will get either the value that was stored, or; /// some later value (which is always clean).; ///; /// This does not work very well with Compare-And-Swap (CAS) and; /// Read-Modify-Write (RMW) operations. To follow the above logic, CAS and RMW; /// must store the new shadow before the app operation, and load the shadow; /// after the app operation. Computers don't work this way. Current; /// implementation ignores the load aspect of CAS/RMW, always returning a clean; /// value. It implements the store part as a simple atomic store by storing a; /// clean shadow.; ///; /// Instrumenting inline assembly.; ///; /// For inline assembly code LLVM has little idea about which memory locations; /// become initialized depending on the arguments. It can be possible to figure; /// out which arguments are meant to point to inputs and outputs, but the; /// actual semantics can be only visible at runtime. In the Linux kernel it's; /// also possible that the arguments only ind",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:4344,Performance,load,load,4344,"ialized value is stored.; /// This way it avoids needless overwriting origin of the 4-byte region on; /// a short (i.e. 1 byte) clean store, and it is also good for performance.; ///; /// Atomic handling.; ///; /// Ideally, every atomic store of application value should update the; /// corresponding shadow location in an atomic way. Unfortunately, atomic store; /// of two disjoint locations can not be done without severe slowdown.; ///; /// Therefore, we implement an approximation that may err on the safe side.; /// In this implementation, every atomically accessed location in the program; /// may only change from (partially) uninitialized to fully initialized, but; /// not the other way around. We load the shadow _after_ the application load,; /// and we store the shadow _before_ the app store. Also, we always store clean; /// shadow (if the application store is atomic). This way, if the store-load; /// pair constitutes a happens-before arc, shadow store and load are correctly; /// ordered such that the load will get either the value that was stored, or; /// some later value (which is always clean).; ///; /// This does not work very well with Compare-And-Swap (CAS) and; /// Read-Modify-Write (RMW) operations. To follow the above logic, CAS and RMW; /// must store the new shadow before the app operation, and load the shadow; /// after the app operation. Computers don't work this way. Current; /// implementation ignores the load aspect of CAS/RMW, always returning a clean; /// value. It implements the store part as a simple atomic store by storing a; /// clean shadow.; ///; /// Instrumenting inline assembly.; ///; /// For inline assembly code LLVM has little idea about which memory locations; /// become initialized depending on the arguments. It can be possible to figure; /// out which arguments are meant to point to inputs and outputs, but the; /// actual semantics can be only visible at runtime. In the Linux kernel it's; /// also possible that the arguments only ind",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:4390,Performance,load,load,4390,"ialized value is stored.; /// This way it avoids needless overwriting origin of the 4-byte region on; /// a short (i.e. 1 byte) clean store, and it is also good for performance.; ///; /// Atomic handling.; ///; /// Ideally, every atomic store of application value should update the; /// corresponding shadow location in an atomic way. Unfortunately, atomic store; /// of two disjoint locations can not be done without severe slowdown.; ///; /// Therefore, we implement an approximation that may err on the safe side.; /// In this implementation, every atomically accessed location in the program; /// may only change from (partially) uninitialized to fully initialized, but; /// not the other way around. We load the shadow _after_ the application load,; /// and we store the shadow _before_ the app store. Also, we always store clean; /// shadow (if the application store is atomic). This way, if the store-load; /// pair constitutes a happens-before arc, shadow store and load are correctly; /// ordered such that the load will get either the value that was stored, or; /// some later value (which is always clean).; ///; /// This does not work very well with Compare-And-Swap (CAS) and; /// Read-Modify-Write (RMW) operations. To follow the above logic, CAS and RMW; /// must store the new shadow before the app operation, and load the shadow; /// after the app operation. Computers don't work this way. Current; /// implementation ignores the load aspect of CAS/RMW, always returning a clean; /// value. It implements the store part as a simple atomic store by storing a; /// clean shadow.; ///; /// Instrumenting inline assembly.; ///; /// For inline assembly code LLVM has little idea about which memory locations; /// become initialized depending on the arguments. It can be possible to figure; /// out which arguments are meant to point to inputs and outputs, but the; /// actual semantics can be only visible at runtime. In the Linux kernel it's; /// also possible that the arguments only ind",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:4700,Performance,load,load,4700,"hadow location in an atomic way. Unfortunately, atomic store; /// of two disjoint locations can not be done without severe slowdown.; ///; /// Therefore, we implement an approximation that may err on the safe side.; /// In this implementation, every atomically accessed location in the program; /// may only change from (partially) uninitialized to fully initialized, but; /// not the other way around. We load the shadow _after_ the application load,; /// and we store the shadow _before_ the app store. Also, we always store clean; /// shadow (if the application store is atomic). This way, if the store-load; /// pair constitutes a happens-before arc, shadow store and load are correctly; /// ordered such that the load will get either the value that was stored, or; /// some later value (which is always clean).; ///; /// This does not work very well with Compare-And-Swap (CAS) and; /// Read-Modify-Write (RMW) operations. To follow the above logic, CAS and RMW; /// must store the new shadow before the app operation, and load the shadow; /// after the app operation. Computers don't work this way. Current; /// implementation ignores the load aspect of CAS/RMW, always returning a clean; /// value. It implements the store part as a simple atomic store by storing a; /// clean shadow.; ///; /// Instrumenting inline assembly.; ///; /// For inline assembly code LLVM has little idea about which memory locations; /// become initialized depending on the arguments. It can be possible to figure; /// out which arguments are meant to point to inputs and outputs, but the; /// actual semantics can be only visible at runtime. In the Linux kernel it's; /// also possible that the arguments only indicate the offset for a base taken; /// from a segment register, so it's dangerous to treat any asm() arguments as; /// pointers. We take a conservative approach generating calls to; /// __msan_instrument_asm_store(ptr, size); /// , which defer the memory unpoisoning to the runtime library.; /// The l",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:4817,Performance,load,load,4817,"we implement an approximation that may err on the safe side.; /// In this implementation, every atomically accessed location in the program; /// may only change from (partially) uninitialized to fully initialized, but; /// not the other way around. We load the shadow _after_ the application load,; /// and we store the shadow _before_ the app store. Also, we always store clean; /// shadow (if the application store is atomic). This way, if the store-load; /// pair constitutes a happens-before arc, shadow store and load are correctly; /// ordered such that the load will get either the value that was stored, or; /// some later value (which is always clean).; ///; /// This does not work very well with Compare-And-Swap (CAS) and; /// Read-Modify-Write (RMW) operations. To follow the above logic, CAS and RMW; /// must store the new shadow before the app operation, and load the shadow; /// after the app operation. Computers don't work this way. Current; /// implementation ignores the load aspect of CAS/RMW, always returning a clean; /// value. It implements the store part as a simple atomic store by storing a; /// clean shadow.; ///; /// Instrumenting inline assembly.; ///; /// For inline assembly code LLVM has little idea about which memory locations; /// become initialized depending on the arguments. It can be possible to figure; /// out which arguments are meant to point to inputs and outputs, but the; /// actual semantics can be only visible at runtime. In the Linux kernel it's; /// also possible that the arguments only indicate the offset for a base taken; /// from a segment register, so it's dangerous to treat any asm() arguments as; /// pointers. We take a conservative approach generating calls to; /// __msan_instrument_asm_store(ptr, size); /// , which defer the memory unpoisoning to the runtime library.; /// The latter can perform more complex address checks to figure out whether; /// it's safe to touch the shadow memory.; /// Like with atomic operations, we call __",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:5682,Performance,perform,perform,5682,"after the app operation. Computers don't work this way. Current; /// implementation ignores the load aspect of CAS/RMW, always returning a clean; /// value. It implements the store part as a simple atomic store by storing a; /// clean shadow.; ///; /// Instrumenting inline assembly.; ///; /// For inline assembly code LLVM has little idea about which memory locations; /// become initialized depending on the arguments. It can be possible to figure; /// out which arguments are meant to point to inputs and outputs, but the; /// actual semantics can be only visible at runtime. In the Linux kernel it's; /// also possible that the arguments only indicate the offset for a base taken; /// from a segment register, so it's dangerous to treat any asm() arguments as; /// pointers. We take a conservative approach generating calls to; /// __msan_instrument_asm_store(ptr, size); /// , which defer the memory unpoisoning to the runtime library.; /// The latter can perform more complex address checks to figure out whether; /// it's safe to touch the shadow memory.; /// Like with atomic operations, we call __msan_instrument_asm_store() before; /// the assembly call, so that changes to the shadow memory will be seen by; /// other threads together with main memory initialization.; ///; /// KernelMemorySanitizer (KMSAN) implementation.; ///; /// The major differences between KMSAN and MSan instrumentation are:; /// - KMSAN always tracks the origins and implies msan-keep-going=true;; /// - KMSAN allocates shadow and origin memory for each page separately, so; /// there are no explicit accesses to shadow and origin in the; /// instrumentation.; /// Shadow and origin values for a particular X-byte memory location; /// (X=1,2,4,8) are accessed through pointers obtained via the; /// __msan_metadata_ptr_for_load_X(ptr); /// __msan_metadata_ptr_for_store_X(ptr); /// functions. The corresponding functions check that the X-byte accesses; /// are possible and returns the pointers to shadow and origi",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:8020,Performance,scalab,scalable,8020,"tion are:; /// - KMSAN always tracks the origins and implies msan-keep-going=true;; /// - KMSAN allocates shadow and origin memory for each page separately, so; /// there are no explicit accesses to shadow and origin in the; /// instrumentation.; /// Shadow and origin values for a particular X-byte memory location; /// (X=1,2,4,8) are accessed through pointers obtained via the; /// __msan_metadata_ptr_for_load_X(ptr); /// __msan_metadata_ptr_for_store_X(ptr); /// functions. The corresponding functions check that the X-byte accesses; /// are possible and returns the pointers to shadow and origin memory.; /// Arbitrary sized accesses are handled with:; /// __msan_metadata_ptr_for_load_n(ptr, size); /// __msan_metadata_ptr_for_store_n(ptr, size);; /// Note that the sanitizer code has to deal with how shadow/origin pairs; /// returned by the these functions are represented in different ABIs. In; /// the X86_64 ABI they are returned in RDX:RAX, and in the SystemZ ABI they; /// are written to memory pointed to by a hidden parameter.; /// - TLS variables are stored in a single per-task struct. A call to a; /// function __msan_get_context_state() returning a pointer to that struct; /// is inserted into every instrumented function before the entry block;; /// - __msan_warning() takes a 32-bit origin parameter;; /// - local variables are poisoned with __msan_poison_alloca() upon function; /// entry and unpoisoned with __msan_unpoison_alloca() before leaving the; /// function;; /// - the pass doesn't declare any global variables or add global constructors; /// to the translation unit.; ///; /// Also, KMSAN currently ignores uninitialized memory passed into inline asm; /// calls, making sure we're on the safe side wrt. possible false positives.; ///; /// KernelMemorySanitizer only supports X86_64 and SystemZ at the moment.; ///; //; // FIXME: This sanitizer does not yet handle scalable vectors; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:29,Safety,detect,detector,29,"//===- MemorySanitizer.cpp - detector of uninitialized reads --------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file; /// This file is a part of MemorySanitizer, a detector of uninitialized; /// reads.; ///; /// The algorithm of the tool is similar to Memcheck; /// (http://goo.gl/QKbem). We associate a few shadow bits with every; /// byte of the application memory, poison the shadow of the malloc-ed; /// or alloca-ed memory, load the shadow bits on every memory read,; /// propagate the shadow bits through some of the arithmetic; /// instruction (including MOV), store the shadow bits on every memory; /// write, report a bug on some other instructions (e.g. JMP) if the; /// associated shadow is poisoned.; ///; /// But there are differences too. The first and the major one:; /// compiler instrumentation instead of binary instrumentation. This; /// gives us much better register allocation, possible compiler; /// optimizations and a fast start-up. But this brings the major issue; /// as well: msan needs to see all program events, including system; /// calls and reads/writes in system libraries, so we either need to; /// compile *everything* with msan or use a binary translation; /// component (e.g. DynamoRIO) to instrument pre-built libraries.; /// Another difference from Memcheck is that we use 8 shadow bits per; /// byte of application memory and use a direct shadow mapping. This; /// greatly simplifies the instrumentation code and avoids races on; /// shadow updates (Memcheck is single-threaded so races are not a; /// concern there. Memcheck uses 2 shadow bits per byte with a slow; /// path storage that uses 8 bits per byte).; ///; /// The default value of shadow is 0, which means ""clean"" (not poisone",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:437,Safety,detect,detector,437,"//===- MemorySanitizer.cpp - detector of uninitialized reads --------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file; /// This file is a part of MemorySanitizer, a detector of uninitialized; /// reads.; ///; /// The algorithm of the tool is similar to Memcheck; /// (http://goo.gl/QKbem). We associate a few shadow bits with every; /// byte of the application memory, poison the shadow of the malloc-ed; /// or alloca-ed memory, load the shadow bits on every memory read,; /// propagate the shadow bits through some of the arithmetic; /// instruction (including MOV), store the shadow bits on every memory; /// write, report a bug on some other instructions (e.g. JMP) if the; /// associated shadow is poisoned.; ///; /// But there are differences too. The first and the major one:; /// compiler instrumentation instead of binary instrumentation. This; /// gives us much better register allocation, possible compiler; /// optimizations and a fast start-up. But this brings the major issue; /// as well: msan needs to see all program events, including system; /// calls and reads/writes in system libraries, so we either need to; /// compile *everything* with msan or use a binary translation; /// component (e.g. DynamoRIO) to instrument pre-built libraries.; /// Another difference from Memcheck is that we use 8 shadow bits per; /// byte of application memory and use a direct shadow mapping. This; /// greatly simplifies the instrumentation code and avoids races on; /// shadow updates (Memcheck is single-threaded so races are not a; /// concern there. Memcheck uses 2 shadow bits per byte with a slow; /// path storage that uses 8 bits per byte).; ///; /// The default value of shadow is 0, which means ""clean"" (not poisone",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:1726,Safety,avoid,avoids,1726,"/ propagate the shadow bits through some of the arithmetic; /// instruction (including MOV), store the shadow bits on every memory; /// write, report a bug on some other instructions (e.g. JMP) if the; /// associated shadow is poisoned.; ///; /// But there are differences too. The first and the major one:; /// compiler instrumentation instead of binary instrumentation. This; /// gives us much better register allocation, possible compiler; /// optimizations and a fast start-up. But this brings the major issue; /// as well: msan needs to see all program events, including system; /// calls and reads/writes in system libraries, so we either need to; /// compile *everything* with msan or use a binary translation; /// component (e.g. DynamoRIO) to instrument pre-built libraries.; /// Another difference from Memcheck is that we use 8 shadow bits per; /// byte of application memory and use a direct shadow mapping. This; /// greatly simplifies the instrumentation code and avoids races on; /// shadow updates (Memcheck is single-threaded so races are not a; /// concern there. Memcheck uses 2 shadow bits per byte with a slow; /// path storage that uses 8 bits per byte).; ///; /// The default value of shadow is 0, which means ""clean"" (not poisoned).; ///; /// Every module initializer should call __msan_init to ensure that the; /// shadow memory is ready. On error, __msan_warning is called. Since; /// parameters and return values may be passed via registers, we have a; /// specialized thread-local shadow for return values; /// (__msan_retval_tls) and parameters (__msan_param_tls).; ///; /// Origin tracking.; ///; /// MemorySanitizer can track origins (allocation points) of all uninitialized; /// values. This behavior is controlled with a flag (msan-track-origins) and is; /// disabled by default.; ///; /// Origins are 4-byte values created and interpreted by the runtime library.; /// They are stored in a second shadow mapping, one 4-byte value for 4 bytes; /// of application memor",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:3321,Safety,avoid,avoids,3321,"rameters (__msan_param_tls).; ///; /// Origin tracking.; ///; /// MemorySanitizer can track origins (allocation points) of all uninitialized; /// values. This behavior is controlled with a flag (msan-track-origins) and is; /// disabled by default.; ///; /// Origins are 4-byte values created and interpreted by the runtime library.; /// They are stored in a second shadow mapping, one 4-byte value for 4 bytes; /// of application memory. Propagation of origins is basically a bunch of; /// ""select"" instructions that pick the origin of a dirty argument, if an; /// instruction has one.; ///; /// Every 4 aligned, consecutive bytes of application memory have one origin; /// value associated with them. If these bytes contain uninitialized data; /// coming from 2 different allocations, the last store wins. Because of this,; /// MemorySanitizer reports can show unrelated origins, but this is unlikely in; /// practice.; ///; /// Origins are meaningless for fully initialized values, so MemorySanitizer; /// avoids storing origin to memory when a fully initialized value is stored.; /// This way it avoids needless overwriting origin of the 4-byte region on; /// a short (i.e. 1 byte) clean store, and it is also good for performance.; ///; /// Atomic handling.; ///; /// Ideally, every atomic store of application value should update the; /// corresponding shadow location in an atomic way. Unfortunately, atomic store; /// of two disjoint locations can not be done without severe slowdown.; ///; /// Therefore, we implement an approximation that may err on the safe side.; /// In this implementation, every atomically accessed location in the program; /// may only change from (partially) uninitialized to fully initialized, but; /// not the other way around. We load the shadow _after_ the application load,; /// and we store the shadow _before_ the app store. Also, we always store clean; /// shadow (if the application store is atomic). This way, if the store-load; /// pair constitutes a happen",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:3412,Safety,avoid,avoids,3412,"uninitialized; /// values. This behavior is controlled with a flag (msan-track-origins) and is; /// disabled by default.; ///; /// Origins are 4-byte values created and interpreted by the runtime library.; /// They are stored in a second shadow mapping, one 4-byte value for 4 bytes; /// of application memory. Propagation of origins is basically a bunch of; /// ""select"" instructions that pick the origin of a dirty argument, if an; /// instruction has one.; ///; /// Every 4 aligned, consecutive bytes of application memory have one origin; /// value associated with them. If these bytes contain uninitialized data; /// coming from 2 different allocations, the last store wins. Because of this,; /// MemorySanitizer reports can show unrelated origins, but this is unlikely in; /// practice.; ///; /// Origins are meaningless for fully initialized values, so MemorySanitizer; /// avoids storing origin to memory when a fully initialized value is stored.; /// This way it avoids needless overwriting origin of the 4-byte region on; /// a short (i.e. 1 byte) clean store, and it is also good for performance.; ///; /// Atomic handling.; ///; /// Ideally, every atomic store of application value should update the; /// corresponding shadow location in an atomic way. Unfortunately, atomic store; /// of two disjoint locations can not be done without severe slowdown.; ///; /// Therefore, we implement an approximation that may err on the safe side.; /// In this implementation, every atomically accessed location in the program; /// may only change from (partially) uninitialized to fully initialized, but; /// not the other way around. We load the shadow _after_ the application load,; /// and we store the shadow _before_ the app store. Also, we always store clean; /// shadow (if the application store is atomic). This way, if the store-load; /// pair constitutes a happens-before arc, shadow store and load are correctly; /// ordered such that the load will get either the value that was stored, or;",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:3876,Safety,safe,safe,3876," of a dirty argument, if an; /// instruction has one.; ///; /// Every 4 aligned, consecutive bytes of application memory have one origin; /// value associated with them. If these bytes contain uninitialized data; /// coming from 2 different allocations, the last store wins. Because of this,; /// MemorySanitizer reports can show unrelated origins, but this is unlikely in; /// practice.; ///; /// Origins are meaningless for fully initialized values, so MemorySanitizer; /// avoids storing origin to memory when a fully initialized value is stored.; /// This way it avoids needless overwriting origin of the 4-byte region on; /// a short (i.e. 1 byte) clean store, and it is also good for performance.; ///; /// Atomic handling.; ///; /// Ideally, every atomic store of application value should update the; /// corresponding shadow location in an atomic way. Unfortunately, atomic store; /// of two disjoint locations can not be done without severe slowdown.; ///; /// Therefore, we implement an approximation that may err on the safe side.; /// In this implementation, every atomically accessed location in the program; /// may only change from (partially) uninitialized to fully initialized, but; /// not the other way around. We load the shadow _after_ the application load,; /// and we store the shadow _before_ the app store. Also, we always store clean; /// shadow (if the application store is atomic). This way, if the store-load; /// pair constitutes a happens-before arc, shadow store and load are correctly; /// ordered such that the load will get either the value that was stored, or; /// some later value (which is always clean).; ///; /// This does not work very well with Compare-And-Swap (CAS) and; /// Read-Modify-Write (RMW) operations. To follow the above logic, CAS and RMW; /// must store the new shadow before the app operation, and load the shadow; /// after the app operation. Computers don't work this way. Current; /// implementation ignores the load aspect of CAS/RMW, alwa",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:5750,Safety,safe,safe,5750,"after the app operation. Computers don't work this way. Current; /// implementation ignores the load aspect of CAS/RMW, always returning a clean; /// value. It implements the store part as a simple atomic store by storing a; /// clean shadow.; ///; /// Instrumenting inline assembly.; ///; /// For inline assembly code LLVM has little idea about which memory locations; /// become initialized depending on the arguments. It can be possible to figure; /// out which arguments are meant to point to inputs and outputs, but the; /// actual semantics can be only visible at runtime. In the Linux kernel it's; /// also possible that the arguments only indicate the offset for a base taken; /// from a segment register, so it's dangerous to treat any asm() arguments as; /// pointers. We take a conservative approach generating calls to; /// __msan_instrument_asm_store(ptr, size); /// , which defer the memory unpoisoning to the runtime library.; /// The latter can perform more complex address checks to figure out whether; /// it's safe to touch the shadow memory.; /// Like with atomic operations, we call __msan_instrument_asm_store() before; /// the assembly call, so that changes to the shadow memory will be seen by; /// other threads together with main memory initialization.; ///; /// KernelMemorySanitizer (KMSAN) implementation.; ///; /// The major differences between KMSAN and MSan instrumentation are:; /// - KMSAN always tracks the origins and implies msan-keep-going=true;; /// - KMSAN allocates shadow and origin memory for each page separately, so; /// there are no explicit accesses to shadow and origin in the; /// instrumentation.; /// Shadow and origin values for a particular X-byte memory location; /// (X=1,2,4,8) are accessed through pointers obtained via the; /// __msan_metadata_ptr_for_load_X(ptr); /// __msan_metadata_ptr_for_store_X(ptr); /// functions. The corresponding functions check that the X-byte accesses; /// are possible and returns the pointers to shadow and origi",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:7844,Safety,safe,safe,7844,"tion are:; /// - KMSAN always tracks the origins and implies msan-keep-going=true;; /// - KMSAN allocates shadow and origin memory for each page separately, so; /// there are no explicit accesses to shadow and origin in the; /// instrumentation.; /// Shadow and origin values for a particular X-byte memory location; /// (X=1,2,4,8) are accessed through pointers obtained via the; /// __msan_metadata_ptr_for_load_X(ptr); /// __msan_metadata_ptr_for_store_X(ptr); /// functions. The corresponding functions check that the X-byte accesses; /// are possible and returns the pointers to shadow and origin memory.; /// Arbitrary sized accesses are handled with:; /// __msan_metadata_ptr_for_load_n(ptr, size); /// __msan_metadata_ptr_for_store_n(ptr, size);; /// Note that the sanitizer code has to deal with how shadow/origin pairs; /// returned by the these functions are represented in different ABIs. In; /// the X86_64 ABI they are returned in RDX:RAX, and in the SystemZ ABI they; /// are written to memory pointed to by a hidden parameter.; /// - TLS variables are stored in a single per-task struct. A call to a; /// function __msan_get_context_state() returning a pointer to that struct; /// is inserted into every instrumented function before the entry block;; /// - __msan_warning() takes a 32-bit origin parameter;; /// - local variables are poisoned with __msan_poison_alloca() upon function; /// entry and unpoisoned with __msan_unpoison_alloca() before leaving the; /// function;; /// - the pass doesn't declare any global variables or add global constructors; /// to the translation unit.; ///; /// Also, KMSAN currently ignores uninitialized memory passed into inline asm; /// calls, making sure we're on the safe side wrt. possible false positives.; ///; /// KernelMemorySanitizer only supports X86_64 and SystemZ at the moment.; ///; //; // FIXME: This sanitizer does not yet handle scalable vectors; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:3933,Security,access,accessed,3933,"n; /// value associated with them. If these bytes contain uninitialized data; /// coming from 2 different allocations, the last store wins. Because of this,; /// MemorySanitizer reports can show unrelated origins, but this is unlikely in; /// practice.; ///; /// Origins are meaningless for fully initialized values, so MemorySanitizer; /// avoids storing origin to memory when a fully initialized value is stored.; /// This way it avoids needless overwriting origin of the 4-byte region on; /// a short (i.e. 1 byte) clean store, and it is also good for performance.; ///; /// Atomic handling.; ///; /// Ideally, every atomic store of application value should update the; /// corresponding shadow location in an atomic way. Unfortunately, atomic store; /// of two disjoint locations can not be done without severe slowdown.; ///; /// Therefore, we implement an approximation that may err on the safe side.; /// In this implementation, every atomically accessed location in the program; /// may only change from (partially) uninitialized to fully initialized, but; /// not the other way around. We load the shadow _after_ the application load,; /// and we store the shadow _before_ the app store. Also, we always store clean; /// shadow (if the application store is atomic). This way, if the store-load; /// pair constitutes a happens-before arc, shadow store and load are correctly; /// ordered such that the load will get either the value that was stored, or; /// some later value (which is always clean).; ///; /// This does not work very well with Compare-And-Swap (CAS) and; /// Read-Modify-Write (RMW) operations. To follow the above logic, CAS and RMW; /// must store the new shadow before the app operation, and load the shadow; /// after the app operation. Computers don't work this way. Current; /// implementation ignores the load aspect of CAS/RMW, always returning a clean; /// value. It implements the store part as a simple atomic store by storing a; /// clean shadow.; ///; /// Instru",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:6309,Security,access,accesses,6309,"int to inputs and outputs, but the; /// actual semantics can be only visible at runtime. In the Linux kernel it's; /// also possible that the arguments only indicate the offset for a base taken; /// from a segment register, so it's dangerous to treat any asm() arguments as; /// pointers. We take a conservative approach generating calls to; /// __msan_instrument_asm_store(ptr, size); /// , which defer the memory unpoisoning to the runtime library.; /// The latter can perform more complex address checks to figure out whether; /// it's safe to touch the shadow memory.; /// Like with atomic operations, we call __msan_instrument_asm_store() before; /// the assembly call, so that changes to the shadow memory will be seen by; /// other threads together with main memory initialization.; ///; /// KernelMemorySanitizer (KMSAN) implementation.; ///; /// The major differences between KMSAN and MSan instrumentation are:; /// - KMSAN always tracks the origins and implies msan-keep-going=true;; /// - KMSAN allocates shadow and origin memory for each page separately, so; /// there are no explicit accesses to shadow and origin in the; /// instrumentation.; /// Shadow and origin values for a particular X-byte memory location; /// (X=1,2,4,8) are accessed through pointers obtained via the; /// __msan_metadata_ptr_for_load_X(ptr); /// __msan_metadata_ptr_for_store_X(ptr); /// functions. The corresponding functions check that the X-byte accesses; /// are possible and returns the pointers to shadow and origin memory.; /// Arbitrary sized accesses are handled with:; /// __msan_metadata_ptr_for_load_n(ptr, size); /// __msan_metadata_ptr_for_store_n(ptr, size);; /// Note that the sanitizer code has to deal with how shadow/origin pairs; /// returned by the these functions are represented in different ABIs. In; /// the X86_64 ABI they are returned in RDX:RAX, and in the SystemZ ABI they; /// are written to memory pointed to by a hidden parameter.; /// - TLS variables are stored in a single pe",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:6459,Security,access,accessed,6459,"s; /// pointers. We take a conservative approach generating calls to; /// __msan_instrument_asm_store(ptr, size); /// , which defer the memory unpoisoning to the runtime library.; /// The latter can perform more complex address checks to figure out whether; /// it's safe to touch the shadow memory.; /// Like with atomic operations, we call __msan_instrument_asm_store() before; /// the assembly call, so that changes to the shadow memory will be seen by; /// other threads together with main memory initialization.; ///; /// KernelMemorySanitizer (KMSAN) implementation.; ///; /// The major differences between KMSAN and MSan instrumentation are:; /// - KMSAN always tracks the origins and implies msan-keep-going=true;; /// - KMSAN allocates shadow and origin memory for each page separately, so; /// there are no explicit accesses to shadow and origin in the; /// instrumentation.; /// Shadow and origin values for a particular X-byte memory location; /// (X=1,2,4,8) are accessed through pointers obtained via the; /// __msan_metadata_ptr_for_load_X(ptr); /// __msan_metadata_ptr_for_store_X(ptr); /// functions. The corresponding functions check that the X-byte accesses; /// are possible and returns the pointers to shadow and origin memory.; /// Arbitrary sized accesses are handled with:; /// __msan_metadata_ptr_for_load_n(ptr, size); /// __msan_metadata_ptr_for_store_n(ptr, size);; /// Note that the sanitizer code has to deal with how shadow/origin pairs; /// returned by the these functions are represented in different ABIs. In; /// the X86_64 ABI they are returned in RDX:RAX, and in the SystemZ ABI they; /// are written to memory pointed to by a hidden parameter.; /// - TLS variables are stored in a single per-task struct. A call to a; /// function __msan_get_context_state() returning a pointer to that struct; /// is inserted into every instrumented function before the entry block;; /// - __msan_warning() takes a 32-bit origin parameter;; /// - local variables are poisoned wit",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:6651,Security,access,accesses,6651,"/ The latter can perform more complex address checks to figure out whether; /// it's safe to touch the shadow memory.; /// Like with atomic operations, we call __msan_instrument_asm_store() before; /// the assembly call, so that changes to the shadow memory will be seen by; /// other threads together with main memory initialization.; ///; /// KernelMemorySanitizer (KMSAN) implementation.; ///; /// The major differences between KMSAN and MSan instrumentation are:; /// - KMSAN always tracks the origins and implies msan-keep-going=true;; /// - KMSAN allocates shadow and origin memory for each page separately, so; /// there are no explicit accesses to shadow and origin in the; /// instrumentation.; /// Shadow and origin values for a particular X-byte memory location; /// (X=1,2,4,8) are accessed through pointers obtained via the; /// __msan_metadata_ptr_for_load_X(ptr); /// __msan_metadata_ptr_for_store_X(ptr); /// functions. The corresponding functions check that the X-byte accesses; /// are possible and returns the pointers to shadow and origin memory.; /// Arbitrary sized accesses are handled with:; /// __msan_metadata_ptr_for_load_n(ptr, size); /// __msan_metadata_ptr_for_store_n(ptr, size);; /// Note that the sanitizer code has to deal with how shadow/origin pairs; /// returned by the these functions are represented in different ABIs. In; /// the X86_64 ABI they are returned in RDX:RAX, and in the SystemZ ABI they; /// are written to memory pointed to by a hidden parameter.; /// - TLS variables are stored in a single per-task struct. A call to a; /// function __msan_get_context_state() returning a pointer to that struct; /// is inserted into every instrumented function before the entry block;; /// - __msan_warning() takes a 32-bit origin parameter;; /// - local variables are poisoned with __msan_poison_alloca() upon function; /// entry and unpoisoned with __msan_unpoison_alloca() before leaving the; /// function;; /// - the pass doesn't declare any global variables ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:6753,Security,access,accesses,6753,"bly call, so that changes to the shadow memory will be seen by; /// other threads together with main memory initialization.; ///; /// KernelMemorySanitizer (KMSAN) implementation.; ///; /// The major differences between KMSAN and MSan instrumentation are:; /// - KMSAN always tracks the origins and implies msan-keep-going=true;; /// - KMSAN allocates shadow and origin memory for each page separately, so; /// there are no explicit accesses to shadow and origin in the; /// instrumentation.; /// Shadow and origin values for a particular X-byte memory location; /// (X=1,2,4,8) are accessed through pointers obtained via the; /// __msan_metadata_ptr_for_load_X(ptr); /// __msan_metadata_ptr_for_store_X(ptr); /// functions. The corresponding functions check that the X-byte accesses; /// are possible and returns the pointers to shadow and origin memory.; /// Arbitrary sized accesses are handled with:; /// __msan_metadata_ptr_for_load_n(ptr, size); /// __msan_metadata_ptr_for_store_n(ptr, size);; /// Note that the sanitizer code has to deal with how shadow/origin pairs; /// returned by the these functions are represented in different ABIs. In; /// the X86_64 ABI they are returned in RDX:RAX, and in the SystemZ ABI they; /// are written to memory pointed to by a hidden parameter.; /// - TLS variables are stored in a single per-task struct. A call to a; /// function __msan_get_context_state() returning a pointer to that struct; /// is inserted into every instrumented function before the entry block;; /// - __msan_warning() takes a 32-bit origin parameter;; /// - local variables are poisoned with __msan_poison_alloca() upon function; /// entry and unpoisoned with __msan_unpoison_alloca() before leaving the; /// function;; /// - the pass doesn't declare any global variables or add global constructors; /// to the translation unit.; ///; /// Also, KMSAN currently ignores uninitialized memory passed into inline asm; /// calls, making sure we're on the safe side wrt. possible false pos",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:6895,Security,sanitiz,sanitizer,6895,"bly call, so that changes to the shadow memory will be seen by; /// other threads together with main memory initialization.; ///; /// KernelMemorySanitizer (KMSAN) implementation.; ///; /// The major differences between KMSAN and MSan instrumentation are:; /// - KMSAN always tracks the origins and implies msan-keep-going=true;; /// - KMSAN allocates shadow and origin memory for each page separately, so; /// there are no explicit accesses to shadow and origin in the; /// instrumentation.; /// Shadow and origin values for a particular X-byte memory location; /// (X=1,2,4,8) are accessed through pointers obtained via the; /// __msan_metadata_ptr_for_load_X(ptr); /// __msan_metadata_ptr_for_store_X(ptr); /// functions. The corresponding functions check that the X-byte accesses; /// are possible and returns the pointers to shadow and origin memory.; /// Arbitrary sized accesses are handled with:; /// __msan_metadata_ptr_for_load_n(ptr, size); /// __msan_metadata_ptr_for_store_n(ptr, size);; /// Note that the sanitizer code has to deal with how shadow/origin pairs; /// returned by the these functions are represented in different ABIs. In; /// the X86_64 ABI they are returned in RDX:RAX, and in the SystemZ ABI they; /// are written to memory pointed to by a hidden parameter.; /// - TLS variables are stored in a single per-task struct. A call to a; /// function __msan_get_context_state() returning a pointer to that struct; /// is inserted into every instrumented function before the entry block;; /// - __msan_warning() takes a 32-bit origin parameter;; /// - local variables are poisoned with __msan_poison_alloca() upon function; /// entry and unpoisoned with __msan_unpoison_alloca() before leaving the; /// function;; /// - the pass doesn't declare any global variables or add global constructors; /// to the translation unit.; ///; /// Also, KMSAN currently ignores uninitialized memory passed into inline asm; /// calls, making sure we're on the safe side wrt. possible false pos",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:7990,Security,sanitiz,sanitizer,7990,"tion are:; /// - KMSAN always tracks the origins and implies msan-keep-going=true;; /// - KMSAN allocates shadow and origin memory for each page separately, so; /// there are no explicit accesses to shadow and origin in the; /// instrumentation.; /// Shadow and origin values for a particular X-byte memory location; /// (X=1,2,4,8) are accessed through pointers obtained via the; /// __msan_metadata_ptr_for_load_X(ptr); /// __msan_metadata_ptr_for_store_X(ptr); /// functions. The corresponding functions check that the X-byte accesses; /// are possible and returns the pointers to shadow and origin memory.; /// Arbitrary sized accesses are handled with:; /// __msan_metadata_ptr_for_load_n(ptr, size); /// __msan_metadata_ptr_for_store_n(ptr, size);; /// Note that the sanitizer code has to deal with how shadow/origin pairs; /// returned by the these functions are represented in different ABIs. In; /// the X86_64 ABI they are returned in RDX:RAX, and in the SystemZ ABI they; /// are written to memory pointed to by a hidden parameter.; /// - TLS variables are stored in a single per-task struct. A call to a; /// function __msan_get_context_state() returning a pointer to that struct; /// is inserted into every instrumented function before the entry block;; /// - __msan_warning() takes a 32-bit origin parameter;; /// - local variables are poisoned with __msan_poison_alloca() upon function; /// entry and unpoisoned with __msan_unpoison_alloca() before leaving the; /// function;; /// - the pass doesn't declare any global variables or add global constructors; /// to the translation unit.; ///; /// Also, KMSAN currently ignores uninitialized memory passed into inline asm; /// calls, making sure we're on the safe side wrt. possible false positives.; ///; /// KernelMemorySanitizer only supports X86_64 and SystemZ at the moment.; ///; //; // FIXME: This sanitizer does not yet handle scalable vectors; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:4620,Testability,log,logic,4620,"hadow location in an atomic way. Unfortunately, atomic store; /// of two disjoint locations can not be done without severe slowdown.; ///; /// Therefore, we implement an approximation that may err on the safe side.; /// In this implementation, every atomically accessed location in the program; /// may only change from (partially) uninitialized to fully initialized, but; /// not the other way around. We load the shadow _after_ the application load,; /// and we store the shadow _before_ the app store. Also, we always store clean; /// shadow (if the application store is atomic). This way, if the store-load; /// pair constitutes a happens-before arc, shadow store and load are correctly; /// ordered such that the load will get either the value that was stored, or; /// some later value (which is always clean).; ///; /// This does not work very well with Compare-And-Swap (CAS) and; /// Read-Modify-Write (RMW) operations. To follow the above logic, CAS and RMW; /// must store the new shadow before the app operation, and load the shadow; /// after the app operation. Computers don't work this way. Current; /// implementation ignores the load aspect of CAS/RMW, always returning a clean; /// value. It implements the store part as a simple atomic store by storing a; /// clean shadow.; ///; /// Instrumenting inline assembly.; ///; /// For inline assembly code LLVM has little idea about which memory locations; /// become initialized depending on the arguments. It can be possible to figure; /// out which arguments are meant to point to inputs and outputs, but the; /// actual semantics can be only visible at runtime. In the Linux kernel it's; /// also possible that the arguments only indicate the offset for a base taken; /// from a segment register, so it's dangerous to treat any asm() arguments as; /// pointers. We take a conservative approach generating calls to; /// __msan_instrument_asm_store(ptr, size); /// , which defer the memory unpoisoning to the runtime library.; /// The l",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:1686,Usability,simpl,simplifies,1686,"/ propagate the shadow bits through some of the arithmetic; /// instruction (including MOV), store the shadow bits on every memory; /// write, report a bug on some other instructions (e.g. JMP) if the; /// associated shadow is poisoned.; ///; /// But there are differences too. The first and the major one:; /// compiler instrumentation instead of binary instrumentation. This; /// gives us much better register allocation, possible compiler; /// optimizations and a fast start-up. But this brings the major issue; /// as well: msan needs to see all program events, including system; /// calls and reads/writes in system libraries, so we either need to; /// compile *everything* with msan or use a binary translation; /// component (e.g. DynamoRIO) to instrument pre-built libraries.; /// Another difference from Memcheck is that we use 8 shadow bits per; /// byte of application memory and use a direct shadow mapping. This; /// greatly simplifies the instrumentation code and avoids races on; /// shadow updates (Memcheck is single-threaded so races are not a; /// concern there. Memcheck uses 2 shadow bits per byte with a slow; /// path storage that uses 8 bits per byte).; ///; /// The default value of shadow is 0, which means ""clean"" (not poisoned).; ///; /// Every module initializer should call __msan_init to ensure that the; /// shadow memory is ready. On error, __msan_warning is called. Since; /// parameters and return values may be passed via registers, we have a; /// specialized thread-local shadow for return values; /// (__msan_retval_tls) and parameters (__msan_param_tls).; ///; /// Origin tracking.; ///; /// MemorySanitizer can track origins (allocation points) of all uninitialized; /// values. This behavior is controlled with a flag (msan-track-origins) and is; /// disabled by default.; ///; /// Origins are 4-byte values created and interpreted by the runtime library.; /// They are stored in a second shadow mapping, one 4-byte value for 4 bytes; /// of application memor",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:4912,Usability,simpl,simple,4912,"y atomically accessed location in the program; /// may only change from (partially) uninitialized to fully initialized, but; /// not the other way around. We load the shadow _after_ the application load,; /// and we store the shadow _before_ the app store. Also, we always store clean; /// shadow (if the application store is atomic). This way, if the store-load; /// pair constitutes a happens-before arc, shadow store and load are correctly; /// ordered such that the load will get either the value that was stored, or; /// some later value (which is always clean).; ///; /// This does not work very well with Compare-And-Swap (CAS) and; /// Read-Modify-Write (RMW) operations. To follow the above logic, CAS and RMW; /// must store the new shadow before the app operation, and load the shadow; /// after the app operation. Computers don't work this way. Current; /// implementation ignores the load aspect of CAS/RMW, always returning a clean; /// value. It implements the store part as a simple atomic store by storing a; /// clean shadow.; ///; /// Instrumenting inline assembly.; ///; /// For inline assembly code LLVM has little idea about which memory locations; /// become initialized depending on the arguments. It can be possible to figure; /// out which arguments are meant to point to inputs and outputs, but the; /// actual semantics can be only visible at runtime. In the Linux kernel it's; /// also possible that the arguments only indicate the offset for a base taken; /// from a segment register, so it's dangerous to treat any asm() arguments as; /// pointers. We take a conservative approach generating calls to; /// __msan_instrument_asm_store(ptr, size); /// , which defer the memory unpoisoning to the runtime library.; /// The latter can perform more complex address checks to figure out whether; /// it's safe to touch the shadow memory.; /// Like with atomic operations, we call __msan_instrument_asm_store() before; /// the assembly call, so that changes to the shadow memo",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:22,Energy Efficiency,power,powers,22,"// Accesses sizes are powers of two: 1, 2, 4, 8.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:3,Security,Access,Accesses,3,"// Accesses sizes are powers of two: 1, 2, 4, 8.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:168,Modifiability,variab,variables,168,"// When compiling the Linux kernel, we sometimes see false positives related to; // MSan being unable to understand that inline assembly calls may initialize; // local variables.; // This flag makes the compiler conservatively unpoison every memory location; // passed into an assembly call. Note that this may cause false positives.; // Because it's impossible to figure out the array sizes, we can only unpoison; // the first sizeof(type) bytes for each type* pointer.; // The instrumentation is only enabled in KMSAN builds, and only if; // -msan-handle-asm-conservative is on. This is done because we may want to; // quickly disable assembly instrumentation when it breaks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:80,Performance,load,load,80,"// This flag controls whether we check the shadow of the address; // operand of load or store. Such bugs are very rare, since load from; // a garbage address typically results in SEGV, but still happen; // (e.g. only lower bits of address are garbage, or the access happens; // early at program startup where malloc-ed memory is more likely to; // be zeroed. As of 2012-08-28 this flag adds 20% slowdown.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:126,Performance,load,load,126,"// This flag controls whether we check the shadow of the address; // operand of load or store. Such bugs are very rare, since load from; // a garbage address typically results in SEGV, but still happen; // (e.g. only lower bits of address are garbage, or the access happens; // early at program startup where malloc-ed memory is more likely to; // be zeroed. As of 2012-08-28 this flag adds 20% slowdown.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:259,Security,access,access,259,"// This flag controls whether we check the shadow of the address; // operand of load or store. Such bugs are very rare, since load from; // a garbage address typically results in SEGV, but still happen; // (e.g. only lower bits of address are garbage, or the access happens; // early at program startup where malloc-ed memory is more likely to; // be zeroed. As of 2012-08-28 this flag adds 20% slowdown.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:40,Safety,detect,detect,40,/// Instrument functions of a module to detect uninitialized reads.; ///; /// Instantiating MemorySanitizer inserts the msan runtime library API function; /// declarations into the module if they don't exist already. Instantiating; /// ensures the __msan_init function is in the list of global constructors for; /// the module.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:67,Modifiability,variab,variables,67,///< Integer type with the size of a ptr in default AS.; // XxxTLS variables represent the per-thread state in MSan and per-task state; // in KMSAN.; // For the userspace these point to thread-local globals. In the kernel land; // they point to the members of a per-task struct obtained via a call to; // __msan_get_context_state().; /// Thread-local shadow storage for function parameters.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:36,Security,Access,AccessSize,36,// These arrays are indexed by log2(AccessSize).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:102,Deployability,update,updated,102,/// Run-time helper that records a store (or any event) of an; /// uninitialized value and returns an updated origin id encoding this info.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:46,Modifiability,variab,variables,46,/// Functions for poisoning/unpoisoning local variables,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:142,Security,Sanitiz,Sanitizers,142,// GlobalsAA is considered stateless and does not get invalidated unless; // explicitly invalidated; PreservedAnalyses::none() is not enough. Sanitizers; // make changes that require GlobalsAA to be invalidated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:25,Modifiability,variab,variables,25,// Create the global TLS variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:336,Safety,avoid,avoid,336,"/// A helper class that handles instrumentation of VarArg; /// functions on a particular platform.; ///; /// Implementations are expected to insert the instrumentation; /// necessary to propagate argument shadow through VarArg function; /// calls. Visit* methods are called during an InstVisitor pass over; /// the function, and should avoid creating new basic blocks. A new; /// instance of this class is created for each instrumented function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:3,Performance,Scalab,Scalable,3,// Scalable types unconditionally take slowpaths.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:65,Performance,Load,Load,65,"/// This class does all the work for a given function. Store and Load; /// instructions store and load corresponding shadow and origin; /// values. Most instructions propagate shadow from arguments to their; /// return values. Certain instructions (most importantly, BranchInst); /// test their argument shadow and print reports (with a runtime call) if it's; /// non-zero.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:98,Performance,load,load,98,"/// This class does all the work for a given function. Store and Load; /// instructions store and load corresponding shadow and origin; /// values. Most instructions propagate shadow from arguments to their; /// return values. Certain instructions (most importantly, BranchInst); /// test their argument shadow and print reports (with a runtime call) if it's; /// non-zero.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:284,Testability,test,test,284,"/// This class does all the work for a given function. Store and Load; /// instructions store and load corresponding shadow and origin; /// values. Most instructions propagate shadow from arguments to their; /// return values. Certain instructions (most importantly, BranchInst); /// test their argument shadow and print reports (with a runtime call) if it's; /// non-zero.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:49,Performance,optimiz,optimized,49,"// Fallback to runtime check, which still can be optimized out later.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:10,Deployability,update,update,10,// Origin update with missing or the same debug location provides no; // additional value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:10,Deployability,update,update,10,"// Insert update just before the check, so we call runtime only just; // before the report.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:40,Availability,Recover,Recover,40,// FIXME: Insert UnreachableInst if !MS.Recover?; // This may invalidate some of the following checks and needs to be done; // at the very end.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:40,Safety,Recover,Recover,40,// FIXME: Insert UnreachableInst if !MS.Recover?; // This may invalidate some of the following checks and needs to be done; // at the very end.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:49,Performance,optimiz,optimized,49,"// Fallback to runtime check, which still can be optimized out later.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:15,Performance,Load,LoadInst,15,"/// Instrument LoadInst; ///; /// Loads the corresponding shadow and (optionally) origin.; /// Optionally, checks that the load address is fully defined.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:34,Performance,Load,Loads,34,"/// Instrument LoadInst; ///; /// Loads the corresponding shadow and (optionally) origin.; /// Optionally, checks that the load address is fully defined.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:123,Performance,load,load,123,"/// Instrument LoadInst; ///; /// Loads the corresponding shadow and (optionally) origin.; /// Optionally, checks that the load address is fully defined.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:160,Availability,reliab,reliably,160,"// Only test the conditional argument of cmpxchg instruction.; // The other argument can potentially be uninitialized, but we can not; // detect this situation reliably without possible false positives.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:138,Safety,detect,detect,138,"// Only test the conditional argument of cmpxchg instruction.; // The other argument can potentially be uninitialized, but we can not; // detect this situation reliably without possible false positives.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:8,Testability,test,test,8,"// Only test the conditional argument of cmpxchg instruction.; // The other argument can potentially be uninitialized, but we can not; // detect this situation reliably without possible false positives.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:286,Modifiability,extend,extending,286,"/// Default propagation of shadow and/or origin.; ///; /// This class implements the general case of shadow propagation, used in all; /// cases where we don't know and/or don't care about what the operation; /// actually does. It converts all input shadow values to a common type; /// (extending or truncating as necessary), and bitwise OR's them.; ///; /// This is much cheaper than inserting checks (i.e. requiring inputs to be; /// fully initialized), and less prone to false positives.; ///; /// This class also implements the general case of origin propagation. For a; /// Nary operation, result origin is set to the origin of an argument that is; /// not entirely initialized. If there is more than one such arguments, the; /// rightmost of them is picked. It does not matter which one is picked if all; /// arguments are initialized.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:35,Modifiability,extend,extending,35,"/// Cast between two shadow types, extending or truncating as; /// necessary.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:72,Testability,test,tests,72,"/// Instrument signed relational comparisons.; ///; /// Handle sign bit tests: x<0, x>=0, x<=-1, x>-1 by propagating the highest; /// bit of the shadow. Everything else is delegated to handleShadowOr().",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:82,Performance,perform,perform,82,"// If any of the S2 bits are poisoned, the whole thing is poisoned.; // Otherwise perform the same shift on S1.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:82,Performance,perform,perform,82,"// If any of the S2 bits are poisoned, the whole thing is poisoned.; // Otherwise perform the same shift on S0 and S1.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:387,Usability,simpl,simply,387,"/// Instrument llvm.memmove; ///; /// At this point we don't know if llvm.memmove will be inlined or not.; /// If we don't instrument it and it gets inlined,; /// our interceptor will not kick in and we will lose the memmove.; /// If we instrument the call here, but it does not get inlined,; /// we will memove the shadow twice: which is bad in case; /// of overlapping regions. So, we simply lower the intrinsic to a call.; ///; /// Similar situation exists for memcpy and memset.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:356,Performance,optimiz,optimization,356,"/// Instrument memcpy; ///; /// Similar to memmove: avoid copying shadow twice. This is somewhat; /// unfortunate as it may slowdown small constant memcpys.; /// FIXME: consider doing manual inline for small constant sizes and proper; /// alignment.; ///; /// Note: This also handles memcpy.inline, which promises no calls to external; /// functions as an optimization. However, with instrumentation enabled this; /// is difficult to promise; additionally, we know that the MSan runtime; /// exists and provides __msan_memcpy(). Therefore, we assume that with; /// instrumentation it's safe to turn memcpy.inline into a call to; /// __msan_memcpy(). Should this be wrong, such as when implementing memcpy(); /// itself, instrumentation should be disabled with the no_sanitize attribute.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:52,Safety,avoid,avoid,52,"/// Instrument memcpy; ///; /// Similar to memmove: avoid copying shadow twice. This is somewhat; /// unfortunate as it may slowdown small constant memcpys.; /// FIXME: consider doing manual inline for small constant sizes and proper; /// alignment.; ///; /// Note: This also handles memcpy.inline, which promises no calls to external; /// functions as an optimization. However, with instrumentation enabled this; /// is difficult to promise; additionally, we know that the MSan runtime; /// exists and provides __msan_memcpy(). Therefore, we assume that with; /// instrumentation it's safe to turn memcpy.inline into a call to; /// __msan_memcpy(). Should this be wrong, such as when implementing memcpy(); /// itself, instrumentation should be disabled with the no_sanitize attribute.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:586,Safety,safe,safe,586,"/// Instrument memcpy; ///; /// Similar to memmove: avoid copying shadow twice. This is somewhat; /// unfortunate as it may slowdown small constant memcpys.; /// FIXME: consider doing manual inline for small constant sizes and proper; /// alignment.; ///; /// Note: This also handles memcpy.inline, which promises no calls to external; /// functions as an optimization. However, with instrumentation enabled this; /// is difficult to promise; additionally, we know that the MSan runtime; /// exists and provides __msan_memcpy(). Therefore, we assume that with; /// instrumentation it's safe to turn memcpy.inline into a call to; /// __msan_memcpy(). Should this be wrong, such as when implementing memcpy(); /// itself, instrumentation should be disabled with the no_sanitize attribute.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:90,Usability,simpl,simple,90,"/// Handle vector store-like intrinsics.; ///; /// Instrument intrinsics that look like a simple SIMD store: writes memory,; /// has 1 pointer argument and 1 vector argument, returns void.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:18,Performance,load,load-like,18,"/// Handle vector load-like intrinsics.; ///; /// Instrument intrinsics that look like a simple SIMD load: reads memory,; /// has 1 pointer argument, returns a vector.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:101,Performance,load,load,101,"/// Handle vector load-like intrinsics.; ///; /// Instrument intrinsics that look like a simple SIMD load: reads memory,; /// has 1 pointer argument, returns a vector.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:89,Usability,simpl,simple,89,"/// Handle vector load-like intrinsics.; ///; /// Instrument intrinsics that look like a simple SIMD load: reads memory,; /// has 1 pointer argument, returns a vector.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:63,Performance,load,load,63,// We don't know the pointer alignment (could be unaligned SSE load!).; // Have to assume to worst case.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:286,Security,access,access,286,"/// Handle (SIMD arithmetic)-like intrinsics.; ///; /// Instrument intrinsics with any number of arguments of the same type,; /// equal to the return type. The type should be simple (no aggregates or; /// pointers; vectors are fine).; /// Caller guarantees that this intrinsic does not access memory.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:175,Usability,simpl,simple,175,"/// Handle (SIMD arithmetic)-like intrinsics.; ///; /// Instrument intrinsics with any number of arguments of the same type,; /// equal to the return type. The type should be simple (no aggregates or; /// pointers; vectors are fine).; /// Caller guarantees that this intrinsic does not access memory.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:28,Performance,load,load,28,// This looks like a vector load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:32,Availability,mask,maskstore,32,// FIXME: detect and handle SSE maskstore/maskload,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:42,Availability,mask,maskload,42,// FIXME: detect and handle SSE maskstore/maskload,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:10,Safety,detect,detect,10,// FIXME: detect and handle SSE maskstore/maskload,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:171,Availability,avail,available,171,"// The first *NumUsedElements* elements of ConvertOp are converted to the; // same number of output elements. The rest of the output is copied from; // CopyOp, or (if not available) filled with zeroes.; // Combine shadow for elements of ConvertOp that are used in this operation,; // and insert a check.; // FIXME: consider propagating shadow of ConvertOp, at least in the case of; // int->any conversion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:82,Performance,perform,perform,82,"// If any of the S2 bits are poisoned, the whole thing is poisoned.; // Otherwise perform the same shift on S1.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:21,Energy Efficiency,reduce,reduce,21,// Instrument vector.reduce.or intrinsic.; // Valid (non-poisoned) set bits in the operand pull low the; // corresponding shadow bits.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:99,Availability,down,down,99,// Instrument vector.reduce.and intrinsic.; // Valid (non-poisoned) unset bits in the operand pull down the; // corresponding shadow bits.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:21,Energy Efficiency,reduce,reduce,21,// Instrument vector.reduce.and intrinsic.; // Valid (non-poisoned) unset bits in the operand pull down the; // corresponding shadow bits.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:37,Performance,load,loaded,37,// Choose between PassThru's and the loaded value's origins.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:21,Availability,mask,mask,21,"// If any bit of the mask operand is poisoned, then the whole thing is.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:122,Integrability,depend,depending,122,"// Instrument pclmul intrinsics.; // These intrinsics operate either on odd or on even elements of the input; // vectors, depending on the constant in the 3rd argument, ignoring the rest.; // Replace the unused elements with copies of the used ones, ex:; // (0, 1, 2, 3) -> (0, 0, 2, 2) (even case); // or; // (0, 1, 2, 3) -> (1, 1, 3, 3) (odd case); // and then apply the usual shadow combining logic.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:396,Testability,log,logic,396,"// Instrument pclmul intrinsics.; // These intrinsics operate either on odd or on even elements of the input; // vectors, depending on the constant in the 3rd argument, ignoring the rest.; // Replace the unused elements with copies of the used ones, ex:; // (0, 1, 2, 3) -> (0, 0, 2, 2) (even case); // or; // (0, 1, 2, 3) -> (1, 1, 3, 3) (odd case); // and then apply the usual shadow combining logic.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:3,Modifiability,Variab,Variable,3,/* Variable */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:3,Modifiability,Variab,Variable,3,/* Variable */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:37,Deployability,Release,Release,37,// Convert the call to have at least Release ordering to make sure; // the shadow operations aren't reordered after it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:179,Performance,optimiz,optimized,179,"// We are going to insert code that relies on the fact that the callee; // will become a non-readonly function after it is instrumented by us. To; // prevent this code from being optimized out, mark that function; // non-readonly in advance.; // TODO: We can likely do better than dropping memory() completely here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:26,Performance,load,load,26,"// __sanitizer_unaligned_{load,store} functions may be called by users; // and always expects shadows in the TLS. So don't check them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:73,Performance,load,load,73,// ByVal requires some special handling as it's too big for a single; // load,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:18,Modifiability,extend,extending,18,"// To avoid ""sign extending"" i1 to an arbitrary aggregate type, we just do; // an extra ""select"". This results in much more compact IR.; // Sa = select Sb, poisoned, (select b, Sc, Sd)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:6,Safety,avoid,avoid,6,"// To avoid ""sign extending"" i1 to an arbitrary aggregate type, we just do; // an extra ""select"". This results in much more compact IR.; // Sa = select Sb, poisoned, (select b, Sc, Sd)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:194,Usability,simpl,simply,194,"// Sa = select Sb, [ (c^d) | Sc | Sd ], [ b ? Sc : Sd ]; // If Sb (condition is poisoned), look for bits in c and d that are equal; // and both unpoisoned.; // If !Sb (condition is unpoisoned), simply pick one of Sc and Sd.; // Cast arguments to shadow-compatible type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:49,Security,sanitiz,sanitizers,49,// Do nothing.; // See https://github.com/google/sanitizers/issues/504,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:54,Safety,avoid,avoid,54,// Here using VAArgOverflowSizeTLS as VAArgSizeTLS to avoid creation of; // a new class member i.e. it is the total size of all VarArgs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:7,Energy Efficiency,Power,PowerPC,7,"// For PowerPC, we need to deal with alignment of stack arguments -; // they are mostly aligned to 8 bytes, but vectors and i128 arrays; // are aligned to 16 bytes, byvals can be aligned to 8 or 16 bytes,; // For that reason, we compute current offset from stack pointer (which is; // always properly aligned), and offset for the first vararg, then subtract; // them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:54,Safety,avoid,avoid,54,// Here using VAArgOverflowSizeTLS as VAArgSizeTLS to avoid creation of; // a new class member i.e. it is the total size of all VarArgs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:334,Modifiability,extend,extended,334,"// ABI says: ""One of the simple integer types no more than 64 bits wide.; // ... If such an argument is shorter than 64 bits, replace it by a full; // 64-bit integer representing the same number, using sign or zero; // extension"". Shadow for an integer argument has the same type as the; // argument itself, so it can be sign or zero extended as well.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:25,Usability,simpl,simple,25,"// ABI says: ""One of the simple integer types no more than 64 bits wide.; // ... If such an argument is shorter than 64 bits, replace it by a full; // 64-bit integer representing the same number, using sign or zero; // extension"". Shadow for an integer argument has the same type as the; // argument itself, so it can be sign or zero extended as well.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:196,Modifiability,extend,extend,196,"// PoP says: ""A short floating-point datum requires only the; // left-most 32 bit positions of a floating-point register"".; // Therefore, in contrast to AK_GeneralPurpose and AK_Memory,; // don't extend shadow and don't mind the gap.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:120,Usability,clear,clear,120,"// FIXME: This implementation limits OverflowOffset to kParamTLSSize, so we; // don't know real overflow size and can't clear shadow beyond kParamTLSSize.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:3,Usability,Clear,Clear,3,// Clear out memory attributes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemProfiler.cpp:47,Security,access,access,47,"//===- MemProfiler.cpp - memory allocation and access profiler ------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file is a part of MemProfiler. Memory accesses are instrumented; // to increment the access count held in a shadow memory location, or; // alternatively to call into the runtime. Memory intrinsic calls (memmove,; // memcpy, memset) are changed to call the memory profiling runtime version; // instead.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemProfiler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemProfiler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemProfiler.cpp:426,Security,access,accesses,426,"//===- MemProfiler.cpp - memory allocation and access profiler ------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file is a part of MemProfiler. Memory accesses are instrumented; // to increment the access count held in a shadow memory location, or; // alternatively to call into the runtime. Memory intrinsic calls (memmove,; // memcpy, memset) are changed to call the memory profiling runtime version; // instead.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemProfiler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemProfiler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemProfiler.cpp:473,Security,access,access,473,"//===- MemProfiler.cpp - memory allocation and access profiler ------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file is a part of MemProfiler. Memory accesses are instrumented; // to increment the access count held in a shadow memory location, or; // alternatively to call into the runtime. Memory intrinsic calls (memmove,; // memcpy, memset) are changed to call the memory profiling runtime version; // instead.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemProfiler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemProfiler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemProfiler.cpp:26,Availability,down,down,26,// Scale from granularity down to shadow size.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemProfiler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemProfiler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemProfiler.cpp:106,Availability,mask,mask,106,// These flags allow to change the shadow mapping.; // The shadow mapping looks like; // Shadow = ((Mem & mask) >> scale) + offset,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemProfiler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemProfiler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemProfiler.cpp:81,Availability,mask,mask,81,/// This struct defines the shadow mapping using the rule:; /// shadow = ((mem & mask) >> Scale) ADD DynamicShadowOffset.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemProfiler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemProfiler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemProfiler.cpp:52,Security,access,accesses,52,/// Instrument the code in module to profile memory accesses.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemProfiler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemProfiler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemProfiler.cpp:35,Security,access,access,35,"/// If it is an interesting memory access, populate information; /// about the access and return a InterestingMemoryAccess struct.; /// Otherwise return std::nullopt.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemProfiler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemProfiler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemProfiler.cpp:79,Security,access,access,79,"/// If it is an interesting memory access, populate information; /// about the access and return a InterestingMemoryAccess struct.; /// Otherwise return std::nullopt.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemProfiler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemProfiler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemProfiler.cpp:30,Security,Access,AccessIsWrite,30,// These arrays is indexed by AccessIsWrite,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemProfiler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemProfiler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemProfiler.cpp:13,Availability,mask,mask,13,// (Shadow & mask) >> scale,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemProfiler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemProfiler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemProfiler.cpp:25,Performance,load,load,25,// Do not instrument the load fetching the dynamic shadow address.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemProfiler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemProfiler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemProfiler.cpp:3,Availability,Mask,Masked,3,// Masked store has an initial operand for the value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemProfiler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemProfiler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemProfiler.cpp:21,Security,access,accesses,21,// Do not instrument accesses from different address spaces; we cannot deal; // with them.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemProfiler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemProfiler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemProfiler.cpp:33,Deployability,update,updates,33,// Do not instrument PGO counter updates.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemProfiler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemProfiler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemProfiler.cpp:47,Modifiability,variab,variables,47,// Do not instrument accesses to LLVM internal variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemProfiler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemProfiler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemProfiler.cpp:21,Security,access,accesses,21,// Do not instrument accesses to LLVM internal variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemProfiler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemProfiler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemProfiler.cpp:3,Availability,Mask,Mask,3,"// Mask is constant false, so no instrumentation needed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemProfiler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemProfiler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemProfiler.cpp:33,Security,access,accesses,33,// Skip instrumentation of stack accesses unless requested.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemProfiler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemProfiler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemProfiler.cpp:89,Deployability,update,update,89,"// Since the access counts will be accumulated across the entire allocation,; // we only update the shadow access count for the first location and thus; // don't need to worry about alignment and type size.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemProfiler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemProfiler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemProfiler.cpp:13,Security,access,access,13,"// Since the access counts will be accumulated across the entire allocation,; // we only update the shadow access count for the first location and thus; // don't need to worry about alignment and type size.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemProfiler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemProfiler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemProfiler.cpp:107,Security,access,access,107,"// Since the access counts will be accumulated across the entire allocation,; // we only update the shadow access count for the first location and thus; // don't need to worry about alignment and type size.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemProfiler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemProfiler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemProfiler.cpp:14,Modifiability,variab,variable,14,// Create the variable for the profile file name.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemProfiler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemProfiler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemProfiler.cpp:42,Performance,load,load,42,"// For each NSObject descendant having a +load method, this method is invoked; // by the ObjC runtime before any of the static constructors is called.; // Therefore we need to instrument such methods with a call to __memprof_init; // at the beginning in order to initialize our runtime before any access to; // the shadow memory.; // We cannot just ignore these methods, because they may call other; // instrumented functions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemProfiler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemProfiler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemProfiler.cpp:297,Security,access,access,297,"// For each NSObject descendant having a +load method, this method is invoked; // by the ObjC runtime before any of the static constructors is called.; // Therefore we need to instrument such methods with a call to __memprof_init; // at the beginning in order to initialize our runtime before any access to; // the shadow memory.; // We cannot just ignore these methods, because they may call other; // instrumented functions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemProfiler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemProfiler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemProfiler.cpp:190,Usability,GUID,GUID,190,"// Previously we used getIRPGOFuncName() here. If F is local linkage,; // getIRPGOFuncName() returns FuncName with prefix 'FileName;'. But; // llvm-profdata uses FuncName in dwarf to create GUID which doesn't; // contain FileName's prefix. It caused local linkage function can't; // find MemProfRecord. So we use getName() now.; // 'unique-internal-linkage-names' can make MemProf work better for local; // linkage function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemProfiler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemProfiler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemProfiler.cpp:3,Safety,Detect,Detect,3,"// Detect if there are non-zero column numbers in the profile. If not,; // treat all column numbers as 0 when matching (i.e. ignore any non-zero; // columns in the IR). The profiled binary might have been built with; // column numbers disabled, for example.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemProfiler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemProfiler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemProfiler.cpp:30,Security,hash,hash,30,// Build maps of the location hash to all profile data with that leaf location; // (allocation info and the callsites).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemProfiler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemProfiler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemProfiler.cpp:53,Security,hash,hashes,53,// List of call stack ids computed from the location hashes on debug; // locations (leaf to inlined at root).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemProfiler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemProfiler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemProfiler.cpp:41,Energy Efficiency,reduce,reduce,41,"// Only consider allocations via new, to reduce unnecessary metadata,; // since those are the only allocations that will be targeted initially.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemProfiler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemProfiler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemProfiler.cpp:243,Deployability,update,updated,243,"// Add callsite metadata for the instruction's location list so that; // it simpler later on to identify which part of the MIB contexts; // are from this particular instruction (including during inlining,; // when the callsite metdata will be updated appropriately).; // FIXME: can this be changed to strip out the matching stack; // context ids from the MIB contexts and not add any callsite; // metadata here to save space?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemProfiler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemProfiler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemProfiler.cpp:76,Usability,simpl,simpler,76,"// Add callsite metadata for the instruction's location list so that; // it simpler later on to identify which part of the MIB contexts; // are from this particular instruction (including during inlining,; // when the callsite metdata will be updated appropriately).; // FIXME: can this be changed to strip out the matching stack; // context ids from the MIB contexts and not add any callsite; // metadata here to save space?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemProfiler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemProfiler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp:1227,Energy Efficiency,reduce,reduce,1227,"rmation.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements PGO instrumentation using a minimum spanning tree based; // on the following paper:; // [1] Donald E. Knuth, Francis R. Stevenson. Optimal measurement of points; // for program frequency counts. BIT Numerical Mathematics 1973, Volume 13,; // Issue 3, pp 313-322; // The idea of the algorithm based on the fact that for each node (except for; // the entry and exit), the sum of incoming edge counts equals the sum of; // outgoing edge counts. The count of edge on spanning tree can be derived from; // those edges not on the spanning tree. Knuth proves this method instruments; // the minimum number of edges.; //; // The minimal spanning tree here is actually a maximum weight tree -- on-tree; // edges have higher frequencies (more likely to execute). The idea is to; // instrument those less frequently executed edges to reduce the runtime; // overhead of instrumented binaries.; //; // This file contains two passes:; // (1) Pass PGOInstrumentationGen which instruments the IR to generate edge; // count profile, and generates the instrumentation for indirect call; // profiling.; // (2) Pass PGOInstrumentationUse which reads the edge count profile and; // annotates the branch weights. It also reads the indirect call value; // profiling records and annotate the indirect call instructions.; //; // To get the precise counter information, These two passes need to invoke at; // the same compilation point (so they see the same IR). For pass; // PGOInstrumentationGen, the real work is done in instrumentOneFunc(). For; // pass PGOInstrumentationUse, the real work in done in class PGOUseFunc and; // the profile is opened in module level and passed to each PGOUseFunc instance.; // The shared code for PGOInstrumentationGen and PGOInstrumentationUse is put; // in class FuncPGOInstrumentation.; //; // Class PGO",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp:93,Testability,test,testing,93,// Command line option to specify the file to read profile from. This is; // mainly used for testing.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp:106,Safety,avoid,avoid,106,// Command line option to control appending FunctionHash to the name of a COMDAT; // function. This is to avoid the hash mismatch caused by the preinliner.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp:116,Security,hash,hash,116,// Command line option to control appending FunctionHash to the name of a COMDAT; // function. This is to avoid the hash mismatch caused by the preinliner.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp:61,Security,hash,hash,61,// Command line option to enable/disable the warning about a hash mismatch in; // the profile data.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp:61,Security,hash,hash,61,"// Command line option to enable/disable the warning about a hash mismatch in; // the profile data for Comdat functions, which often turns out to be false; // positive due to the pre-instrumentation inline.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp:30,Performance,optimiz,optimization,30,// Emit branch probability as optimization remarks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp:19,Modifiability,variab,variable,19,// Create a COMDAT variable INSTR_PROF_RAW_VERSION_VAR to make the runtime; // aware this is an ir_level profile so it can set the version flag.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp:108,Usability,simpl,simply,108,"/// The select instruction visitor plays three roles specified; /// by the mode. In \c VM_counting mode, it simply counts the number of; /// select instructions. In \c VM_instrument mode, it inserts code to count; /// the number times TrueValue of select is taken. In \c VM_annotate mode,; /// it reads the profile data and annotate the select instruction with metadata.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp:108,Modifiability,variab,variable,108,// Visit the IR stream and instrument all select instructions. \p; // Ind is a pointer to the counter index variable; \p TotalNC; // is the total number of counters; \p FNV is the pointer to the; // PGO function name var; \p FHash is the function hash.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp:247,Security,hash,hash,247,// Visit the IR stream and instrument all select instructions. \p; // Ind is a pointer to the counter index variable; \p TotalNC; // is the total number of counters; \p FNV is the pointer to the; // PGO function name var; \p FHash is the function hash.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp:31,Performance,perform,perform,31,// Visit \p SI instruction and perform tasks according to visit mode.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp:7,Security,hash,hash,7,// CFG hash value for this function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp:42,Availability,avail,available,42,// Return the auxiliary BB information if available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp:34,Security,hash,hash,34,// This should be done before CFG hash computation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp:39,Security,Hash,Hash,39,"// end anonymous namespace; // Compute Hash value for the CFG: the lower 32 bits are CRC32 of the index; // value of each BB in the CFG. The higher 32 bits are the CRC32 of the numbers; // of selects, indirect calls, mem ops and edges.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp:3,Security,Hash,Hash,3,// Hash format for context sensitive profile. Reserve 4 bits for other; // information.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp:19,Safety,safe,safely,19,// Check if we can safely rename this Comdat function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp:278,Energy Efficiency,efficient,efficiently,278,"// FIXME: Current only handle those Comdat groups that only containing one; // function.; // (1) For a Comdat group containing multiple functions, we need to have a; // unique postfix based on the hashes for each function. There is a; // non-trivial code refactoring to do this efficiently.; // (2) Variables can not be renamed, so we can not rename Comdat function in a; // group including global vars.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp:255,Modifiability,refactor,refactoring,255,"// FIXME: Current only handle those Comdat groups that only containing one; // function.; // (1) For a Comdat group containing multiple functions, we need to have a; // unique postfix based on the hashes for each function. There is a; // non-trivial code refactoring to do this efficiently.; // (2) Variables can not be renamed, so we can not rename Comdat function in a; // group including global vars.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp:299,Modifiability,Variab,Variables,299,"// FIXME: Current only handle those Comdat groups that only containing one; // function.; // (1) For a Comdat group containing multiple functions, we need to have a; // unique postfix based on the hashes for each function. There is a; // non-trivial code refactoring to do this efficiently.; // (2) Variables can not be renamed, so we can not rename Comdat function in a; // group including global vars.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp:197,Security,hash,hashes,197,"// FIXME: Current only handle those Comdat groups that only containing one; // function.; // (1) For a Comdat group containing multiple functions, we need to have a; // unique postfix based on the hashes for each function. There is a; // non-trivial code refactoring to do this efficiently.; // (2) Variables can not be renamed, so we can not rename Comdat function in a; // group including global vars.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp:7,Availability,Avail,AvailableExternallyLinkage,7,"// For AvailableExternallyLinkage functions, change the linkage to; // LinkOnceODR and put them into comdat. This is because after renaming, there; // is no backup external copy available for the function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp:178,Availability,avail,available,178,"// For AvailableExternallyLinkage functions, change the linkage to; // LinkOnceODR and put them into comdat. This is because after renaming, there; // is no backup external copy available for the function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp:29,Deployability,update,update,29,// Use a worklist as we will update the vector during the iteration.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp:52,Integrability,rout,routines,52,"// When generating value profiling calls on Windows routines that make use of; // handler funclets for exception processing an operand bundle needs to attached; // to the called function. This routine will set \p OpBundles to contain the; // funclet information, if any is needed, that should be placed on the generated; // value profiling call for the value profile candidate call.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp:193,Integrability,rout,routine,193,"// When generating value profiling calls on Windows routines that make use of; // handler funclets for exception processing an operand bundle needs to attached; // to the called function. This routine will set \p OpBundles to contain the; // funclet information, if any is needed, that should be placed on the generated; // value profiling call for the value profile candidate call.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp:144,Integrability,rout,routine,144,// Intrinsics or other instructions do not get funclet information from the; // front-end. Need to use the BlockColors that was computed by the routine; // colorEHFunclets to determine whether a funclet is needed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp:106,Safety,avoid,avoid,106,// Split indirectbr critical edges here before computing the MST rather than; // later in getInstrBB() to avoid invalidating it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp:41,Security,hash,hash,41,"// llvm.instrprof.cover(i8* <name>, i64 <hash>, i32 <num-counters>,; // i32 <index>)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp:45,Security,hash,hash,45,"// llvm.instrprof.timestamp(i8* <name>, i64 <hash>, i32 <num-counters>,; // i32 <index>)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp:45,Security,hash,hash,45,"// llvm.instrprof.increment(i8* <name>, i64 <hash>, i32 <num-counters>,; // i32 <index>)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp:22,Deployability,update,update,22,// Add an OutEdge and update the edge count.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp:21,Deployability,update,update,21,// Add an InEdge and update the edge count.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp:23,Security,hash,hash,23,// Return the function hash.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp:42,Availability,avail,available,42,// Return the auxiliary BB information if available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp:63,Availability,error,error,63,// Find the Instrumented BB and set the value. Return false on error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp:109,Availability,error,error,109,// Visit all the edges and assign the count value for the instrumented; // edges and the BB. Return false on error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp:26,Deployability,update,update,26,// Set the edge count and update the count of unknown edges for BBs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp:215,Availability,error,errors,215,"// Read the profile from ProfileFileName and assign the value to the; // instrumented BB and the edges. This function also updates ProgramMaxCount.; // Return true if the profile are successfully read, and false on errors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp:123,Deployability,update,updates,123,"// Read the profile from ProfileFileName and assign the value to the; // instrumented BB and the edges. This function also updates ProgramMaxCount.; // Return true if the profile are successfully read, and false on errors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp:7,Energy Efficiency,efficient,efficient,7,"// For efficient traversal, it's better to start from the end as most; // of the instrumented edges are at the end.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp:3,Testability,Assert,Assert,3,// Assert every BB has a valid counter.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp:126,Modifiability,variab,variables,126,"// For the context-sensitve instrumentation, we should have a separated pass; // (before LTO/ThinLTO linking) to create these variables.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp:7,Modifiability,variab,variable,7,// The variable in a comdat may be discarded by LTO. Ensure the declaration; // will be retained.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp:106,Safety,avoid,avoid,106,// Split indirectbr critical edges here before computing the MST rather; // than later in getInstrBB() to avoid invalidating it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp:3,Usability,Clear,Clear,3,// Clear function attribute cold.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOMemOPSizeOpt.cpp:556,Availability,avail,available,556,"//===-- PGOMemOPSizeOpt.cpp - Optimizations based on value profiling ===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the transformation that optimizes memory intrinsics; // such as memcpy using the size value profile. When memory intrinsic size; // value profile metadata is available, a single memory intrinsic is expanded; // to a sequence of guarded specialized versions that are called with the; // hottest size(s), for later expansion into more optimal inline sequences.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOMemOPSizeOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOMemOPSizeOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOMemOPSizeOpt.cpp:30,Performance,Optimiz,Optimizations,30,"//===-- PGOMemOPSizeOpt.cpp - Optimizations based on value profiling ===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the transformation that optimizes memory intrinsics; // such as memcpy using the size value profile. When memory intrinsic size; // value profile metadata is available, a single memory intrinsic is expanded; // to a sequence of guarded specialized versions that are called with the; // hottest size(s), for later expansion into more optimal inline sequences.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOMemOPSizeOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOMemOPSizeOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOMemOPSizeOpt.cpp:422,Performance,optimiz,optimizes,422,"//===-- PGOMemOPSizeOpt.cpp - Optimizations based on value profiling ===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the transformation that optimizes memory intrinsics; // such as memcpy using the size value profile. When memory intrinsic size; // value profile metadata is available, a single memory intrinsic is expanded; // to a sequence of guarded specialized versions that are called with the; // hottest size(s), for later expansion into more optimal inline sequences.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOMemOPSizeOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOMemOPSizeOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOMemOPSizeOpt.cpp:29,Performance,optimiz,optimize,29,// The minimum call count to optimize memory intrinsic calls.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOMemOPSizeOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOMemOPSizeOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOMemOPSizeOpt.cpp:51,Performance,optimiz,optimization,51,// Command line option to disable memory intrinsic optimization. The default is; // false. This is for debug purpose.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOMemOPSizeOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOMemOPSizeOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOMemOPSizeOpt.cpp:28,Performance,optimiz,optimize,28,// The percent threshold to optimize memory intrinsic calls.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOMemOPSizeOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOMemOPSizeOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOMemOPSizeOpt.cpp:34,Performance,optimiz,optimizing,34,// Maximum number of versions for optimizing memory intrinsic call.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOMemOPSizeOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOMemOPSizeOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOMemOPSizeOpt.cpp:7,Performance,perform,perform,7,// Not perform on constant length calls.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOMemOPSizeOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOMemOPSizeOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOMemOPSizeOpt.cpp:3,Usability,Clear,Clear,3,// Clear the value profile data.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOMemOPSizeOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOMemOPSizeOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOMemOPSizeOpt.cpp:21,Deployability,update,update,21,// Otherwise we need update with the un-promoted records back.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOMemOPSizeOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOMemOPSizeOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PoisonChecking.cpp:2292,Energy Efficiency,reduce,reduced,2292,"ducing flags on the; // instruction itself (e.g. checks for overflow on nsw).; // 4) A check rule which traps (to a handler function) if this instruction must; // execute undefined behavior given the poison state of it's inputs.; //; // This is a must analysis based transform; that is, the resulting code may; // produce a false negative result (not report UB when actually exists; // according to the LangRef spec), but should never produce a false positive; // (report UB where it doesn't exist).; //; // Use cases for this pass include:; // - Understanding (and testing!) the implications of the definition of poison; // from the LangRef.; // - Validating the output of a IR fuzzer to ensure that all programs produced; // are well defined on the specific input used.; // - Finding/confirming poison specific miscompiles by checking the poison; // status of an input/IR pair is the same before and after an optimization; // transform.; // - Checking that a bugpoint reduction does not introduce UB which didn't; // exist in the original program being reduced.; //; // The major sources of inaccuracy are currently:; // - Most validation rules not yet implemented for instructions with poison; // relavant flags. At the moment, only nsw/nuw on add/sub are supported.; // - UB which is control dependent on a branch on poison is not yet; // reported. Currently, only data flow dependence is modeled.; // - Poison which is propagated through memory is not modeled. As such,; // storing poison to memory and then reloading it will cause a false negative; // as we consider the reloaded value to not be poisoned.; // - Poison propagation across function boundaries is not modeled. At the; // moment, all arguments and return values are assumed not to be poison.; // - Undef is not modeled. In particular, the optimizer's freedom to pick; // concrete values for undef bits so as to maximize potential for producing; // poison is not modeled.; //; //===---------------------------------------------------",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PoisonChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PoisonChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PoisonChecking.cpp:2533,Integrability,depend,dependent,2533,"nstruction itself (e.g. checks for overflow on nsw).; // 4) A check rule which traps (to a handler function) if this instruction must; // execute undefined behavior given the poison state of it's inputs.; //; // This is a must analysis based transform; that is, the resulting code may; // produce a false negative result (not report UB when actually exists; // according to the LangRef spec), but should never produce a false positive; // (report UB where it doesn't exist).; //; // Use cases for this pass include:; // - Understanding (and testing!) the implications of the definition of poison; // from the LangRef.; // - Validating the output of a IR fuzzer to ensure that all programs produced; // are well defined on the specific input used.; // - Finding/confirming poison specific miscompiles by checking the poison; // status of an input/IR pair is the same before and after an optimization; // transform.; // - Checking that a bugpoint reduction does not introduce UB which didn't; // exist in the original program being reduced.; //; // The major sources of inaccuracy are currently:; // - Most validation rules not yet implemented for instructions with poison; // relavant flags. At the moment, only nsw/nuw on add/sub are supported.; // - UB which is control dependent on a branch on poison is not yet; // reported. Currently, only data flow dependence is modeled.; // - Poison which is propagated through memory is not modeled. As such,; // storing poison to memory and then reloading it will cause a false negative; // as we consider the reloaded value to not be poisoned.; // - Poison propagation across function boundaries is not modeled. At the; // moment, all arguments and return values are assumed not to be poison.; // - Undef is not modeled. In particular, the optimizer's freedom to pick; // concrete values for undef bits so as to maximize potential for producing; // poison is not modeled.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PoisonChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PoisonChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PoisonChecking.cpp:2616,Integrability,depend,dependence,2616,"nstruction itself (e.g. checks for overflow on nsw).; // 4) A check rule which traps (to a handler function) if this instruction must; // execute undefined behavior given the poison state of it's inputs.; //; // This is a must analysis based transform; that is, the resulting code may; // produce a false negative result (not report UB when actually exists; // according to the LangRef spec), but should never produce a false positive; // (report UB where it doesn't exist).; //; // Use cases for this pass include:; // - Understanding (and testing!) the implications of the definition of poison; // from the LangRef.; // - Validating the output of a IR fuzzer to ensure that all programs produced; // are well defined on the specific input used.; // - Finding/confirming poison specific miscompiles by checking the poison; // status of an input/IR pair is the same before and after an optimization; // transform.; // - Checking that a bugpoint reduction does not introduce UB which didn't; // exist in the original program being reduced.; //; // The major sources of inaccuracy are currently:; // - Most validation rules not yet implemented for instructions with poison; // relavant flags. At the moment, only nsw/nuw on add/sub are supported.; // - UB which is control dependent on a branch on poison is not yet; // reported. Currently, only data flow dependence is modeled.; // - Poison which is propagated through memory is not modeled. As such,; // storing poison to memory and then reloading it will cause a false negative; // as we consider the reloaded value to not be poisoned.; // - Poison propagation across function boundaries is not modeled. At the; // moment, all arguments and return values are assumed not to be poison.; // - Undef is not modeled. In particular, the optimizer's freedom to pick; // concrete values for undef bits so as to maximize potential for producing; // poison is not modeled.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PoisonChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PoisonChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PoisonChecking.cpp:2148,Performance,optimiz,optimization,2148,"// state of each input to whether the dynamic output of the instruction; // produces poison.; // 3) A creation rule which validates any poison producing flags on the; // instruction itself (e.g. checks for overflow on nsw).; // 4) A check rule which traps (to a handler function) if this instruction must; // execute undefined behavior given the poison state of it's inputs.; //; // This is a must analysis based transform; that is, the resulting code may; // produce a false negative result (not report UB when actually exists; // according to the LangRef spec), but should never produce a false positive; // (report UB where it doesn't exist).; //; // Use cases for this pass include:; // - Understanding (and testing!) the implications of the definition of poison; // from the LangRef.; // - Validating the output of a IR fuzzer to ensure that all programs produced; // are well defined on the specific input used.; // - Finding/confirming poison specific miscompiles by checking the poison; // status of an input/IR pair is the same before and after an optimization; // transform.; // - Checking that a bugpoint reduction does not introduce UB which didn't; // exist in the original program being reduced.; //; // The major sources of inaccuracy are currently:; // - Most validation rules not yet implemented for instructions with poison; // relavant flags. At the moment, only nsw/nuw on add/sub are supported.; // - UB which is control dependent on a branch on poison is not yet; // reported. Currently, only data flow dependence is modeled.; // - Poison which is propagated through memory is not modeled. As such,; // storing poison to memory and then reloading it will cause a false negative; // as we consider the reloaded value to not be poisoned.; // - Poison propagation across function boundaries is not modeled. At the; // moment, all arguments and return values are assumed not to be poison.; // - Undef is not modeled. In particular, the optimizer's freedom to pick; // concrete values",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PoisonChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PoisonChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PoisonChecking.cpp:3045,Performance,optimiz,optimizer,3045,"nstruction itself (e.g. checks for overflow on nsw).; // 4) A check rule which traps (to a handler function) if this instruction must; // execute undefined behavior given the poison state of it's inputs.; //; // This is a must analysis based transform; that is, the resulting code may; // produce a false negative result (not report UB when actually exists; // according to the LangRef spec), but should never produce a false positive; // (report UB where it doesn't exist).; //; // Use cases for this pass include:; // - Understanding (and testing!) the implications of the definition of poison; // from the LangRef.; // - Validating the output of a IR fuzzer to ensure that all programs produced; // are well defined on the specific input used.; // - Finding/confirming poison specific miscompiles by checking the poison; // status of an input/IR pair is the same before and after an optimization; // transform.; // - Checking that a bugpoint reduction does not introduce UB which didn't; // exist in the original program being reduced.; //; // The major sources of inaccuracy are currently:; // - Most validation rules not yet implemented for instructions with poison; // relavant flags. At the moment, only nsw/nuw on add/sub are supported.; // - UB which is control dependent on a branch on poison is not yet; // reported. Currently, only data flow dependence is modeled.; // - Poison which is propagated through memory is not modeled. As such,; // storing poison to memory and then reloading it will cause a false negative; // as we consider the reloaded value to not be poisoned.; // - Poison propagation across function boundaries is not modeled. At the; // moment, all arguments and return values are assumed not to be poison.; // - Undef is not modeled. In particular, the optimizer's freedom to pick; // concrete values for undef bits so as to maximize potential for producing; // poison is not modeled.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PoisonChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PoisonChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PoisonChecking.cpp:658,Security,sanitiz,sanitizer,658,"//===- PoisonChecking.cpp - -----------------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Implements a transform pass which instruments IR such that poison semantics; // are made explicit. That is, it provides a (possibly partial) executable; // semantics for every instruction w.r.t. poison as specified in the LLVM; // LangRef. There are obvious parallels to the sanitizer tools, but this pass; // is focused purely on the semantics of LLVM IR, not any particular source; // language. If you're looking for something to see if your C/C++ contains; // UB, this is not it.; //; // The rewritten semantics of each instruction will include the following; // components:; //; // 1) The original instruction, unmodified.; // 2) A propagation rule which translates dynamic information about the poison; // state of each input to whether the dynamic output of the instruction; // produces poison.; // 3) A creation rule which validates any poison producing flags on the; // instruction itself (e.g. checks for overflow on nsw).; // 4) A check rule which traps (to a handler function) if this instruction must; // execute undefined behavior given the poison state of it's inputs.; //; // This is a must analysis based transform; that is, the resulting code may; // produce a false negative result (not report UB when actually exists; // according to the LangRef spec), but should never produce a false positive; // (report UB where it doesn't exist).; //; // Use cases for this pass include:; // - Understanding (and testing!) the implications of the definition of poison; // from the LangRef.; // - Validating the output of a IR fuzzer to ensure that all programs produced; // are well defined on the specific inpu",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PoisonChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PoisonChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PoisonChecking.cpp:1213,Security,validat,validates,1213,"SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Implements a transform pass which instruments IR such that poison semantics; // are made explicit. That is, it provides a (possibly partial) executable; // semantics for every instruction w.r.t. poison as specified in the LLVM; // LangRef. There are obvious parallels to the sanitizer tools, but this pass; // is focused purely on the semantics of LLVM IR, not any particular source; // language. If you're looking for something to see if your C/C++ contains; // UB, this is not it.; //; // The rewritten semantics of each instruction will include the following; // components:; //; // 1) The original instruction, unmodified.; // 2) A propagation rule which translates dynamic information about the poison; // state of each input to whether the dynamic output of the instruction; // produces poison.; // 3) A creation rule which validates any poison producing flags on the; // instruction itself (e.g. checks for overflow on nsw).; // 4) A check rule which traps (to a handler function) if this instruction must; // execute undefined behavior given the poison state of it's inputs.; //; // This is a must analysis based transform; that is, the resulting code may; // produce a false negative result (not report UB when actually exists; // according to the LangRef spec), but should never produce a false positive; // (report UB where it doesn't exist).; //; // Use cases for this pass include:; // - Understanding (and testing!) the implications of the definition of poison; // from the LangRef.; // - Validating the output of a IR fuzzer to ensure that all programs produced; // are well defined on the specific input used.; // - Finding/confirming poison specific miscompiles by checking the poison; // status of an input/IR pair is the same before and after an optimization; // transform.; // - Checking that a bugpoint reduction does not introdu",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PoisonChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PoisonChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PoisonChecking.cpp:1886,Security,Validat,Validating,1886,"g; // components:; //; // 1) The original instruction, unmodified.; // 2) A propagation rule which translates dynamic information about the poison; // state of each input to whether the dynamic output of the instruction; // produces poison.; // 3) A creation rule which validates any poison producing flags on the; // instruction itself (e.g. checks for overflow on nsw).; // 4) A check rule which traps (to a handler function) if this instruction must; // execute undefined behavior given the poison state of it's inputs.; //; // This is a must analysis based transform; that is, the resulting code may; // produce a false negative result (not report UB when actually exists; // according to the LangRef spec), but should never produce a false positive; // (report UB where it doesn't exist).; //; // Use cases for this pass include:; // - Understanding (and testing!) the implications of the definition of poison; // from the LangRef.; // - Validating the output of a IR fuzzer to ensure that all programs produced; // are well defined on the specific input used.; // - Finding/confirming poison specific miscompiles by checking the poison; // status of an input/IR pair is the same before and after an optimization; // transform.; // - Checking that a bugpoint reduction does not introduce UB which didn't; // exist in the original program being reduced.; //; // The major sources of inaccuracy are currently:; // - Most validation rules not yet implemented for instructions with poison; // relavant flags. At the moment, only nsw/nuw on add/sub are supported.; // - UB which is control dependent on a branch on poison is not yet; // reported. Currently, only data flow dependence is modeled.; // - Poison which is propagated through memory is not modeled. As such,; // storing poison to memory and then reloading it will cause a false negative; // as we consider the reloaded value to not be poisoned.; // - Poison propagation across function boundaries is not modeled. At the; // moment, all argu",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PoisonChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PoisonChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PoisonChecking.cpp:2367,Security,validat,validation,2367,"nstruction itself (e.g. checks for overflow on nsw).; // 4) A check rule which traps (to a handler function) if this instruction must; // execute undefined behavior given the poison state of it's inputs.; //; // This is a must analysis based transform; that is, the resulting code may; // produce a false negative result (not report UB when actually exists; // according to the LangRef spec), but should never produce a false positive; // (report UB where it doesn't exist).; //; // Use cases for this pass include:; // - Understanding (and testing!) the implications of the definition of poison; // from the LangRef.; // - Validating the output of a IR fuzzer to ensure that all programs produced; // are well defined on the specific input used.; // - Finding/confirming poison specific miscompiles by checking the poison; // status of an input/IR pair is the same before and after an optimization; // transform.; // - Checking that a bugpoint reduction does not introduce UB which didn't; // exist in the original program being reduced.; //; // The major sources of inaccuracy are currently:; // - Most validation rules not yet implemented for instructions with poison; // relavant flags. At the moment, only nsw/nuw on add/sub are supported.; // - UB which is control dependent on a branch on poison is not yet; // reported. Currently, only data flow dependence is modeled.; // - Poison which is propagated through memory is not modeled. As such,; // storing poison to memory and then reloading it will cause a false negative; // as we consider the reloaded value to not be poisoned.; // - Poison propagation across function boundaries is not modeled. At the; // moment, all arguments and return values are assumed not to be poison.; // - Undef is not modeled. In particular, the optimizer's freedom to pick; // concrete values for undef bits so as to maximize potential for producing; // poison is not modeled.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PoisonChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PoisonChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PoisonChecking.cpp:1803,Testability,test,testing,1803,"hing to see if your C/C++ contains; // UB, this is not it.; //; // The rewritten semantics of each instruction will include the following; // components:; //; // 1) The original instruction, unmodified.; // 2) A propagation rule which translates dynamic information about the poison; // state of each input to whether the dynamic output of the instruction; // produces poison.; // 3) A creation rule which validates any poison producing flags on the; // instruction itself (e.g. checks for overflow on nsw).; // 4) A check rule which traps (to a handler function) if this instruction must; // execute undefined behavior given the poison state of it's inputs.; //; // This is a must analysis based transform; that is, the resulting code may; // produce a false negative result (not report UB when actually exists; // according to the LangRef spec), but should never produce a false positive; // (report UB where it doesn't exist).; //; // Use cases for this pass include:; // - Understanding (and testing!) the implications of the definition of poison; // from the LangRef.; // - Validating the output of a IR fuzzer to ensure that all programs produced; // are well defined on the specific input used.; // - Finding/confirming poison specific miscompiles by checking the poison; // status of an input/IR pair is the same before and after an optimization; // transform.; // - Checking that a bugpoint reduction does not introduce UB which didn't; // exist in the original program being reduced.; //; // The major sources of inaccuracy are currently:; // - Most validation rules not yet implemented for instructions with poison; // relavant flags. At the moment, only nsw/nuw on add/sub are supported.; // - UB which is control dependent on a branch on poison is not yet; // reported. Currently, only data flow dependence is modeled.; // - Poison which is propagated through memory is not modeled. As such,; // storing poison to memory and then reloading it will cause a false negative; // as we conside",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PoisonChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PoisonChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PoisonChecking.cpp:222,Testability,test,testing,222,"// Return false for unknwon values - this implements a non-strict mode where; // unhandled IR constructs are simply considered to never produce poison. At; // some point in the future, we probably want a ""strict mode"" for testing if; // nothing else.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PoisonChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PoisonChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PoisonChecking.cpp:109,Usability,simpl,simply,109,"// Return false for unknwon values - this implements a non-strict mode where; // unhandled IR constructs are simply considered to never produce poison. At; // some point in the future, we probably want a ""strict mode"" for testing if; // nothing else.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PoisonChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PoisonChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PoisonChecking.cpp:290,Availability,mask,mask,290,"/* Major TODO Items:; - Control dependent poison UB; - Strict mode - (i.e. must analyze every operand); - Poison through memory; - Function ABIs; - Full coverage of intrinsics, etc.. (ouch). Instructions w/Unclear Semantics:; - shufflevector - It would seem reasonable for an out of bounds mask element; to produce poison, but the LangRef does not state.; - all binary ops w/vector operands - The likely interpretation would be that; any element overflowing should produce poison for the entire result, but; the LangRef does not state.; - Floating point binary ops w/fmf flags other than (nnan, noinfs). It seems; strange that only certian flags should be documented as producing poison. Cases of clear poison semantics not yet implemented:; - Exact flags on ashr/lshr produce poison; - NSW/NUW flags on shl produce poison; - Inbounds flag on getelementptr produce poison; - fptosi/fptoui (out of bounds input) produce poison; - Scalable vector types for insertelement/extractelement; - Floating point binary ops w/fmf nnan/noinfs flags produce poison; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PoisonChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PoisonChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PoisonChecking.cpp:32,Integrability,depend,dependent,32,"/* Major TODO Items:; - Control dependent poison UB; - Strict mode - (i.e. must analyze every operand); - Poison through memory; - Function ABIs; - Full coverage of intrinsics, etc.. (ouch). Instructions w/Unclear Semantics:; - shufflevector - It would seem reasonable for an out of bounds mask element; to produce poison, but the LangRef does not state.; - all binary ops w/vector operands - The likely interpretation would be that; any element overflowing should produce poison for the entire result, but; the LangRef does not state.; - Floating point binary ops w/fmf flags other than (nnan, noinfs). It seems; strange that only certian flags should be documented as producing poison. Cases of clear poison semantics not yet implemented:; - Exact flags on ashr/lshr produce poison; - NSW/NUW flags on shl produce poison; - Inbounds flag on getelementptr produce poison; - fptosi/fptoui (out of bounds input) produce poison; - Scalable vector types for insertelement/extractelement; - Floating point binary ops w/fmf nnan/noinfs flags produce poison; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PoisonChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PoisonChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PoisonChecking.cpp:929,Performance,Scalab,Scalable,929,"/* Major TODO Items:; - Control dependent poison UB; - Strict mode - (i.e. must analyze every operand); - Poison through memory; - Function ABIs; - Full coverage of intrinsics, etc.. (ouch). Instructions w/Unclear Semantics:; - shufflevector - It would seem reasonable for an out of bounds mask element; to produce poison, but the LangRef does not state.; - all binary ops w/vector operands - The likely interpretation would be that; any element overflowing should produce poison for the entire result, but; the LangRef does not state.; - Floating point binary ops w/fmf flags other than (nnan, noinfs). It seems; strange that only certian flags should be documented as producing poison. Cases of clear poison semantics not yet implemented:; - Exact flags on ashr/lshr produce poison; - NSW/NUW flags on shl produce poison; - Inbounds flag on getelementptr produce poison; - fptosi/fptoui (out of bounds input) produce poison; - Scalable vector types for insertelement/extractelement; - Floating point binary ops w/fmf nnan/noinfs flags produce poison; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PoisonChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PoisonChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PoisonChecking.cpp:697,Usability,clear,clear,697,"/* Major TODO Items:; - Control dependent poison UB; - Strict mode - (i.e. must analyze every operand); - Poison through memory; - Function ABIs; - Full coverage of intrinsics, etc.. (ouch). Instructions w/Unclear Semantics:; - shufflevector - It would seem reasonable for an out of bounds mask element; to produce poison, but the LangRef does not state.; - all binary ops w/vector operands - The likely interpretation would be that; any element overflowing should produce poison for the entire result, but; the LangRef does not state.; - Floating point binary ops w/fmf flags other than (nnan, noinfs). It seems; strange that only certian flags should be documented as producing poison. Cases of clear poison semantics not yet implemented:; - Exact flags on ashr/lshr produce poison; - NSW/NUW flags on shl produce poison; - Inbounds flag on getelementptr produce poison; - fptosi/fptoui (out of bounds input) produce poison; - Scalable vector types for insertelement/extractelement; - Floating point binary ops w/fmf nnan/noinfs flags produce poison; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PoisonChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PoisonChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/SanitizerBinaryMetadata.cpp:7,Security,Sanitiz,SanitizerBinaryMetadata,7,"//===- SanitizerBinaryMetadata.cpp - binary analysis sanitizers metadata --===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file is a part of SanitizerBinaryMetadata.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/SanitizerBinaryMetadata.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/SanitizerBinaryMetadata.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/SanitizerBinaryMetadata.cpp:53,Security,sanitiz,sanitizers,53,"//===- SanitizerBinaryMetadata.cpp - binary analysis sanitizers metadata --===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file is a part of SanitizerBinaryMetadata.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/SanitizerBinaryMetadata.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/SanitizerBinaryMetadata.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/SanitizerBinaryMetadata.cpp:406,Security,Sanitiz,SanitizerBinaryMetadata,406,"//===- SanitizerBinaryMetadata.cpp - binary analysis sanitizers metadata --===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file is a part of SanitizerBinaryMetadata.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/SanitizerBinaryMetadata.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/SanitizerBinaryMetadata.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/SanitizerBinaryMetadata.cpp:88,Usability,simpl,simply,88,"// The only instances of MetadataInfo are the constants above, so a set of; // them may simply store pointers to them. To deterministically generate code,; // we need to use a set with stable iteration order, such as SetVector.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/SanitizerBinaryMetadata.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/SanitizerBinaryMetadata.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/SanitizerBinaryMetadata.cpp:391,Security,Sanitiz,SanitizerBinaryMetadata,391,"// Determines which set of metadata to collect for this instruction.; //; // Returns true if covered metadata is required to unambiguously interpret; // other metadata. For example, if we are interested in atomics metadata, any; // function with memory operations (atomic or not) requires covered metadata; // to determine if a memory operation is atomic or not in modules compiled; // with SanitizerBinaryMetadata.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/SanitizerBinaryMetadata.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/SanitizerBinaryMetadata.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/SanitizerBinaryMetadata.cpp:22,Integrability,depend,dependent,22,// Returns the target-dependent section name.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/SanitizerBinaryMetadata.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/SanitizerBinaryMetadata.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/SanitizerBinaryMetadata.cpp:23,Security,access,access,23,"// Returns true if the access to the address should be considered ""atomic"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/SanitizerBinaryMetadata.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/SanitizerBinaryMetadata.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/SanitizerBinaryMetadata.cpp:177,Security,Sanitiz,SanitizerBinaryMetadata,177,"// Covered metadata is always emitted if explicitly requested, otherwise only; // if some other metadata requires it to unambiguously interpret it for; // modules compiled with SanitizerBinaryMetadata.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/SanitizerBinaryMetadata.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/SanitizerBinaryMetadata.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/SanitizerBinaryMetadata.cpp:15,Availability,mask,mask,15,// The feature mask will be placed after the function size.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/SanitizerBinaryMetadata.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/SanitizerBinaryMetadata.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/SanitizerBinaryMetadata.cpp:291,Modifiability,variab,variables,291,"// There are no intrinsic functions that leak arguments.; // If the called function does not return, the current function; // does not return as well, so no possibility of use-after-return.; // Sanitizer function also don't leak or don't return.; // It's safe to both pass pointers to local variables to them; // and to tail-call them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/SanitizerBinaryMetadata.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/SanitizerBinaryMetadata.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/SanitizerBinaryMetadata.cpp:255,Safety,safe,safe,255,"// There are no intrinsic functions that leak arguments.; // If the called function does not return, the current function; // does not return as well, so no possibility of use-after-return.; // Sanitizer function also don't leak or don't return.; // It's safe to both pass pointers to local variables to them; // and to tail-call them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/SanitizerBinaryMetadata.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/SanitizerBinaryMetadata.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/SanitizerBinaryMetadata.cpp:194,Security,Sanitiz,Sanitizer,194,"// There are no intrinsic functions that leak arguments.; // If the called function does not return, the current function; // does not return as well, so no possibility of use-after-return.; // Sanitizer function also don't leak or don't return.; // It's safe to both pass pointers to local variables to them; // and to tail-call them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/SanitizerBinaryMetadata.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/SanitizerBinaryMetadata.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/SanitizerBinaryMetadata.cpp:55,Safety,avoid,avoid,55,"// Some compiler-generated accesses are known racy, to avoid false positives; // in data-race analysis pretend they're atomic.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/SanitizerBinaryMetadata.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/SanitizerBinaryMetadata.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/SanitizerBinaryMetadata.cpp:27,Security,access,accesses,27,"// Some compiler-generated accesses are known racy, to avoid false positives; // in data-race analysis pretend they're atomic.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/SanitizerBinaryMetadata.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/SanitizerBinaryMetadata.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/SanitizerBinaryMetadata.cpp:141,Availability,error,errors,141,"// Use ExternalWeak so that if all sections are discarded due to section; // garbage collection, the linker will not report undefined symbol errors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/SanitizerBinaryMetadata.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/SanitizerBinaryMetadata.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/SanitizerCoverage.cpp:8,Security,Sanitiz,SanitizerCoverage,8,"//===-- SanitizerCoverage.cpp - coverage instrumentation for sanitizers ---===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Coverage instrumentation done on LLVM IR level, works with Sanitizers.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/SanitizerCoverage.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/SanitizerCoverage.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/SanitizerCoverage.cpp:61,Security,sanitiz,sanitizers,61,"//===-- SanitizerCoverage.cpp - coverage instrumentation for sanitizers ---===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Coverage instrumentation done on LLVM IR level, works with Sanitizers.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/SanitizerCoverage.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/SanitizerCoverage.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/SanitizerCoverage.cpp:442,Security,Sanitiz,Sanitizers,442,"//===-- SanitizerCoverage.cpp - coverage instrumentation for sanitizers ---===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Coverage instrumentation done on LLVM IR level, works with Sanitizers.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/SanitizerCoverage.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/SanitizerCoverage.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/SanitizerCoverage.cpp:31,Modifiability,variab,variable,31,"// If true, we create a global variable that contains PCs of all instrumented; // BBs, put this global into a named section, and pass this section's bounds; // to __sanitizer_cov_pcs_init.; // This way the coverage instrumentation does not need to acquire the PCs; // at run-time. Works with trace-pc-guard, inline-8bit-counters, and; // inline-bool-flag.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/SanitizerCoverage.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/SanitizerCoverage.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/SanitizerCoverage.cpp:142,Security,Sanitiz,Sanitizers,142,// GlobalsAA is considered stateless and does not get invalidated unless; // explicitly invalidated; PreservedAnalyses::none() is not enough. Sanitizers; // make changes that require GlobalsAA to be invalidated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/SanitizerCoverage.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/SanitizerCoverage.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/SanitizerCoverage.cpp:141,Availability,error,errors,141,"// Use ExternalWeak so that if all sections are discarded due to section; // garbage collection, the linker will not report undefined symbol errors.; // Windows defines the start/stop symbols in compiler-rt so no need for; // ExternalWeak.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/SanitizerCoverage.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/SanitizerCoverage.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/SanitizerCoverage.cpp:41,Modifiability,extend,extended,41,// Make sure smaller parameters are zero-extended to i64 if required by the; // target ABI.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/SanitizerCoverage.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/SanitizerCoverage.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/SanitizerCoverage.cpp:3,Performance,Load,Loads,3,// Loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/SanitizerCoverage.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/SanitizerCoverage.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/SanitizerCoverage.cpp:25,Security,sanitiz,sanitizer,25,// Should not instrument sanitizer init functions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/SanitizerCoverage.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/SanitizerCoverage.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/SanitizerCoverage.cpp:29,Deployability,configurat,configuration,29,// Don't instrument MSVC CRT configuration helpers. They may run before normal; // initialization.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/SanitizerCoverage.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/SanitizerCoverage.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/SanitizerCoverage.cpp:29,Modifiability,config,configuration,29,// Don't instrument MSVC CRT configuration helpers. They may run before normal; // initialization.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/SanitizerCoverage.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/SanitizerCoverage.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/SanitizerCoverage.cpp:55,Performance,Optimiz,Optimizers,55,"// sancov_pcs parallels the other metadata section(s). Optimizers (e.g.; // GlobalOpt/ConstantMerge) may not discard sancov_pcs and the other; // section(s) as a unit, so we conservatively retain all unconditionally in; // the compiler.; //; // With comdat (COFF/ELF), the linker can guarantee the associated sections; // will be retained or discarded as a unit, so llvm.compiler.used is; // sufficient. Otherwise, conservatively make all of them retained by the; // linker.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/SanitizerCoverage.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/SanitizerCoverage.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/SanitizerCoverage.cpp:142,Performance,cache,cache,142,"// On every indirect call we call a run-time function; // __sanitizer_cov_indir_call* with two parameters:; // - callee address,; // - global cache array that contains CacheSize pointers (zero-initialized).; // The cache is used to speed up recording the caller-callee pairs.; // The address of the caller is passed implicitly via caller PC.; // CacheSize is encoded in the name of the run-time function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/SanitizerCoverage.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/SanitizerCoverage.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/SanitizerCoverage.cpp:168,Performance,Cache,CacheSize,168,"// On every indirect call we call a run-time function; // __sanitizer_cov_indir_call* with two parameters:; // - callee address,; // - global cache array that contains CacheSize pointers (zero-initialized).; // The cache is used to speed up recording the caller-callee pairs.; // The address of the caller is passed implicitly via caller PC.; // CacheSize is encoded in the name of the run-time function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/SanitizerCoverage.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/SanitizerCoverage.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/SanitizerCoverage.cpp:215,Performance,cache,cache,215,"// On every indirect call we call a run-time function; // __sanitizer_cov_indir_call* with two parameters:; // - callee address,; // - global cache array that contains CacheSize pointers (zero-initialized).; // The cache is used to speed up recording the caller-callee pairs.; // The address of the caller is passed implicitly via caller PC.; // CacheSize is encoded in the name of the run-time function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/SanitizerCoverage.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/SanitizerCoverage.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/SanitizerCoverage.cpp:346,Performance,Cache,CacheSize,346,"// On every indirect call we call a run-time function; // __sanitizer_cov_indir_call* with two parameters:; // - callee address,; // - global cache array that contains CacheSize pointers (zero-initialized).; // The cache is used to speed up recording the caller-callee pairs.; // The address of the caller is passed implicitly via caller PC.; // CacheSize is encoded in the name of the run-time function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/SanitizerCoverage.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/SanitizerCoverage.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp:691,Performance,Optimiz,Optimizations,691,"//===-- ThreadSanitizer.cpp - race detector -------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file is a part of ThreadSanitizer, a race detector.; //; // The tool is under development, for the details about previous versions see; // http://code.google.com/p/data-race-test; //; // The instrumentation phase is quite simple:; // - Insert calls to run-time library before every memory access.; // - Optimizations may apply to avoid instrumenting some of the accesses.; // - Insert calls at function entry/exit.; // The rest is handled by the run-time library.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp:35,Safety,detect,detector,35,"//===-- ThreadSanitizer.cpp - race detector -------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file is a part of ThreadSanitizer, a race detector.; //; // The tool is under development, for the details about previous versions see; // http://code.google.com/p/data-race-test; //; // The instrumentation phase is quite simple:; // - Insert calls to run-time library before every memory access.; // - Optimizations may apply to avoid instrumenting some of the accesses.; // - Insert calls at function entry/exit.; // The rest is handled by the run-time library.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp:430,Safety,detect,detector,430,"//===-- ThreadSanitizer.cpp - race detector -------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file is a part of ThreadSanitizer, a race detector.; //; // The tool is under development, for the details about previous versions see; // http://code.google.com/p/data-race-test; //; // The instrumentation phase is quite simple:; // - Insert calls to run-time library before every memory access.; // - Optimizations may apply to avoid instrumenting some of the accesses.; // - Insert calls at function entry/exit.; // The rest is handled by the run-time library.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp:718,Safety,avoid,avoid,718,"//===-- ThreadSanitizer.cpp - race detector -------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file is a part of ThreadSanitizer, a race detector.; //; // The tool is under development, for the details about previous versions see; // http://code.google.com/p/data-race-test; //; // The instrumentation phase is quite simple:; // - Insert calls to run-time library before every memory access.; // - Optimizations may apply to avoid instrumenting some of the accesses.; // - Insert calls at function entry/exit.; // The rest is handled by the run-time library.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp:677,Security,access,access,677,"//===-- ThreadSanitizer.cpp - race detector -------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file is a part of ThreadSanitizer, a race detector.; //; // The tool is under development, for the details about previous versions see; // http://code.google.com/p/data-race-test; //; // The instrumentation phase is quite simple:; // - Insert calls to run-time library before every memory access.; // - Optimizations may apply to avoid instrumenting some of the accesses.; // - Insert calls at function entry/exit.; // The rest is handled by the run-time library.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp:750,Security,access,accesses,750,"//===-- ThreadSanitizer.cpp - race detector -------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file is a part of ThreadSanitizer, a race detector.; //; // The tool is under development, for the details about previous versions see; // http://code.google.com/p/data-race-test; //; // The instrumentation phase is quite simple:; // - Insert calls to run-time library before every memory access.; // - Optimizations may apply to avoid instrumenting some of the accesses.; // - Insert calls at function entry/exit.; // The rest is handled by the run-time library.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp:562,Testability,test,test,562,"//===-- ThreadSanitizer.cpp - race detector -------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file is a part of ThreadSanitizer, a race detector.; //; // The tool is under development, for the details about previous versions see; // http://code.google.com/p/data-race-test; //; // The instrumentation phase is quite simple:; // - Insert calls to run-time library before every memory access.; // - Optimizations may apply to avoid instrumenting some of the accesses.; // - Insert calls at function entry/exit.; // The rest is handled by the run-time library.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp:610,Usability,simpl,simple,610,"//===-- ThreadSanitizer.cpp - race detector -------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file is a part of ThreadSanitizer, a race detector.; //; // The tool is under development, for the details about previous versions see; // http://code.google.com/p/data-race-test; //; // The instrumentation phase is quite simple:; // - Insert calls to run-time library before every memory access.; // - Optimizations may apply to avoid instrumenting some of the accesses.; // - Insert calls at function entry/exit.; // The rest is handled by the run-time library.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp:24,Integrability,wrap,wrapper,24,// Internal Instruction wrapper that contains more information about the; // Instruction from prior analysis.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp:22,Energy Efficiency,power,powers,22,"// Accesses sizes are powers of two: 1, 2, 4, 8, 16.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp:3,Security,Access,Accesses,3,"// Accesses sizes are powers of two: 1, 2, 4, 8, 16.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp:21,Security,access,accesses,21,// Do not instrument accesses from different address spaces; we cannot deal; // with them.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp:52,Availability,redundant,redundant,52,"// Instrumenting some of the accesses may be proven redundant.; // Currently handled:; // - read-before-write (within same BB, no calls between); // - not captured variables; //; // We do not handle some of the patterns that should not survive; // after the classic compiler optimizations.; // E.g. two reads from the same temp should be eliminated by CSE,; // two writes should be eliminated by DSE, etc.; //; // 'Local' is a vector of insns within the same BB (no calls between).; // 'All' is a vector of insns that will be instrumented.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp:164,Modifiability,variab,variables,164,"// Instrumenting some of the accesses may be proven redundant.; // Currently handled:; // - read-before-write (within same BB, no calls between); // - not captured variables; //; // We do not handle some of the patterns that should not survive; // after the classic compiler optimizations.; // E.g. two reads from the same temp should be eliminated by CSE,; // two writes should be eliminated by DSE, etc.; //; // 'Local' is a vector of insns within the same BB (no calls between).; // 'All' is a vector of insns that will be instrumented.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp:275,Performance,optimiz,optimizations,275,"// Instrumenting some of the accesses may be proven redundant.; // Currently handled:; // - read-before-write (within same BB, no calls between); // - not captured variables; //; // We do not handle some of the patterns that should not survive; // after the classic compiler optimizations.; // E.g. two reads from the same temp should be eliminated by CSE,; // two writes should be eliminated by DSE, etc.; //; // 'Local' is a vector of insns within the same BB (no calls between).; // 'All' is a vector of insns that will be instrumented.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp:52,Safety,redund,redundant,52,"// Instrumenting some of the accesses may be proven redundant.; // Currently handled:; // - read-before-write (within same BB, no calls between); // - not captured variables; //; // We do not handle some of the patterns that should not survive; // after the classic compiler optimizations.; // E.g. two reads from the same temp should be eliminated by CSE,; // two writes should be eliminated by DSE, etc.; //; // 'Local' is a vector of insns within the same BB (no calls between).; // 'All' is a vector of insns that will be instrumented.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp:29,Security,access,accesses,29,"// Instrumenting some of the accesses may be proven redundant.; // Currently handled:; // - read-before-write (within same BB, no calls between); // - not captured variables; //; // We do not handle some of the patterns that should not survive; // after the classic compiler optimizations.; // E.g. two reads from the same temp should be eliminated by CSE,; // two writes should be eliminated by DSE, etc.; //; // 'Local' is a vector of insns within the same BB (no calls between).; // 'All' is a vector of insns that will be instrumented.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp:30,Security,access,accesses,30,"// If we distinguish volatile accesses and if either the read or write; // is volatile, do not omit any instrumentation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp:7,Modifiability,variab,variable,7,"// The variable is addressable but not captured, so it cannot be; // referenced from a different thread and participate in a data race; // (see llvm/Analysis/CaptureTracking.h for details).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp:25,Integrability,synchroniz,synchronization,25,// TODO: Ask TTI whether synchronization scope is between threads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp:38,Performance,load,loads,38,"// Traverse all instructions, collect loads/stores/returns, check for calls.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp:123,Modifiability,variab,variables,123,"// We have collected all loads and stores.; // FIXME: many of these accesses do not need to be checked for races; // (e.g. variables that do not escape, etc).; // Instrument memory accesses only if we want to report bugs in the function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp:25,Performance,load,loads,25,"// We have collected all loads and stores.; // FIXME: many of these accesses do not need to be checked for races; // (e.g. variables that do not escape, etc).; // Instrument memory accesses only if we want to report bugs in the function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp:68,Security,access,accesses,68,"// We have collected all loads and stores.; // FIXME: many of these accesses do not need to be checked for races; // (e.g. variables that do not escape, etc).; // Instrument memory accesses only if we want to report bugs in the function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp:181,Security,access,accesses,181,"// We have collected all loads and stores.; // FIXME: many of these accesses do not need to be checked for races; // (e.g. variables that do not escape, etc).; // Instrument memory accesses only if we want to report bugs in the function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp:84,Integrability,synchroniz,synchronization,84,// Instrument atomic memory accesses in any case (they can be used to; // implement synchronization).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp:28,Security,access,accesses,28,// Instrument atomic memory accesses in any case (they can be used to; // implement synchronization).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp:68,Security,access,accesses,68,// Instrument function entry/exit points if there were instrumented accesses.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp:541,Safety,avoid,avoid,541,"// If a memset intrinsic gets inlined by the code gen, we will miss races on it.; // So, we either need to ensure the intrinsic is not inlined, or instrument it.; // We do not instrument memset/memmove/memcpy intrinsics (too complicated),; // instead we simply replace them with regular function calls, which are then; // intercepted by the run-time.; // Since tsan is running after everyone else, the calls should not be; // replaced back with intrinsics. If that becomes wrong at some point,; // we will need to call e.g. __tsan_memset to avoid the intrinsics.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp:254,Usability,simpl,simply,254,"// If a memset intrinsic gets inlined by the code gen, we will miss races on it.; // So, we either need to ensure the intrinsic is not inlined, or instrument it.; // We do not instrument memset/memmove/memcpy intrinsics (too complicated),; // instead we simply replace them with regular function calls, which are then; // intercepted by the run-time.; // Since tsan is running after everyone else, the calls should not be; // replaced back with intrinsics. If that becomes wrong at some point,; // we will need to call e.g. __tsan_memset to avoid the intrinsics.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp:155,Availability,avail,available,155,"// Both llvm and ThreadSanitizer atomic operations are based on C++11/C1x; // standards. For background see C++11 standard. A slightly older, publicly; // available draft of the standard (not entirely up-to-date, but close enough; // for casual browsing) is available here:; // http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2011/n3242.pdf; // The following page contains more background information:; // http://www.hpl.hp.com/personal/Hans_Boehm/c++mm/",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp:258,Availability,avail,available,258,"// Both llvm and ThreadSanitizer atomic operations are based on C++11/C1x; // standards. For background see C++11 standard. A slightly older, publicly; // available draft of the standard (not entirely up-to-date, but close enough; // for casual browsing) is available here:; // http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2011/n3242.pdf; // The following page contains more background information:; // http://www.hpl.hp.com/personal/Hans_Boehm/c++mm/",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ValueProfileCollector.cpp:6,Modifiability,plugin,plugin-based,6,"/// A plugin-based class that takes an arbitrary number of Plugin types.; /// Each plugin type must satisfy the following API:; /// 1) the constructor must take a `Function &f`. Typically, the plugin would; /// scan the function looking for candidates.; /// 2) contain a member function with the following signature and name:; /// void run(std::vector<CandidateInfo> &Candidates);; /// such that the plugin would append its result into the vector parameter.; ///; /// Plugins are defined in ValueProfilePlugins.inc",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ValueProfileCollector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ValueProfileCollector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ValueProfileCollector.cpp:59,Modifiability,Plugin,Plugin,59,"/// A plugin-based class that takes an arbitrary number of Plugin types.; /// Each plugin type must satisfy the following API:; /// 1) the constructor must take a `Function &f`. Typically, the plugin would; /// scan the function looking for candidates.; /// 2) contain a member function with the following signature and name:; /// void run(std::vector<CandidateInfo> &Candidates);; /// such that the plugin would append its result into the vector parameter.; ///; /// Plugins are defined in ValueProfilePlugins.inc",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ValueProfileCollector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ValueProfileCollector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ValueProfileCollector.cpp:83,Modifiability,plugin,plugin,83,"/// A plugin-based class that takes an arbitrary number of Plugin types.; /// Each plugin type must satisfy the following API:; /// 1) the constructor must take a `Function &f`. Typically, the plugin would; /// scan the function looking for candidates.; /// 2) contain a member function with the following signature and name:; /// void run(std::vector<CandidateInfo> &Candidates);; /// such that the plugin would append its result into the vector parameter.; ///; /// Plugins are defined in ValueProfilePlugins.inc",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ValueProfileCollector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ValueProfileCollector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ValueProfileCollector.cpp:193,Modifiability,plugin,plugin,193,"/// A plugin-based class that takes an arbitrary number of Plugin types.; /// Each plugin type must satisfy the following API:; /// 1) the constructor must take a `Function &f`. Typically, the plugin would; /// scan the function looking for candidates.; /// 2) contain a member function with the following signature and name:; /// void run(std::vector<CandidateInfo> &Candidates);; /// such that the plugin would append its result into the vector parameter.; ///; /// Plugins are defined in ValueProfilePlugins.inc",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ValueProfileCollector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ValueProfileCollector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ValueProfileCollector.cpp:400,Modifiability,plugin,plugin,400,"/// A plugin-based class that takes an arbitrary number of Plugin types.; /// Each plugin type must satisfy the following API:; /// 1) the constructor must take a `Function &f`. Typically, the plugin would; /// scan the function looking for candidates.; /// 2) contain a member function with the following signature and name:; /// void run(std::vector<CandidateInfo> &Candidates);; /// such that the plugin would append its result into the vector parameter.; ///; /// Plugins are defined in ValueProfilePlugins.inc",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ValueProfileCollector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ValueProfileCollector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ValueProfileCollector.cpp:468,Modifiability,Plugin,Plugins,468,"/// A plugin-based class that takes an arbitrary number of Plugin types.; /// Each plugin type must satisfy the following API:; /// 1) the constructor must take a `Function &f`. Typically, the plugin would; /// scan the function looking for candidates.; /// 2) contain a member function with the following signature and name:; /// void run(std::vector<CandidateInfo> &Candidates);; /// such that the plugin would append its result into the vector parameter.; ///; /// Plugins are defined in ValueProfilePlugins.inc",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ValueProfileCollector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ValueProfileCollector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ValueProfileCollector.cpp:13,Modifiability,Plugin,PluginChainFinal,13,/// The type PluginChainFinal is the final chain of plugins that will be used by; /// ValueProfileCollectorImpl.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ValueProfileCollector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ValueProfileCollector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ValueProfileCollector.cpp:52,Modifiability,plugin,plugins,52,/// The type PluginChainFinal is the final chain of plugins that will be used by; /// ValueProfileCollectorImpl.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ValueProfileCollector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ValueProfileCollector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ValueProfileCollector.cpp:58,Modifiability,inherit,inherits,58,// end anonymous namespace; /// ValueProfileCollectorImpl inherits the API of PluginChainFinal.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ValueProfileCollector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ValueProfileCollector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ValueProfileCollector.cpp:78,Modifiability,Plugin,PluginChainFinal,78,// end anonymous namespace; /// ValueProfileCollectorImpl inherits the API of PluginChainFinal.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ValueProfileCollector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ValueProfileCollector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ValueProfileCollector.h:1182,Modifiability,plugin,plugin,1182,"/// Utility analysis that determines what values are worth profiling.; /// The actual logic is inside the ValueProfileCollectorImpl, whose job is to; /// populate the Candidates vector.; ///; /// Value profiling an expression means to track the values that this expression; /// takes at runtime and the frequency of each value.; /// It is important to distinguish between two sets of value profiles for a; /// particular expression:; /// 1) The set of values at the point of evaluation.; /// 2) The set of values at the point of use.; /// In some cases, the two sets are identical, but it's not unusual for the two; /// to differ.; ///; /// To elaborate more, consider this C code, and focus on the expression `nn`:; /// void foo(int nn, bool b) {; /// if (b) memcpy(x, y, nn);; /// }; /// The point of evaluation can be as early as the start of the function, and; /// let's say the value profile for `nn` is:; /// total=100; (value,freq) set = {(8,10), (32,50)}; /// The point of use is right before we call memcpy, and since we execute the; /// memcpy conditionally, the value profile of `nn` can be:; /// total=15; (value,freq) set = {(8,10), (4,5)}; ///; /// For this reason, a plugin is responsible for computing the insertion point; /// for each value to be profiled. The `CandidateInfo` structure encapsulates; /// all the information needed for each value profile site.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ValueProfileCollector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ValueProfileCollector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ValueProfileCollector.h:86,Testability,log,logic,86,"/// Utility analysis that determines what values are worth profiling.; /// The actual logic is inside the ValueProfileCollectorImpl, whose job is to; /// populate the Candidates vector.; ///; /// Value profiling an expression means to track the values that this expression; /// takes at runtime and the frequency of each value.; /// It is important to distinguish between two sets of value profiles for a; /// particular expression:; /// 1) The set of values at the point of evaluation.; /// 2) The set of values at the point of use.; /// In some cases, the two sets are identical, but it's not unusual for the two; /// to differ.; ///; /// To elaborate more, consider this C code, and focus on the expression `nn`:; /// void foo(int nn, bool b) {; /// if (b) memcpy(x, y, nn);; /// }; /// The point of evaluation can be as early as the start of the function, and; /// let's say the value profile for `nn` is:; /// total=100; (value,freq) set = {(8,10), (32,50)}; /// The point of use is right before we call memcpy, and since we execute the; /// memcpy conditionally, the value profile of `nn` can be:; /// total=15; (value,freq) set = {(8,10), (4,5)}; ///; /// For this reason, a plugin is responsible for computing the insertion point; /// for each value to be profiled. The `CandidateInfo` structure encapsulates; /// all the information needed for each value profile site.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ValueProfileCollector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ValueProfileCollector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AlwaysInliner.cpp:65,Safety,avoid,avoids,65,// Remember to try and delete this function afterward. This both avoids; // re-walking the rest of the module and avoids dealing with any; // iterator invalidation issues while deleting functions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AlwaysInliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AlwaysInliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AlwaysInliner.cpp:114,Safety,avoid,avoids,114,// Remember to try and delete this function afterward. This both avoids; // re-walking the rest of the module and avoids dealing with any; // iterator invalidation issues while deleting functions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AlwaysInliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AlwaysInliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AlwaysInliner.cpp:13,Integrability,interface,interface,13,/// Main run interface method. We override here to avoid calling skipSCC().,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AlwaysInliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AlwaysInliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AlwaysInliner.cpp:51,Safety,avoid,avoid,51,/// Main run interface method. We override here to avoid calling skipSCC().,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AlwaysInliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AlwaysInliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp:1271,Modifiability,config,configured,1271,"//===- ArgumentPromotion.cpp - Promote by-reference arguments -------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass promotes ""by reference"" arguments to be ""by value"" arguments. In; // practice, this means looking for internal functions that have pointer; // arguments. If it can prove, through the use of alias analysis, that an; // argument is *only* loaded, then it can pass the value into the function; // instead of the address of the value. This can cause recursive simplification; // of code and lead to the elimination of allocas (especially in C++ template; // code like the STL).; //; // This pass also handles aggregate arguments that are passed into a function,; // scalarizing them if the elements of the aggregate are only loaded. Note that; // by default it refuses to scalarize aggregates which would require passing in; // more than three operands to the function, because passing thousands of; // operands for a large array or structure is unprofitable! This limit can be; // configured or disabled, however.; //; // Note that this transformation could also be done for arguments that are only; // stored to (returning the value instead), but does not currently. This case; // would be best handled when and if LLVM begins supporting multiple return; // values from functions.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp:630,Performance,load,loaded,630,"//===- ArgumentPromotion.cpp - Promote by-reference arguments -------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass promotes ""by reference"" arguments to be ""by value"" arguments. In; // practice, this means looking for internal functions that have pointer; // arguments. If it can prove, through the use of alias analysis, that an; // argument is *only* loaded, then it can pass the value into the function; // instead of the address of the value. This can cause recursive simplification; // of code and lead to the elimination of allocas (especially in C++ template; // code like the STL).; //; // This pass also handles aggregate arguments that are passed into a function,; // scalarizing them if the elements of the aggregate are only loaded. Note that; // by default it refuses to scalarize aggregates which would require passing in; // more than three operands to the function, because passing thousands of; // operands for a large array or structure is unprofitable! This limit can be; // configured or disabled, however.; //; // Note that this transformation could also be done for arguments that are only; // stored to (returning the value instead), but does not currently. This case; // would be best handled when and if LLVM begins supporting multiple return; // values from functions.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp:1014,Performance,load,loaded,1014,"//===- ArgumentPromotion.cpp - Promote by-reference arguments -------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass promotes ""by reference"" arguments to be ""by value"" arguments. In; // practice, this means looking for internal functions that have pointer; // arguments. If it can prove, through the use of alias analysis, that an; // argument is *only* loaded, then it can pass the value into the function; // instead of the address of the value. This can cause recursive simplification; // of code and lead to the elimination of allocas (especially in C++ template; // code like the STL).; //; // This pass also handles aggregate arguments that are passed into a function,; // scalarizing them if the elements of the aggregate are only loaded. Note that; // by default it refuses to scalarize aggregates which would require passing in; // more than three operands to the function, because passing thousands of; // operands for a large array or structure is unprofitable! This limit can be; // configured or disabled, however.; //; // Note that this transformation could also be done for arguments that are only; // stored to (returning the value instead), but does not currently. This case; // would be best handled when and if LLVM begins supporting multiple return; // values from functions.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp:749,Usability,simpl,simplification,749,"//===- ArgumentPromotion.cpp - Promote by-reference arguments -------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass promotes ""by reference"" arguments to be ""by value"" arguments. In; // practice, this means looking for internal functions that have pointer; // arguments. If it can prove, through the use of alias analysis, that an; // argument is *only* loaded, then it can pass the value into the function; // instead of the address of the value. This can cause recursive simplification; // of code and lead to the elimination of allocas (especially in C++ template; // code like the STL).; //; // This pass also handles aggregate arguments that are passed into a function,; // scalarizing them if the elements of the aggregate are only loaded. Note that; // by default it refuses to scalarize aggregates which would require passing in; // more than three operands to the function, because passing thousands of; // operands for a large array or structure is unprofitable! This limit can be; // configured or disabled, however.; //; // Note that this transformation could also be done for arguments that are only; // stored to (returning the value instead), but does not currently. This case; // would be best handled when and if LLVM begins supporting multiple return; // values from functions.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp:41,Performance,load,load,41,/// A representative guaranteed-executed load or store instruction for use by; /// metadata transfer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp:39,Performance,perform,performs,39,"/// DoPromotion - This method actually performs the promotion of the specified; /// arguments, and returns the new function. At this point, we know that it's; /// safe to do so.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp:163,Safety,safe,safe,163,"/// DoPromotion - This method actually performs the promotion of the specified; /// arguments, and returns the new function. At this point, we know that it's; /// safe to do so.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp:93,Performance,load,loaded,93,"// Loop over all the callers of the function, transforming the call sites to; // pass in the loaded pointers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp:45,Performance,load,loads,45,"// Loop over the operands, inserting GEP and loads in the caller as; // appropriate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp:155,Performance,load,loads,155,"// Only transfer poison-generating metadata if we also have; // !noundef.; // TODO: Without !noundef, we could merge this metadata across; // all promoted loads.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp:118,Performance,load,loads,118,// Cleanup the code from the dead instructions: GEPs and BitCasts in between; // the original argument and its users: loads and stores. Retarget every; // user to the new created alloca.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp:36,Safety,safe,safe,36,"/// Determine that this argument is safe to promote, and find the argument; /// parts it can be promoted into.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp:57,Performance,load,loads,57,"// We can only promote this argument if all the uses are loads at known; // offsets.; //; // Promoting the argument causes it to be loaded in the caller; // unconditionally. This is only safe if we can prove that either the load; // would have happened in the callee anyway (ie, there is a load in the entry; // block) or the pointer passed in at every call site is guaranteed to be; // valid.; // In the former case, invalid loads can happen, but would have happened; // anyway, in the latter case, invalid loads won't happen. This prevents us; // from introducing an invalid load that wouldn't have happened in the; // original code.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp:132,Performance,load,loaded,132,"// We can only promote this argument if all the uses are loads at known; // offsets.; //; // Promoting the argument causes it to be loaded in the caller; // unconditionally. This is only safe if we can prove that either the load; // would have happened in the callee anyway (ie, there is a load in the entry; // block) or the pointer passed in at every call site is guaranteed to be; // valid.; // In the former case, invalid loads can happen, but would have happened; // anyway, in the latter case, invalid loads won't happen. This prevents us; // from introducing an invalid load that wouldn't have happened in the; // original code.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp:224,Performance,load,load,224,"// We can only promote this argument if all the uses are loads at known; // offsets.; //; // Promoting the argument causes it to be loaded in the caller; // unconditionally. This is only safe if we can prove that either the load; // would have happened in the callee anyway (ie, there is a load in the entry; // block) or the pointer passed in at every call site is guaranteed to be; // valid.; // In the former case, invalid loads can happen, but would have happened; // anyway, in the latter case, invalid loads won't happen. This prevents us; // from introducing an invalid load that wouldn't have happened in the; // original code.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp:290,Performance,load,load,290,"// We can only promote this argument if all the uses are loads at known; // offsets.; //; // Promoting the argument causes it to be loaded in the caller; // unconditionally. This is only safe if we can prove that either the load; // would have happened in the callee anyway (ie, there is a load in the entry; // block) or the pointer passed in at every call site is guaranteed to be; // valid.; // In the former case, invalid loads can happen, but would have happened; // anyway, in the latter case, invalid loads won't happen. This prevents us; // from introducing an invalid load that wouldn't have happened in the; // original code.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp:426,Performance,load,loads,426,"// We can only promote this argument if all the uses are loads at known; // offsets.; //; // Promoting the argument causes it to be loaded in the caller; // unconditionally. This is only safe if we can prove that either the load; // would have happened in the callee anyway (ie, there is a load in the entry; // block) or the pointer passed in at every call site is guaranteed to be; // valid.; // In the former case, invalid loads can happen, but would have happened; // anyway, in the latter case, invalid loads won't happen. This prevents us; // from introducing an invalid load that wouldn't have happened in the; // original code.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp:508,Performance,load,loads,508,"// We can only promote this argument if all the uses are loads at known; // offsets.; //; // Promoting the argument causes it to be loaded in the caller; // unconditionally. This is only safe if we can prove that either the load; // would have happened in the callee anyway (ie, there is a load in the entry; // block) or the pointer passed in at every call site is guaranteed to be; // valid.; // In the former case, invalid loads can happen, but would have happened; // anyway, in the latter case, invalid loads won't happen. This prevents us; // from introducing an invalid load that wouldn't have happened in the; // original code.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp:577,Performance,load,load,577,"// We can only promote this argument if all the uses are loads at known; // offsets.; //; // Promoting the argument causes it to be loaded in the caller; // unconditionally. This is only safe if we can prove that either the load; // would have happened in the callee anyway (ie, there is a load in the entry; // block) or the pointer passed in at every call site is guaranteed to be; // valid.; // In the former case, invalid loads can happen, but would have happened; // anyway, in the latter case, invalid loads won't happen. This prevents us; // from introducing an invalid load that wouldn't have happened in the; // original code.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp:187,Safety,safe,safe,187,"// We can only promote this argument if all the uses are loads at known; // offsets.; //; // Promoting the argument causes it to be loaded in the caller; // unconditionally. This is only safe if we can prove that either the load; // would have happened in the callee anyway (ie, there is a load in the entry; // block) or the pointer passed in at every call site is guaranteed to be; // valid.; // In the former case, invalid loads can happen, but would have happened; // anyway, in the latter case, invalid loads won't happen. This prevents us; // from introducing an invalid load that wouldn't have happened in the; // original code.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp:42,Performance,load,load,42,"// An end user of a pointer argument is a load or store instruction.; // Returns std::nullopt if this load or store is not based on the argument.; // Return true if we can promote the instruction, false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp:102,Performance,load,load,102,"// An end user of a pointer argument is a load or store instruction.; // Returns std::nullopt if this load or store is not based on the argument.; // Return true if we can promote the instruction, false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp:24,Performance,scalab,scalable,24,// Don't try to promote scalable types.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp:28,Performance,load,loading,28,"// For now, we only support loading/storing one specific type at a given; // offset.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp:79,Performance,load,load,79,"// If this instruction is not guaranteed to execute, and we haven't seen a; // load or store at this offset before (or it had lower alignment), then we; // need to remember that requirement.; // Note that skipping instructions of previously seen offsets is only; // correct because we only allow a single type for a given offset, which; // also means that the number of accessed bytes will be the same.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp:370,Security,access,accessed,370,"// If this instruction is not guaranteed to execute, and we haven't seen a; // load or store at this offset before (or it had lower alignment), then we; // need to remember that requirement.; // Note that skipping instructions of previously seen offsets is only; // correct because we only allow a single type for a given offset, which; // also means that the number of accessed bytes will be the same.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp:12,Performance,load,loads,12,// Look for loads and stores that are guaranteed to execute on entry.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp:19,Performance,load,loads,19,// Now look at all loads of the argument. Remember the load instructions; // for the aliasing check below.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp:55,Performance,load,load,55,// Now look at all loads of the argument. Remember the load instructions; // for the aliasing check below.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp:90,Performance,load,load,90,"// If store instructions are allowed, the path from the entry of the function; // to each load may be not free of instructions that potentially invalidate; // the load, and this is an admissible situation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp:163,Performance,load,load,163,"// If store instructions are allowed, the path from the entry of the function; // to each load may be not free of instructions that potentially invalidate; // the load, and this is an admissible situation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp:55,Performance,load,load,55,"// Okay, now we know that the argument is only used by load instructions, and; // it is safe to unconditionally perform all of them. Use alias analysis to; // check to see if the pointer is guaranteed to not be modified from entry of; // the function to each of the load instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp:112,Performance,perform,perform,112,"// Okay, now we know that the argument is only used by load instructions, and; // it is safe to unconditionally perform all of them. Use alias analysis to; // check to see if the pointer is guaranteed to not be modified from entry of; // the function to each of the load instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp:266,Performance,load,load,266,"// Okay, now we know that the argument is only used by load instructions, and; // it is safe to unconditionally perform all of them. Use alias analysis to; // check to see if the pointer is guaranteed to not be modified from entry of; // the function to each of the load instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp:88,Safety,safe,safe,88,"// Okay, now we know that the argument is only used by load instructions, and; // it is safe to unconditionally perform all of them. Use alias analysis to; // check to see if the pointer is guaranteed to not be modified from entry of; // the function to each of the load instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp:23,Performance,load,load,23,// Check to see if the load is invalidated from the start of the block to; // the load itself.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp:82,Performance,load,load,82,// Check to see if the load is invalidated from the start of the block to; // the load itself.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp:80,Performance,load,load,80,"// Pointer is invalidated!; // Now check every path from the entry block to the load for transparency.; // To do this, we perform a depth first search on the inverse CFG from the; // loading block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp:122,Performance,perform,perform,122,"// Pointer is invalidated!; // Now check every path from the entry block to the load for transparency.; // To do this, we perform a depth first search on the inverse CFG from the; // loading block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp:183,Performance,load,loading,183,"// Pointer is invalidated!; // Now check every path from the entry block to the load for transparency.; // To do this, we perform a depth first search on the inverse CFG from the; // loading block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp:54,Performance,load,load,54,"// If the path from the entry of the function to each load is free of; // instructions that potentially invalidate the load, we can make the; // transformation!",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp:119,Performance,load,load,119,"// If the path from the entry of the function to each load is free of; // instructions that potentially invalidate the load, we can make the; // transformation!",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp:128,Safety,safe,safe,128,"/// PromoteArguments - This method checks the specified function to see if there; /// are any promotable arguments and if it is safe to promote the function (for; /// example, all callers are direct). If safe to promote some arguments, it; /// calls the DoPromotion method.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp:204,Safety,safe,safe,204,"/// PromoteArguments - This method checks the specified function to see if there; /// are any promotable arguments and if it is safe to promote the function (for; /// example, all callers are direct). If safe to promote some arguments, it; /// calls the DoPromotion method.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp:9,Performance,perform,perform,9,// Don't perform argument promotion for naked functions; otherwise we can end; // up removing parameters that are seemingly 'not used' as they are referred; // to in the assembly.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp:95,Integrability,depend,depending,95,"// Don't transform functions that receive inallocas, as the transformation may; // not be safe depending on calling convention.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp:90,Safety,safe,safe,90,"// Don't transform functions that receive inallocas, as the transformation may; // not be safe depending on calling convention.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp:45,Energy Efficiency,reduce,reduces,45,// Replace sret attribute with noalias. This reduces register pressure by; // avoiding a register copy.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp:78,Safety,avoid,avoiding,78,// Replace sret attribute with noalias. This reduces register pressure by; // avoiding a register copy.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp:194,Deployability,update,updates,194,"// Directly substitute the functions in the call graph. Note that this; // requires the old function to be completely dead and completely; // replaced by the new function. It does no call graph updates, it merely; // swaps out the particular function mapped to a particular node in the; // graph.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp:9,Usability,clear,cleared,9,// We've cleared out analyses for deleted functions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp:389,Availability,down,down,389,"// TODO: Determine a good default value.; //; // In the LLVM-TS and SPEC2006, 32 seems to not induce compile time overheads; // (when run with the first 5 abstract attributes). The results also indicate; // that we never reach 32 iterations but always find a fixpoint sooner.; //; // This will become more evolved once we perform two interleaved fixpoint; // iterations: bottom-up and top-down.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp:306,Modifiability,evolve,evolved,306,"// TODO: Determine a good default value.; //; // In the LLVM-TS and SPEC2006, 32 seems to not induce compile time overheads; // (when run with the first 5 abstract attributes). The results also indicate; // that we never reach 32 iterations but always find a fixpoint sooner.; //; // This will become more evolved once we perform two interleaved fixpoint; // iterations: bottom-up and top-down.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp:322,Performance,perform,perform,322,"// TODO: Determine a good default value.; //; // In the LLVM-TS and SPEC2006, 32 seems to not induce compile time overheads; // (when run with the first 5 abstract attributes). The results also indicate; // that we never reach 32 iterations but always find a fixpoint sooner.; //; // This will become more evolved once we perform two interleaved fixpoint; // iterations: bottom-up and top-down.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp:4,Testability,Log,Logic,4,/// Logic operators for the change status enum class.; ///; ///{,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp:157,Integrability,depend,dependences,157,// Containers to remember the pointer infos and new copies while we are not; // sure that we can find all of them. If we abort we want to avoid spurious; // dependences and potential copies in the provided container.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp:121,Safety,abort,abort,121,// Containers to remember the pointer infos and new copies while we are not; // sure that we can find all of them. If we abort we want to avoid spurious; // dependences and potential copies in the provided container.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp:138,Safety,avoid,avoid,138,// Containers to remember the pointer infos and new copies while we are not; // sure that we can find all of them. If we abort we want to avoid spurious; // dependences and potential copies in the provided container.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp:99,Performance,optimiz,optimize,99,// A null pointer access can be undefined but any offset from null may; // be OK. We do not try to optimize the latter.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp:18,Security,access,access,18,// A null pointer access can be undefined but any offset from null may; // be OK. We do not try to optimize the latter.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp:76,Integrability,depend,dependences,76,// Only if we were successful collection all potential copies we record; // dependences (on non-fix AAPointerInfo AAs). We also only then modify the; // given PotentialCopies container.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp:348,Safety,avoid,avoid,348,"// We know kernels (generally) cannot be called from within the module. Thus,; // for reachability we would need to step back from a kernel which would allow; // us to reach anything anyway. Even if a kernel is invoked from another; // kernel, values like allocas and shared memory are not accessible. We; // implicitly check for this situation to avoid costly lookups.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp:290,Security,access,accessible,290,"// We know kernels (generally) cannot be called from within the module. Thus,; // for reachability we would need to step back from a kernel which would allow; // us to reach anything anyway. Even if a kernel is invoked from another; // kernel, values like allocas and shared memory are not accessible. We; // implicitly check for this situation to avoid costly lookups.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp:261,Performance,perform,perform,261,"// If we can go arbitrarily backwards we will eventually reach an entry point; // that can reach ToI. Only if a set of blocks through which we cannot go is; // provided, or once we track internal functions not accessible from the; // outside, it makes sense to perform backwards analysis in the absence of a; // GoBackwardsCB.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp:210,Security,access,accessible,210,"// If we can go arbitrarily backwards we will eventually reach an entry point; // that can reach ToI. Only if a set of blocks through which we cannot go is; // provided, or once we track internal functions not accessible from the; // outside, it makes sense to perform backwards analysis in the absence of a; // GoBackwardsCB.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp:3,Testability,Test,Test,3,// Test if the underlying call site operand is argument number u of the; // callback callee.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp:128,Availability,avail,available,128,"// If no callbacks were found, or none used the underlying call site operand; // exclusively, use the direct callee argument if available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp:18,Modifiability,variab,variable,18,// Silence unused variable warning.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp:179,Usability,simpl,simplified,179,"// First check all callbacks provided by outside AAs. If any of them returns; // a non-null value that is different from the associated value, or; // std::nullopt, we assume it's simplified.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp:179,Usability,simpl,simplified,179,"// First check all callbacks provided by outside AAs. If any of them returns; // a non-null value that is different from the associated value, or; // std::nullopt, we assume it's simplified.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp:179,Usability,simpl,simplified,179,"// First check all callbacks provided by outside AAs. If any of them returns; // a non-null value that is different from the associated value, or; // std::nullopt, we assume it's simplified.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp:28,Usability,simpl,simplification,28,"// If no high-level/outside simplification occurred, use; // AAPotentialValues.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp:31,Energy Efficiency,allocate,allocated,31,"// The abstract attributes are allocated via the BumpPtrAllocator Allocator,; // thus we cannot delete them. We can, and want to, destruct them though.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp:20,Performance,cache,cache,20,// TODO: Maintain a cache of Values that are; // on the pathway from a Argument to a Instruction that would effect the; // liveness/return state etc.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp:165,Deployability,update,updates,165,"// For invalid AAs we can fix dependent AAs that have a required dependence,; // thereby folding long dependence chains in a single step without the need; // to run updates.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp:30,Integrability,depend,dependent,30,"// For invalid AAs we can fix dependent AAs that have a required dependence,; // thereby folding long dependence chains in a single step without the need; // to run updates.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp:65,Integrability,depend,dependence,65,"// For invalid AAs we can fix dependent AAs that have a required dependence,; // thereby folding long dependence chains in a single step without the need; // to run updates.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp:102,Integrability,depend,dependence,102,"// For invalid AAs we can fix dependent AAs that have a required dependence,; // thereby folding long dependence chains in a single step without the need; // to run updates.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp:13,Integrability,depend,dependences,13,// Check the dependences to fast track invalidation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp:52,Integrability,depend,dependent,52,// Add all abstract attributes that are potentially dependent on one that; // changed to the work list.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp:3,Deployability,Update,Update,3,// Update all abstract attribute in the work list and record the ones that; // changed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp:97,Deployability,update,updates,97,// Use the InvalidAAs vector to propagate invalid states fast transitively; // without requiring updates.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp:90,Integrability,depend,dependent,90,// Reset the work list and repopulate with the changed abstract attributes.; // Note that dependent ones are added above.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp:207,Integrability,depend,depending,207,"// Reset abstract arguments not settled in a sound fixpoint by now. This; // happens when we stopped the fixpoint iteration early. Note that only the; // ones marked as ""changed"" *and* the ones transitively depending on them; // need to be reverted to a pessimistic state. Others might not be in a; // fixpoint state but we can use the optimistic results for them anyway.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp:193,Integrability,depend,dependent,193,"// If there is not already a fixpoint reached, we can now take the; // optimistic state. This is correct because we enforced a pessimistic one; // on abstract attributes that were transitively dependent on a changed one; // already above.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp:6,Safety,avoid,avoid,6,// To avoid triggering an assertion in the lazy call graph we will not delete; // any internal library functions. We should modify the assertion though and; // allow internals to be deleted.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp:26,Testability,assert,assertion,26,// To avoid triggering an assertion in the lazy call graph we will not delete; // any internal library functions. We should modify the assertion though and; // allow internals to be deleted.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp:135,Testability,assert,assertion,135,// To avoid triggering an assertion in the lazy call graph we will not delete; // any internal library functions. We should modify the assertion though and; // allow internals to be deleted.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp:30,Safety,avoid,avoid,30,// Delete stuff at the end to avoid invalid references and a nice order.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp:41,Deployability,update,update,41,// If we plan to replace NewV we need to update it at this point.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp:9,Modifiability,rewrite,rewrite,9,"// If we rewrite a return and the new value is not an argument, strip the; // `returned` attribute as it is wrong now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp:3,Modifiability,Rewrite,Rewrite,3,// Rewrite the functions as requested during manifest.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp:40,Deployability,update,update,40,// Use a new dependence vector for this update.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp:13,Integrability,depend,dependence,13,// Use a new dependence vector for this update.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp:58,Integrability,depend,dependence,58,"// Verify the stack was used properly, that is we pop the dependence vector we; // put there earlier.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp:34,Integrability,wrap,wrapper,34,// Move the COMDAT section to the wrapper.; // TODO: Check if we need to keep it for F as well.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp:26,Integrability,wrap,wrapper,26,// Create the call in the wrapper.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp:76,Modifiability,rewrite,rewrite,76,// Forbid the call site to cast the function return type. If we need to; // rewrite these functions we need to re-create a cast for the new call site; // (if the old had uses).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp:3,Safety,Avoid,Avoid,3,// Avoid var-arg functions for now.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp:3,Safety,Avoid,Avoid,3,// Avoid functions with complicated argument passing semantics.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp:3,Safety,Avoid,Avoid,3,// Avoid callbacks for now.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp:36,Modifiability,rewrite,rewrites,36,// Deleted functions do not require rewrites.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp:3,Deployability,Patch,Patch,3,// Patch the pointer to LLVM function in debug info descriptor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp:20,Testability,assert,assert,20,// only used inside assert.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp:44,Availability,repair,repair,44,// TODO: Exose the attribute set to the ACS repair callback,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp:160,Performance,cache,cache,160,"// As we do not modify the function here we can remove the const; // withouth breaking implicit assumptions. At the end of the day, we could; // initialize the cache eagerly which would look the same to the users.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp:138,Deployability,update,update,138,// Walk all instructions to find interesting instructions that might be; // queried by abstract attributes during their initialization or update.; // This has to happen before we create attributes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp:184,Performance,cache,cache,184,// To allow easy access to all instructions in a function with a given; // opcode we store them in the InfoCache. As not all opcodes are interesting; // to concrete attributes we only cache the ones that are as identified in; // the following switch.; // Note: There are no concrete attributes now so this is initially empty.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp:17,Security,access,access,17,// To allow easy access to all instructions in a function with a given; // opcode we store them in the InfoCache. As not all opcodes are interesting; // to concrete attributes we only cache the ones that are as identified in; // the following switch.; // Note: There are no concrete attributes now so this is initially empty.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp:49,Performance,load,loads,49,// The alignment of a pointer is interesting for loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp:31,Energy Efficiency,allocate,allocated,31,"// The instruction vectors are allocated using a BumpPtrAllocator, we need to; // manually destroy them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp:27,Deployability,update,update,27,"// If we are outside of an update, thus before the actual fixpoint iteration; // started (= when we create AAs), we do not track dependences because we will; // put all AAs into the initial worklist anyway.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp:129,Integrability,depend,dependences,129,"// If we are outside of an update, thus before the actual fixpoint iteration; // started (= when we create AAs), we do not track dependences because we will; // put all AAs into the initial worklist anyway.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp:78,Safety,detect,detection,78,// Check for dead BasicBlocks in every function.; // We need dead instruction detection because we do not want to deal with; // broken IR in which SSA rules do not apply.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp:27,Usability,simpl,simplified,27,// Every function might be simplified.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp:80,Integrability,interface,interface,80,// Every argument might be simplified. We have to go through the; // Attributor interface though as outside AAs can register custom; // simplification callbacks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp:27,Usability,simpl,simplified,27,// Every argument might be simplified. We have to go through the; // Attributor interface though as outside AAs can register custom; // simplification callbacks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp:136,Usability,simpl,simplification,136,// Every argument might be simplified. We have to go through the; // Attributor interface though as outside AAs can register custom; // simplification callbacks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp:65,Usability,simpl,simplify,65,// TODO: Even if the callee is not known now we might be able to simplify; // the call/callee.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp:84,Integrability,interface,interface,84,// Call site argument might be simplified. We have to go through the; // Attributor interface though as outside AAs can register custom; // simplification callbacks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp:31,Usability,simpl,simplified,31,// Call site argument might be simplified. We have to go through the; // Attributor interface though as outside AAs can register custom; // simplification callbacks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp:140,Usability,simpl,simplification,140,// Call site argument might be simplified. We have to go through the; // Attributor interface though as outside AAs can register custom; // simplification callbacks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp:56,Performance,cache,cache,56,// Create an Attributor and initially empty information cache that is filled; // while we identify default attribute opportunities.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp:18,Integrability,wrap,wrappers,18,// Create shallow wrappers for all functions that are not IPO amendable,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp:135,Integrability,interface,interface,135,"// Internalize non-exact functions; // TODO: for now we eagerly internalize functions without calculating the; // cost, we need a cost interface to determine whether internalizing; // a function is ""beneficial""",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp:3,Deployability,Update,Update,3,// Update call graph,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp:105,Performance,cache,cache,105,// Populate the Attributor with abstract attribute opportunities in the; // function and the information cache with IR information.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp:56,Performance,cache,cache,56,// Create an Attributor and initially empty information cache that is filled; // while we identify default attribute opportunities.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp:105,Performance,cache,cache,105,// Populate the Attributor with abstract attribute opportunities in the; // function and the information cache with IR information.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp:3,Performance,Cache,CachedOnly,3,/* CachedOnly */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:14,Integrability,depend,dependence,14,// Only track dependence if we are going to use the assumed info.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:41,Integrability,interface,interface,41,"// If possible, use the hasAssumedIRAttr interface.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:27,Deployability,update,updateImpl,27,/// See AbstractAttribute::updateImpl(...).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:41,Integrability,interface,interface,41,"// If possible, use the hasAssumedIRAttr interface.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:25,Integrability,bridg,bridge,25,/// This function is the bridge between argument position and the call base; /// context.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:41,Integrability,interface,interface,41,"// If possible, use the hasAssumedIRAttr interface.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:27,Deployability,update,updateImpl,27,/// See AbstractAttribute::updateImpl(...).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:27,Deployability,update,updateImpl,27,/// See AbstractAttribute::updateImpl(...).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:41,Integrability,interface,interface,41,"// If possible, use the hasAssumedIRAttr interface.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:49,Security,Access,Access,49,// namespace AA; /// Helper for AA::PointerInfo::Access DenseMap/Set usage.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:32,Security,Access,Access,32,/// Helper for AA::PointerInfo::Access DenseMap/Set usage ignoring everythign; /// but the instruction,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:14,Security,Access,Access,14,"/// Add a new Access to the state at offset \p Offset and with size \p Size.; /// The access is associated with \p I, writes \p Content (if anything), and; /// is of kind \p Kind. If an Access already exists for the same \p I and same; /// \p RemoteI, the two are combined, potentially losing information about; /// offset and size. The resulting access must now be moved from its original; /// OffsetBin to the bin for its new offset.; ///; /// \Returns CHANGED, if the state changed, UNCHANGED otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:86,Security,access,access,86,"/// Add a new Access to the state at offset \p Offset and with size \p Size.; /// The access is associated with \p I, writes \p Content (if anything), and; /// is of kind \p Kind. If an Access already exists for the same \p I and same; /// \p RemoteI, the two are combined, potentially losing information about; /// offset and size. The resulting access must now be moved from its original; /// OffsetBin to the bin for its new offset.; ///; /// \Returns CHANGED, if the state changed, UNCHANGED otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:186,Security,Access,Access,186,"/// Add a new Access to the state at offset \p Offset and with size \p Size.; /// The access is associated with \p I, writes \p Content (if anything), and; /// is of kind \p Kind. If an Access already exists for the same \p I and same; /// \p RemoteI, the two are combined, potentially losing information about; /// offset and size. The resulting access must now be moved from its original; /// OffsetBin to the bin for its new offset.; ///; /// \Returns CHANGED, if the state changed, UNCHANGED otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:347,Security,access,access,347,"/// Add a new Access to the state at offset \p Offset and with size \p Size.; /// The access is associated with \p I, writes \p Content (if anything), and; /// is of kind \p Kind. If an Access already exists for the same \p I and same; /// \p RemoteI, the two are combined, potentially losing information about; /// offset and size. The resulting access must now be moved from its original; /// OffsetBin to the bin for its new offset.; ///; /// \Returns CHANGED, if the state changed, UNCHANGED otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:42,Security,Access,Access,42,"// Every memory instruction results in an Access object. We maintain a list of; // all Access objects that we own, along with the following maps:; //; // - OffsetBins: RangeTy -> { Access }; // - RemoteIMap: RemoteI x LocalI -> Access; //; // A RemoteI is any instruction that accesses memory. RemoteI is different; // from LocalI if and only if LocalI is a call; then RemoteI is some; // instruction in the callgraph starting from LocalI. Multiple paths in the; // callgraph from LocalI to RemoteI may produce multiple accesses, but these; // are all combined into a single Access object. This may result in loss of; // information in RangeTy in the Access object.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:87,Security,Access,Access,87,"// Every memory instruction results in an Access object. We maintain a list of; // all Access objects that we own, along with the following maps:; //; // - OffsetBins: RangeTy -> { Access }; // - RemoteIMap: RemoteI x LocalI -> Access; //; // A RemoteI is any instruction that accesses memory. RemoteI is different; // from LocalI if and only if LocalI is a call; then RemoteI is some; // instruction in the callgraph starting from LocalI. Multiple paths in the; // callgraph from LocalI to RemoteI may produce multiple accesses, but these; // are all combined into a single Access object. This may result in loss of; // information in RangeTy in the Access object.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:181,Security,Access,Access,181,"// Every memory instruction results in an Access object. We maintain a list of; // all Access objects that we own, along with the following maps:; //; // - OffsetBins: RangeTy -> { Access }; // - RemoteIMap: RemoteI x LocalI -> Access; //; // A RemoteI is any instruction that accesses memory. RemoteI is different; // from LocalI if and only if LocalI is a call; then RemoteI is some; // instruction in the callgraph starting from LocalI. Multiple paths in the; // callgraph from LocalI to RemoteI may produce multiple accesses, but these; // are all combined into a single Access object. This may result in loss of; // information in RangeTy in the Access object.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:228,Security,Access,Access,228,"// Every memory instruction results in an Access object. We maintain a list of; // all Access objects that we own, along with the following maps:; //; // - OffsetBins: RangeTy -> { Access }; // - RemoteIMap: RemoteI x LocalI -> Access; //; // A RemoteI is any instruction that accesses memory. RemoteI is different; // from LocalI if and only if LocalI is a call; then RemoteI is some; // instruction in the callgraph starting from LocalI. Multiple paths in the; // callgraph from LocalI to RemoteI may produce multiple accesses, but these; // are all combined into a single Access object. This may result in loss of; // information in RangeTy in the Access object.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:277,Security,access,accesses,277,"// Every memory instruction results in an Access object. We maintain a list of; // all Access objects that we own, along with the following maps:; //; // - OffsetBins: RangeTy -> { Access }; // - RemoteIMap: RemoteI x LocalI -> Access; //; // A RemoteI is any instruction that accesses memory. RemoteI is different; // from LocalI if and only if LocalI is a call; then RemoteI is some; // instruction in the callgraph starting from LocalI. Multiple paths in the; // callgraph from LocalI to RemoteI may produce multiple accesses, but these; // are all combined into a single Access object. This may result in loss of; // information in RangeTy in the Access object.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:520,Security,access,accesses,520,"// Every memory instruction results in an Access object. We maintain a list of; // all Access objects that we own, along with the following maps:; //; // - OffsetBins: RangeTy -> { Access }; // - RemoteIMap: RemoteI x LocalI -> Access; //; // A RemoteI is any instruction that accesses memory. RemoteI is different; // from LocalI if and only if LocalI is a call; then RemoteI is some; // instruction in the callgraph starting from LocalI. Multiple paths in the; // callgraph from LocalI to RemoteI may produce multiple accesses, but these; // are all combined into a single Access object. This may result in loss of; // information in RangeTy in the Access object.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:575,Security,Access,Access,575,"// Every memory instruction results in an Access object. We maintain a list of; // all Access objects that we own, along with the following maps:; //; // - OffsetBins: RangeTy -> { Access }; // - RemoteIMap: RemoteI x LocalI -> Access; //; // A RemoteI is any instruction that accesses memory. RemoteI is different; // from LocalI if and only if LocalI is a call; then RemoteI is some; // instruction in the callgraph starting from LocalI. Multiple paths in the; // callgraph from LocalI to RemoteI may produce multiple accesses, but these; // are all combined into a single Access object. This may result in loss of; // information in RangeTy in the Access object.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:651,Security,Access,Access,651,"// Every memory instruction results in an Access object. We maintain a list of; // all Access objects that we own, along with the following maps:; //; // - OffsetBins: RangeTy -> { Access }; // - RemoteIMap: RemoteI x LocalI -> Access; //; // A RemoteI is any instruction that accesses memory. RemoteI is different; // from LocalI if and only if LocalI is a call; then RemoteI is some; // instruction in the callgraph starting from LocalI. Multiple paths in the; // callgraph from LocalI to RemoteI may produce multiple accesses, but these; // are all combined into a single Access object. This may result in loss of; // information in RangeTy in the Access object.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:23,Security,access,access,23,"// Check if we have an access for this instruction, if not, simply add it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:60,Usability,simpl,simply,60,"// Check if we have an access for this instruction, if not, simply add it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:61,Deployability,update,update,61,"// Combine the new Access with the existing Access, and then update the; // mapping in the offset bins.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:19,Security,Access,Access,19,"// Combine the new Access with the existing Access, and then update the; // mapping in the offset bins.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:44,Security,Access,Access,44,"// Combine the new Access with the existing Access, and then update the; // mapping in the offset bins.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:30,Security,access,access,30,// Ranges that are in the old access but not the new access need to be removed; // from the offset bins.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:53,Security,access,access,53,// Ranges that are in the old access but not the new access need to be removed; // from the offset bins.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:30,Security,access,access,30,// Ranges that are in the new access but not the old access need to be added; // to the offset bins.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:53,Security,access,access,53,// Ranges that are in the new access but not the old access need to be added; // to the offset bins.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:108,Performance,load,load,108,"// If the function is not ending in aligned barriers, we need the stores to; // be in aligned barriers. The load being in one is not sufficient since the; // store might be executed by a thread that disappears after, causing the; // aligned barrier guarding the load to unblock and the load to read a value; // that has no CFG path to the load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:262,Performance,load,load,262,"// If the function is not ending in aligned barriers, we need the stores to; // be in aligned barriers. The load being in one is not sufficient since the; // store might be executed by a thread that disappears after, causing the; // aligned barrier guarding the load to unblock and the load to read a value; // that has no CFG path to the load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:286,Performance,load,load,286,"// If the function is not ending in aligned barriers, we need the stores to; // be in aligned barriers. The load being in one is not sufficient since the; // store might be executed by a thread that disappears after, causing the; // aligned barrier guarding the load to unblock and the load to read a value; // that has no CFG path to the load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:339,Performance,load,load,339,"// If the function is not ending in aligned barriers, we need the stores to; // be in aligned barriers. The load being in one is not sufficient since the; // store might be executed by a thread that disappears after, causing the; // aligned barrier guarding the load to unblock and the load to read a value; // that has no CFG path to the load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:341,Security,access,access,341,"// Helper to determine if we need to consider threading, which we cannot; // right now. However, if the function is (assumed) nosync or the thread; // executing all instructions is the main thread only we can ignore; // threading. Also, thread-local objects do not require threading reasoning.; // Finally, we can ignore threading if either access is executed in an; // aligned region.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:126,Safety,avoid,avoid,126,"// Helper to determine if the access is executed by the same thread as the; // given instruction, for now it is sufficient to avoid any potential; // threading effects as we cannot deal with them anyway.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:30,Security,access,access,30,"// Helper to determine if the access is executed by the same thread as the; // given instruction, for now it is sufficient to avoid any potential; // threading effects as we cannot deal with them anyway.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:10,Security,access,accesses,10,// Set of accesses/instructions that will overwrite the result and are; // therefore blockers in the reachability traversal.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:51,Security,access,accesses,51,// If the object has kernel lifetime we can ignore accesses only reachable; // by other kernels. For now we only skip accesses *in* other kernels.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:118,Security,access,accesses,118,// If the object has kernel lifetime we can ignore accesses only reachable; // by other kernels. For now we only skip accesses *in* other kernels.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:28,Security,access,accesses,28,// Track if all interesting accesses are in the same `nosync` function as; // the given instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:55,Security,access,access,55,// Helper to determine if we can skip a specific write access.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:20,Integrability,depend,dependences,20,"// Check read (RAW) dependences and write (WAR) dependences as necessary.; // If we successfully excluded all effects we are interested in, the; // access can be skipped.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:48,Integrability,depend,dependences,48,"// Check read (RAW) dependences and write (WAR) dependences as necessary.; // If we successfully excluded all effects we are interested in, the; // access can be skipped.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:148,Security,access,access,148,"// Check read (RAW) dependences and write (WAR) dependences as necessary.; // If we successfully excluded all effects we are interested in, the; // access can be skipped.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:39,Security,access,access,39,"// If the instruction cannot reach the access, the former does not; // interfere with what the access reads.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:95,Security,access,access,95,"// If the instruction cannot reach the access, the former does not; // interfere with what the access reads.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:47,Security,access,access,47,"// If the instruction cannot be reach from the access, the latter does not; // interfere with what the instruction reads.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:505,Deployability,update,updated,505,"// If we still might be affected by the write of the access but there are; // dominating writes in the function of the instruction; // (HasBeenWrittenTo), we can try to reason that the access is overwritten; // by them. This would have happend above if they are all in the same; // function, so we only check the inter-procedural case. Effectively, we; // want to show that there is no call after the dominting write that might; // reach the access, and when it returns reach the instruction with the; // updated value. To this end, we iterate all call sites, check if they; // might reach the instruction without going through another access; // (ExclusionSet) and at the same time might reach the access. However,; // that is all part of AAInterFnReachability.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:53,Security,access,access,53,"// If we still might be affected by the write of the access but there are; // dominating writes in the function of the instruction; // (HasBeenWrittenTo), we can try to reason that the access is overwritten; // by them. This would have happend above if they are all in the same; // function, so we only check the inter-procedural case. Effectively, we; // want to show that there is no call after the dominting write that might; // reach the access, and when it returns reach the instruction with the; // updated value. To this end, we iterate all call sites, check if they; // might reach the instruction without going through another access; // (ExclusionSet) and at the same time might reach the access. However,; // that is all part of AAInterFnReachability.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:185,Security,access,access,185,"// If we still might be affected by the write of the access but there are; // dominating writes in the function of the instruction; // (HasBeenWrittenTo), we can try to reason that the access is overwritten; // by them. This would have happend above if they are all in the same; // function, so we only check the inter-procedural case. Effectively, we; // want to show that there is no call after the dominting write that might; // reach the access, and when it returns reach the instruction with the; // updated value. To this end, we iterate all call sites, check if they; // might reach the instruction without going through another access; // (ExclusionSet) and at the same time might reach the access. However,; // that is all part of AAInterFnReachability.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:442,Security,access,access,442,"// If we still might be affected by the write of the access but there are; // dominating writes in the function of the instruction; // (HasBeenWrittenTo), we can try to reason that the access is overwritten; // by them. This would have happend above if they are all in the same; // function, so we only check the inter-procedural case. Effectively, we; // want to show that there is no call after the dominting write that might; // reach the access, and when it returns reach the instruction with the; // updated value. To this end, we iterate all call sites, check if they; // might reach the instruction without going through another access; // (ExclusionSet) and at the same time might reach the access. However,; // that is all part of AAInterFnReachability.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:636,Security,access,access,636,"// If we still might be affected by the write of the access but there are; // dominating writes in the function of the instruction; // (HasBeenWrittenTo), we can try to reason that the access is overwritten; // by them. This would have happend above if they are all in the same; // function, so we only check the inter-procedural case. Effectively, we; // want to show that there is no call after the dominting write that might; // reach the access, and when it returns reach the instruction with the; // updated value. To this end, we iterate all call sites, check if they; // might reach the instruction without going through another access; // (ExclusionSet) and at the same time might reach the access. However,; // that is all part of AAInterFnReachability.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:699,Security,access,access,699,"// If we still might be affected by the write of the access but there are; // dominating writes in the function of the instruction; // (HasBeenWrittenTo), we can try to reason that the access is overwritten; // by them. This would have happend above if they are all in the same; // function, so we only check the inter-procedural case. Effectively, we; // want to show that there is no call after the dominting write that might; // reach the access, and when it returns reach the instruction with the; // updated value. To this end, we iterate all call sites, check if they; // might reach the instruction without going through another access; // (ExclusionSet) and at the same time might reach the access. However,; // that is all part of AAInterFnReachability.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:62,Security,access,access,62,"// Without going backwards in the call tree, can we reach the access; // from the least dominating write. Do not allow to pass the instruction; // itself either.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:32,Security,access,accesses,32,// Run the user callback on all accesses we cannot skip and return if; // that succeeded for all or not.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:15,Security,access,accesses,15,// Combine the accesses bin by bin.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:15,Security,access,accesses,15,// Combine the accesses bin by bin.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:17,Security,access,access,17,/// Deal with an access and signal if it was handled successfully.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:19,Security,access,access,19,// Add the element access.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:27,Deployability,update,updateImpl,27,/// See AbstractAttribute::updateImpl(...).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:141,Deployability,update,updated,141,"/// If the indices to \p GEP can be traced to constants, incorporate all; /// of these into \p UsrOI.; ///; /// \return true iff \p UsrOI is updated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:14,Modifiability,Variab,VariableOffsets,14,"// Each VI in VariableOffsets has a set of potential constant values. Every; // combination of elements, picked one each from these sets, is separately; // added to the original set of offsets, thus resulting in more offsets.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:16,Usability,simpl,simply,16,"// One does not simply walk into a map and assign a reference to a possibly; // new location. That can cause an invalidation before the assignment; // happens, like so:; //; // OffsetInfoMap[Usr] = OffsetInfoMap[CurPtr]; /* bad idea! */; //; // The RHS is a reference that may be invalidated by an insertion caused by; // the LHS. So we ensure that the side-effect of the LHS happens first.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:32,Security,access,access,32,"// Note the order here, the Usr access might change the map, CurPtr is; // already in it though.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:32,Security,access,access,32,"// Note the order here, the Usr access might change the map, CurPtr is; // already in it though.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:35,Integrability,depend,dependent,35,"// Check if the PHI operand is not dependent on the PHI itself. Every; // recurrence is a cyclic net of PHIs in the data flow, and has an; // equivalent Cycle in the control flow. One of those PHIs must be in the; // header of that control flow Cycle. This is independent of the choice of; // Cycles reported by CycleInfo. It is sufficient to check the PHIs in; // every Cycle header; if such a node is marked unknown, this will; // eventually propagate through the whole net of PHIs in the recurrence.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:10,Security,access,access,10,"// If the access is to a pointer that may or may not be the associated; // value, e.g. due to a PHI, we cannot assume it will be read.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:35,Performance,load,load,35,// Check if the assumption and the load are executed together without; // memory modification.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:56,Performance,load,load,56,// Check if we found an assumption associated with this load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:10,Security,access,access,10,"// If the access is to a pointer that may or may not be the associated; // value, e.g. due to a PHI, we cannot assume it will be written.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:27,Deployability,update,updateImpl,27,/// See AbstractAttribute::updateImpl(...).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:27,Deployability,update,updateImpl,27,/// See AbstractAttribute::updateImpl(...).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:141,Security,access,accessed,141,"// We handle memory intrinsics explicitly, at least the first (=; // destination) and second (=source) arguments as we know how they are; // accessed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:27,Deployability,update,updateImpl,27,/// See AbstractAttribute::updateImpl(...).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:27,Deployability,update,updateImpl,27,/// See AbstractAttribute::updateImpl(...).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:27,Deployability,update,updateImpl,27,/// See AbstractAttribute::updateImpl(...).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:28,Deployability,update,updateImpl,28,/// See Abstract Attribute::updateImpl(...).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:27,Deployability,update,updateImpl,27,/// See AbstractAttribute::updateImpl(...).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:27,Deployability,update,updateImpl,27,/// See AbstractAttribute::updateImpl(...).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:116,Safety,avoid,avoid,116,"// We need to follow common pointer manipulation uses to the accesses they; // feed into. We can try to be smart to avoid looking through things we do not; // like for now, e.g., non-inbounds GEPs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:61,Security,access,accesses,61,"// We need to follow common pointer manipulation uses to the accesses they; // feed into. We can try to be smart to avoid looking through things we do not; // like for now, e.g., non-inbounds GEPs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:74,Integrability,depend,dependences,74,// As long as we only use known information there is no need to track; // dependences here.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:27,Deployability,update,updateImpl,27,/// See AbstractAttribute::updateImpl(...).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:27,Deployability,update,updateImpl,27,/// See AbstractAttribute::updateImpl(...).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:27,Deployability,update,updateImpl,27,/// See AbstractAttribute::updateImpl(...).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:305,Deployability,update,update,305,"// If we know all call sites and all are known no-recurse, we are done.; // If all known call sites, which might not be all that exist, are known; // to be no-recurse, we are not done but we can continue to assume; // no-recurse. If one of the call sites we have not visited will become; // live, another update is triggered.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:27,Deployability,update,updateImpl,27,/// See AbstractAttribute::updateImpl(...).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:27,Deployability,update,updateImpl,27,/// See AbstractAttribute::updateImpl(...).; // through a pointer (i.e. also branches etc.),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:61,Security,access,accesses,61,"// If we reach here, we know we have an instruction; // that accesses memory through a pointer operand,; // for which getPointerOperand() should give it to us.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:80,Usability,simpl,simplified,80,"// Either we stopped and the appropriate action was taken,; // or we got back a simplified value to continue.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:12,Security,access,access,12,// A memory access through a pointer is considered UB; // only if the pointer has constant null value.; // TODO: Expand it to not only check constant values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:12,Security,access,access,12,// A memory access using constant null pointer is only considered UB; // if null pointer is _not_ defined for the target platform.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:80,Usability,simpl,simplified,80,"// Either we stopped and the appropriate action was taken,; // or we got back a simplified value to continue.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:38,Usability,simpl,simplified,38,"// If current argument is known to be simplified to null pointer and the; // corresponding argument position is known to have nonnull attribute,; // the argument is poison. Furthermore, if the argument is poison and; // the position is known to have noundef attriubte, this callsite is; // considered UB.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:127,Usability,Simpl,Simplified,127,"// Here, we handle three cases.; // (1) Not having a value means it is dead. (we can replace the value; // with undef); // (2) Simplified to undef. The argument violate noundef attriubte.; // (3) Simplified to null pointer where known to be nonnull.; // The argument is a poison value and violate noundef attribute.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:196,Usability,Simpl,Simplified,196,"// Here, we handle three cases.; // (1) Not having a value means it is dead. (we can replace the value; // with undef); // (2) Simplified to undef. The argument violate noundef attriubte.; // (3) Simplified to null pointer where known to be nonnull.; // The argument is a poison value and violate noundef attribute.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:80,Usability,simpl,simplified,80,"// Either we stopped and the appropriate action was taken,; // or we got back a simplified return value to continue.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:290,Usability,simpl,simplified,290,"// Check if a return instruction always cause UB or not; // Note: It is guaranteed that the returned position of the anchor; // scope has noundef attribute when this is called.; // We also ensure the return position is not ""assumed dead""; // because the returned value was then potentially simplified to; // `undef` in AAReturnedValues without removing the `noundef`; // attribute yet.; // When the returned position has noundef attriubte, UB occurs in the; // following cases.; // (1) Returned value is known to be undef.; // (2) The value is known to be a null pointer and the returned; // position has nonnull attribute (because the returned value is; // poison).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:235,Testability,test,test,235,"// In simple words, if an instruction is not in the assumed to _not_; // cause UB, then it is assumed UB (that includes those; // in the KnownUBInsts set). The rest is boilerplate; // is to ensure that it is one of the instructions we test; // for UB.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:6,Usability,simpl,simple,6,"// In simple words, if an instruction is not in the assumed to _not_; // cause UB, then it is assumed UB (that includes those; // in the KnownUBInsts set). The rest is boilerplate; // is to ensure that it is one of the instructions we test; // for UB.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:843,Deployability,update,updateImpl,843,"/// Note: The correctness of this analysis depends on the fact that the; /// following 2 sets will stop changing after some point.; /// ""Change"" here means that their size changes.; /// The size of each set is monotonically increasing; /// (we only add items to them) and it is upper bounded by the number of; /// instructions in the processed function (we can never save more; /// elements in either set than this number). Hence, at some point,; /// they will stop increasing.; /// Consequently, at some point, both sets will have stopped; /// changing, effectively making the analysis reach a fixpoint.; /// Note: These 2 sets are disjoint and an instruction can be considered; /// one of 3 things:; /// 1) Known to cause UB (AAUndefinedBehavior could prove it) and put it in; /// the KnownUBInsts set.; /// 2) Assumed to cause UB (in every updateImpl, AAUndefinedBehavior; /// has a reason to assume it).; /// 3) Assumed to not cause UB. very other instruction - AAUndefinedBehavior; /// could not find a reason to assume or prove that it can cause UB,; /// hence it assumes it doesn't. We have a set for these instructions; /// so that we don't reprocess them in every update.; /// Note however that instructions in this set may cause UB.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:1173,Deployability,update,update,1173,"/// Note: The correctness of this analysis depends on the fact that the; /// following 2 sets will stop changing after some point.; /// ""Change"" here means that their size changes.; /// The size of each set is monotonically increasing; /// (we only add items to them) and it is upper bounded by the number of; /// instructions in the processed function (we can never save more; /// elements in either set than this number). Hence, at some point,; /// they will stop increasing.; /// Consequently, at some point, both sets will have stopped; /// changing, effectively making the analysis reach a fixpoint.; /// Note: These 2 sets are disjoint and an instruction can be considered; /// one of 3 things:; /// 1) Known to cause UB (AAUndefinedBehavior could prove it) and put it in; /// the KnownUBInsts set.; /// 2) Assumed to cause UB (in every updateImpl, AAUndefinedBehavior; /// has a reason to assume it).; /// 3) Assumed to not cause UB. very other instruction - AAUndefinedBehavior; /// could not find a reason to assume or prove that it can cause UB,; /// hence it assumes it doesn't. We have a set for these instructions; /// so that we don't reprocess them in every update.; /// Note however that instructions in this set may cause UB.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:43,Integrability,depend,depends,43,"/// Note: The correctness of this analysis depends on the fact that the; /// following 2 sets will stop changing after some point.; /// ""Change"" here means that their size changes.; /// The size of each set is monotonically increasing; /// (we only add items to them) and it is upper bounded by the number of; /// instructions in the processed function (we can never save more; /// elements in either set than this number). Hence, at some point,; /// they will stop increasing.; /// Consequently, at some point, both sets will have stopped; /// changing, effectively making the analysis reach a fixpoint.; /// Note: These 2 sets are disjoint and an instruction can be considered; /// one of 3 things:; /// 1) Known to cause UB (AAUndefinedBehavior could prove it) and put it in; /// the KnownUBInsts set.; /// 2) Assumed to cause UB (in every updateImpl, AAUndefinedBehavior; /// has a reason to assume it).; /// 3) Assumed to not cause UB. very other instruction - AAUndefinedBehavior; /// could not find a reason to assume or prove that it can cause UB,; /// hence it assumes it doesn't. We have a set for these instructions; /// so that we don't reprocess them in every update.; /// Note however that instructions in this set may cause UB.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:23,Deployability,update,updates,23,"// Should be called on updates in which if we're processing an instruction; // \p I that depends on a value \p V, one of the following has to happen:; // - If the value is assumed, then stop.; // - If the value is known but undef, then consider it UB.; // - Otherwise, do specific processing with the simplified value.; // We return std::nullopt in the first 2 cases to signify that an appropriate; // action was taken and the caller should stop.; // Otherwise, we return the simplified value that the caller should; // use for specific processing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:89,Integrability,depend,depends,89,"// Should be called on updates in which if we're processing an instruction; // \p I that depends on a value \p V, one of the following has to happen:; // - If the value is assumed, then stop.; // - If the value is known but undef, then consider it UB.; // - Otherwise, do specific processing with the simplified value.; // We return std::nullopt in the first 2 cases to signify that an appropriate; // action was taken and the caller should stop.; // Otherwise, we return the simplified value that the caller should; // use for specific processing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:301,Usability,simpl,simplified,301,"// Should be called on updates in which if we're processing an instruction; // \p I that depends on a value \p V, one of the following has to happen:; // - If the value is assumed, then stop.; // - If the value is known but undef, then consider it UB.; // - Otherwise, do specific processing with the simplified value.; // We return std::nullopt in the first 2 cases to signify that an appropriate; // action was taken and the caller should stop.; // Otherwise, we return the simplified value that the caller should; // use for specific processing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:476,Usability,simpl,simplified,476,"// Should be called on updates in which if we're processing an instruction; // \p I that depends on a value \p V, one of the following has to happen:; // - If the value is assumed, then stop.; // - If the value is known but undef, then consider it UB.; // - Otherwise, do specific processing with the simplified value.; // We return std::nullopt in the first 2 cases to signify that an appropriate; // action was taken and the caller should stop.; // Otherwise, we return the simplified value that the caller should; // use for specific processing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:9,Integrability,depend,depend,9,// Don't depend on assumed values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:28,Testability,test,tested,28,"// If it is known (which we tested above) but it doesn't have a value,; // then we can assume `undef` and hence the instruction is UB.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:37,Availability,avail,available,37,"// If either SCEV or LoopInfo is not available for the function then we assume; // any cycle to be unbounded cycle.; // We use scc_iterator which uses Tarjan algorithm to find all the maximal; // SCCs.To detect if there's a cycle, we only need to find the maximal ones.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:204,Safety,detect,detect,204,"// If either SCEV or LoopInfo is not available for the function then we assume; // any cycle to be unbounded cycle.; // We use scc_iterator which uses Tarjan algorithm to find all the maximal; // SCCs.To detect if there's a cycle, we only need to find the maximal ones.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:27,Deployability,update,updateImpl,27,/// See AbstractAttribute::updateImpl(...).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:27,Deployability,update,updateImpl,27,/// See AbstractAttribute::updateImpl(...).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:16,Security,hash,hash,16,/// Precomputed hash for this RQI.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:83,Performance,cache,cache,83,/// Constructor replacement to ensure unique and stable sets are used for the; /// cache.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:27,Deployability,update,updateImpl,27,/// See AbstractAttribute::updateImpl(...).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:37,Performance,cache,cache,37,// Remove the temporary RQI from the cache.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:11,Integrability,depend,depend,11,"// We only depend on liveness. DeadEdges is all we care about, check if any; // of them changed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:79,Deployability,update,update,79,// Set of assumed dead blocks we used in the last query. If any changes we; // update the state.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:78,Deployability,update,update,78,// Set of assumed dead edges we used in the last query. If any changes we; // update the state.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:205,Deployability,update,updateImpl,205,"// We have to make sure no-alias on the argument does not break; // synchronization when this is a callback argument, see also [1] below.; // If synchronization cannot be affected, we delegate to the base updateImpl; // function, otherwise we give up for now.; // If the function is no-sync, no-alias cannot break synchronization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:68,Integrability,synchroniz,synchronization,68,"// We have to make sure no-alias on the argument does not break; // synchronization when this is a callback argument, see also [1] below.; // If synchronization cannot be affected, we delegate to the base updateImpl; // function, otherwise we give up for now.; // If the function is no-sync, no-alias cannot break synchronization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:145,Integrability,synchroniz,synchronization,145,"// We have to make sure no-alias on the argument does not break; // synchronization when this is a callback argument, see also [1] below.; // If synchronization cannot be affected, we delegate to the base updateImpl; // function, otherwise we give up for now.; // If the function is no-sync, no-alias cannot break synchronization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:314,Integrability,synchroniz,synchronization,314,"// We have to make sure no-alias on the argument does not break; // synchronization when this is a callback argument, see also [1] below.; // If synchronization cannot be affected, we delegate to the base updateImpl; // function, otherwise we give up for now.; // If the function is no-sync, no-alias cannot break synchronization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:55,Integrability,synchroniz,synchronization,55,"// If the argument is read-only, no-alias cannot break synchronization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:80,Integrability,synchroniz,synchronization,80,"// If the argument is never passed through callbacks, no-alias cannot break; // synchronization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:53,Integrability,synchroniz,synchronization,53,"// TODO: add no-alias but make sure it doesn't break synchronization by; // introducing fake uses. See:; // [1] Compiler Optimizations for OpenMP, J. Doerfert and H. Finkel,; // International Workshop on OpenMP 2018,; // http://compilers.cs.uni-saarland.de/people/doerfert/par_opt18.pdf",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:121,Performance,Optimiz,Optimizations,121,"// TODO: add no-alias but make sure it doesn't break synchronization by; // introducing fake uses. See:; // [1] Compiler Optimizations for OpenMP, J. Doerfert and H. Finkel,; // International Workshop on OpenMP 2018,; // http://compilers.cs.uni-saarland.de/people/doerfert/par_opt18.pdf",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:59,Security,access,accesses,59,// If the argument is readnone we are done as there are no accesses via the; // argument.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:27,Deployability,update,updateImpl,27,/// See AbstractAttribute::updateImpl(...).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:180,Deployability,update,update,180,// Explicitly set the dependence class to required because we want a long; // chain of N dependent instructions to be considered live as soon as one is; // without going through N update cycles. This is not required for; // correctness.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:22,Integrability,depend,dependence,22,// Explicitly set the dependence class to required because we want a long; // chain of N dependent instructions to be considered live as soon as one is; // without going through N update cycles. This is not required for; // correctness.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:89,Integrability,depend,dependent,89,// Explicitly set the dependence class to required because we want a long; // chain of N dependent instructions to be considered live as soon as one is; // without going through N update cycles. This is not required for; // correctness.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:157,Performance,cache,cached,157,// If we are collecting assumes to be deleted we are in the manifest stage.; // It's problematic to collect the potential copies again now so we use the; // cached ones.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:27,Deployability,update,updateImpl,27,/// See AbstractAttribute::updateImpl(...).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:27,Deployability,update,updateImpl,27,/// See AbstractAttribute::updateImpl(...).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:27,Deployability,update,updateImpl,27,/// See AbstractAttribute::updateImpl(...).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:9,Modifiability,Rewrite,Rewrite,9,// TODO: Rewrite the signature to return void?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:27,Deployability,update,updateImpl,27,/// See AbstractAttribute::updateImpl(...).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:162,Performance,perform,performance,162,// We assume that all of BB is (probably) live now and if there are calls to; // internal functions we will assume that those are now live as well. This; // is a performance optimization for blocks with calls to a lot of internal; // functions. It can however cause dead functions to be treated as live.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:174,Performance,optimiz,optimization,174,// We assume that all of BB is (probably) live now and if there are calls to; // internal functions we will assume that those are now live as well. This; // is a performance optimization for blocks with calls to a lot of internal; // functions. It can however cause dead functions to be treated as live.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:114,Deployability,update,update,114,// Copy and clear the list of instructions we need to explore from. It is; // refilled with instructions the next update has to look at.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:12,Usability,clear,clear,12,// Copy and clear the list of instructions we need to explore from. It is; // refilled with instructions the next update has to look at.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:27,Deployability,update,updateImpl,27,/// See AbstractAttribute::updateImpl(...).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:42,Security,access,accessed,42,/// }; /// Helper function for collecting accessed bytes in must-be-executed-context,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:216,Availability,down,down,216,"// If something was stripped but there is circular reasoning we look; // for the offset. If it is positive we basically decrease the; // dereferenceable bytes in a circular loop now, which will simply; // drive them down to the known value in a very slow way which we; // can accelerate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:194,Usability,simpl,simply,194,"// If something was stripped but there is circular reasoning we look; // for the offset. If it is positive we basically decrease the; // dereferenceable bytes in a circular loop now, which will simply; // drive them down to the known value in a very slow way which we; // can accelerate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:61,Security,access,accesses,61,// We need to follow common pointer manipulation uses to the accesses they; // feed into.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:74,Integrability,depend,dependences,74,// As long as we only use known information there is no need to track; // dependences here.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:99,Energy Efficiency,power,power,99,"// BasePointerAddr + Offset = Alignment * Q for some integer Q.; // So we can say that the maximum power of two which is a divisor of; // gcd(Offset, Alignment) is an alignment.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:159,Safety,avoid,avoid,159,// TODO: Provide a helper to determine the implied ABI alignment and check in; // the existing manifest method and a new one for AAAlignImpl that value; // to avoid making the alignment explicit if it did not improve.; /// See AbstractAttribute::getDeducedAttributes,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:99,Energy Efficiency,power,power,99,"// BasePointerAddr + Offset = Alignment * Q for some integer Q.; // So we can say that the maximum power of two which is a divisor of; // gcd(Offset, Alignment) is an alignment.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:27,Deployability,update,updateImpl,27,/// See AbstractAttribute::updateImpl(Attributor &A).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:85,Integrability,depend,dependence,85,// We only take known information from the argument; // so we do not need to track a dependence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:27,Deployability,update,updateImpl,27,/// See AbstractAttribute::updateImpl(Attributor &A).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:27,Deployability,update,updateImpl,27,/// See AbstractAttribute::updateImpl(...).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:27,Deployability,update,updateImpl,27,/// See AbstractAttribute::updateImpl(...).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:27,Deployability,update,updateImpl,27,/// See AbstractAttribute::updateImpl(...).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:174,Performance,load,loading,174,"// A function cannot capture state in memory if it only reads memory, it can; // however return/throw state and the state might be influenced by the; // pointer value, e.g., loading from a returned pointer might reveal a bit.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:27,Deployability,update,updateImpl,27,/// See AbstractAttribute::updateImpl(...).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:27,Deployability,update,update,27,/// Check the use \p U and update \p State accordingly. Return true if we; /// should continue to update the state.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:98,Deployability,update,update,98,/// Check the use \p U and update \p State accordingly. Return true if we; /// should continue to update the state.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:31,Testability,log,logic,31,"// For now we only use special logic for call sites. However, the tracker; // itself knows about a lot of other non-capturing cases already.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:4,Deployability,Update,Update,4,"/// Update \p State according to \p CapturedInMem, \p CapturedInInt, and; /// \p CapturedInRet, then return true if we should continue updating the; /// state.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:27,Deployability,update,updateImpl,27,/// See AbstractAttribute::updateImpl(...).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:27,Deployability,update,updateImpl,27,/// See AbstractAttribute::updateImpl(...).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:43,Usability,Simpl,Simplify,43,// namespace; /// ------------------ Value Simplify Attribute ----------------------------,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:136,Usability,Simpl,SimplifiedValue,136,/// Helper function for querying AAValueSimplify and updating candidate.; /// \param IRP The value position we are trying to unify with SimplifiedValue,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:36,Integrability,synchroniz,synchronization,36,"// TODO: We probably need to verify synchronization is not an issue, e.g.,; // there is no race by not copying a constant byval.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:108,Safety,avoid,avoids,108,"// Simplify the argument operand explicitly and check if the result is; // valid in the current scope. This avoids refering to simplified values; // in other functions, e.g., we don't want to say a an argument in a; // static function is actually an argument in a different function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:3,Usability,Simpl,Simplify,3,"// Simplify the argument operand explicitly and check if the result is; // valid in the current scope. This avoids refering to simplified values; // in other functions, e.g., we don't want to say a an argument in a; // static function is actually an argument in a different function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:127,Usability,simpl,simplified,127,"// Simplify the argument operand explicitly and check if the result is; // valid in the current scope. This avoids refering to simplified values; // in other functions, e.g., we don't want to say a an argument in a; // static function is actually an argument in a different function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:36,Deployability,update,update,36,"// If a candidate was found in this update, return CHANGED.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:36,Deployability,update,update,36,"// If a candidate was found in this update, return CHANGED.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:88,Usability,simpl,simplified,88,// We queried AAValueSimplify for the returned values so they will be; // replaced if a simplified form was found. Nothing to do here.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:36,Deployability,update,update,36,"// If a candidate was found in this update, return CHANGED.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:27,Deployability,update,updateImpl,27,/// See AbstractAttribute::updateImpl(...).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:19,Safety,avoid,avoid,19,// TODO: We should avoid simplification duplication to begin with.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:25,Usability,simpl,simplification,25,// TODO: We should avoid simplification duplication to begin with.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:18,Energy Efficiency,allocate,allocates,18,/// The call that allocates the memory.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:22,Modifiability,rewrite,rewrite,22,/// The status wrt. a rewrite.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:39,Deployability,release,release,39,// Ensure we call the destructor so we release any memory allocated in the; // sets.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:58,Energy Efficiency,allocate,allocated,58,// Ensure we call the destructor so we release any memory allocated in the; // sets.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:171,Usability,simpl,simply,171,"// Initialize the alloca with the same value as used by the allocation; // function. We can skip undef as the initial value of an alloc is; // undef, and the memset would simply end up being DSEd.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:21,Deployability,update,update,21,// Flag to ensure we update our deallocation information at most once per; // updateImpl call and only if we use the free check reasoning.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:78,Deployability,update,updateImpl,78,// Flag to ensure we update our deallocation information at most once per; // updateImpl call and only if we use the free check reasoning.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:23,Security,access,accessible,23,"// If the stack is not accessible by other threads, the ""must-free"" logic; // doesn't apply as the pointer could be shared and needs to be places in; // ""shareable"" memory.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:68,Testability,log,logic,68,"// If the stack is not accessible by other threads, the ""must-free"" logic; // doesn't apply as the pointer could be shared and needs to be places in; // ""shareable"" memory.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:14,Deployability,update,update,14,// The actual update starts here. We look at all allocations and depending on; // their status perform the appropriate check(s).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:65,Integrability,depend,depending,65,// The actual update starts here. We look at all allocations and depending on; // their status perform the appropriate check(s).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:95,Performance,perform,perform,95,// The actual update starts here. We look at all allocations and depending on; // their status perform the appropriate check(s).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:116,Usability,clear,clear,116,"/// Identify the type we can chose for a private copy of the underlying; /// argument. std::nullopt means it is not clear yet, nullptr means there is; /// none.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:89,Testability,stub,stub,89,/// Return a privatizable type that encloses both T0 and T1.; /// TODO: This is merely a stub for now as we should manage a mapping as well.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:77,Modifiability,rewrite,rewrite,77,"// If this is a byval argument and we know all the call sites (so we can; // rewrite them), there is no need to check them explicitly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:385,Deployability,patch,patch,385,"// Make sure the associated call site argument has the same type at all call; // sites and it is an allocation we know is safe to privatize, for now that; // means we only allow alloca instructions.; // TODO: We can additionally analyze the accesses in the callee to create; // the type from that information instead. That is a little more; // involved and will be done in a follow up patch.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:122,Safety,safe,safe,122,"// Make sure the associated call site argument has the same type at all call; // sites and it is an allocation we know is safe to privatize, for now that; // means we only allow alloca instructions.; // TODO: We can additionally analyze the accesses in the callee to create; // the type from that information instead. That is a little more; // involved and will be done in a follow up patch.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:241,Security,access,accesses,241,"// Make sure the associated call site argument has the same type at all call; // sites and it is an allocation we know is safe to privatize, for now that; // means we only allow alloca instructions.; // TODO: We can additionally analyze the accesses in the callee to create; // the type from that information instead. That is a little more; // involved and will be done in a follow up patch.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:27,Deployability,update,updateImpl,27,/// See AbstractAttribute::updateImpl(...).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:7,Integrability,depend,dependence,7,// The dependence is optional so we don't give up once we give up on the; // alignment.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:3,Safety,Avoid,Avoid,3,// Avoid arguments with padding for now.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:14,Modifiability,rewrite,rewrite,14,// Register a rewrite of the argument.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:37,Performance,load,loads,37,"// Traverse the type, build GEPs and loads.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:103,Performance,load,loads,103,// Query AAAlign attribute for alignment of associated argument to; // determine the best alignment of loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:15,Availability,repair,repair,15,// Callback to repair the associated function. A new alloca is placed at the; // beginning and initialized with the values passed through arguments. The; // new alloca replaces the use of the old pointer argument.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:15,Availability,repair,repair,15,// Callback to repair a call site of the associated function. The elements; // of the privatizable type are loaded prior to the call and passed to the; // new function version.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:108,Performance,load,loaded,108,// Callback to repair a call site of the associated function. The elements; // of the privatizable type are loaded prior to the call and passed to the; // new function version.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:42,Performance,load,load,42,"// When no alignment is specified for the load instruction,; // natural alignment is assumed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:14,Modifiability,rewrite,rewrite,14,// Register a rewrite of the argument.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:27,Deployability,update,updateImpl,27,/// See AbstractAttribute::updateImpl(...).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:3,Usability,Clear,Clear,3,// Clear existing attributes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:3,Usability,Clear,Clear,3,// Clear conflicting writable attribute.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:27,Deployability,update,updateImpl,27,/// See AbstractAttribute::updateImpl(...).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:70,Modifiability,variab,variable,70,/// Return true if users of \p UserI might access the underlying; /// variable/location described by \p U and should therefore be analyzed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:43,Security,access,access,43,/// Return true if users of \p UserI might access the underlying; /// variable/location described by \p U and should therefore be analyzed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:4,Deployability,Update,Update,4,/// Update the state according to the effect of use \p U in \p UserI.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:27,Deployability,update,updateImpl,27,/// See AbstractAttribute::updateImpl(...).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:27,Deployability,update,updateImpl,27,/// See AbstractAttribute::updateImpl(Attributor &A).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:3,Usability,Clear,Clear,3,// Clear conflicting writable attribute.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:3,Usability,Clear,Clear,3,// Clear conflicting writable attribute.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:10,Security,access,access,10,// Remove access kind modifiers if necessary.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:73,Safety,avoid,avoid,73,"// First, check the function scope. We take the known information and we avoid; // work if the assumed information implies the current assumed information for; // this attribute. This is a valid for all but byval arguments.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:57,Performance,perform,perform,57,"// Droppable users, e.g., llvm::assume does not actually perform any action.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:7,Performance,load,loaded,7,"// The loaded value is unrelated to the pointer argument, no need to; // follow the users of the load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:97,Performance,load,load,97,"// The loaded value is unrelated to the pointer argument, no need to; // follow the users of the load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:3,Performance,Load,Loads,3,// Loads cause the NO_READS property to disappear.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:23,Security,access,access,23,// Adjust the possible access behavior based on the information on the; // argument.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:22,Energy Efficiency,allocate,allocated,22,"// The AccessSets are allocated via a BumpPtrAllocator, we call; // the destructor manually.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:7,Security,Access,AccessSets,7,"// The AccessSets are allocated via a BumpPtrAllocator, we call; // the destructor manually.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:236,Performance,perform,performance,236,// For internal functions we ignore `argmemonly` and; // `inaccessiblememorargmemonly` as we might break it via interprocedural; // constant propagation. It is unclear if this is the best way but it is; // unlikely this will cause real performance problems. If we are deriving; // attributes for the anchor function we even remove the attribute in; // addition to ignoring it.; // TODO: A better way to handle this would be to add ~NO_GLOBAL_MEM /; // MemoryEffects::Other as a possible location.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:89,Security,access,access,89,// If we give up and indicate a pessimistic fixpoint this instruction will; // become an access for all potential access kinds:; // TODO: Add pointers for argmemonly and globals to improve the results of; // checkForAllAccessesToMemoryKind.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:114,Security,access,access,114,// If we give up and indicate a pessimistic fixpoint this instruction will; // become an access for all potential access kinds:; // TODO: Add pointers for argmemonly and globals to improve the results of; // checkForAllAccessesToMemoryKind.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:106,Security,access,accesses,106,/// Helper struct to tie together an instruction that has a read or write; /// effect with the pointer it accesses (if any).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:36,Security,access,access,36,/// The instruction that caused the access.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:29,Security,access,accessed,29,"/// The base pointer that is accessed, or null if unknown.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:16,Security,access,access,16,/// The kind of access (read/write/read+write).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:109,Security,access,accesses,109,"/// Mapping from *single* memory location kinds, e.g., LOCAL_MEM with the; /// value of NO_LOCAL_MEM, to the accesses encountered for this memory kind.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:92,Deployability,update,update,92,/// Categorize the pointer arguments of CB that might access memory in; /// AccessedLoc and update the state and access map accordingly.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:54,Security,access,access,54,/// Categorize the pointer arguments of CB that might access memory in; /// AccessedLoc and update the state and access map accordingly.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:76,Security,Access,AccessedLoc,76,/// Categorize the pointer arguments of CB that might access memory in; /// AccessedLoc and update the state and access map accordingly.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:113,Security,access,access,113,/// Categorize the pointer arguments of CB that might access memory in; /// AccessedLoc and update the state and access map accordingly.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:47,Security,access,accessed,47,/// Return the kind(s) of location that may be accessed by \p V.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:15,Security,access,access,15,/// Return the access kind as determined by \p I.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:4,Deployability,Update,Update,4,/// Update the state \p State and the AccessKind2Accesses given that \p I is; /// an access of kind \p AK to a \p MLK memory location with the access; /// pointer \p Ptr.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:85,Security,access,access,85,/// Update the state \p State and the AccessKind2Accesses given that \p I is; /// an access of kind \p AK to a \p MLK memory location with the access; /// pointer \p Ptr.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:143,Security,access,access,143,/// Update the state \p State and the AccessKind2Accesses given that \p I is; /// an access of kind \p AK to a \p MLK memory location with the access; /// pointer \p Ptr.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:94,Deployability,update,update,94,"/// Determine the underlying locations kinds for \p Ptr, e.g., globals or; /// arguments, and update the state and access map accordingly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:115,Security,access,access,115,"/// Determine the underlying locations kinds for \p Ptr, e.g., globals or; /// arguments, and update the state and access map accordingly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:12,Energy Efficiency,allocate,allocate,12,/// Used to allocate access sets.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:21,Security,access,access,21,/// Used to allocate access sets.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:46,Security,access,accesses,46,// TODO: recognize the TBAA used for constant accesses.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:10,Security,access,accesses,10,// Filter accesses to constant (GPU) memory if we have an AS at the access; // site or the object is known to actually have the associated AS.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:68,Security,access,access,68,// Filter accesses to constant (GPU) memory if we have an AS at the access; // site or the object is known to actually have the associated AS.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:65,Performance,perform,performed,65,"// TODO: For now we do not treat byval arguments as local copies performed; // on the call edge, though, we should. To make that happen we need to; // teach various passes, e.g., DSE, about the copy effect of a byval. That; // would also allow us to mark functions only accessing byval arguments as; // readnone again, arguably their accesses have no effect outside of the; // function, like accesses to allocas.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:270,Security,access,accessing,270,"// TODO: For now we do not treat byval arguments as local copies performed; // on the call edge, though, we should. To make that happen we need to; // teach various passes, e.g., DSE, about the copy effect of a byval. That; // would also allow us to mark functions only accessing byval arguments as; // readnone again, arguably their accesses have no effect outside of the; // function, like accesses to allocas.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:334,Security,access,accesses,334,"// TODO: For now we do not treat byval arguments as local copies performed; // on the call edge, though, we should. To make that happen we need to; // teach various passes, e.g., DSE, about the copy effect of a byval. That; // would also allow us to mark functions only accessing byval arguments as; // readnone again, arguably their accesses have no effect outside of the; // function, like accesses to allocas.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:392,Security,access,accesses,392,"// TODO: For now we do not treat byval arguments as local copies performed; // on the call edge, though, we should. To make that happen we need to; // teach various passes, e.g., DSE, about the copy effect of a byval. That; // would also allow us to mark functions only accessing byval arguments as; // readnone again, arguably their accesses have no effect outside of the; // function, like accesses to allocas.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:26,Security,access,accessed,26,// Categorize potentially accessed pointer arguments as if there was an; // access instruction with them as pointer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:76,Security,access,access,76,// Categorize potentially accessed pointer arguments as if there was an; // access instruction with them as pointer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:42,Security,access,access,42,// First check if we assume any memory is access is visible.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:43,Security,access,accessed,43,// Now handle global memory if it might be accessed. This is slightly tricky; // as NO_GLOBAL_MEM has multiple bits set.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:45,Security,access,accessed,45,// Now handle argument memory if it might be accessed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:27,Deployability,update,updateImpl,27,/// See AbstractAttribute::updateImpl(Attributor &A).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:27,Deployability,update,updateImpl,27,/// See AbstractAttribute::updateImpl(...).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:76,Modifiability,variab,variable,76,"// TODO: Make SCEV use Attributor assumption.; // We may be able to bound a variable range via assumptions in; // Attributor. ex.) If x is assumed to be in [1, 3] and y is known to; // evolve to x^2 + x, then we can say that y is in [2, 12].",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:185,Modifiability,evolve,evolve,185,"// TODO: Make SCEV use Attributor assumption.; // We may be able to bound a variable range via assumptions in; // Attributor. ex.) If x is assumed to be in [1, 3] and y is known to; // evolve to x^2 + x, then we can say that y is in [2, 12].",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:3,Integrability,Bridg,BridgeCallBaseContext,3,/* BridgeCallBaseContext */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:3,Integrability,Bridg,BridgeCallBaseContext,3,/* BridgeCallBaseContext */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:14,Performance,load,load,14,"// If it is a load instruction with range metadata, use it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:88,Deployability,update,update,88,// We can work with PHI and select instruction as we traverse their operands; // during update.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:3,Usability,Simpl,Simplify,3,// Simplify the operands first.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:3,Usability,Simpl,Simplify,3,// Simplify the operand first.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:3,Usability,Simpl,Simplify,3,// Simplify the operands first.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:27,Deployability,update,updateImpl,27,/// See AbstractAttribute::updateImpl(...).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:3,Usability,Simpl,Simplify,3,// Simplify the operand first.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:88,Modifiability,evolve,evolves,88,"// Catch circular reasoning in a pessimistic way for now.; // TODO: Check how the range evolves and if we stripped anything, see also; // AADereferenceable or AAAlign for similar situations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:14,Performance,load,load,14,"// If it is a load instruction with range metadata, use the metadata.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:3,Safety,Avoid,Avoid,3,// Avoid recursion when the caller is computing constant values for this; // IRP itself.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:27,Deployability,update,updateImpl,27,/// See AbstractAttribute::updateImpl(...).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:27,Deployability,update,updateImpl,27,/// See AbstractAttribute::updateImpl(...).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:20,Usability,simpl,simplified,20,// A position whose simplified value does not have any value is; // considered to be dead. We don't manifest noundef in such positions for; // the same reason above.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:27,Deployability,update,updateImpl,27,/// See AbstractAttribute::updateImpl(...).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:12,Usability,simpl,simple,12,// The most simple case.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:27,Deployability,update,updateImpl,27,/// See AbstractAttribute::updateImpl(...).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:97,Usability,simpl,simplified,97,/// Helper struct to tie a value+context pair together with the scope for; /// which this is the simplified version.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:27,Deployability,update,updateImpl,27,/// See AbstractAttribute::updateImpl(...).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:3,Usability,Simpl,Simplify,3,// Simplify the operands first.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:17,Integrability,depend,depends,17,"// The new value depends on the predicate, true for != and false for ==.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:16,Usability,simpl,simplify,16,"// We could not simplify the condition, assume both values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:19,Performance,load,loads,19,// Do not simplify loads that are only used in llvm.assume if we cannot also; // remove all stores that may feed into the load. The reason is that the; // assume is probably worth something as long as the stores are around.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:122,Performance,load,load,122,// Do not simplify loads that are only used in llvm.assume if we cannot also; // remove all stores that may feed into the load. The reason is that the; // assume is probably worth something as long as the stores are around.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:10,Usability,simpl,simplify,10,// Do not simplify loads that are only used in llvm.assume if we cannot also; // remove all stores that may feed into the load. The reason is that the; // assume is probably worth something as long as the stores are around.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:41,Integrability,interface,interface,41,// We won't bother with the InstSimplify interface if we didn't simplify any; // operand ourselves.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:64,Usability,simpl,simplify,64,// We won't bother with the InstSimplify interface if we didn't simplify any; // operand ourselves.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:71,Integrability,depend,dependence,71,// If we actually used liveness information so we have to record a; // dependence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:27,Deployability,update,updateImpl,27,/// See AbstractAttribute::updateImpl(...).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:402,Deployability,update,updated,402,"/// Propagates assumption information from parent functions to all of their; /// successors. An assumption can be propagated if the containing function; /// dominates the called function.; ///; /// We start with a ""known"" set of assumptions already valid for the associated; /// function and an ""assumed"" set that initially contains all possible; /// assumptions. The assumed set is inter-procedurally updated by narrowing its; /// contents as concrete values are known. The concrete values are seeded by the; /// first nodes that are either entries into the call graph, or contains no; /// assumptions. Each node is updated as the intersection of the assumed state; /// with all of its predecessors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:617,Deployability,update,updated,617,"/// Propagates assumption information from parent functions to all of their; /// successors. An assumption can be propagated if the containing function; /// dominates the called function.; ///; /// We start with a ""known"" set of assumptions already valid for the associated; /// function and an ""assumed"" set that initially contains all possible; /// assumptions. The assumed set is inter-procedurally updated by narrowing its; /// contents as concrete values are known. The concrete values are seeded by the; /// first nodes that are either entries into the call graph, or contains no; /// assumptions. Each node is updated as the intersection of the assumed state; /// with all of its predecessors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:27,Deployability,update,updateImpl,27,/// See AbstractAttribute::updateImpl(...).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:27,Deployability,update,updateImpl,27,/// See AbstractAttribute::updateImpl(...).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:27,Deployability,update,updateImpl,27,/// See AbstractAttribute::updateImpl(...).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:31,Testability,log,logic,31,"// For now we only use special logic for call sites. However, the tracker; // itself knows about a lot of other non-capturing cases already.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:7,Usability,simpl,simplification,7,"// Use simplification to find potential callees, if !callees was present,; // fallback to that set if necessary.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:9,Usability,simpl,simplification,9,"// Check simplification result, prune known UB callees, also restrict it to; // the !callees set, if present.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:58,Usability,simpl,simply,58,// It doesn't matter if we can't check all uses as we can simply; // conservatively ignore those that can not be visited.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:18,Modifiability,rewrite,rewrite,18,// TODO: we don't rewrite function argument for now because it will need to; // rewrite the function signature and all call sites.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:80,Modifiability,rewrite,rewrite,80,// TODO: we don't rewrite function argument for now because it will need to; // rewrite the function signature and all call sites.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:18,Modifiability,rewrite,rewrite,18,// TODO: we don't rewrite call site argument for now because it will need to; // rewrite the function signature of the callee.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:81,Modifiability,rewrite,rewrite,81,// TODO: we don't rewrite call site argument for now because it will need to; // rewrite the function signature of the callee.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:9,Deployability,update,update,9,// TODO: update check for malloc like calls,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:62,Energy Efficiency,reduce,reduce,62,"// For zero sized allocations, we give up.; // Since we can't reduce further",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:9,Modifiability,refactor,refactor,9,// TODO: refactor this to be part of multiple bin case,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:18,Modifiability,rewrite,rewrite,18,// TODO: we don't rewrite function argument for now because it will need to; // rewrite the function signature and all call sites,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:80,Modifiability,rewrite,rewrite,80,// TODO: we don't rewrite function argument for now because it will need to; // rewrite the function signature and all call sites,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/BarrierNoopPass.cpp:408,Safety,AVOID,AVOIDABLE,408,"//===- BarrierNoopPass.cpp - A barrier pass for the pass manager ----------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // NOTE: DO NOT USE THIS IF AVOIDABLE; //; // This pass is a nonce pass intended to allow manipulation of the implicitly; // nesting pass manager. For example, it can be used to cause a CGSCC pass; // manager to be closed prior to running a new collection of function passes.; //; // FIXME: This is a huge HACK. This should be removed when the pass manager's; // nesting is made explicit instead of implicit.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/BarrierNoopPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/BarrierNoopPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/BarrierNoopPass.cpp:200,Usability,clear,clear,200,/// A nonce module pass used to place a barrier in a pass manager.; ///; /// There is no mechanism for ending a CGSCC pass manager once one is started.; /// This prevents extension points from having clear deterministic ordering; /// when they are phrased as non-module passes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/BarrierNoopPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/BarrierNoopPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/BlockExtractor.cpp:37,Safety,avoid,avoid,37,// Set linkage as ExternalLinkage to avoid erasing unreachable functions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/BlockExtractor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/BlockExtractor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/CalledValuePropagation.cpp:406,Modifiability,variab,variable,406,"/// To enable interprocedural analysis, we assign LLVM values to the following; /// groups. The register group represents SSA registers, the return group; /// represents the return values of functions, and the memory group represents; /// in-memory values. An LLVM Value can technically be in more than one group.; /// It's necessary to distinguish these groups so we can, for example, track a; /// global variable separately from the value stored at its location.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/CalledValuePropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/CalledValuePropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/CalledValuePropagation.cpp:95,Testability,test,testing,95,"/// Comparator for sorting the functions set. We want to keep the order; /// deterministic for testing, etc.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/CalledValuePropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/CalledValuePropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/CalledValuePropagation.cpp:378,Energy Efficiency,efficient,efficiently,378,"/// Holds functions indicating the possible targets of call sites. This set; /// is empty for lattice values in the undefined, overdefined, and untracked; /// states. The maximum size of the set is controlled by; /// MaxFunctionsPerValue. Since most LLVM values are expected to be in; /// uninteresting states (i.e., overdefined), CVPLatticeVal objects should be; /// small and efficiently copyable.; // FIXME: This could be a TinyPtrVector and/or merge with LatticeState.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/CalledValuePropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/CalledValuePropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/CalledValuePropagation.cpp:268,Modifiability,variab,variables,268,"/// The custom lattice function used by the generic sparse propagation solver.; /// It handles merging lattice values and computing new lattice values for; /// constants, arguments, values returned from trackable functions, and values; /// located in trackable global variables. It also computes the lattice values; /// that change as a result of executing instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/CalledValuePropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/CalledValuePropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/CalledValuePropagation.cpp:176,Usability,simpl,simply,176,"/// Merge the two given lattice values. The interesting cases are merging two; /// FunctionSet values and a FunctionSet value with an Undefined value. For; /// these cases, we simply union the function sets. If the size of the union; /// is greater than the maximum functions we track, the merged value is; /// overdefined.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/CalledValuePropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/CalledValuePropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/CalledValuePropagation.cpp:167,Performance,optimiz,optimization,167,"/// Compute a new lattice value for the given constant. The constant, after; /// stripping any pointer casts, should be a Function. We ignore null; /// pointers as an optimization, since calling these values is undefined; /// behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/CalledValuePropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/CalledValuePropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/CalledValuePropagation.cpp:38,Deployability,update,update,38,"// Void return, No need to create and update CVPLattice state as no one; // can use it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/CalledValuePropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/CalledValuePropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/CalledValuePropagation.cpp:65,Performance,perform,perform,65,"// Inform the solver that the called function is executable, and perform; // the merges for the arguments and return value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/CalledValuePropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/CalledValuePropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/CalledValuePropagation.cpp:38,Deployability,update,update,38,"// Void return, No need to create and update CVPLattice state as no one can; // use it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/CalledValuePropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/CalledValuePropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/CalledValuePropagation.cpp:82,Modifiability,variab,variable,82,"/// Handle load instructions. If the pointer operand of the load is a global; /// variable, we attempt to track the value. The loaded value state is the; /// merge of the loaded value state with the global variable state.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/CalledValuePropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/CalledValuePropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/CalledValuePropagation.cpp:206,Modifiability,variab,variable,206,"/// Handle load instructions. If the pointer operand of the load is a global; /// variable, we attempt to track the value. The loaded value state is the; /// merge of the loaded value state with the global variable state.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/CalledValuePropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/CalledValuePropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/CalledValuePropagation.cpp:11,Performance,load,load,11,"/// Handle load instructions. If the pointer operand of the load is a global; /// variable, we attempt to track the value. The loaded value state is the; /// merge of the loaded value state with the global variable state.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/CalledValuePropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/CalledValuePropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/CalledValuePropagation.cpp:60,Performance,load,load,60,"/// Handle load instructions. If the pointer operand of the load is a global; /// variable, we attempt to track the value. The loaded value state is the; /// merge of the loaded value state with the global variable state.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/CalledValuePropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/CalledValuePropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/CalledValuePropagation.cpp:127,Performance,load,loaded,127,"/// Handle load instructions. If the pointer operand of the load is a global; /// variable, we attempt to track the value. The loaded value state is the; /// merge of the loaded value state with the global variable state.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/CalledValuePropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/CalledValuePropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/CalledValuePropagation.cpp:171,Performance,load,loaded,171,"/// Handle load instructions. If the pointer operand of the load is a global; /// variable, we attempt to track the value. The loaded value state is the; /// merge of the loaded value state with the global variable state.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/CalledValuePropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/CalledValuePropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/CalledValuePropagation.cpp:84,Modifiability,variab,variable,84,"/// Handle store instructions. If the pointer operand of the store is a; /// global variable, we attempt to track the value. The global variable state; /// is the merge of the stored value state with the global variable state.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/CalledValuePropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/CalledValuePropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/CalledValuePropagation.cpp:136,Modifiability,variab,variable,136,"/// Handle store instructions. If the pointer operand of the store is a; /// global variable, we attempt to track the value. The global variable state; /// is the merge of the stored value state with the global variable state.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/CalledValuePropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/CalledValuePropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/CalledValuePropagation.cpp:211,Modifiability,variab,variable,211,"/// Handle store instructions. If the pointer operand of the store is a; /// global variable, we attempt to track the value. The global variable state; /// is the merge of the stored value state with the global variable state.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/CalledValuePropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/CalledValuePropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/CalledValuePropagation.cpp:3,Usability,Simpl,Simply,3,// Simply bail if this instruction has no user.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/CalledValuePropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/CalledValuePropagation.cpp
